<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The YSLib Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Book tranplanted from YSLib BitBucket wiki.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The YSLib Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="english-version"><a class="header" href="#english-version"><a href="Home.en-US.html">English Version</a></a></h1>
<h1 id="简体中文版"><a class="header" href="#简体中文版"><a href="Home.zh-CN.html">简体中文版</a></a></h1>
<h1 id="contentszh-cn主题目录"><a class="header" href="#contentszh-cn主题目录"><a href="Contents.zh-CN.html">Contents(zh-CN)/主题目录</a></a></h1>
<h1 id="copyright-of-this-wiki"><a class="header" href="#copyright-of-this-wiki">Copyright of this wiki</a></h1>
<p>© 2013-2024 <a href="mailto:frankhb1989@gmail.com">FrankHB</a> and wiki editors.</p>
<p>Except where otherwise specified explicitly, materials in this repository are licensed under following terms:</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" alt="https://creativecommons.org/licenses/by-sa/4.0/" title="license" /></a></p>
<p>This work is licensed under a <a href="https://creativecommons.org/licenses/by-sa/4.0/" title="CC-BY-SA 4.0">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="about"><a class="header" href="#about">About</a></h1>
<p>The YSLib Project is a project of platform-neutral framework consists of several multi-licensed open source libraries. It is aiming to develop native applications in a naturally cross-platform manner.</p>
<p>See LICENSE.TXT in the source directory for licensing affairs.</p>
<p>The main part (except libraries not being maintained in this project) of the libraries is coded in C++, which is strictly conforming to ISO/IEC 14882. (For features being used, see <a href="StandardUsing.en-US.html">here</a>. For some issues concerned with this project, see <a href="ReportedIssues.en-US.html">here</a>.)</p>
<p>The project is currently in <a href="Releases.zh-CN.html">Alpha state(zh-CN)</a> with following interface compatibility strategies:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a> compatibility for any revision depending on specific platform, toolchain or build configuration is never guaranteed.</li>
<li>ABI compatibility may not be retained between releases with same platform, toolchain and build configuration.</li>
<li><a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> of libraries may be modified locally and there is no guarantee for compatibility between releases.</li>
<li><a href="https://en.wikipedia.org/wiki/User_interface">UI</a> of tools (see <a href="Contents.zh-CN.html">contents(zh-CN)</a> for the list) may be modified progressively across builds; unless specified elsewhere, added features are kept being <a href="https://en.wikipedia.org/wiki/Backward_compatibility">backward compatible</a> within at least one next releases.</li>
</ul>
<p>See <a href="GettingStarted.zh-CN.html">here(zh-CN)</a> for basic steps to use YSLib in development.</p>
<p>See <a href="Releases.zh-CN.html">here(zh-CN)</a> for releases and plans.</p>
<h2 id="currently-supported-platforms"><a class="header" href="#currently-supported-platforms">Currently supported platforms</a></h2>
<ul>
<li>(<a href="https://en.wikipedia.org/wiki/Nintendo">Nintendo</a>/<a href="https://en.wikipedia.org/wiki/IQue">iQue</a>) <a href="https://en.wikipedia.org/wiki/Nintendo_DS_line#Nintendo_DS_family">DS</a> (arm-none-eabi)
<ul>
<li>using <a href="DeSmuME.en-US.html">DeSmuME</a> to run on PC</li>
</ul>
</li>
<li>MinGW32 (i686-w64-mingw32, compatible with i686-pc-mingw32)</li>
</ul>
<h2 id="pending-supported-platform"><a class="header" href="#pending-supported-platform">Pending supported platform</a></h2>
<ul>
<li>Android (arm-linux-androideabi)</li>
<li>MinGW64 (x86_64-w64-mingw32)</li>
<li>Linux32 (i686-linux-gnu)</li>
<li>Linux64 (x86_64-linux-gnu)</li>
</ul>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<h3 id="documentation-in-the-yslib-project"><a class="header" href="#documentation-in-the-yslib-project">Documentation in the YSLib project</a></h3>
<p>Documentation in the YSLib project consist of several parts:</p>
<ul>
<li>The development documentation which is intended for the project maintainers, see <a href="Development.zh-CN.html">development(zh-CN)</a>.
<ul>
<li>The document in <code>doc/vsd</code> can be viewed by Microsoft Office Visio or Microsoft Visual Studio 2013.</li>
</ul>
</li>
<li>Souce code documentation, which can be generated using Doxygen, see <a href="BuildDocumentation.zh-CN.html">building documentation(zh-CN)</a>.
<ul>
<li>Currently the Doxygen commands in the source code are mainly coded in simplified Chinese. It is planned to utilize Doxygen's <code>~[LanguageId]</code> command to generate multilingual documents in future. All other comments, however, should be in English by default.</li>
</ul>
</li>
<li>Other non-generated documents are text files in the repository, like <code>Readme.zh-CN.txt</code>.</li>
</ul>
<h3 id="about-this-wiki"><a class="header" href="#about-this-wiki">About this wiki</a></h3>
<p>This wiki is a project related to the YSLib project. They are currently the only two members in the same project group, each has separated repository. Common documentation for the project group, general user documentation and list of significant features for the YSLib project are dominated by this wiki. Documentation in the YSLib project is mainly for maintainers of the project. They are bidirectionally referenced, namely the content of this wiki may be refenenced in the YSLib project and vice versa.</p>
<p>Unless otherwise specified, the content of this wiki is fit for the current last master branch revision (i.e. the revision <code>tip</code> of <code>master</code> branch in the repository).</p>
<p>See <a href="WikiRules.en-US.html">here</a> for rules to edit this wiki.</p>
<p>It is intended to reference every pages of this wiki in this page.</p>
<h1 id="contributions"><a class="header" href="#contributions">Contributions</a></h1>
<p>Contributions to the projects are welcomed. Provided materials thereby shall be adjusted by contributors (and the project maintainer) to conform the license of the corresponding projects if necessary.</p>
<p><strong>Rules in this wiki are treated as consensus.</strong> Rules in project documentation have effect on maintainers but not other contributors. However, the contents in the projects shall always be conforming to the project rules.</p>
<p>To feedback or report issues, <del>use <a href="https://bitbucket.org/FrankHB/yslib/issues/">Bitbucket issue tracker</a>, or</del> contact the project maintainer as noted below.</p>
<p><strong>NOTE</strong> The Bitbucket project <a href="https://bitbucket.org/blog/sunsetting-mercurial-support-in-bitbucket">is no longer available</a>. The project is archived <a href="https://bitbucket-archive.softwareheritage.org/projects/fr/FrankHB/yslib.html">here</a>.</p>
<h2 id="rules-for-project-contents"><a class="header" href="#rules-for-project-contents">Rules for project contents</a></h2>
<p>The following philosophy are generally accommodated throughout the projects.</p>
<ul>
<li>
<p><strong>Do not <a href="https://en.wikipedia.org/wiki/Reinventing_the_wheel">reinvent the wheel</a>.</strong> Projects here only accepts modular components which would be better elsewhere. Here "better" is defined as "superior than current solution in at least one aspect for consensually known need".</p>
<ul>
<li>See the notes in <a href="Features.zh-CN.html">features(zh-CN)</a> for the list of invented wheels and the rationale.</li>
</ul>
</li>
<li>
<p><strong>Decline premature optimization.</strong> However, what is "premature" is determined by the need, which would be probably variable.</p>
</li>
</ul>
<h1 id="contacts"><a class="header" href="#contacts">Contacts</a></h1>
<ul>
<li>Mail to: <a href="mailto:frankhb1989@gmail.com">frankhb1989@gmail.com</a></li>
<li>Post <a href="http://tieba.baidu.com/f?kw=%BB%C3%A4%CE%C9%CF%B5%DB">here</a> (mainly zh-CN)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概要"><a class="header" href="#概要">概要</a></h1>
<p>　　YSLib 项目是一个提供多个开源库组成的平台中立框架的项目，主要致力于以自然的方式开发跨平台本机应用。</p>
<p>　　使用的许可证见源代码目录中的 LICENSE.TXT 。</p>
<p>　　主要部分（非此项目维护的库除外）使用 C++ 编码，严格符合 ISO/IEC 14882 。（使用的 ISO 特性参见<a href="StandardUsing.en-US.html">这里(en-US)</a> 。和本项目相关的被报告的问题见<a href="ReportedIssues.en-US.html">这里(en-US)</a> 。）</p>
<p>　　项目当前为 <a href="Releases.zh-CN.html">Alpha 状态</a>，具有以下接口兼容性策略：</p>
<ul>
<li>任意版本不保证依赖特定平台、工具链或构建配置的 <a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a> 兼容性。</li>
<li>同一平台、工具链和构建配置的发布版本之间的 ABI 可能不兼容。</li>
<li>库的 <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> 设计在局部调整而不保证在发布版本之间兼容。</li>
<li>工具（列表参见<a href="Contents.zh-CN.html">目录</a>）的 <a href="https://en.wikipedia.org/wiki/User_interface">UI</a> 可能会在构建中渐进修改；除非另行指定，添加的特性在之后的至少一个发布版本中保持<a href="https://en.wikipedia.org/wiki/Backward_compatibility">向后兼容</a>。</li>
</ul>
<p>　　关于使用 YSLib 开发的基本步骤，参见<a href="GettingStarted.zh-CN.html">入门</a>。</p>
<p>　　目前已发布版本、进展和计划看<a href="Releases.zh-CN.html">这里</a>。</p>
<h2 id="当前支持平台"><a class="header" href="#当前支持平台">当前支持平台</a></h2>
<ul>
<li>(<a href="https://zh.wikipedia.org/zh-cn/%E4%BB%BB%E5%A4%A9%E5%A0%82">Nintendo</a>/<a href="https://zh.wikipedia.org/zh-cn/%E7%A5%9E%E6%B8%B8%E7%A7%91%E6%8A%80">iQue</a>) <a href="https://zh.wikipedia.org/zh-cn/%E4%BB%BB%E5%A4%A9%E5%A0%82DS%E5%AE%B6%E6%97%8F#.E4.BB.BB.E5.A4.A9.E5.A0.82DS.E5.AE.B6.E6.97.8F">DS</a> (arm-none-eabi)
<ul>
<li>在 PC 上使用<a href="DeSmuME.en-US.html">DeSmuME(en-US)</a> 运行</li>
</ul>
</li>
<li>MinGW32 (i686-w64-mingw32, compatible with i686-pc-mingw32)</li>
</ul>
<h2 id="待定支持平台"><a class="header" href="#待定支持平台">待定支持平台</a></h2>
<ul>
<li>Android (arm-linux-androideabi)</li>
<li>MinGW64 (x86_64-w64-mingw32)</li>
<li>Linux32 (i686-linux-gnu)</li>
<li>Linux64 (x86_64-linux-gnu)</li>
</ul>
<h2 id="文档"><a class="header" href="#文档">文档</a></h2>
<h3 id="yslib-项目中的文档"><a class="header" href="#yslib-项目中的文档">YSLib 项目中的文档</a></h3>
<p>　　YSLib 项目中的文档主要包括以下几个部分：</p>
<ul>
<li>主要供项目维护者参考的开发文档，详见<a href="Development.zh-CN.html">开发说明</a>。
<ul>
<li>目录 <code>doc/vsd</code> 下的文档可使用 Microsoft Office Visio 或 Microsoft Visual Studio 2013 查看。</li>
</ul>
</li>
<li>源代码文档，可使用 Doxygen 生成，参见<a href="BuildDocumentation.zh-CN.html">构建文档</a>。
<ul>
<li>当前源代码中的 Doxygen 命令主要编码为简体中文。未来计划使用 Doxygen 的 <code>~[LanguageId]</code> 命令生成多种语言的文档。其它注释主要使用英文。</li>
</ul>
</li>
<li>其它非生成的文本文件，如 <code>Readme.zh-CN.txt</code> 。</li>
</ul>
<h3 id="关于本-wiki"><a class="header" href="#关于本-wiki">关于本 wiki</a></h3>
<p>　　本 wiki 是和 YSLib 项目关联的项目。本 wiki 和 YSLib 项目组成了同一个项目组当前仅有的两个成员，每个项目都有单独的版本库。项目组的公共文档、YSLib 的一般用户文档和重要特性列表主要由本 wiki 提供。YSLib 项目中的文档主要面向项目的维护者。两者的文档构成双向引用，即 YSLib 项目可能引用本 wiki 的内容，反之亦然。</p>
<p>　　除非另行指定，本 wiki 的内容适合当前最新的主分支版本（即版本库 <code>master</code> 分支标识为 <code>tip</code> 的版本）。</p>
<p>　　编辑本 wiki 的规则参见<a href="WikiRules.en-US.html">这里(en-US)</a> 。</p>
<p>　　本页面有意引用所有本 wiki 的所有页面。</p>
<h1 id="贡献"><a class="header" href="#贡献">贡献</a></h1>
<p>　　对项目的贡献受到欢迎。由此提供的材料应在必要时由贡献者（及项目维护者）调整，以符合相应项目的许可证。</p>
<p>　　<strong>这个 wiki 规则被视为共识。</strong> 在项目文档内部的规则对维护者而不是其他贡献者有效。但是，项目中的内容应符合项目规则。</p>
<p>　　要反馈或报告问题，<del>使用 <a href="https://bitbucket.org/FrankHB/yslib/issues/">Bitbucket 问题跟踪系统</a>，或</del>按如下方式联系项目维护者。</p>
<p><strong>注释</strong> Bitbucket 项目已<a href="https://bitbucket.org/blog/sunsetting-mercurial-support-in-bitbucket">不再可用</a>。项目归档在<a href="https://bitbucket-archive.softwareheritage.org/projects/fr/FrankHB/yslib.html">此处</a>。</p>
<h2 id="项目内容规则"><a class="header" href="#项目内容规则">项目内容规则</a></h2>
<p>　　下列指导原则一般地适用于所有项目。</p>
<ul>
<li><strong>不<a href="https://zh.wikipedia.org/zh-cn/%E9%87%8D%E9%80%A0%E8%BD%AE%E5%AD%90">重复发明轮子</a>。</strong> 这里的项目只接受比别处更好的模块化组件。此处“更好”定义为“在至少一个方面比现有解决方案更有效地满足一致同意的已知需求”。
<ul>
<li>参见<a href="Features.zh-CN.html">特性</a>注记的轮子列表和原理。</li>
</ul>
</li>
<li><strong>拒绝不成熟的优化。</strong> 然而，何谓“不成熟”由需求决定，这很可能变化。</li>
</ul>
<h1 id="联系方式"><a class="header" href="#联系方式">联系方式</a></h1>
<ul>
<li>发邮件到<a href="mailto:frankhb1989@gmail.com">frankhb1989@gmail.com</a></li>
<li>在<a href="http://tieba.baidu.com/f?kw=%BB%C3%A4%CE%C9%CF%B5%DB">贴吧</a>发贴/Post <a href="http://tieba.baidu.com/f?kw=%BB%C3%A4%CE%C9%CF%B5%DB">here</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="主题目录"><a class="header" href="#主题目录">主题目录</a></h1>
<ul>
<li><a href="GettingStarted.zh-CN.html">入门</a></li>
<li><a href="Development.zh-CN.html">开发说明</a>
<ul>
<li><a href="Prerequisitions.zh-CN.html">先决条件</a></li>
<li><a href="GettingSources.zh-CN.html">获取源代码</a>（另见项目维护资源）</li>
<li><a href="Build.zh-CN.html">构建</a>
<ul>
<li><a href="BuildDocumentation.zh-CN.html">构建文档</a></li>
</ul>
</li>
<li><a href="Test.zh-CN.html">测试</a></li>
<li><a href="Run.zh-CN.html">运行</a></li>
</ul>
</li>
<li><a href="Features.zh-CN.html">结构和特性</a>
<ul>
<li><a href="ProjectDependencies.zh-CN.html">（内部）项目依赖性</a>说明</li>
<li><a href="Features/NPL.zh-CN.html">NPL</a></li>
</ul>
</li>
<li>应用开发环境
<ul>
<li><a href="Sysroot.zh-CN.html">Sysroot</a></li>
<li><a href="YDE.zh-CN.html">YDE</a></li>
</ul>
</li>
<li>项目维护资源
<ul>
<li><a href="Releases.zh-CN.html">发布工程</a>：规则、版本清单和路线图等</li>
<li><a href="Archives.zh-CN.html">归档</a>：发布的历史资源</li>
<li>以下工具中部分用于项目维护</li>
</ul>
</li>
<li>工具
<ul>
<li><a href="Tools/SHBuild.zh-CN.html">SHBuild</a></li>
<li><a href="Tools/RevisionPatcher.zh-CN.html">RevisionPatcher</a></li>
<li><a href="Tools/SXML2XML.zh-CN.html">SXML2XML</a></li>
<li><a href="Tools/ProjectGenerator.zh-CN.html">ProjectGenerator</a></li>
<li><a href="Tools/Scripts.zh-CN.html">脚本</a></li>
</ul>
</li>
<li><a href="Tutorial.zh-CN.html">教程</a></li>
<li><a href="Terminology.zh-CN.html">术语概要</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="导航"><a class="header" href="#导航">导航</a></h1>
<p>　　<a href="Home.zh-CN.html">YSLib 是什么？</a></p>
<p>　　返回<a href="Contents.zh-CN.html">目录</a>查看其它内容。</p>
<h1 id="目标读者"><a class="header" href="#目标读者">目标读者</a></h1>
<p>　　本文预期的读者是对了解如何使用 YSLib 创建项目感兴趣的<strong>开发者</strong>。</p>
<h2 id="基础知识"><a class="header" href="#基础知识">基础知识</a></h2>
<p>　　本文假定读者已经掌握或了解以下知识，不详细展开讨论：</p>
<ul>
<li>计算机体系结构常识。</li>
<li>了解如何运行命令行程序和配置环境变量。</li>
<li>了解规范 C++ 语言的标准（ISO/IEC 14882）。</li>
<li>了解什么是语言的实现（如编译器和链接器等）并掌握常见实现的使用方法（如 G++ 命令行）。</li>
<li>有必要时，能避免依赖只在特定实现支持的方言特性。</li>
</ul>
<h1 id="概要-1"><a class="header" href="#概要-1">概要</a></h1>
<p>　　本文档说明开发 YSLib 程序的简易操作。以下仅提供操作步骤和主要意义的解释。</p>
<p><strong>注意</strong> 若需自行定制构建，参照以下引用的文档的全文，而非某个特定章节；再按照<a href="Build.zh-CN.html">构建</a>中的步骤执行。</p>
<p>　　以下只提供关于部分<a href="Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">宿主实现</a>的环境配置：</p>
<ul>
<li>Windows ：基于 MSYS2 环境。</li>
<li>Linux 。</li>
</ul>
<h1 id="环境配置"><a class="header" href="#环境配置">环境配置</a></h1>
<p>　　使用 YSLib 开发需要配置 YSLib 环境，以确保 YSLib 的库和相关环境可用。</p>
<p>　　当前建议直接在本机环境中从源代码构建安装 YSLib ，参照以下步骤和要点：</p>
<ul>
<li>参照<a href="Prerequisitions.zh-CN.html#pcwin32">先决条件的 <strong>PC(MinGW32)</strong> 一节</a> 给出的链接下载 MSYS2 并配置环境，执行脚本安装所需的工具。
<ul>
<li><strong>注释</strong> 若不需要构建 GUI 应用程序，也可以参照<a href="Prerequisitions.zh-CN.html#pclinux">先决条件的 <strong>PC/Linux</strong> 一节</a>，在 Linux 环境下本机构建。</li>
</ul>
</li>
<li><a href="GettingSources.zh-CN.html">获取源代码</a>。
<ul>
<li><strong>注意</strong> 若直接从版本库获取，直接构建可能找不到<a href="ProjectDependencies.zh-CN.html#%E5%A4%96%E9%83%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%BA%93">库</a>而在链接时失败。可以选取以下方式之一：
<ul>
<li><a href="Sysroot.zh-CN.html#%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96%E9%A1%B9">设置环境变量 <code>YSLib_DistDir</code></a>在以下的安装脚本中自动处理。</li>
<li><a href="Archives.zh-CN.html">从归档仓库下载</a>二进制文件放置到指定的库文件路径中，详见<a href="Development.zh-CN.html">开发说明</a>。</li>
<li>自行参照文档构建缺少的<a href="ProjectDependencies.zh-CN#%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96%E9%A1%B9">二进制库外部依赖项</a>。</li>
</ul>
</li>
<li>文件不包含 POSIX 权限。若需在依赖文件权限的环境（包括典型的 Linux 环境）中直接运行 shell 脚本，需确保（可能被间接调用的）脚本文件可执行，如运行 <code>find Tools -type f -name "*.sh" -exec chmod +x {} \;</code> 。</li>
</ul>
</li>
<li>参照 <a href="Sysroot.zh-CN.html">Sysroot</a> ，运行 <code>Tools/install-sysroot.sh</code> 脚本以构建 YSLib 并安装头所需的文件，得到 Sysroot 环境。然后，把 <code>sysroot/usr/bin</code> 目录的完整路径加入 <code>PATH</code> 环境变量（一般应添加在最前端）。
<ul>
<li><strong>注意</strong> 除非了解确切的作用，不要添加 YSLib 中的其它目录到 <code>PATH</code> ；添加不合适的目录可能会导致脚本运行失败。</li>
</ul>
</li>
</ul>
<p><strong>注释</strong> 以上是对新手的建议步骤。为了避免在之后的步骤中出现需要回溯解决的问题，这些步骤务求详尽。若已了解构建环境配置或为自动化部署，通常总是可以使用一行脚本在受支持的环境中直接构建 Sysroot 。</p>
<h1 id="开发基础"><a class="header" href="#开发基础">开发基础</a></h1>
<p>　　以下介绍使用 YSLib 开发须知的基础要点，并说明如何开发示例程序。</p>
<h2 id="控制台程序和图形用户界面gui-程序"><a class="header" href="#控制台程序和图形用户界面gui-程序">控制台程序和图形用户界面(GUI) 程序</a></h2>
<p>　　需要注意，在 Windows 中控制台程序仍然可以包含 GUI 。</p>
<p>　　YSLib 支持各种用户应用程序。为了简便起见，以下只介绍 GUI 程序的使用。更具体的说明参见 <a href="Prerequisitions.zh-CN.html">Windows 子系统</a>。</p>
<h2 id="编写-hello-world-程序"><a class="header" href="#编写-hello-world-程序">编写 Hello World 程序</a></h2>
<p>　　新建 C++ 源文件（名称任意，但需要<a href="Tools/SHBuild.zh-CN.html#markdown-header-_1">以 <code>.cpp</code> 等作为扩展名以保证 SHBuild 作为 C++ 源文件处理</a>），内容如下：</p>
<pre><code class="language-cpp">#include &lt;YSBuild.h&gt;
#include YFM_Helper_GUIApplication
#include YFM_YSLib_UI_Label
#include YFM_Helper_HostedUI

int
main()
{
	using namespace YSLib;
	GUIApplication app;
	UI::Label wgt({480, 360, 160, 24});

	wgt.Text = u"Hello world!";
	Host::ShowTopLevel(wgt, WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX, 0);
	Execute(app);
}
</code></pre>
<h3 id="关于头文件"><a class="header" href="#关于头文件">关于头文件</a></h3>
<p>　　可以安全地重复包含头文件。</p>
<p>　　注意到 <code>#include</code> 后可以是一个宏。这里表示路径的宏 <code>YFM_*</code> 由 <code>&lt;YSBuild.h&gt;</code> 保证定义，因此这个头文件需要在使用这些宏之前被包含。</p>
<p>　　使用宏表示 YFramework 的大多数头文件名是兼容性的需要。用户程序不需要使用这种策略，尤其是集成开发环境可能会对这样引入的头文件的修改不敏感而导致的构建遗漏。</p>
<p>　　MinGW32 平台的 Helper::HostedUI 的头文件已经保证包含了 <code>&lt;Windows.h&gt;</code> 中宿主窗口的声明，不需要显式包含。</p>
<h2 id="使用-shbuild-buildapp-脚本构建程序"><a class="header" href="#使用-shbuild-buildapp-脚本构建程序">使用 SHBuild-BuildApp 脚本构建程序</a></h2>
<p>　　把上面的文件保存到<strong>一个空的目录</strong>下，以下以 <code>$SRC</code> 指定这个目录名。</p>
<p>　　执行以下命令：</p>
<pre><code class="language-shell">bash -c "cd $SRC; SHBuild-BuildPkg.sh release ."
</code></pre>
<p>　　在目录 <code>$SRC/.release</code> 下找到构建好的可执行文件（具体文件名取决于源文件名），执行观察结果。</p>
<h3 id="说明"><a class="header" href="#说明">说明</a></h3>
<p>　　<code>bash -c</code> 启动新的 shell 执行命令。</p>
<p>　　<code>cd $SRC</code> 切换 shell 的当前工作目录到源代码目录。</p>
<p>　　<code>SHBuild-BuildPkg.sh</code> 调用构建脚本。脚本的参数分别是：</p>
<ul>
<li><code>release</code> 是一个配置名称。配置名称决定保存生成的文件的输出目录相对当前工作目录的位置，这里输出目录是当前工作目录下的 <code>.release</code> 子目录。可以更换配置名称以指定不同的输出目录。
　　* 若配置名称以 <code>debug</code> 起始，启用调试配置，自动使用调试库和构建选项。</li>
<li><code>.</code> 表示构建的目录源代码的根目录为当前工作目录。</li>
<li>之后的可选参数在此省略。</li>
</ul>
<p>　　构建脚本以特定的选项调用 <a href="Tools/SHBuild.zh-CN.html">SHBuild</a> 工具作为脚本解释器执行 NPLA1 脚本 <code>SHBuild-BuildApp.txt</code> ，详见 <a href="Sysroot.zh-CN.html">Sysroot</a> 。</p>
<p>　　<code>SHBuild-BuildApp.txt</code> 内部再次调用 SHBuild 工具进行构建。默认会递归扫描整个目录（除了名称以 <code>.</code> 起始的子目录外）。若存在多个源文件，这些文件都会被一起编译并链接。为了避免预期以外的结果，之前要求源文件在空目录中。</p>
<h3 id="其它方法"><a class="header" href="#其它方法">其它方法</a></h3>
<p>　　也可以直接调用 <code>SHBuild</code> 或者编译器命令行，但需要手动指定调用编译器的参数以及链接的库等，较为复杂，在此从略。</p>
<h3 id="清理"><a class="header" href="#清理">清理</a></h3>
<p>　　无论是 <code>SHBuild</code> 还是 <code>SHBuild-BuildPkg.sh</code> 当前都不提供清理功能。因为包括中间文件的输出文件都在同一个输出目录中，直接删除输出的目录即可。</p>
<h1 id="进一步阅读"><a class="header" href="#进一步阅读">进一步阅读</a></h1>
<p>　　参见<a href="Development.zh-CN.html">开发说明</a>的相应章节和进阶的<a href="Tutorial.zh-CN.html">教程</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开发说明"><a class="header" href="#开发说明">开发说明</a></h1>
<p>　　关于环境配置，详见<a href="Prerequisitions.zh-CN.html">先决条件</a>和<a href="Run.zh-CN.html">运行</a>。其中后者也包含部分面向最终用户的说明。</p>
<p>　　以下为面向开发者的说明。</p>
<h1 id="准备"><a class="header" href="#准备">准备</a></h1>
<ul>
<li>了解<a href="Prerequisitions.zh-CN.html">先决条件</a></li>
<li><a href="GettingSources.zh-CN.html">获取源代码</a></li>
<li>了解<a href="ProjectDependencies.zh-CN.html">项目依赖性</a>以确保源代码以外的必要的<a href="Terminology.zh-CN.html#%E5%86%85%E9%83%A8%E4%BE%9D%E8%B5%96%E5%92%8C%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96">外部依赖</a>可用</li>
<li>了解<a href="Terminology.zh-CN.html">术语概要</a>的体例以备参考</li>
</ul>
<p>　　YSLib 项目文档位于 YSLib 项目而不是本 wiki 项目中：</p>
<ul>
<li>维护者参考的细节和一般规则详见 YSLib 项目文档 <code>doc/ProjectRules.txt</code> 。</li>
<li>在 <a href="Terminology.zh-CN.html">本 wiki 项目文档约定的术语</a>的基础上，其它术语的完整定义详见 YSLib 项目文档 <code>doc/CommonRules.txt</code> 。</li>
<li>在 <a href="Features/NPL.zh-CN.html">本 wiki 的预定的 NPL 规范文档</a>的基础上，具体实现参见 YSLib 项目文档 <code>doc/NPL.txt</code> 。</li>
</ul>
<p><strong>注释</strong> 项目文件在 YSLib <a href="Terminology.zh-CN.html#%E7%89%88%E6%9C%AC%E5%BA%93">存储库</a>中维护。</p>
<h1 id="项目过程"><a class="header" href="#项目过程">项目过程</a></h1>
<p>　　基本规则参见 YSLib 项目文档 <code>doc/ProjectRules.txt</code> 。</p>
<p>　　本 wiki 项目作为用户手册和开发者补充文档的形式作为实现及之后阶段输出。</p>
<p>　　实现的附加输出为库和工具。</p>
<p>　　之前阶段（如设计）为前期过程，其文档和适用于维护过程的项目规则位于 YSLib 的项目文档中的 <code>doc/</code> 目录。其中整体过程由 <code>doc/Designation.txt</code> 指定。当前内联设计以外的过程，因此不存在设计外前期过程的单独文档。</p>
<h1 id="开发"><a class="header" href="#开发">开发</a></h1>
<ul>
<li><a href="Build.zh-CN.html">构建</a>
<ul>
<li><a href="BuildDocumentation.zh-CN.html">构建文档</a></li>
</ul>
</li>
<li><a href="Run.zh-CN.html">运行</a></li>
<li>使用 <a href="Sysroot.zh-CN.html">Sysroot</a> 开发和部署程序</li>
</ul>
<h1 id="平台"><a class="header" href="#平台">平台</a></h1>
<p>　　关于<strong>外部依赖</strong>、<strong>平台</strong>、<strong>目标平台</strong>和<strong>宿主平台</strong>等概念的一般定义参见<a href="Terminology.zh-CN.html#%E5%B9%B3%E5%8F%B0">术语概要</a>。</p>
<p>　　YSLib 项目约定一个体系结构和使用的外部依赖是一个平台。</p>
<p><strong>注释</strong> 这仍然满足<a href="Terminology.zh-CN.html#%E5%B9%B3%E5%8F%B0%E6%A0%87%E8%AF%86">关于平台标识默认的使用约定</a>。</p>
<p>　　YSLib 支持不同的目标平台。类似 ISO C/C++ 的独立实现(freestanding implementation) 和宿主实现(hosted implementation) ，平台分为两类：<strong>独立实现平台</strong>和<strong>宿主实现平台</strong>。后者存在操作系统的支持而前者没有。</p>
<h2 id="语言使用和实现要求"><a class="header" href="#语言使用和实现要求">语言使用和实现要求</a></h2>
<p>　　本节适用于 YSLib 项目，不直接限制依赖项和用户程序。项目中特定部分的规则及适用性详见 YSLib 项目文档 <code>doc/ProjectRules.txt</code> 。</p>
<p>　　本节不保证所有具体要求都是完备的。特别地，这里不指定仅具体平台配置适用的要求。对一般开发者，<a href="Prerequisitions.zh-CN.html">先决条件</a>中应已足够配置开发环境。</p>
<p><strong>原理</strong> 本节中的要求和配置补充<a href="Prerequisitions.zh-CN.html">先决条件</a>，和开发环境的选型可能直接相关，为维护者提供设定平台配置要求提供基准依据。</p>
<p>　　除脚本（见以下相关章节）外，使用 ISO C++ 作为主要开发语言。</p>
<p>　　不使用和 ISO C++03 以后被接受的特性不兼容的特性，包括但不限于：</p>
<ul>
<li>被取消的特性，如 ISO C++03 后导出模板的 <code>export</code> 关键字。
<ul>
<li>不限制有条件使用的之后的其它特性，如 <code>export</code> 被作为模块。（当前不使用模块。）</li>
</ul>
</li>
<li>在 ISO C++03 中标记为 deprecated 而在之后版本去除的特性，如 <code>const char</code> 数组类型左值到 <code>char*</code> 右值的转换。</li>
<li>在 ISO C++03 中标记为 deprecated 但在之后版本重新取消 deprecated 的特性，如修饰命名空间作用域声明的 <code>static</code> 。</li>
<li>实现的 Defect Report ，如 <a href="http://wg21.cmeerw.net/cwg/issue615">CWG 615</a> 。</li>
<li>显式排除的特定的语言特性：
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r3.pdf">P0145R3</a> ：ISO C++17 指定的特定表达式的求值顺序。
<ul>
<li><strong>注释</strong> 使用 <a href="https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Dialect-Options.html">G++ 的 <code>-fno-strong-eval-order</code> 选项</a>可显式指定假定避免依赖这项特性。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　注意即使使用特定模式，一些实现也可能引入之后的 Defect Report 而不保证兼容，如 <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65890">GCC PR 65890</a> 。</p>
<p>　　关于精确的特性使用规则、具体使用及备选的特性的清单等，详见<a href="StandardUsing.en-US.html">标准使用（英文）</a> 。</p>
<p>　　以下对语言实现的要求和支持情况适用整个项目。具体内容可能会在未来变动。</p>
<h3 id="基准实现要求"><a class="header" href="#基准实现要求">基准实现要求</a></h3>
<p>　　YSLib 依赖 ISO C++ 独立实现或宿主实现，附加以下要求：</p>
<ul>
<li>满足<a href="StandardUsing.en-US.html">标准使用(en-US)</a> 中具体特性的要求。
<ul>
<li><strong>注释</strong> 默认基于 ISO C++11 环境，但并不要求实现完整支持所有特性。</li>
<li><strong>注释</strong> 一些特性具有替代实现或者是可选的，而不被依赖。</li>
</ul>
</li>
<li>满足 ISO C++11 [implimits] 建议的最小实现要求。</li>
<li>标准库基于 ISO C++11 定义的宿主实现，并满足以下要求：
<ul>
<li><strong>注释</strong> 语言实现不需要是完整的宿主实现。</li>
<li>提供以下符合标准的整数类型：
<ul>
<li>定宽整数 <code>std::intN_t</code> 和 <code>std::uintN_t</code>（其中 N 为 8 、16 、32 或 64 ）。</li>
<li>类型 <code>std::uintptr_t</code> 。</li>
<li><strong>注释</strong> 定宽整数在 ISO C++11 中为可选支持。</li>
</ul>
</li>
<li>满足以下实现定义行为的要求：
<ul>
<li>至少支持 <code>std::placeholders::_7</code>。</li>
<li><strong>注释</strong> 按 ISO C++11 Annex B [implimits] ，符合标准的下限为 10 ，因此已被上述规则涵盖。</li>
</ul>
</li>
<li>假定用于迭代器的 <code>difference_type</code> 或坐标计算的有符号整数作为显式转换的目标类型且结果不能在范围内表示时，不引起副作用且结果的值不是能在此范围内表示的任意值（即为小于 <code>0</code> 的值）。
<ul>
<li><strong>注释</strong> 一个典型的例子是 <code>std::ptrdiff_t</code> 。</li>
<li>当前标准中，转换到有符号数的结果由实现定义。</li>
<li><a href="http://wg21.link/p0907">WG21 P0907</a> 已提议修改使用补码表示，并在 ISO C++20 采纳，按，符合此要求。</li>
<li><strong>注释</strong> 一般的到有符号数转换的由实现定义的行为仍不被依赖。</li>
</ul>
</li>
<li>假定特定类型的特定操作无异常抛出。
<ul>
<li><strong>注释</strong> 可能具有相应的异常规范。</li>
<li>当前包括：
<ul>
<li><code>std::string</code> 的默认构造函数。
<ul>
<li>注释 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4002.pdf">WG21 N4002</a> 引入了显式指定 <code>noexcept</code> ，仅从标准草案 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf">WG21 N4296</a> 起有效）。</li>
</ul>
</li>
<li>容器类型的迭代器的复制初始化。
<ul>
<li><strong>原理</strong> 这允许使用迭代器类型作为函数的参数时，不影响调用者的异常安全保证。</li>
<li><strong>注释</strong> 包括可能被显式定义的类的复制构造和转移构造函数。</li>
<li><strong>注释</strong> 已知 libstdc++ 、libc++ 和 Microsoft STL 的当前实现（蕴含所有被支持的平台配置）的非调试版本都满足这些要求且具有无异常抛出的异常规范。因为 <a href="https://eel.is/c++draft/nullablepointer.requirements#4"><code>NullablePointer</code> 的操作满足无异常抛出保证</a>，使用这些类型直接实现的迭代器的操作满足这里的要求。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>假定被包含在具有外部链接实体的函数体或声明命名空间作用域中外部链接名称的被 ODR 使用(<a href="http://eel.is/c++draft/basic.def.odr#3">odr-used</a>) 的 lambda 表达式相同。
<ul>
<li>否则会引起被包含的代码中的 lambda 在多个翻译单元 ODR 使用时<a href="http://eel.is/c++draft/basic.def.odr#6">违反 ODR 引发未定义行为</a> 。此类未定义行为包括以下情形：
<ul>
<li>所在函数体在 <code>extern inline</code> 函数。这被 <a href="http://wg21.cmeerw.net/cwg/issue765">CWG 765</a> 解决并存在于 ISO C++11 和<a href="http://eel.is/c++draft/dcl.fct.spec#4">之后的标准文本</a>中。
<ul>
<li>对符合 ISO C++11 及之后版本标准的实现，<a href="https://www.reddit.com/r/cpp/comments/40saz8/a_workaround_for_dangerous_lambda_odr_violations/">这个变通</a> 对其中的示例代码因此是不必要的；其它情况也有代码膨胀的缺陷，不应使用。</li>
<li>已知当前所有版本的 Microsoft VC++ 编译器都<a href="https://www.reddit.com/r/cpp/comments/40lm8o/lambdas_are_dangerous/">没有实现这个特性且会在内联代码后引起未预期的行为，计划在下一版本修复</a>。</li>
</ul>
</li>
<li>命名空间作用域中的 lambda 表达式，或所在函数体在其它实体，包括函数模板、类模板的成员函数以及类模板的成员函数模板。这是<a href="http://stackoverflow.com/questions/34717823/can-using-a-lambda-in-header-files-violate-the-odr/34721371#34721371">未被提交和解决的 ISO C++ 缺陷</a>。此处的假定作为用于避免这个问题。</li>
</ul>
</li>
<li>基于 <a href="https://mentorembedded.github.io/cxx-abi/abi.html#closure-types">Itanium ABI</a> 的实现符合这个条件。</li>
</ul>
</li>
<li>对宿主环境中程序外部的状态的并发修改不引起未定义行为。
<ul>
<li>现有操作系统和文件系统提供的接口和实现普遍不能保证避免 <a href="https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use">TOCTTOU 访问(en-US)</a> 导致的问题。具体修改的结果未指定，但应不直接引起无法预测的程序行为。</li>
<li>除非另行指定，本项目的实现不保证检查外部程序的修改。</li>
</ul>
</li>
</ul>
<p>　　假定 YSLib 实现和用户程序的代码满足以下要求：</p>
<ul>
<li>假定异常和标准库 RTTI 对象满足 ODR ，即使是在使用动态库的宿主实现中。
<ul>
<li>但影响用户代码生成的实现的二进制约定（如 <a href="https://reviews.llvm.org/rL205139">ARM64</a> ）且不使用以下错误实现变通的情形除外。</li>
<li>这要求用户代码不依赖影响相关符号可见性而导致 ODR 失效的特性。
<ul>
<li>例如，这不允许如 <code>dlopen</code> 使用 <code>RTLD_LOCAL</code> 加载具有相关符号的库。</li>
</ul>
</li>
<li>这允许 <code>std::type_info</code> 的比较操作和散列操作的高效实现，并避免一些实现错误。
<ul>
<li>使用 libstdc++ (libsupc++) 时，需要重定义宏 <code>__GXX_TYPEINFO_EQUALITY_INLINE</code> 和宏 <code>__GXX_MERGED_TYPEINFO_NAMES</code> 为 <code>1</code> 。
<ul>
<li>这是对 <code>std::type_info</code> 比较操作的错误实现的变通。
<ul>
<li>参见 <a href="https://gcc.gnu.org/viewcvs/gcc?view=revision&amp;revision=179236">GCC r179236</a> 的修改。</li>
<li>参见 <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=103240">GCC PR 103240</a> 。</li>
</ul>
</li>
<li>一般在编译器命令行中使用 <code>-U</code> 选项取消可能存在的预定义再使用 <code>-D</code> 选项重新显式定义，以避免预定义宏被重定义。</li>
<li>调整 <code>__GXX_TYPEINFO_EQUALITY_INLINE</code> 对启用 <code>__GXX_MERGED_TYPEINFO_NAMES</code> 是必要的。</li>
<li><strong>注释</strong> <code>__GXX_MERGED_TYPEINFO_NAMES</code> 默认值被<a href="https://gcc.gnu.org/viewcvs/gcc?view=revision&amp;revision=149964">修改</a> 以支持上述影响符号可见性的特性。</li>
</ul>
</li>
<li>其它实现暂不使用选项支持，以避免和上述二进制约定冲突。
<ul>
<li>libc++ 不支持另行调整，由实现根据<a href="Terminology.zh-CN.html#%E5%B9%B3%E5%8F%B0">平台环境</a>指定 <code>_LIBCPP_HAS_NONUNIQUE_TYPEINFO</code> 。</li>
<li>另见以下关于 <code>std::type_info</code> 比较的限制。</li>
</ul>
</li>
</ul>
</li>
<li>链接时除上述二进制约定，假定 <code>std::type_info</code> 相关的符号被共享。
<ul>
<li>这不允许在实现生成以外显式地<a href="https://stackoverflow.com/questions/19496643/using-clang-fvisibility-hidden-and-typeinfo-and-type-erasure">隐藏相关的符号</a>（如通过 <code>#pragma</code> 预处理指令或 <code>-fvisibility=hidden</code> 编译器命令行选项）。</li>
<li>这一般要求在兼容 GNU ld 的链接器在<a href="https://sourceware.org/binutils/docs/ld/Options.html#Options">命令行选项</a>中使用 <code>--dynamic-list-cpp-typeinfo</code> 等方式导出相关符号（也允许但不要求使用 <code>-rdynamic</code> 或 <code>-export-dynamic</code> ）。</li>
</ul>
</li>
</ul>
</li>
<li>不依赖 RTTI 的 <code>std::type_info</code> 对象在未命名命名空间中同名不同实体的比较结果：
<ul>
<li>libc++ 没有正确支持这些比较，参见 <a href="https://bugs.llvm.org/show_bug.cgi?id=34907">LLVM PR 34907</a>(<a href="https://github.com/llvm/llvm-project/issues/34255">LLVM GitHub issue 34255</a>)。</li>
<li>Clang++ <a href="https://github.com/llvm/llvm-project/issues/59790">当前没有正确支持生成相关名称</a>。</li>
<li><strong>注释</strong> 在未命名命名空间的实体和命名命名空间的实体之间的比较不被涵盖。</li>
</ul>
</li>
<li>假定在标准库宏 <code>NDEBUG</code> 被定义的翻译单元中的代码不违反异常规范。
<ul>
<li><strong>原理</strong> 这允许改进代码生成，如使用 <a href="https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Dialect-Options.html">G++ 的 <code>-fno-enforce-eh-specs</code> 选项</a>。</li>
<li>程序应不依赖违反异常规范时调用标准库的函数的行为。否则，程序行为未定义。
<ul>
<li><strong>注释</strong> 例如，违反上述特定类型的特定操作无异常抛出的假定时。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　YSLib 中具体子项目可要求更严格的实现假定，违反这些假定要求诊断，并可能在不保证支持的构建配置环境下终止构建。需要显式提供诊断时，若可行，应使用符合上述要求的可移植特性。此外，YSLib 实现可依赖可选的语言实现扩展。具体的更严格的假定、可选特性或非全局的特性使用参见项目版本库中 <code>doc</code> 目录下的相关项目文档。</p>
<p><strong>注释</strong> 一些诊断通过语言规则保证而无需显式提供。提供诊断使用的可移植特性的一个例子是 <code>#error</code> 预处理命令。</p>
<p><strong>原理</strong></p>
<p>　　本节中指定的要求通常难以以源代码的形式检查或检测，因此在此作为前提明确。一些普遍但并非严格必须作为全局依赖的特性和实现假定，可以通过源程序表达时，不在这里指定；但为简化实现，也可以通过要求的形式可选地指定。</p>
<p>　　YBase 对标准库的修正实现要求更严格的关于实现细节的假定。YBase 对标准库的不分替代（如 <code>std::addressof</code> ）需依赖更严格的实现特性才能完整实现和标准库相同的保证（尽管不分保证作为 YBase 替代是可选提供的）。依赖更严格的实现假定也允许依赖和向用户代码提供特定平台配置的功能特性，以及提供质量更好的高性能实现。</p>
<p><strong>注释</strong></p>
<p>　　非全局的特性涉及的假定可能以子项目或更小的模块作为单位明确其适用范围。关于可选指定的实现要求，参见以下的<a href="Development.zh-CN.html#%E5%8F%AF%E9%80%89%E5%AE%9E%E7%8E%B0%E8%A6%81%E6%B1%82">可选实现要求</a>。</p>
<h3 id="可选实现要求"><a class="header" href="#可选实现要求">可选实现要求</a></h3>
<p>　　以下相对<a href="Development.zh-CN.html#%E5%9F%BA%E5%87%86%E5%AE%9E%E7%8E%B0%E8%A6%81%E6%B1%82">基准实现要求</a>更严格的实现要求默认不作为全局默认要求，而可供特定的子项目和平台配置按需启用。具体使用参见存储库中 <code>doc/</code> 目录下有关具体子项目的项目文档。</p>
<ul>
<li>关于整数类型的假定：
<ul>
<li>1 字节具有 8 位（即 <code>CHAR_BIT == 8</code> ）。</li>
<li>相对 ISO C++ 要求更严格的特定整数类型的取值范围。</li>
<li>语言实现和外部环境满足以下表示的要求：
<ul>
<li>除指定的例外，整数类型的表示不具有<em>填充位(padding bit)</em> ，即构成其<a href="https://eel.is/c++draft/basic.types"><em>对象表示(object representation)</em></a> 的位和<a href="https://eel.is/c++draft/basic.types#general-4"><em>值表示(value representation)</em></a>一致，但这里指定的例外除外。
<ul>
<li><strong>注释</strong> 关于填充位，参见 ISO C 关于整数类型的描述。</li>
<li>指定的例外包含以下情形：
<ul>
<li>（可能 <em>cv</em> 限定的）<code>bool</code> 类型。</li>
<li>语义和表示可能兼容 ISO C23 <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2763.pdf"><code>_BitInt(N)</code></a> 的类型。
<ul>
<li><strong>注释</strong> 一个例子是 LLVM 扩展 <a href="https://blog.llvm.org/2020/04/the-new-clang-extint-feature-provides.html"><code>_ExtInt(N)</code></a> 。</li>
</ul>
</li>
<li>其它在 YSLib 中的 API 或<a href="Development.zh-CN.html#%E4%BA%92%E6%93%8D%E4%BD%9C">互操作</a>规范中指定的允许接受的特定整数类型。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>关于标准库实现的附加假定：
<ul>
<li>假定 <code>std::chrono::system_clock</code> 使用 1970-01-01 00:00:00 UTC 作为时间历元。
<ul>
<li><strong>注释</strong> 这和 <a href="https://zh.wikipedia.org/wiki/UNIX%E6%97%B6%E9%97%B4">UNIX 时间</a> 以及<a href="https://pubs.opengroup.org/onlinepubs/9699919799.orig/basedefs/V1_chap04.html#tag_04_15">POSIX.1</a> 的基本概念实质相同。这是 ISO C++11 中不存在但 ISO C++20 起在添加的要求，由 <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0355r7.html#time.clock.system">WG21 P0355R7</a> 引入。</li>
<li><strong>原理</strong> 主要的标准库实现（ libstdc++ 、libc++ 或 Microsoft STL ）都满足这个要求。被支持的实现不使用其它标准库，因此也都满足这个要求。即便使用其它实现，未来出现不满足这个要求的实现的可能性很小。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>原理</strong> 以上假定通常被主流实现支持，但并不直接被满足<a href="Development.zh-CN.html#%E5%9F%BA%E5%87%86%E5%AE%9E%E7%8E%B0%E8%A6%81%E6%B1%82">基准实现要求</a>中的 ISO C++ 保证，因此不作为基准实现要求。但是，被支持的实现<a href="Development.zh-CN.html#%E5%B9%B3%E5%8F%B0">平台</a>一般都满足这些条件，因此直接完整地使用本项目的应用可以直接依赖这些特性。区分基准实现要求和可选实现要求允许对本项目的组件以更细粒度的方式使用。</p>
<h3 id="历史实现要求"><a class="header" href="#历史实现要求">历史实现要求</a></h3>
<p>　　以下要求已被修改或取消。</p>
<ul>
<li>假定提供撤销标准库未定义行为的保证：
<ul>
<li>撤销 <a href="http://eel.is/c++draft/res.on.functions#2.5">[res.on.functions]/2.5</a> 对特定不完整类型作为模板实际参数引起未定义行为的限制，包括：
<ul>
<li>使用默认分配器（ <code>std::allocator</code> 的实例）的 <code>std::vector</code> 的 <code>value_type</code> 类型。
<ul>
<li>这被包含在 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4510.html">WG21 N4510</a> 。</li>
<li><code>ystdex::pmr::pool_resource</code> 的实现从 b843[2018-11-10] 起依赖这项特性。</li>
<li>从 b863[2019-07-26] 起不使用不完整类型的元素而不再依赖这项特性。</li>
</ul>
</li>
<li>使用默认分配器（ <code>std::allocator</code> 的实例）的关联容器（即 <code>std::map</code> 和 <code>std::set</code> ）的 <code>value_type</code> 类型。
<ul>
<li>对 <code>std::vector</code> 、<code>std::list</code> 和 <code>std::forward_list</code> ，<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4510.html">WG21 N4510</a> 引入了不完整类型的支持。这<strong>不在</strong>此处要求。关联容器的要求预期在未来被添加。</li>
<li>已知 libstdc++ 的实现符合这个条件。</li>
<li>在 YSLib 中仅被 <code>YSLib::ValueNode</code> 通过在 <code>std::map</code> 使用递归的键类型的实现从 b338[2012-09-13] 起依赖。</li>
<li>因为使用 <code>ystdex::map</code> 替代 <code>std::map</code> ，从 b830[2017-08-11] 起取消这个要求，不再依赖标准库实现提供的扩展特性。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>假定特定类型的特定操作无异常抛出（但不依赖异常规范的行为），包括：
<ul>
<li><code>std::function::swap</code>（ <a href="https://wg21.cmeerw.net/lwg/issue2062">LWG 2062</a> 起有效）。
<ul>
<li>因为使用 <code>ystdex::function</code> 替代 <code>std::function</code> ，从 b848[2018-12-24] 起取消这个要求。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="可选实现支持"><a class="header" href="#可选实现支持">可选实现支持</a></h3>
<p>　　允许使用 ISO C++11 以后兼容最新标准草案的正式标准中的特性（可通过 <code>__cplusplus</code> 宏和 <a href="https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations">SG10 建议的特性检查</a>判断）。</p>
<h3 id="扩展特性"><a class="header" href="#扩展特性">扩展特性</a></h3>
<p>　　除非另行指定，不依赖实现的方言扩展。</p>
<p><strong>注释</strong> 在确保实现能支持时，在特定的代码中可通过条件包含等方式选用。</p>
<p>　　关于语言特性中的具体使用以及启用的扩展，参见 YSLib 项目文档 <code>doc/LanguageRules.txt</code> 和 <code>doc/YBase.txt</code> 等具体部分的相关开发文档。</p>
<p>　　若实现默认具有不符合标准的特性，在本项目的代码中不依赖这些特性，即便外部依赖项可能对此进行配置（如 MinGW G++ 为了和 Microsoft VC++ 兼容启用的 <code>-mms-bitfields</code> ，而 MSYS2 安装的 freetype2 的 <code>pkg-config</code> 的 CFLAGS 隐含此参数）。</p>
<h2 id="保留名称"><a class="header" href="#保留名称">保留名称</a></h2>
<p>　　YSLib 项目中，除了 YBase.LibDefect 是对标准库实现的修正外，并不是语言的实现，因此公开接口遵循 ISO C++ 对保留名称的使用，如不引入以 <code>__</code> 起始的标识符。</p>
<p>　　对实现环境已经以保留标识符提供的接口，适用以下规则：</p>
<ul>
<li><code>&lt;ydef.h&gt;</code> 提供宏包装特定实现的标识符。</li>
<li>除标准预定义的（如 <code>__cplusplus</code> ）和用于特性检查的标识符（以 <code>__cpp</code> 或 <code>__has</code> 起始），以及上述被包装时的宏定义，不在注解（作为宏 <code>YB_ATTR</code> 和 <code>YB_ATTR_STD</code> 的参数）外直接使用保留标识符。</li>
</ul>
<p>　　<code>&lt;ydef.h&gt;</code> 和其它一些 YSLib 项目头文件保留特定的不被标准保留的标识符，详见 YSLib 项目文档 <code>doc/Definitions.txt</code> 。</p>
<h1 id="库概述"><a class="header" href="#库概述">库概述</a></h1>
<p>　　YSLib 项目由多个子项目组成。其中主要的有顶级子项目：YBase 和 YFramework 。它们是开发 YSLib 应用的必备的库。每个库被构建为单独的映像（静态库或动态库）。</p>
<p>　　YSLib 的组件有些是依赖于特定平台的，但更多是<strong>平台中立</strong>的。关于库的组件在此的不同，详见下文的解释。</p>
<p>　　静态库、动态库或其它可能被库构建时依赖的输入以及构建使用的工具是库构建的<strong>依赖项</strong>。关于依赖项的一般说明，详见<a href="Terminology.zh-CN.html">术语</a>中关于依赖管理的说明。</p>
<h2 id="平台模拟"><a class="header" href="#平台模拟">平台模拟</a></h2>
<p>　　除非另行指定，文档中的狭义的“模拟”概念指程序模拟。</p>
<p>　　YSLib 项目中，<strong>平台模拟(platform emulation)</strong> 主要指直接以运行时环境适配层嵌入宿主平台运行时，在具体程序中提供类似被模拟的目标平台的具体特性和接口。</p>
<p>　　完整的定义详见 YSLib 项目文档 <code>doc/CommonRules.txt</code> 。</p>
<h2 id="模块"><a class="header" href="#模块">模块</a></h2>
<p>　　YSLib 项目组织为一个逻辑上的树形结构，其叶节点称为<strong>模块</strong>。类似文件系统，非叶节点称为<strong>模块目录</strong>。在源代码中使用<strong>模块路径</strong>来标识不同的模块，其分隔符为 <code>::</code> 。在 YSLib 项目下直接划分的<strong>顶级子项目</strong>的名称仅在必要时出现在模块路径中，完整模块路径一般从<strong>次级子项目</strong>的名称起始。</p>
<p>　　C 和 C++ 源代码的一个模块由以下三种形式之一构成：</p>
<ul>
<li>一个头文件</li>
<li>一个非头文件的源文件</li>
<li>一个头文件和对应的源文件</li>
</ul>
<p>　　作为公开接口的模块是公开模块。公开模块的头文件在单独的目录中以便部署。</p>
<p>　　按 ISO C 和 ISO C++ 规定，C 或 C++ 模块中存在的非头文件的源文件和包含的头文件构成一个 C 或 C++（预处理）翻译单元，简称<strong>单元</strong>。注意这里包含的头文件不仅限于模块中的头文件。</p>
<p>　　关于模块的进一步说明以及模块路径的形式文法和头文件依赖的基本规则，参见 YSLib 项目文档 <code>doc/ProjectRules.txt</code> 。</p>
<h2 id="文件系统布局"><a class="header" href="#文件系统布局">文件系统布局</a></h2>
<p>　　作为 C++ 项目，YSLib 把每个顶级子项目的源文件和公开模块头文件分别保存在不同的目录中，即 <code>include</code> 和 <code>source</code> 。非公开模块若有头文件，也位于 <code>source</code> 。</p>
<p>　　特定于目标平台配置的代码会直接位于 <code>平台名</code> 目录下，称为<strong>平台扩展</strong>。对应的两个目录为 <code>平台名/include</code> 和 <code>平台名/source</code> 。</p>
<p>　　除了平台扩展的内容，文件系统目录和模块目录的每一级对应。平台扩展的模块目录名是对应平台中立部分加上后缀 <code>_(平台名)</code> 。</p>
<p>　　举例：顶级子项目 YFramework 下的次级子项目 Helper 的非平台扩展的源代码在目录 <code>YFramework/include/Helper</code> 和 <code>YFramework/source/Helper</code> 中，它的 DS 平台扩展的源代码位于 <code>YFramework/DS/include/Helper</code> 和 <code>YFramework/DS/source/Helper</code> 中。</p>
<p>　　提供平台扩展的次级子项目只有 YCLib 和 Helper 。</p>
<p>　　编译项目时包含的头文件是合并的，如编译器命令行 <code>-IYFramework/DS/include -IYFramework/include</code> 在一次编译中同时使用平台中立和特定于平台 DS 的模块的 YFramework 头文件。</p>
<h2 id="yslib-及其本体"><a class="header" href="#yslib-及其本体">YSLib 及其本体</a></h2>
<p>　　在 YBase 和 YFramework 分离之前，YSLib 是一整个库。原 YSLib 大部分仍然在 YFramework 中，仍然可称为 YSLib ，是一个 YFramework 下的次级子项目。注意和整个项目名的不同，以下称为 <strong>YSLib 库</strong>，以示区分。</p>
<p>　　YSLib 库中，Adaptor 用于适配特定于具体外部依赖的接口。可以通过修改其中的代码替换外部依赖，包括部分标准库兼容接口。</p>
<p>　　其它部分的接口和实现都是严格平台中立且不依赖外部特定接口而变化的，称为<strong>本体</strong>。本体中提供了 YSLib 的主要功能。</p>
<h2 id="helper"><a class="header" href="#helper">Helper</a></h2>
<p>　　若需要开发依赖平台特定的应用，本体接口可能不足，而需要使用平台扩展。此外，可能需要一些便利功能。</p>
<p>　　在 YSLib 库之上，Helper 对此类需求提供了一致而灵活的接口。</p>
<p>　　若需要更接近特定平台实现的接口，可以使用 YCLib 及其平台扩展。</p>
<p>　　YCLib 和 Helper 在宿主实现上都提供了更加丰富的功能。</p>
<h1 id="持久数据"><a class="header" href="#持久数据">持久数据</a></h1>
<p>　　除非另行指定，项目中处理的文件符合本节规则。</p>
<h2 id="文件格式"><a class="header" href="#文件格式">文件格式</a></h2>
<p>　　文件可具有编码的数据。存储库文件的内容作为持久保存的数据，其中的<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">编码</a>可满足外部交互的需要而应约定具体的格式，即<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">外部编码</a>。</p>
<p>　　<a href="Terminology.zh-CN.html#%E7%89%88%E6%9C%AC%E5%BA%93">存储库</a>的文件编码应当使用外部编码。</p>
<p><strong>原理</strong> 存储库的文件具有持久保存的内容。明确格式以确保内容的相对稳定，有助于维护。</p>
<p>　　若<a href="WikiRules.en-US.html">本 wiki 的规则(en-US)</a> 存在指定文件格式的规则，在适用外部编码的上下文中，从其约定。</p>
<p><strong>原理</strong> 应用 wiki 规则以允许本 wiki 作为<a href="Terminology.zh-CN.html#%E7%89%88%E6%9C%AC%E5%BA%93">版本库</a>的一部分被管理。</p>
<h3 id="文本文件"><a class="header" href="#文本文件">文本文件</a></h3>
<p><strong>推论</strong> 按 <a href="WikiRules.en-US.html#textfiles">wiki 规则</a>，文本文件使用带有字节序标记(BOM, byte order mark) 的 UTF-8 编码以及 CR+LF 行尾(EOL, end-of-line) 。</p>
<p><strong>原理</strong> 文本文件格式具有以下几个原因：</p>
<ul>
<li>使用 UTF-8 + BOM 的原因是：
<ul>
<li>作为外部编码具有良好的可用性和可移植性。
<ul>
<li>UTF-8 是当前最被广泛使用的外部文本编码。</li>
<li>尽管<a href="https://github.com/FrankHB/pl-docs/blob/master/zh-CN/criticisms-on-UTF-8-everywhere-manifesto">具有技术缺陷</a>，普遍上仍然缺乏其它替代。</li>
<li>尽管存在<a href="https://github.com/FrankHB/pl-docs/blob/master/zh-CN/about-operating-systems.md#%E9%9D%A2%E5%90%91%E6%96%87%E6%9C%ACtextoriented">历史遗留问题问题导致的误解</a>，因为确定使用的编码，相对不使用 BOM ，处理 BOM 的程序的行为更加确定，而具有更好的可移植性。
<ul>
<li>不带 BOM 的 UTF-8 编码的文本内容可能在不同的运行环境中识别为不同的编码。
<ul>
<li>例如，在 Windows 程序（例如 Visual Studio ）中带有 BOM 的文本文件不会认为使用代码页(codepage) 的非 UTF 编码的文本文件；在 Linux 等环境的用户程序中往往默认不带 BOM 的文本文件以 UTF-8 编码。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>可兼容不同的 UTF 编码作为外部编码（外部编码 UTF 的主要使用场景）；参见 wiki 规则中的原理(rationale) 。</li>
<li>同以上应用 wiki 规则的原理，使文本文件能作为版本库的一部分管理。</li>
</ul>
</li>
<li>使用 CR+LF 的原因是：
<ul>
<li>CR 和 LF 具有不同的含义。强调 CR+LF 允许处理只有 CR 的例外情形（尽管除直接以 CR 作为行尾的情形这通常被视为格式错误）。</li>
<li>CR+LF 被强调作为外部编码。相对地，ISO C 和 ISO C++ 等文件流读写实现的文本模式可能处理这些格式并转换为只有 LF 结尾的内部编码。直接使用 LF 可以被兼容且更简单，但损失了边界区分外部编码和内部编码的边界。</li>
<li>CR+LF 是一些最被广泛使用的外部编码标准（如 <a href="https://www.rfc-editor.org/rfc/rfc9110">HTTP</a> ）中要求的一部分。</li>
</ul>
</li>
</ul>
<p>　　程序的<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源代码</a>作为文本文件，应满足文本文件的要求。</p>
<p><strong>注释</strong> 静态确定的源代码一般都以文本文件的形式存储。</p>
<h1 id="代码规范"><a class="header" href="#代码规范">代码规范</a></h1>
<p>　　YSLib 项目维护的代码规范符合 YSLib 项目中的文档约定的规则，包括：</p>
<ul>
<li><code>doc/CommonRules.txt</code> ：一般规则。</li>
<li><code>doc/ProjectRules.txt</code> ：项目规则。</li>
<li><code>doc/LanguageConvention.txt</code> ：语言使用约定。</li>
</ul>
<p>　　YSLib 中的脚本代码应符合以下相关章节的约定。</p>
<h2 id="代码格式化"><a class="header" href="#代码格式化">代码格式化</a></h2>
<p>　　<code>doc/CommonRules.txt</code> 中规定了命名风格和参考的代码格式。由于格式化代码涉及语义分析，并不保证可以完全自动化进行，需要在编码时注意调整。</p>
<p>　　以下工具配置可以把其中的主要工作自动化进行：</p>
<ul>
<li><code>clang-format</code>
<ul>
<li>可通过 MSYS2 包 <code>mingw-w64-i686-clang</code> 或 <code>mingw-w64-x86_64-clang</code> 安装，以下配置以这里的 3.7 版本为基准测试</li>
<li>配置选项的文档参见<a href="http://clang.llvm.org/docs/ClangFormatStyleOptions.html">这里</a></li>
<li>通过命令行 <code>-style=</code> 指定使用选项文件 <code>Tools/YSLib.clang-format</code></li>
<li><strong>注意</strong> 至少以下格式需要手动调整
<ul>
<li>在 <a href="http://lists.llvm.org/pipermail/cfe-commits/Week-of-Mon-20160808/167367.html">LLVM r278121</a> 添加 <a href="https://reviews.llvm.org/D23317">SpaceAfterTemplateKeyword 支持</a> 前 <a href="http://stackoverflow.com/questions/34423615/cpp-template-spacing-using-clang-format-3-6-not-working-as-expected">只支持 <code>template &lt;</code> 而不支持 <code>template&lt;</code></a></li>
<li>行末的 <code>\</code> 前可能附加多个空格</li>
<li><code>{}</code> 会被拆分</li>
<li>部分宏会被作为块的起始叠加缩进</li>
<li>选项 <code>AlwaysBreakAfterReturnType</code> 未被支持，部分函数和函数模板声明的返回类型后缺少换行</li>
</ul>
</li>
<li>通过命令行 <code>-i</code> 直接编辑文件而不是打印结果到标准输出</li>
<li>命令行示例： <code>find YBase YFramework YSTest -name "*.h" -o -name "*.hpp" -o -name "*. cpp" | xargs clang-format -i -style=file</code></li>
<li>命令行示例： <code>find YBase YFramework YSTest -name "*.h" -o -name "*.hpp" -o -name "*. cpp" | xargs -i sh -c "clang-format -i -style=file {}"</code></li>
<li>命令行示例（同时替换 <code>template &lt;</code> ）： <code>find YBase YFramework YSTest -name "*.h" -o -name "*.hpp" -o -name "*. cpp" | xargs -i sh -c "clang-format -i -style=file {} &amp;&amp; sed -bi 's/template &lt;/template&lt;/g' {}"</code></li>
</ul>
</li>
<li><code>astyle</code>
<ul>
<li>可通过 MSYS2 包 <code>mingw-w64-i686-astyle</code> 或 <code>mingw-w64-x86_64-astyle</code> 安装，以下命令行以这里的 2.05.1 版本为基准测试
*（版本 2.05 ）命令行选项的文档参见<a href="http://astyle.sourceforge.net/astyle.html">这里</a>
<ul>
<li><code>--help</code> 取得的文档可能<a href="https://github.com/Alexpux/MINGW-packages/issues/1011">有问题</a>，<code>--delete-empty-lines</code> 对应的短选项应为 <code>-xe</code> 而不是 <code>-xd</code></li>
</ul>
</li>
<li>使用命令行选项 <code>-A1 -T -p -U -k1 -xj -xy -xC80</code>
<ul>
<li>短选项可以缩写</li>
<li>和上述 <code>clang-format</code> 比较，少了部分功能，主要有
<ul>
<li><code>AlignAfterOpenBracket: DontAlign</code></li>
<li><code>AlignTrailingComments: true</code></li>
<li><code>AlwaysBreakAfterReturnType: All</code></li>
<li><code>MaxEmptyLinesToKeep: 2</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>注意</strong> 至少以下格式需要手动调整
<ul>
<li>无法正确识别 <code>constexpr</code> 导致错误的缩进</li>
<li>虽然<a href="http://sourceforge.net/p/astyle/bugs/265/">右值引用识别问题</a>已解决，但实测对模板参数无效</li>
<li>对 <code>extern "C"</code> 块冗余缩进</li>
<li>断行后的缩进</li>
<li>lambda 表达式的捕获列表中的 <code>=</code> 周围的冗余空格以及对应的 <code>{</code> 断行</li>
<li><code>static_cast</code> 等关键字后的 <code>&lt;&gt;</code> 周围的冗余空格</li>
<li>宏实际参数列表头部的 <code>(</code> 和作为第一个参数的标点可能有冗余空格</li>
<li>宏实际参数列表尾部的 <code>,)</code> 没有以空格隔离</li>
<li>初始化数组的列表 <code>{</code> 和之前的 <code>]</code> 存在冗余空格</li>
</ul>
</li>
<li>不使用 <code>-xp</code> ，尽管一些注释需要（移除行首 <code>*</code> 后保持一级缩进）的此类格式，但它会不必要地影响大部分 Doxygen 注释块</li>
<li>默认备份文件后缀 <code>.orig</code> ；可选使用 <code>-n</code> 取消备份文件，或 <code>--suffix=</code> 修改备份文件后缀</li>
<li>使用 <code>-r</code> 递归处理子目录</li>
<li>可选使用 <code>-v</code> 显示详细过程</li>
<li>可选使用 <code>-Q</code> 只显示被处理的文件</li>
<li>可选使用 <code>--dry-run</code> 不实际处理文件</li>
<li>命令行示例：<code>astyle -vQnrA1TpUk1xjxyxC80 YBase/*.h* YBase/*.cpp YFramework/*.h* YFramework/*.cpp YSTest/*.h* YSTest/*.cpp</code></li>
</ul>
</li>
</ul>
<h2 id="shell-语言使用规范"><a class="header" href="#shell-语言使用规范">Shell 语言使用规范</a></h2>
<p>　　本节提供除测试用途和一次性交互式使用场景外的 <a href="https://pubs.opengroup.org/onlinepubs/9799919799/utilities/V3_chap02.html#tag_19">shell 命令语言</a>及其兼容方言的代码的特性使用和代码风格的规则。</p>
<p><strong>注释</strong> YSLib 提供和使用的<a href="Development.zh-CN.html#shell-%E8%84%9A%E6%9C%AC">shell 脚本</a>具有明确的环境要求，其中的代码也<a href="Development.zh-CN.html#shell-%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E8%A7%84%E7%BA%A6">被本节涵盖且满足其它一些具体要求</a>。</p>
<h3 id="空白符"><a class="header" href="#空白符">空白符</a></h3>
<p>　　注意 shell 语言和方言的类似赋值的操作符（如 <code>=</code> 、<code>:=</code> 等）和操作数不能有空白符。</p>
<p><strong>原理</strong></p>
<p>　　文法规则中，赋值不能有空白符，否则被视为单独的构成命令的<em>字(word)</em> 而被分析为命令或参数等非预期的记号。具体地，没有空白符的带有赋值的字视为 <strong>ASSIGNMENT_WORD</strong> 在之后进一步被解析。</p>
<p>　　这和历史同期的 B 语言和 C 语言不同，因为 shell 语言被设计为命令语言，而非更通用的编程语言更强调表达式（例如，考虑到赋值作为表达式可以嵌套使用作为另一赋值表达式的右操作数），赋值被直接视为一类表达式而非一类记号。</p>
<h4 id="重定向"><a class="header" href="#重定向">重定向</a></h4>
<p>　　一般地，<a href="https://pubs.opengroup.org/onlinepubs/9799919799/utilities/V3_chap02.html#tag_19_7">shell 重定向</a>语法中：</p>
<ul>
<li><code>&gt;&amp;</code> 和 <code>&lt;&amp;</code> 按 shell 语言文法规则要求被视为一个记号时内部不应有空白符。</li>
<li>重定向操作符和以数值表示文件描述符或非文件名的 <code>-</code> 操作数之间一般不应有空白符，而其它操作数之间保留空格（与常规命令以及命令参数类似）。</li>
<li>省略重定向操作符之前表示文件描述符的操作数 <code>1</code> 。</li>
</ul>
<p>　　重定向在命令中出现的位置未指定，可被适当调整位置以满足源代码排版清晰，如减少出现在字符串参数中的 <code>\</code> 。</p>
<p><strong>注释</strong> 这可能引起 <a href="https://www.shellcheck.net/wiki/SC2210">ShellCheck 警告 SC2210</a> 。这是其中例外情形而可安全忽略。</p>
<p><strong>示例</strong></p>
<ul>
<li>使用 <code>&gt; &amp;2</code> 或 <code>&gt; &amp; 2</code> 复制输出文件描述符 <code>2</code> 是错误的。</li>
<li>一般应使用 <code>2&gt; /dev/null</code> 和 <code>2&gt; 1</code> ，而不是 <code>2&gt;/dev/null</code> 和 <code>2&gt;1</code> 。</li>
<li>一般应使用 <code>&gt;&amp;2</code> 或 <code>&gt;&amp;-</code> 而不是 <code>1&gt;&amp;2</code> 、<code>1 &gt;&amp; 2</code> 或 <code>&gt;&amp; -</code> 。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　作为命令语言，shell 语言传统上更加强调重定向的 I/O 功能先于指定环境的赋值语法。一般的实现中，重定向被分析出记号之前单独处理，重定向操作符和操作数之间的空格是可选的。POSIX 关于重定向的规范也有和命令中的其它部分更多非平凡的规则：</p>
<ul>
<li>在 shell 重定向的<a href="(https://pubs.opengroup.org/onlinepubs/9799919799/utilities/V3_chap02.html#tag_19_7)">一般格式</a> [<em>n</em>]<em>redir_op</em> <em>word</em> 这个表示中，重定向操作符和之后的操作数技术上没有空格，仅为元语言避免 <em>redir_opword</em> 保持。
<ul>
<li>后文 [<em>n</em>]&gt;<em>word</em> 等描述和示例不再有空格也可以证实这一点。</li>
</ul>
</li>
<li>依照 <a href="https://pubs.opengroup.org/onlinepubs/9799919799/utilities/V3_chap02.html#tag_19_10_02">shell 文法规则</a>：
<ul>
<li>重定向操作符之前的操作数是 <code>IO_NUMBER</code> 而非 <code>WORD</code> 。</li>
<li>重定向操作符之后的操作数在是 <code>io_file</code> ，由重定向操作符（如记号 <code>&gt;</code> ）和规约至 <code>filename</code> 的 <code>WORD</code> 组成。</li>
</ul>
</li>
</ul>
<p>　　但是，除了 <code>&gt;&amp;</code> 应被视为整个记号这样的符合文法规则要求的要点外，这里约定的风格不直接由文法规则决定，而指派相对独立的用例场景分类。（事实上，套用文法规约反而会和这里规则相反地得到 <code>IO_NUMBER</code> 和之后的重定向操作符之间有空白符而重定向操作符和之后的字之间可省略空白符的结论。）这是因为：</p>
<ul>
<li>强调重定向的传统惯用的命令风格中，文件描述符或非文件名的 <code>-</code> 操作数和重定向操作符被视为一个整体，而命令中的其它字则不是，如：<code>command &lt; input &gt; output 2&gt;&amp;1</code> 。
<ul>
<li>重定向规则中的 <code>-</code> 在被（不视为文件名）单独支持时，和文件描述符遵循相同的规则。</li>
<li>和重定向的格式描述中的示例不同，在 <a href="https://pubs.opengroup.org/onlinepubs/9799919799/utilities/V3_chap02.html#exec"><code>exec</code> 的示例</a>等描述中，使用了这种方式，同时在格式上也把 <code>-</code> 视为文件描述符。</li>
</ul>
</li>
<li>操作数是否被视为文件描述符的规则和具体重定向操作符相关，特别是预期使用文件名的而实际是文件名的易错情形。强调区分这两种用法风格可能减少这些误用。</li>
</ul>
<h4 id="保留字和命令"><a class="header" href="#保留字和命令">保留字和命令</a></h4>
<p>　　注意命令之间需要有空白符；但 <code>((</code> 虽然是命令，其后的表达式被视为特设语法的一部分而不被视为命令的操作数而可能被特殊处理。具体地：</p>
<ul>
<li>在 <code>[</code> 和参数之间应有空白符，否则语法错误。</li>
<li>在 <code>$((</code> 或 <code>((</code> 和之后的表达式可以有空白符，但一般应省略。
<ul>
<li><strong>原理</strong> 这使 <code>if</code> 和 <code>for</code> 等关键字相对接近 C 语法风格惯例。</li>
</ul>
</li>
<li>在 <code>((</code> 和之前的关键字之间不省略空格。
<ul>
<li><strong>注释</strong> 尽管在 GNU Bash 文档中没有提及，如 <code>if((</code> 和 <code>for((</code> 实际上可被 Bash 解释器识别并拆分出关键字和 <code>((</code> 记号。这不被这里依赖。</li>
<li><strong>原理</strong> 一般避免依赖 POSIX <a href="https://pubs.opengroup.org/onlinepubs/9799919799/utilities/V3_chap02.html#tag_19_04">从命令识别保留字</a>以外的附加处理。</li>
</ul>
</li>
<li><strong>注释</strong> <code>((</code> 在扩展方言中使用。POSIX 在<a href="https://pubs.opengroup.org/onlinepubs/9799919799/utilities/V3_chap02.html#tag_19_09_04_01">组合命令(compound commands)</a> 中提及实现可能提供这种算术求值(arithmetic evaluation) 语法。</li>
</ul>
<p>　　除非另行指定，以下命令的行为未指定：</p>
<ul>
<li>在 POSIX 或使用的 shell 语言实现环境（如特定方言扩展）中未指定的行为。</li>
<li>诊断消息的具体内容。</li>
<li>除 <a href="https://pubs.opengroup.org/onlinepubs/9799919799/utilities/V3_chap02.html#tag_19_09">POSIX 指定的命令行长度限制</a>以及显式引用这个限制的情形，这个命令行长度限制的具体值。
<ul>
<li><strong>示例</strong> 使用 <a href="https://pubs.opengroup.org/onlinepubs/9799919799/utilities/getconf.html"><code>getconf</code> 实用工具</a> 能显式得到这个值（即 <a href="https://pubs.opengroup.org/onlinepubs/9799919799/functions/sysconf.html"><code>ARG_MAX</code></a> 值）。</li>
</ul>
</li>
</ul>
<h3 id="引号"><a class="header" href="#引号">引号</a></h3>
<p>　　使用引用时，优先使用单引号。</p>
<p>　　考察以下情形决定是否使用引号：</p>
<ul>
<li>在字符串字面量使用 shell 参数或其它其它在字面量中起作用的扩展时，应使用双引号。</li>
<li>在字符串字面量使用 shell 通配符或其它不在字面量中起作用的扩展时，应不使用双引号。</li>
<li>对 <code>echo</code> 和类似能支持多个参数合并字符串的命令的字符串字面量一般应始终使用引号以确保作为单一参数处理。</li>
<li>对其它的简单的命令参数，特别是相对固定的参数（如 <code>%s</code> 这样的仅包含不被 shell 扩展的格式字符串），一般应省略引号。</li>
</ul>
<p><strong>原理</strong> 使用引号使字符串字面量的内容和源代码直接对应，可避免一些非预期 shell 导致的难以检查的误用。</p>
<h3 id="变量和环境"><a class="header" href="#变量和环境">变量和环境</a></h3>
<p>　　变量的初始化和默认值满足以下约定：</p>
<ul>
<li>若没有指定变量的初始化调用函数，则使用 shell 内建的方式（如赋值）直接实现。
<ul>
<li><strong>注释</strong> 变量的初始化还可通过调用函数间接实现。</li>
</ul>
</li>
<li>除非另行指定，初始化的变量具有的只读或导出等属性未指定。
<ul>
<li><strong>注释</strong> 之后可能通过声明只读或取消属性。</li>
</ul>
</li>
<li>除非另行指定，变量被修改前要求非只读。
<ul>
<li>若不满足要求，则运行出错。</li>
<li><strong>注释</strong> 另行指定的特定的变量可能通过声明取消只读之后被修改。</li>
<li>取消只读的变量在修改后重新设置只读属性。</li>
</ul>
</li>
<li>初始化变量时若需使用默认值，可能发生附加的求值（如命令调用）以其结果确定具体默认值。</li>
<li>除非变量的初始化被指定为由特定的函数确定，变量在未指定的脚本被执行时无条件初始化，而不需要使用变量的值前调用特定的函数。</li>
<li>除非另行指定：
<ul>
<li>在特定函数中初始化的变量由此函数指定其默认值。</li>
<li>初始化时使用的外部环境变量的值可假定和脚本运行环境直接或间接调用脚本前相同。</li>
</ul>
</li>
</ul>
<p>　　除非另行指定，shell 的变量可能被 shell 脚本执行时修改。</p>
<p><strong>原理</strong> 这允许一般不要求检查变量是否只读，包括提供默认值或直接复用外部可能已初始化的环境变量，以简化实现。</p>
<p>　　注意循环等语法隐式引入的 shell 变量是全局变量。若有可能（当 shell 方言支持的上下文时），显式声明局部变量后再使用变量；在 POSIX shell 中可引入函数使用参数代替。</p>
<p><strong>原理</strong> 使用局部变量代替全局变量以在不需要共享时避免污染全局环境。这要求方言和特定的上下文（如函数体中），不总是容易实现。使用函数是相对容易在 POSIX shell 中实现局部作用于的方法；其它方式（如子 shell ）可具有更大的开销和更多的可能非预期的副作用（如无法共享变量），因此不作要求。</p>
<h3 id="实用程序"><a class="header" href="#实用程序">实用程序</a></h3>
<p>　　实用程序(utility) 提供 shell 语言中可用的命令。</p>
<ul>
<li>功能可满足需要且没有显著的性能问题时，优先使用兼容 POSIX 的实用程序。</li>
<li>除非另行指定，假定实用程序不具有调用时不一致的行为的别名。
<ul>
<li><strong>注释</strong> 不假定不存在对其它命令可见的不同的行为，如特定的 <code>alias</code> 和 <code>command -v</code> 调用可能结果不同。</li>
<li><strong>注释</strong> 约定的未指定行为不视为不一致，如<a href="Development.zh-CN.html#%E4%BF%9D%E7%95%99%E5%AD%97%E5%92%8C%E5%91%BD%E4%BB%A4">命令行长度</a>的改变。</li>
<li><strong>示例</strong> 在非交互式 shell 中，<code>alias=ls --color=auto</code> 不影响 <code>ls</code> 命令的行为而满足假定。</li>
</ul>
</li>
<li>使用 <a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/env.html">POSIX <code>env</code> 实用程序</a> 以避免对<a href="Development.zh-CN.html#%E5%8F%98%E9%87%8F%E5%92%8C%E7%8E%AF%E5%A2%83">只读变量</a>的赋值。</li>
<li>除非另行指定，不使用 <code>which</code> 。
<ul>
<li><strong>原理</strong> 这个命令不是 POSIX 实用程序，兼容性相对较差，且一般没有 shell 内建支持。
<ul>
<li>另见 <a href="https://www.shellcheck.net/wiki/SC2230">ShellCheck 警告 SC2230</a> 和<a href="https://github.com/koalaman/shellcheck/issues/1162">相关讨论</a>。</li>
</ul>
</li>
<li>在 GNU Bash 中，对检查一个操作数的情形，使用 <code>type -P</code> 代替。
<ul>
<li>在 makefile 中，可<a href="https://www.gnu.org/software/make/manual/html_node/Choosing-the-Shell.html">使用 <code>SHELL</code></a> 或 <code>bash -c</code> 等方式调用 <code>type -P</code> 。</li>
</ul>
</li>
<li>在不依赖 shell 扩展和不同行为时，可使用 <code>command -v</code> 。
<ul>
<li><strong>注意</strong> <code>command -v</code> 对别名等非 <code>$PATH</code> 中可搜索的程序以及多个参数时的处理和 <code>which</code> 的一般实现不同。</li>
</ul>
</li>
<li>在没有满足要求的替代确定可依赖 <code>which</code> 时，可使用 <code>which</code> 。</li>
</ul>
</li>
</ul>
<h2 id="构建选项"><a class="header" href="#构建选项">构建选项</a></h2>
<p>　　一般地，在脚本中默认指定的工具链的警告选项应能支持代码规范。</p>
<h1 id="脚本"><a class="header" href="#脚本">脚本</a></h1>
<p>　　YSLib 版本库中包含若干脚本。这些脚本和 YSLib 安装部署的脚本使用<a href="Run.zh-CN.html#%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%8E%AF%E5%A2%83">命令行程序运行环境</a>和本章中的约定。</p>
<p>　　脚本一般通过调用解释器运行。<em>脚本运行环境(script runtime environment)</em> 是支持脚本运行的命令行程序运行环境。除非另行指定，脚本运行环境是<a href="Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">宿主环境</a>或非宿主环境内部通过<a href="Development.zh-CN.html#%E5%B9%B3%E5%8F%B0%E6%A8%A1%E6%8B%9F">平台模拟</a>提供的类宿主环境。</p>
<p><strong>注释</strong> 符合 YSLib 源码 <code>YF_Hosted</code> 定义支持的平台能提供宿主环境。</p>
<p>　　除非另行指定，脚本以文件的形式部署。</p>
<h2 id="外部环境"><a class="header" href="#外部环境">外部环境</a></h2>
<ul>
<li>除非另行指定，脚本不假定自身的存储位置。
<ul>
<li>一般地，这允许脚本的内容不总是可通过文件系统访问。这包括执行时脚本的来源被移除和不公开以文件的形式部署等情形。</li>
</ul>
</li>
<li>对文件系统中的脚本：
<ul>
<li>脚本文件总是普通文件或可解析到普通文件的有效的符号链接。</li>
<li>除非另行指定，不假定脚本文件所在的位置或其父路径可写。</li>
</ul>
</li>
</ul>
<p>　　项目中提供的脚本在版本库中具有固定的相对路径。除解释环境适用的公共的约定，脚本不预设绝对路径的假定。</p>
<p><strong>示例</strong> 公共约定如使用一般类 UNIX 系统使用的文件系统布局的 <a href="https://zh.wikipedia.org/zh-cn/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86">FHS（文件系统层次结构标准）</a>。另见<a href="Run.zh-CN.html#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80">文件系统布局</a>。</p>
<p><strong>警告</strong> 小心处理路径。当前脚本直接或间接使用的所有涉及文件系统递归操作均不假设检查遍历的目标之间是否重复，若使用不恰当的目录链接，可能造成未预期的行为（如复制指向父目录的目录链接时可引起无限递归）。部署时应提前确保不存在这样的链接。</p>
<p>　　脚本实现假定没有可能冲突的并发文件访问。</p>
<h2 id="脚本文件"><a class="header" href="#脚本文件">脚本文件</a></h2>
<p>　　<strong>脚本文件总是使用以下约定的扩展名。</strong></p>
<p>　　除了 Windows 命令解释器使用的 <code>.cmd</code> 文件以及 <a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0">NPLA1</a> 脚本使用的 <code>.txt</code> 文件，所有脚本使用 <a href="http://zh.wikipedia.org/zh-cn/Shebang">Shebang</a> 明确需要使用的解释环境（详见 <a href="Development.zh-CN.html#shell-%E8%84%9A%E6%9C%AC">shell 脚本的说明</a>）。</p>
<p>　　Windows 命令解释器脚本因为实现限制使用本机 ANSI 代码页的编码，约定为兼容 ASCII 。</p>
<p>　　<a href="Development.zh-CN.html#npla1-%E8%84%9A%E6%9C%AC">NPLA1 脚本</a>约定使用带有 BOM 的 UTF-8 编码（去除 BOM 的脚本可能兼容 ASCII ）。</p>
<p><strong>注释</strong></p>
<p>　　关于 NPLA1 脚本编码，另见：</p>
<ul>
<li>以上关于<a href="Development.zh-CN.html#%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6">文本文件</a>的规则。</li>
<li><a href="Features/NPL.zh-CN.html#%E5%BD%93%E5%89%8D%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">NPL 当前实现</a>的说明。</li>
<li><a href="Tools/SHBuild.zh-CN.html#npl-%E6%94%AF%E6%8C%81">Stage 1 SHBuild 中关于 NPL 支持</a>的说明。</li>
</ul>
<h2 id="接口约定"><a class="header" href="#接口约定">接口约定</a></h2>
<p>　　脚本变量可能被读取和加载。</p>
<p>　　除非另行指定，脚本引入的非导出的变量和名称以 <code>_</code> 结尾的变量，都不是公开接口。</p>
<p><strong>原理</strong> 基于名称约定便于和构成公开接口的名称区分。</p>
<h3 id="路径"><a class="header" href="#路径">路径</a></h3>
<p>　　<em>路径(path)</em> 是由有限的路径<em>组件(component)</em> 构成的序列。在不引起歧义时，路径即指文件系统路径。文件系统的路径组件能以字符串形式表示。</p>
<p>　　特定的路径上的规约操作是<em>路径解析(path resolution)</em> 。</p>
<p>　　路径的字符串表示可具有<em>分隔符(separater)</em> ，以显式区分组件的边界。</p>
<p>　　<em>路径后缀(path suffix)</em> 是路径中最后的一个或多个组件序列构成的序列。路径表示的后缀蕴含分隔这些组件的内部分隔符和之后的分隔符。除非另行指定，一个路径的后缀中的组件序列是最后一个组件（若存在）。</p>
<p>　　<em>路径前缀(path prefix)</em> 是路径或其表示中不包含路径后缀的部分。</p>
<p>　　在支持相对路径的环境中，是否支持相对路径取决于被使用的具体程序（可能是脚本）。</p>
<p>　　除非另行指定，内部的路径的分隔符使用 <code>/</code> 。通过<a href="Tools/Scripts.zh-CN.html">工具脚本</a>提供的 <a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-SHBuild_2w"><code>SHBuild_2w</code></a> 等函数，可转换为带有不同路径分隔符的路径字符串。这种转换通常仅在必要时（如明确作为外部工具的输入）使用。</p>
<p>　　字符串形式的路径（即路径字符串）可能是保证不以分隔符结尾的文件名和确保以分隔符结尾的目录路径字符串。目录路径指目录路径字符串或其对应的非字符串形式的路径。</p>
<p>　　两个路径字符串的拼接可构成新的路径字符串。这两个路径字符串分别是路径前缀和路径后缀。除非另行指定，作为路径前缀使用的路径字符串是文件名。这要求通过串接路径后缀构成访问前缀指定的目录的新的路径时，路径后缀需要以分隔符起始。</p>
<p><strong>注意</strong> YBase 的 <code>ystdex::path</code> 和 YFramework 的 <code>YSLib::IO::Path</code> 等数据结构表示根路径外无视结尾分隔符的非字符串形式的路径，因为有效的分隔符仅在根路径中出现。这些实现一般不检查分隔符的合法性，如其中具有包含分隔符的路径组件，也可能正常转换为字符串形式的合法路径。当前脚本只使用字符串形式的路径。</p>
<p><strong>示例</strong></p>
<p>　　在使用 POSIX.1 定义的宿主环境中：</p>
<ul>
<li>文件系统路径及其字符串表示是 <a href="https://pubs.opengroup.org/onlinepubs/9799919799/basedefs/V1_chap03.html#tag_03_254">POSIX 路径名(pathname)</a> 。</li>
<li>使用的分隔符是非前缀的至少一个连续字符 <code>/</code> 。</li>
<li>对应的路径解析适用 <a href="https://pubs.opengroup.org/onlinepubs/9799919799/basedefs/V1_chap04.html#tag_04_16">POSIX.1 路径名解析(pathname resolution)</a> 的规则，且 YSLib 的具体程序可指定应用其它不依赖 POSIX.1 的转换规则。路径前缀是<a href="https://pubs.opengroup.org/onlinepubs/9799919799/basedefs/V1_chap03.html#tag_03_256">POSIX.1 路径前缀</a> 。</li>
<li><em>文件名(filename)</em> 作为文件系统路径的组件。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　POSIX 路径名 <code>/</code> 是根路径；前缀 <code>//</code> 在路径解析中具有实现定义的行为，但 3 个或以上 <code>/</code> 视为 1 个 <code>/</code> 而不具有类似的实现定义语义。</p>
<p>　　Windows 的 POSIX 实现如 Cygwin 和 MSYS 使用 <code>//</code> 作为 POSIX 路径的 UNC 路径前缀（在 Win32 中为 <code>\\</code> ）。</p>
<h3 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h3>
<p>　　依照<a href="Run.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">运行时环境的约定</a>，除非另行指定，YSLib 程序（包含脚本）不区分未设置的环境变量和已设置但具有空值的环境变量，以允许在外部环境配置脚本的执行。这两种情形下，被用于脚本中的变量的都可能被指定一个非空的初始值，称为变量的<em>默认值(default value)</em> 。</p>
<p>　　程序中参照环境变量管理的具有对应字符串类型的值的具名配置项，也可视为具有默认值的变量。</p>
<p><strong>注释</strong> 被作为环境变量传递的值应能通过<a href="Development.zh-CN.html#%E4%BA%92%E6%93%8D%E4%BD%9C">互操作</a>确保和环境变量的值具有对应关系。即便变量仅在脚本或非脚本的程序内部使用，也可用本节的规则，但这部分是可选的。</p>
<p>　　变量是否使用默认值总在先于第一次使用变量的值的初始化时确定。指定按需<em>按需(as needed)</em> 初始化的变量，当且仅当具有非空值时被初始化为默认值。</p>
<p>　　YSLib 程序可按需使用以下能通过外部环境指定值的环境变量及其默认值：</p>
<ul>
<li>用于指定命令：
<ul>
<li><code>SHBuild</code> ：外部 <a href="Tools/SHBuild.zh-CN.html">SHBuild</a> 可执行文件路径。</li>
</ul>
</li>
<li>用于指定存储库中的资源：
<ul>
<li><code>SHBuild_ToolDir</code> ：工具目录中的脚本目录即 <a href="Tools/Scripts.zh-CN.html#Tools"><code>Tools/Scripts</code></a> 。</li>
<li><code>SHBuild_BaseDir</code> : SHBuild 目录，是工具目录中提供 SHBuild 的源代码的目录。
<ul>
<li>默认值按 <code>SHBuild_ToolDir</code> 初始化后的相对位置确定，为 <code>"$SHBuild_ToolDir/../SHBuild"</code>。</li>
</ul>
</li>
<li><code>YSLib_BaseDir</code> ：YSLib 目录，即版本库检出后的工作目录。</li>
</ul>
</li>
<li>用于指定输出目录：
<ul>
<li><code>SHBuild_BuildDir</code> ：构建使用的中间输出文件路径。
<ul>
<li>默认值定义如下：
<ul>
<li>对不依赖 <a href="Sysroot.zh-CN.html">Sysroot</a> 的以及 <code>YSLib/YSTest</code> 目录下的项目构建脚本，默认值指定在完整的版本库中和 <code>"$YSLib_BaseDir/build/$(SHBuild_GetBuildName)"</code> 相同的目录，且构建 <a href="Sysroot.zh-CN.html">stage 1</a> YSLib 时确保为绝对路径。</li>
<li>对 <code>YSLib/YDE</code> 目录下的项目构建脚本，默认值是 <code>".$(SHBuild_GetBuildName)"</code> 。</li>
<li>否则，默认值是当前工作目录 <code>.</code> 。</li>
<li>以上调用的函数 <code>SHBuild_GetBuildName</code> 在<a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-commonsh">脚本 <code>Tools/Scripts/SHBuild-common.sh</code></a> 中，依赖具有非空值的变量 <code>SHBuild_Host_OS</code> 和 <code>SHBuild_Host_Arch</code> 。</li>
</ul>
</li>
</ul>
</li>
<li><code>SHBuild_SysRoot</code> ：Sysroot 根路径。
<ul>
<li>在 <a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">SHBuild 构建环境</a>中，指定 <a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 2 SHBuild</a> 的输出目录；默认值是 <code>"$YSLib_BaseDir/sysroot"</code> 。</li>
<li>在<a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">部署后环境</a>中，指定一个先前的 Sysroot 安装位置；默认值按 <code>SHBuild</code> 初始化后的相对位置确定。
<ul>
<li><strong>注释</strong> 当前仅在经过 SHBuild 构建环境后直接复用，而不单独作为<a href="Development.zh-CN.html#%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D">入口位置</a>。</li>
</ul>
</li>
<li>其值被作为路径使用时，结尾的一个或多个 <code>/</code> 被忽略。</li>
<li><strong>原理</strong> 忽略结尾 <code>/</code> 允许 Sysroot 根路径的字符串表示作为<a href="Development.zh-CN.html#%E8%B7%AF%E5%BE%84">路径前缀</a>和一个 POSIX 绝对路径的路径前缀（以 <code>/</code> 起始的字符串）拼接时，把后者视为相对 Sysroot 根路径的<a href="Development.zh-CN.html#%E8%B7%AF%E5%BE%84">路径后缀</a>而不在结果中引入多余的 <code>/</code> 。否则，支持被拼接的路径前缀视为路径后缀时 Sysroot 根路径无法支持指定 POSIX 根路径 <code>/</code> ，因为这要求变量 <code>SHBuild_SysRoot</code> 的值是空值而和默认值冲突。</li>
</ul>
</li>
</ul>
</li>
<li>用于配置构建环境：
<ul>
<li>其它情形不用于指定输出目录，不保证具有默认值。</li>
<li><code>SHBuild_Env_TempDir</code> ：构建时使用的临时目录路径。
<ul>
<li>由脚本 <code>Tools/Scripts/SHBuild-common.sh</code> 的<a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_preparebuild">函数 <code>SHBuild_PrepareBuild</code></a> 初始化。</li>
<li>默认值由脚本 <code>Tools/Scripts/SHBuild-common.sh</code> 中的<a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_gettempdir">函数 <code>SHBuild_GetTempDir</code></a> 的调用确定。</li>
</ul>
</li>
<li><code>SHBuild_Env_Arch</code> ：构建系统架构。
<ul>
<li>由脚本 <code>Tools/Scripts/SHBuild-common.sh</code> 的<a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_checkuname">函数 <code>SHBuild_CheckUName</code></a> 初始化。</li>
</ul>
</li>
<li><code>SHBuild_Env_OS</code> ：构建系统操作系统。
<ul>
<li>初始化和确定值的方式同 <code>SHBuild_Env_Arch</code> 。</li>
</ul>
</li>
<li><code>SHBuild_Host_Arch</code> ：宿主架构。
<ul>
<li>由脚本 <code>Tools/Scripts/SHBuild-common.sh</code> 的函数 <code>SHBuild_PrepareBuild</code> 初始化。</li>
<li>默认值使用以下方式指定：
<ul>
<li>当 <code>SHBuild_Env_OS</code> 的值是 <code>Win32</code> 且外部变量 <code>MSYSTEM</code> 的值是 <code>MSYSTEM64</code> 时，默认值为 <code>x86_64</code> 。</li>
<li>当 <code>SHBuild_Env_OS</code> 的值是 <code>Win32</code> 且外部变量 <code>MSYSTEM</code> 的值是 <code>MSYSTEM32</code> 时，默认值为 <code>i686</code> 。</li>
<li>其它情形默认值同 <code>SHBuild_Env_Arch</code> 初始化后的值。</li>
</ul>
</li>
</ul>
</li>
<li><code>SHBuild_Host_OS</code> ：宿主操作系统。
<ul>
<li>初始化的方式同 <code>SHBuild_Host_Arch</code> 。</li>
<li>默认值同 <code>SHBuild_Env_OS</code> 初始化后的值。</li>
</ul>
</li>
<li><code>SHBuild_VCS_</code> 起始的变量：指定使用的版本控制系统。
<ul>
<li><code>SHBuild_VCS_hg</code> ：若非空，指定使用 <a href="https://www.mercurial-scm.org/">Mercurial</a> 。</li>
<li><code>SHBuild_VCS_git</code> ：若非空，指定使用 <a href="http://git-scm.com/">Git</a> 。</li>
<li>除非另行指定，若同时指定使用 Mercurial 和 Git 两者，则使用 Mercurial 。</li>
<li>指定使用版本控制系统是提示，不保证是实际的选择。具体使用前，脚本可能自动对可用性（命令行 <code>hg</code> 和 <code>git</code> 及当前工作目录是否位于对应的版本库）进行检查，当不满足要求时可能忽略提示。</li>
<li><strong>原理</strong> 若当前工作目录同时位于多个版本控制系统的版本库，使用提示可以明确选择其中之一。</li>
<li><strong>注释</strong> 本项目的<a href="GettingSources.zh-CN.html">源代码可从 Mercurial 或 Git 中取得</a>。</li>
</ul>
</li>
<li><code>SHBuild</code> 构建使用的变量：详见 SHBuild 的帮助信息。</li>
<li>其它构建脚本使用的变量：详见以下具体脚本的说明。</li>
</ul>
</li>
<li><strong>注释</strong> 上述变量中，可作为<a href="Development.zh-CN.html#%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D">入口位置</a>的变量的默认值在此省略，详见<a href="Development.zh-CN.html#%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D">文件定位</a>的相关说明。</li>
</ul>
<p><strong>注释</strong> <a href="Tools/Scripts.zh-CN.html#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">脚本中的环境配置约定</a>指定更具体的脚本可访问的变量，其命名满足以上变量名要求。</p>
<p>　　若以上变量在上述任一情形存在作为路径的默认值且外部环境指定变量的值，则指定的值应表示合法的路径。若指定的是可执行文件，则具有可访问和执行的权限。脚本可对这些条件进行检查，若失败则引起错误。</p>
<h2 id="互操作"><a class="header" href="#互操作">互操作</a></h2>
<p>　　脚本源代码中可引用自身或其它程序，被引用的程序是<em>目标程序(target program)</em> 。目标程序可使用脚本实现，即<em>目标脚本(target script)</em> 。被执行的<em>当前脚本(current script)</em> 可能通过文件路径和脚本语言支持的构造使用目标程序。</p>
<p><strong>示例</strong> Shell 脚本中可使用 <code>.</code> 或 <code>source</code> 命令执行参数指定路径的兼容 shell 的目标脚本、调用脚本解释器命令执行参数指定的被解释器支持的目标脚本或直接使用带有适当权限的文件名作为命令执行目标程序。</p>
<h3 id="文件定位"><a class="header" href="#文件定位">文件定位</a></h3>
<p>　　被引用的目标程序或其它文件被运行时相对特定的文件系统中的位置应被确定，即对<em>目标文件(target file)</em> 的<em>定位(locating)</em> 。</p>
<p>　　定位包含一次或多次对输入的指定文件位置的参数进行处理，输出新的路径作为候选，这个过程即<em>解析(resolution)</em> 。<em>入口位置(entry location)</em> 是定位的起始位置，作为第一步路径解析的输入，之后可选的步骤迭代可继续输入不同的相对路径迭代解析，直至取得与其的目标文件的位置。入口位置可以是当前被执行的脚本文件在文件系统中的位置，或通过<a href="Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">特定的环境变量</a>的值指定。其它一些变量也可指定路径解析步骤的输入。</p>
<p><strong>注释</strong> 定位解析的迭代方式和文件系统对<a href="Development.zh-CN.html#%E8%B7%AF%E5%BE%84">路径解析</a>的方式类似，但输入和输出不一定是路径。通常最终的输出是能在当前上下文中直接和唯一地确定文件位置的路径。若当前上下文不支持访问工作目录，这个路径一般应为绝对路径。和路径解析不同，位置的抽象解析可以包含执行任意操作而不排除其中可能具有副作用，但通常仍应完全避免依赖这些副作用。</p>
<p>　　同时在多个环境都适用的目标文件，相对当前脚本的位置不保证相同。若表达这些相对位置的相对路径确保作用等价，则视为相对位置唯一确定。</p>
<p><strong>注释</strong> 目标程序通常是 YSLib 提供的脚本或构建后部署的程序。若使用其它程序，可能安装在 <code>$PATH</code> 可引用的路径或其它周知的位置，而不需要使用本节的方式定位；但本节的方式仍可能（有限地）适用。</p>
<p>　　当前设计中，YSLib 提供的脚本可以在 <a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">SHBuild 构建环境</a>和<a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">部署后环境</a>中使用，即可访问和可执行。Sysroot 布局可提供在部署后环境脚本的特定位置的目标文件。YSLib <a href="Terminology.zh-CN.html#%E7%89%88%E6%9C%AC%E5%BA%93">存储库</a>提供部署之前的确定的相对位置的脚本。</p>
<p><strong>注释</strong> 可能有程序在不同环境中的<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">可观察行为</a>不完全相同，如 <a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 1 和 stage 2 SHBuild</a> 依赖不同的库，也不保证未来具有完全相同的特性集。</p>
<p>　　定位解析的典型情形如下：</p>
<ul>
<li>使用已知位置的相对路径定位：位置由表示已知位置的路径和相对当前脚本的相对路径确定。
<ul>
<li>其中，已知位置是当前脚本或一个已被定位的目标文件的位置。</li>
<li><strong>注释</strong> 当脚本同时支持 SHBuild 构建环境和部署后环境，预期使用等效的目标文件，一般应使用文件直接确定而非以下可配置的<a href="Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量</a>。对无法唯一定位的目标文件，则可使用以下其它方式。</li>
</ul>
</li>
<li>使用<a href="Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">变量</a>的值定位：位置由作为路径的变量的值指定，若非空则需要<a href="Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">默认值</a>。</li>
<li>搜索路径定位：使用搜索特定变量值中的元素作为路径前缀的结果。
<ul>
<li>除非另行指定，被搜索变量是内容满足 <a href="https://pubs.opengroup.org/onlinepubs/9799919799/basedefs/V1_chap08.html">POSIX.1 定义</a>的 <code>PATH</code> ，使用 <a href="Development.zh-CN.html#%E8%B7%AF%E5%BE%84">POSIX.1 路径名解析</a> 的方式取得结果。</li>
</ul>
</li>
</ul>
<p>　　可用于指定入口的<a href="Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量</a>的默认值和特定脚本被设计适应的部署环境可能相关，确定如下：</p>
<ul>
<li><code>SHBuild</code> ：
<ul>
<li>SHBuild 构建环境中的安装过程中的默认值参见<a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">构建过程</a>。</li>
<li>否则，对部署后环境中的可执行脚本，默认值是 Sysroot 中的脚本直接指定 Sysroot 根目录定位的结果。</li>
<li>否则，默认值是搜索路径定位的结果。</li>
</ul>
</li>
<li><code>SHBuild_ToolDir</code> ：
<ul>
<li>默认值按脚本根据存储库所在目录确定。</li>
<li><strong>注释</strong> 在 SHBuild 构建之后，脚本可能脱离存储库运行，不保证这个目录存在，因此部署后环境下的脚本不依赖 <code>SHBuild_ToolDir</code> 取脚本路径。</li>
</ul>
</li>
<li><code>YSLib_BaseDir</code> ：
<ul>
<li>默认值按变量 <code>SHBuild_ToolDir</code> 初始化后的值指定的位置的相对路径确定，为 <code>"$SHBuild_ToolDir/../.."</code>。</li>
</ul>
</li>
<li><strong>原理</strong> 工具目录及其子目录相对存储库的布局（相对路径）是确定的，可直接使用相对路径定位。</li>
<li><strong>原理</strong> <a href="Sysroot.zh-CN.html#%E5%B8%83%E5%B1%80">Sysroot 布局</a>已能在 <a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 1 环境</a>之后假定固定的相对路径的存在性。为简化规则，不使用<a href="Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">变量 <code>SHBuild_SysRoot</code></a> 的值指定入口。</li>
</ul>
<p>　　在以上通用的变量外，特定脚本使用不同的变量指定入口位置，默认值<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">由实现定义</a>（如通过脚本的接口规范指定）或未指定。</p>
<p>　　指定入口位置以外，定位解析的中间结果可被保存在由实现定义或未指定的变量中。</p>
<p><strong>注释</strong> 使用的变量一般被明确指定或至少指定变量名的模式(pattern) ，以便用户避免使用可能引发潜在冲突的无关的变量。</p>
<p>　　YSLib 提供的脚本的实现中，定位目标文件所在目录（以确定脚本所在路径）的一般策略如下：</p>
<ul>
<li>若目标文件在 SHBuild 构建环境和部署后环境中同时可用，且被当前脚本使用具有的可观察行为相同，同时相对当前脚本的位置唯一确定，使用当前脚本作为已知位置，以相对路径定位。
<ul>
<li><strong>原理</strong> 总是使用当前脚本的相对路径定位，因为需要兼容 SHBuild 构建环境，而部署后环境可用的脚本无法依赖<a href="Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">变量 <code>SHBuild_ToolDir</code></a> 的值指定目标文件所在的目录。</li>
</ul>
</li>
<li>否则，若目标文件是部署后环境中被部署的公开可执行程序，使用变量的值指定，其默认值对应指定其位置，是搜索路径定位的结果。
<ul>
<li>若目标文件是可执行程序 <code>SHBuild</code> ，使用<a href="Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">变量 <code>SHBuild</code></a> 。</li>
<li>否则，使用<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">由实现定义</a>的变量。</li>
<li><strong>注释</strong> 除 <code>SHBuild</code> 外仅可在部署后环境使用；确定默认值的方式和部署后环境的 <code>SHBuild</code> 相同。</li>
</ul>
</li>
<li>否则，若目标文件是 Sysroot 根路径指定的目录，使用 <code>SHBuild</code> 的位置的相对路径定位。</li>
<li>否则，若目标文件在 Sysroot 根路径指定的目录或子目录中，按 Sysroot 根目录的位置的相对路径定位目标文件。
<ul>
<li><strong>注释</strong> 另见 <a href="Development.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">NPLA1 环境变量</a>。</li>
</ul>
</li>
<li>否则，若目标文件是工具目录中的脚本目录，使用<a href="Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">变量 <code>SHBuild_ToolDir</code></a> 的值作为定位的结果。</li>
<li>否则，若目标文件在工具目录中的脚本目录中，按工具目录的位置的相对路径定位目标文件。</li>
<li>否则，若目标文件是存储库根目录，使用<a href="Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">变量 <code>YSLib_BaseDir</code></a> 的值作为定位的结果。</li>
<li>否则，若目标文件在存储库根目录或子目录中，按存储库根目录的位置的相对路径定位目标文件。
<ul>
<li><strong>注释</strong> 典型地，YSLib 存储库的工具目录外的源代码属于这种情形。</li>
</ul>
</li>
<li>否则，对每个目标文件，当前脚本可通过由实现定义的方式确定其位置的方式。
<ul>
<li><strong>注释</strong> 这是可选的。可能不通过公开文档指定，如使用注释。</li>
</ul>
</li>
<li>否则，目标文件的位置未指定。
<ul>
<li><strong>注释</strong> 一般仅在实现内部使用未指定唯一位置的文件，以避免影响约定的脚本程序的可观察行为。</li>
</ul>
</li>
<li><strong>注释</strong> 一般分别使用以上策略对不同目标文件定位。
<ul>
<li><strong>原理</strong> 即便脚本还依赖以下其它规则定位仅在部署后环境可用的目标文件，也不影响单独定位，以在支持尽可能多的配置组合同时减少规则的复杂性。</li>
<li><strong>示例</strong> 在 SHBuild 构建环境和部署后环境可用的公共脚本，不使用 <code>SHBuild</code> 以外的变量的值指定位置。</li>
</ul>
</li>
<li><strong>注释</strong> 通过变量定位时，原则上优先使用相对路径较简单的较近父目录的位置。
<ul>
<li><strong>原理</strong> 单独指定更上级目录的变量因此无效。这避免要求实现检查所有可能涉及的变量。</li>
</ul>
</li>
<li><strong>注释</strong> 一些目标文件的定位可作为其它文件的已完成的解析步骤。
<ul>
<li><strong>示例</strong> 通过定位确定工具目录位置后，可定位其中的其它文件。</li>
<li>这些定位不一定通过<a href="Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">周知的变量</a>访问，可能由实现定义或未指定。</li>
</ul>
</li>
</ul>
<p>　　定位所在的目录后，其中的脚本可基于所在目录的路径表达式构造路径指定位置。定位可在脚本中的不同位置中出现，应当满足依赖项的使用需求。</p>
<p><strong>原理</strong> 当存在多个<a href="Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">配置入口的不同环境变量</a>时，以上定位的规则能无歧义地指定其中<a href="Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">默认值</a>的生效方式。特别地，Sysroot 的布局蕴含 <code>SHBuild</code> 、Sysroot 根目录和目标文件的位置之间的相对路径是确定的，能保证唯一确定路径。</p>
<p><strong>警告</strong> 假定脚本定位的目标程序是支持的版本且不依赖其具体位置，否则调用目标程序的脚本行为未指定。特别地，混用不同版本的存储库或 Sysroot 对应的文件不被支持。</p>
<h2 id="shell-脚本"><a class="header" href="#shell-脚本">Shell 脚本</a></h2>
<p>　　扩展名 <code>.sh</code> 的脚本文件是 shell 脚本文件。大多数脚本需要使用 <a href="https://www.gnu.org/software/bash/">GNU Bash</a> 运行，如：</p>
<pre><code class="language-shell">#!/usr/bin/bash
</code></pre>
<p>　　需要考虑兼容性时，一般使用以下替代：</p>
<pre><code class="language-bash">#!/usr/bin/env bash
</code></pre>
<p>　　其它可以直接兼容 POSIX shell 的 <code>.sh</code> 脚本使用 Shebang 如：</p>
<pre><code class="language-shell">#!/usr/bin/sh
</code></pre>
<p>　　需要考虑兼容性时，一般使用以下替代：</p>
<pre><code class="language-shell">#!/usr/bin/env sh
</code></pre>
<p>　　若脚本可以确保兼容 POSIX shell ，使用 <code>sh</code> 而不是 <code>bash</code> 。</p>
<p>　　为简化脚本代码，用户需要保证调用 shell 脚本时，环境应满足以下条件，否则行为未指定：</p>
<ul>
<li>使用满足要求的 shell 语言实现：
<ul>
<li>对 Bash 脚本：
<ul>
<li>满足版本要求：<strong>当前最低版本为 <a href="https://www.gnu.org/software/bash/manual/">GNU Bash</a> 4.4 。</strong>
<ul>
<li><strong>注释</strong> 要求 4.0 保证能使用 <a href="https://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html#index-mapfile"><code>mapfile</code></a> 等 <a href="https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html">Bash 内建命令</a>。</li>
<li><strong>注释</strong> 要求 4.4 保证能使用 <code>${@@Q}</code> 等<a href="https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html">参数替换</a>。</li>
</ul>
</li>
<li>不使用 POSIX 兼容模式。</li>
</ul>
</li>
<li>对其它 POSIX shell 脚本：
<ul>
<li>使用符合 POSIX 的 shell ，或使用以上要求相同的 <code>bash</code> 运行 shell 脚本。</li>
</ul>
</li>
<li>可支持使用特定的公共非 POSIX 扩展：
<ul>
<li>使用 <a href="https://unix.stackexchange.com/questions/614808"><code>mktemp</code></a> 命令创建临时文件名。</li>
<li><strong>注释</strong> 这些扩展在应在受支持的<a href="Terminology.zh-CN.html#%E5%B9%B3%E5%8F%B0">平台环境</a>中可用。</li>
</ul>
</li>
<li><strong>注释</strong> 除非另行指定，不要求对 shell 环境进行检查。</li>
</ul>
</li>
<li>不论是否设置了变量 <code>POSIXLY_CORRECT</code> ，命令解释环境的变量满足：
<ul>
<li><a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_14">特殊内建工具</a>没有被用户定义的同名变量或别名覆盖。</li>
<li>被脚本调用的 POSIX 定义的工具命令没有被用户定义的同名变量或别名覆盖为调用时<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">可观察行为</a>不等价的实体。</li>
<li>变量 <code>IFS</code> 未设置或设置为默认值。</li>
</ul>
</li>
<li>命令解释器同 <code>bash</code> 的 <code>-p</code> 选项启用时效果相同。
<ul>
<li>用户应保证不设置 <code>CDPATH</code> 等 <code>-p</code> 忽略的<a href="Run.zh-CN.html">环境变量</a>及 <code>$BASH_ENV</code> 等启动文件，以避免未预期的不同行为。</li>
</ul>
</li>
<li>脚本文件不是目标在不同目录中的符号链接。
<ul>
<li>对 Bash 脚本，允许使用变量 <code>BASH_SOURCE</code> 的值（如 <code>${BASH_SOURCE[0]}</code> 或 <code>${BASH_SOURCE%/*}</code> 等形式） 较可靠地判断脚本文件的路径。此时，隐含需要附加假定通过脚本文件路径确定其它资源的位置。</li>
<li>部分脚本可能有更进一步的使用限制或不依赖 <code>.</code> 命令及命令解释器调用的差异。此时，可直接使用 <code>"$0"</code> 判断路径。</li>
</ul>
</li>
<li>除非另行指定，调用的外部命令的程序满足以下可用性要求：
<ul>
<li>以 POSIX 实用程序名称直接调用的满足 POSIX 对应的要求。</li>
<li>当前使用的 shell 的名称（如 <code>bash</code> ）总是能被 <a href="Development.zh-CN.html#%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F">POSIX <code>env</code> 实用程序</a>搜索到并调用。</li>
<li><code>/usr/bin/env</code> 总是提供可用的 POSIX <code>env</code> 实用程序。
<ul>
<li><strong>注释</strong> 这允许上述 Shebang 可用。同时，<code>/usr/bin/env</code> 作为命令名称一般等同于 <code>env</code> 。</li>
</ul>
</li>
<li><strong>注释</strong> <a href="Development.zh-CN.html#%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F">避免使用 <code>which</code></a>。</li>
</ul>
</li>
</ul>
<p>　　脚本实现中的调用不受以上限制。</p>
<p>　　若对应解释器位于其它目录，可通过符号链接以满足以上要求。</p>
<p><strong>注释</strong> 一般不检查解释器的路径是否指定一个符号链接。</p>
<p>　　除非另行指定，本文档约定使用的路径字符串的分隔符为 <code>/</code> ，不连续出现在路径中，且不在结尾出现。例外：</p>
<ul>
<li>平台相关的绝对路径转义可出现 <code>//</code> 。</li>
<li>构成路径的路径前缀可能以分隔符结尾，直接表示上层目录。</li>
</ul>
<p><strong>注意</strong> 当前版本库中的文件不保证跟踪权限。在一些环境中可能因为可执行权限问题导致无法立即执行脚本，参见<a href="GettingSources.zh-CN.html">这里的说明</a> 。</p>
<p>　　脚本可能执行 <code>set -e</code> 以及早发现错误，包括但不限于<a href="Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">变量的默认值</a>初始化失败。</p>
<p>　　<a href="Releases.zh-CN.html">正式支持的发布版本</a>中的公开 Shell 脚本应保证用 <a href="https://www.shellcheck.net/">ShellCheck</a> 0.7 或以上版本（任选）检查没有诊断消息。检查的命令行为 <code>shellcheck -x -P SCRIPTDIR</code> 跟随文件名。除非另行指定，使用明确的方式避免引起检查的问题而不是使用指令消除检查的结果，如使用 <code>${BASH_SOURCE[0]}</code> 代替 <code>$BASH_SOURCE</code> 以避免 <a href="https://www.shellcheck.net/wiki/SC2128">ShellCheck 警告 SC2128</a> 。</p>
<h3 id="shell-语言使用规约"><a class="header" href="#shell-语言使用规约">Shell 语言使用规约</a></h3>
<p>　　对 shell 命令语言和兼容方言的使用符合 <a href="Development.zh-CN.html#shell-%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83">shell 语言使用规范</a> 。</p>
<p>　　脚本程序不调整影响别名扩展的 shell 选项（如 Bash 的 <code>shopt -u expand_aliases</code> ）。</p>
<p>　　非生成的脚本源代码中不使用包含 <code>__</code> 的名称。</p>
<p>　　公开函数的函数名及公开的变量名<a href="Development.zh-CN.html#%E6%8E%A5%E5%8F%A3%E7%BA%A6%E5%AE%9A">不以 <code>_</code> 结尾</a>，否则以一个 <code>_</code> 结尾。</p>
<p>　　对 <a href="Tools/SHBuild.zh-CN.html">SHBuild</a> 相关工具使用的函数，使用前缀 <code>SHBuild</code> 。</p>
<p>　　函数出错且无法恢复时退出脚本。</p>
<p>　　版本库中的提供的脚本一般应能通过 ShellCheck 检查。对需要使用 <a href="https://github.com/koalaman/shellcheck/wiki/Directive">ShellCheck 指令</a>指定脚本起始构造的检查时，在之前添加一行空命令（对 Bash 脚本使用 <code>:</code> ，非 Bash 脚本命令使用 <code>true</code> ）以避免非预期地使指令作用于整个脚本。</p>
<h3 id="shell-变量"><a class="header" href="#shell-变量">Shell 变量</a></h3>
<p>　　除非另行指定，shell 脚本对变量的使用符合 <a href="Development.zh-CN.html#%E5%8F%98%E9%87%8F%E5%92%8C%E7%8E%AF%E5%A2%83">shell 代码对变量的规则</a>。</p>
<p>　　Shell 脚本可使用<a href="Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量</a>指定外部配置变量的值，即<em>外部变量(external variable)</em> 。</p>
<p><strong>示例</strong> Bash 命令 <code>_="${SHBuild:="$(type -P SHBuild)"}"</code> 初始化变量 <code>SHBuild</code> 的值<a href="Development.zh-CN.html#%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D%E7%9A%84%E5%AE%9E%E7%8E%B0">实现搜索 <code>$PATH</code> 的路径定位</a> <code>SHBuild</code> 命令。</p>
<p>　　Shell 的<em>内部变量(internal variable)</em> 在脚本之间使用，通过 <a href="Development.zh-CN.html#%E4%BA%92%E6%93%8D%E4%BD%9C"><code>.</code> 或 <code>source</code> 命令共享</a>。</p>
<p><strong>注释</strong> 外部变量和内部变量类似 C 语言标识符的链接。类似地，局部变量不是外部变量或内部变量。</p>
<p>　　以下内部变量具有公共的含义：</p>
<ul>
<li><code>INC_SHBuild_</code> ：用于指定标记已被检查<a href="Development.zh-CN.html#%E4%BA%92%E6%93%8D%E4%BD%9C">用 <code>.</code> 或 <code>source</code> 命令包含</a>的前缀。
<ul>
<li><strong>注释</strong> 类似 C 和 C++ 源程序中的守卫宏(macro name) 的名称。多次调用可能效果不同的脚本一般不使用。</li>
<li>这些变量不被设置为只读以支持显式地取消定义而重复包含脚本。</li>
</ul>
</li>
</ul>
<p>　　除非另行指定，外部变量总是允许指定通过环境变量值，内部变量总是能通过互操作共享值，但这些变量不一定被视为公开接口。</p>
<p>　　除指定入口的环境变量，是否支持外部可覆盖默认值的上述环境变量是可选的，取决于各个脚本的具体支持。</p>
<p>　　典型地，Shell 指定的环境变量可被以下方式在被 shell 运行的命令中使用：</p>
<ul>
<li>标记导出变量，在调用的命令访问变量：
<ul>
<li><a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_22"><code>export</code></a> 命令。</li>
<li><a href="https://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html#index-declare"><code>declare -x</code></a> 命令。</li>
<li>使用 <a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html"><code>set -a</code></a> 命令后的变量声明。</li>
</ul>
</li>
<li>启用子 shell(subshell) 或调用 shell 解释器等方式运行 shell 脚本或以下命令等方式使用当前环境或继承环境：
<ul>
<li><a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_18_01"><code>.</code></a> 命令。</li>
<li><a href="https://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html#index-source"><code>source</code></a> 命令。</li>
<li><a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#eval"><code>eval</code></a> 命令。</li>
</ul>
</li>
<li>临时指定特定的环境并调用命令：
<ul>
<li>使用 <a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/env.html"><code>env</code></a> 命令。</li>
<li>调用命令时以兼容 Bourne shell 的<a href="https://www.gnu.org/software/bash/manual/html_node/Environment.html">使用前缀参数赋值的命令调用</a>临时指定特定的环境。</li>
<li>使用 <a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html"><code>set -k</code></a> 命令后的参数赋值。</li>
</ul>
</li>
<li><strong>注释</strong> 另见 <a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_12">POSIX 命令执行环境</a> 和 <a href="https://www.gnu.org/software/bash/manual/html_node/Command-Execution-Environment.html">GNU Bash 命令执行环境</a>。</li>
</ul>
<p>　　关于这些环境变量如何影响其它程序，参见<a href="Run.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">运行时的环境变量</a>。</p>
<h3 id="shell-函数"><a class="header" href="#shell-函数">Shell 函数</a></h3>
<p>　　除非另行指定，shell 函数满足以下约定：</p>
<ul>
<li>已定义的 shell 函数假定不被其它变量覆盖。
<ul>
<li><strong>原理</strong> 这允许实现省略 <code>readonly -f</code> 或 <code>declare -g -r -f</code> 声明，且允许使用相同的定义覆盖以简化调试。</li>
</ul>
</li>
<li>Shell 函数返回值是通过接口语义中蕴含的最后的命令调用的返回值；或当不存在这样的命令时，默认为 <code>0</code> 。</li>
<li>Shell 函数的结果是标准输出的内容。
<ul>
<li><strong>注释</strong> 通常使用 <code>echo</code> 或功能蕴含 <code>echo</code> 的命令调用输出返回的值。</li>
</ul>
</li>
</ul>
<h3 id="文件定位的实现"><a class="header" href="#文件定位的实现">文件定位的实现</a></h3>
<p>　　定位<a href="Development.zh-CN.html#%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D">入口位置</a>的实现一般如下：</p>
<ul>
<li>使用当前脚本的相对路径定位：
<ul>
<li><strong>示例</strong> Bash 脚本可使用 <code>${BASH_SOURCE[0]}</code> 引用自身，使用 <code>$(dirname ${BASH_SOURCE[0]})</code> 表达被定位的目录，如：<code>. "$(dirname "${BASH_SOURCE[0]}")/SHBuild-common.sh"</code> 执行当前脚本目录下的 <a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-commonsh"><code>SHBuild-common.sh</code></a> 。</li>
<li><strong>示例</strong> Shell 脚本可使用 <code>"$0"</code> 指定自身位置，使用 <code>cd</code> 、<code>dirname</code> 和 <code>pwd</code> 解析构造的相对路径的结果。</li>
</ul>
</li>
<li>搜索路径定位：
<ul>
<li><strong>示例</strong> Bash 脚本可使用 <code>$(type -P program)</code> 指定 <code>program</code> 的位置。</li>
</ul>
</li>
</ul>
<h2 id="npla1-脚本"><a class="header" href="#npla1-脚本">NPLA1 脚本</a></h2>
<p>　　NPLA1 脚本可被 SHBuild 调用。SHBuild 支持特定的选项作为 NPLA1 的脚本解释器。脚本解释器支持 NPLA1 脚本文件。此外，在 shell 脚本中，NPLA1 脚本代码可能以字符串的形式存储和被 SHBuild 调用。</p>
<h3 id="npla1-环境变量"><a class="header" href="#npla1-环境变量">NPLA1 环境变量</a></h3>
<p>　　NPLA1 脚本可使用和 shell 脚本通用的环境变量，如 <code>SHBuild</code> 。</p>
<p>　　除 stage 1 外，shell 脚本使用环境变量 <code>NPLA1_ROOT</code> 指定的根目录路径表示 SHBuild 加载 NPLA1 脚本使用的<a href="Development.zh-CN.html#%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D">入口位置</a>。</p>
<p>　　脚本（包括直接或间接调用 NPLA1 脚本的其它脚本）除默认值外不需要依赖 Sysroot 的安装路径下的目录和文件布局，环境变量 <code>SHBuild</code> 和 <code>NPLA1_ROOT</code> 可分别指定相互无依赖的路径。当仅指定 <code>SHBuild</code> 时，通过指定的 SHBuild 路径推断 <code>NPLA1_ROOT</code> 默认值，此时使用假定符合 Sysroot 约定的相对路径。</p>
<p>　　NPLA1 脚本可使用以上约定含义和默认值的 shell 环境变量并初始化 NPLA1 脚本内的同名变量，但部分变量的作用域和初始化方式可能不同：</p>
<ul>
<li>在 Tools/Scripts/SHBuild-YSLib-common.txt 中直接初始化变量 <code>SHBuild_Env_Arch</code> 和 <code>SHBuild_Env_OS</code> 。</li>
<li>在 Tools/Scripts/SHBuild-YSLib-common.txt 的函数 <code>SHBuild_GetPlatformStrings</code>（详见版本库中的 <code>doc/NPL.txt</code>）的调用中初始化变量 <code>SHBuild_Host_Arch</code> 和 <code>SHBuild_Host_OS</code> 。</li>
</ul>
<p>　　注意在 NPLA1 脚本中创建的变量不是环境变量；但和 shell 脚本类似，若需作为其它外部命令的环境变量，可先导出再调用对应的程序。</p>
<h3 id="npla1-函数"><a class="header" href="#npla1-函数">NPLA1 函数</a></h3>
<p>　　NPLA1 脚本可提供部分 shell 脚本中的同名函数。除非另行指定，这些函数的调用接口以及功能和 shell 脚本中的同名函数一致，但实现和以下行为不保证相同：</p>
<ul>
<li>出错时的诊断方式。</li>
<li>缓存的变量及相关的输出提示信息。</li>
<li>性能。</li>
<li>影响的非公开环境变量等其它外部环境状态。</li>
</ul>
<p>　　作为公开接口的 NPLA1 函数另见 <code>doc/NPL.txt</code> 中的描述。</p>
<h2 id="构建脚本"><a class="header" href="#构建脚本">构建脚本</a></h2>
<p>　　一些开发脚本被用于构建。构建脚本的一般形式提供配置和生成阶段的自动化功能。</p>
<p>　　配置阶段设置交互环境。典型地，通过执行命令前设置的环境变量指定可配置项。</p>
<p>　　生成阶段调用合适的工具完成构建。</p>
<p>　　配置阶段的接口可能对外隐藏，此时使用默认配置进行构建。</p>
<p>　　一些公用的构建脚本可适用于整个项目。其它的构建脚本可构建具体子项目中的目标。</p>
<p>　　构建脚本可以是 makefile 或其它可执行的脚本。其中，makefile 可能使用以上约定含义的 shell 环境变量，但不保证可被外部指定覆盖脚本中指定的默认值。</p>
<h1 id="参考"><a class="header" href="#参考">参考</a></h1>
<ul>
<li>YSLib 项目文档 <code>doc/Dependencies.txt</code> 了解组织结构、开发规则、默认使用的外部依赖项（包括语言实现）和相关约定。</li>
<li><a href="Features.zh-CN.html">结构和特性</a> 中的树形结构了解项目依赖性。</li>
<li>YSLib 项目文档 <code>doc/ProjectRules.txt</code> 了解组织结构、开发规则和相关约定。</li>
<li>YSLib 项目文档 <code>doc/YBase.txt</code> 了解顶级子项目 YBase 。</li>
<li>YSLib 项目文档 <code>doc/YFramework.txt</code> 了解顶级子项目 YFramework 。</li>
<li>YSLib 项目文档 <code>doc/YSLib.txt</code> 了解 YFramework 的次级子项目 YSLib 。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="先决条件"><a class="header" href="#先决条件">先决条件</a></h1>
<p>　　本文档列出受支持的构建配置的关联的先决条件，以及这些环境下的已知问题和相关应对。</p>
<p><strong>注释</strong> 构建配置和平台的相关定义详见<a href="Terminology.zh-CN.html">术语</a>。对问题的描述可能仅适用于个别的配置和源代码版本。仅需要配置构建环境的用户可以跳过关于非目标平台和不相关的问题的内容。</p>
<p>　　特定历史版本依赖的详细环境和平台库版本参见开发文档 <code>doc/Dependencies.txt</code> 。以下仅为当前最新主分支版本中用于构建 YSLib 自身及基于 YSLib 开发应用的环境配置说明。</p>
<p>　　关于本项目对平台的定义和项目保持的环境约束，包括开发需要的以下基础环境外的其它第三方依赖，在了解下文内容后，参见<a href="Development.zh-CN.html">开发说明</a>。</p>
<p><strong>注意</strong> <a href="GettingSources.zh-CN.html">获取到源代码</a>并不保证能够直接构建 YSLib（特别是对于直接从版本库获取的途径）。如需自行构建，应注意<a href="ProjectDependencies.zh-CN.html#%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96%E9%A1%B9">项目依赖性中的外部依赖项</a>的说明。</p>
<p>　　关于<a href="Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">运行环境</a>，另见<a href="Run.zh-CN.html">运行时平台环境的说明</a>。</p>
<p>　　详细提交测试的环境参见开发文档 <code>doc/Test.txt</code> 。</p>
<p>　　若不使用特定的特性或构建平台，构建环境的部分要求是可选的。</p>
<p>　　以下各节的环境配置以“<a href="Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">宿主平台</a>/<a href="Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">目标平台</a>(目标平台名)”为标题指定，其中目标平台名是正式的配置名称（也在其它项目文档中作为配置名称使用），若和平台一致则被省略；其它平台的标识当前仅为明确开发流程，在用户文档中使用。对宿主平台和目标平台两者一致的情形，只标识一个平台。关于“平台”的一般含义，参见<a href="Terminology.zh-CN.html">术语</a>。</p>
<h2 id="公共构建环境"><a class="header" href="#公共构建环境">公共构建环境</a></h2>
<p>　　构建环境提供工具链（语言实现）和构建需要的工具。某些工具被不同的构建环境共享（但可能仍需针对不同构建平台使用不同二进制程序）。</p>
<p>　　Windows 平台上的 MSYS2 基础环境符合以下公共构建环境的所有要求。当前发布和一般提交（包括<a href="Terminology.zh-CN.html#%E8%BF%90%E8%A1%8C%E5%B9%B3%E5%8F%B0">本机平台</a>和<a href="Terminology.zh-CN.html#%E4%BE%9D%E8%B5%96%E5%92%8C%E5%A4%96%E5%BB%B6">交叉构建</a>）时仅测试 MSYS2 。</p>
<h3 id="命令行环境"><a class="header" href="#命令行环境">命令行环境</a></h3>
<p>　　除非另行指定，构建环境的命令兼容 POSIX shell 。当前非 POSIX shell 的命令行构建环境仅在 <a href="Sysroot.zh-CN.html">Sysroot stage 2 环境</a> 被支持。</p>
<h3 id="工具链"><a class="header" href="#工具链">工具链</a></h3>
<p>　　使用 <code>make</code> 的平台需要 POSIX shell 支持。</p>
<p>　　除非另行指定，<code>make</code> 使用 GNU make ，版本 3.78 以上（建议使用 4.0 以上版本，虽然 YSLib makefile 不使用不兼容的特性）；不使用 <code>mingw32-make</code> 。</p>
<p>　　POSIX shell 实现可使用<a href="Tools/Scripts.zh-CN.html">和工具脚本兼容的脚本解释环境</a> ，一般即 <code>bash</code> （建议版本 4.0 或以上）。</p>
<p>　　除非另行指定，直接支持的 C++ 实现为 GNU C++ 4.9 或以上版本。</p>
<p><strong>注意</strong></p>
<ul>
<li><code>make</code> 可能被构建工具使用，详见以下链接时优化的说明。</li>
<li>使用 <code>make</code> 的参数和可能处理的文件的路径名称中不支持空白符或冒号。
<ul>
<li><strong>原理</strong> 这是因为 <a href="https://savannah.gnu.org/bugs/index.php?func=detailitem&amp;item_id=712">GNU make 无条件把空格作为列表分隔符而不支持带有空格的字符串值作为参数</a>的限制。
<ul>
<li>使用<a href="https://lists.gnu.org/archive/html/help-make/2006-03/msg00007.html">多次替换变量值的变通</a>依赖<a href="https://lists.gnu.org/archive/html/help-make/2006-03/msg00010.html">路径名称中不含有的特定子串模式的假设</a>。</li>
<li>参数可能在生成路径名称使用。为了简化实现，不支持参数带有空白符。</li>
<li>尽管特定 make 函数如 <code>notdir</code> 在已知参数只有 1 个时可被 shell 命令 <code>basename</code> 替换，这依赖外部程序实现命令（在 GNU make 中 <code>basename</code> 不属于内建命令），为了简化环境假设且避免调用外部命令可能具有的开销，也不被支持。</li>
</ul>
</li>
<li>但在被调用 shell 的命令中，实现仍按 <a href="Development.zh-CN.html#shell-%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E8%A7%84%E7%BA%A6">shell 语言使用的约定</a>，支持命令行参数可能有空格的情形。</li>
</ul>
</li>
</ul>
<h3 id="二进制兼容性"><a class="header" href="#二进制兼容性">二进制兼容性</a></h3>
<p>　　一般地，<a href="Prerequisitions.zh-CN.html#%E5%B7%A5%E5%85%B7%E9%93%BE">工具链</a>生成的二进制文件遵循 <a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">ABI</a> 规范，在构建使用的配置和程序原代码不变时提供有限的兼容性，能允许混合不同来源工具链的构建。</p>
<p>　　尽管如此，不同的工具链仍可能隐含不同的配置或实现缺陷等问题而不能保证成功构建，这类情形在此不被支持。</p>
<p><strong>示例</strong> 依赖不同<a href="Prerequisitions.zh-CN.html#%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83">线程模型</a>或不同 <a href="Prerequisitions.zh-CN.html#%E9%93%BE%E6%8E%A5%E6%97%B6%E4%BC%98%E5%8C%96lto">LTO 配置</a>的工具链生成的代码之间不保证二进制兼容。</p>
<p>　　特别地，考虑到二进制库文件形式的<a href="ProjectDependencies.zh-CN.html#%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96%E9%A1%B9">外部依赖项</a>的<a href="Build.zh-CN.html#%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96%E9%A1%B9%E6%9E%84%E5%BB%BA">构建</a>可能仅适合特定工具链的默认配置，更换（包括某些情形时的升级）工具链可能破坏兼容性。</p>
<p>　　本项目提供的二进制文件可能隐含对这些特定工具链的依赖。这些特定的工具链在本文档以下具体支持的平台的描述中指定。</p>
<p>　　已知的因工具链的切换而破坏二进制兼容性的情形可能被指出。工具链的来源可能给出已知的不兼容变更。</p>
<p><strong>示例</strong> GCC 具有明确的 <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html">ABI 策略</a>。GCC 5 起 libstdc++ 支持<a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_dual_abi.html">双 ABI</a> ，为实现 ISO C++ 要求一般的工具链和基于这些工具链的系统发行版通常使用不和先前兼容的 ABI 选项。</p>
<p>　　当前已经使用的包括工具链的详细外部依赖项详见 YSLib 项目文档 <code>doc/Dependencies.txt</code> 。</p>
<p><strong>注意</strong></p>
<p>　　本节不是对 <a href="Features.zh-CN.html#abi">YSLib 自身的 ABI</a> 以及针对<a href="Releases.zh-CN.html">发布版本</a>的二进制文件之间的兼容性的保证。</p>
<h3 id="自动环境检测"><a class="header" href="#自动环境检测">自动环境检测</a></h3>
<p>　　在命令行环境中使用<a href="Tools/Scripts.zh-CN.html">脚本</a>构建时，脚本可能自动检测构建环境而需要附加的工具。这些工具可能在具体的构建环境（如以下各节）中可能已被提供或可选安装，参阅各个构建环境附带的文档。</p>
<ul>
<li><code>grep</code> ：用于判断线程支持的命令行选项。</li>
<li><code>uname</code> ：用于查询平台配置。</li>
</ul>
<p>　　使用特定的选项跳过自动检测构建时，可不依赖某些工具。详见具体脚本的说明。</p>
<h3 id="控制台和终端"><a class="header" href="#控制台和终端">控制台和终端</a></h3>
<p>　　除了自动检测环境（ Win32 或非 Win32 下使用 ANSI 转义序列）开启的彩色（前景色）文本，构建环境没有使用依赖特定终端的字符界面。因此可以使用不同的控制台或终端模拟器。</p>
<p><strong>注意</strong> 在 Windows 平台上若使用 ConEmu 出现 0xC0000005 错误，尝试<a href="https://code.google.com/p/conemu-maximus5/wiki/MicrosoftBugs">升级到最新版本后勾选 Inject ConEmuHk 选项</a> ，或直接使用 <code>cmd</code> 代替。</p>
<h3 id="线程执行环境"><a class="header" href="#线程执行环境">线程执行环境</a></h3>
<p>　　除非另行指定，线程执行环境使用 ISO C++ 的定义，参见 <a href="http://www.eel.is/c++draft/intro.multithread">ISO C++ [intro.multithread]</a> 。</p>
<p>　　库或接口的集合对多线程环境的依赖性满足以下要求：</p>
<ul>
<li>明确<strong>不依赖多线程执行环境</strong>时，保证在指定<a href="Terminology.zh-CN.html">平台</a>上可用的的公开 API 可构建并满足接口约定的语义，可在单线程执行环境中运行。</li>
<li>明确<strong>严格不依赖多线程执行环境</strong>时，在不依赖多线程执行环境的要求上，还应保证语义一致。</li>
<li>否则，不保证接口提供的功能可用。</li>
</ul>
<p>　　YSLib 整体不依赖多线程执行环境。特定的依赖多线程执行的情形包括以下话题：</p>
<ul>
<li>使用 ISO C++ 线程环境（首先要求实现满足<a href="Development.zh-CN.html">整体要求</a>）：
<ul>
<li>运行时环境需要部署的线程支持库，参见以下章节对各个平台的说明。</li>
<li>特定的依赖线程环境语义的接口，参见具体组件的开发文档（如 <code>doc/YSLib.txt</code> ）及源代码中的 API 注释或以此<a href="BuildDocumentation.zh-CN.html">构建 API 文档</a>。</li>
</ul>
</li>
<li>特定的平台实现使用非 ISO C++ 线程模型或实现（不保证<a href="Terminology.zh-CN.html">平台中立</a>）：
<ul>
<li>不会作为对所有平台必要的公开接口。</li>
<li>YCLib 提供 POSIX API 封装。</li>
<li>其它实现细节参见开发文档 <code>doc/YCLib.txt</code> 等。</li>
</ul>
</li>
</ul>
<h3 id="链接时优化lto"><a class="header" href="#链接时优化lto">链接时优化(LTO)</a></h3>
<p>　　YSLib 默认在 release 构建配置下通过向编译器和链接器传递命令行参数 <code>-flto</code> 等启用 LTO 。若工具链不支持 LTO ，可能需要自行修改脚本去除相关选项——这不被正式支持。</p>
<p>　　<a href="Prerequisitions.zh-CN.html#msys2">MSYS2</a> 的 MinGW 目标的 binutils-git 包的 <code>gnu-ar</code> 较早启用了 LTO 插件，可以直接使用。现在 MSYS2 的 MinGW 目标的 binutils 包也应支持。其它工具链需自行验证。</p>
<p><strong>注意</strong> <a href="http://gcc.gnu.org/gcc-4.9/changes.html">GCC 4.9 起使用 LTO 默认不启用 -ffat-lto-objects 选项</a>，因此需要链接器具有 LTO 插件支持，否则在启用 <code>-flto</code> 选项时会出现无法解析符号的链接错误。因为本项目当前只支持 GCC 5.0 以上的版本，使用 GCC 时这总是应当被注意。</p>
<p><strong>注意</strong> <a href="https://github.com/gcc-mirror/gcc/blob/master/gcc/lto-wrapper.c#L1309">GCC 的 LTO wrapper 默认使用 <code>make</code></a> ，若没有 <code>make</code> 也没有通过指定 <code>MAKE</code> <a href="Run.zh-CN.html">环境变量</a>替代，构建时使用 <code>-flto</code> 会失败。</p>
<h2 id="pcdsds"><a class="header" href="#pcdsds">PC/DS(DS)</a></h2>
<p>　　支持的构建环境：</p>
<ul>
<li>DS <a href="Terminology.zh-CN.html#%E4%BE%9D%E8%B5%96%E5%92%8C%E5%A4%96%E5%BB%B6">交叉编译</a>环境，包括：
<ul>
<li>使用 <code>make</code> 的公共构建环境。</li>
<li>ARM 目标平台 C/C++ 交叉编译环境。</li>
<li>生成 .nds 文件的 <code>ndstool</code> 工具。</li>
<li>环境变量 <code>DEVKITARM</code> 指定工具路径（见以下说明）。</li>
</ul>
</li>
</ul>
<p>　　在常见架构的 Windows 、Linux 和 macOS 宿主环境的交叉编译环境适用 <a href="http://devkitpro.org/">devkitPro</a> ，提供 devkitARM 工具链和相关的库。具体配置步骤可参见其<a href="https://devkitpro.org/wiki/Getting_Started">官方文档</a>。</p>
<p>　　支持的运行环境：</p>
<ul>
<li>Nintendo/iQue DS[Lite/i/LL] 。
<ul>
<li>仅测试了 iQue DS Lite 。</li>
</ul>
</li>
<li>DeSmuME 0.9.9 。
<ul>
<li><strong>注意</strong> 新版本因为<a href="http://wiki.desmume.org/index.php?title=Faq#How_can_I_run_homebrew_games_that_require_DLDI_patching_.3F">自动 DLDI</a> 存在缺陷，暂时不支持运行自制程序。</li>
</ul>
</li>
</ul>
<p>　　环境变量 <code>DEVKITPRO</code> 指定一个 POSIX 路径，其中的 <code>devkitARM/bin</code> 子目录下包括 devkitARM 工具链可执行文件。可选的环境变量 <code>DEVKITARM</code> 在 devkitPro 的示例项目的 Makefile 使用，当前 YSLib 已不再依赖。示例（ POSIX shell 使用 Windows 路径）：</p>
<pre><code class="language-shell">export DEVKITPRO=/C/devkitPro
export DEVKITARM=/C/devkitPro/devkitARM
</code></pre>
<p>　　Linux 宿主通过 <a href="https://devkitpro.org/wiki/devkitPro_pacman">devkitPro Pacman</a> 安装较新版本的 devkitPro 时，可配合登录 shell 运行的脚本（一般在 <code>/etc/profile.d/devkit-env.sh</code> ）初始化环境变量设置，典型内容为：</p>
<pre><code class="language-shell">cat
export DEVKITPRO=/opt/devkitpro
export DEVKITARM=$DEVKITPRO/devkitARM
export DEVKITPPC=$DEVKITPRO/devkitPPC

export PATH=$DEVKITPRO/tools/bin:$PATH
</code></pre>
<p>　　使用这种方式不再需要手动设置。这里同时修改了 <code>$PATH</code> 以提供 devkitPro 的工具（如 <code>ndstool</code> ），但 YSLib 项目默认不依赖工具链或其它工具在 <code>$PATH</code> 中可被搜索。</p>
<p>　　在 Windows 下，先前的 devkitPro 安装器提供集成 MSYS 环境，在 devkitPro 安装目录下 <code>msys/bin</code> 包含 <code>bash</code> 等程序。可把此路径添加到环境变量 <code>PATH</code> 。而近年的<a href="https://github.com/devkitPro/installer/releases/latest">图形化安装器</a>则直接打包修改的 MSYS2 。也可参照文档，复用 Windows 构建使用的 <a href="Prerequisitions.zh-CN.html#msys2">MSYS2 环境</a>。</p>
<p>　　发布和一般提交时仅测试 devkitPro 最新版本，目标平台<a href="Terminology.zh-CN.html#%E5%B9%B3%E5%8F%B0%E6%A0%87%E8%AF%86">三元组</a> <code>arm-none-eabi</code>（先前为简略形式 <code>arm-eabi</code> ） 。</p>
<p>　　devkitARM 工具链升级可引起二进制不兼容而需要重新构建生成的目标文件（尽管不一定需要构建二进制<a href="Terminology.zh-CN.html#%E5%86%85%E9%83%A8%E4%BE%9D%E8%B5%96%E5%92%8C%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96">依赖</a>）。除上游问题外，已知如下：</p>
<ul>
<li>自 <a href="https://devkitpro.org/viewtopic.php?t=9450">devkitPro 2023-04 更新</a> 发布 devkitARM r60 ，<a href="Prerequisitions.zh-CN.html#%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83">线程模型</a> 由 <code>single</code> 变更为 <code>posix</code> 。
<ul>
<li>这可能引起 <code>__STDCPP_THREADS__</code> 等 C++ 代码的语义变化而不保证向前兼容。</li>
<li>但 YSLib 没有在 DS 上依赖多线程执行，仍可向后兼容。</li>
</ul>
</li>
<li>自 <a href="https://devkitpro.org/viewtopic.php?t=9596">devkitPro 2024-05 更新</a> 发布 devkitARM r64 ，和之前的工具链生成代码二进制不兼容。
<ul>
<li>直接构建和现有二进制库链接时会出现未定义引用 <code>__aeabi_read_tp</code> 的链接错误。
<ul>
<li>符号 <code>__aeabi_read_tp</code> 来自 <a href="https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html">ARM GCC 生成的线程局部存储的软实现</a>。</li>
<li>一般地，这个符号的定义的实现在 <code>libgcc</code> 中提供，发行版中通常以提供 libc 更新的方式提供。但同时更新的 crtls 1.2.5 包 <code>devkitarm-crtls-1.2.5-1</code> 并没有这个符号的定义，本机 TLS 实际上不可用。</li>
<li>直至 <a href="https://devkitpro.org/viewtopic.php?t=9662">devkitPro 2024-11 更新</a> 发布 libnds 2.0.0 依赖 <a href="https://github.com/devkitPro/calico">Calico</a>提供这个符号的定义，如 <code>libcalico_ds9.a</code> 。</li>
</ul>
</li>
<li>这个版本的工具链没有被 YSLib 正式支持，但之后的工具链仍需兼容保持其配置，并更新 libnds 2.0.0 支持（需要适配其它特性如定时器）。</li>
</ul>
</li>
<li>devkitARM 工具链和相关的包需要同步升级，部分升级可引起二进制不兼容而不被支持，如：
<ul>
<li>除非同时更新 devkitARM r64 或之后的版本，单独更新包 <code>devkitarm-crtls-1.2.5-1</code> 和旧版本工具链生成的二进制文件不兼容，错误：<code>arm-none-eabi-g++: fatal error: cannot read spec file 'sync-none.specs': No such file or directory</code> 。
<ul>
<li>这在 <a href="https://gcc.gnu.org/git/?p=gcc.git;a=commit;h=439779bacee869643c93a4710a29f89ad031ee4a">ARM GCC 14 的 <code>libgcc</code> 提供</a>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="pcwin32"><a class="header" href="#pcwin32">PC(Win32)</a></h2>
<p>　　Windows 平台使用 Microsoft VC++ 构建。因为一些已知的问题，暂不正式支持。参见以下 MinGW32 平台的构建条件以获取 Windows 可执行文件。</p>
<p>　　但以下的部分信息和 MinGW 通用。</p>
<h3 id="windows-子系统"><a class="header" href="#windows-子系统">Windows 子系统</a></h3>
<p>　　<a href="http://zh.wikipedia.org/zh-cn/Windows_NT%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">Windows NT 内核以上支持不同的称为<em>子系统(subsystem)</em> 的用户模式运行时环境</a> ，主要包括 Win32 子系统、OS/2 子系统和 POSIX 子系统。</p>
<p>　　因为标准库实现以及 YFramework 的部分组件依赖 Win32 API ，YSLib 在 Windows 上的实现依赖 Win32 子系统。</p>
<p>　　Microsoft Visual C++ 提供 <a href="http://msdn.microsoft.com/zh-cn/library/fcc1zstk.aspx"><code>/SUBSYSTEM</code> 链接器选项</a>来指定不同的子系统。在此 <code>CONSOLE</code> 指定控制台程序，而 <code>WINDOWS</code> 指定非控制台的通常使用 GUI 的程序，它们都使用 Win32 子系统实现。</p>
<p>　　控制台程序和 GUI 程序的入口不同，也有一些行为上的不同。例如，启动控制台程序默认会显示命令行窗口；GUI 程序忽略命令行的交互式输入。</p>
<h3 id="操作系统版本"><a class="header" href="#操作系统版本">操作系统版本</a></h3>
<p>　　Windows 操作系统版本一般对（非交叉编译的）构建没有直接影响，但有以下例外：</p>
<p>　　GCC 的<strong>预编译头文件不保证对系统兼容</strong>：升级系统后可能出现错误，例如升级 Windows 10 1803 以后的系统，使用旧的预编译头文件（而不更改编译器二进制文件），可能出现以下内部错误：</p>
<pre><code class="language-text">internal error in mingw32_gt_pch_use_address, at config/i386/host-mingw32.c:184: MapViewOfFileEx: 试图访问无效的地址。
</code></pre>
<p>　　此时删除所有预编译头文件，或不使用预编译头文件重新构建即可。类似的问题在其它的项目中<a href="https://jira.reactos.org/browse/CORE-8053">也是已知的问题</a>，使用类似的方式解决。</p>
<p>　　另外，<a href="https://github.com/msys2/MINGW-packages/issues/5067">部分 Windows 版本可能存在不明原因的内核缺陷导致类似的问题</a>。不仅限于构建，这些问题可能对运行也有影响。</p>
<p>　　硬件故障（如有缺陷的物理内存）也可能导致类似的故障，但这和使用的操作系统版本无关。</p>
<h3 id="预编译头文件"><a class="header" href="#预编译头文件">预编译头文件</a></h3>
<p>　　部分构建使用可选的预编译头文件。</p>
<h2 id="pcmingw32"><a class="header" href="#pcmingw32">PC(MinGW32)</a></h2>
<p>　　MinGW32 包含 32 位和 64 位<a href="Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">宿主和目标平台</a>。关于 MinGW 或 MinGW32 的称谓，参见<a href="https://github.com/FrankHB/pl-docs/blob/master/zh-CN/mingw-vs-mingw-v64.md">这里</a>的说明。</p>
<p>　　支持的构建环境：</p>
<ul>
<li>目标 32 位(i686) MinGW GCC 工具链。
<ul>
<li>支持不同的 MinGW 运行时
<ul>
<li><a href="https://sourceforge.net/projects/mingw-w64/">MinGW-W64</a> （目标平台<a href="Terminology.zh-CN.html#%E5%B9%B3%E5%8F%B0%E6%A0%87%E8%AF%86">三元组</a> i686-w64-mingw32 ）。</li>
<li><a href="http://mingw.org/">MinGW.org</a> （目标平台三元组 i686-pc-mingw32 ）</li>
</ul>
</li>
<li>要求标准库多线程支持，否则只支持构建 YBase ，不支持构建 YFramework 。
<ul>
<li>当前 <a href="https://gcc.gnu.org">GCC 官方</a>的 libstdc++ 只提供 POSIX 线程模型的支持，不支持 Win32 线程模型。</li>
<li>可考虑使用 <a href="https://github.com/lhmouse/mcfgthread">mcfgthread</a></li>
</ul>
</li>
<li>仅测试 Windows 上的本机构建（构建平台三元组同目标平台三元组）。
<ul>
<li>一般提交时仅测试 MinGW-W64 的发行版。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　非正式支持的构建环境：</p>
<ul>
<li>目标 64 位(x86_64) MinGW GCC 本机工具链（宿主和目标平台三元组 x86_64-w64-mingw32 或 x86_64-pc-mingw32 ）。</li>
<li>以上工具链中使用 LLVM 和 Clang++ 代替 GCC 。
<ul>
<li>仅测试 MSYS2 的 <code>MSYSTEM</code> 为 <code>MINGW32</code> 和 <code>MINGW64</code> 替换 GCC 。</li>
<li>虽然可支持，没有测试 <code>MSYSTEM</code> 为 <code>CLANG32</code> 和 <code>CLANG64</code> 的工具链。</li>
<li>当前 32 位平台暂不支持 LLD（ MSYS2 包 <code>mingw32/mingw-w64-i686-lld</code> ）。</li>
</ul>
</li>
<li>虽然可支持，没有测试 <code>MSYSTEM</code> 为 <code>UCRT64</code> 的工具链。</li>
<li>暂不在配置<a href="Tools/Scripts.zh-CN.html">脚本</a>以外支持和测试 <code>MSYSTEM</code> 为 <code>CLANGARM64</code> 的工具链（宿主平台三元组 aarch64-w64-mingw32 ）。</li>
</ul>
<p>　　对 i686 平台，存储库中 <code>YFramework/MinGW32/lib-i686</code> 目录用于保存外部依赖项 FreeType2 和修改版 FreeImage 的二进制文件。</p>
<p>　　对 x86_64 平台，需要自行编译依赖项。若构建环境存在可二进制兼容的 FreeType2 ，只需要编译修改版本的 FreeImage 。</p>
<p>　　支持的运行环境：</p>
<ul>
<li>Microsoft Windows XP 或以上版本的操作系统。
<ul>
<li>对于 64 位目标工具链构建的程序，需要 64 位操作系统。</li>
<li>当前默认发行的二进制文件使用 MSYS2 环境（详见以下小节）构建，要求 Microsoft Windows 7 64 位或以上版本的操作系统。</li>
</ul>
</li>
<li>构建环境匹配的附加运行库，默认支持的工具链要求包括以下动态库文件：
<ul>
<li><code>libwinpthread-1.dll</code></li>
<li><code>libgcc_s_dw2-1.dll</code></li>
<li><code>libstdc++-6.dll</code></li>
<li><code>libquadmath-0.dll</code>（自 build 932 起）</li>
</ul>
</li>
</ul>
<p>　　注意以上运行库未在发布版本中打包。此处依赖的详细说明参见开发文档 <code>doc/Dependencies.txt</code> @1.5.2 。</p>
<p>　　若缺少 DLL ，也可在 MinGW32 GCC 发行版中的 <code>bin</code> 目录下找到。</p>
<p><strong>特别注意</strong> 应使用对应的正确的线程模型（使用 POSIX 或 MCF 而不是 Win32 ，后者没有实现标准库的线程支持）以及异常模型（ i686 为 Dwarf2 和 SjLj 之一，特定构建版本相关）。运行时 DLL 不匹配会导致错误。</p>
<h3 id="msys2"><a class="header" href="#msys2">MSYS2</a></h3>
<p>　　建议使用 <a href="http://msys2.org/">MSYS2</a> 环境。</p>
<p>　　MSYS2 以从 <a href="https://wiki.archlinux.org/index.php/Main_page_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">Arch Linux</a> 移植的 <a href="https://wiki.archlinux.org/index.php/Pacman_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">pacman</a> 作为包管理器，可以直接通过命令行安装和移除不同的包，包括开发工具。</p>
<p>　　以下环境也可用于开发其它 MSYS2 或 MinGW32 应用（忽略标注为 YSLib 的步骤即可）。</p>
<h4 id="体系结构和命令行调用"><a class="header" href="#体系结构和命令行调用">体系结构和命令行调用</a></h4>
<p>　　一个 MSYS2 环境同时支持 MSYS2 和 i686(x86) 和 x86_64(x64) 的 MinGW32 三个目标平台。其中 MSYS2 目标类似 <a href="https://www.cygwin.com/">Cygwin</a> ，运行时依赖特定的 POSIX 兼容层 DLL （这里一般是 msys-2.0.dll ），性能往往较依赖 <a href="https://msdn.microsoft.com/library/abx4dbyh.aspx">MSVCRT</a> （默认版本现在 Windows 系统中应都已存在部署）的 MinGW32 目标低。所以不需要严格的 POSIX 兼容的应用尽量使用 MinGW 而不是 MSYS2 目标。</p>
<p>　　MSYS2 自身也存在不同的体系结构而成为目标平台。和 MinGW32 不同，每个基础环境是 i686 和 x86_64 之一。在 x64 Windows 上，可以通过部署多个基础环境，合理设置环境变量 <code>PATH</code> 来切换使用 i686 或 x86_64 （而 32 位 Windows 只支持 i686 ）路径；但一般情形下只需要使用其中之一。这个决定一般会作用到所有 MSYS2 程序，如 <code>bash</code> 。</p>
<p>　　不论是 i686 还是 x86_64 的 MSYS2 基础环境，都可以选择安装 i686 或 x86_64 的 MinGW32 目标的包，但因为使用不同的 MSYS2 程序，两者并非可完全替换。</p>
<p><strong>注意</strong> 因为基础环境中 <code>uname</code> 是位于 <code>/usr/bin</code> 的 MSYS2 程序，基础环境的体系结构会影响 <code>uname</code> 的结果而导致目标体系结构的自动判断结果不同，当前可能会影响后续需要的命令，详见 <a href="Sysroot.zh-CN.html">MinGW Sysroot 开发指令</a>。</p>
<p><strong>注意</strong> MSYS2 程序和不同体系结构的（本机或其它 MSYS2 ）程序混用可能出现问题。参见下文关于 MSYS2 程序运行问题的说明。</p>
<p>　　一个 MSYS2 环境中可能同时存在不同目标的程序，通过合理控制环境变量 <code>PATH</code> 的顺序或在调用时加前缀(prefix) 控制。例如 <code>/usr/bin/gcc.exe</code> 和 <code>/mingw32/bin/gcc.exe</code> 可能同时存在，分别是 MSYS2 和 i686 MinGW32 的 GCC ，可通过以下方式确定调用 MinGW32 GCC ：</p>
<ul>
<li>在 <code>PATH</code> 中使 <code>/mingw32/bin</code> 尽量靠前来指定 <code>gcc</code> 调用 MinGW32 而不是 MSYS2 GCC</li>
<li>若存在 <code>i686-w64-mingw32-gcc</code> 等明确目标平台的版本，一般可以直接在命令行中代替 <code>gcc</code></li>
<li>明确路径前缀，即使用 <code>/mingw32/bin/gcc</code> 代替 <code>gcc</code></li>
</ul>
<p>　　某些工具可能在附加路径前缀 <code>/mingw32</code> 指定此类程序的安装位置。但当前 YSLib 不提供工具控制这些部署方式，默认只使用第一种方式：手动配置 <code>PATH</code> 。</p>
<p>　　MSYS2 MinGW 工具链使用 POSIX 线程模型。</p>
<p>　　MSYS2 MinGW i686 工具链使用 Dwarf2 异常模型。</p>
<p>　　当前 YSLib 不支持 MSYS 目标。</p>
<h4 id="主要配置步骤"><a class="header" href="#主要配置步骤">主要配置步骤</a></h4>
<p>　　（某些步骤和原理也可参考<a href="https://sourceforge.net/p/msys2/wiki/MSYS2%20installation/">官方 Wiki</a> 。）</p>
<ul>
<li>进入<a href="https://sourceforge.net/projects/msys2/files/Base/">官方发布站点</a>/<a href="http://mirror.bit.edu.cn/msys2/Base/">北京理工大学镜像</a>/<a href="https://mirrors.tuna.tsinghua.edu.cn/msys2/distrib/">清华大学 TUNA 镜像</a>/<a href="http://mirrors.ustc.edu.cn/msys2/distrib/">中国科学技术大学开源软件镜像</a>的其中一个子目录下载 MSYS2 基础环境：
<ul>
<li>目录 <code>i686</code> 和 <code>x86_64</code> 针对 MSYS2 而非 MinGW32 目标。</li>
<li>一般尽量选择较新的 <code>x86_64</code> 版本。</li>
<li>如果有能解压缩 <code>.xz</code> 的软件，可以直接下载压缩包，否则选择 <code>.exe</code> 文件；对应版本内容一致。</li>
</ul>
</li>
<li>安装 MSYS2 基础环境到自定义的目录如 <code>C:\msys2</code> （以下称为<strong>MSYS2 根目录</strong>）。
<ul>
<li>注意 Win32 下 <code>PATH_MAX</code> 为 <code>260</code> ，此处最好避免过长的路径以使一些软件具有更好的兼容性。</li>
<li>对压缩包直接利用现有工具解压；对可执行文件直接执行安装。</li>
<li>之后，<strong>必须</strong>执行 MSYS2 根目录下的 <code>msys2_shell.bat</code> 确保完成安装。</li>
</ul>
</li>
<li>设置环境变量：
<ul>
<li>可总是使用 MSYS2 根目录下自带的批处理文件打开 终端（默认是 <code>mintty</code> ），会自动在终端环境的 <code>PATH</code> 变量前加入对应所需的路径，不需要另行设置。
<ul>
<li>对较新的版本（安装了 <code>filesystem-2016.05-2</code> 或更新版本的包）的 MSYS2 基础环境安装，分别运行启动脚本 <code>msys2_shell.cmd -msys</code> 、<code>msys2_shell.cmd -mingw32</code> 和 <code>mingw64_shell.cmd -mingw64</code> 进入对应的 MSYS2 、MinGW32 和 MinGW64 的 shell 。</li>
<li>对未更新 <code>filesystem-2016.05-2</code> 或更新版本的包的 MSYS2 旧版本基础环境安装，分别运行启动脚本 <code>msys2_shell.cmd</code> 、<code>mingw32_shell.bat</code> 和 <code>mingw64_shell.bat</code> 进入对应的 MSYS2 、MinGW32 和 MinGW64 的 shell 。</li>
</ul>
</li>
<li>也可直接一次性设置 Windows 系统环境变量，这样可以对其它命令行环境（如 <code>cmd</code> ）生效。
<ul>
<li><strong>注意</strong> 环境变量的值需要符合 Windows 的路径格式，每个路径之间以分号分隔。</li>
<li>需要设置 <code>bash</code> 所在的 MSYS 工具的目录（即 MSYS2 根目录下的 <code>/usr/bin</code> ）以及 MinGW 目标编译器和其它工具所在的目录（对 32 位的目标为 MSYS2 根目录下的 <code>/mingw32/bin</code> ）。</li>
<li><strong>注意</strong> 因为 MSYS 和 MinGW 是不同的目标，使用不同的 GCC （可能被同时安装），需要保证 MinGW 编译器被优先搜索，所以 MinGW 目录一般应在 MSYS 目录之前。</li>
</ul>
</li>
<li><a href="http://sourceforge.net/p/msys2/tickets/4/">一些构建环境可能会依赖环境变量 <code>MSYSTEM</code> 的值，MSYS2 根目录批处理文件进入的不同环境对此有不同的设置</a>。YSLib 中的构建脚本可使用此变量判断平台。MSYS2 中对应的启动脚本会自动完成这些设置。</li>
</ul>
</li>
<li>确保能搜索到正确的 MinGW 编译器。
<ul>
<li>可以进入 Shell 执行命令 <code>type -P gcc</code> ，确定输出的结果为 MinGW 编译器（默认为 <code>/mingw32/bin/gcc.exe</code> 和 <code>/mingw64/bin/gcc.exe</code> 之一）而不是 MSYS 编译器（默认为 <code>/usr/bin/gcc.exe</code> ）</li>
<li>若已确保 MSYS 根目录下 <code>/usr/bin</code> 目录在环境变量 <code>PATH</code> 中，直接进入 <code>cmd</code> 或 Shell 直接执行 <code>which gcc</code> ，方法和效果与上述方法相同</li>
<li>可以直接在命令行执行 <code>gcc -v</code> 查看输出，确认 <code>Target:</code> 带有后缀 <code>-w64-mingw32</code></li>
</ul>
</li>
<li>建议手动执行 <code>pacman -Syu</code> 自行升级，或 <code>pacman -S</code> 安装所需的包的最新版本</li>
<li>若用于构建 YSLib ，建议<a href="GettingSources.zh-CN.html">获取源代码</a>后，进入 <code>bash</code> （此处也可以使用其它 Shell ）后运行 POSIX Shell 脚本 <code>Tools/msys2-pacman-update.sh</code> 以确保 YSLib 构建需要的依赖项被安装
<ul>
<li>脚本不会重复安装已经安装的包</li>
</ul>
</li>
</ul>
<p>　　上述脚本调用 MSYS2 的包管理器 <code>pacman</code> 分批下载安装或更新所需工具：首先安装必要的工具，其次安装可选（但推荐）的工具。具体内容详见脚本代码。若安装工具时需要确认，按 <code>Y</code> 并回车。</p>
<h4 id="配置安装源"><a class="header" href="#配置安装源">配置安装源</a></h4>
<p>　　官方镜像配置参见 <a href="https://github.com/msys2/MSYS2-packages/tree/master/pacman-mirrors">pacman-mirrors</a> 。</p>
<p>　　若 <code>pacman</code> 下载过慢，可用文本编辑器打开 MSYS 根目录下的 <code>/etc/pacman.d</code> 中的配置文件，编辑对应的镜像地址。若没有修改过 <code>/etc/pacman.conf</code> 中的配置，默认配置文件由包 <code>pacman-mirrors</code> 指定，需编辑 <code>/etc/pacman.d/mirrorlist.mingw</code> ，如：</p>
<pre><code class="language-text">## 清华大学 TUNA 镜像
Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/$repo
## 北京外国语大学开源软件镜像站
Server = https://mirrors.bfsu.edu.cn/msys2/mingw/$repo
## 浙江大学开源镜像
Server = https://mirrors.zju.edu.cn/msys2/mingw/$repo
## 中国科学技术大学开源软件镜像
Server = https://mirrors.ustc.edu.cn/msys2/mingw/$repo
</code></pre>
<p>　　这里的 <code>$repo</code> 自适应 MinGW32 和其它 MinGW 环境。</p>
<p><strong>注释</strong> <a href="https://github.com/msys2/MSYS2-packages/commit/3553fd197b070589eeb656d1d5dc55ae77d68087">自 2021-07-02</a> ，不同的 MinGW 镜像的配置文件被合并，包 <code>pacman-mirrors</code> 的安装脚本兼容原有的镜像文件列表，重命名仓库名（最底层子目录）<code>i686</code> 和 <code>x86_64</code> 为 <code>mingw32</code> 和 <code>mingw64</code> 。自 2024-11-11 旧的子目录名在远端已不提供。若以往编辑过 <code>/etc/pacman.conf</code> 指向和 <code>pacman-mirrors</code> 默认安装的不同的配置文件，需要手动编辑。如使用先前的配置文件，对 32 位的 MinGW 包，可在 <code>mirrorlist.mingw32</code> 对应编辑，替换以上的 <code>$repo</code> 为 <code>mingw32</code> 。</p>
<p>　　因为包 mingw-w64-x86_64-freetype 的 FreeType2 可二进制兼容，x86_64 平台（即 <code>mingw64</code> ）只需要编译修改版本的 FreeImage 。</p>
<h4 id="msys2-程序运行问题"><a class="header" href="#msys2-程序运行问题">MSYS2 程序运行问题</a></h4>
<p>　　MSYS2 类似 Cygwin ，依赖 <code>fork</code> 调用创建新进程。这可能会出错。</p>
<p>　　在执行以下步骤（参考<a href="http://sourceforge.net/p/msys2/tickets/74/">这里</a>）后，重新运行程序：</p>
<ul>
<li>关闭窗口或用任务管理器终止 <code>sh.exe</code> 和 <code>bash.exe</code> 等进程并尽量确保没有基于 MSYS2 环境的其它程序正在被运行</li>
<li>执行 MSYS 根目录下的 <code>autorebase.bat</code></li>
</ul>
<p>　　也可以参考 <a href="https://www.cygwin.com/faq.html#faq.using.fixing-fork-failures">Cygwin 的解决方法</a>。</p>
<p>　　混用 x86/x64 程序（不管是 Win32 还是 MSYS 程序）导致的类似问题可能经以上步骤仍然无法修复，这可由 MSYS2 <a href="http://sourceforge.net/p/msys2/tickets/208/">在特定操作系统上的一个缺陷</a>引起。变通做法是只使用固定目标的程序，例如只使用 i686 MSYS 基础系统执行 i686 MinGW32 GCC 。注意 i686 MinGW32 GCC 是 x86 的 Win32 程序。尽管它不是 MSYS2 程序，但可在 LTO 时调用 MSYS2 程序 <code>make</code> ，这时候可能出错。</p>
<p>　　如果确定只使用少数程序，在命令行指定替换。例如 x86_64 的 MSYS2 bash 环境中使用 i686 MinGW32 GCC ，指定 LTO 调用的 <code>make</code> ：</p>
<pre><code class="language-shell">export MAKE=/path-to-another-msys2-root/mingw32/make
</code></pre>
<p>　　或直接替换所有 <code>make</code> ：</p>
<pre><code class="language-shell">export make=/path-to-another-msys2-root/mingw32/make
</code></pre>
<p><strong>注意</strong> <code>%SystemRoot%\System32\cmd.exe</code> 在 x64 Windows 下是 x64 程序，对应的 x86 版本是 <code>%SystemRoot%\SysWOW64\cmd.exe</code> 。</p>
<h3 id="gcc-with-the-mcf-thread-model"><a class="header" href="#gcc-with-the-mcf-thread-model">GCC with the MCF thread model</a></h3>
<p>　　也可使用 <a href="https://gcc-mcf.lhmouse.com/">MCF 线程模型构建的 GCC</a> ，基于 MinGW-W64 和 mcfgthread ，使用 MCF 线程模型。</p>
<p>　　这个发行版没有 <code>make</code> 。</p>
<p>　　需自行编译依赖项。</p>
<p>　　未在提交中测试。</p>
<h3 id="mingw-builds"><a class="header" href="#mingw-builds">MinGW-Builds</a></h3>
<p>　　也可使用 <a href="http://mingw-w64.sourceforge.net/">MinGW-W64</a> 发行版，如 <a href="http://sourceforge.net/projects/mingw-w64/files/latest/download">mingw-builds</a> ，并自行获得和配置脚本 <code>Tools/msys2-pacman-update.sh</code> 中被安装的工具。</p>
<p>　　需使用基于 POSIX 线程模型的版本，否则只可用 YBase 。</p>
<p>　　需自行编译依赖项。</p>
<p>　　当前未测试。</p>
<h3 id="nuwennet"><a class="header" href="#nuwennet">Nuwen.net</a></h3>
<p>　　对 x86_64 平台可使用 <a href="http://nuwen.net/mingw.html">newen.net</a> 提供的 MinGW 发行版，包含比较多的第三方库。</p>
<p>　　仍需自行编译依赖项以支持 YFramework （当前不支持）。</p>
<p>　　因为 15.2 之前的版本仅支持 Win32 线程模型，不支持 <code>std::thread</code> 等标准库线程 API ，不支持生成 YFramework ，只支持生成 YBase 。</p>
<p>　　当前未测试。</p>
<h3 id="windows-子系统-1"><a class="header" href="#windows-子系统-1">Windows 子系统</a></h3>
<p>　　基本内容参见以上 <a href="Prerequisitions.zh-CN.html#pcwin32">PC(Win32) 平台</a>关于 <a href="Prerequisitions.zh-CN.html#windows-%E5%AD%90%E7%B3%BB%E7%BB%9F">Windows 子系统</a>的介绍。</p>
<p>　　在 MinGW 工具链的命令行中，选项 <code>-mconsole</code> 和 <code>-mwindows</code> 对应 Microsoft VC++ 工具链的子系统选项。若没有指定，一般默认为前者。通常 <code>-mwindows</code> 隐式使用一些附加的库，如 <code>-lgdi32 -lcomdlg32</code> 。和 VC++ 不同，当前使用的 MinGW 实现一般可以支持统一使用 <code>main</code> 作为入口，不需要特别修改。</p>
<p>　　对 <code>gcc</code> 或 <code>g++</code> ，使用 <code>-dumpspecs</code> 查看内建支持的 specs 。Clang/Clang++ 不适用 specs ，需要查看文档和源代码。</p>
<h2 id="pcandroid"><a class="header" href="#pcandroid">PC/Android</a></h2>
<p>　　支持的构建环境：</p>
<ul>
<li>Android 开发环境（仅测试 Windows x64 <a href="Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">宿主环境</a>），包括：
<ul>
<li>使用 <code>make</code> 的公共构建环境。</li>
<li>JDK（仅测试 Oracle JDK 1.8 ；注意 Android 仅支持部分 Java 8 特性）。</li>
<li>Android SDK 。</li>
<li>Android SDK Build-tools 。</li>
<li>Android NDK （仅使用独立工具链）。</li>
<li>用于打包 APK 的私钥（用 Tools/create-android-debug-keystore.sh 可生成默认私钥）。</li>
</ul>
</li>
</ul>
<p>　　支持的运行环境：</p>
<ul>
<li>Android 模拟器，运行操作系统 Android 5 （对应 API level 21 ），或更高版本（未测试，可能有兼容性问题）。</li>
<li>物理设备，操作系统要求同上（未正式测试，可能有兼容性问题）。</li>
</ul>
<h2 id="pclinux"><a class="header" href="#pclinux">PC/Linux</a></h2>
<p>　　当前仅用于可移植性测试。要点：</p>
<ul>
<li>当前仅测试 x86-64 （提供 FreeImage 二进制文件）</li>
<li>可用被支持版本的 G++ 或 Clang++</li>
<li>因为不提供 freetype2 的二进制库，需要保证 freetype2 库文件可用，可以通过 <code>pkg-source</code> 找到或位于 <code>/usr/lib</code> 路径中</li>
<li>使用 XCB 作为系统库，但功能不全</li>
</ul>
<p>　　Windows 10 可使用 <a href="https://zh.wikipedia.org/zh-cn/Windows_Subsystem_for_Linux">WSL(Windows Subsystem for Linux)</a> 。</p>
<p>　　注意 Windows 10 秋季创意者更新（版本 1709 ）的 WSL 存在<a href="https://github.com/Microsoft/WSL/issues/2606">已知可导致并行构建失败的缺陷</a> ，以及可能有的<a href="https://github.com/Microsoft/BashOnWindows/issues/2534">其它问题</a> ，本项目不针对这些问题单独提供变通。</p>
<h1 id="其它构建环境"><a class="header" href="#其它构建环境">其它构建环境</a></h1>
<p>　　集成开发环境是可选的，参见<a href="Build.zh-CN.html">构建</a>。</p>
<p>　　关于文档构建需要的依赖，参见<a href="BuildDocumentation.zh-CN.html">构建文档</a>。</p>
<p>　　关于执行工具脚本需要的环境，参见<a href="Tools/Scripts.zh-CN.html">脚本</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="获取源代码"><a class="header" href="#获取源代码">获取源代码</a></h1>
<p>　　建议通过 <a href="https://www.mercurial-scm.org/">Mercurial</a> 或 <a href="http://git-scm.com/">Git</a> 获取仓库中的最新代码。</p>
<p><strong>注意</strong> 构建过程可依赖源代码中不直接提供的二进制文件。详见<a href="Build.zh-CN.html">构建</a>中的说明。</p>
<h2 id="通过-mercurial"><a class="header" href="#通过-mercurial">通过 Mercurial</a></h2>
<p>　　安装 Mercurial ，使用命令行</p>
<pre><code class="language-console">hg clone https://hg.osdn.net/view/yslib/YSLib YSLib
</code></pre>
<p>　　得到源代码的本地副本。</p>
<p>　　若已有本地副本，可使用</p>
<pre><code class="language-console">hg pull -u
</code></pre>
<p>　　同步更新到最新版本。</p>
<p>　　或者安装 GUI 客户端（如 <a href="http://tortoisehg.bitbucket.org/">TortoiseHg</a> ）进行以上操作。具体使用参考软件附带的手册。</p>
<h2 id="通过-git"><a class="header" href="#通过-git">通过 Git</a></h2>
<p>　　安装 Git ，使用以下命令行之一得到源代码的本地副本：</p>
<pre><code class="language-console">git clone https://github.com/FrankHB/YSLib.git YSLib
</code></pre>
<pre><code class="language-console">git clone https://gitee.com/FrankHB/YSLib.git YSLib
</code></pre>
<p>　　若已有本地副本，可使用</p>
<pre><code class="language-console">git pull
</code></pre>
<p>　　同步更新到最新版本。</p>
<p>　　或者安装 GUI 客户端（如 <a href="http://tortoisegit.net/">TortoiseGit</a> ）进行以上操作。具体使用参考软件附带的手册。</p>
<p><strong>注意</strong> Git 版本库是 Mercurial 版本库的镜像。不同版本库可具有不同的传输性能；使用合适的镜像可能大幅改善同步的体验。上述版本库都是官方维护的，大多数时候不需要担心同步时效性，但镜像版本库的更新仍可能比主版本库稍晚数分钟到数小时。</p>
<h2 id="下载已发布版本"><a class="header" href="#下载已发布版本">下载已发布版本</a></h2>
<p>　　<a href="Releases.zh-CN.html">已经发布的版本</a>列出了可以直接下载的测试发布版本。</p>
<p>　　可以在以下<a href="Archives.zh-CN.html">归档</a>中获得特定发布版本的源代码和部分二进制文件。</p>
<p>　　注意这些代码通常比版本库中的旧。在 <a href="Releases.zh-CN.html">Beta 阶段</a>前也不表示更稳定。</p>
<h2 id="文件权限"><a class="header" href="#文件权限">文件权限</a></h2>
<p><strong>已知缺陷</strong> Windows 上的 Mercurial 不跟踪可执行位。</p>
<p>　　若在其它环境中因此无法执行脚本，在版本库根目录下执行以下 shell 命令变通：</p>
<pre><code class="language-shell">find . -type f -name "*.sh" -exec chmod +x {} \;
</code></pre>
<p>　　因为约定<a href="Tools/Scripts.zh-CN.html">总是使用 <code>*.sh</code> 作为可执行的脚本的扩展名</a>，不需要考虑其它文件。</p>
<h2 id="历史资源"><a class="header" href="#历史资源">历史资源</a></h2>
<p>　　因为代码托管站点不再提供服务，以下资源已过时：</p>
<ul>
<li>曾经可用，当前服务已经停止：
<ul>
<li><a href="https://code.google.com/">Google Code</a>: <code>hg clone https://yslib.googlecode.com/hg/ YSLib</code></li>
<li><a href="http://gitcafe.com">GitCafe</a>: <code>git clone https://gitcafe.com/FrankHB/YSLib.git YSLib</code></li>
</ul>
</li>
<li>已经无法同步：
<ul>
<li><a href="https://bitbucket.org">Bitbucket</a>: <code>hg clone https://bitbucket.org/FrankHB/yslib YSLib</code></li>
</ul>
</li>
<li>被取代：
<ul>
<li><a href="http://git.oschina.net">OSChina</a>: <code>git clone http://git.oschina.net/FrankHB/yslib.git YSLib</code>（使用 Gitee 代替）</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="准备-1"><a class="header" href="#准备-1">准备</a></h1>
<ul>
<li>参见<a href="Development.zh-CN.html">开发说明</a></li>
<li>参见<a href="ProjectDependencies.zh-CN.html">项目依赖性</a>了解 YSLib 子项目之间的联系</li>
</ul>
<h1 id="外部依赖项构建"><a class="header" href="#外部依赖项构建">外部依赖项构建</a></h1>
<p>　　这个步骤是可选的。若已获取作为<a href="ProjectDependencies.zh-CN.html#%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96%E9%A1%B9">外部依赖项</a>的二进制的库文件，可以跳过。</p>
<p>　　YSLib 发布的文件和对应使用的外部依赖项（包括二进制的库文件）可以<a href="Archives.zh-CN.html">从归档仓库下载</a>。</p>
<p>　　进入 <code>3rdparty</code> 对应库的目录查看 <code>Readme</code> 文件说明。按此说明进行构建，一般方法为：</p>
<ul>
<li>自行获取指定的公开发行的源代码</li>
<li>复制 <code>3rdparty</code> 库的目录中的文件到源代码，替换源代码中的原始文件</li>
<li>运行指定的构建脚本命令行</li>
</ul>
<h1 id="库和示例程序构建"><a class="header" href="#库和示例程序构建">库和示例程序构建</a></h1>
<p>　　以下主要描述构建项目的默认目标：库和示例程序 <code>YSTest</code> 。对特定的构建方式，支持附加的其它目标。</p>
<p><strong>注意</strong> 除了 <a href="Tools/SHBuild.zh-CN.html">SHBuild</a> 外，当前没有实现子项目间的依赖管理。由于<a href="Releases.zh-CN.html">非正式版不保证二进制兼容性</a>，直接增量构建可能在更新代码后失败。此时可手动清理构建生成的中间目录即 <code>build</code>。</p>
<p>　　另见<a href="BuildDocumentation.zh-CN.html">构建文档</a>。</p>
<h2 id="使用构建工具和脚本"><a class="header" href="#使用构建工具和脚本">使用构建工具和脚本</a></h2>
<p>　　这是宿主平台的建议构建方式，支持所有的构建目标。</p>
<p>　　基本使用详见 <a href="Tools/SHBuild.zh-CN.html">SHBuild</a> 和 <a href="Sysroot.zh-CN.html">Sysroot</a> 。</p>
<p>　　b600 起用于发布和测试的二进制文件使用 SHBuild 构建。</p>
<p>　　当前版本的构建使用以下方式：</p>
<ul>
<li>调用 <code>Tools/install-sysroot.sh</code> 构建 Sysroot 。
<ul>
<li>确保环境变量 <code>SHBuild_UseDebug</code> 和 <code>SHBuild_UseRelease</code> 的值非空。</li>
<li>确保环境变量 <code>SHBuild_NoStatic</code> 、<code>SHBuild_No3rd</code> 和 <code>SHBuild_NoDev</code> 的值为空。</li>
</ul>
</li>
<li>在 Sysroot 部署完成后，设置环境变量 <code>PATH</code> 包含 Sysroot 布局下的<a href="Sysroot.zh-CN.html">二进制目录</a>。
<ul>
<li>对配置名 <code>debug-static</code>、<code>debug</code>、<code>release-static</code> 和 <code>release</code> ，以配置名作为第一参数分别调用 <code>YSTest/SHBuild-YSTest.sh</code> 构建示例项目 <code>YSTest</code> 的各个配置。</li>
<li>类似地，调用 <code>YDE/install-all.sh</code> 构建 <a href="YDE.zh-CN.html">YDE</a> 中所有包的各个配置。</li>
</ul>
</li>
</ul>
<h2 id="microsoft-visual-studio"><a class="header" href="#microsoft-visual-studio">Microsoft Visual Studio</a></h2>
<p>　　源代码包含 Microsoft Visual Studio 解决方案 <code>.sln</code> 文件。可以直接生成解决方案。注意若修改被依赖项目代码后直接生成，依赖项目也不会重新编译，需要手动清除或重新编译。</p>
<p><strong>注释</strong> 早期支持可追溯到 Microsoft Visual Studio 2012 。当前仅对提交时的正式发布的 Microsoft Visual Studio 最新版本和前一个正式版本提供支持。这里的支持仅包括集成开发环境可打开其中的文件，不保证其中的构建工具可用。</p>
<p>　　当前包含了平台中立项目（便于源代码管理，不实际生成）、DS 项目 、MinGW32 项目和 Android 项目，但仅支持生成使用 make 的平台（ DS 和 Android ，需要对应的工具链支持）。</p>
<p>　　因为正确支持的语言特性不足或存在缺陷，Visual Studio 使用的工具链不保证正常生成其中的 Win32 项目，仅有以下不依赖 YSLib 主要输出目标的项目被支持：</p>
<ul>
<li><code>Tools/CreationTimeManager</code></li>
<li><code>Tools/PredefinedMacroDetector</code></li>
</ul>
<p>　　使用 Microsoft Visual Studio 打开文件，需特定的环境变量以保证使用 makefile 的项目可构建。以下（使用兼容 <a href="Development.zh-CN#shell-%E8%84%9A%E6%9C%AC">shell 语言</a>的）路径仅为示例：</p>
<p>　　DS 项目：</p>
<pre><code class="language-shell">DEVKITPRO=/opt/devkitpro
</code></pre>
<p>　　Android 项目：</p>
<pre><code class="language-shell">ANDROID_SDK=/d/Android/sdk
PATH=/d/clang-android/bin:/c/Program\ Files/Java/jdk1.8.0_211/bin:$PATH
</code></pre>
<p><strong>注意</strong> Visual Studio 项目使用的 makefile 命令行依赖 <code>bash</code> 以便及时检测到错误停止生成，可参见<a href="Prerequisitions.zh-CN.html">先决条件</a>配置<a href="Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">宿主环境</a>。</p>
<p>　　支持生成的 Visual Studio 项目包含依赖性，不需要另行设置；也支持清理命令。</p>
<h2 id="codeblocks"><a class="header" href="#codeblocks">Code::Blocks</a></h2>
<p>　　从 b217 (2011-06-13) 起支持。</p>
<p>　　源代码包含 Code::Blocks 工作空间 .workspace 文件，建议使用 Code::Blocks 12.11 或以上版本打开。</p>
<p><strong>注意</strong> 打开工作空间后直接生成，其中的项目不都能成功构建，因为并非所有项目都保证能生成。项目名没有平台后缀的不用于构建，仅作为项目原型便于开发。</p>
<p>　　当前包含了平台中立项目（项目名不含下划线，便于源代码管理，不实际生成）、DS 项目和 MinGW32 项目，支持构建 DS 项目和 MinGW32 项目，每个分别包含 debug 和 release 配置。除此之外，MinGW32 项目还支持 debug_DLL 配置和 release_DLL 配置，用于生成动态链接库或使用动态链接库生成可执行文件。</p>
<p>　　对于 DS 可以分别编译其它各个项目，但不能运行。可以在工具菜单添加 DeSmuME 命令行运行。</p>
<p>　　b599 (2015-05-21) 起支持通过<a href="Tools/Scripts.zh-CN.html#toolsscriptsgenerateprojectssh">脚本 GenerateProjects.sh</a> 生成 <code>.cbp</code> 文件。</p>
<p>　　和 Visual Studio 不同，生成 <code>.cbp</code> 的项目文件的内容不保证随<a href="Releases.zh-CN.html#%E8%BF%AD%E4%BB%A3%E9%98%B6%E6%AE%B5">提交版本</a>保持最新。这些文件以后仅保证在<a href="Releases.zh-CN.html">发布版本</a>更新。</p>
<p>　　b600 前用于发布和测试的二进制文件使用此方式构建。</p>
<p>　　因为编译时使用的文件路径和可能存在动态确定的个别选项不同等原因，构建的二进制文件和通过 SHBuild 和 Sysroot 环境构建的输出不完全等价，但受支持的功能相同。</p>
<h2 id="make-命令行"><a class="header" href="#make-命令行">make 命令行</a></h2>
<p>　　和 Visual Studio 类似，Code::Blocks 项目文件仅用于查看项目文件，当前不作为首要的构建途径被支持。</p>
<p>　　虽然 Code::Blocks 具有模块化设计，但仍有一些欠缺可配置性及文档的逻辑被集成在核心（使用 C++ 实现，且不容易改动）而造成问题，如：</p>
<ul>
<li>头文件搜索使用字符串匹配。
<ul>
<li>这直接导致在编辑器中无法定位宏名形式的 <code>#include</code> 的路径。</li>
<li>这种形式实际被 YFramework 及 FreeType 使用。</li>
</ul>
</li>
<li>在运行时环境插入 <code>PATH</code> 环境变量的前缀，不保证和构建时相同也不可由用户指定去除。
<ul>
<li>前缀包括 <code>.</code> 、链接器和调试器的可执行文件所在的路径。</li>
<li>因为是前缀，当前路径及链接器和调试器可执行文件的路径直接污染环境变量，无法通过其它设置去除。</li>
<li>当这些路径具有和构建时不同版本的动态库时，使用 Code::Blocks 运行程序会使用错误的动态库。</li>
<li>因此，使用 Code::Blocks 运行程序时，为了使用正确的动态库，不同的版本的动态库不能和工具链共存。</li>
</ul>
</li>
</ul>
<p>　　由于这些自身的局限性，Code::Blocks 不适合作为现代的集成开发环境，没有在现状以外其它的改进支持的计划。</p>
<p>　　使用 <code>make</code> 构建适用于使用 Makefile 的平台，当前包括 DS 和 Android 。</p>
<p>　　设 $Configuration 是生成配置名称，则</p>
<p>　　在各个项目目录下运行</p>
<pre><code class="language-shell">make -r BUILD=$Configuration
</code></pre>
<p>　　即可生成。</p>
<p>　　在各个项目目录下运行</p>
<pre><code class="language-shell">make -r BUILD=$Configuration rebuild
</code></pre>
<p>　　即可重新生成。</p>
<p>　　在各个项目目录下运行</p>
<pre><code class="language-shell">make -r BUILD=$Configuration clean
</code></pre>
<p>　　即可清除生成。</p>
<p><strong>注意</strong> 因为不同子项目的 makefile 之间不追溯依赖关系，直接运行 makefie 需明确依赖顺序，参见<a href="ProjectDependencies.zh-CN.html">项目依赖性</a>。</p>
<p>　　和其它构建方式类似，YFramework 依赖于 YBase 。对 DS 项目，注意附加的项目依赖性以确定生成顺序：</p>
<ul>
<li>YSTest/DS_ARM9 依赖 YFramework 。</li>
<li>YSTest 依赖 YSTest/DS_ARM7 和 YSTest/DS_ARM9 。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="准备-2"><a class="header" href="#准备-2">准备</a></h1>
<ul>
<li><a href="GettingSources.zh-CN.html">获取源代码</a></li>
<li>安装带有图形界面前端的 Doxygen</li>
<li>安装 Graphviz/Dot 工具（见注意事项）</li>
</ul>
<h1 id="构建"><a class="header" href="#构建">构建</a></h1>
<p>　　使用 Doxywizard(Doxygen GUI) 打开目录下的 Doxygen 文件，选择 Run 选项卡，点击 Run doxygen 按钮等待完成即可。</p>
<p>　　构建文档的内容主要来自源文件中的注释。</p>
<p>　　默认的输出路径在 <code>doc/html</code> 。打开其中的 <code>index.html</code> 进入主页。</p>
<h1 id="注意事项"><a class="header" href="#注意事项">注意事项</a></h1>
<ul>
<li>Dot 工具的路径是被硬编码的。
<ul>
<li>如果不确定安装的位置，使用前清空 <code>DOT_PATH</code> ，并设置 <a href="Run.zh-CN.html"><code>PATH</code> 环境变量</a>使二进制文件能被找到。可以直接编辑 Doxyfile 或者在 Expert 选项卡的 Dot 项中设置 <code>DOT_PATH</code> 。</li>
</ul>
</li>
<li>当前配置使用 <code>DOT_IMAGE_FORMAT</code> 为 <code>svg</code> 而不是默认的 <code>png</code> ，生成的文件不支持 Intenet Explorer 9 以前版本的浏览器。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述"><a class="header" href="#概述">概述</a></h1>
<p>　　这是单列的测试顶级子项目。</p>
<p>　　预期覆盖整个项目中的各个<a href="Features.zh-CN.html">库</a>，但目前仅测试 YBase 。框架部分的主要测试由示例程序 YReader 完成。</p>
<h1 id="准备-3"><a class="header" href="#准备-3">准备</a></h1>
<ul>
<li>参见<a href="Build.zh-CN.html">构建</a></li>
<li>参见<a href="Development.zh-CN.html">开发说明</a></li>
<li>配置满足<a href="Prerequisitions.zh-CN.html">先决条件</a>的对应平台运行环境</li>
</ul>
<h1 id="依赖"><a class="header" href="#依赖">依赖</a></h1>
<p>　　当前测试脚本 <code>test.sh</code> 依赖<a href="Tools/Scripts.zh-CN.html">工具脚本</a> ，并使用相同的解释环境。</p>
<h1 id="运行"><a class="header" href="#运行">运行</a></h1>
<p>　　测试脚本 <code>test.sh</code> 构建测试程序并运行。</p>
<p>　　当前测试程序只包括 YBase::YStandardEx 的相关内容。</p>
<p>　　以标准输出显示测试项的数量和每个测试项的结果。通过为 <code>PASS.</code> ，失败为 <code>FAIL.</code> 。</p>
<h2 id="配置"><a class="header" href="#配置">配置</a></h2>
<p>　　变量 <code>TestDir</code> 表示当前测试使用的目录，默认值即为 <code>test</code> 目录。</p>
<p>　　和工具脚本类似，变量 <code>SHBuild_ToolDir</code> 指定工具脚本目录。测试脚本据此包含构建配置所需的工具脚本。因为默认定位到此路径，不需要依赖 <a href="Sysroot.zh-CN.html">Sysroot</a> 安装脚本。</p>
<p>　　在包含工具脚本前，测试脚本使用（当前被直接硬编码在脚本中）以下配置：</p>
<pre><code class="language-shell">CXXFLAGS_OPT_UseAssert=true
SHBuild_Debug=debug
SHBuild_NoAdjustSubsystem=true
</code></pre>
<p>　　脚本不会调用 <code>SHBuild</code> 。脚本直接接受的参数附加为使用 <code>$CXX</code> 构建时命令行选项。</p>
<p>　　和构建 YBase 和 YFramework 库的工具脚本类似，测试脚本支持预编译头文件。但因为默认直接使用 <code>TestDir</code> 作为输出路径，修改配置后可能需要手动清理 <code>gch</code> 文件以免预编译头文件失效。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="准备-4"><a class="header" href="#准备-4">准备</a></h1>
<ul>
<li>参见<a href="Build.zh-CN.html">构建</a></li>
<li>参见<a href="Development.zh-CN.html">开发说明</a></li>
<li>配置满足<a href="Prerequisitions.zh-CN.html">先决条件</a>的对应平台<a href="Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">运行环境</a></li>
</ul>
<h1 id="平台环境"><a class="header" href="#平台环境">平台环境</a></h1>
<p>　　以下约定适用包含 YSLib 程序和其它程序的构建和运行环境的规则。</p>
<p>　　并非每一个程序都需要区分特定<a href="Terminology.zh-CN.html#%E5%B9%B3%E5%8F%B0">平台</a>，一些程序的行为是<a href="Terminology.zh-CN.html#%E5%85%BC%E5%AE%B9%E6%80%A7%E5%92%8C%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7">平台中立</a>的。</p>
<p><strong>注意</strong> 特定平台可能有附加的限制和被支持的配置，详见<a href="Run.zh-CN.html#%E7%89%B9%E5%AE%9A%E5%B9%B3%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83">各个平台运行时环境</a>的说明。</p>
<h2 id="结构要求"><a class="header" href="#结构要求">结构要求</a></h2>
<p>　　YSLib 程序及其组件的构建时依赖项应兼容运行环境：</p>
<ul>
<li>除非另行指定，运行时<a href="Terminology.zh-CN.html#%E4%BE%9D%E8%B5%96%E5%92%8C%E5%A4%96%E5%BB%B6">目标平台</a>的<a href="Terminology.zh-CN#%E5%B9%B3%E5%8F%B0%E6%A0%87%E8%AF%86">系统软件环境</a>应和构建时的配置兼容。
<ul>
<li>这蕴含程序运行时组件及其依赖项（特别地，<a href="Terminology.zh-CN#%E5%B9%B3%E5%8F%B0%E6%A0%87%E8%AF%86">系统库</a>）的版本和配置应匹配，或其偏差在受到支持的范围内。</li>
<li>配置包括构建配置和运行时指定的参数。
<ul>
<li><strong>注释</strong> 例如通过命令行或环境变量分别在构建时和运行时指定的选项以及<a href="Run.zh-CN.html#%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6">配置文件</a>等。</li>
<li>构建配置可允许选择支持的目标平台。</li>
<li>配置可改变和默认的预期的目标平台中的系统软件环境。</li>
<li><strong>注释</strong> 程序实现被建议但不一定提供可选的配置。缺少配置选项可能削弱可移植性，如<a href="https://github.com/boostorg/filesystem/issues/172">要求使用的 API 不被较旧的运行环境支持</a>。</li>
</ul>
</li>
<li><strong>原理</strong> 配置可指定不同的<a href="Terminology.zh-CN.html#%E5%B9%B3%E5%8F%B0%E9%85%8D%E7%BD%AE">平台环境</a>而影响可移植性。修复不受支持的偏差可能需要重新构建程序并重新部署。提供兼容的预期以减少这类情形造成的影响。</li>
</ul>
</li>
<li>作为完整性和安全保证的一部分，程序可检查程序组件或外部依赖项存在和版本，以确保环境符合预期。</li>
<li>若违反假定，则程序的行为未定义，但不得违反任意提供运行环境完整性和数据可用性的显式安全保证。
<ul>
<li><strong>注释</strong> 技术上，程序具有未定义行为。保证通常由宿主环境或其它平台环境实现机制对影响的资源范围进行限制而实现。</li>
</ul>
</li>
<li><strong>注释</strong> 一般地，在可行时，建议程序的实现进行基本的检查明确拒绝非预期的环境，提供最小可预期的行为，以利于用户简化排查部署错误。</li>
</ul>
<h2 id="硬件资源要求"><a class="header" href="#硬件资源要求">硬件资源要求</a></h2>
<p>　　除非另行指定，YSLib 程序及其组件构建和运行时占用的硬件资源不确定，取决于平台配置以及具体应用程序。</p>
<h2 id="文件系统"><a class="header" href="#文件系统">文件系统</a></h2>
<p>　　YSLib 项目对文件系统的使用满足以下约定。YSLib 程序可以使用这些约定作为默认的假设。</p>
<h3 id="文件系统特性"><a class="header" href="#文件系统特性">文件系统特性</a></h3>
<p>　　YSLib 项目仅依赖具有足够可移植性的文件系统特性：</p>
<ul>
<li><strong>注释</strong> 这些特性的可移植性具有相对性。</li>
<li><strong>注释</strong> 一般地，和 ISO C++17 定义的能兼容 <a href="https://eel.is/c++draft/fs.conform.9945">POSIX</a> 和<a href="https://eel.is/c++draft/filesystems#fs.conform.os">特定操作系统</a>（如 Microsoft Windows ）的 <a href="https://eel.is/c++draft/filesystems"><code>std::filesystem</code></a> 支持的文件系统特性集合以及<a href="https://www.boost.org/doc/libs/1_84_0/libs/filesystem/doc/portability_guide.htm">兼容两者的文件名</a>被视为可用。</li>
<li>若不可用，则使用回退(fallback) 实现且不引起其它行为的改变，而不需要在接口中显式依赖：
<ul>
<li>（非目录文件的）硬链接。
<ul>
<li>在不支持的硬链接的文件系统中，链接数总是 1 。</li>
</ul>
</li>
<li>符号链接。
<ul>
<li>在不支持的符号链接的文件系统中，文件不是符号链接，总是不解析符号链接。</li>
</ul>
</li>
</ul>
</li>
<li>假定总是可用：
<ul>
<li>ISO/IEC 14882:2011 中的基本执行字符集中的可打印字符构成的文件名，但除非另行指定：
<ul>
<li>避免大小写不敏感时引起重名。</li>
<li>排除 DOS <a href="https://learn.microsoft.com/windows/win32/fileio/naming-a-file">保留名称</a>。</li>
</ul>
</li>
<li>支持以 <code>char</code> 编码的本机路径的长度不少于 <code>MAX_PATH</code>（当实现的 API 中存在时）和 <code>31</code> 中的较大值。</li>
<li>（不超过文件路径长度限制时的一级或多级）子目录。
<ul>
<li><strong>注释</strong> MS-DOS 2.0 前的文件系统不支持子目录，但当前总是普遍可用。</li>
</ul>
</li>
</ul>
</li>
<li>当实现可能支持时，允许可选引入（而不唯一依赖）特定的可能依赖具体文件系统的实现的特性：
<ul>
<li>被特定的平台可选引入，仅作为优化实现，不引起其它行为的改变，而不需要在接口中显式依赖：
<ul>
<li>可选地使用不属于 POSIX.1 等标准文件系统 API 支持的元数据。包括但不限于：
<ul>
<li><a href="https://www.gnu.org/software/libc/manual/html_node/Directory-Entries.html"><code>d_type</code></a> ：
<ul>
<li><a href="https://www.mingw-w64.org/">MinGW-w64</a> 不支持，但 <a href="https://osdn.net/projects/mingw">MinGW.org</a> 支持。</li>
<li>许多文件系统在 Linux 上的实现支持，但 <a href="https://github.com/ggreer/the_silver_searcher/issues/36">ReiserFS</a> 和 <a href="https://docs.oracle.com/en/operating-systems/uek/4/relnotes4.6/uek4.6-KnownIssues.html">XFS</a> 不支持，结果总是 <code>DT_UNKNOWN</code> 。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>支持超过 POSIX 或 Win32 的 <code>MAX_PATH</code> 长度限制的特定路径。
<ul>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation">Windows 长文件名(LFN, long filename)</a>。</li>
</ul>
</li>
<li>在操作不支持时引起运行时错误或取得指定不支持情形的结果，包括但不限于：
<ul>
<li><a href="Run.zh-CN.html#%E6%97%B6%E9%97%B4%E6%88%B3">文件创建时间</a>的查询和修改在不同平台具有不同的支持：
<ul>
<li>Win32 在使用 FAT 和 NTFS 等文件系统时完全支持，但不同操作和在不同文件系统上使用的文件时间的<a href="https://learn.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-filetime">精度不保证相同</a>。</li>
<li>Linux 在使用 ext4 时可通过 <a href="http://man7.org/linux/man-pages/man2/statx.2.html"><code>statx</code></a> 读取，但不支持写入。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>对其它文件系统特性保持中立。
<ul>
<li><strong>原理</strong> 允许最终用户修改文件系统运行时配置（如挂载参数）而不破坏 YSLib 程序的可用性。</li>
</ul>
</li>
</ul>
<p><strong>注释</strong> 文件系统特性不是唯一限制文件系统路径可用性的因素。参见以下<a href="Run.zh-CN.html#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%B7%AF%E5%BE%84">文件系统路径</a>的规则。</p>
<p>　　一般地，YBase 不要求文件系统访问；使用 YFramework 框架的程序，由 YFramework 中的<a href="Run.zh-CN.html#%E6%A1%86%E6%9E%B6%E5%88%9D%E5%A7%8B%E5%8C%96">框架初始化</a>等逻辑引入文件系统访问。</p>
<h3 id="文件系统路径"><a class="header" href="#文件系统路径">文件系统路径</a></h3>
<p>　　为最大化可移植性，除满足<a href="Run.zh-CN.html#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%89%B9%E6%80%A7">文件系统特性</a>的要求，YSLib 项目中的程序及其组件使用的文件系统路径同时具有以下约束：</p>
<ul>
<li>逻辑<strong>不依赖自身组件具有显式编码的具体文件路径</strong>，且默认<strong>不要求在具体系统约定的周知(well-known) 的文件系统位置</strong>，除以下例外：
<ul>
<li>为实现接口约定的功能，特定平台环境中的实现可能隐式地依赖特定的文件系统路径。
<ul>
<li><strong>注释</strong> 例如，Linux 平台的实现可能依赖 <code>/proc</code> 访问进程相关的运行时信息。</li>
</ul>
</li>
<li>具体安装配置可以自行限定外部文件的<a href="Run.zh-CN.html#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80">目录布局</a>作为默认运行时环境，且外部文件可约定默认路径。
<strong>注释</strong> 系统约定的路径如 <a href="https://docs.microsoft.com/zh-cn/windows/win32/dlls/dynamic-link-library-search-order">Windows DLL 搜索路径</a>中的目录和 <a href="https://zh.wikipedia.org/zh-cn/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86">FHS</a> 定义的目录。</li>
</ul>
</li>
<li>最小化依赖特定的文件系统和路径表示。
<ul>
<li>特别地，不依赖文件系统是否具有文件名的大小写敏感性。</li>
<li><strong>推论</strong> 为保证可移植性，文件系统路径大小写敏感，需要显式区分而加以明确。</li>
<li><strong>原理</strong> 这样仍可兼容 FAT 等大小写不敏感的文件系统。</li>
<li>除非特定的接口约定，不依赖可选的大小写敏感的文件系统特性。
<ul>
<li><strong>注释</strong> Microsoft Windows 10 支持默认大小写不敏感的 NTFS 配置为每目录启用大小写敏感，用于<a href="https://devblogs.microsoft.com/commandline/improved-per-directory-case-sensitivity-support-in-wsl/">支持 WSL DrvFS 实现</a>等场景。</li>
<li><strong>注释</strong> <a href="https://www.systutorials.com/docs/linux/man/8-jfs_mkfs/">JFS 提供选项</a>以支持 OS/2 的大小写不敏感的文件系统特性。</li>
<li><strong>注释</strong> <a href="https://lore.kernel.org/lkml/20190507232823.GA28416@mit.edu/">Linux 5.2 起支持默认大小写敏感的 ext4 配置为每目录启用大小写不敏感</a>，可用于提升 WINE 应用性能等场景。</li>
</ul>
</li>
</ul>
</li>
<li>使用的路径应能支持符合 YSLib 项目规范的开发（参见项目的 <code>doc/ProjectRules.txt</code> ）。</li>
</ul>
<h3 id="时间戳"><a class="header" href="#时间戳">时间戳</a></h3>
<p>　　文件系统可支持不同的文件时间戳，以记录和文件系统操作有关的事件发生的时间。</p>
<p>　　典型地，文件系统支持文件修改时间(modification time) 和访问时间(access time) 。但有的时间戳仅在部分实现中支持，如创建时间(creation time) ：</p>
<ul>
<li>部分文件系统支持创建时间；但其它文件系统不支持保存这种元数据。
<ul>
<li><strong>注释</strong> 例如，NTFS 和 ext4 原生支持保存文件创建时间。</li>
</ul>
</li>
<li>部分实现提供支持访问文件系统时间；但是其它实现支持有限。
<ul>
<li><strong>注释</strong> Windows NT 和 Win32 可支持读取和写入文件修改时间的 API 。</li>
<li><strong>注释</strong> POSIX 没有原生支持文件系统的访问时间，但可以通过特定的原生方式提供，例如：
<ul>
<li>Linux 支持通过 <code>statx</code> 系统调用取得 ext4 等文件系统中保存的文件创建时间戳，但不支持修改。</li>
<li>BSD 支持保存创建文件，不支持修改。</li>
</ul>
</li>
</ul>
</li>
<li><strong>注释</strong> 相同特性的名称在不同实现中不同：
<ul>
<li>在 FAT 和 NTFS 称为 ctime（注意这和 POSIX 的 ctime(change time) 不同）。</li>
<li>在 JFS 和 Btrfs 称为 otime 。</li>
<li>在 ext4 称为 crtime(creation time) 。</li>
<li><code>statx</code> 支持 btime(birth time) 。</li>
<li>BSD 支持 birthtime 。</li>
<li>另见<a href="https://lwn.net/Articles/397442/">这里的讨论</a>。</li>
</ul>
</li>
</ul>
<p>　　程序应注意可移植性限制，避免依赖错误的假设：</p>
<ul>
<li>即使是被支持的时间戳，精度可能也会受到文件系统设计的限制。
<ul>
<li><strong>注释</strong> 例如，NTFS 支持微秒级的时间戳，但 FAT32 文件系统只支持到秒级的时间戳。</li>
</ul>
</li>
<li>此外，文件系统的实现（操作系统的驱动）可能还会对时间戳进行一些调整或优化而具有不同的行为：
<ul>
<li>因为时间戳的历元未指定，涉及时区或时间转换时，具有未指定的语义。
<ul>
<li><strong>注释</strong> 例如，NTFS 会将时间戳存储为 UTC 时间，在 Windows 上自动调整为本地时间。</li>
</ul>
</li>
<li>一些文件系统在挂载(mount) 时可（通过用户指定的选项）调整行为。
<ul>
<li><strong>注释</strong> 例如，Linux 的 ext4 文件系统可通过选项来选择是否使用 UTC 时间戳。</li>
</ul>
</li>
<li>因为性能原因，文件系统的实现更新访问时间戳可能不及时。</li>
</ul>
</li>
</ul>
<h2 id="二进制依赖项"><a class="header" href="#二进制依赖项">二进制依赖项</a></h2>
<p>　　按以上<a href="Run.zh-CN.html#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">文件路径约定</a>，构建得到的目标程序没有预设特定的位置限制，可按需转移。</p>
<p>　　运行程序前，应确保程序能找到二进制依赖项：</p>
<ul>
<li>确保<a href="Prerequisitions.zh-CN.html">先决条件</a>中的依赖项可以在 <code>PATH</code> 环境变量的目录被找到，或者复制到程序所在的目录。</li>
<li>对于静态链接 YFramework 和 YBase 程序，不需要其它二进制程序文件的部署。</li>
<li>使用 DLL 的程序可能依赖 YFramework.dll 和 YBase.dll ，或者 debug 配置的 YFrameworkd.dll 和 YBased.dll 。这些库已经在 sysroot 的 <code>bin</code> 目录下安装，因此可以直接把 <code>bin</code> 目录加入 <code>PATH</code> 环境变量，而不必复制或移动库文件。</li>
</ul>
<p><strong>说明</strong> 在任意被支持的平台上，YSLib 避免使用导致在特定平台上被特殊处理且无法可靠避免这种行为而确保兼容性一致的外部依赖项名称（若因为外部环境更新导致此类问题，则需在 YSLib 的新版本适当修改后支持）。例如，支持 <a href="http://www.geoffchappell.com/studies/windows/win32/apisetschema/index.htm">API Set Schema</a> 的 Windows 版本加载 DLL 时，<a href="https://stackoverflow.com/a/47530043/2307646"><code>LdrLoadDll</code> 解析以 <code>api-</code> 或 <code>EXT-</code> 起始的文件名进行重定位</a> ，因此设计时确保外部依赖项对应的文件名不以这些前缀起始。</p>
<p><strong>注意</strong> 当前没有二进制兼容保证。使用不兼容的二进制文件的程序实现的行为未定义。特别地，使用不同工具链乃至编译或链接时仅仅使用了不同的构建选项可能生成互不兼容的二进制文件。使用这些文件时应当确定使用的源代码版本和构建环境匹配。例如，在支持动态库的 <code>POSIX</code> 平台，应当确保 <code>PATH</code> 和 <code>LD_LIBRARY_PATH</code> 这些影响加载程序二进制文件位置的环境变量被适当配置，以确保实际使用的二进制文件之间兼容。</p>
<h2 id="兼容平台"><a class="header" href="#兼容平台">兼容平台</a></h2>
<p><strong>注意</strong> 示例程序最大化地使用了 YSLib 的<a href="Development.zh-CN.html#%E5%B9%B3%E5%8F%B0%E6%A8%A1%E6%8B%9F">平台模拟</a>特性，支持特定的<a href="Development.zh-CN.html#%E5%B9%B3%E5%8F%B0">目标平台</a>在运行时作为<a href="Development.zh-CN.html">宿主平台</a>对另一平台的平台模拟，即运行的原生示例程序和被模拟平台的原生程序保持基本相同的功能效果；但并不保证所有其它 YSLib 程序同样支持。</p>
<p>　　被正式支持的平台模拟列表如下：</p>
<ul>
<li>PC 模拟 DS</li>
</ul>
<p>　　被非正式支持的平台模拟列表如下：</p>
<ul>
<li>Android 模拟 DS</li>
</ul>
<h1 id="运行时交互"><a class="header" href="#运行时交互">运行时交互</a></h1>
<p>　　以下约定适用程序运行时可能进行交互的运行环境的规则，涵盖以下程序：</p>
<ul>
<li>通过用户界面运行 YSLib 项目中的程序。</li>
<li>以上方式间接运行的其它程序。
<ul>
<li><strong>注释</strong> 例如，在程序中调用<a href="Development.zh-CN.html#%E8%84%9A%E6%9C%AC">脚本</a>，或者程序使用基于 <code>std::system</code> 等本机 <a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 实现的互操作。YSLib 安装程序可能间接调用其它程序。</li>
</ul>
</li>
</ul>
<p>　　用于 YSLib 自举构建的工具（如 <a href="Tools/SHBuild.zh-CN.html">SHBuild</a> ）在运行时也满足以上要求，因此这类情形的构建时也满足上述要求。</p>
<h2 id="环境变量-1"><a class="header" href="#环境变量-1">环境变量</a></h2>
<p>　　<a href="https://zh.wikipedia.org/zh-cn/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量</a>是程序的实现环境（典型地，如操作系统）的运行<a href="Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">环境</a>提供的一种机制。程序在运行时可能访问这些环境变量，以提供不同的行为，或在程序之间、程序与外部环境之间传递信息。</p>
<p><strong>注释</strong> 非宿主实现的平台可能不支持环境变量。本项目的程序在这些平台上不使用环境变量。</p>
<p>　　没有依赖这些具体应用或其提供的实现环境时，如有可能，应当避免使用依赖这些具体的使用方式。</p>
<p>　　一些情形程序通过判断特定的环境变量配置功能。特别地，设置特定的环境变量为非空值可能启用功能。</p>
<p>　　一般地，只要环境变量被支持，一个环境变量总是能被设置为非空的字符串（至少本项目支持的平台能假定如此）。但是，访问环境变量的行为仍可能依赖具体平台的不同细节，而影响可移植性：</p>
<ul>
<li>环境变量的名称可能是大小写敏感或不敏感的：名称仅有大小写不同的环境变量可能被视为不同或同一个。
<ul>
<li>例如，Windows（指 Win32 环境，下同）的环境变量名对大小写不敏感。其它大部分实现环境对环境变量的大小写敏感。</li>
<li>因此，作为公开接口提供的环境变量应当总是具有固定的、大小写敏感的拼写，且避免出现仅有不同大小写的可能因同名冲突的不同环境变量名。</li>
</ul>
</li>
<li>环境变量可被设置为空值。具有空值的环境变量可能会或不会被视为没有被设置（或被取消设置）的环境变量。
<ul>
<li>例如，设置 Windows 的某个环境变量为空值，效果即删除环境变量。其它大部分实现环境中，设置环境变量为空值，环境变量不被删除。</li>
<li>一些环境可能指定不同的行为，如<a href="https://www.msys2.org/news/#2022-09-24-changed-behavior-for-empty-env-vars">较新版本的 MSYS2 支持配置 <code>MSYS=noemptyenvvalues</code></a> 。</li>
<li>特定的实现被设置的环境变量具有空值，如 <a href="https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_environment_variables">PowerShell</a> 。</li>
<li>为避免这些不同实现的复杂性，不直接判断环境变量被设置，而访问环境变量并检查是否为空值。未设置的环境变量被视为具有空值。</li>
</ul>
</li>
<li>环境变量名可能具有不同的限制。
<ul>
<li>仅假定 ISO C 基本字符集的标识符（大小写拉丁字母、数字和下划线 <code>_</code> ）可被用于环境变量名。</li>
</ul>
</li>
<li>具体环境变量的访问方式可能和具体宿主平台中访问环境变量的具体程序相关，如：
<ul>
<li><a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_05_03">POSIX shell 变量</a>引用 <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html#tag_08">XBD 环境变量</a>，可使用 <code>$VAR</code> 访问变量 <code>VAR</code> 的值。</li>
<li><a href="https://learn.microsoft.com/windows-server/administration/windows-commands/set_1">Windows <code>set</code> 命令</a> 显示或设置环境变量，可使用 <code>%VAR%</code> 访问变量 <code>VAR</code> 的值。</li>
<li><a href="https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_environment_variables">Powershell 支持环境变量</a>，可通过 <code>$Env:VAR</code> 访问变量 <code>VAR</code> 的值。</li>
</ul>
</li>
<li>以下<em>周知的(well-known)</em> 环境变量因在各个被本项目支持的宿主实现平台普遍可用，而可被直接使用，但使用方式并非完全相同：
<ul>
<li><strong>原理</strong> 以下约定简化可移植的使用。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/PATH_%28%E5%8F%98%E9%87%8F%29"><code>PATH</code></a> 表示程序中执行（外部程序提供的）命令使用的搜索路径。
<ul>
<li>对 Windows ，另见 <a href="https://learn.microsoft.com/windows-server/administration/windows-commands/path"><code>path</code> 命令</a>（其中使用 <code>%PATH%</code> 引用环境变量 <code>PATH</code> ）。</li>
<li>另见 <a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_09_01_01">POSIX</a> 的规定。</li>
<li><code>PATH</code> 的值可支持多个路径名称，其中分隔符不一定相同，如 Windows 使用 <code>;</code> ，而 POSIX 使用 <code>:</code> 。</li>
<li>Windows 可能直接提供 <code>Path</code> 环境变量，而在 <code>cmd.exe</code> 中仍然被识别为 <code>PATH</code> 。此时，使用 <code>PATH</code> 。</li>
</ul>
</li>
<li><a href="https://en.wikipedia.org/wiki/COMSPEC">环境变量 <code>COMSPEC</code> 或 <code>ComSpec</code> (en-US)</a> 指定命令解释器。
<ul>
<li>Windows 可能直接提供 <code>ComSpec</code> 环境变量，而在 <code>cmd.exe</code> 中仍然被识别为 <code>COMSPEC</code> 。此时，使用 <code>COMSPEC</code> 。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　除非需要依赖具体实现环境或另行指定，本项目中提供的环境变量应当避免上述依赖差异。</p>
<h3 id="应用程序变量"><a class="header" href="#应用程序变量">应用程序变量</a></h3>
<p>　　应用程序继承环境，可能根据环境变量指定不同的行为。</p>
<p>　　除非另行指定，以下环境变量若被本项目提供的程序支持，则具有一致的含义：</p>
<ul>
<li><code>NO_COLOR</code> ：若这个环境变量被设置为非空值，宿主实现环境忽略终端支持的彩色和其它视觉效果格式（如下划线）特性。
<ul>
<li><strong>注释</strong> <code>NO_COLOR</code> 的检查符合 <a href="https://no-color.org/">no-color.org</a> 的约定。</li>
<li><strong>注释</strong> 一些命令解释环境的实现直接支持 <code>NO_COLOR</code> ，如 <a href="https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_environment_variables">PowerShell</a>。</li>
</ul>
</li>
<li><code>CLICOLOR_FORCE</code> ：若这个环境变量被设置为非空值且 <code>NO_COLOR</code> 没有被设置为非空值，则指定宿主实现环境忽略终端支持的彩色和其它视觉效果格式（如下划线）特性。
<ul>
<li><strong>注释</strong> <code>CLICOLOR_FORCE</code> 的检查符合 <a href="https://bixense.com/clicolors/">clicolors</a> 的约定。</li>
<li><strong>注释</strong> <code>CLICOLOR_FORCE</code> 最早可见于 <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;manpath=FreeBSD+4.1.1-RELEASE">FreeBSD 4.1.1-RELEASE 的 <code>ls</code> 命令</a>。特性支持<a href="https://cgit.freebsd.org/src/commit/?id=3d2ddc9e1a6a60d585b7c0a3e378b6ef986dac57">在 2000 年被添加</a>。同时还有 <code>CLICOLOR</code> 环境变量，但在此没有约定。</li>
</ul>
</li>
</ul>
<p><strong>注释</strong> 环境变量指定的配置可能和其它方式（如配置文件和命令行参数）交互产生影响而具有不同的作用（可能被完全覆盖）。</p>
<p>　　除标准库和系统配置外，YFramework 可使用特定的环境变量改变运行时行为，参见 YSLib 项目文档 <code>doc/YFramework.txt</code> 。</p>
<p>　　除非另行指定，程序可假定以上环境变量不变，即仅在程序初始化时检查一次。</p>
<p>　　提供给程序的环境变量可能被命令行工具的选项覆盖，如 <a href="Tools/SHBuild.zh-CN.html#%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%BC%8F">SHBuild 构建模式</a>中指定变量定义的选项 。</p>
<h2 id="多任务环境"><a class="header" href="#多任务环境">多任务环境</a></h2>
<p>　　除非另行指定，通过 YSLib 安装程序调用的程序或者依赖 YSLib 的命令行程序假定以下的外部环境和交互方式：</p>
<ul>
<li>非<a href="Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">宿主环境</a>：执行其它程序的<em>宿主(host)</em> 未指定。
<ul>
<li>被视为默认不支持外部程序。</li>
<li><strong>注释</strong> 程序使用 <code>std::system</code> 等实现定义的行为可能导致非预期但可被定义的结果。</li>
</ul>
</li>
<li>宿主环境：
<ul>
<li>以被执行的当前程序或脚本解释器作为执行其它程序的宿主。
<ul>
<li><strong>注释</strong> 一般由操作系统在用户空间规范提供约定，且系统的安装提供完整的环境。例如，Windows 提供 <code>cmd.exe</code> 作为命令行解释器，而 UNIX 系统提供 shell 程序解释 shell 语言命令和脚本。</li>
</ul>
</li>
<li>以宿主定义的规则解析命令行参数。
<ul>
<li>Windows ：命令行<a href="https://daviddeley.com/autohotkey/parameters/parameters.htm#WINPASS">由程序实现指定</a>。对未指定宿主程序的情形，视为和 <code>cmd.exe</code> 一致。
<ul>
<li><strong>注释</strong> Windows 可通过 shell 程序传递命令，这<em>不是</em>默认假定的环境。</li>
<li>Windows ：对引号的解析，兼容<a href="https://daviddeley.com/autohotkey/parameters/parameters.htm#WINCRULESDOC">未被文档指定的新规则</a>，即仅在引号有效地块中 <code>""</code> 转义未 <code>"</code>。</li>
</ul>
</li>
</ul>
</li>
<li>使用<a href="Run.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量</a>的约定。</li>
<li>若<a href="https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap08.html#tag_21_08_03_03">环境变量 <code>SHELL</code></a> 被设置，则：
<ul>
<li>假定被正确设置至支持的 shell 程序的路径。</li>
<li>假定 <a href="https://pubs.opengroup.org/onlinepubs/009695299/utilities/contents.html">POSIX.1-2004 环境的命令</a>可用。</li>
<li><strong>注释</strong> 在 shell 环境内部通常不需要检查。可能使用其它 POSIX 兼容 shell 兼容 POSIX shell 或 GNU bash 的运行环境。</li>
</ul>
</li>
<li>非 Windows 宿主平台：使用 POSIX shell 或 GNU bash 作为执行环境的 shell 。</li>
<li>Windows ：使用随系统分发的 <code>cmd.exe</code> 作为命令行解释器。
<ul>
<li>不显式依赖<a href="Run.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量 <code>COMSPEC</code> 或 <code>ComSpec</code></a>。</li>
<li>对使用 <a href="https://www.msys2.org/">MSYS2</a> 或与之兼容的环境，使用<a href="https://www.msys2.org/docs/environments/">环境变量 <code>MSYSTEM</code></a> 指定活动的环境和子系统。</li>
</ul>
</li>
<li>不要求支持嵌套不同的命令行环境最终重入到非 POSIX 兼容 shell 的情形。
<ul>
<li><strong>注释</strong> 若 <code>SHELL</code> 被设置为非空值，即视当前 shell 是 POSIX 兼容 shell 。</li>
<li><strong>原理</strong> 被继承的环境变量检查可能嵌套的命令行环境不可靠。可靠检查通常依赖进程间通信确定当前的程序，为减少复杂性，不被要求。</li>
</ul>
</li>
<li>以上环境变量在相关规范定义明确允许的情形以外，可被程序假定不被修改。</li>
<li>运行其它程序时，不检查或隔离外部环境。
<ul>
<li><strong>警告</strong> 尽管 YSLib 项目提供的程序的大部分实现会避免明显的安全性问题，任何可能执行第三方程序仍然可能有潜在的安全性风险。因此，在完全审计环境并确保外部环境可信之前，<strong>不建议使用特权运行包括 YSLib 安装脚本内的这些程序</strong>。
<ul>
<li><strong>注释</strong> 利用方式如拦截在程序中已知会调用的外部命令（包括命令解释器），以及使用环境变量 <code>IFS</code> 等特定外部命令的机制注入。</li>
</ul>
</li>
</ul>
</li>
<li>使用包含带有 Windows 环境变量展开语法（以 <code>%</code> 起始和结尾）的参数未指定。
<ul>
<li><strong>原理</strong> Windows 命令行解释器脚本可使用 <code>%%</code> 转义，但这对交互式命令行环境的调用不适用。因此，包含这种形式的参数可因是否使用 Windows 命令行解释器表现不同的行为。</li>
<li><strong>注释</strong> <a href="Development.zh-CN.html#npla1-%E8%84%9A%E6%9C%AC">NPLA1 脚本</a>可调用依赖 Windows 命令行解释器执行的命令。</li>
</ul>
</li>
<li>除非被功能蕴含或另行指定：
<ul>
<li>不和程序处理的外部对象或外部程序执行时的安全机制或其它附加元数据的机制显式交互。
<ul>
<li>外部对象可能是文件系统对象或其它对象。</li>
<li>安全机制可能是对象具有的权限(permission) 或权能(capability) 。</li>
<li>附加元数据在 API 的意义上明确，如依赖具体文件系统的扩展属性(extend attribute) 。</li>
<li>交互包含对状态的访问，如检查和配置。</li>
</ul>
</li>
<li>若有必要使用：
<ul>
<li>尽量使用可确定不具有全局（整个系统）影响的方式。</li>
<li>当不能避免全局影响时，使用影响较小的方式。</li>
</ul>
</li>
<li><strong>注释</strong> 系统可能具有对用户可见的默认设置。例如，POSIX 进程可继承<a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_12">文件创建掩码</a>，且可被用户通过 <a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/umask.html"><code>umask</code></a> 设置。</li>
</ul>
</li>
</ul>
</li>
<li><strong>原理</strong> POSIX shell 和 <code>cmd.exe</code> 是平台默认分发的应用，通过<a href="Terminology.zh-CN.html#%E4%BE%9D%E8%B5%96%E5%92%8C%E5%A4%96%E5%BB%B6">构建平台或宿主平台</a>直接区分是可行的。
<ul>
<li>同时，一些语法兼容，使有些命令不需要区分两者。即便在一些基本语法上（如重定向错误流）不完全兼容，默认仍然可以通过特定的环境区分两者。</li>
<li>环境变量 <code>SHELL</code> 在不同实现的支持情形不同，不适合提供统一的假定：
<ul>
<li>环境变量 <code>SHELL</code> 在 <a href="https://pubs.opengroup.org/onlinepubs/9699919799/mindex.html">POSIX.1-2017</a> 的 <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html#tag_08">基本定义中出现</a>，而其含义决定若这个环境变量被定义，其值非空。<a href="https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap08.html#tag_21_08_03_03">相关原理</a>解释了 <code>SHELL</code> 具有可被系统配置为非 POSIX shell 的含义。</li>
<li>环境变量 <code>SHELL</code> 不是<a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_05_03">被定义的 shell 执行环境</a>的一部分，不被要求影响 shell 的执行，但仍能判断系统配置。</li>
<li>环境变量 <code>SHELL</code> 的值通常被初始化环境的启动程序（如传统的 <code>login</code>，仍被 <a href="https://www.unix.com/man-page/posix/1/login/">BSD</a> 和 <a href="https://man7.org/linux/man-pages/man1/login.1.html">Linux</a> 等使用）设置。</li>
<li>GNU bash <a href="https://www.gnu.org/software/bash/manual/html_node/Bash-Variables.html#index-SHELL">确保启动时 <code>SHELL</code> 的值被设置</a>。</li>
<li>其它兼容 POSIX shell 可使用环境变量 <code>SHELL</code> 执行命令，但通常不设置它的值（如 <a href="https://www.ibm.com/docs/aix/7.1?topic=shell-variables-used-by-korn-posix">Korn shell</a>）。</li>
</ul>
</li>
<li>环境变量 <code>COMSPEC</code> 和 <code>ComSpec</code> 缺乏标准化，且会被继承。
<ul>
<li>这通常仅用于判断在 Windows 同时使用兼容 POSIX shell 环境。</li>
<li>Windows 可能使用嵌套的兼容 POSIX 的 shell 而同时继承 <code>COMSPEC</code> 且被设置 <code>SHELL</code> 的情形。</li>
<li>为避免复杂性，一般避免单独检查这些环境变量。</li>
<li>C 运行时实现使用 <a href="https://learn.microsoft.com/cpp/c-runtime-library/reference/system-wsystem"><code>std::system</code> 和 <code>::_wsystem</code></a> 实际可能总是依赖 <code>COMSPEC</code> 和 <code>cmd.exe</code> ，因此成功互操作时已经隐含依赖了这项运行时配置。</li>
</ul>
</li>
<li>安全机制、附加元数据及其交互方式往往依赖具体外部环境，可移植性较低。除外部环境已明确的默认配置，仅在必要时使用。
<ul>
<li>一般地，这也适用于不同机制之间的比较。例如，若有必要使用不同上下文的文件系统附加属性，一般默认<a href="https://www.freedesktop.org/wiki/CommonExtendedAttributes/">仅在用户空间使用</a>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>注释</strong> <a href="https://learn.microsoft.com/powershell/">PowerShell</a> 、<a href="https://github.com/PowerShell/PowerShell">PowerShell Core</a> 或 <a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_pwsh"><code>pwsh</code></a> 默认不被支持。
<ul>
<li><strong>原理</strong> PowerShell 和上述命令行解释器支持的语法都不兼容，且不直接提供简便可靠的可移植的方式检查差异。</li>
<li><strong>注释</strong> 可靠检查 PowerShell 通常依赖<a href="https://stackoverflow.com/questions/55597797">进程间通信</a>。</li>
</ul>
</li>
</ul>
<p>　　关于 YSLib 版本库内的及安装 YSLib 部署的脚本的运行环境，另见<a href="Development.zh-CN.html">脚本运行</a>的相关说明。</p>
<h2 id="外部文件"><a class="header" href="#外部文件">外部文件</a></h2>
<p>　　外部文件包括：</p>
<ul>
<li>在文件系统中部署的外部<a href="Run.zh-CN.html#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BE%9D%E8%B5%96%E9%A1%B9">二进制依赖项</a>。</li>
<li>配置文件：可被修改以改变程序的运行时行为。</li>
<li>其它数据文件。</li>
</ul>
<p>　　数据文件提供程序运行时所需的必要或可选的信息。配置文件可能作为数据文件使用。</p>
<p>　　外部文件的路径应符合前述关于文件路径的约定。</p>
<h3 id="文件格式-1"><a class="header" href="#文件格式-1">文件格式</a></h3>
<p>　　除非另行指定，使用以下文件格式：</p>
<ul>
<li>配置文件是内容为 <a href="Features/NPL.zh-CN.html">NPL</a> 配置的 UTF-8 文本文件，具有 UTF-8 BOM 。</li>
<li>其它数据文件为二进制文件 。</li>
</ul>
<h3 id="文件系统布局-1"><a class="header" href="#文件系统布局-1">文件系统布局</a></h3>
<p>　　除<a href="Run.zh-CN.html#%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6">配置文件</a>可能指定默认的具体位置（详见<a href="Run.zh-CN.html#%E9%85%8D%E7%BD%AE%E8%B7%AF%E5%BE%84">下文</a>）外，YFramework 程序不需依赖特定的文件系统布局。</p>
<p>　　除非另行指定（暂无），YFramework 不创建文件系统目录。</p>
<p>　　<a href="Sysroot.zh-CN.html">Sysroot</a> 使用类似 <a href="https://zh.wikipedia.org/zh-cn/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86">FHS</a> 的文件系统布局，称为<em>局部 FHS 目录布局(local FHS directory layout)</em> 。</p>
<p><strong>原理</strong> 在不同环境下都可使用一般类 UNIX 系统使用的布局，有助于减少安装后运行时环境的差异，便于部署。</p>
<h2 id="其它外部环境交互"><a class="header" href="#其它外部环境交互">其它外部环境交互</a></h2>
<ul>
<li>在功能明确的情形以外，除非另行指定，运行时不通过文件系统以外的方式访问远程资源。
<ul>
<li><strong>原理</strong> 隐式访问网络资源可具有不可预期的开销，影响用户体验。</li>
</ul>
</li>
</ul>
<h1 id="特定平台运行环境"><a class="header" href="#特定平台运行环境">特定平台运行环境</a></h1>
<h2 id="ds"><a class="header" href="#ds">DS</a></h2>
<p>　　以下说明中，<code>$NDSEmulator</code> 为模拟器 <a href="DeSmuME.en-US.html">DeSmuME</a> 可执行文件的绝对路径，<code>$TargetPath</code> 为 ROM 映像文件（ <code>.nds</code> 文件）的路径，$FAT_Path为 FAT 目录路径（见以下说明）。</p>
<p>　　之前经测试的最小版本为 0.9.6 。建议使用最新版本。</p>
<p>　　运行时，需在运行模拟器的宿主机中准备一个目录作为映射到设备中的虚拟 FAT 目录。宿主的目录在运行中不会被 DeSmuME 修改；宿主目录的文件系统不要求为 FAT 。运行时会加载虚拟目录的内容。</p>
<p><strong>注意</strong> 官方版的 DeSmuME 不支持包含非 ASCII 字符的宿主路径而忽略这些文件。部分修改版可能没有这个限制。</p>
<p><strong>注意</strong> 因为 DS 模拟器和烧录卡需要加载 ROM 映像到 RAM 后才能运行，映像大小会影响可用运行内存，使用 debug 配置构建的 YSTest 示例版本不一定在 DS 上支持所有功能。相关支持限制及变更详见 YSLib 项目文档 <code>doc/Test.txt</code> 。</p>
<p>　　可通过以下方式之一指定 FAT 目录。</p>
<h3 id="slot-1-映射"><a class="header" href="#slot-1-映射">Slot 1 映射</a></h3>
<p>　　Slot 1 （即 NDS ROM 卡槽，硬件介质可以是 NDS 卡带，或烧录卡和存储卡的组合）的模拟从 DeSmuME 0.9.8 版本起支持。</p>
<p>　　运行命令行示例：</p>
<pre><code class="language-shell">"$NDSEmulator" "$TargetPath" --preload-rom --slot1-fat-dir="$FAT_Path"
</code></pre>
<p>　　其中 <code>--preload-rom</code> 对 0.9.10 和 0.9.11 版本是必须的（以支持自动 <a href="https://wiki.gbatemp.net/wiki/DLDI">DLDI(en-US)</a> 补丁），否则加载失败。这个选项可以在模拟器（Windows 版本）的 GUI 菜单中 <code>Config</code> → <code>ROM Loading</code> 中选择。最新版本的源码会对自制 ROM 自动启用 ROM 预先加载的选项而不用另行配置，可以省略这个选项。</p>
<h3 id="slot-2-映射"><a class="header" href="#slot-2-映射">Slot 2 映射</a></h3>
<p>　　Slot 1 （即 GBA ROM 卡槽，硬件介质可以是 GBA 卡带或其它扩展）的模拟需要配置为使用 <code>GBA Movie Player (Compact Flash)</code> 。</p>
<p>　　运行命令行示例：</p>
<pre><code class="language-shell">"$NDSEmulator" "$TargetPath" --cflash-path="$FAT_Path"
</code></pre>
<p>　　对 0.9.10 和 0.9.11 版本，需同 Slot 1 映射添加 <code>--preload-rom</code> 或使用菜单设置加载选项，否则同样无法加载（尽管源码中表示 <code>--preload-rom</code> 是适用 Slot 1 而不是 Slot 2 的选项）。</p>
<p>　　这个选项也可以通过 GUI 配置。在 0.9.9 版本前，使用菜单 <code>Emulation</code> → <code>GBA Slot</code> 。自 0.9.9 版本起，使用菜单 <code>Config</code> → <code>Slot 2 (GBA Slot)</code> 。</p>
<p><strong>注意</strong> DeSmuME svn4030 及之后的一些版本（至少包括 0.9.8 ）会在载入 MPCF 映像时错误地忽略 <code>--cflash-path</code> 选项，以 仿真(Emulation) → GBA 插槽(GBA Slot) 菜单中的设置或对应配置文件 <code>desmume.ini</code> 中指定正确的路径。</p>
<p>　　在 <code>desmume.ini</code> 中有效的最小配置：</p>
<pre><code class="language-ini">[GBAslot]
type=1
[GBAslot.CFlash]
fileMode=0
path=H:\NDS\efsroot\
</code></pre>
<p>　　这里 <code>H:\NDS\efsroot</code> 是 <code>$FAT_Path</code> 的一个示例。</p>
<p><strong>注意</strong> 自 Slot1 0.9.10 起，当 Slot 1 设置为 R4 时会覆盖 Slot 2 设置加载 R4 路径（ Dev+ 版本显示自动 DLDI 补丁在 Slot 1 设置为 R4 从 <code>GBA Movie Player (Compact Flash)</code> 改为 <code>R4(DS) - Revolution for DS</code> ），因此需确保<strong>Slot 1 设置不为 R4 ，或正确设置了 Slot 1 R4 的路径</strong>（而改用 Slot 1 映射）。</p>
<h2 id="mingw32"><a class="header" href="#mingw32">MinGW32</a></h2>
<p>　　自 build 431 起，YFramework 使用的 <a href="https://freeimage.sourceforge.io/">FreeImage</a> 修改版集成 <a href="https://zh.wikipedia.org/zh-cn/Libjpeg#libjpeg-turbo">libjepg-turbo</a> ，需要 CPU 支持 <a href="https://zh.wikipedia.org/zh-cn/SSE2">SSE2</a> 指令集扩展。</p>
<p>　　除 2005 年前生产的硬件外绝大多数环境已经满足这个条件。当前几乎所有兼容 IA-32 的市售 CPU 都包含 SSE2 支持。特别地，支持 x86_64 指令集的 CPU 要求支持 SSE2 ，在使用 x86_64 的 64 位 Windows 上运行 32 位 Win32 程序（通过 <a href="https://zh.wikipedia.org/zh-cn/WoW64">WoW64</a> ）也支持 SSE2 。</p>
<h2 id="android"><a class="header" href="#android">Android</a></h2>
<p>　　可使用 <code>adb</code> 命令安装 APK 包，如：</p>
<pre><code class="language-shell">"$ANDROID_SDK/platform-tools/adb" -e install -r "$1"
</code></pre>
<p>　　此处 <code>-e</code> 指定 TCP/IP 设备（通常是模拟器），若使用 USB 设备（通常是物理机器）应移除或使用较新的 <code>adb</code> 的 <code>-d</code> 选项代替；<code>"$1"</code> 指定 APK 文件路径。</p>
<p>　　之后，在 Android 的 GUI 环境下直接运行安装的程序。</p>
<p>　　若因签名变更等原因无法覆盖安装或更新，需要先卸载后再安装。</p>
<p><strong>注意</strong> Android 安装 <code>.apk</code> 包时需要占用额外存储资源。为避免内置存储空间不足导致不直接表现安装失败（需要 <code>logcat</code> 查看）但直至运行时找不到二进制库而导致启动失败，应保留足够的空间，特别是对占用较大的 debug 配置构建的映像。保留空间的大小一般大于 <code>.apk</code> 作为 <code>.zip</code> 解压缩占用的空间。另见<a href="https://code.google.com/p/android/issues/detail?id=21670">此处报告的未确认的类似问题</a>。</p>
<h1 id="框架约定"><a class="header" href="#框架约定">框架约定</a></h1>
<p>　　除非另行指定，YFramework 的运行时行为适用以下约定。</p>
<h2 id="外部数据格式"><a class="header" href="#外部数据格式">外部数据格式</a></h2>
<p>　　YFramework 使用 UTF-8 作为<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">外部文本编码</a>。</p>
<p><strong>注释</strong> 这可支持<a href="Development.zh-CN.html#%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6">默认要求的文本处理规则</a>。YBase 没有这个假定，但使用 YBase 处理数据时通常能兼容这个假定。</p>
<h2 id="文件访问约定"><a class="header" href="#文件访问约定">文件访问约定</a></h2>
<p>　　除非另行指定，YFramework 对外部文件的访问适用本节约定。</p>
<p><strong>注意</strong> 除非另行指定，程序访问配置文件的时机是未指定的。</p>
<h3 id="基本要求"><a class="header" href="#基本要求">基本要求</a></h3>
<p>　　应确保外部文件满足以下条件，否则运行时出错，或在另行指定（暂无）的特定情形下不保证行为符合预期：</p>
<ul>
<li>具有适当的（可读和可写）权限以允许程序访问其内容及元数据，或在必要时进行创建。</li>
<li>需要写入的文件所在的位置应该具有足够的空间。</li>
</ul>
<h3 id="文件映射和内存映像"><a class="header" href="#文件映射和内存映像">文件映射和内存映像</a></h3>
<p>　　文件读写使用 YCLib::MemoryMapping ，优先使用内存文件映射。在文件无法访问时，部分文件可能使用内存映像代替。</p>
<p><strong>注意</strong> 除非使用内存映像，应确保外部文件的内容可读；否则，可在之后引发无法恢复的错误；参见当前实现使用的 <a href="Features.zh-CN.html">YCLib::MemoryMapping 的注意事项</a>。</p>
<h3 id="共享文件"><a class="header" href="#共享文件">共享文件</a></h3>
<p>　　宿主平台使用协同锁(advisory lock) 对并发文件内容访问提供有限的共享保护，避免基于 YFramework 程序并发访问外部文件时的竞争。不使用强制锁(mandatory lock) 以利于提升性能。</p>
<p><strong>注意</strong> 除检查文件创建外，不提供相关文件系统元数据并发访问保护。</p>
<p><strong>注意</strong> 因为锁定非强制，宿主不保证其它机制访问文件的程序（如非 YFramework 程序）在这里产生冲突，有可能破坏文件内容。用户应避免对相关文件造成此类访问的破坏性编辑。</p>
<p><strong>注意</strong> 因为访问顺序未指定，不同 YFramework 实例可能修改相同的文件（如配置文件）而导致外部可见的影响。</p>
<p>　　未来可能添加完整的对共享文件内容修改的传递和检查的机制。</p>
<h2 id="配置生成和输入输出"><a class="header" href="#配置生成和输入输出">配置生成和输入输出</a></h2>
<p>　　配置文件可能提供默认内容，在外部文件不存在或读取失败时尝试创建。默认内容一般由框架直接提供。</p>
<ul>
<li>自动生成并保存外部文件时需确保程序可在指定目录下创建文件。
<ul>
<li>具体目录视具体文件而定。</li>
<li>可在运行前部署正确的配置文件以避免自动生成。</li>
</ul>
</li>
<li>若无法满足，生成保存在内存中的临时配置映像之后的修改不会保存到外部文件。
<ul>
<li><strong>注意</strong> 某些版本的 Windows （如 Windows Vista 以后的版本）在特定的目录（如 <code>%PROGRAMFILES%</code> ）中创建文件默认需要管理员权限。</li>
</ul>
</li>
</ul>
<h2 id="公共配置文件"><a class="header" href="#公共配置文件">公共配置文件</a></h2>
<p>　　文件 <code>yconf.txt</code> 为 YFramework 程序的公共<a href="Tutorial/Configuration.zh-CN.html">配置</a>文件，在框架初始化时，先于其它配置文件之前处理。若不存在，提供默认内容。其位置是预先指定的，和平台相关。详见下一章对框架初始化的说明。</p>
<p>　　为避免 YFramework 程序在运行时出错或行为不符合预期，注意确保满足前述访问约定的要求。若无法在程序映像文件所在目录（详见以下关于框架初始化的说明）创建文件，配置不能保存到外部文件。</p>
<p>　　在 Win32 上一个正确的公共配置文件的内容可能是这样的：</p>
<pre><code class="language-yconf.txt">YFramework
(
	DataDirectory "C:\Data\\"
)
(
	FontDirectory "C:\Windows\Font\\"
)
(
	FontFile "C:\Windows\Font\FZYTK.TTF"
)
</code></pre>
<p>　　这里指定的路径分别为数据目录路径、字体文件目录路径和字体文件路径。</p>
<h2 id="数据目录"><a class="header" href="#数据目录">数据目录</a></h2>
<p>　　用于存放 YFramework 程序必要的数据以及运行时的配置。</p>
<p>　　通过 <code>yconf.txt</code> 中项 <code>DataDirectory</code> 的值指定数据目录的路径。</p>
<p>　　自动生成的配置中数据目录的默认路径如下：</p>
<ul>
<li>DS ：<code>/Data</code> 目录</li>
<li>Win32 ：同默认生成配置文件所在的目录</li>
<li>Android ：SD 卡目录（自动检测同上）下的 <code>Data</code> 目录</li>
<li>其它平台：当前工作目录</li>
</ul>
<p>　　当前可用数据文件位于 YSLib 存储库的 <code>Data</code> 目录下，可自行复制到数据目录。</p>
<h3 id="chrlib-的-gbk-转换例程初始化"><a class="header" href="#chrlib-的-gbk-转换例程初始化">CHRLib 的 GBK 转换例程初始化</a></h3>
<p>　　对使用 CHRLib 提供的 GBK 编码转换的程序，需保证数据目录下存在数据文件 <code>cp113.bin</code> 。</p>
<p>　　对 Win32 平台，CHRLib 初始化 GBK 转换例程读取数据文件失败时，首先尝试使用 NLS 替代：</p>
<ul>
<li>通过读取注册表取得 NLS 文件路径，默认为系统目录下的 <code>C_936.NLS</code>（文件名大小写可能不同，这不影响加载）。</li>
<li><strong>注意</strong> 并非所有 Windows 安装带有指定的 NLS 文件。
<ul>
<li>具体支持的 NLS 文件名由注册表读取。这些文件在系统目录（<code>%WINDIR%\System32</code> 或 <code>%WINDIR%\SysWOW64</code>）存在。这些目录中是否存在注册表中指定文件的 NLS 文件首先和系统支持的语言相关。</li>
<li>新近版本的 64 位 Windows 10 可能在 <code>%WINDIR%\System32\C_936.NLS</code> 但不存在 <code>%WINDIR%\SysWOW64\C_936.NLS</code> 。由于 64 位 Windows 默认<a href="https://msdn.microsoft.com/library/windows/desktop/aa384187.aspx">对系统目录重定向</a>，导致 32 位系统中直接读取系统目录找不到 NLS 文件。在 build 937 前，YFramework 初始化加载 NLS 文件时不特别处理这种情况，因此 NLS 不可用。</li>
</ul>
</li>
<li>若 Win32 NLS 初始化仍然失败，则 CHRLib 初始化 GBK 转换例程失败。</li>
</ul>
<p>　　对其它平台，数据文件读取失败则 CHRLib 初始化 GBK 转换例程失败。</p>
<p>　　初始化失败后，使用 CHRLib 转换 GBK 编码的程序在调用转换例程时抛出异常，可能导致程序非正常退出。</p>
<h3 id="mime-数据"><a class="header" href="#mime-数据">MIME 数据</a></h3>
<p>　　数据目录下的配置文件 <code>MIMEExtMap.txt</code> 存储 MIME 数据。若不存在，提供默认内容。</p>
<h3 id="字体目录和文件路径"><a class="header" href="#字体目录和文件路径">字体目录和文件路径</a></h3>
<p>　　只要其中之一有效即可（若没有成功指定字体文件路径，则默认字体文件路径不确定）。</p>
<p>　　自动生成的配置中字体文件的默认路径如下：</p>
<ul>
<li>DS ：<code>/Font/FZYTK.ttf</code></li>
<li>Win32 ：系统字体目录下的 <code>SimSun.ttc</code></li>
<li>Android ：<code>/system/fonts/DroidSansFallback.ttf</code></li>
<li>Linux ：<code>./SimSun.ttc</code></li>
</ul>
<p>　　自动生成的配置中字体目录的默认路径如下：</p>
<ul>
<li>DS ：<code>/Font</code> 目录</li>
<li>Android ：<code>/system/fonts</code> 目录</li>
<li>其它平台：同数据目录</li>
</ul>
<h2 id="框架初始化"><a class="header" href="#框架初始化">框架初始化</a></h2>
<p>　　框架初始化服务于整个框架。</p>
<p>　　初始化的重要策略之一是在程序启动时减少不必要的初始化，以允许实现以下目的：</p>
<ul>
<li>减少可能的外部依赖（如不需要使用文字的程序就不初始化字体缓存，也不需要依赖外部字体文件和字体配置等）。</li>
<li>减少可能的运行时程序资源占用。</li>
<li>保留静态链接时优化去除没有调用的代码以减少二进制可执行文件大小的可能性。</li>
</ul>
<p>　　按当前框架的设计，框架初始化在 DS 平台在程序运行初始阶段完成。其它平台可延迟初始化，按需调用。</p>
<p>　　并非所有 YFramework 中的 API 都要求框架初始化。以下功能隐含自动进行的框架初始化：</p>
<ul>
<li>使用默认字体缓存。</li>
<li>使用 MIME 数据时。</li>
</ul>
<p>　　框架初始化加载配置文件，其中配置文件路径的确定方式参见以下节的说明。成功公共加载配置文件后，框架初始化检查配置文件的内容，并访问框架公共配置。若检查失败，抛出异常。</p>
<p>　　修改 YFramework 模块 Helper::Initialization 重新编译后，可修改默认设置改变初始化行为。以下行为<strong>可能会在未来改变</strong>。</p>
<h3 id="根路径"><a class="header" href="#根路径">根路径</a></h3>
<p>　　<strong>根路径(root path)</strong> 是框架初始化时参考的基本路径，由如下方式确定：</p>
<ul>
<li>Win32 和 Linux（除 Android ）：程序映像所在的目录。</li>
<li>Android ：SD 卡目录（自动按顺序检测 <code>/sdcard</code> 、<code>/mnt/sdcard</code> 或 <code>/storage/sdcard0</code> 之一）。</li>
<li>其它平台：第一次初始化时的当前工作目录。</li>
</ul>
<p>　　确定根路径在框架初始化或要求确定根路径时进行。若定位程序映像，同时会解析符号链接。若定位根路径失败，抛出异常。</p>
<p>　　抛出的异常默认不被框架处理，可使程序退出。用户代码捕获特定异常可改变默认退出行为。</p>
<h3 id="配置路径"><a class="header" href="#配置路径">配置路径</a></h3>
<p>　　公共配置文件 <code>yconf.txt</code> 所在目录的路径前缀（结尾带有路径分隔符）称为框架的<strong>配置路径(configuration path)</strong> ，决定和平台相关的配置加载起始位置。配置路径和配置文件相对路径（对 <code>yconf.txt</code> ，即配置文件名）组合得到配置文件路径。</p>
<p>　　配置路径的确定方式和平台相关。</p>
<p>　　任意平台总能确定一个首选的配置路径。</p>
<p>　　除首选的配置路径外，一些平台还支持一个或多个不同的<em>后备(fallback) 配置路径</em>。在读写特定的配置文件时，若根路径访问失败，但存在后备配置路径，依序使用这些路径重试直至成功或全部访问失败。这样的配置文件当前包括 <code>yconf.txt</code> 。具体应用可使用初始化 API 以类似的方式加载其它配置文件。</p>
<p>　　以下是具有后备配置路径的平台中确定配置路径的顺序：</p>
<ul>
<li>Linux（除 Android ）：
<ul>
<li>首先使用首选的配置路径。</li>
<li>若环境变量 <code>HOME</code> 的值非空，则路径 <code>$HOME/.YSLib/</code> 是后备配置路径。</li>
</ul>
</li>
<li>Win32 ：
<ul>
<li>同 Linux 平台的顺序（对应使用 Win32 的环境变量和路径语法，即后备配置路径 <code>%HOME%\.YSLib\</code> ）。</li>
<li>若环境变量 <code>USERPROFILE</code> 的值非空，则路径 <code>%USERPROFILE%\.YSLib\</code> 是后备配置路径。</li>
<li><strong>注意</strong> 环境变量 <code>HOME</code> 在此不影响 Win32 中约定的路径。但是，Win32 中的<a href="Development.zh-CN.html#%E8%84%9A%E6%9C%AC">脚本运行环境</a>支持 <a href="Development.zh-CN.html#shell-%E8%84%9A%E6%9C%AC">shell 脚本</a>，可具有和 <a href="https://pubs.opengroup.org/onlinepubs/9799919799/utilities/V3_chap02.html#tag_19_05_03">POSIX.1 定义的兼容的行为而附加依赖 <code>HOME</code></a> 。
<ul>
<li><strong>原理</strong> 这和<a href="https://github.com/rust-lang/rust/issues/28940#issuecomment-147274312">现有的一些语言的行为类似</a>。</li>
<li>在此处的约定外，实现可以提供附加的接口兼容显式引入这种行为。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　后备配置路径中若子目录 <code>.YSLib</code> 不存在则被创建。若创建失败，配置路径访问失败。</p>
<p>　　对不具有后备路径的平台，首选的配置路径总是根路径。否则，首选的配置路径由以下方式确定：</p>
<ul>
<li>程序映像所在的位置可推断出<a href="Run.zh-CN.html#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80">局部 FHS 目录布局</a>，则首选的配置路径为程序映像所在的目录的上一级目录的 <code>var</code> 子目录下的 <code>YSLib</code> 子目录。
<ul>
<li>推断文件系统布局为以 POSIX 环境变量语法表示为 <code>$PREFIX/</code>、<code>$PREFIX/$BIN/</code>、<code>$PREFIX/lib/</code> 和 <code>$PREFIX/share/</code> 这些路径前缀都存在且可作为目录访问，其中 <code>$PREFIX</code> 是程序映像所在的目录的上级目录，而 <code>$BIN</code> 是程序映像所在的目录的名称（按 <a href="Run.zh-CN.html#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80">FHS</a> 通常为 <code>bin</code> ，此处不检查）。</li>
<li>这保证创建映像的可执行程序映像的目录中内容不被修改，以符合 FHS 。</li>
</ul>
</li>
<li>否则，首选的配置路径为根路径。
<ul>
<li>确定配置路径要求确定根路径。</li>
</ul>
</li>
</ul>
<p>　　对不具有后备路径的平台不检查文件系统布局，也不要求实现确保程序映像路径的操作，以简化实现。</p>
<p><strong>注意</strong> 若后备配置路径的配置文件可访问，直接使用此配置文件保存配置，不再创建配置文件。若需要恢复在首选配置路径创建配置文件的行为，需确保后备配置路径的配置文件不可访问（例如，移除所有后备配置路径的这些配置文件）。</p>
<h3 id="配置文件加载"><a class="header" href="#配置文件加载">配置文件加载</a></h3>
<p>　　加载配置文件 <code>yconf.txt</code> 时，首先按上述的顺序确定各个配置路径，每确定一个路径时访问其中的配置文件。若全部失败（如找不到可读的文件），则尝试自动生成配置并创建配置文件。创建配置文件的位置和顺序同上述确定配置路径的顺序。若创建配置文件全部失败，则放弃创建配置文件，直接使用生成的配置。</p>
<p>　　不存在配置文件时，配置不能通过 Helper::Initialization 的 API 持久化保存，尝试保存配置会失败。</p>
<h3 id="其它初始化"><a class="header" href="#其它初始化">其它初始化</a></h3>
<p>　　成功后，框架进一步处理公共配置文件以外的其它初始化；详见以上具体配置文件的相关章节。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://en.wikipedia.org/wiki/DeSmuME">DeSmuME</a> is a cross-platform, open source <a href="https://en.wikipedia.org/wiki/Nintendo_DS_line#Nintendo_DS_family">Nintendo DS/DS Lite/DSi/DSi LL(XL)</a> emulator.</p>
<p>Use "dev" version to debug with GDB.</p>
<p>It is possible to debug with Visual Studio debugger with WinGDB.</p>
<h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<p>See <a href="http://desmume.org/">official website</a> for details.</p>
<ul>
<li><a href="http://desmume.org/download/">Download page</a></li>
<li><a href="http://sourceforge.net/p/desmume/code/HEAD/tree/">Source</a></li>
</ul>
<p>Note that due to the DLDI bug, homebrew programs are not supported on newest versions. Use <a href="http://sourceforge.net/projects/desmume/files/desmume/0.9.9/">0.9.9</a> or a suitable custom build instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="版本库结构和文件说明"><a class="header" href="#版本库结构和文件说明">版本库结构和文件说明</a></h1>
<p>　　版本库依赖支持子目录的层次文件系统。以下只包括版本库根目录下的顶级子目录和少数特定的二级子目录及其中的部分文件的说明。</p>
<ul>
<li><code>.git</code> Git 目录（可通过 hg-git 同步）</li>
<li><code>.hg</code> Mercurial 目录</li>
<li><code>3rdparty</code> 第三方依赖项</li>
<li><code>Data</code> 最终用户环境中部署的数据目录</li>
<li><code>Tools</code> 开发使用的（辅助）工具
<ul>
<li><code>Tools/SHBuild</code> SHBuild 构建工具</li>
<li><code>Tools/Scripts</code> 用于构建和建立 SHBuild 环境的工具脚本</li>
</ul>
</li>
<li><code>YBase</code> 顶级子项目 YBase</li>
<li><code>YFramework</code> 顶级子项目 YFramework</li>
<li><code>YSTest</code> 测试用示例项目目录（项目名为 YSTest ，以实际内容命名的项目名为 YReader ）
<ul>
<li><code>YSTest/Android</code> 示例项目 YReader 的 Android 平台项目（未完成正式支持）</li>
<li><code>YSTest/DS_ARM7</code> 示例项目 YReader 的 ARM7 项目（仅用于 DS 平台，用于生成 ARM7 ELF 二进制映像）</li>
<li><code>YSTest/DS_ARM9</code> 示例项目 YReader 的 ARM9 项目（包括 DS 平台 ARM9 部分，于生成 ARM9 ELF 二进制映像；源代码和其它平台共享）</li>
<li><code>YSTest/DS</code> 示例项目 YReader 的 DS 平台可执行文件项目（仅用于 DS 平台，用于生成 NDS 文件）</li>
<li><code>YSTest/MinGW32</code> 示例项目 YReader 的 MinGW32 平台可执行文件项目（仅用于 MinGW32 平台，用于生成 EXE 文件）</li>
</ul>
</li>
<li><code>build</code> 默认构建目录（可选构建时生成）</li>
<li><code>doc</code> 开发文档</li>
<li><code>doc/vsd</code> 架构示意 Visio 文档</li>
<li><code>test</code> 测试代码目录</li>
<li><code>.gitignore</code> Git 忽略文件</li>
<li><code>.hgeol</code> Mercurial EOL 插件配置文件</li>
<li><code>.hgignore</code> Mercurial 忽略文件</li>
<li><code>.hgtags</code> Mercurial 标签文件</li>
<li><code>CC BY-SA 3.0 legalcode.txt</code> 文档许可证： Creative Commons Legal Code Attribution-ShareAlike 3.0 Unported</li>
<li><code>Doxyfile</code> Doxygen 配置文件</li>
<li><code>FTL.TXT</code> 许可证： The FreeType Project LICENSE</li>
<li><code>gpl-2.0.txt</code> 许可证： GNU GENERAL PUBLIC LICENSE Version 2</li>
<li><code>gpl-3.0.txt</code> 许可证： GNU GENERAL PUBLIC LICENSE Version 3</li>
<li><code>LICENSE.txt</code> 整体许可证</li>
<li><code>LICENSE_HISTORY.txt</code> 整体许可证：历史版本</li>
<li><code>license-fi.txt</code> 许可证： FreeImage Public License - Version 1.0</li>
<li><code>Readme.zh-CN.txt</code> 自述文件</li>
<li><code>YSTest.sln</code> Visual Studio 解决方案文件</li>
<li><code>YSTest.workspace</code> Code::Blocks 工作空间文件</li>
</ul>
<p><strong>注释</strong> 以上布局中的顶级子目录可作为顶级子项目或作为项目模块在开文档中引用，其名称起始使用大写字母，以目录的名称原文作为模块名称。其它构建时生成以外的目录也可被引用，但不使用目录名称作为模块名称。</p>
<p>　　顶级子项目或其中的平台子目录中，可包含以下目录：</p>
<ul>
<li><code>include</code> 可被安装部署的公开头文件</li>
<li><code>source</code> 被构建的源文件</li>
</ul>
<p>　　以下目录会被默认支持的构建配置生成：</p>
<ul>
<li><code>YDE/</code> 下以 <code>.</code> 起始的特定宿主平台为子目录名的构建目录是 <a href="Sysroot.zh-CN.html">stage 2 环境</a>下的 <a href="YDE.zh-CN.html">YDE 项目</a>的生成文件目录</li>
<li><code>build/</code> 下以特定的宿主平台为子目录名的默认构建目录，默认配置构建时会创建不同的平台目录，其中的子目录可包括：
<ul>
<li><code>.stage1</code> <a href="Tools/SHBuild.zh-CN.html">stage 1 环境</a> 构建和生成目录</li>
<li><code>.test</code> <a href="Test.zh-CN.html">测试项目</a>构建和生成文件目录</li>
<li>以 <code>.</code> 起始的其它 <a href="Sysroot.zh-CN.html">Sysroot</a> 构建目录，用于创建 <a href="Sysroot.zh-CN.html">stage 2 环境</a>的 YSLib 库以及基于 stage 2 环境的 Sysroot 方式的 YSTest 的构建</li>
<li>其它非 Sysroot 的 YSLib 和 YSTest 项目生成文件目录</li>
</ul>
</li>
<li><code>sysroot</code> 使用<a href="Tools/Scripts.zh-CN.html">脚本</a>构建的默认 <a href="Sysroot.zh-CN.html">Sysroot （含 stage 2 环境）</a> 生成目录</li>
</ul>
<h2 id="文件系统布局约定"><a class="header" href="#文件系统布局约定">文件系统布局约定</a></h2>
<p>　　版本库遵循一定的文件系统布局规则。这些规则在这里和一些开发文档中被描述。没有通过这些描述被明确的布局应被视为实现细节，其改变可不被文档描述。</p>
<p>　　不论是否是实现细节，特定的路径都可被版本库的忽略文件路径涵盖。</p>
<p><strong>注意</strong> 版本库中的文件系统布局和 Sysroot 约定的部署实例的布局相互独立，不适用此处的规则，且布局可能存在差异。</p>
<p>　　虽然没有在项目初始指定，版本库中部分目录和文件结构及使用方式与现有的一些约定类似或兼容：</p>
<ul>
<li>部分文件系统布局和使用符合 <a href="https://api.csswg.org/bikeshed/?force=1&amp;url=https://raw.githubusercontent.com/vector-of-bool/pitchfork/develop/data/spec.bs">cxx-pflR1</a> 。
<ul>
<li>顶级子目录 <code>build</code> 符合 <a href="https://api.csswg.org/bikeshed/?force=1&amp;url=https://raw.githubusercontent.com/vector-of-bool/pitchfork/develop/data/spec.bs#tld.build"><code>build/</code></a> 指定的目的和作用。</li>
<li>顶级子项目或其中的平台子目录中的子目录 <code>include</code> 和 <code>source</code> 对应符合 <a href="https://api.csswg.org/bikeshed/?force=1&amp;url=https://raw.githubusercontent.com/vector-of-bool/pitchfork/develop/data/spec.bs#tld.include"><code>include/</code></a> 和 <a href="https://api.csswg.org/bikeshed/?force=1&amp;url=https://raw.githubusercontent.com/vector-of-bool/pitchfork/develop/data/spec.bs#tld.src"><code>src/</code></a> 指定的目的和作用，其使用符合<a href="https://api.csswg.org/bikeshed/?force=1&amp;url=https://raw.githubusercontent.com/vector-of-bool/pitchfork/develop/data/spec.bs#src.header-placement">分离放置布局</a>。</li>
<li>顶级子目录 <code>test</code> 符合 <a href="https://api.csswg.org/bikeshed/?force=1&amp;url=https://raw.githubusercontent.com/vector-of-bool/pitchfork/develop/data/spec.bs#tld.tests"><code>tests/</code></a> 指定的主要目的和作用，但不限于非单元测试。</li>
<li>顶级子目录 <code>Data</code> 符合 <a href="https://api.csswg.org/bikeshed/?force=1&amp;url=https://raw.githubusercontent.com/vector-of-bool/pitchfork/develop/data/spec.bs#tld.data"><code>data/</code></a> 指定的主要目的和作用，但强调最终用户环境，且不适用生成文档的源代码。</li>
<li>顶级子目录 <code>doc</code> 符合 <a href="https://api.csswg.org/bikeshed/?force=1&amp;url=https://raw.githubusercontent.com/vector-of-bool/pitchfork/develop/data/spec.bs#tld.docs"><code>docs/</code></a> 指定的目的和作用。</li>
<li>因为不使用版本管理的子模块机制，不使用 <a href="https://api.csswg.org/bikeshed/?force=1&amp;url=https://raw.githubusercontent.com/vector-of-bool/pitchfork/develop/data/spec.bs#tld.libs"><code>libs/</code></a> 和 <a href="https://api.csswg.org/bikeshed/?force=1&amp;url=https://raw.githubusercontent.com/vector-of-bool/pitchfork/develop/data/spec.bs#submod.extras"><code>extras/</code></a> ，符合指定的规则。</li>
</ul>
</li>
<li>部分文件系统布局和使用符合 <a href="http://jdebp.uk/FGA/slashpackage.html">Jonathan de Boyne Pollard 约定的 slashpackage 内部结构</a>。
<ul>
<li>顶级子项目或其中的平台子目录中的子目录 <code>source</code> 符合指定的目的和作用。</li>
<li>默认构建目录是名为 <code>build</code> 的一级子目录，可能不存在，符合指定的目的和作用。</li>
<li>除构建目录外的文件预期不应被构建过程修改，默认与之兼容。</li>
<li>不要求 <code>source</code> 链接到 <code>build</code> ，与之不兼容。</li>
<li>构建 Sysroot 可能直接链接文件到输出目录，与之不兼容。</li>
<li>仅要求部署过程正常时的部署目标目录的完整性，不要求更新是原子的或可事务性回滚，与之不兼容。</li>
</ul>
</li>
</ul>
<h1 id="项目结构和特性"><a class="header" href="#项目结构和特性">项目结构和特性</a></h1>
<p>　　项目内容以模块为单位组织。关于模块的概念及其表示形式，详见 YSLib 项目文档 <code>doc/ProjectRules.txt</code> 。因为特性众多，在此只列出较上层的基本结构，不总是精确到具体模块。</p>
<h2 id="ybase-yframework-基础库"><a class="header" href="#ybase-yframework-基础库">YBase ：YFramework 基础库</a></h2>
<p>　　详见 <code>doc/YBase.txt</code> 。</p>
<p>　　替代标准库的特性另见 <a href="StandardUsing.en-US.html">StandardUsing(en-US)</a> 。</p>
<ul>
<li>YStandardEx ： YFramework 标准扩展库</li>
<li>LibDefect ：标准库修正</li>
<li>YTest ：YFramework 基础测试库</li>
</ul>
<h2 id="yframework--yframework-框架库"><a class="header" href="#yframework--yframework-框架库">YFramework ： YFramework 框架库</a></h2>
<p>　　详见 <code>doc/YFramework.txt</code> 。</p>
<ul>
<li>CHRLib ：字符编码处理库
<ul>
<li>编码标识</li>
<li>目前支持 UTF-8/UCS-2/UCS-4/GBK ，可扩充</li>
<li>默认编码 UTF-8</li>
</ul>
</li>
<li>YCLib ： YSLib 基础库
<ul>
<li>Platform ：平台定义</li>
<li>平台相关 API 封装</li>
<li>平台相关硬件抽象</li>
<li>Win32 专用接口（略）</li>
</ul>
</li>
<li>YSLib ：YShell 库（主体，暂定）
<ul>
<li>Adaptor ：适配器层
<ul>
<li>Configuration ： 库配置</li>
<li>YReference ：智能指针封装（基于 Loki 实现【已移除】/使用 ISO C++11 标准库）</li>
<li>简单的内存调试设施</li>
<li>附加容器（可选 Loki 的 yasli 容器，默认不启用）</li>
<li>Anti-Grain Geometry 2.4 移植（修复了一处在 2.5 仍然存在的 bug ），因在 DS 上效率太低所以默认不启用【已移除】</li>
<li>Font ：字体管理（基于 FreeType 2 实现）</li>
<li>Image ：平台中立的图像输入和输出（基于 FreeImage 实现）</li>
</ul>
</li>
<li>Core ： YSLib 核心</li>
<li>Service ：YSLib 服务</li>
<li>UI ： YSLib 用户界面</li>
<li><a href="Features/NPL.zh-CN.html">NPL</a></li>
<li>Helper ：助手库：初始化、宿主支持等</li>
</ul>
</li>
</ul>
<h2 id="yreader-示例"><a class="header" href="#yreader-示例">YReader ：示例</a></h2>
<ul>
<li>ShlExplorer ：文件列表浏览</li>
<li>控件测试：按钮点击、窗口拖曳、FPS （伪）显示等</li>
<li>Shell 切换</li>
<li>ShlReader ：文本浏览
<ul>
<li>读取并显示文本文件的内容</li>
<li>随机跳转</li>
<li>书签设置、读取和保存</li>
</ul>
</li>
<li>HexBrowser：十六进制浏览</li>
</ul>
<h1 id="构建-1"><a class="header" href="#构建-1">构建</a></h1>
<p>　　支持使用多种途径进行<a href="Build.zh-CN.html">构建</a>。支持<a href="Terminology.zh-CN.html">多平台构建</a>。另见 <a href="Sysroot.zh-CN.html">Sysroot</a> 和以下的“轮子列表”章节。</p>
<p>　　<a href="Terminology.zh-CN.html">依赖</a>以模块为单位组织。接口（如公开 API 头文件）不出现循环依赖。</p>
<p>　　可通过修改代码以裁剪、定制库实现内部的模块构建（如为了减小编译后的二进制映像体积），但应注意在 YSLib 项目文档中列出的显式依赖规则。未来可能会支持构建时的定制配置工具。</p>
<h1 id="abi"><a class="header" href="#abi">ABI</a></h1>
<p>　　目前除 YBase::LibDefect 和具体实现兼容外，不保证 ABI 稳定。</p>
<p>　　具体策略详见 YSLib 项目文档 <code>doc/</code> 下各个库的文档。</p>
<h1 id="api"><a class="header" href="#api">API</a></h1>
<p>　　对各 API 的说明和注意事项详见 YSLib 项目中的源代码，可<a href="BuildDocumentation.zh-CN.html">构建文档</a>。</p>
<h2 id="平台相关-api-注意事项"><a class="header" href="#平台相关-api-注意事项">平台相关 API 注意事项</a></h2>
<ul>
<li>YCLib::MemoryMapping 中 <code>platform::MappedFile</code> 的实现需确保文件内容可访问，否则取指针后，可在之后的操作中引发不可恢复的错误。
<ul>
<li>在硬件支持 MMU 的平台上，使用内存映射实现。
<ul>
<li>读取错误产生不可恢复的错误。
<ul>
<li>因为无法确保确定的调用位置，框架不做任何处理。
<ul>
<li>除非用户程序进行处理，这将导致程序崩溃。</li>
</ul>
</li>
<li>Win32 平台：失败时<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa366801(v=vs.85).aspx">引发 <code>EXCEPTION_IN_PAGE_ERROR</code> 结构化异常</a>。</li>
<li>POSIX 宿主平台：失败时<a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html">引发 <code>SIGSEGV</code> 信号</a>。</li>
</ul>
</li>
<li>因此不支持不可靠的远程文件。</li>
</ul>
</li>
<li>其它平台（当前包括 DS ），使用文件流模拟。
<ul>
<li>若 <code>platform::MappedFile</code> 初始化失败会直接抛出异常。除非用户代码忽略，可避免引发后续失败（引起未定义行为）。</li>
</ul>
</li>
<li>当前仅支持只读映射。若修改取得的映射指针指向的存储，在使用内存映射实现的平台上也可引发上述行为类似的不可恢复的错误。</li>
</ul>
</li>
</ul>
<h2 id="标准库使用"><a class="header" href="#标准库使用">标准库使用</a></h2>
<p>　　YSLib 对 C++ 标准库<a href="Prerequisitions.zh-CN.html">具有明确的要求</a>，且仅使用<a href="StandardUsing.en-US.html">明确的标准库特性</a>。</p>
<p>　　和 <a href="http://llvm.org/docs/CodingStandards.html#c-standard-library">LLVM 编码标准对 C++ 标准库的使用(en-US)</a>类似，YSLib 强调尽可能依赖标准库的公开接口。仅在具有充足理由时不依赖标准库而提供和使用自定义 API （基本上总是因为设计和实现的质量不足够满足需求和以上要求的原因）。</p>
<p>　　对标准库特性使用的具体限制见<a href="Development.zh-CN.html">开发说明</a>及 YSLib 项目文档 <code>doc/LanguageConvention.txt</code> 等规则。</p>
<p>　　相关的其它原理另见下节。</p>
<h2 id="轮子列表"><a class="header" href="#轮子列表">轮子列表</a></h2>
<p>　　本项目发明了一些轮子。为了符合<a href="Home.zh-CN.html">不重复发明轮子的项目内容规则</a>，在发现更好的替代时，其中一些会被逐渐移除。</p>
<p>　　但是，其余一些轮子，因为特定的原因，不视为对此规则的违反而得以保留，包括一些在当前实现中使用的和较新版本语言规范中提供的兼容的特性。</p>
<p>　　主要包括以下内容：</p>
<ul>
<li>YBase.YStandardEx
<ul>
<li>为了兼容性需要，一些标准库接口的实现会被保留。但当合适的版本可用时，通过条件包含选择别名声明，优先使用标准库提供的版本。</li>
<li>Meta 、TypeTraits 以及其它元编程设施
<ul>
<li>其它元编程设施因为没有被标准化、风格和可用性问题，提供了 C++14 兼容的元函数和类似 <a href="https://github.com/ericniebler/range-v3">Range-v3</a> 及 <a href="http://boostorg.github.io/hana/">Boost.Hana</a> 的实现使用的接口。</li>
</ul>
</li>
<li>IntegerSequence
<ul>
<li>主要接口兼容 C++14 的 <code>std::integer_sequence</code> ，但早于提案 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3493.html">N3493</a> 。</li>
<li>提供了更丰富的底层接口如 <code>make_peano_sequence</code> 。</li>
</ul>
</li>
<li>Operators
<ul>
<li>接口类似 <a href="http://www.boost.org/doc/libs/1_60_0/libs/utility/operators.htm">Boost.Operators</a> ，但有以下不同：
<ul>
<li>要求 C++11 支持。</li>
<li>使用代码量较少的紧凑的实现，不支持对不符合标准的编译器的多数实现细节上的变通。</li>
<li>不支持链式模板参数（这是为了兼容不支持偏特化的编译器的变通）。</li>
<li>提供对 <code>noexcept</code> 的支持。</li>
</ul>
</li>
<li>接口类似 <a href="https://github.com/taocpp/operators">The Art of C++ / Operators</a>（原 df.operators ）。</li>
<li>除以上列出外，还有以下差异和特性：
<ul>
<li>操作符模板使用别名而不保证是类。</li>
<li>支持可选的操作符参数，默认推断 <code>constexpr</code> 。</li>
<li>重载操作符实现为模板友元以支持推断 <code>constexpr</code> 同时允许在派生类中提供显式覆盖实现。</li>
</ul>
</li>
<li>此外，提供部分不在上述类似接口中提供的成员操作符重载。</li>
</ul>
</li>
<li>Any
<ul>
<li>接口类似 <a href="http://www.boost.org/doc/libs/1_60_0/doc/html/any.html">Boost.Any</a> ，包括内部非公开的 <code>unsafe_any_cast</code> 作为扩展；此外 <code>any</code> 成员也有一些扩展。</li>
<li>除了 <code>any</code> 外还提供底层实现相关的扩展，用于实现 AnyIterator ，<strong>这无法被简单取代</strong>。</li>
<li>Any 的<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1939.html">提案</a>最早于 2006 年基于 Boost.Any 提出，未考虑 C++11 特性。此实现早于标准库提案的<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3390.html">后续修订版本</a>实现。</li>
<li>现在和 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4081.html">WG21 N4081</a> 的 <code>std::experimental::any</code> 同步，但仍然保持扩展。</li>
<li>使用了小对象优化实现，这也符合后来<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3804.html">更新的提案</a>中的建议。
<ul>
<li>空间性能<strong>明显比 Boost.Any 高效</strong>。</li>
<li><strong>libstdc++ 的 <code>std::experimental::any</code> 也使用了类似的实现，但<a href="https://gcc.gnu.org/ml/libstdc++/2014-06/msg00093.html">比此处的实现晚 1 年以上</a></strong>。早期 libstdc++ 实现还存在<a href="https://gcc.gnu.org/ml/libstdc++/2015-05/msg00052.html">遗漏考虑对齐</a>和<a href="https://gcc.gnu.org/ml/libstdc++/2015-07/msg00091.html">自赋值</a>的缺陷，这些问题在此处从不存在。</li>
</ul>
</li>
<li>提供 <code>emplace</code> 相关扩展，可避免构造 <code>any</code> 对象或赋值时冗余初始化目标类型的值。</li>
<li>提供 <code>unchecked_*</code> 成员和 <code>unchecked_any_cast</code> 模板扩展，要求参数非空，因为省略检查比对应的检查空值的接口（ <code>unchecked_any_cast</code> 对应 <code>unsafe_any_cast</code> ）更高效。</li>
</ul>
</li>
<li>Optional
<ul>
<li>ISO C++17 的 <code>&lt;optional&gt;</code> 在 ISO C++11 下的移植和扩展。</li>
<li>支持几乎所有特性，除 <code>operator-&gt;</code> 因为核心语言特性限制不总是支持结果是常量表达式。</li>
<li>支持少量扩展接口： <code>make_optional_inplace</code> 和 <code>ref_opt</code> 。</li>
</ul>
</li>
<li>Map
<ul>
<li>ISO C++17 的 <code>&lt;map&gt;</code> 在 ISO C++11 下的移植和扩展。</li>
<li>支持不完整键类型，不依赖特定扩展（如 libstdc++ 的 <code>std::map</code>）。</li>
</ul>
</li>
<li>Invoke
<ul>
<li>提供 <code>std::invoke</code> 的替代。</li>
</ul>
</li>
<li>Apply
<ul>
<li>提供 <code>std::apply</code> 的替代。</li>
</ul>
</li>
<li>Function
<ul>
<li>提供 <code>std::function</code> 的替代。</li>
</ul>
</li>
<li>Rational
<ul>
<li>类模板 <code>fixed_point</code> 和提案 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0037r1.html">P0037R1</a> 中的有相似之处，但模板参数类型更明确，且提出较早。</li>
</ul>
</li>
<li>一些非直接的（以同名接口一一替代的）标准库替代接口
<ul>
<li>减少了标准库对应的限制，提升了易用性。</li>
<li>不一定和标准库的对应功能的 API 同名。</li>
<li><code>lref</code> 部分取代 <a href="http://www.eel.is/c++draft/refwrap"><code>std::reference_wrapper</code></a> （涉及 <code>std::bind</code> 的使用无法取代）。
<ul>
<li>和 <code>std::reference_wrapper</code> 不同而和 <a href="http://www.boost.org/doc/libs/1_60_0/libs/core/doc/html/boost/reference_wrapper.html"><code>boost::reference_wrapper</code></a> 类似，
不<a href="http://www.eel.is/c++draft/refwrap#3">提供 weak result type</a> ，不<a href="http://www.eel.is/c++draft/requirements#res.on.functions-2">要求模板参数为完整类型</a>。</li>
<li>保证满足 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4277.html">WG21 N4277</a> 提出的 TrivialCopyable 要求。</li>
<li>提供配套的 <code>ref</code> 和 <code>cref</code> 外还有和 <a href="http://www.boost.org/doc/libs/1_60_0/libs/core/doc/html/core/ref.html">Boost 接口</a>一致但支持 <code>lref</code> 的 <code>is_reference_wrapper</code> 和 <code>unwrap_reference</code> 元函数。</li>
</ul>
</li>
<li><code>mapped_set</code> 用 <code>ystdex::map</code> 模拟 <code>std::set</code> 。
<ul>
<li>不要求键类型保持 <code>const</code> 。这意味着（和 C++98/03 类似）只要不影响比较操作的等价关系，元素可以使用无 <code>mutable</code> 修饰的成员而保持 <code>const</code> 类型检查。</li>
<li>使用 ADL <code>set_value_move</code> 优化插入等操作，允许转移值。</li>
<li>在 C++11 下即支持<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3657.htm">泛型查询</a>接口。</li>
<li>因为使用 <code>ystdex::map</code>  ，支持不完整键类型。</li>
</ul>
</li>
</ul>
</li>
<li>一些通常典型地用于标准库内部实现的接口
<ul>
<li>实际上也适于被用户代码使用。</li>
<li><code>has_mem_value</code> 、<code>has_nested_allocator</code> 和 <code>enable_if_transparent_t</code> 等检查类型要求的元编程设施。</li>
<li><code>search_map</code> 提供关联容器查找，适合实现 <code>map</code> 等的 <code>operator[]</code> 和 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4279.html"><code>try_emplace</code></a> 等设施。
<ul>
<li>支持迭代器提示参数。使用比当前(2016-03) 最新开发版本的 libstdc++ 更紧凑的实现（而 <a href="http://stackoverflow.com/questions/34382073/re-implementing-stdmaptry-emplace-from-c17-in-c11">libc++ 对 <code>map::try_emplace</code>，用 <code>lower_bound</code> 近似</a>，也包括对用户代码提供提示参数的情况（直接忽略提示），后者尽管满足复杂度要求但特定情况下容易更低效。</li>
</ul>
</li>
</ul>
</li>
<li>其它可在 C++11 下使用的标准库扩展
<ul>
<li>ISO/IEC TS 19568:2015 C++ Extensions for Library Fundamentals （最终草案 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html">N4480</a>） 以及 ISO/IEC DTS 19568 C++ Extensions for Library Fundamentals, Version 2 （草案 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4564.pdf">N4564</a>）的一些接口在 C++11 下的实现和 YStandardEx 扩展。
<ul>
<li>提供元函数 <code>and_</code> 、<code>or_</code> 和 <code>not_</code> 。
<ul>
<li>是早于提案 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0013r0.html">P0013R0</a> 的实现。</li>
<li>比原始提案及 libstdc++ 中使用的实现更简单。</li>
<li>以别名模板的形式支持 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0013r1.html">P0013R1</a> 。</li>
</ul>
</li>
<li>函数模板 <code>apply</code> 利用更加强大（投影到不同参数位置进行调用）的 <code>call_projection</code> 实现，而非直接基于 <code>integer_sequence</code> 。</li>
<li>类模板 <code>optional</code> 。</li>
<li>类 <code>any</code> 大体兼容这里的接口规范。</li>
<li>类模板 <code>string_view</code> 。</li>
<li>类模板 <code>observer_ptr</code> 。</li>
<li>部分比较操作使用 Operators 实现，保证一般预期的可用性同时简化实现及改善编译性能，但不完全和规范一致。</li>
</ul>
</li>
<li>函数模板 <code>destroy</code> 是早于提案 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0040r0.html">P0040R0</a> 的实现。
<ul>
<li>使用不同的参数形式被重命名为 <code>destruct</code> 等模板。</li>
<li>实现和 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0040r0.html">P0040R2</a> 兼容的相关接口。</li>
</ul>
</li>
<li>类型特征 <code>unwrap_reference</code> 早于提案 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0318r0.pdf">P0318R0</a> 提供，功能近似。</li>
</ul>
</li>
</ul>
</li>
<li>YFramework
<ul>
<li>一些接口存在第三方的高效实现，但不足以同时在性能和功能上取代现有接口和实现。（以下性能测试因为实际环境基准问题当前仅用于内部测试，未正式支持。）</li>
<li>CHRLib
<ul>
<li>提供的 UTF-8 解码实现之一在主要支持平台（即 MinGW32 ）上实测为当前已知最快的实现。
<ul>
<li>第二快的是 <a href="https://github.com/miloyip/rapidjson">RapidJSON</a> 。虽然同样使用状态转移查找表，它使用刻意避免分支判断的实现机制，使用的表较大而对缓存可能不友好，导致在典型的实现中反而不一定更快。此外实测表明，使用 GCC 的 <code>__attribute__((flatten))</code> 即能明显影响这里的性能，程度和算法优化相比无法忽视。</li>
<li>其它朴素实现都明显落后于<a href="http://bjoern.hoehrmann.de/utf-8/decoder/dfa/">使用状态查找表</a>算法的性能。</li>
</ul>
</li>
</ul>
</li>
<li>YSLib.Core.YEvent
<ul>
<li>在不进行体系结构和 ABI 相关优化的限制前提下，<code>YSLib::GEvent</code> 的性能超过<a href="https://github.com/FrankHB/nano-signal-slot">这里</a>的除了 <code>jl_signal</code> 所有实现。而后者基于特定实现的 ABI 进行了较为复杂的优化。（待定：整合<a href="https://github.com/NoAvailableAlias/signal-slot-benchmarks">新的测试</a>。）</li>
<li>除了没有 Boost.Signal2 的线程安全和定制返回类型策略的接口外，所有功能都不弱于上述测试中的例子。</li>
<li>此外，基于 <code>ystdex::make_expanded</code> 提供允许省略未使用的参数这个实用特性，是以上测试用例都不具备的。事实上，尚没有已知的 C++ 库中提供类似的特性。其它语言可能提供类似的特性简化 GUI 开发，如 <a href="https://msdn.microsoft.com/en-us/library/windows/apps/mt204783.aspx">{x:Bind}</a> ，但实现原理上，其运行时性能不可能超过此处的方式（静态语言在翻译时确定参数列表）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="项目依赖性"><a class="header" href="#项目依赖性">项目依赖性</a></h1>
<p>　　项目的构建和运行可能依赖外部和内部的资源，详见<a href="Terminology.zh-CN.html#%E5%86%85%E9%83%A8%E4%BE%9D%E8%B5%96%E5%92%8C%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96">术语说明</a>。</p>
<h2 id="外部依赖项"><a class="header" href="#外部依赖项">外部依赖项</a></h2>
<p>　　在构建项目的上下文中，<strong>外部依赖项</strong>指构建时可能使用的<a href="Terminology.zh-CN.html#%E5%86%85%E9%83%A8%E4%BE%9D%E8%B5%96%E5%92%8C%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96">外部依赖</a>，是不由本项目维护和单独发布的依赖项。</p>
<p>　　关于<a href="GettingSources.zh-CN.html">获取源代码</a>获取构建项目必要的<a href="Terminology.zh-CN.html#%E6%BA%90%E4%BB%A3%E7%A0%81">源代码</a>。以下描述其余的必要外部依赖项。</p>
<p>　　YSLib 项目严格使用 ISO C++ 的子集和特定实现的可选的扩展。关于依赖的语言特性，参见<a href="Development.zh-CN.html#%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E8%A6%81%E6%B1%82">语言使用和实现要求</a>的说明。语言的实现（工具链）是必要的外部依赖项，在确保可参照系统厂商的文档安装，其中受支持的配置在<a href="Prerequisitions.zh-CN.html">先决条件</a>中说明。</p>
<p>　　当前在所有受支持的目标平台上，除了（构成语言和运行环境的）<a href="Terminology.zh-CN.html#%E5%B9%B3%E5%8F%B0%E6%A0%87%E8%AF%86">系统库</a>外，显示指定的直接外部依赖项在名义上是相同的，但可能使用不同的版本，也不一定按相同的配置构建。实现可能隐含其它的间接外部依赖。</p>
<p>　　部分外部依赖项是可选的。可选的依赖项仍可能会改变个别开发或运行时需要的其它外部依赖项。</p>
<p><strong>注释</strong> 例如，<code>pkg-config</code> 等工具被可选地隐含依赖以便自动配置包。</p>
<p>　　无论是否显式指定，都可能需要开发者或开发环境的系统管理员干预，以使这些外部依赖项在开发环境中可用。</p>
<p><strong>注释</strong> 例如，通过系统包管理器安装工具链和库等构建需要的外部依赖项。</p>
<p>　　具体外部依赖项的名称可能在不同环境不同。可根据相关来源的文档以及<a href="Build.zh-CN.html#%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96%E9%A1%B9%E6%9E%84%E5%BB%BA">外部依赖项构建的说明</a>确保获取的资源能和以下描述的依赖项准确对应。</p>
<p>　　除了系统库外，一部分外部依赖项可选或必须使用自行构建的（可能被修改的）版本。这些外部依赖项的修改和构建脚本位于版本库的 <code>3rdparty</code> 目录，默认按原始许可证发行。</p>
<p>　　YBase 只直接依赖 ISO C++ 标准库。</p>
<p>　　YFramework 默认依赖经过修改的 FreeType2 和 FreeImage 。其中前者当前仅修改头文件，经过特别处理和官方发布的直接构建的版本二进制兼容，可以被系统库替换。</p>
<p>　　构建 YFramework 时需包含 <code>3rdparty/include</code> 目录的头文件。<a href="Sysroot.zh-CN.html">Sysroot</a> 安装脚本 <a href="Tools/Scripts.zh-CN.html">Tools/install-sysroot.sh</a> 会复制包括上面的头文件在内的文件。</p>
<p>　　当前已经使用的详细外部依赖项详见 YSLib 项目文档 <code>doc/Dependencies.txt</code> 。</p>
<h3 id="外部二进制库"><a class="header" href="#外部二进制库">外部二进制库</a></h3>
<p>　　当前版本中，源代码中不同宿主平台对应的静态库文件（后缀名为 <code>.a</code> ）的目录如下：</p>
<ul>
<li><code>YFramework/DS/lib</code></li>
<li><code>YFramework/MinGW32/lib</code></li>
<li><code>YFramework/MinGW64/lib</code></li>
<li><code>YFramework/Android/lib</code></li>
<li><code>YFramework/Linux/lib</code></li>
</ul>
<p>　　其中，使用的 FreeImage 静态库对应 YFramework 的 <code>debug</code> 和非 <code>debug</code> 配置，文件名分别为 <code>libFreeImaged.a</code> 和 <code>libFreeImage.a</code> 。这可在同一个目录树中共存。</p>
<p>　　（当前 Android 和 Linux 仅支持单一本机体系结构，实际仅测试 Android ARMv7 和 Linux x86_64 。）</p>
<p>　　自 build 562 起，在 build 885 之前，版本库历史的对应的宿主平台中的静态库位于以下位置：</p>
<ul>
<li><code>YFramework/DS/lib</code></li>
<li><code>YFramework/MinGW32/lib-i686</code></li>
<li><code>YFramework/Android/lib</code></li>
<li><code>YFramework/Linux/lib-x86_64</code></li>
</ul>
<p>　　其中 Android 平台只包括 FreeType2 ，Linux 平台只包括 FreeImage 。其它平台包括 FreeType2 和 FreeImage 库文件。</p>
<p>　　其它平台中，只有随其它文件的发布版本包含完整更新，否则压缩包中可能只有其中一个库文件。</p>
<p>　　在 build 562 之前，版本库历史的对应的宿主平台中的静态库位于以下位置：</p>
<ul>
<li><code>YFramework/DS/lib</code></li>
<li><code>YFramework/MinGW32/lib</code></li>
</ul>
<p><strong>注意</strong> 在 V0.6(build 600) 之前版本库历史中包括静态库(<code>.a</code>) 文件，但为减少版本库大小，不再更新且可能移除，使用<a href="ProjectDependencies.zh-CN.html#%E5%AE%89%E8%A3%85%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96%E9%A1%B9">以下描述的方式安装外部依赖项</a>或<a href="Build.zh-CN.html#%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96%E9%A1%B9%E6%9E%84%E5%BB%BA">自行构建</a>的方式替代。</p>
<h3 id="安装外部依赖项"><a class="header" href="#安装外部依赖项">安装外部依赖项</a></h3>
<p>　　可使用以下方式安装外部依赖项：</p>
<ul>
<li>参见<a href="Archives.zh-CN.html">归档</a>，获取<a href="Archives.zh-CN.html#external">单独</a>或<a href="Archives.zh-CN.html#Sysroot">源代码目录集成的</a>已编译的外部依赖项。
<ul>
<li>非正式支持并<a href="Releases.zh-CN.html#%E5%8F%91%E5%B8%83%E9%98%B6%E6%AE%B5">发布</a>的平台当前不都提供归档。</li>
<li>关于正式支持，另见存储库中的 <code>doc/ProjectRules.txt</code> 的说明。</li>
</ul>
</li>
<li>若在宿主平台使用 <a href="Sysroot.zh-CN.html">Sysroot</a> ，<a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-yslib-buildtxt">脚本可自动从网络下载安装归档</a>。
<ul>
<li>非宿主平台当前不支持使用 Sysroot 构建。</li>
<li>对全新安装，设置<a href="Tools/Scripts.zh-CN.html#%E5%85%AC%E5%85%B1%E6%9E%84%E5%BB%BA%E9%85%8D%E7%BD%AE%E5%8F%98%E9%87%8F">环境变量 <code>SS_DirectExtract</code></a> 为非空值可能（很小地）提升性能。</li>
</ul>
</li>
<li>参见存储库中的 <code>3rdparty</code> 中的内容，手动构建所需的外部依赖项。</li>
</ul>
<p>　　关于自行构建外部依赖项的方法，参见<a href="Build.zh-CN.html">构建说明</a>。</p>
<h2 id="内部依赖"><a class="header" href="#内部依赖">内部依赖</a></h2>
<p>　　项目之间存在依赖，即<em>内部依赖(internal dependency)</em>。</p>
<p>　　示例项目 YSTest 在 DS 上依赖 YSTest/DS_ARM7 和 YSTest/DS_ARM9 两个项目。</p>
<p>　　YSTest/DS_ARM9 依赖于 YFramework ；在其它平台直接依赖 YFramework 。</p>
<p>　　YFramework 依赖 YBase 。</p>
<p>　　除了 MinGW 外使用 Make 构建。需要添加静态库时，把相应的 .a 文件加入相应的 lib 目录下，否则需要手动修改对应的 <code>Makefile</code> 。</p>
<p>　　MinGW 使用 Code::Block 或 <a href="Sysroot.zh-CN.html">Sysroot</a> 构建。</p>
<h2 id="生成路径"><a class="header" href="#生成路径">生成路径</a></h2>
<p>　　默认构建的根目录位于版本库下的 <code>build</code> 目录。</p>
<p><strong>注意</strong> 本节以下内容不适用于 <a href="Sysroot.zh-CN.html">Sysroot</a> 。</p>
<p>　　设 <code>$(Platform)</code> 是平台名称，<code>$(Configuration)</code> 是生成配置名称，则各个项目生成的文件和中间文件都在项目的 <code>build/$(Platform)/$(Configuration)</code> 子目录下。修改 <code>Makefile</code> 的配置可以分离生成文件和中间文件的输出路径。</p>
<p>　　默认生成配置名称可以是 <code>debug</code> 或 <code>release</code>（注意此项的大小写会在 <code>Makefile</code> 中表现出区别）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述-1"><a class="header" href="#概述-1">概述</a></h1>
<p>　　NPL 是 YSLib 提供的语言集合，它在语言规范层次上被设计为可扩展的。</p>
<p>　　通过<em>派生(derive)</em> 现有的语言（ NPL 的<em>方言(dialect)</em> ），避免完全重新设计新的语言，来满足需要一些新语言的场合下的需求。被派生的语言是 NPL 的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">抽象语言实现</a>。翻译或执行 NPL 或 NPL 抽象语言实现的程序是 NPL （方言）的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">具体语言实现</a>。具有具体语言实现的方言仍可以派生新的语言作为<a href="https://en.wikipedia.org/wiki/Domain-specific_language">领域特定语言</a>。</p>
<p>　　派生领域特定语言的一个其它的例子是 <a href="https://en.wikipedia.org/wiki/XML">XML</a> 。</p>
<h2 id="语法和语义"><a class="header" href="#语法和语义">语法和语义</a></h2>
<p>　　NPL 的<a href="Features/NPL.zh-CN.html#%E8%AF%AD%E6%B3%95">语法</a>基于形式文法上可递归构造的<strong>表达式</strong>。</p>
<p>　　在操作语义（基于<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E9%87%8D%E5%86%99%E7%B3%BB%E7%BB%9F">项重写系统</a>）的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E8%A7%84%E5%88%99%E5%92%8C%E6%B1%82%E5%80%BC">意义</a>上，其中的子表达式又称为<strong>项</strong>。</p>
<p>　　非正式地，NPL 使用类似 <a href="https://zh.wikipedia.org/wiki/S-%E8%A1%A8%E8%BE%BE%E5%BC%8F">S-表达式</a>的基本语法，但不使用二元有序对（和终止符号）而直接支持列表；即表达式直接以是否为括号作为边界，分为<a href="Features/NPL.zh-CN.html#%E5%88%97%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">列表表达式</a>和非列表表达式。</p>
<p>　　正式语法中，作为子表达式的项可以是列表或非列表项的<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F">复合表达式</a>规约列表项中的一部分代替有序对的地位，以要求任意项可被无歧义地进行从左到右的语法分析。</p>
<p>　　NPL 只要求小括号作为列表表达式的边界。其它替代的括号由<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">派生实现</a>约定。对于适用于多个 NPL 实现的可移植代码，避免使用其它语言中习惯作为代替括号边界的字符表示替代的括号以外的含义，特别地，[ISO C++] 文法 <code>balanced-token</code> 中的边界字符 <code>()[]{}</code> 。</p>
<p>　　NPL 对标识符的限制较为宽松。[ISO C] 和 [ISO C++] 的所有标识符都是 NPL 标识符。但派生实现可加以限制。</p>
<p>　　NPL 不提供专用的注释语法。以特定形式的项（如表示字符串的字面量）替代注释是预期的惯用法(idiom) 。这不妨碍派生语言可能添加预处理器扩展特性。</p>
<p>　　NPL 提供了一些通用的概念和<a href="Features/NPL.zh-CN.html#npl-%E5%85%AC%E5%85%B1%E8%AF%AD%E4%B9%89">公共规则</a>，但不构成<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">具体语言实现</a>的完整语义规则。语义规则由派生实现补充完整。</p>
<p><strong>注释</strong></p>
<p>　　排除注释及<a href="Features/NPL.zh-CN.html#%E4%B8%AD%E7%BC%80%E8%AF%AD%E6%B3%95">中缀标点 <code>;</code> 和 <code>,</code></a> ，NPL 的语法和 <a href="https://en.wikipedia.org/wiki/Scheme_%28programming_language%29">Scheme 语言</a>或<a href="https://web.cs.wpi.edu/~jshutt/kernel.html">Kernel 语言</a>的语法近似。不过，NPL 不支持构造循环引用，也不提供相关语法。详见以下<a href="Features/NPL.zh-CN.html#%E8%AF%AD%E6%B3%95">语法</a>中的讨论。</p>
<h2 id="需求概述"><a class="header" href="#需求概述">需求概述</a></h2>
<p>　　设计满足的需求描述参见<a href="https://github.com/FrankHB/pl-docs/blob/master/en-US/calling-for-language-features.md">这里(en-US)</a> 。</p>
<p>　　需求来源：</p>
<ul>
<li>出发点：构建一个可用计算机实现的语言。</li>
<li>基本目的：在以标准 C++ 环境（ [ISO C++] 定义的<em>宿主实现(hosted implementation)</em> ）的程序框架中嵌入配置和脚本操作。</li>
<li>扩展目的：渐进地向独立的计算机系统演进，探究能适用于各个领域并以计算机实现的<em>通用目的语言(general-purpose language)</em> 。</li>
</ul>
<p>　　本文档描述基于此出发点的 <strong>NPL(Name Protocoling Language)</strong> （一个替代的递归缩写是“NPL's not a Programming Language”，因其不仅适合作为 PL 的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>特性及其参照实现。</p>
<p>　　和大部分其它设计不同，为了确保一定程度的适应通用目的的性质，它们被设计整体首要考虑。这样的设计的语言是（自设计(by desing) 用于）满足通用目的的语言(general-purposed language) 。</p>
<h2 id="其它设计和实现参考"><a class="header" href="#其它设计和实现参考">其它设计和实现参考</a></h2>
<p>　　NPL 是独立设计的语言，但它和 [R<sup>n</sup>RK] 定义的 <a href="https://web.cs.wpi.edu/~jshutt/kernel.html">Kernel 语言</a>有许多核心设计的相似之处，尽管设计的一些基本特征（如<a href="Features/NPL.zh-CN.html#%E8%B5%84%E6%BA%90%E5%8F%AF%E7%94%A8%E6%80%A7%E5%9F%BA%E6%9C%AC%E7%BA%A6%E5%AE%9A">资源可用性基本约定</a>）以及<a href="Features/NPL.zh-CN.html#%E9%A2%86%E5%9F%9F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">基本哲学</a>相当不同。</p>
<p>　　NPL 的<a href="Features/NPL.zh-CN.html#npla1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80">主要实现</a>的核心部分实质上支持了 Kernel 的<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9E%8B">形式模型</a>—— vau 演算(vau calculi) 。</p>
<p><strong>注释</strong> 另见<a href="Features/NPL.zh-CN.html#%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E6%96%B9%E6%B3%95">操作语义</a>。</p>
<p>　　具体的 NPL 语言在这些模型的基础上提供。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0">NPL 的命名</a>即体现了 vau 演算和传统 <a href="Features/NPL.zh-CN.html#%CE%BB-%E5%AE%8C%E5%A4%87%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AF%B9%E5%BA%94%E8%AF%AD%E6%B3%95">λ 演算</a>为模型的语言的核心差异：</p>
<p>　　强调允许在<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>中指定求值上下文的<em>显式求值(explicit evaluation)</em>（而非 Lisp 方言中以 <code>quote</code> 为代表的显式干预默认的隐式求值）的风格以及<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>前后的不同，特别地，关注在语言中直接表达的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">名称</a>和<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>后指称的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">实体</a>的不同。</p>
<p>　　更进一步地，NPL 普遍地支持区分<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">一等引用</a>和被引用的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等实体</a>并具有更精确的资源控制机制，这是与 Kernel 的主要设计上的差异。</p>
<p>　　关于 vau 演算的形式模型和其它相关内容，详见 [Shu10] 。特别地，vau 演算提供了 <a href="https://en.wikipedia.org/wiki/Fexpr">fexpr</a> 类似的抽象。</p>
<p><strong>注释</strong> 另见<a href="Features/NPL.zh-CN.html#npla1-%E8%A7%84%E8%8C%83%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值算法设计的实例</a>。</p>
<p>　　关于一些其它支持 fexpr 特性的语言设计，参见：</p>
<ul>
<li><a href="https://software-lab.de/doc/faq.html#lambda">PicoLisp</a></li>
<li><a href="http://www.newlisp.org/downloads/newlisp_manual.html#define-macro">newLISP</a></li>
</ul>
<p>　　和 Kernel 以及本设计不同，这两个例子的设计使用<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">动态作用域</a>；在主要的特性中存在一些关键的不同而在形式模型的适用性上有显著的区别。</p>
<p><strong>注释</strong></p>
<p>　　NPL 和历史上同名的 <a href="https://en.wikipedia.org/wiki/John_Darlington">John Darlington</a> 的 <a href="https://en.wikipedia.org/wiki/NPL_(programming_language)">NPL (New Programming Language)</a> 没有直接渊源；特别地，后者的多个等式的函数定义语法和高阶类型没有被内建支持，而<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态类型</a>和纯函数式限制被避免。</p>
<p>　　Kernel 语言的原始参照实现是 SINK 依赖 MzScheme version 103 的解释器实现，和 [R<sup>n</sup>RK] 有一定差异。例如，字面量 <code>#ignore</code> 和 <code>#inert</code> 用 <code>%ignore</code> 和 <code>%inert</code> 代替。</p>
<p>　　<em><a href="https://web.archive.org/web/20210301121505/http://klisp.org/">klisp</a></em> 是 Kernel 语言的一个更完善的实现。</p>
<p>　　有些特性（如复数支持）都没有在这两个中实现提供，而仅在 [R<sup>n</sup>RK] 中指定。</p>
<h2 id="实现"><a class="header" href="#实现">实现</a></h2>
<p>　　在 YFramework/NPL 提供一些参考<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">具体语言实现</a>。当前 YFramework 主要使用<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">抽象语言实现</a> <a href="Features/NPL.zh-CN.html#npla">NPLA</a> 的具体<em>派生(derived)</em> 的实现 <a href="Features/NPL.zh-CN.html#npla1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80">NPLA1</a> ，在这个基础上用于不同的目的，如<a href="Features/../Tutorial/Configuration.zh-CN.html">程序配置</a>、<a href="Features/../Tutorial/GUI.zh-CN.html">动态加载的 GUI</a> 等。</p>
<p>　　NPLA 提供了比大多数现有的程序设计语言更强大的一般抽象。这集中体现在：</p>
<ul>
<li>和 NPL 的原始设计一致，不提供也不要求区分实现的阶段(phase) 。</li>
<li>支持<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">一等环境</a>不修改现有语言的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>即可实现共享类似语法的新语言。</li>
<li>允许以一般手段表达求值和未求值表达式的差异。</li>
</ul>
<p>　　这意味着 NPLA 是本质上动态的语言，但和一般语言不同，用户可以很大程度上动态地替换现有语言实现，包括在运行时替换一个解释实现为一个或多个优化编译器。这也意味着语言设计上既不需要区分解释实现和编译实现（本质上不对立），也不需要区分动态和静态（因为随时能从基础语言上构造出静态子集）。</p>
<p>　　这样的特性设计在绝大多数语言中不存在并且几乎无法支持。已知唯一的例外是 <a href="http://web.cs.wpi.edu/~jshutt/kernel.html">Kernel</a> ，在这些特性上有极大的相似，尽管实际上基本特性是<strong>独立设计的</strong>，并且在基本<a href="Features/NPL.zh-CN.html#%E9%A2%86%E5%9F%9F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">设计哲学</a>上有极大不同（ NPL 和 [R<sup>n</sup>RK] 中明确的 guidelines有很大不同且基本不兼容）。不过，考察设计的完整性，NPL 的派生语言也从中借鉴了一些重要的设计：</p>
<ul>
<li><a href="http://lambda-the-ultimate.org/node/4093"><code>$vau</code></a> 、<em>合并子(combiner)</em> /<em>应用子(applicative)</em> /<em>操作子(operative)</em> 等术语。</li>
<li>在<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>中支持模式匹配的<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">形式参数树</a>。</li>
<li>一些以合并子形式提供的操作。
<ul>
<li>一般的作为接口提供的合并子在 NPL 中仍称为函数；合并子是作为表达式的函数的特定的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>。
<ul>
<li><strong>注释</strong> 在 Scheme 中，合并子中的应用子对应<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">过程</a>。</li>
</ul>
</li>
<li>相似的操作主要体现在<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">名称</a>和<a href="Features/../Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">语义</a>上。因为一些基本设计的差异，不保证完全兼容。</li>
<li>相似操作的实现不尽相同，但其中不通过<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>的直接的实现（称为<em>派生(derivation)</em> ）有一部分几乎完全相同。</li>
<li>使用 <code>$</code> 作为一些<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">标识符</a>（如 <code>$lambda</code> ）的前缀是独立设计的巧合；现在含义已和 Kernel 一致，表示 <em>special form</em> 。</li>
</ul>
</li>
</ul>
<p>　　一些值得注意的和类似语言的主要设计差异（原理详见开发文档）：</p>
<ul>
<li>NPL 和 Kernel 类似，强调<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>，但含义有所不同。此处的“对象”和 [ISO C] 及 [ISO C++] 中的定义类似，具有比 Kernel 更严格的含义。
<ul>
<li>和 Kernel 合并子及 Scheme 过程类似，NPLA 默认使用<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值传递</a>参数和结果；但与之不同，不隐式对实际参数<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%88%AB%E5%90%8D">别名</a>，不<a href="Features/NPL.zh-CN.html#%E5%85%B1%E4%BA%AB%E5%BC%95%E7%94%A8">共享</a>对象。</li>
</ul>
</li>
<li>NPLA 和<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">派生实现</a>的语法和整体的求值类似 Scheme 和 Kernel 大多数基于 S-表达式的 <a href="https://en.wikipedia.org/wiki/Lisp_%28programming_language%29">Lisp</a> 方言，但有一些显著的区别。
<ul>
<li>和 Scheme 不同，而和 Kernel 一致，NPLA 避免顶层(top-level) 和局部的上下文的差异。</li>
<li>NPLA1 明确区分约定包括列表项的求值规则。和传统习惯不同，NPLA1 中括号明确不需要表示应用的含义，这可以减少一些场合（如命令行）需要输入的过多的连续括号。</li>
<li>和 [R<sup>n</sup>RS] 定义的 Scheme 以及 [R<sup>n</sup>RK] 定义的 Kernel 一致，不支持某些 Lisp 方言的方括号 <code>[]</code> 替代圆括号 <code>()</code> 的语法。</li>
<li>不提供注释语法。</li>
<li>语言实现中<a href="Features/NPL.zh-CN.html#%E4%B8%AD%E7%BC%80%E8%AF%AD%E6%B3%95">内置预处理处理中缀 <code>;</code> 和 <code>,</code></a> ，作为前缀合并子 <code>$sequence</code> 和 <code>list</code> 的语法糖。两者的含义和 Kernel 中的相同（类似 Scheme 的 <code>begin</code> 和 <code>list</code> ）。</li>
</ul>
</li>
<li>和 Kernel 相似而和 Scheme 不同，使用操作子及一等环境和 <code>eval</code> 代替 Scheme 的<a href="https://en.wikipedia.org/wiki/Hygienic_macro">卫生宏(hygienic macro)(en-US)</a> 及宏展开的作用。
<ul>
<li>和 Kernel 类似，鼓励使用直接求值风格而不是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%A3%8E%E6%A0%BC">引用(quote)</a> 。</li>
<li>不过 NPLA 也提供了 <code>$quote</code> 的派生而非如 Kernel 一样完全避免。</li>
</ul>
</li>
<li>和 Kernel 不同，NPL 明确支持资源抽象，<strong>不保证支持</strong><a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>，而 NPLA 明确<strong>不支持</strong>循环引用。</li>
<li>NPLA 明确支持基于 [ISO C++] 实现的对象模型和<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>，且明确<strong>不要求</strong>支持全局 <a href="https://zh.wikipedia.org/zh-cn/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_%28%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8%29">GC</a> 。
<ul>
<li>从在互操作的目的出发，和 C++ 具有相似性和相容性。
<ul>
<li>支持基于 <a href="https://eel.is/c++draft/intro.abstract">C++ 抽象机语义</a>的更一般的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>（除原生 <code>volatile</code> 外）和一等状态(first-class states)  。</li>
<li>和 [ISO C++] 类似，在<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>中保留特定的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未定义行为</a>，而不要求实现避免。</li>
<li>暂时不直接支持<a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">多线程环境</a>，但可以在不同<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">宿主语言</a>线程上同时使用不同的实现的实例。</li>
<li>函数默认使用不隐式别名的按值调用和返回传递复制或转移值，和 C++ 对应上下文的复制初始化(copy initialization) 语义一致。（不过求值为操作子的 NPL 函数在 C++ 没有直接的对应。）</li>
</ul>
</li>
<li>在 vau 演算的论文 ([Shu10]) 中，提及不支持全局 GC 有较大的管理开销(admistrative cost) 但没有详细讨论和<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言特性</a>的联系。</li>
</ul>
</li>
<li>即便不支持全局 GC ，当前实现仍然<strong>明确支持</strong> <a href="Features/NPL.zh-CN.html#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C-ptc">PTC(proper tail call)</a> 。
<ul>
<li>PTC 基于语言规则而不是<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">实现行为</a>定义，详见 <a href="https://www.researchgate.net/profile/William_Clinger/publication/2728133_Proper_Tail_Recursion_and_Space_Efficiency/links/02e7e53624927461c8000000/Proper-Tail-Recursion-and-Space-Efficiency.pdf">proper tail recursion</a> ，这里和 Kernel 提供的保证含义一致。</li>
<li>没有在其它语言发现这种不支持全局 GC 和支持类似 C++ 副作用的情形下的 PTC 支持的先例。</li>
</ul>
</li>
<li>和 Kernel 不同，NPLA 不完全强制对象类型的<a href="Features/NPL.zh-CN.html#%E5%B0%81%E8%A3%85">封装</a>；且基于支持互操作的考虑，支持<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%85%A8%E9%9B%86">开放</a>的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">类型系统</a>，而不要求覆盖所有值（即要求对象类型分区(partition) ）。</li>
<li>对机器数（不论是整数还是浮点数）的操作被剥离了，当前不被支持，需要用户代码添加个别操作。</li>
<li>NPLA 的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">规约</a>框架和 vau 演算的<a href="Features/NPL.zh-CN.html#%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E6%96%B9%E6%B3%95">操作语义</a>几乎完全一致，不过实际上（因为先前语言设计上的不确定）显著地保留了更多的可扩展和可修改性。</li>
</ul>
<h2 id="当前具体实现"><a class="header" href="#当前具体实现">当前具体实现</a></h2>
<p>　　当前派生实现的 <a href="Features/NPL.zh-CN.html#npla1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80">NPLA1</a> 由 YFramework 提供 <a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 。其中包括 <a href="https://zh.wikipedia.org/wiki/%E8%AF%BB%E5%8F%96%EF%B9%A3%E6%B1%82%E5%80%BC%EF%B9%A3%E8%BE%93%E5%87%BA%E5%BE%AA%E7%8E%AF">REPL (read-eval-print loop)</a> 的解释实现。外部文件的形式的 NPLA1 脚本可被基于这些 API 实现的 <a href="Features/../Tools/SHBuild.zh-CN.html">stage 1 SHBuild</a> 调用并用于 YFramework 的构建。</p>
<p>　　由 <a href="Features/../Run.zh-CN.html#%E5%A4%96%E9%83%A8%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F">YFramework 对外部文本编码的约定</a>，NPLA1 实现加载的文件流的剩余内容的编码视为 UTF-8 ；同时支持 CR+LF 或 LF 为换行符。</p>
<p><strong>注释</strong> 这些实现基于 YSLib API 提供互操作支持。</p>
<h1 id="绪论"><a class="header" href="#绪论">绪论</a></h1>
<h2 id="正式引用"><a class="header" href="#正式引用">正式引用</a></h2>
<p>　　仅在此给出本文档中的外部引用的名称。其它引用文献的内容详见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<!-- markdownlint-capture -->
<!-- markdownlint-disable MD049 -->
<ul>
<li>[ISO C] <a href="https://www.iso.org/standard/74528.html">ISO/IEC 9899</a></li>
<li>[ISO C++] <a href="https://www.iso.org/standard/79358.html">ISO/IEC 14882</a>
<ul>
<li>[ISO C++11] <a href="https://www.iso.org/standard/50372.html">ISO/IEC 14882:2011</a></li>
<li>[ISO C++14] <a href="https://www.iso.org/standard/64029.html">ISO/IEC 14882:2014</a></li>
<li>[ISO C++17] <a href="https://www.iso.org/standard/68564.html">ISO/IEC 14882:2017</a></li>
<li>[ISO C++20] <a href="https://www.iso.org/standard/79358.html">ISO/IEC 14882:2020</a></li>
<li>[WG21] (ISO/IEC JTC1/SC22/WG21) <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers">C++ Standards Committee Papers</a>
<ul>
<li>[WG21 P0135R1] Richard Smith, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0135r1.html">Wording for guaranteed copy elision through simplified value categories</a>, 2016-06-20.</li>
</ul>
</li>
</ul>
</li>
<li>[R<sup>n</sup>RK] <a href="https://web.cs.wpi.edu/~jshutt/kernel.html">Revised Report on the Kernel Programming Language</a>
<ul>
<li>[Shu09] John N. Shutt, <a href="ftp://ftp.cs.wpi.edu/pub/techreports/pdf/05-07.pdf">Revised<sup>-1</sup> Report on the Kernel Programming Language</a>, Technical report WPI-CS-TR-05-07, Worcester Polytechnic Institute, Worcester, MA, March 2005, amended 29 October 2009.</li>
<li><strong>注释</strong> 当前 [R<sup>n</sup>RK] 只有 <tt>n = -1</tt> 的版本。引用确切版本时，同 [Shu10] 中的用法，使用 [Shu09] 标记；但引用时一般同样不涉及其版本差异。</li>
</ul>
</li>
<li>[Shu10] John N. Shutt, <a href="https://web.wpi.edu/Pubs/ETD/Available/etd-090110-124904/unrestricted/jshutt.pdf">Fexprs as the basis of Lisp function application; or, <code>$vau</code>: the ultimate abstraction</a>, Ph.D. Dissertation, WPI CS Department, 2010.</li>
<li>[R<sup>n</sup>RS] <a href="http://www.scheme-reports.org/">Revised Report on the Algorithmic Language Scheme</a>
<ul>
<li>[R<sup>5</sup>RS] <a href="https://schemers.org/Documents/Standards/R5RS/r5rs.pdf">Revised<sup>5</sup> Report on the Algorithmic Language Scheme</a></li>
<li>[R<sup>6</sup>RS] <a href="http://www.r6rs.org/final/r6rs.pdf">Revised<sup>6</sup> Report on the Algorithmic Language Scheme</a></li>
<li>[R<sup>6</sup>RS-Rationale] <a href="http://www.r6rs.org/final/r6rs-rationale.pdf">Revised<sup>6</sup> Report on the Algorithmic Language Scheme -Rationale-</a></li>
<li>[R<sup>7</sup>RS] <a href="https://small.r7rs.org/attachment/r7rs.pdf">Revised<sup>7</sup> Report on the Algorithmic Language Scheme</a></li>
</ul>
</li>
<li>[Fl91] Matthias Felleisen, <a href="https://www.ccs.neu.edu/racket/pubs/scp91-felleisen.ps.gz">On the Expressive Power of Programming Languages</a>, <em>Science of Computer Programming</em> <a href="https://www.sciencedirect.com/journal/science-of-computer-programming/vol/17/issue/1">Volume 17, Issues 1–3</a>, December 1991, pp. 35–75.</li>
<li>[EGAL] James Noble, Andrew P. Black, Kim B. Bruce, Michael Homer and Mark S. Miller, <a href="http://web.cecs.pdx.edu/~black/publications/egal.pdf">The Left Hand of Equals</a>, Onward! 2016: <em>Proceedings of the 2016 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software</em>, October 2016, pp. 224–237.</li>
<li>[So90] Harald Søndergaard and Peter Sestoft, <a href="http://www.itu.dk/people/sestoft/papers/SondergaardSestoft1990.pdf">Referential transparency, definiteness and unfoldability</a>, <a href="https://link.springer.com/journal/236"><em>Acta Informatica</em></a> 27, 1990, pp. 505–517.</li>
<li>[Rust] <a href="https://doc.rust-lang.org/reference/index.html">The Rust Reference</a>
<ul>
<li>不定期更新。</li>
</ul>
</li>
<li>[Fi94] Andrzej Filinski, <a href="https://dl.acm.org/doi/pdf/10.1145/174675.178047">Representing Monads</a>, POPL '94: <em>Proceedings of the 21st ACM SIGPLAN-SIGACT symposium on Principles of programming languages</em>, February 1994, pp. 446–457.</li>
<li>[Hi90] Robert Hieb, R. Kent Dybvig and Carl Bruggema, <a href="https://legacy.cs.indiana.edu/~dyb/pubs/stack.pdf">Representing Control in the Presence of First-Class Continuation</a>, <em>ACM SIGPLAN Notices</em>, Volume 25, Issue 6, Jun. 1990, pp. 66–77.</li>
<li>[Racket] <a href="https://docs.racket-lang.org/">Racket Documentation</a>
<ul>
<li>不定期更新。</li>
</ul>
</li>
<li>[Chu41] Alonzo Church, <a href="https://compcalc.github.io/public/church/church_calculi_1941.pdf"><em>The Calculi of Lambda-Conversion</em></a>, Annals of Mathematics Studies, Princeton: Princeton University Press, 1941.</li>
<li>[Bare84] Hendrik Pieter Barendregt, <a href="https://philpapers.org/rec/BARTLC"><em>The Lambda Calculus: Its Syntax and Semantics</em></a> [<em>Studies in Logic and the Foundations of Mathematics</em> 103], Revised Edition, Amsterdam: North Holland, 1984.</li>
<li>[Cl98] William D. Clinger, <a href="https://www.researchgate.net/profile/William_Clinger/publication/2728133_Proper_Tail_Recursion_and_Space_Efficiency/links/02e7e53624927461c8000000/Proper-Tail-Recursion-and-Space-Efficiency.pdf">Proper Tail Recursion and Space Efficiency</a></li>
<li>[IEC 60559] <a href="https://www.iso.org/standard/80985.html">ISO/IEC 60559</a></li>
<li>[ECMAScript] <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-262/">ECMA-262</a>
<ul>
<li>[ECMAScript 2019] <a href="https://262.ecma-international.org/10.0/">ECMA-262 10.0</a></li>
</ul>
</li>
</ul>
<!-- markdownlint-restore -->
<h2 id="领域设计原则"><a class="header" href="#领域设计原则">领域设计原则</a></h2>
<p>　　本节描述被本文档中的一些原理讨论引用的的公共依据。</p>
<p>　　原则指关于设计和实现的哲学，同时作为一般规则约束设计和实现的工程阶段。</p>
<p>　　关于需求特别是通用目的语言的讨论，参见<a href="https://github.com/FrankHB/pl-docs/blob/master/en-US/calling-for-language-features.md#module">需求概要(en-US)</a> 。</p>
<h3 id="本体论"><a class="header" href="#本体论">本体论</a></h3>
<p>　　为使论述有效，约定<em>本体论(ontology)</em> 规则。</p>
<p>　　基本的本体论规则是约束逻辑系统构造的公理。</p>
<h4 id="正规性"><a class="header" href="#正规性">正规性</a></h4>
<p>　　有效的陈述（如需求描述）应保证操作上可预期结果。</p>
<p>　　在此意义下，缺乏约束性的规则不可预期的风险是代价。</p>
<p>　　推论：规则应适当约定适用范围，以避免外延不清。</p>
<h4 id="存在性"><a class="header" href="#存在性">存在性</a></h4>
<p>　　语义的存在体现本质。</p>
<p>　　仅仅应用语法规则，即限定为<em>语法的文法(syntactic grammar)</em> 的形式系统归纳的设计，不被视为表示任何<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E8%A7%84%E6%80%A7">有效</a>的含义。</p>
<h4 id="名实问题"><a class="header" href="#名实问题">名实问题</a></h4>
<p>　　名义概念的内涵和外延应被足够显式指定，避免指涉上的歧义，允许构造<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E8%A7%84%E6%80%A7">有效的陈述</a>。</p>
<h4 id="不可分的同一性"><a class="header" href="#不可分的同一性">不可分的同一性</a></h4>
<p>　　<a href="https://plato.stanford.edu/entries/identity-indiscernible/">不可分的同一性(the identity of indiscernibles) (en-US)</a> 比较陈述的客体之间是否相同而不需要被重复地处理。</p>
<h3 id="价值观"><a class="header" href="#价值观">价值观</a></h3>
<p>　　价值观是关于价值判断的规则，其输出为二元的值，决定是否接受决策。</p>
<p>　　作为应对普遍需求场景的不同解决方案选型时的价值判断的抽象归纳，价值观被作为比较是否采用设计相关决策的全局依据。</p>
<p>　　以下陈述形式表达价值优先的选项，同时作为公理。</p>
<p><strong>注释</strong> 相同推理结果仍然可能不唯一，这来自于自然语言描述的输入的不精确性。</p>
<h4 id="变化的自由"><a class="header" href="#变化的自由">变化的自由</a></h4>
<p>　　在明确需求的前提下，尽可能保证对现状按需进行改变的可行性和便利性。</p>
<p>　　适用于一般需求。</p>
<p>　　对计算机软件或其它可编程的实体：尽可能避免不必要地损失可修改性，便于保障按需引入或除去<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">接口</a>及其实现的自由。</p>
<p><strong>原理</strong></p>
<p>　　一般地，需求可能随着不可控的外部条件变化。假设已明确的需求不变只能适合相当有限的情形。积极应对变化能提供价值。</p>
<h4 id="避免不必要付出的代价"><a class="header" href="#避免不必要付出的代价">避免不必要付出的代价</a></h4>
<p>　　尽可能消除对满足需求无意义的代价，减少影响需求实现的整体成本。</p>
<p>　　适用于一般需求中设计决策的比较。</p>
<p>　　对计算机软件或其它可编程的实体：不为不需要的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">特性</a>付出代价。</p>
<p><strong>注释</strong></p>
<p>　　一个类似的表述：</p>
<blockquote>
<p>Efficiency has been a major design goal for C++ from the beginning, also the principle of “zero overhead” for any feature that is not used in a program. It has been a guiding principle from the earliest days of C++ that “you don’t pay for what you don’t use”.</p>
</blockquote>
<p>　　— <a href="https://www.iso.org/standard/43351.html">ISO/IEC TR 18015</a></p>
<h4 id="最小接口原则"><a class="header" href="#最小接口原则">最小接口原则</a></h4>
<p>　　在满足需求的前提下，尽可能使用符合倾向减小实现需求代价的单一良基关系下具有极小元的接口设计。</p>
<p><strong>注释</strong> 减小实现需求的代价，如减小设计工作量。</p>
<p>　　这是一条模式规则，依赖具体情形何者符合良基关系的极小元这条非模式规则作为输入。</p>
<p>　　实际使用时，非模式规则可以直接指定为二元关系的子集，或者一种良序的度量。</p>
<p><strong>注释</strong> 例如，“公开函数声明数”“模块数”。</p>
<p>　　这个输入也可能直接对应符合需求集合的某种最小功能集合而不需要附加度量，如表示某种设计的裁剪。</p>
<p>　　注意规则指定的基数是对实现需求有意义的代价，因此不涵盖<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>。</p>
<p>　　在确定的范围内尽可能少地提供必须的接口，避免不必要的假设影响接口适应需求的能力，同时减少实现需求的各个阶段的复杂性。</p>
<p>　　适用于一般需求的实现，特别地，强调“通用”目的时。</p>
<p>　　对需要在计算机上实现的人工语言设计：设计语言不应该进行功能的堆砌，而应该尽可能减少弱点和限制，使剩下的功能显得必要。</p>
<blockquote>
<p>Programming languages should be designed not by piling feature on top of feature, but by removing the weaknesses and restrictions that make additional features appear necessary.</p>
</blockquote>
<p>　　— [R<sup>n</sup>RS] &amp; [R<sup>n</sup>RK]</p>
<p><strong>注释</strong></p>
<p>　　其它各个领域中的实质等价一些表述包括：</p>
<ul>
<li>用于安全系统设计的<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E7%89%B9%E6%9D%83%E5%8E%9F%E5%88%99">最小特权原则</a>。</li>
<li>用于自然科学理论设计的<a href="https://zh.wikipedia.org/zh-cn/%E5%A5%A5%E5%8D%A1%E5%A7%86%E5%89%83%E5%88%80">奥卡姆剃刀(Occam’s Razor)</a> 原理，避免不必要的假设引入诉诸无知(argument from ignorance) 谬误。</li>
</ul>
<h4 id="关注点分离原则"><a class="header" href="#关注点分离原则">关注点分离原则</a></h4>
<p>　　<a href="https://zh.wikipedia.org/zh-cn/%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB">关注点分离(separation of concerns, SoC)</a> 原则 ：局部设计的内容应和需求的陈述或其它隐含的设计前提分别一一对应。</p>
<p>　　适用于一般需求的实现，特别是其中依赖认识论观点的过程。</p>
<p><strong>原理</strong></p>
<p>　　这条规则利用需求和设计内容陈述中概念外延普遍蕴含的<em>局域性(locality)</em> ，提供给定代价下更多的可行性或求解给定问题时使用较小的代价，用于：</p>
<ul>
<li>应对不可控复杂条件下使问题可解。</li>
<li>局部可复用现有解的子集。</li>
</ul>
<p>　　此外，尽管并非总是必要，应用知识内容的简单假设、<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>和本原则可在认识论上导出还原论。</p>
<h3 id="形而上学"><a class="header" href="#形而上学">形而上学</a></h3>
<p>　　根据作为需求的<a href="Features/NPL.zh-CN.html#%E4%BB%B7%E5%80%BC%E8%A7%82">价值观</a>，归纳适用于通用目的语言应有的构成及其性质（形而上学(metaphysics) ）的设计规则，包括三条价值判断实现公理：</p>
<ul>
<li>设计应尽可能满足<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>。</li>
<li>设计应尽可能满足<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>。</li>
<li>设计的正确性应优先于简单性。</li>
</ul>
<p>　　具备这些性质的设计可视为由<a href="Features/NPL.zh-CN.html#%E4%BB%B7%E5%80%BC%E8%A7%82">价值判断</a>蕴含，预设前提为真的设计<a href="Features/NPL.zh-CN.html#%E6%96%B9%E6%B3%95%E8%AE%BA">方法论</a>的实现。</p>
<p><strong>注释</strong></p>
<p>　　注意和 <a href="https://en.wikipedia.org/wiki/Worse_is_better">worse is better</a> 或 <a href="https://en.wikipedia.org/wiki/Worse_is_better#The_MIT_approach">the MIT approach</a> 不同，设计的性质并非完全并列。特别地，<a href="Features/NPL.zh-CN.html#%E5%AE%8C%E6%95%B4%E6%80%A7">完整性</a>和<a href="Features/NPL.zh-CN.html#%E4%B8%80%E8%87%B4%E6%80%A7">一致性</a>都被作为正确性的一部分考虑。</p>
<p>　　因为<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>，具体需求以及判断正确性和简单性的确切依据都可能会随着项目的进展而变化。</p>
<h4 id="正确性"><a class="header" href="#正确性">正确性</a></h4>
<p>　　设计应正确地反映需求，不在需求的基础上新增作为实现细节以外的不确定性。</p>
<p>　　无法确保满足这种<em>正确性(correctness)</em> 要求时，不应继续设计。</p>
<p>　　正确性包含<em>可行性(feasibility)</em> 。</p>
<p>　　若无法满足正确性，则需求输入存在问题。</p>
<p>　　正确性不包含但应逻辑蕴含设计的一些其它性质。若无法实现，则具体性质的定义存在问题。</p>
<p>　　保持正确性作为设计评价的首要依据以使决策简单，同时能符合<a href="Features/NPL.zh-CN.html#%E4%BB%B7%E5%80%BC%E8%A7%82">价值判断</a>。</p>
<h5 id="完整性"><a class="header" href="#完整性">完整性</a></h5>
<p>　　正确性应蕴含<em>完整性(completeness)</em> ，即确保没有需求被遗漏。</p>
<p>　　推论：设计应包含完整的需求响应。</p>
<p><strong>原理</strong></p>
<p>　　对通用编程语言的一个完整性要求是支持<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算</a>上的<em>可表达性(expresiveness)</em> 。</p>
<p>　　这种性质被称为<em>可有效计算性(effective computability)</em> ，或 <em>Turing 完备性(Turing completeness)</em> 。在可物理实现的计算普遍遵循 <a href="https://zh.wikipedia.org/zh-cn/%E9%82%B1%E5%A5%87%EF%BC%8D%E5%9B%BE%E7%81%B5%E8%AE%BA%E9%A2%98">Church–Turing 论题(Church–Turing thesis)</a> 的情形下，这同时是<em>可计算性(computability)</em> 。以上性质一般不加分辨。</p>
<p>　　具体的语言中允许的表达的可计算性是<em>表达能力(expressive power)</em> 。另见 [Fl91] 。</p>
<p>　　特定的场合要求更弱的性质。例如，类型检查等情形需要<em>全(total)</em> 计算而确保实现总是<a href="Features/NPL.zh-CN.html#%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%BA%A6%E5%AE%9A">可终止</a>。这种要求在完整的实现中可通过附加的设施（用户提供的标注或证明）保证，而不应通过系统设计的规则静态地排除，否则实现是不完整的。仅在作为领域特定语言时，通过从需求中排除可计算性，静态规则作为优化是被允许的。</p>
<h5 id="一致性"><a class="header" href="#一致性">一致性</a></h5>
<p>　　正确性应蕴含一致性，即内部的逻辑无矛盾性。</p>
<p>　　推论：设计应保证一致性。</p>
<h4 id="简单性"><a class="header" href="#简单性">简单性</a></h4>
<p>　　在满足正确性的前提下，接口设计应尽可能满足简单性(simplicity)，即尽可能少地具有可被继续简化的内容。</p>
<p>　　接口设计的简单性优先于实现的简单性。</p>
<h4 id="可修改性"><a class="header" href="#可修改性">可修改性</a></h4>
<p>　　<em>可修改性(modifiablity)</em> ：在满足需求的前提下，修改应尽可能少地有碍于其它的接口。</p>
<p>　　这是<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>的推论。</p>
<h4 id="避免抽象泄漏"><a class="header" href="#避免抽象泄漏">避免抽象泄漏</a></h4>
<p>　　<em>泄漏的抽象(leaky abstraction)</em> 指抽象的底层复杂性没有被抽象合理地<a href="Features/NPL.zh-CN.html#%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F">隐藏</a>，而在一定程度上构成了利用抽象时的不必要的依赖。</p>
<p>　　这种<em>抽象泄漏(abstraction leak)</em> 的结果直接和<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>、<a href="Features/NPL.zh-CN.html#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99">关注点分离原则</a>和<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>冲突。</p>
<p>　　同时，抽象的有效性被削弱，泄漏构成的不被预期的依赖难以满足<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>；只要有避免抽象泄漏的方法，就不满足<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>。</p>
<p>　　因此，只要可能，避免抽象泄漏。</p>
<p><strong>注释</strong> 在信息安全意义上，抽象泄漏还可能提供难以抵御的附加的攻击信道。</p>
<h4 id="关注资源限制"><a class="header" href="#关注资源限制">关注资源限制</a></h4>
<p>　　为了可实现性，<em>宿主(host)</em> 系统对总的资源（典型地，运行程序需要的存储）有<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定</a>的上限。</p>
<p>　　除此之外，接口抽象不附加接口语义要求以外的限制。</p>
<p>　　这个原则同时利于满足<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>和<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>。而不遵循这个原则的设计在接口描述上违反<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>。</p>
<p>　　在允许实现的前提下，附加具体<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">特性</a>上的使用限制（如 [ISO C] ）可放宽对实现的要求；但无原则地随意选取此处的限制不足以直接证明具体的限制的有效性，而依赖实际实现的情况才能判断，造成<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F">抽象泄漏</a>。</p>
<p><strong>注释</strong> 实例：<a href="https://software-lab.de/doc/faq.html#lambda">PicoLisp</a> 使用符合此原则的设计。</p>
<h4 id="开放性"><a class="header" href="#开放性">开放性</a></h4>
<p>　　<em>开放性(openness)</em> ：除非另行指定，不假定实体不存在。</p>
<p>　　这个原则主要用于建模(modeling) 的依据。对一般的模型，这个原则称为<a href="https://zh.wikipedia.org/zh-cn/%E5%BC%80%E6%94%BE%E4%B8%96%E7%95%8C%E5%81%87%E5%AE%9A">开放世界假定(open-world assumption)</a>。</p>
<p>　　与之相对，<a href="https://zh.wikipedia.org/zh-cn/%E5%B0%81%E9%97%AD%E4%B8%96%E7%95%8C%E5%81%87%E5%AE%9A">封闭世界假定(closed-world assumption)</a> 需要提前设置一个<em>全集(universe)</em> 以保持至少在逻辑的意义上<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E8%A7%84%E6%80%A7">合规</a>。</p>
<p>　　开放世界的元素的全集是模型的结构化规则推断得到的，而非名义上的定义决定。这同时称为模型的语言的<em>论域(universe of disclosure)</em> 。</p>
<p><strong>原理</strong></p>
<p>　　封闭世界假定表面上可能简化实现，但在一般的模型中是不必要的，因为保持问题合规性的论域应已由清晰的需求描述规范，不应为此阻碍实现<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>。</p>
<p>　　使用封闭世界假定的一个主要实用意义是使模型在有限的信息下能推理出逻辑上更强的结论。在重视结论的知识系统中，这通常是一种优化；但在重视<a href="Features/NPL.zh-CN.html#%E5%AE%8C%E6%95%B4%E6%80%A7">表达能力</a>（而通过其它方式辅助求解问题）的通用模型中，这种前提是一种直接的限制。同时，封闭世界假定的优化不保证对所有输入有效，对否定输入还可能导出一些矛盾。</p>
<p><strong>注释</strong></p>
<p>　　开放世界包含的元素的外延及其语言的论域伴随随<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>的修改而改变。</p>
<p>　　开放世界不限制论域中的某个子集是封闭的。例如，论域中可能存在某个子集的所有元素通过一定方式被枚举。</p>
<h3 id="结构和依赖原则"><a class="header" href="#结构和依赖原则">结构和依赖原则</a></h3>
<h4 id="接口设计和实现分离"><a class="header" href="#接口设计和实现分离">接口设计和实现分离</a></h4>
<p>　　语言设计独立于<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言实现</a>。</p>
<p>　　这是同时应用<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>和<a href="Features/NPL.zh-CN.html#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99">关注点分离原则</a>的推论。</p>
<p>　　这种分离允许<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F">避免抽象泄露</a>。</p>
<p>　　典型地，使用提供接口抽象层作为必要构造的架构方法，即分层设计。</p>
<h4 id="最小特权原则"><a class="header" href="#最小特权原则">最小特权原则</a></h4>
<p>　　<a href="https://zh.wikipedia.org/zh-cn/%E6%9C%80%E5%B0%8F%E6%9D%83%E9%99%90%E5%8E%9F%E5%88%99">最小特权原则(principle of least privilege, PoLA)</a> ：除非有必要，接口抽象不提供满足需求以外的其它信息和资源。</p>
<p>　　这是<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>在限制适用领域前提下的等价表述之一，用于避免不必要的访问路径引入额外的安全(safety) 风险，更容易满足（针对恶意使用风险的）安全性(security) 和可信性保证相关的需求。</p>
<p>　　实质上提供例外的必要性之一是接口正确性：不附加不存在于需求以外的安全设计；根据<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E4%BF%AE%E6%94%B9%E6%80%A7">可修改性</a>，这应是实现细节。</p>
<h4 id="最小依赖原则"><a class="header" href="#最小依赖原则">最小依赖原则</a></h4>
<p>　　最小依赖原则(principle of least dependencies) ：除非有必要，接口实现仅使用必要的依赖。</p>
<p>　　这是<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>的推论之一，其非模式规则的输入为：</p>
<ul>
<li>已知必要的依赖较已知必要的依赖和不必要的依赖的并集要求较小的使用和维护成本。</li>
<li>这里的使用包括演绎抽象自身的推理(reasoning) 。依赖较少时，推理时需要搜索的解空间也越小。</li>
</ul>
<h5 id="单一模块依赖倒置原则"><a class="header" href="#单一模块依赖倒置原则">单一模块依赖倒置原则</a></h5>
<p>　　依赖倒置原则(dependence inversion principle) 在单一模块下包含以下含义：</p>
<ul>
<li>抽象（的接口）不应该依赖（实现）细节。</li>
<li>（实现）细节应依赖抽象（的接口）。</li>
</ul>
<p>　　这是最小依赖原则应用在不同抽象的<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9D%97%E5%8C%96">模块化设计</a>中使用以下公设的推论：</p>
<p>　　抽象是细节包含的子集，依赖抽象的接口较依赖实现细节具有更少的依赖。</p>
<h4 id="可复用性"><a class="header" href="#可复用性">可复用性</a></h4>
<p>　　设计应具有<em>可复用性(reusability)</em> ：高层抽象设计的实现应包括复用此设计的实现的设计。</p>
<p>　　这是<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>的推论之一，其非模式规则的输入为以下公设：</p>
<p>　　一般地，高层抽象设计和复用此设计的实现较单一的高层设计的实现更复杂。</p>
<p>　　此前提条件由对需求工作量可行性分析中的度量验证总是成立。</p>
<p>　　推论：除非必要，不分离抽象设计的实现和复用此设计的实现的设计，避免复杂性。</p>
<p>　　全局意义上的不分离设计不违反<a href="Features/NPL.zh-CN.html#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99">关注点分离原则</a>。</p>
<p><strong>注释</strong></p>
<p>　　典型实例：语言是一种高层抽象设计，语言的<em>库(library)</em> 是一种复用语言的设计。因此，语言实现应包括库设计。</p>
<p>　　另一个实例是<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>设计复用<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>。</p>
<h4 id="可组合性"><a class="header" href="#可组合性">可组合性</a></h4>
<p>　　<em>组合(composition)</em> 是一种特定形式的涉及多个实体的复用，允许复用时不修改被复用的其它实体。</p>
<p>　　<em>可组合(composability)</em> 原则：接口的设计应允许不同设计之间的组合满足这些设计响应以外的需求。</p>
<p>　　这是<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>的推论之一，其非模式规则的输入为以下过程推断得到的引理。</p>
<p>　　公设：一般地，在存在充足基础解决方案的情形下，组合现有解决方案的设计较重新给出不依赖这些解决方案的设计的解节约成本。</p>
<p>　　应用<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>，得到引理：</p>
<p>　　一般地，在存在充足基础解决方案和满足需求限制的情形下，组合现有解决方案的设计优于重新设计。</p>
<p>　　即提升可组合性可减少实现被<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7">复用</a>的设计的成本。</p>
<h3 id="接口设计性质和原则"><a class="header" href="#接口设计性质和原则">接口设计性质和原则</a></h3>
<h4 id="统一性"><a class="header" href="#统一性">统一性</a></h4>
<p>　　接口的设计应具有<em>统一性(uniformity)</em> ：尽可能避免特例。</p>
<p>　　这是要求<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>的推论之一，以<a href="Features/NPL.zh-CN.html#%E4%B8%80%E8%87%B4%E6%80%A7">一致性</a>作为非模式规则输入。</p>
<p>　　无限制的特例要求指定更多的附加规则避免潜在的违反一致性的风险，而违反这个要求。</p>
<p>　　因为不需要特设只有对象语言中可用的规则，<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7">复用元语言规则</a>有利于实现统一性。</p>
<p>　　以统一的方式复用元语言和对象语言公共设施在<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">语法</a>设计上称为<em>光滑性(smoothness)</em> ，而这可推广到<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">语义</a>上（另见<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E4%BA%A4%E6%80%A7">正交性</a>），以避免对<em>抽象能力(power of abstraction)</em> 的限制([Shu10] §1.1.2) 。</p>
<p><strong>原理</strong></p>
<p>　　在语言设计上，这类似 [R<sup>n</sup>RK] 的设计原则 G1 ：</p>
<ul>
<li>G1a 对象状态(object status) ：语言操作<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>。</li>
<li>G1b 可扩展性(extensibility) ：用户定义的设施能重现内建<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">特性</a>的<em>能力(capability)</em> 。</li>
</ul>
<p>　　以上原则在 NPL 中略有变化。</p>
<p>　　同 [R<sup>n</sup>RK] ，被 G1b 重现能力的特性是内建的(built-in) 。这不同于如 [R<sup>n</sup>RK] G2 指定的基本的(primitive) 特性。</p>
<p>　　[R<sup>n</sup>RK] 的基本特性指不要求作为派生的(derived) ，即以<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>程序实现的特性。而内建特性适合整个<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规范</a>的接口设计约定，不论其实现是否被派生。不被要求重现的部分是实现细节。</p>
<p>　　但是，因为基本特性不要求能通过对象语言特性的组合实现，在不考虑派生特性的可实现性时，G1b 不会限定基本特性的能力。</p>
<p>　　整体上的 G1b 在和<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>冲突时不被要求。这也避免了 [R<sup>n</sup>RK] §0.1.1 指出的“妥协”。</p>
<p>　　因为语言规范不依赖使用<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>表达，G1b 仅表示用户使用语言的扩展，不表示语言自身的可扩展性；后者通过<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">满足需求的能力</a>和强调支持<a href="Features/NPL.zh-CN.html#%E5%BC%80%E6%94%BE%E6%80%A7">开放性</a>体现。</p>
<p>　　仅通过<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>实现的这种原则在 NPL 的设计中不被视为必要。但偏离这个原则的设计一般同样是不必要的。</p>
<p><strong>注释</strong></p>
<p>　　关于 G1a 的改变，详见<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">一等实体和一等对象</a>。</p>
<h4 id="适用性"><a class="header" href="#适用性">适用性</a></h4>
<p>　　设计应提供<em>适用性(usability)</em> ：合乎预期满足的问题领域的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">特性</a>。</p>
<p>　　对通用目的的领域，应进行权衡。</p>
<p><strong>注释</strong></p>
<p>　　这个原则存在以下的侧重不同使用方式或场景的具体表述。</p>
<p>　　结合用户的经验，这个规则的变体是之一<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%83%8A%E5%A5%87%E5%8E%9F%E5%88%99">最小惊奇原则</a>，强调降低接口的学习和适应成本。</p>
<h5 id="易预测性"><a class="header" href="#易预测性">易预测性</a></h5>
<p>　　设计应符合<em>易预测性(predictability)</em> ：允许但难以偶然实现的危险操作。</p>
<p>　　同 [R<sup>n</sup>RK] 的设计原则 G3 。</p>
<p>　　这里的危险的操作指引起较大代价的不预期或无法预期结果的操作。</p>
<p>　　这是<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>和<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>的推论，包含两方面：</p>
<ul>
<li>避免危险操作的风险是<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E8%A7%84%E6%80%A7">正规性</a>和<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>的推论。</li>
<li>不直接禁止危险的操作以满足上述的允许变化的要求。</li>
</ul>
<p>　　避免危险的操作在许多上下文中可减少程序中易错(error-prone) 的实现的风险。</p>
<h5 id="可用性"><a class="header" href="#可用性">可用性</a></h5>
<p>　　一旦提供<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">特性</a>，应提供<em>可用性(availablity)</em> ：保证一定程度的典型场景下能被使用。</p>
<p>　　绝大多数情形都不能使用的特性是对接口设计的一种浪费，很难符合也通常不符合<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>。</p>
<p>　　可用性的概念有时也指抽象和实体具有的符合这个原则的属性。</p>
<h4 id="最小惊奇原则"><a class="header" href="#最小惊奇原则">最小惊奇原则</a></h4>
<p>　　最小惊奇原则(principle of least astonishment)：在保持合理性的前提下，若能评估目标用户的接受能力，避免违反其直觉的设计。</p>
<p>　　其中，合理性至少应蕴含<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>，一般也蕴含<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>和<a href="Features/NPL.zh-CN.html#%E9%80%82%E7%94%A8%E6%80%A7">适用性</a>同时不违反其它原则（特别应注意尽量保持<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7">可复用性</a>和<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%BB%84%E5%90%88%E6%80%A7">可组合性</a>）。</p>
<p>　　这个原则主要适用于人机交互接口的设计，但也适用于一般的 <a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 。</p>
<p>　　推论：<a href="https://zh.wikipedia.org/zh-cn/%E7%BA%A6%E5%AE%9A%E4%BC%98%E4%BA%8E%E9%85%8D%E7%BD%AE">约定优于配置(convention over configuration)</a> ：约定接口的合理的默认<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">行为</a>，而不是隐藏其行为而提供配置另行实现。</p>
<h4 id="正交性"><a class="header" href="#正交性">正交性</a></h4>
<p>　　在满足<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>的前提下，接口的设计应具有<em>正交性(orthogonality)</em> ：根据需求适当分解为<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7">排除冗余和重复</a>且<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%BB%84%E5%90%88%E6%80%A7">能合理组合</a>的部分。</p>
<p>　　这是<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>和<a href="Features/NPL.zh-CN.html#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99">关注点分离原则</a>在接口设计上的应用。</p>
<p>　　一般地，正交的设计使相同目的可使用更精简的接口组合方式实现。这也使接口具有更强的<a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">抽象能力</a>。</p>
<h3 id="方法论"><a class="header" href="#方法论">方法论</a></h3>
<p>　　<em>方法论(methodology)</em> 是严格独立<a href="Features/NPL.zh-CN.html#%E4%BB%B7%E5%80%BC%E8%A7%82">价值判断</a>的规则，是关于<a href="Features/NPL.zh-CN.html#%E4%BB%B7%E5%80%BC%E8%A7%82">价值判断</a>结果参数化的判断规则。</p>
<p>　　不同的价值判断的结果作为方法论输入，决定是否适用此方法。</p>
<p>　　其它方法详见以下各节。</p>
<p><strong>注释</strong></p>
<p>　　一些规则因其主要表述包含价值判断而不在此归纳为方法论，尽管其中一些表述中的前提可以被参数化（如<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">奥卡姆剃刀</a>的“如无必要”的具体必要条件）。</p>
<h4 id="避免不成熟的优化"><a class="header" href="#避免不成熟的优化">避免不成熟的优化</a></h4>
<blockquote>
<p>Premature optimization is the root of all evil (or at least most of it) in programming.</p>
</blockquote>
<!-- markdownlint-disable-next-line MD049 -->
<p>　　— <em>The Art of Computer Programming</em></p>
<p>　　原始含义适合计算机程序设计中以效率为目标的决策。</p>
<p>　　扩展的外延适用于一般需求，要求：</p>
<ul>
<li>适时收缩理论长度以照顾可操作性。
<ul>
<li>注意断言一个优化过早自身可能就是一个过早的优化。</li>
</ul>
</li>
<li>主动适应需求变更。
<ul>
<li>不同时明确全部的具体需求，只限定需求范围：能使用计算机实现部分语义的任务。</li>
</ul>
</li>
</ul>
<h4 id="封装"><a class="header" href="#封装">封装</a></h4>
<p>　　<em>封装(encapsulation)</em> 是接口设计的合理性准则。</p>
<p>　　封装是<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E5%8F%AF%E5%88%86%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">不可分的同一性</a>的一种实现方式：封装提供的接口以下的所有实现在接口从使用者的角度都是不可分的。</p>
<p><strong>注释</strong> 若存在使用者可感知的<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F">抽象泄漏</a>，这种实现可能失效。</p>
<p>　　以接口的预设风格的价值判断为输入，封装性要求接口满足以下<em>多态性(polymorhism)</em> ：</p>
<p>　　给定接口的替代接口，则替代接口应能代替原接口，当且仅当不引起非预期的可观察的差异。</p>
<p>　　在语言设计中，去除风格参数化的这条原则被作为 <a href="https://zh.wikipedia.org/zh-cn/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99">LSP(Liskov Substitution Principle)</a> 。</p>
<p>　　参数化风格限定并非任意符合 LSP 的接口设计都符合封装性要求。这便于从不期望的设计中剔除不符合其它原则的设计。</p>
<p><strong>注释</strong></p>
<p>　　一些程序设计语言中的封装提供符合 LSP 的<a href="https://zh.wikipedia.org/zh-cn/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">面向对象</a>风格的设施。这些设施把数据和代码组合在一起提供，但仅仅组合并不体现封装性。因此，同时具有<a href="Features/NPL.zh-CN.html#%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F">信息隐藏</a>的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">特性</a>，如 [ISO C++] 的类成员的访问控制的机制，被认为是典型的封装。</p>
<p>　　即便如此，封装在严格意义上和信息隐藏是相互独立的。即便语言不提供信息隐藏而仅仅指定违反封装性不关心实现细节的假设的操作<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">未定义</a>，也不失去封装性。事实上，[ISO C++] 中，使用 <code>reinterpre_cast</code> 无视类的访问控制就是这种例子。</p>
<p>　　另一方面，LSP 事实上关于<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>，不限于以类作为类型的基于类的面向对象风格，实际外延更广。</p>
<h4 id="信息隐藏"><a class="header" href="#信息隐藏">信息隐藏</a></h4>
<p>　　<a href="https://zh.wikipedia.org/zh-cn/%E8%B3%87%E8%A8%8A%E9%9A%B1%E8%97%8F_%28%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8%29">信息隐藏(information hiding)</a> 保持不需要公开的信息不被公开，以使设计符合<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>并支持<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F">避免抽象泄漏</a>。</p>
<p>　　适用于接口及其实现。</p>
<p>　　信息隐藏以是否需要公开信息的<a href="Features/NPL.zh-CN.html#%E4%BB%B7%E5%80%BC%E8%A7%82">价值判断</a>（特别地，关于如何符合最小接口原则）的结果参数化。</p>
<p><strong>注释</strong></p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%B0%81%E8%A3%85">封装</a>的接口通常有助于实现信息隐藏。直接限定避免接口规格具有过多的信息，是另一种直接的实现方式。</p>
<p>　　例如，基于类的<a href="https://zh.wikipedia.org/zh-cn/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">面向对象</a>通过对<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">名称</a>组成的表达式限制对类成员的外部访问，隐藏了类成员的信息，同时提供<a href="Features/NPL.zh-CN.html#%E5%B0%81%E8%A3%85">封装性</a>。</p>
<p>　　其它方式可直接不在外部提供任何访问被封装实体的名称，如 [R<sup>n</sup>RK] 的封装类型(encapsulate type) 和 <a href="https://github.com/tc39/proposal-class-fields/blob/main/PRIVATE_SYNTAX_FAQ.md#how-can-you-model-encapsulation-using-weakmaps">[ECMAScript] 通过 <code>WeakMap</code> 实现的封装</a>。这些封装也同时实现了被封装实体的信息隐藏。</p>
<p>　　即便如此，如关于封装的讨论指出的，封装不一定需要实现信息隐藏。更一般地，信息隐藏的目的也不一定是提供封装。例如，系统的安全性可能直接在需求上要求隐藏特定信息，不论这种信息是否关于某种接口的实现。</p>
<h4 id="模块化"><a class="header" href="#模块化">模块化</a></h4>
<p>　　接口和实现的设计应具有足够的模块化(modularity) ：被划分为若干保持联系的组件即<em>模块(module)</em> ，至少满足<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>和<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%BB%84%E5%90%88%E6%80%A7">可组合性</a>，并强调实现<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7">可复用性</a>。</p>
<p>　　模块化设计通常有利于使设计具有<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E4%BA%A4%E6%80%A7">正交性</a>，但模块化相对可复用性，更侧重可组合性。</p>
<p>　　参数化的输入是需被评估模块化程度的结构设计（包括模块的<em>粒度(granularity)</em> 和组成部分的依赖关系）相对给定需求的实现质量的价值判断。</p>
<h3 id="其它推论和比较"><a class="header" href="#其它推论和比较">其它推论和比较</a></h3>
<p>　　从对<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>的强调可知，较<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>优先考虑<em>通用性(generality)</em> 。</p>
<p>　　这和 [R<sup>n</sup>RK] 中讨论的设计哲学虽然相当不同，但仍允许和 Kernel 具有相似的特性。</p>
<p>　　作为典型的 NPL 的一个<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">派生实现</a>，<a href="Features/NPL.zh-CN.html#npla1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80">NPLA1</a> 具有以下和 Kernel 相似的核心设计：</p>
<ul>
<li>相似的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>算法（差异详见 <a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">NPLA1 求值算法</a>）。</li>
<li><a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">环境</a>可作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>。</li>
<li>支持 <a href="Features/NPL.zh-CN.html#vau-%E6%8A%BD%E8%B1%A1">vau 抽象</a>，且使用<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83%E6%8F%90%E4%BE%9B%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">词法作用域</a>。</li>
<li>强调支持<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>中的<a href="Features/NPL.zh-CN.html#%E5%85%B6%E5%AE%83%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8F%82%E8%80%83">显式求值风格</a>及<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>求值前后的不同。</li>
<li>强调直接求值而非传统 LISP 方言的 <a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%A3%8E%E6%A0%BC"><code>quote</code></a> 。</li>
</ul>
<h1 id="规格说明"><a class="header" href="#规格说明">规格说明</a></h1>
<p>　　在<a href="Features/NPL.zh-CN.html#%E9%99%84%E5%BD%95">附录</a>之前的以下章节给出 NPL 的正式规格说明的公共部分，即<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规范</a>。</p>
<p>　　本文档仅提供部分<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">派生实现</a>的规格说明。关于其它具体规格说明，详见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p>　　在不和其它<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>冲突时，派生实现可能补充或覆盖更确切范围中生效的定义和具体语言规则。</p>
<h2 id="略称"><a class="header" href="#略称">略称</a></h2>
<p>　　仅在不致混淆时使用。</p>
<ul>
<li>实现(implementation) ：<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言实现</a>。</li>
<li>环境(environment) ：<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">实现环境</a>。
<ul>
<li>外部环境：（当前描述的系统边界的）外部的实现环境。</li>
</ul>
</li>
<li>派生实现(derived implementation) ：<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">派生语言实现</a>。</li>
</ul>
<h2 id="补充领域定义"><a class="header" href="#补充领域定义">补充领域定义</a></h2>
<p>　　以下术语的定义参见<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">计算机体系结构</a>。</p>
<ul>
<li>指令</li>
<li>指令集</li>
<li>ISA</li>
</ul>
<h1 id="整体设计"><a class="header" href="#整体设计">整体设计</a></h1>
<p>　　一些<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>可能显式地由<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">派生实现</a>指定，或补充具体规则。</p>
<p><strong>注释</strong></p>
<p>　　具体讨论设计策略另见需求描述文档。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E9%A2%86%E5%9F%9F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">设计原则</a>的讨论；对本章内容的描述的理解应符合其中的原则。</p>
<h2 id="模型"><a class="header" href="#模型">模型</a></h2>
<p>　　可用计算机实现的语言首先是<em>计算的模型(model of computation)</em> ，或者<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算模型</a>，对<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算</a>进行建模得到。</p>
<p>　　与之相关地，为计算机系统建模作为<em>计算机的模型(model of computer)</em> ，需对有限计算资源的现实进行适应。</p>
<p>　　这些模型可使用<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">形式方法</a>建立，即<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">形式模型</a>。</p>
<p>　　被计算机实现的语言应同时具有这两方面的特征。</p>
<p>　　作为实用的语言，语言还应强调提供<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">可编程性</a>以允许用户利用；这样的语言称为<em>编程语言(programming language)</em> 。</p>
<p>　　本设计尝试在语言的原生设计中应对现有语言缺乏模型问题以避免这些妥协带来的消极影响，同时取得比非模型方法更强的可用性。</p>
<p>　　这种可用性至少体现在语义的精确性可通过模型直接决定；仅为精确性，不需要另行补充模型设计（尽管现有模型可能仍然是不完全形式化的）。</p>
<p><strong>原理</strong></p>
<p>　　以无限的计算资源为前提，理想的模型无法被物理地完全实现，无法直接作为计算机实现的语言的模型。</p>
<p>　　同时，这些模型仅适合对计算建模，并没有强调允许可编程性的实现；扩充可编程设计而保持模型自身的主要性质相当困难。</p>
<p>　　因此，基于计算的模型适配编程语言的设计必然需要妥协：对这些模型的裁剪和补充能提供若干编程语言的模型，但这无可避免地显著地复杂化模型自身，且不利用用户使用简单有效的规则实现通用目的上的可编程性。</p>
<p>　　事实上，使用严格形式化的模型描述编程语言的<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">行为</a>较编程语言自身的发展更落后：</p>
<ul>
<li>大部分编程语言并没有使用模型支持它们的设计。</li>
<li>现实的实用语言，特别地，包括所有主流的<em>工业语言(industrial language)</em> ，几乎都没有在<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">语言规范</a>中给出完整的模型。</li>
<li>通常的实用语言只形式化基本的<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">语法</a>上的规则，无法指导用户精确理解程序的含义。</li>
</ul>
<p>　　这些落后集中体现在的<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">语义</a>模型的缺失，使对编程语言语义的判断取决于规格说明中模型外规则的理解。</p>
<p>　　后验(postpone) 的语义模型可以使用不同<a href="Features/NPL.zh-CN.html#%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E6%96%B9%E6%B3%95">形式语义方法</a>设计，但和语言规范差异的一些本应避免的附加工作，并且通常难以完整地作为标准规格的描述。</p>
<p><strong>注释</strong></p>
<p>　　Turing 机、<a href="https://zh.wikipedia.org/zh-cn/%CE%9B%E6%BC%94%E7%AE%97">无类型 λ 演算(untyped lambda calculus)</a> 等早期计算模型不考虑有限计算资源限制。</p>
<h3 id="计算复杂度约定"><a class="header" href="#计算复杂度约定">计算复杂度约定</a></h3>
<p>　　特定的算法过程具有<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算复杂度</a>要求。除非另行指定：</p>
<ul>
<li>这些复杂度是任意避免符合<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">错误条件</a>的方式调用时求值蕴含的<em>渐进(asymptotic)</em> 时间复杂度。</li>
<li>若指定边界，明确的输入规模以<em>哑变量(dummy)</em> <tt>n</tt> 表示。</li>
<li>指定复杂度的计算保证可<em>终止(terminate)</em> 。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　算法过程也适用<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>上的操作。</p>
<h3 id="资源可用性基本约定"><a class="header" href="#资源可用性基本约定">资源可用性基本约定</a></h3>
<p>　　在<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机</a>的配置中，任意通过<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80"><em>元语言(metalanguage)</em></a> 语法描述的资源总是可用的。</p>
<p>　　为避免对具体资源的总量和实现细节做出假设，除此之外，本设计只要求模型蕴含<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权</a>语义（即便不严格形式化——注意作为元语言的描述模型使用的形式语言仍然可能是实现细节）。</p>
<p>　　具体计算机系统的实现中，保证基本可用的资源被直接映射到程序执行(execution) 的环境中。尽管和适配的软件环境相关，这最终由硬件实现物理地保证。</p>
<p><strong>原理</strong></p>
<p>　　在严格的<a href="Features/NPL.zh-CN.html#%E5%85%B3%E6%B3%A8%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6">资源限制要求</a>下，<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9E%8B">模型</a>不能隐藏预设的无限资源的前提。</p>
<p>　　因此，有必要做出基本的<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>约定以允许表达明确的要求以避免不可实现。</p>
<h2 id="适用领域"><a class="header" href="#适用领域">适用领域</a></h2>
<p>　　为尽可能解决<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9E%8B">模型</a>相关的问题，优先以<a href="Features/NPL.zh-CN.html#%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0">通用目的</a>而不是<em>领域特定(domain-specific)</em> 语言作为评估<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言特性</a>设计的参考原则。</p>
<p>　　领域特定语言的特性应能合理地从支持通用目的的特性中<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">派生</a>，且不影响实际的可用性。</p>
<h2 id="形式语义方法"><a class="header" href="#形式语义方法">形式语义方法</a></h2>
<p>　　<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">形式语义</a>方法是建立<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9E%8B">语义模型</a>的形式方法。</p>
<p>　　形式语义方法主要有<em>公理语义(axiomatic semantics)</em> 、<em>指称语义(denotational semantic)</em> 和<em>操作语义(operational semantics)</em> 。</p>
<p>　　操作语义可分为在模型中指定具体<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">规约</a>步骤状态的<em>结构化操作语义(structural operational semantics)</em>（或<em>小步(small-step)</em> 语义），及仅指定规约的输入和输出的<em>自然语义(natural semantics)</em>（或<em>大步(big-step)</em> 语义）。</p>
<p><strong>注释</strong> <a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机</a>和<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E9%87%8D%E5%86%99%E7%B3%BB%E7%BB%9F">演算</a>是使用操作语义的模型的两类例子，虽然后者也可以对<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>以外的表示建模而实现其它的语义方法。</p>
<p>　　非确定语义：经验语义，不需要使用自然语言解释的部分。</p>
<p>　　本文档不直接给出形式语义。<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>确定的经验语义可在一定条件下转写为上述形式语义方法表达的形式。</p>
<h2 id="程序实现"><a class="header" href="#程序实现">程序实现</a></h2>
<p>　　<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">程序</a>是语言的具体派生。实现程序即在语言的基础上指定具体派生规则。</p>
<p>　　<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言实现</a>外的程序是<em>用户程序(user program)</em> 。</p>
<p>　　以程序或另行指定的其它形式实现的可复用程序被归类为<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7">库</a>。</p>
<p><strong>注释</strong> 一般地，不论是语言实现还是用户程序，都可能使用库。</p>
<p>　　除非另行指定，一个程序支持多个库的实例，之间不共享内部的状态。</p>
<p>　　语言特性包含不依赖库的<em>核心语言特性(core language feature)</em> 和<em>库特性(library feature)</em> 。</p>
<h2 id="规范模型"><a class="header" href="#规范模型">规范模型</a></h2>
<p>　　NPL 是抽象的语言，没有<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">具体语言实现</a>，但一些直接影响实现表现形式的规则被本节限定。</p>
<p>　　NPL 的实现可进行<em>抽象解释(abstraction interpret)</em> ，其目标不一定是<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">程序</a>。</p>
<p>　　任一 NPL 实现（和派生实现）的<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">符合性</a>由以下 NPL 符合性规则定义：文档指定的满足对实现的<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">要求</a>的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>子集，包括本节、<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95">基本文法</a>、<a href="Features/NPL.zh-CN.html#npl-%E5%85%AC%E5%85%B1%E8%AF%AD%E4%B9%89">语义</a>和其它派生实现定义的规则。</p>
<p>　　这类规则总是包含对应语言的<a href="Features/NPL.zh-CN.html#npl-%E5%85%AC%E5%85%B1%E8%AF%AD%E4%B9%89">语义的 NPL 公共子集</a>，且蕴含<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">实现行为</a>的要求。</p>
<p>　　<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>约定的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定</a>的程序或实现的属性及实现行为在符合性要求上等价。满足这类规则的前提下，实现选取特定的未指定的属性及对<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定行为</a>的特定实现的选择不影响实现的符合性。</p>
<p><strong>原理</strong></p>
<p>　　基于抽象机可直接定义最小的符合性要求，如 <a href="https://eel.is/c++draft/intro.abstract#6">C++ 的规则</a>。</p>
<p>　　NPL 没有直接在此定义同等具体的规则，而以一般的要求取代。这允许派生实现对不同的具体规则<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">进行补充和调整</a>。特别地，这允许<a href="Features/NPL.zh-CN.html#%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E6%96%B9%E6%B3%95">不同的方式</a>提供语义规则。</p>
<p>　　蕴含实现行为的要求的一个主要例子是关于<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">状态</a>的规则。除了允许由实现定义和派生实现指定的不同，这实质上提供和上述具体规则等价的默认情形，而简化派生实现需要的对语言规则的补充和调整。</p>
<h3 id="实现的执行阶段"><a class="header" href="#实现的执行阶段">实现的执行阶段</a></h3>
<p>　　一个 NPL 的完整实现应保证行为能符合以下的<em>执行阶段(phase of execution)</em> ：</p>
<ul>
<li><em>分析(analysis)</em> 阶段：处理代码，取得适当的 <a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">IR</a> 。</li>
<li><em>（目标）代码生成(target code generation)</em> ：以 IR 作为输入，生成可被其它阶段执行的代码，即<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">目标代码(target code)</a> 。
<ul>
<li><strong>注释</strong> 一般意义的代码生成可以有多个子阶段，包括多种内部 IR 的翻译，直至得到<em>最终目标代码(final target code)</em> 作为输出。</li>
</ul>
</li>
<li>运行：运行生成的最终目标代码。
<ul>
<li><strong>注释</strong> 最终目标代码的形式视不同而定，可能有附加的封装格式。例如<a href="Features/../Terminology.zh-CN.html">编译器</a>的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">目标代码(object code)</a> 经<em>链接(linking)</em> 为可<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">执行</a>的<em>映像(image)</em> ，被<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">加载</a>后形式才能运行。</li>
</ul>
</li>
</ul>
<p>　　其中分析阶段是任意实现必要的，依次包含：</p>
<ul>
<li>词法分析(lexical analysis) ：必要时转换字符编码；<em>转义(escape)</em> 并提取记号。</li>
<li>语法分析(syntactic analysis) ：语法检查（检验语法<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>）并尝试匹配记号和语法规则中的<a href="Features/NPL.zh-CN.html#%E8%AF%AD%E6%B3%95">语法元素</a>。</li>
<li>语义分析(semantic analysis) ：语义检查（检验语义正确性）并实现其它语义规则。</li>
</ul>
<p>　　以上的具体阶段不要求和实际实现中的一一对应，但应保证顺序一致。</p>
<p>　　运行之前的阶段总称为<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80"><em>翻译(translation)</em></a> ，包含各个<em>翻译阶段(phase of translation)</em> 。</p>
<p>　　对有<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">宿主语言</a>支持的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">嵌入实现</a>或目标不是程序的情况，代码生成及之后的阶段不是必须的。</p>
<p>　　宿主语言实现可提供作为<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">客户语言</a>的 NPL 的<em>本机(native)</em> 实现。</p>
<p>　　宿主语言实现提供 NPL 实现环境，同时对 NPL 环境的操作可影响 NPL 程序，这些情形都是<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元编程</a>，NPL 在此同时是<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>。</p>
<p>　　嵌入实现的宿主语言可直接运行语义分析的结果（中间表示）。</p>
<p>　　在语义不变的前提下，允许实现一次或多次翻译部分代码产生部分中间结果并复用。</p>
<p>　　<em>运行时(runtime)</em> 程序实现运行阶段。</p>
<p>　　其它可能的阶段由派生实现定义，但应满足所有阶段具有确定的全序关系，且不改变上述指定的阶段的顺序。符合这些条件的附加阶段称为扩展阶段。</p>
<p><strong>注释</strong></p>
<p>　　字符编码是被翻译的源中的二进制表示相关的模式。</p>
<h3 id="并发实现"><a class="header" href="#并发实现">并发实现</a></h3>
<p>　　一个实现可能具有计算模型意义上的<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">并发</a>属性，即<em>并发实现(concurrent implementation)</em> 。</p>
<p>　　一个实现中顺序执行以上执行阶段的一组<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">状态</a>称为一个<em>执行线程(thread of execution)</em> ，简称<em>线程(thread)</em> 。</p>
<p>　　一个实现在整个执行过程中可以有一个或多个线程被执行。是否支持多线程执行（多线程翻译和/或多线程运行）由派生实现定义。</p>
<p>　　若实现支持多线程执行，则执行阶段的状态区分不同的并发执行线程，此时具体的状态构成由实现定义。</p>
<h3 id="阶段不变量约束"><a class="header" href="#阶段不变量约束">阶段不变量约束</a></h3>
<p>　　若某些状态在某个执行阶段 k 被唯一确定为不可变状态，且在之后的状态下是<em>不变量(invariant)</em> ，则此状态称为满足 k 阶段不变量约束的。</p>
<h2 id="正确性-1"><a class="header" href="#正确性-1">正确性</a></h2>
<p>　　<em>正确性(correctness)</em> 规则约束被执行的程序，包含语法正确性和语义正确性。</p>
<p>　　当正确性规则被发现违反时，实现进入异常执行状态。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%BF%BB%E8%AF%91%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%A7%84%E5%88%99">翻译时正确性规则</a>以外的异常执行条件和状态由派生实现定义。</p>
<h3 id="翻译时正确性规则"><a class="header" href="#翻译时正确性规则">翻译时正确性规则</a></h3>
<p>　　翻译时的异常状态要求给出用于区分正常状态特定的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">行为</a>作为<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">诊断</a>，包括<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">诊断消息</a>和其它派生实现定义的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">实现行为</a>。</p>
<p>　　语法正确性规则是翻译时正确性规则。</p>
<p>　　部分形式上的正确性规则在翻译时确保。</p>
<p>　　允许翻译时确保的形式上正确的程序是<em>合式的(well-formed)</em> ；反之<em>不合式(ill-formed)</em> 。</p>
<p>　　合式的程序符合语法和语义的正确性的规则。</p>
<p>　　其中，实现被要求确保通过翻译的程序符合语法规则和翻译时确保的<em>可诊断(diagnosable)</em> 语义规则。</p>
<p>　　不合式的程序不保证被完整地翻译，应在运行前终止执行阶段。</p>
<h3 id="错误"><a class="header" href="#错误">错误</a></h3>
<p>　　<em>错误(error)</em> 是不满足预期的正确性或其它派生实现定义的不变性质时的特定诊断。</p>
<p>　　非正确性或不满足这些不变性的条件是<em>错误条件(error condition)</em> 。</p>
<p>　　满足错误条件时，实现可<em>引起(signal)</em> 错误。</p>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RS] 中的某些版本指定错误可以不诊断不同，引起错误蕴含诊断。</p>
<h2 id="实现行为"><a class="header" href="#实现行为">实现行为</a></h2>
<p>　　实现的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">行为</a>由具有存在非特定空间上限的存储的<em>抽象机(abstract machine)</em> 描述。这种描述对应的语言的语义是<em>抽象机语义(abstract machine semantics)</em> 。</p>
<p>　　若语言规则明确特定的行为可被忽略，则被忽略之后的实现行为与之前在语言规则中视为等价。翻译的实现可选取这些等价行为中的任一具体行为。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">派生实现</a>可通过<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E6%A8%A1%E5%9E%8B">显式的未指定规则</a>定义附加的等价性。</p>
<p>　　不论程序是否满足<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性规则</a>，实现对程序的执行都可能存在<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未定义行为</a>，此时实现的行为不需要满足正确性规则指定的行为要求。</p>
<p>　　特定的语言规则引入未定义行为。程序的执行在适用这些规则指定的条件时，引起未定义行为。</p>
<p>　　特定的语言规则排除未定义行为的引入，以满足一定的<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>。这不排除程序的执行可能因同时使用的其它语言规则引起的未定义行为。</p>
<p><strong>注释</strong></p>
<p>　　抽象机语义是一种<a href="Features/NPL.zh-CN.html#%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E6%96%B9%E6%B3%95">操作语义</a>。</p>
<p>　　抽象机语义也可非形式地定义语言的正式的(normative) 语义和行为要求，例如 <a href="https://eel.is/c++draft/intro.abstract">C++ 抽象机</a> 。</p>
<h2 id="简单实现模型约定"><a class="header" href="#简单实现模型约定">简单实现模型约定</a></h2>
<h3 id="嵌入宿主语言实现"><a class="header" href="#嵌入宿主语言实现">嵌入宿主语言实现</a></h3>
<p>　　一个派生实现使用外部语言 L 简单实现模型 NPL-EMA ，若满足：</p>
<ul>
<li>以 L 为宿主语言的嵌入实现，不包含<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">扩展执行阶段</a>。</li>
<li>单一实现不保证提供<a href="Features/NPL.zh-CN.html#%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0">多线程执行</a>的支持，但对资源的使用进行适当的分组，以允许多个实现同时在宿主中多线程执行。</li>
</ul>
<p>　　宿主语言提供的实现环境称为宿主实现环境，简称<em>宿主环境(host environment)</em> 。</p>
<p><strong>注释</strong></p>
<p>　　若支持多线程执行，需要附加的显式同步。</p>
<p>　　这种实现可能提供宿主语言的多线程环境中对应的线程实体，其中包含需要的被隔离的资源。</p>
<p>　　其它语言的实现也可能提供类似的设计，例如 <a href="https://v8.github.io/api/head/classv8_1_1Isolate.html">V8 的 <code>v8::Isolate</code></a> 。</p>
<p>　　另见<a href="Features/../Terminology.zh-CN.html#%E5%85%BC%E5%AE%B9%E6%80%A7%E5%92%8C%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7">可移植</a>和<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>意义上的<a href="Features/../Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">宿主环境</a>。</p>
<h1 id="基本文法"><a class="header" href="#基本文法">基本文法</a></h1>
<p>　　本章约定基本的 NPL <a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">文法</a>规则中，包括语法及对应的基础词法。对应的语义<a href="Features/NPL.zh-CN.html#npl-%E5%85%AC%E5%85%B1%E8%AF%AD%E4%B9%89">在下文列出</a>。</p>
<p>　　多态文法规则：<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">派生实现</a>可完全不提供本章明确定义的词法和语法构造的支持，仅当提供同构的替代文法且符合语义规则。</p>
<p>　　本章定义的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>的正式文法以 <a href="https://zh.wikipedia.org/zh-cn/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F">BNF（Backus–Naur Form ，Backus–Naur 形式）</a>作为元语法形式地描述，且在与对象语言之间无歧义时不在终结符(terminal) 边界使用引号（即 <code>"</code> 和 <code>'</code> ）。</p>
<p><strong>注释</strong></p>
<p>　　因为这种 BNF 使用符合 <a href="https://github.com/highlightjs/highlight.js/blob/main/src/languages/bnf.js"><code>highlight.js</code> 支持的语法</a>，在 Markdown 源代码中直接使用<a href="https://github.com/highlightjs/highlight.js/blob/main/SUPPORTED_LANGUAGES.md">支持的语言别名 <code>bnf</code> 标记</a>。</p>
<h2 id="基本文法概念"><a class="header" href="#基本文法概念">基本文法概念</a></h2>
<ul>
<li>字符(character) ：组成语言代码的最小实体。</li>
<li>基本翻译单元(basic transation unit) ：作为<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">翻译</a>输入的任意连续字符的有限序列（可以是空序列）。</li>
<li>翻译单元(translation unit) ：基本翻译单元的集合，之间满足由派生实现定义的规则。</li>
</ul>
<p>　　<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">程序</a>以翻译单元或具体操作指定的以翻译单元进行<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">翻译</a>得到的其它变换形式表示。</p>
<h2 id="字符集和字符串"><a class="header" href="#字符集和字符串">字符集和字符串</a></h2>
<ul>
<li>字符集(character set) ：对一个实现而言不变的字符的有限集合。</li>
<li>基本字符集(basic character set) ：实现环境必须支持的字符集。具体由派生实现定义。</li>
<li>字符串(character string) ：字符集上的序列。</li>
</ul>
<p>　　除非另行指定，关于字符集定义的其它概念同 [ISO C++11] 对 character 和 character set 的有关定义。</p>
<p><strong>注释</strong></p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">字符编码</a>基于字符集定义。</p>
<p>　　一般地，一个翻译单元只具有同一个字符编码。</p>
<h2 id="词法规则"><a class="header" href="#词法规则">词法规则</a></h2>
<p>　　<em>词法规则(lexical rules)</em> 约定在字符基础上的最小一级的可组合为<a href="Features/NPL.zh-CN.html#%E8%AF%AD%E6%B3%95">语法</a>元素单位直接关联的文法规则。</p>
<p>　　约定<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>语法 <code>&lt;x&gt;</code> 表示词法元素 <code>x</code> ，<code>::=</code> 表示定义，<code>|</code> 表示析取。</p>
<h3 id="基本词法构造"><a class="header" href="#基本词法构造">基本词法构造</a></h3>
<p>　　文法：</p>
<pre><code class="language-bnf">&lt;token&gt; ::= &lt;literal&gt; | &lt;$punctuator&gt; | &lt;$identifier&gt;
</code></pre>
<ul>
<li>分隔符(delimiter) ：代码中标记特定字符序列模式的字符序列。</li>
<li>词素(lexeme) ：代码中以分隔符确定边界的字符序列。</li>
<li>记号(token) ：词素的顶级分类。</li>
</ul>
<p>　　属于记号的语法元素可以是以下的词法分类：</p>
<ul>
<li>字面量(literal) ：一种记号，参见<a href="Features/NPL.zh-CN.html#%E5%AD%97%E9%9D%A2%E9%87%8F">以下描述</a>。</li>
<li>标点(punctuator) ：由派生实现定义的特定字符序列的集合，可具有一定语义功能。</li>
<li>标识符(identifier) ：除字面量和标点以外的记号</li>
</ul>
<p>　　代码中邻接的分隔符和非分隔符不构成一个词素。</p>
<p>　　不在记号内包含的空白符是分隔符，而不是词素。</p>
<p>　　标点是分隔符，也是词素。</p>
<p>　　超过一个字符的标点可能在匹配字符序列确定是否构成词素时具有词法歧义。此时，应指定消歧义规则确保存在唯一可接受的匹配方式，或引起词法<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">错误</a>终止翻译。</p>
<p>　　除非派生实现指定，字面量以外的记号不包含分隔符。</p>
<p>　　记号是可能附带附加<a href="Features/NPL.zh-CN.html#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90">词法分析</a>信息的词素。词法分析后得到的记号可以用词素映射到词法分类的有序对表示，但 NPL 不要求在此阶段保持分类也不限定表示的构造。</p>
<p>　　可以保证 [ISO C++11] 的 identifier 的定义，或在上述标识符中插入字符 <code>$</code> 构造得到的标识符属于 NPL 标识符。</p>
<p>　　派生实现可定义其它能构成标识符的词素。</p>
<p><strong>注释</strong></p>
<p>　　NPL 不指定超过一个字符的分隔符，因此默认没有词法歧义。派生实现可指定这些规则。</p>
<p>　　NPL 是<em>自由形式(free form)</em> 的语言，空白符原则上不构成字面量以外的词素和语义。</p>
<h3 id="转义序列和字符序列"><a class="header" href="#转义序列和字符序列">转义序列和字符序列</a></h3>
<p>　　文法：</p>
<pre><code class="language-bnf">&lt;char-escape-content-seq&gt; ::= &lt;$single-escape-char&gt; | &lt;$escape-prefix-char&gt;&lt;$escape-content-seq&gt;
&lt;char-seq&gt; ::= &lt;$literal-char&gt; | &lt;char-escape-seq&gt;
</code></pre>
<p>　　包含 <code>&lt;char-escape-seq&gt;</code> 的 <code>&lt;char-seq&gt;</code> 包括：</p>
<ul>
<li><code>\'</code></li>
<li><code>\"</code></li>
<li><code>\\</code></li>
<li><code>\a</code></li>
<li><code>\b</code></li>
<li><code>\f</code></li>
<li><code>\n</code></li>
<li><code>\r</code></li>
<li><code>\t</code></li>
<li><code>\v</code></li>
</ul>
<p>　　<code>&lt;char-seq&gt;</code> 的含义同 [ISO C++] 的对应转义序列。</p>
<p><strong>注释</strong> 这是 [ISO C++] 的 <code>&lt;simple-escape-sequence&gt;</code> 词法分类中除了 <code>"\?"</code> 的情形，也是 [R<sup>6</sup>RS] 在 <code>&lt;string element&gt;</code> 中支持的字面情形。</p>
<h3 id="字面量"><a class="header" href="#字面量">字面量</a></h3>
<p>　　文法：</p>
<pre><code class="language-bnf">&lt;literal-content&gt; ::= &lt;char-seq&gt; | &lt;literal-char-seq&gt;&lt;literal-data&gt;
&lt;code-literal&gt; ::= '&lt;literal-content&gt;'
&lt;data-literal&gt; ::= "&lt;literal-content&gt;"
&lt;string-literal&gt; ::= &lt;code-literal&gt; | &lt;data-literal&gt;
&lt;literal&gt; ::= &lt;string-literal&gt; | &lt;$derived-impldef-literal&gt;
</code></pre>
<ul>
<li>代码字面量(code literal) ：以 ' 作为起始和结束字符的记号。</li>
<li>数据字面量(data literal) ：以 " 作为起始和结束字符的记号。</li>
<li>字符串字面量(string literal) ：代码字面量或数据字面量。</li>
<li>扩展字面量(extended literal) ：由派生实现定义的非代码字面量或数据字面量的记号。</li>
<li>字面量(literal) ：代码字面量、数据字面量、字符串字面量或扩展字面量。</li>
</ul>
<p>　　派生实现定义的解释可排除代码字面量作为字符串字面量。</p>
<p><strong>原理</strong></p>
<p>　　传统的字面量一般是<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">自求值项</a>，这包括一般的字符串字面量。</p>
<p>　　代码字面量可提供非自求值项的处理方式。</p>
<h3 id="分隔符"><a class="header" href="#分隔符">分隔符</a></h3>
<p>　　以下单字符标点是 NPL 图形分隔符：</p>
<ul>
<li><code>(</code></li>
<li><code>)</code></li>
<li><code>,</code></li>
<li><code>;</code></li>
</ul>
<p>　　以下单字符标点是 NPL 分隔符：</p>
<ul>
<li>NPL 图形分隔符</li>
<li>空白符（字符串 " \n\r\t\v" 中的字符之一）</li>
</ul>
<p><strong>注释</strong></p>
<p>　　空白符同 [ISO C++] <code>std::isspace</code> 在 C 区域下的定义，不含<code>空字符(null character)</code> 。</p>
<p><strong>原理</strong></p>
<p>　　NPL 图形分隔符可不和其它字符组合而作为单独的记号。因此，这不包含构成字面量的字符 <code>'</code> 和字符 <code>"</code> 。</p>
<p>　　NPL 分隔符用于一般分隔记号（而不是识别<a href="Features/NPL.zh-CN.html#%E5%AD%97%E9%9D%A2%E9%87%8F">字面量</a>）的外部描述，也没有显式地包含这些字符，但词法分析仍应把按字面量规则把这些字符作为必要时区分不同记号的边界。</p>
<h3 id="词法分析"><a class="header" href="#词法分析">词法分析</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">词法分析</a>输入<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95%E6%A6%82%E5%BF%B5">翻译单元</a>，输出记号序列。</p>
<p>　　以下规则（按优先顺序）定义了词法分析转换输入为输出的步骤：</p>
<ul>
<li>反斜杠转义：连续两个反斜杠被替换为一个反斜杠。</li>
<li>引号转义：反斜杠之后紧接单引号或双引号时，反斜杠会被删除。</li>
<li>断行连接：反斜杠之后紧接换行符的双字符序列视为续行符，被删除使分隔的行组成逻辑行。</li>
<li>字面量：未被转义的单引号或双引号后进入字面量解析状态，无视以下规则，直接逐字节输出原始输入，直至遇到对应的另一个引号。</li>
<li>窄字符空白符替换：单字节空格、水平/垂直制表符、换行符被替换为单一空格；回车符会被忽略。</li>
<li>原始输出：其它字符序列逐字节输出。</li>
</ul>
<p>　　不对空字符特殊处理。</p>
<p><strong>注释</strong></p>
<p>　　因为不一定是 <a href="Features/NPL.zh-CN.html#%E5%88%86%E9%9A%94%E7%AC%A6">NPL 分隔符</a>，转义字符不总是分隔标识符。</p>
<h2 id="语法"><a class="header" href="#语法">语法</a></h2>
<p>　　本节指定 NPL 作为对象语言的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">语法</a>。</p>
<p>　　约定<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>语法 <code>&lt;x&gt;</code> 表示语法元素 <code>x</code> ，<code>::=</code> 表示定义，<code>|</code> 表示析取。</p>
<p>　　程序被作为<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言实现</a>组成部分的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">语法分析</a>程序<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">规约</a>，结果能确定其和一定的语法元素匹配。</p>
<p>　　规约时应进行语法规则的检查。</p>
<p><strong>原理</strong></p>
<p>　　NPL 的基本语法更接近原始的 S-表达式，有利于简化<a href="Features/NPL.zh-CN.html#%E5%90%8C%E5%83%8F%E6%80%A7">同像性</a>的使用和实现。这也避免一些微妙的特性冲突和对特性的演化的的阻碍。一些 <a href="http://xahlee.info/UnixResource_dir/writ/lisp_problems.html">Lisp 方言用户存在类似的看法并认为这些设计是主要的缺陷之一</a>。</p>
<p>　　不过，<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">词素</a>中的构造不在此考虑（不限制具体的风格），例如派生实现可指定支持有 <code>#</code> 前缀的类似 Scheme 风格的词素表示字面量。构造词素也需要词素的具体表示，如字符串，才可能实现。因为词素的表示以及构造过程在此不透明，原则上不影响同像性。</p>
<h3 id="基本语法构造"><a class="header" href="#基本语法构造">基本语法构造</a></h3>
<p>　　NPL 的基本语法单元是可递归构造的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>，或派生实现指定的其它语法构造。</p>
<p>　　构成基本语法单元的规则参见<a href="Features/NPL.zh-CN.html#%E8%AF%8D%E6%B3%95%E8%A7%84%E5%88%99">词法规则</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%BF%BB%E8%AF%91%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%A7%84%E5%88%99">合式</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95%E6%A6%82%E5%BF%B5">基本翻译单元</a>应是一个或多个基本语法单元。</p>
<h3 id="表达式"><a class="header" href="#表达式">表达式</a></h3>
<p>　　文法：</p>
<pre><code class="language-bnf">&lt;expression&gt; ::= &lt;atom-expression&gt; | &lt;composite-expression&gt; | &lt;list-expression&gt;
</code></pre>
<p>　　<em>表达式(expression)</em> 是受表达式语法约束的记号序列，可以是：</p>
<ul>
<li><em><a href="Features/NPL.zh-CN.html#%E5%8E%9F%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F">原子表达式(atom expression)</a></em></li>
<li><em><a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F">复合表达式(composite expression)</a></em></li>
<li><em><a href="Features/NPL.zh-CN.html#%E5%88%97%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">列表表达式(list expression)</a></em></li>
</ul>
<p>　　构成表达式的表达式是被构成的表达式的<em>子表达式(subexpression)</em> 。</p>
<h4 id="原子表达式"><a class="header" href="#原子表达式">原子表达式</a></h4>
<p>　　文法：</p>
<pre><code class="language-bnf">&lt;atom-expression&gt; ::= &lt;token&gt;
</code></pre>
<p>　　原子表达式不能被表示为其它表达式的语法构成形式的复合。</p>
<h4 id="复合表达式"><a class="header" href="#复合表达式">复合表达式</a></h4>
<p>　　文法：</p>
<pre><code class="language-bnf">&lt;composite-expression&gt; ::= &lt;token-expression&gt; | &lt;expression-token&gt;
</code></pre>
<p>　　复合表达式是原子表达式和表达式的复合，即语法意义上的直接<em>并置连接(juxtaposition)</em> ，不在被复合的表达式之间存在其它记号。</p>
<p>　　同一个表达式可能被按原子表达式出现的位置以不同的方式规约为复合表达式。允许的规约复合表达式的方式由派生实现定义。</p>
<h4 id="列表表达式"><a class="header" href="#列表表达式">列表表达式</a></h4>
<p>　　文法：</p>
<pre><code class="language-bnf">&lt;separators&gt; ::= &lt;separator&gt; | &lt;separator&gt;&lt;separators&gt;
&lt;expressions&gt; ::= | &lt;expression&gt; | &lt;expression&gt;&lt;separators&gt;&lt;expressions&gt;
&lt;list-expression&gt; ::= &lt;left-list-bound&gt;&lt;expressions&gt;&lt;right-list-bound&gt;
&lt;left-list-bound&gt; ::= ( | &lt;extended-left-list-bound&gt;
&lt;right-list-bound&gt; ::= ) | &lt;extended-right-list-bound&gt;
</code></pre>
<p>　　其中，<code>&lt;separator&gt;</code> 是 <a href="Features/NPL.zh-CN.html#%E5%88%86%E9%9A%94%E7%AC%A6">NPL 分隔符</a>。</p>
<p>　　列表表达式是在其他表达式的序列（可能为空）左右附加一组 <code>&lt;left-list-bound&gt;</code> 和 <code>&lt;right-list-bound&gt;</code> 作为边界构成的表达式。</p>
<p>　　<code>&lt;left-list-bound&gt;</code> 和 <code>&lt;right-list-bound&gt;</code> 是不同的标点。</p>
<p>　　边界为 <code>(</code> 和 <code>)</code> 的表达式是基本列表表达式。其它可能的边界由派生实现定义，构成扩展列表表达式。</p>
<p><strong>注释</strong></p>
<p>　　对 <code>&lt;list-expression&gt;</code> 的定义，以<a href="Features/NPL.zh-CN.html#npl-%E5%85%AC%E5%85%B1%E8%AF%AD%E4%B9%89">形式语义使用的元语言</a> 中的元语法符号 <code>*</code> 扩展元语法，可以简记作 <code>&lt;list-expression&gt; ::= &lt;left-list-bound&gt; &lt;expression&gt;* &lt;right-list-bound&gt;</code> 。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%88%97%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">列表表达式</a>的边界是 <a href="Features/NPL.zh-CN.html#%E5%88%86%E9%9A%94%E7%AC%A6">NPL 图形分隔符</a>。</p>
<h3 id="名称"><a class="header" href="#名称">名称</a></h3>
<p>　　NPL 的<em>名称(name)</em> 是符合语法规则约束的若干<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">记号</a>的集合。</p>
<p>　　存在非空的名称集合可被作为<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>。</p>
<p><strong>原理</strong></p>
<p>　　<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">名称</a>的集合是<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">广义实体</a>和<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">实体</a>的差集。</p>
<p>　　语言规则对语言可表达的名称添加要求，以使语言的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源代码</a>能够直接使用名称。</p>
<p>　　名称在源代码形式之外也可广泛存在，且能通过不唯一的方式构造。因此，语言规则允许不和源代码形式一一对应的名称。</p>
<p><strong>注释</strong></p>
<p>　　构成名称的集合的表现形式不唯一。</p>
<p>　　特定的名称可能为空集。</p>
<p>　　约束通常包含顺序，即其中的记号构成确定顺序的序列。</p>
<p>　　记号或记号集合经<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">编码</a>，一般可实现为可表达的字符串。</p>
<h3 id="语法形式"><a class="header" href="#语法形式">语法形式</a></h3>
<p>　　<em>语法形式(syntactic form)</em> 是词法上满足特定<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">形式</a>的语法构造。</p>
<p>　　除非派生实现另行指定，语法形式总是表达式。</p>
<h3 id="语句"><a class="header" href="#语句">语句</a></h3>
<p>　　以派生实现定义的标点结尾的表达式称为<em>语句(statement)</em> 。</p>
<p>　　语句语法的<em>分组(grouping)</em> 规则以及是否隐式地作为列表表达式<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>由派生实现定义。</p>
<h3 id="简单文法约定"><a class="header" href="#简单文法约定">简单文法约定</a></h3>
<p>　　一个派生实现使用简单文法 NPL-GA ，若满足：</p>
<ul>
<li>翻译单元同<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95%E6%A6%82%E5%BF%B5">基本翻译单元</a>。</li>
<li>只支持左原子表达式构成<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F">复合表达式</a>。</li>
<li>只支持基本<a href="Features/NPL.zh-CN.html#%E5%88%97%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">列表表达式</a>。</li>
<li>标点为单个<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95%E6%A6%82%E5%BF%B5">字符</a>。</li>
<li>若支持语句，总是 NPL-GA <a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　NPL-GA 允许一些典型的<em>分析器(parser)</em> 简化设计作为实现。</p>
<p>　　在<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>的形式文法仅作为语法规则，使用<a href="Features/NPL.zh-CN.html#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90">词法分析</a>的结果提供作为<em>语法类别(syntactic category)</em> 的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">词素</a>的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">串</a>作为输入的情况下，NPL-GA 支持 LL(1) 文法分析，即使用 NPL-GA 语法。</p>
<p>　　若延迟<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F">复合表达式</a>和<a href="Features/NPL.zh-CN.html#%E5%88%97%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">列表表达式</a>中的选择到分析器外（之后可能由语义处理），检查语法的判定程序可进一步简化，仅判断记号 <code>(</code> 和 <code>)</code> 的匹配。</p>
<p>　　若词法分析处理直接对 <code>(</code> 和 <code>)</code> 和进行<em>记号化(tokenize)</em> 标记，则 NPL-GA 分析器不需要支持其它判定。这样的分析器实现的 NPL-GA 子集等效 LL(0) 文法。但由于 NPL-GA 不限定语法元素具体数量，等效 LL(0) 分析器当且仅当输入的串终止时接受输入，因此是<em>平凡的(trivial)</em> ，通常不具有实际意义，因为：</p>
<ul>
<li>形式上这里只有算法步骤的多少的差异，而几乎所有实现的语言都不把它作为<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>。</li>
<li>即便需要统计串的长度，也应可以在之前（词法分析）计算，使用语法分析完成这个任务在此是低效的。</li>
</ul>
<p>　　反之，在分析 NPL-GA 语法前扩展其它语法<em>预处理(preprocessing)</em> 规则可以支持更多的文法扩展。这样的文法扩展可接受扩展的非 NPL-GA 文法，但仍允许保持语法分析器的实现使用 NPL-GA 语法。</p>
<h1 id="npl-公共语义"><a class="header" href="#npl-公共语义">NPL 公共语义</a></h1>
<p>　　NPL 的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">语义规则</a>构成<a href="https://en.wikipedia.org/wiki/Formal_system#Deductive_system"><em>演绎系统(deductive system)</em> (en-US)</a> ，通过对<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95%E6%A6%82%E5%BF%B5">翻译单元</a>中的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>表达。</p>
<p>　　除非<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">派生实现</a>另行指定，仅使用表达式指定关于<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>中的计算的语义。</p>
<p>　　基本语义规则要求：</p>
<ul>
<li>所有不需要<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">诊断消息</a>的规则由派生实现定义。</li>
<li>本章内的规则应不引入<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未定义行为</a>。</li>
</ul>
<p>　　NPL 允许程序具有语义等价的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定行为</a>。派生实现可能通过约定和限制其具体选项的选取以指定更具体的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">实现行为</a>。</p>
<p>　　本章内的语言语义基于一种<a href="https://zh.wikipedia.org/zh-cn/%E6%89%A9%E5%B1%95%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F">EBNF（扩展 BNF ）</a> 的方言，其中：</p>
<ul>
<li>规则定义符号(defining symbol) 为 <code>::=</code> 。</li>
<li>除非元素的含义和用法被单独另行指定，作为文法类的元素使用 <code>&lt;</code> 和 <code>&gt;</code> 作为分隔符。
<ul>
<li><strong>注释</strong> 这和 BNF 相同，但和常见 EBNF 可能不同。</li>
</ul>
</li>
<li>在和对象语言之间没有歧义的情形时：
<ul>
<li>使用 <code>*</code> 作为修饰前一个元素的 <a href="https://zh.wikipedia.org/zh-cn/%E5%85%8B%E8%8E%B1%E5%B0%BC%E6%98%9F%E5%8F%B7">Kleene 星号</a>，表示之前修饰的项可出现 0 次或多次。</li>
<li>使用 <code>(</code> 和 <code>)</code> 组合之间的元素。</li>
</ul>
</li>
<li>若对象语言直接出现元语言的元符号(metasymbol) 而出现歧义，需要用一对 <code>"</code> 或 <code>'</code> 标记。
<ul>
<li><strong>注释</strong> 此时和非原始版本的 BNF 以及常见 EBNF 可能相同。</li>
</ul>
</li>
</ul>
<p><strong>原理</strong></p>
<p>　　<a href="https://www.cl.cam.ac.uk/~mgk25/iso-14977.pdf">ISO/IEC 14977:1996</a>正式定义了最常见的方言，但这一标准没有简化业已分歧的元语法方言，以至于<a href="https://www.grammarware.net/text/2012/bnf-was-here.pdf">仅在 ISO 的不同编程语言标准中，就存在多种记法并用</a>。</p>
<p>　　BNF 作为元语法形式地描述适用描述形式语言的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">串</a>的<a href="Features/NPL.zh-CN.html#%E6%BC%94%E7%BB%8E%E8%A7%84%E5%88%99">重写系统</a>，而非对描述语义更灵活的<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E9%87%8D%E5%86%99%E7%B3%BB%E7%BB%9F">项重写系统</a>。</p>
<p>　　在语法之外，元素之间的空白符通常不是重要的。因此，可直接省略元语言分隔符 <code>&lt;</code> 和 <code>&gt;</code> 。这也是大多数 EBNF 的典型用法（即便描述的是语法）。描述语义的例子如 [Shu10] ，其中使用特定的字体支持元语言中出现的元素。</p>
<p>　　然而，为便于在代码中表示而不依赖特设的字体，此处仍然使用 <code>&lt;</code> 和 <code>&gt;</code> ，除非元素的含义和用法被单独另行指定。</p>
<p><strong>注释</strong></p>
<p>　　因为这种 EBNF 使用不符合 <a href="https://github.com/highlightjs/highlight.js/blob/main/src/languages/ebnf.js"><code>highlight.js</code> 支持的语法</a>，在 Markdown 源代码中不使用<a href="https://github.com/highlightjs/highlight.js/blob/main/SUPPORTED_LANGUAGES.md">支持的语言别名 <code>ebnf</code> 标记</a>，而记作自定义语言标记 <code>xbnf</code> 。</p>
<p>　　ISO EBNF 被 <code>highlight.js</code> 的 <code>ebnf</code> 语法定义支持。</p>
<p>　　[Shu10] 也使用 <code>::=</code> 作为规则定义符号。</p>
<h2 id="基本语义概念"><a class="header" href="#基本语义概念">基本语义概念</a></h2>
<ul>
<li>区域(region) ：和特定位置代码关联的有限<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">实体</a>集合。</li>
<li>范围(range) ：一个连续区间。
<ul>
<li>此处“连续”的概念由派生实现定义，默认参照数学的形式定义。</li>
</ul>
</li>
<li>声明(declaration) ：引入单一<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0">名称</a>的表达式。</li>
<li>声明区域(declarative region) ：对某一个声明及其引入的名称，通过<a href="Features/NPL.zh-CN.html#%E5%A3%B0%E6%98%8E%E5%8C%BA%E5%9F%9F%E7%BA%A6%E5%AE%9A">声明区域规则</a>决定的范围。</li>
<li>有效名称(valid name) ：可以唯一确定<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">指称</a>的实体的名称。</li>
<li>有效命名实体(valid named entity) ：有效名称指称的实体。</li>
<li>名称隐藏(name hiding) ：若同一个名称在同一个位置属于超过一个声明区域，则应能通过<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E8%A7%81%E5%90%8D%E7%A7%B0">名称隐藏规则</a>确定唯一有效的声明以指定有效名称和对应的有效命名实体，此时有效名称隐藏其它声明区域声明的名称，有效命名实体隐藏可以使用被隐藏名称指称的实体。</li>
<li>作用域(scope) ：声明区域的子集，满足其中指定的名称是有效名称。</li>
<li>生存期(lifetime) ：逻辑上关于实体的<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>的连续区间的抽象，是一个闭集。</li>
<li>属性(property) ：实体表现的性质。</li>
<li>同一性(identity) ：实体上的一种<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">等价关系</a>，允许实体具有标识不相等特定的属性。
<ul>
<li><strong>注释</strong> 特定属性的例子如占据存储。</li>
</ul>
</li>
<li>对象(object) ：可确定同一性的实体。</li>
<li>值(value) ：表达式关联的<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">不可变状态</a>。
　　* 作为实体，对象总是关联值作为它的内容，称为<em>对象的值(value of object)</em> 。</li>
<li>未指定值(unspecified value) ：<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定</a>的值。</li>
<li>修改(modification) ：使<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">状态</a>被<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">改变</a>的操作。</li>
<li>作用(effect) ：语言支持的一定上下文内的表达式规约蕴含的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">计算作用</a>。</li>
<li>副作用(side effect) ：对表达式的值以外的表示的改变的作用。</li>
<li>幂等性(idempotence) ：重复后即不改变状态的性质。</li>
<li>项(term) ：特定的演绎系统中处理的对象，是带有基本递归构造的元素，可对应语法中的表达式。
<ul>
<li><strong>注释</strong> 这样的演绎系统主要是<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E9%87%8D%E5%86%99%E7%B3%BB%E7%BB%9F">项重写系统</a>。</li>
</ul>
</li>
<li>子项(subterm) ：具有递归形式构造的文法描述的参与构成项的项。</li>
<li>变量(variable) ：通过声明显式引入或通过演绎系统规则隐式引入的以名称指称的实体。</li>
<li>绑定(binding) ：引入变量的操作或结果，其中后者是变量的名称和引入的被变量表示的实体构成的有序对。</li>
<li>约束变量(bound variable) ：子项中出现的名称被绑定的变量，即其指称可能依赖具体上下文的变量。
<ul>
<li>同名的约束变量的整体重命名替换不保证不改变指称进而可能影响语义。</li>
</ul>
</li>
<li>自由变量(free variable) ：子项中出现的非约束变量。</li>
<li>组合子(combinator) ：不是变量也不含相对任何项的自由变量作为子项的项。</li>
<li>常量(constant) ：满足某种不变量的约束以和不可变状态关联的实体。具体由派生实现定义。
<ul>
<li><strong>注释</strong> 不和变量对立：蕴含不可变状态的变量可能是常量。</li>
</ul>
</li>
<li>转换(conversion) ：根据基于特定等价性（假设）前提的两个项之间的自反的演绎。</li>
<li>规约(reduction) ：两个项之间的、<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">实例</a>是某个转换的子集的满足反自反的演绎。</li>
<li>抽象求值(abstract evaluation) ：对表达式的不取得作用的规约。</li>
<li>具体求值(concrete evaluation) ：对表达式的取得作用的规约。</li>
<li>求值(evaluation) ：抽象求值或具体求值。
<ul>
<li><strong>注释</strong> 即对表达式的规约。</li>
</ul>
</li>
<li>求值结果(evaluation result) ：作用的子集，是求值得到的用于替换被求值的表达式作为它的值的实体，或其它由派生实现定义的实体。
<ul>
<li>不和其它结果混淆时，简称<em>结果(result)</em> 。</li>
<li>求值中取得求值结果中的表达式的值的过程称为<em>值计算(value computation)</em> 。</li>
<li>值计算包含确定用于替换的实体以及替换的过程，两者之间具有因果性。</li>
</ul>
</li>
<li>值对象(value object) ：表示值的对象。
<ul>
<li><strong>注释</strong> 值对象是可作为值使用的对象，例如作为求值结果的一部分。和值不同，值对象不一定是不可变状态。</li>
</ul>
</li>
<li>控制状态(control state) ：实现中决定求值的状态。
<ul>
<li>程序表现的控制状态通称<em>控制(control)</em> 。</li>
<li>特定控制状态的改变使不同的实体被求值，这对应控制<em>转移(transfer)</em> 。</li>
<li><em>调度(schedule)</em> 特定可能改变控制作用的实体可决定如何转移控制状态。
<ul>
<li><strong>注释</strong> 这可能实现<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">并发的</a>计算。</li>
</ul>
</li>
<li>除非派生实现另行指定，控制状态是<a href="Features/NPL.zh-CN.html#%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0">区分多线程执行中不同线程的状态</a>。</li>
</ul>
</li>
<li>控制作用(control effect) ：引起控制状态改变的作用。
<ul>
<li>在 NPL 中，控制作用是在对象或派生实现定义的实体上引起改变的副作用。</li>
</ul>
</li>
<li>相等关系(equality relationship) ：定义在值的集合上的等价关系。</li>
<li>布尔值(boolean value)：逻辑真或逻辑假。</li>
<li>谓词(predicate) ：若具有结果，则结果是布尔值的实体。</li>
<li>数据结构(data structure) ：<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">数据</a>的构造性表示。</li>
<li>一等实体(first-class entity) ：语言表达的允许支持足够特性的子集的实体，其中特性支持包括：
<ul>
<li>可作为语言中的有效命名实体。</li>
<li>可作为语言中的值在<a href="Features/NPL.zh-CN.html#%CE%BB-%E5%AE%8C%E5%A4%87%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AF%B9%E5%BA%94%E8%AF%AD%E6%B3%95">特定的对象语言构造</a>中使用。</li>
<li>可表达数据结构。</li>
<li>满足以上支持的值域中没有任意特设的限制。</li>
<li><strong>注释</strong> 使用的判定准则和 [R<sup>n</sup>RK] Appendix B 的 first-class object 的约定实质上一致。</li>
</ul>
</li>
<li>一等对象(first-class object) ：可确定同一性的一等实体。</li>
<li>访问(access) ：从实体上取得状态或修改实体。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　一些设计中，值对象是专用于<a href="https://en.wikipedia.org/wiki/Value_object">表示（不可变的）值的对象(en-US)</a> 。本设计不使用这个定义，因为：</p>
<ul>
<li>值对象作为对象，蕴含<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>的目的，在语言设计而非实现的上下文中不是值的等义词。</li>
<li>以实现角度考察值对象提供值的表示时，不关心它<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E5%8F%98%E7%8A%B6%E6%80%81%E5%92%8C%E6%99%AE%E9%81%8D%E6%80%A7">是否可作为一等对象</a>而要求<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">不可变</a>可允许其上的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>替换表示具有其它的值。</li>
<li>作为对象的值，它可能因为<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>等目的在外部被直接作为其它语言实现中可作为（允许可变的）一等对象的实体。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　在实现执行的上下文，生存期概念兼容 <a href="https://www.iso.org/standard/63598.html">ISO/IEC 2382</a> 的 lifetime 定义：</p>
<blockquote>
<p>portion of the execution duration during which a language construct exists</p>
</blockquote>
<p>　　定义绑定的有序对作为抽象表示，不需要被对象语言支持。对象语言可支持其它具体的有序对数据结构。</p>
<p>　　典型地，作用包括计算得到的值、引起的副作用以及其它可由区域和变化的状态二元组描述的实体。</p>
<p>　　一等对象同时是对象。</p>
<p>　　为满足可在表达式中通过求值被使用，一等实体总是能关联表达求值结果的值，称为实体的值。</p>
<h3 id="表示"><a class="header" href="#表示">表示</a></h3>
<p>　　<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">表示</a>用于表现演绎实例、具体实现及其中一部分实体的状态。</p>
<p><strong>注释</strong> 其中的一部分实体可以是某个值。</p>
<p>　　因为保证同一性，对象的值作为<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可变状态</a>的表示时，即对象存储的值。</p>
<p><strong>注释</strong> 变量不一定是可变状态的表示。</p>
<p>　　<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">外部表示</a>和<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">内部表示</a>是相对的。不同<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">外部环境</a>可以有不同的外部表示，这些外部表示相对其它外部环境而言可以不是外部表示。</p>
<p>　　外部表示可能被<em>读取(read)</em> 处理为内部表示。内部表示可能被<em>写入(write)</em> 处理为外部表示。</p>
<p>　　读取和写入操作的副作用分别是<em>输入(input)</em> 和<em>输出(output)</em> 。</p>
<p>　　外部表示为元素序列时，读取和写入是非特定格式数据和元素序列之间的转换，若不含其它<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>，其操作是进行<em>反序列化(deserialize)</em> 和<em>序列化(serialize)</em> 。</p>
<p>　　内部表示为对象时，读取和写入包含对象和非特定格式数据之间的转换，其操作是进行<em>列集(marshall)</em> 和<em>散集(unmarshall)</em> 。</p>
<p>　　除非另行指定，不要求对象语言提供内部表示到外部表示的转换。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95">文法</a>约定基准的表示作为<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">翻译</a>的输入。这种表示是翻译所在外部环境的外部表示，即<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源代码</a>；翻译结果是对象语言代码，简称<em>对象代码(object code)</em> ，可以是另外的外部表示。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95%E6%A6%82%E5%BF%B5">翻译单元</a>是这里被翻译的外部表示。</p>
<p>　　由<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95">基本文法</a>，空白符和参与的表示，不一一对应。为便于输出标准化，NPL 约定以下<em>规范(canonical)</em> 外部表示：</p>
<!-- markdownlint-disable-next-line MD038 -->
<ul>
<li>对列表，输出的表示是以 <code>(</code> 和 <code>)</code> 作为边界，元素以单个 <code> </code> 为分隔符的序列，其中的元素在括号中被递归地嵌套表示。</li>
<li>对非列表的存在唯一的对应词法形式（如字面量）的值，输出这个值的词法形式。</li>
<li>其它值的外部表示<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定</a>。
<ul>
<li><strong>注释</strong> 值自身可能<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定</a>。<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">未指定值</a>通常蕴含未指定的外部表示，但不绝对。</li>
</ul>
</li>
</ul>
<p>　　谓词在模型中表示为数学关系、映射或单值函数；在对象语言中可有不同的表示，如<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数</a>。</p>
<p>　　其它外部表示和内部表示的外延由派生实现定义。</p>
<h4 id="同像性"><a class="header" href="#同像性">同像性</a></h4>
<p>　　外部表示和内部表示可能部分共享相同的规则。这些表示是<em>同像的(homoiconic)</em> 。语言支持同像的表示及其有关特性的性质是<a href="https://zh.wikipedia.org/zh-cn/%E5%90%8C%E5%83%8F%E6%80%A7"><em>同像性(homoiconicity)</em></a> 。</p>
<p>　　典型地，同像性允许复用代码和数据之间的表示。特别地，同像性允许对象语言中的代码作为数据(code as data) ，而不需要显式地处理为和代码不同的数据结构，显著简化<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元编程</a>的接口复杂性。</p>
<p>　　除非另行指定，NPL 和派生实现不限制语言中任何不同表示之间可能具有的同像性。</p>
<p><strong>原理</strong></p>
<p>　　<a href="https://zh.wikipedia.org/zh-cn/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84">存储程序的体系结构</a>自然而普遍地依赖代码和数据具有相同的表示，以便有效地把存储的数据直接作为代码提供给控制部件。</p>
<p>　　存储程序型计算机因此能自然地支持<a href="https://zh.wikipedia.org/zh-cn/%E8%87%AA%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81">自修改代码</a>。在更高层次的抽象中，高级语言可能改变这些性质的可用性，使其符合<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>，符合安全设计的需要。</p>
<p>　　但是，自修改程序在一些情形下仍然必要。为了<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">通用目的</a>，这些设计应符合<a href="Features/NPL.zh-CN.html#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测性</a>，而非完全禁止。</p>
<p>　　通过语言规则指定的同像性不具有体系结构设计时依赖的具体数据表示容易引起非预期操作的风险，有必要作为公开特性。</p>
<p>　　不需对代码和数据分别提供不同的特性有利于语言设计和使用的<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>。</p>
<p>　　这同时使对象语言不需要提供特设的对自身的<em>反射(reflection)</em> 特性，因为潜在可被反射的对象伴随一般的元编程无处不在而可被随时引入或排除，直至另行指定的规则限制这种能力。</p>
<p>　　这也是使对象语言的设计符合<a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">光滑性</a>的主要机制。</p>
<p><strong>注释</strong></p>
<p>　　自修改程序在一般意义下对运行时生成代码的 JIT(just-in-time) <a href="Features/../Terminology.zh-CN.html">编译器</a> 是必要的。这有助于提升程序运行时性能。</p>
<p>　　另行指定的规则包含显式的涉及表示的转换规则，例如<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">语法分析等阶段</a>可能转换外部表示为不同的（不确定种类的）内部表示，这些表示不保证其中的组成在变换前后一一对应。但是，NPL 规则没有明确指定破坏可能具有对应的规则，因此不同内部表示之间的非同像性仅在派生实现中可能指定。</p>
<h3 id="演绎规则"><a class="header" href="#演绎规则">演绎规则</a></h3>
<p>　　演绎系统具有的演绎规则决定演绎推理(deductive reasoning) 的输出。</p>
<p>　　指定转换输入和输出之间的关系的演绎规则是转换规则。</p>
<p>　　两两可转换的对象的传递闭包构成<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">等价类</a>，称为可转换等价类。除非另行指定，以下只讨论具有单一可转换等价类的转换规则演绎系统，即（抽象）<em>重写系统(rewriting system)</em> 。</p>
<p>　　对象之间的转换保持某种<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">等价关系</a>的等价<em>变换(transformation)</em> 。对象之间的规约是其中的子集，即以存在等价关系的一个对象替代另一个对象的有向转换。</p>
<p>　　若两个对象具有规约到相同结果的变换，这两个对象<em>可连接的(joinable)</em> 。</p>
<p>　　若任意两个对象等价蕴含对象可连接，则此重写系统具有 <em>Church–Rosser 属性(Church–Rosser property)</em> 。</p>
<p>　　若可从任意一个对象规约到的任意两个对象可连接，则重写系统具有<em>汇聚性(confluence)</em> 。</p>
<p>　　若可从任意一个对象的一步规约到的任意两个对象可连接，则重写系统具有<em>局部汇聚性(local confluence)</em> ，或称为<em>弱汇聚性(weak confluence)</em> 。</p>
<p>　　若可从一个对象规约到的任意两个对象可连接，则此对象具有汇聚性。</p>
<p>　　若可从一个对象的一步规约到的任意两个对象可连接，则此对象具有局部汇聚性，或称为弱汇聚性。</p>
<p>　　规约中可包括涉及<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">实现环境</a>的交互。</p>
<p>　　若规约用于求值，汇聚性限定为：满足任意以此规则变换前和变换后的项被分别规约时，两者的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>相等。</p>
<h3 id="项重写系统"><a class="header" href="#项重写系统">项重写系统</a></h3>
<p>　　作为<a href="Features/NPL.zh-CN.html#%E6%BC%94%E7%BB%8E%E8%A7%84%E5%88%99">重写系统</a>的实例，一个<a href="https://en.wikipedia.org/wiki/Rewriting#Term_rewriting_systems"><em>项重写系统(term rewriting system)</em></a> 包含以下组成：</p>
<ul>
<li>语法元素(syntactic element) 的集合。
<ul>
<li>项及其子项是语法元素的非空的串。</li>
</ul>
</li>
<li>辅助语义函数(auxiliary semantic function) 的集合。
<ul>
<li>可通过语义变量(semantic variable) 指称其中的元素。</li>
</ul>
</li>
<li><em>重写规则(rewrite rule)</em> 的集合。
<ul>
<li>重写规则指定<em>重写(rewrite)</em> ：接收项输入并产生作为重写的输入的项，和被重写的项之间满足某种<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">等价关系</a>即<em>重写关系(rewrite relation)</em> 。</li>
<li>重写规则集合以包含语法元素和语义变量的重写关系在<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>中表达为<em>模式(scheme)</em> 。</li>
</ul>
</li>
</ul>
<p>　　语法上蕴含<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">自由变量</a>的项是<em>开项(open term)</em> 。<em>闭项(closed term)</em> 是开项在项上的补集。</p>
<p>　　为表达计算，限制特定的重写关系使之不满足自反性，得到<em>规约关系(reduction relation)</em> ，即指定<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">规约</a>。对应地，双向的重写规则限制为其子集的单向的<em>规约规则(reduction rule)</em> 。经限制的系统是<em>项规约系统(term reduction system)</em> 。</p>
<p>　　规约关系视为表达计算查询(computational query) 的项和答案(answer) 的项之间的映射。此时，项规约系统被作为一种<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9E%8B">计算模型</a>。</p>
<ul>
<li><strong>注释</strong> 为表达计算的答案的确定性，需要确保规约可能取得<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">范式</a>。</li>
</ul>
<p>　　一般地，项规约系统关联的结构总称为演算(calculus) 。</p>
<p>　　对每个演算，存在和项对应的<em>上下文(context)</em> 。元语言中，一般的上下文以语义变量 <code>C</code> 表示，形式化为具有元变量(meta variable) □ 的以下构造：</p>
<pre><code class="language-xbnf">C ::= □ | ...
</code></pre>
<p>　　其中 <code>...</code> 是演算支持的项的语法中替换<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">子项</a>得到的对应构造。</p>
<p><strong>注释</strong> 例如，对作为对象语言的 λ 演算，语义变量 <code>x</code> 表示约束变量，其上下文为：`C ::= □ | (CT) | (TC) | (λx.C) 。这里的记法基本同 [Shu10] 。</p>
<p>　　一般的项记作语义变量 <code>T</code> ，则 <code>C[T]</code> 表示上下文 <code>C</code> 中作为元变量通过语法代换(syntactic replacement) 为项 <code>T</code> 的结果，它是一个项。</p>
<p>　　作为对象语言的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">变量</a>的项可依赖不同的上下文指称不同的实体。</p>
<p>　　一个变量 <code>x</code> 被上下文 <code>C</code> <em>捕获(capture)</em> ，若对任意 <code>x</code> 是其<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">自由变量</a>的项 <code>T</code> ，<code>T</code> 中自由出现的 <code>x</code> 在 <code>C[T]</code> 中是<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">约束变量</a>。</p>
<p><strong>注释</strong> <code>C</code> 中仍可因自由出现的 <code>x</code> 而使 <code>x</code> 是 <code>C[T]</code> 中的自由变量。</p>
<h3 id="状态和行为"><a class="header" href="#状态和行为">状态和行为</a></h3>
<p>　　状态不变蕴含语言规则中或可选地由实现定义的<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">等价关系</a>决定。</p>
<p>　　除非派生实现另行指定，约定：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">实现行为</a>总是可使用状态进行描述。</li>
<li>存在<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>为<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">可观察行为</a>的必要条件。</li>
<li>在实现外部<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>某个状态的操作（输入/输出操作）是副作用。</li>
</ul>
<p>　　若存在状态等价性以外描述的行为描述，由派生实现指定。</p>
<p>　　可观察行为如有其它外延，由派生实现指定；否则存在副作用是存在可观察行为的充分条件。</p>
<p>　　实现应满足实现行为和语义蕴含的可观察行为等价。除派生实现指定的更特定的具体行为等价性外，其余的行为等价性<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定</a>。</p>
<p>　　实现可支持实体具有对外部不引起可观察行为差异的<em>隐藏状态(hidden state)</em> 。</p>
<p>　　隐藏状态和程序约定的一些状态作为<em>管理状态(administrative state)</em> ，以隐藏局部的状态变化对程序中其它状态的影响。</p>
<p>　　非管理状态是<em>数据状态(data state)</em> 。</p>
<p><strong>原理</strong></p>
<p>　　形式上，可观察的性质影响特定的项的<em>操作等价性(operational equivalence)</em> ：替换操作等价的项得到的两个规约在可观察性质上是等价的，即两个规约的结果相等（对应行为不可分辨）。因此，可观察的性质可形式化为作为这些等价规约的结果的参数。</p>
<p>　　最简单的做法，如 [Shu10] §8.3.2 把具有可观察性质的项处理为常量语法域(syntactic domain) ，不需要附加定义相等性或影响其它规约规则。</p>
<p>　　对语义蕴含的可观察行为等价的要求指定了允许实现进行<em>语义保持变换(semantic preserving transformation)</em> 不能修改可观察性质的内涵，进而明确了实现对程序的可优化的界限。</p>
<p>　　数据状态和管理状态的分类类似 [R<sup>n</sup>RK] 中改变对象的性质上对状态的划分，但不仅仅应用在关于改变对象的判断上。</p>
<p>　　改变对象意义上和 [R<sup>n</sup>RK] 对应的具体实例是<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">实体的不可变性</a>。</p>
<p><strong>注释</strong></p>
<p>　　关于实体的状态，参见<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">实体的等价性</a>。</p>
<p>　　不严格要求实现行为和<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机语义</a>蕴含的所有推论一致。</p>
<p>　　NPL 派生实现不保证是纯函数式语言，其中的<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算</a>允许描述状态的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">改变</a>。表达式的求值的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>和 [ISO C] 以及 [ISO C++] 类似。不同的是，本文档的定义明确指定<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制作用</a>的更一般外延：改变<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制状态</a>，即便这些状态并非从属<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等实体</a>。特别地，最简单的条件分支也明确具有副作用。</p>
<h3 id="作用使用原则"><a class="header" href="#作用使用原则">作用使用原则</a></h3>
<p>　　派生实现可定义其它的作用。</p>
<p>　　在推理<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">实现行为</a>时，副作用应仅在必要时引入。</p>
<p>　　作用具有<em>种类(kind)</em> 。<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值计算</a>是作用的种类。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>中，对象的改变是一种作用的种类。</p>
<p>　　是否存在副作用是互斥的，即一种作用不可能同时是副作用和不是副作用。其它作用的种类可能相交，即可能同属不同的作用。</p>
<p>　　派生实现可定义其它作用的种类。</p>
<p>　　求值可引起副作用的<em>起始(initiation)</em> 。副作用的存在（如改变状态）可继续保持到求值结束后，并可影响<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>。</p>
<p>　　副作用的<em>完成(completed)</em> 即副作用的存在的终止（如改变状态完成）。</p>
<p>　　引起作用的求值<em>蕴含(imply)</em> 求值关联的作用，以及其中蕴含的副作用的起始决定的其它作用。派生实现可定义特定的求值使之蕴含的其它的作用。</p>
<p>　　作用之间可存在<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">等价关系</a>。等价的作用相互替换不影响可观察行为。</p>
<p><strong>原理</strong></p>
<p>　　允许派生实现定义不同的作用以维护<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>。</p>
<p>　　不同<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>对<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">行为</a>的影响可能依赖作用之间的顺序。</p>
<p>　　因此，副作用应仅在必要时引入，不能在推理行为时无中生有(out of thin air) ，除非证明引入的副作用不蕴含<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">被许可的等价的实现行为</a>以外的其它行为。通常需明确区分是否依赖副作用以避免非预期的行为。这有助于保持<a href="Features/NPL.zh-CN.html#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测性</a>和<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%BB%84%E5%90%88%E6%80%A7">可组合性</a>。</p>
<p>　　NPL 及其派生实现中的作用可描述一般的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">计算作用</a>，不限定作用的种类的外延。</p>
<p>　　明确副作用的起始是必要的，因为语言至少需要支持允许无法反馈外部状态完成改变的副作用，即 I/O 操作，此时副作用的存在应被允许保持到求值结束后，否则求值无法终止而被<em>阻塞(blocked)</em> 。</p>
<p>　　副作用的完成是和起始相对的概念，在讨论有关<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">顺序</a>时可能实用。</p>
<p><strong>注释</strong></p>
<p>　　派生实现可定义的其它的作用可能是副作用。</p>
<p>　　副作用的起始在 [ISO C++] 的关于求值（引起的作用）的规则中同样被明确。</p>
<h2 id="实体语义"><a class="header" href="#实体语义">实体语义</a></h2>
<p>　　实体是语言中主要表达的目标。</p>
<p>　　本节提供和实体相关的公共定义和语义规则，并归纳关于<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等实体</a>和<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>的性质。</p>
<p>　　除非另行指定，语言中不引入<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E8%AF%AD%E4%B9%89">非一等实体</a>。仅在特定局部上下文中操作非一等实体。</p>
<p><strong>原理</strong></p>
<p>　　限制非一等实体出现的规则有助于<a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">统一性</a>。</p>
<p><strong>注释</strong></p>
<p>　　根据<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">一等实体和一等对象</a>，<a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">规则 G1a</a> 是限制非一等实体的规则的推论。</p>
<p>　　一等实体的<em>一等(first-class)</em> 性质体现在语言支持的操作限制足够小，使之实例的全集可以涵盖任意<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">求值上下文</a>中。</p>
<p>　　一个一等性质的反例是 [ISO C] 的数组类型的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>无法作为函数的形式参数。推论：[ISO C] 的数组对象不是一等对象。</p>
<h3 id="实体的等价性"><a class="header" href="#实体的等价性">实体的等价性</a></h3>
<p>　　<em>等价谓词(equivalence predicate)</em> 是判断<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">等价关系</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">谓词</a>。</p>
<p>　　等价谓词可定义一些<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">等价类</a>划分。</p>
<p>　　语言提供等价谓词判断两个项之间是否满足等价关系，满足判断等价关系的需要。</p>
<p>　　作用于<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">实体的值</a>的等价谓词（若存在）定义实体的<em>相等(equality)</em> 关系。</p>
<p><strong>注释</strong> 这类似一般的值的集合上可能存在的相等关系。</p>
<p>　　决定相等关系的谓词是相等谓词，可判断实体和实体的值<em>相等(equal)</em> 。</p>
<p>　　除非另行指定，默认实体上的具体等价关系是<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">实体的同一性</a>。</p>
<p>　　对象语言不要求提供默认的具体等价关系，即任意两个实体不一定可以比较等价。</p>
<p>　　已知可比较等价的任意实体之间的等价关系也不具有唯一性。</p>
<p>　　一般地，设计等价谓词需注意避免一些现实的使用困难，如<a href="https://www.craigstuntz.com/posts/2020-03-09-equality-is-hard.html">关于相等性的困难</a>。</p>
<p>　　为使等价关系在实体全集上<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">良定义</a>，等价谓词可能在特定情形弱化为同一性。</p>
<p>　　一般地，弱化应具有可用性理由，这可能和既有等价谓词和等价关系的蕴含的设计相关。</p>
<p><strong>原理</strong></p>
<p>　　等价谓词在避免依赖良序(well-ordering) 和良基(well-founded) 的理论中满足最小依赖原则，尽管其实现仍可能依赖序关系。</p>
<p>　　等价谓词的用途和上下文相关。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>在作为等价关系蕴含实体上的任何其它等价关系。被蕴含的等价关系可具有更多的限制条件。</p>
<p>　　实体的同一性是普遍的，但不是普适的，它仍不足以在所有上下文中都被关注。</p>
<p>　　同时，同一性无法保证在对象语言的所有实体上被实现；否则，会引起根本上显著的问题，限制<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">语言的可扩展性</a>，而和<a href="Features/NPL.zh-CN.html#%E5%BD%A2%E8%80%8C%E4%B8%8A%E5%AD%A6">通用目的语言的一般属性</a>冲突：</p>
<ul>
<li>这类普遍同一性的具体判断依赖<a href="https://zh.wikipedia.org/zh-cn/%E5%A4%96%E5%BB%B6%E6%80%A7">外延性</a>，实质上是语言要求的相等性。
<ul>
<li>这要求任意具体的实现通过已知的、有限的方式构造，直接破坏<a href="Features/NPL.zh-CN.html#%E5%B0%81%E8%A3%85">封装性</a>。
<ul>
<li>特别地，在<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数</a>等实体上的定义体现<a href="https://ncatlab.org/nlab/show/function+extensionality">函数外延性(function existionality)</a> ，非常依赖具体实体的构造。</li>
</ul>
</li>
<li>即便不考虑实现细节，如 λ 演算这样较为简单（但足够有<a href="Features/NPL.zh-CN.html#%E5%AE%8C%E6%95%B4%E6%80%A7">表达能力</a>)）的形式系统，一般的外延性即是<a href="https://zh.wikipedia.org/zh-cn/%E6%B1%BA%E5%AE%9A%E6%80%A7%E5%95%8F%E9%A1%8C">不可判定的</a>。
<ul>
<li><strong>注释</strong> 这种不可判定使某些具体编码具有不唯一的表示，如 <a href="https://en.wikipedia.org/wiki/Church_encoding#Use">Church 数(en-US)</a> 。</li>
</ul>
</li>
<li>尽管有的系统如<a href="https://zh.wikipedia.org/zh-cn/%E5%85%AC%E7%90%86%E5%8C%96%E9%9B%86%E5%90%88%E8%AE%BA">公理化集合论</a>通过<a href="Features/NPL.zh-CN.html#%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E6%96%B9%E6%B3%95">公理语义</a>（具体地，<a href="https://zh.wikipedia.org/zh-cn/%E5%A4%96%E5%BB%B6%E5%85%AC%E7%90%86">外延公理</a>）可以确切定义外延性，这同样依赖破坏封装的具体实现。</li>
<li>即便非通用目的语言也可能类似地因为外延性上的不可判定等问题，<a href="https://github.com/coq/coq/wiki/extensional_equality">存在充分理由拒绝默认提供函数外延性的等价谓词</a>。</li>
</ul>
</li>
<li>进一步，为满足<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>和<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>，这自然地要求任意具体的实现是对象语言的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源代码</a>中可表达，而破坏语言的可扩展性。
<ul>
<li><strong>注释</strong> 例如，语言中不能引入隐藏具体实现细节的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>。</li>
<li><strong>注释</strong> 作为反例，λ 演算中的对象都被 λ 项编码。但这引起的限制在通用目的语言中无法接受。
<ul>
<li>例如，<a href="https://zh.wikipedia.org/zh-cn/%E9%82%B1%E5%A5%87%E6%95%B0">原生的算术</a>在<a href="https://en.wikipedia.org/wiki/Church_encoding#Use">算法复杂度意义上即是低效</a>的，而通过机器数等方式的实现在复杂度和常数上都更高效。但后者的实现依赖外部系统，不能表达为 λ 项。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　决定普适的等价谓词中蕴含的统一的等价关系是不可能的，因此语言中应允许共存多个等价谓词。具体等价谓词的设计可由派生实现及语言的用户提供。</p>
<p>　　等价谓词设计中弱化等价性的一个例子是 [R<sup>6</sup>RS] 的<a href="http://www.r6rs.org/r6rs-editors/2005-August/000840.html">记录(record) 对象的相等性</a>。</p>
<p><strong>注释</strong></p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">实体的同一性</a>是实体上的<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可用于定义状态不变</a>的等价关系的例子。它蕴含了实体没有被替换为不同的实体的判断，满足保持这种判断的<a href="Features/NPL.zh-CN.html#%E9%98%B6%E6%AE%B5%E4%B8%8D%E5%8F%98%E9%87%8F%E7%BA%A6%E6%9D%9F">不变量</a>。</p>
<p>　　关于实体的关联的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>是相对同一性更弱的等价关系。因为<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E5%8F%AF%E5%88%86%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">不可分的同一性</a>，同一实体蕴含其值相等。</p>
<p>　　一些情况部分值的集合不满足数学意义上的等价（如浮点数的 <a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">NaN</a> ），但在此忽略这种可被单独扩展的情况。</p>
<p>　　以下不同准则的操作是相等关系的实例（参见 [EGAL] ）：</p>
<ul>
<li><em>抽象相等(abstract equality)</em></li>
<li><em><a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>相等(reference equality)</em></li>
<li>EGAL ([EGAL])</li>
</ul>
<h4 id="实体的同一性"><a class="header" href="#实体的同一性">实体的同一性</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>是实体上的等价关系的一个主要实例。</p>
<p>　　同一性决定的等价类之间的实体相同，即其整体和任意的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">属性</a>在任意上下文中等价。</p>
<p>　　相同的实体在语言中不需要被区分，可直接替换而不影响程序的语义和行为。后者蕴含<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为等价</a>。</p>
<p>　　实体的同一性可体现在以下隐含的默认规则：</p>
<ul>
<li>不同上下文的实体默认相互独立而不保证能被视为相同（在任意上下文中等价）。</li>
<li>通过语言构造引入的超过一个实体，默认为不相同的实体。</li>
<li>除非另行指定，表示具有同一性的实体的语言构造和其它实体不被要求<a href="Features/NPL.zh-CN.html#%E5%85%B1%E4%BA%AB%E5%BC%95%E7%94%A8">共享</a>指称相同的具有同一性的实体。</li>
</ul>
<p>　　语言在<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等实体</a>上提供的同一性的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">具体判断依据</a>和具体语言支持的特性相关。</p>
<p><strong>原理</strong></p>
<p>　　同一性决定任意两个实体可在语言中不依赖具体操作的行为被直接区分，即满足 Leibneiz 法则(Leibneiz's law) ，或称为<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E5%8F%AF%E5%88%86%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">不可分的同一性</a>。</p>
<p>　　基于这个性质，可在实体上定义和 [So90] 相容的更强的（不依赖语言设计中不存在副作用的）<em>引用透明性(referential transparency)</em> 。</p>
<p>　　同一性的引入默认是名义的，即断言具有同一性的实体和其它实体上的行为相互独立，而不需要附加证明。这种假设避免了一般地证明任意实体具有同一性的困难。</p>
<p>　　若不依赖直接在实体上标记等价类等依赖名义同一性假设的方法，证明一个实体具有同一性而非已知的其它实体，需证明任意的其它允许在程序中构造的实体和这个实体上的任意作用的可观察行为无关。在不限定具体的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">计算作用</a>属于会影响可观察行为的计算作用的确切集合时，这是计算上不可能的。因此，支持这类证明会有效地限制语言在支持不同的计算作用种类上的<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">可扩展性</a>。</p>
<p>　　反之，从不同的对象上取消同一性（而允许实现共享资源等目的）一般是容易的：只要证明不存在影响可观察行为的计算作用即可。这种证明可以由程序名义地表达，例如标记某个实体上只涉及纯计算而没有副作用。</p>
<p>　　另一方面，这也提示纯计算在各种计算作用中具有的特殊性不足以使其作为唯一的可扩展配置的起点。</p>
<p>　　最平凡的起点应是没有任何计算作用的空计算。这无法表达计算，而必须要求扩展才具有实用性。而<a href="Features/NPL.zh-CN.html#%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0">通用目的语言</a>需要支持一般的计算作用，这同时包含支持纯计算。</p>
<p>　　从一般的计算作用排除副作用而得到纯计算，只需要添加可被系统证明的假设，这种机制可以嵌入到系统的规约规则中；而以支持纯计算的系统扩展表达一般的计算，需要引入不足以被对象语言求值规则描述其语义的间接表示（即需要被规约以外的规则翻译），并暴露更多和表达一般计算的目的无关的实现细节。</p>
<p><strong>注释</strong></p>
<p>　　按不可分的同一性，实体的属性在形式逻辑中通过量化的谓词判断而实现。</p>
<p>　　和不可分的同一性相对，存在同一性的不可分性(the indiscernibility of identicals) 。两者可被二阶语言形式地描述。</p>
<p>　　对象语言可提供同一性的相关操作，如：</p>
<ul>
<li>[ISO C] 的非空对象指针的比较操作比较指向的相同类型对象的同一性。</li>
<li>[R<sup>n</sup>RS] 和 [R<sup>n</sup>RK] 的 <code>eq?</code> 过程/应用子比较两个<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>的同一性。</li>
</ul>
<h4 id="实体的不可变性"><a class="header" href="#实体的不可变性">实体的不可变性</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">通过特定的等价关系可定义</a>具体的<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">不可变状态</a>的集合。</p>
<p>　　这些集合可用于定义以这些状态为值的实体的<em>不可变性(immutability)</em> ，进而定义不保持可变性的<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">改变</a>操作和具体的其中可能影响<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">修改</a>操作。</p>
<p>　　通过限定不同的修改操作，定义不同的<em>可修改性(modifiability)</em> 和对立的<em>不可修改性(nonmodifiability)</em> 。</p>
<p>　　通过明确不可修改性拒绝支持修改操作（例如通过通过实体的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>拒绝特定的修改操作），或通过不提供修改操作，语义规则保证实体不被修改操作改变状态。</p>
<p><strong>注释</strong> 例如，关于 [ISO C++] 的非类且非数组类型的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>不可修改，尽管要求非纯右值的语义规则可被视为是一种类型检查。</p>
<p>　　（不依赖和影响<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">实体同一性</a>的）同一个实体上的修改操作是改变操作。只有具有<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">可变状态</a>的实体可能支持这些操作。</p>
<p>　　不论是否能区分同一性，实体可能关联不排除影响<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>的可变状态。</p>
<p>　　一般地，一个实体不一定保证可区分是否具有不可变性以及具有何种不可变性（也蕴含一般不可区分可修改性），因为不可变性依赖实体的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>进行约定。</p>
<p>　　改变操作可能继续保持实体不变。</p>
<p>　　潜在引起实体的一些内部状态的变化的操作可不被视为影响不可变性而不被视为实体的（整体意义上的）改变操作。这种实体具有<em>内部可变性(interior mutability)</em> 。</p>
<p>　　可引起实体变化的状态按设计上是否<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">隐藏局部变化</a>分为两类：</p>
<ul>
<li><em>可变管理状态(mutable administrative state)</em>
<ul>
<li>可变管理状态的改变作为<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">管理状态</a>的改变，不被视为对象（整体）改变的对象内部状态的改变。</li>
</ul>
</li>
<li><em>可变数据状态(mutable data state)</em>
<ul>
<li>可变数据状态的改变是对象的改变。</li>
</ul>
</li>
</ul>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">隐藏状态</a>在可变性的意义上视为可变管理状态。</p>
<p>　　推论：</p>
<ul>
<li>引起实体内的可变管理状态的改变的操作不一定是改变对象的操作。</li>
<li>引起实体内的隐藏的可变状态的改变的操作不一定是修改操作。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　基于等价关系而不是预设具体表示之间的相等定义可变性，避免抽象的目的（如<a href="Features/NPL.zh-CN.html#%E5%B0%81%E8%A3%85">封装性</a>）<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F">依赖特定相等关系的实现细节</a>，支持<a href="Features/NPL.zh-CN.html#%E5%BC%80%E6%94%BE%E6%80%A7">开放世界假定</a>。</p>
<p>　　这种设计的一类典型反例是在预设排除副作用的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯的</a>的设计为基础进行扩展定义改变操作，包括：</p>
<ul>
<li>默认使用不可变<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">数据结构</a>，并在此基础上扩展出可变的数据结构（如 [Rust] ）。</li>
<li>默认支持保证排除副作用的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>，仅在有限的上下文中通过特定构造模拟支持非纯求值（如 Haskell 等纯函数式语言）。</li>
</ul>
<p>　　一般地，这类策略对<a href="Features/NPL.zh-CN.html#%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0">通用目的语言</a>是过度设计，因为这实质上要求所有不存在改变操作的实体操作都完全排除副作用，不支持指定不同类别或层次保留不同改变操作并划分不同等价类的可能性，而限制表达的能力或增加实现相同抽象的复杂性。</p>
<p>　　关联可变状态的实体通常是对象，因为支持区分<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">同一性</a>而能支持发生在不同实体上的作用引起独立的状态的改变而分别影响可观察行为，但这并非绝对。只要允许构造出按等价关系判断具有不相同状态，非对象实体仍可支持内部可变性等不能排除影响可观察行为的性质。这不通过需要区分同一性的状态改变。</p>
<p>　　不区分同一性允许实现任选其中的实例代替其它实例。因此，在抽象机语义上依赖这些实体的不同等价状态表现的所有<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">良定义行为</a>都应被允许，即未指定行为。</p>
<p>　　内部可变性同 [Rust] 的 <code>RefCell&lt;T&gt;</code> 等使用的模式以及 [ISO C++] 的 <code>mutable</code> ，允许对象具有可变管理状态，而不影响依赖可变或可修改的对象整体意义上的类型检查。</p>
<p>　　和 [Rust] 不同而和 [ISO C++] 更加类似，这里的内部可变性仅限关于对象不可变性，和对象是否被<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%88%AB%E5%90%8D">别名</a>正交（一些实例分析参见<a href="https://stackoverflow.com/questions/63487359">这里</a>）。</p>
<p>　　但是，和 [Rust] 及 [ISO C++] 都不同，这里不要求不可变性通过<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>强制。</p>
<p><strong>注释</strong></p>
<p>　　可变和不可变的状态的区分类似 [R<sup>n</sup>RK] 。</p>
<p>　　其它语言也遵循类似的设计。作为非对象实体的可变性的一个例子，<a href="https://eel.is/c++draft/dcl.ref#4">C++ 引用是否要求存储未指定</a>，尽管占用存储这一状态并非是语言支持的可变状态。这一规则直接允许 C++ 实现不需要依赖 <a href="https://eel.is/c++draft/intro.abstract#footnote-6">as-if 规则</a>即可选取占用和不占用存储的方式实现引用的实例（乃至在运行时改变选取策略），即便是否占用存储可能对应 C++ 程序的不同的可观察行为。</p>
<p>　　改变或修改实体后，实体可能不变，即仍然具有和之前等价的状态。例如：</p>
<ul>
<li>改变操作使用等价的状态替换先前的状态。</li>
<li>连续的改变操作使回复原始的状态，则这些改变操作的组合的作用不改变实体。</li>
</ul>
<p>　　按<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">定义</a>，蕴含引起表达式的值以外的改变的操作的作用是副作用。这里的改变是名义的，允许改变前后的状态等价。</p>
<p>　　支持不同等价的不可变性的一个用例是，有序的数据结构中的键需要保持的（通过序关系定义的）等价关系和键的可修改性是两种不同的等价关系。作为它的一个具体的反例，C++ 标准库要求关联容器的键具有 <code>const</code> 修饰，没有区分两种等价性，导致无法修改等价的键（除非具有 mutable 数据成员），而引起一些不必要的复杂。</p>
<h3 id="实体的副本"><a class="header" href="#实体的副本">实体的副本</a></h3>
<p>　　在已知的实体以外，实体，作为其<em>副本(copy)</em> ，满足：</p>
<ul>
<li>实体和实体的副本满足某种<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">等价</a>，至少蕴含<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">实体的值</a>之间满足<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">不可变性</a>。</li>
<li>若一个实体是对象，它的副本和它不<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一</a>。</li>
</ul>
<p>　　除非另行指定，若实体的副本无法被创建，引起创建副本的操作<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　若实体的副本可被创建，它可能通过：</p>
<ul>
<li><em>复制(copy)</em> 实体：创建副本后，保持原实体的值<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">不变</a>。</li>
<li><em>转移(move)</em> 实体：创建副本后，原实体被转移而具有<em>有效但未指定(valid but unspecified)</em> 的状态；若可能取得实体的值，其值<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定</a>。
<ul>
<li><strong>原理</strong> 要求有效，隐含其<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>时具有<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">良定义行为</a>。</li>
<li><strong>注释</strong> 参见<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">未指定状态</a>。</li>
<li><strong>注释</strong> 这类似 [ISO C++] <a href="https://eel.is/c++draft/lib.types.movedfrom">[lib.types.movedfrom]</a> 。</li>
</ul>
</li>
<li><em>析构性转移(destructively move)</em> 实体：创建副本后，原实体的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>结束，不再可<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>。</li>
<li>其它派生实现指定的创建实体副本的不同方式。</li>
</ul>
<h3 id="实体数据结构"><a class="header" href="#实体数据结构">实体数据结构</a></h3>
<p>　　实体的集合上可定义关联关系：集合的包含关系或其它实现定义的<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">严格偏序关系</a>。被关联的实体称为<em>子实体(subentity)</em> 。</p>
<p>　　子实体可以是作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">数据结构</a>的一部分。这种数据结构可以是一般的<em>图(graph)</em> 。</p>
<p>　　数据结构也可在对象语言中通过实体包含关系以外的途径定义。</p>
<p><strong>注释</strong></p>
<p>　　例如，限定包含关系构成的图中的<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权关系</a>附加限制，详见<a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">自引用数据结构和循环引用</a>。</p>
<h3 id="续延"><a class="header" href="#续延">续延</a></h3>
<p>　　<em>续延(continuation)</em> 是特定<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87">上下文</a>中描述未来的<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算</a>的实体。</p>
<p>　　续延描述的计算可能在尚未发生的后继的规约中实现，在此之前可能被<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">调度</a>，其中可指定不同的计算内容。上下文可决定这些计算中可变的参数化部分。</p>
<p>　　计算可通过切换续延蕴含<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制状态</a>改变而具有<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制作用</a>。</p>
<p>　　当前规约的上下文中对应的续延是<em>当前续延(current continuation)</em> 。</p>
<p>　　按对控制的限制，续延可分为<em>无界续延(undelimited continuation)</em> 和<em>有界续延(delimited continuation)</em> 等不同形式。</p>
<p>　　续延蕴含<em>子续延(child continuation)</em> 作为最后的一系列子计算。</p>
<p>　　形式上，若续延表示为一个计算步骤的序列，子续延的表示是续延的表示的后缀。</p>
<p>　　推论：无界续延的子续延是无界续延；有界续延的子续延是有界续延。</p>
<p><strong>注释</strong></p>
<p>　　续延可由符合<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E9%87%8D%E5%86%99%E7%B3%BB%E7%BB%9F">项规约系统</a>的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E8%A7%84%E5%88%99%E5%92%8C%E6%B1%82%E5%80%BC">规约步骤</a>的集合或未指定的其它形式的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">表示</a>。</p>
<p>　　不同形式的续延的调用都能具有类似的控制作用，但<a href="Features/NPL.zh-CN.html#%E5%AE%8C%E6%95%B4%E6%80%A7">表达能力</a>不尽相同。</p>
<p>　　有界续延可从无界续延或有界续延通过添加续延的<em>界限(delimiter)</em> （或称为<em>提示(prompt)</em> ）派生。派生的结果是原续延的一部分，表达原续延对应的计算的<em>子计算(subcomputation)</em> ，又称<em>部分续延(partial continuation)</em> 。</p>
<p>　　在仅使用<em>局部变换(local transformation)</em> 即 Felleisen <em>宏表达(macro-expressible)</em> ([Fl91]) 的意义上，[Fi94] 指出：</p>
<ul>
<li>有界续延和可变状态（存储）可实现无界续延。</li>
<li>嵌入在语言中的任意表达<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">计算作用</a>的<em>单子(monad)</em> 的构造可用有界续延实现。</li>
</ul>
<h3 id="一等实体和一等对象"><a class="header" href="#一等实体和一等对象">一等实体和一等对象</a></h3>
<p>　　NPL 区分两类不同的一等实体：只关心关联（作为对象时）的值的，和同时关心作为对象的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">其它属性</a>的一等对象。</p>
<p>　　其中，后者允许更多的操作，且允许作为前者使用，反之无法直接保证：一等对象总是一等实体，一等实体不保证可作为一等对象使用。</p>
<p>　　逻辑上，一等实体可以关联其它对象（作为一等对象时关联可以是存储）。关联的对象的（表达式相关的）值是一等实体关联的值，可对应一等对象存储值。关联的值或存储的值是一等实体或一等对象的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">属性</a>。</p>
<p>　　除非派生实现指定，NPL 的一等实体都是一等对象。</p>
<p>　　结合<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E8%AF%AD%E4%B9%89">实体语义</a>相关规则，存在推论：除非另行指定，语言中不引入非一等对象。</p>
<p><strong>原理</strong></p>
<p>　　一等对象的值是一等对象的属性。</p>
<p>　　一些设计中，显式地不区分对象和值，因为这些设计中不支持普遍的一等对象。在这些设计中，一等实体被称为一等对象。因为不保证提供其它属性，一等对象的值和一等对象也不再被区分。这有助于<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>，但阻碍<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">实体语义的可扩展性</a>，直接无法从语言设计中允许在一等实体中区分一等对象。因此，NPL 不使用这种设计。</p>
<p><strong>注释</strong></p>
<p>　　派生实现可以定义非一等对象的其它一等实体。</p>
<p>　　除非派生实现指定，非一等对象也不是一等实体。</p>
<p>　　显式地不区分对象和值如 [R<sup>n</sup>RS] 。这些设计中，<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值对象</a>若被使用，仍被作为实现细节；且因为互操作和允许支持副作用，值对象并非全部一等对象的内部表示。</p>
<h4 id="一等对象的同一性"><a class="header" href="#一等对象的同一性">一等对象的同一性</a></h4>
<p>　　一等对象通过保证具有<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>强调不相同的对象总是存在至少一种<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">总是不相同的属性</a>。</p>
<p>　　一般地，语言规则选取其中一种属性作为名义(nominal) 同一性属性。</p>
<p>　　一等对象具有名义同一性，定义为可比较名义同一性属性<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">相等</a>；名义同一性的相等即名义同一性属性相等。</p>
<p>　　名义同一性在名义上标识相同的对象，区分不相同的对象，即便后者可能仍然在行为上完全符合同一性的要求。</p>
<p>　　形式上，一等对象是名义同一性属性和它作为一等实体的关联的对象作为非对象（无视同一性）的其它属性集合（如<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">存储的值</a>）的二元组。</p>
<p>　　为简化设计，NPL 约定以下默认规则：</p>
<ul>
<li>除非另行指定，名义同一性属性指定为对象在<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机语义</a>下的存储位置。
<ul>
<li>对象占据存储位置起始的若干存储。</li>
<li>存储位置的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>未指定；派生实现可指定具体的表示。</li>
</ul>
</li>
<li>在语言规则中，一等对象满足<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">实体的同一性</a>的默认规则。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　由语言特性而非<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>提供表达同一性的支持是必要的，这体现在通过在<a href="Features/NPL.zh-CN.html#%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0">通用目的语言</a>中省略同一性的表达再由实现或用户程序引入的做法一般是不可行的：</p>
<ul>
<li>由 <a href="https://zh.wikipedia.org/zh-cn/%E8%8E%B1%E6%96%AF%E5%AE%9A%E7%90%86">Rice 定理</a>，非平凡(non-trivial) 的程序语义性质无法被<a href="Features/NPL.zh-CN.html#%E5%AE%8C%E6%95%B4%E6%80%A7">可计算地</a>实现，而确定程序中任意对象的同一性蕴含判定“和特定程序行为一致”这种非平凡语义性质，无法被通过证明程序行为的等价或其中的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">实体在任意上下文上的等价</a>任意地引入，因此若无法确定用户程序不需要任意的同一性（这是一种平凡情形），指定“不需要引入同一性”总是只能在特定的程序上由语言设计者或用户具体地决定。</li>
<li>作为通用目的语言若需要描述能适应语言自身实现问题的特性，总是依赖具体语言的逻辑上的<a href="https://zh.wikipedia.org/zh-cn/%E9%9D%9E%E7%9B%B4%E8%B0%93%E6%80%A7">直谓(predicative) 的</a>规则（如资源抽象），除非语言规则是空集（这是一种平凡情形），这不可能完全由用户程序提供。</li>
</ul>
<p>　　语言的设计中显式区分一等实体和一等对象的支持而非只直接支持一等对象仍然是必要的，主要原因是：</p>
<ul>
<li>一等实体的具体表现形式通常是实现细节而要求不被依赖，为了支持前者不被显式表达，满足<a href="Features/NPL.zh-CN.html#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99">关注点分离原则</a>。</li>
<li>一等实体的普遍支持允许以<a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">统一</a>的方式抽象<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可变状态</a>，且扩展使便于满足<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>。</li>
</ul>
<h4 id="可变状态和普遍性"><a class="header" href="#可变状态和普遍性">可变状态和普遍性</a></h4>
<p>　　NPL 对一等实体提供普遍的支持。</p>
<p>　　除非另行指定，NPL 不限制一等实体上可能具有的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>，包括<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>。</p>
<p><strong>原理</strong></p>
<p>　　一等实体的普遍支持体现在：</p>
<ul>
<li>在一般的一等实体上引入可变状态，实质上提供了<em>一等副作用(first-class side effect)</em> ，而不把<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">可修改性</a>限于特定的数据结构（如<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">求值环境</a>）。</li>
<li>允许以一致的方式和实现的外部环境进行<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>，特别地，允许物理上提供状态抽象的设备实体的状态直接映射为一等对象。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　特别地，一等对象默认支持可变状态。</p>
<p>　　派生实现可附加规则改变本节中对一等对象的默认要求，提供不同的保证或性质，包括<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>上的其它一等实体上的不同作用。</p>
<h3 id="同一性关联扩展性质"><a class="header" href="#同一性关联扩展性质">同一性关联扩展性质</a></h3>
<p>　　NPL 中，对象的同一性关联的属性包括明确开始和终止的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>。</p>
<p>　　推论：对象是表示能明确生存期开始和终止的实体。</p>
<p>　　一等对象之间总是能准确地判断影响程序语义的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">同一性</a>：仅当能证明不改变<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>时，两个一等对象的同一性可能未指定。</p>
<p><strong>原理</strong></p>
<p>　　通过一等对象关联同一性，允许语言提供依赖同一性差异的特性。</p>
<p><strong>注释</strong></p>
<p>　　同一性在这个意义上不是对象自身确定的性质（而是对象和解释对象表示的可能由外部提供的实现的共同确保的性质），不是应被隐藏的内部实现，因此 [EGAL] 中有关自我诊断(autognosis) 的结论不适用；而代理(proxy) 仍然可通过语言提供适当的隐藏同一性的手段可靠地实现。</p>
<h4 id="一等状态"><a class="header" href="#一等状态">一等状态</a></h4>
<p>　　确保区分同一性的<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">状态</a>是<em>一等状态(first-class state)</em> 。</p>
<p>　　一等对象能直接表示一等状态。</p>
<p>　　一等状态是否通过其它特性派生是未指定的。</p>
<p><strong>原理</strong></p>
<p>　　一等对象相对一等实体的附加规则限制集中体现在允许一等对象映射到的支持上。</p>
<p>　　注意并非所有一等对象都需要支持一等状态；否则几乎总是会<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">付出本不必要的代价</a>也难以避免违反<a href="Features/NPL.zh-CN.html#%E9%80%82%E7%94%A8%E6%80%A7">适用性</a>；因此有必要区分一等状态的对象和非一等状态的对象。</p>
<p>　　这种区分实质上更普遍地对具体的计算操作也存在意义，自然地引入了类似 [ISO C++] 的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">值类别</a>；最简单的设计如区分<em>左值(lvalue)</em> 和<em>右值(rvalue)</em> 分别关联是否需要支持一等状态的对象。</p>
<p>　　为支持一等状态，有必要支持判断两个对象的同一性，确保<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">修改</a>某个对象的操作不会关联到任意其它对象，以允许特定对象关联特定的一等状态。</p>
<p>　　为允许一等状态和<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">外部环境</a>的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>，不能总是假定只有一类总是可被程序局部预知的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">修改操作</a>（典型地，定义为“设置<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>”操作，如 [R<sup>n</sup>RK] §3.1 ）影响状态，而应允许和特定对象关联的求值时的不透明的副作用。</p>
<p>　　若不考虑互操作，则一等对象用有限的不同<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">等价谓词</a>]即能提供区分同一性的操作；否则，等价谓词的设计即便保持<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E4%BA%A4%E6%80%A7">正交</a>，也需区分不同的一等对象对各种<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>的不同支持情况。</p>
<p>　　避免指定一等对象的可派生方式有助于<a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">统一性</a>。</p>
<p>　　基于 [Fi94] ，结合可变状态能被表达为单子（如<a href="https://www.pauldownen.com/publications/delimited-control-effects.pdf">这里</a>）的事实，<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">有界续延</a>可实现状态。</p>
<p>　　相对地，基于 [Fl91] ，<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">无界续延</a>和<a href="Features/NPL.zh-CN.html#%E5%BC%82%E5%B8%B8">异常</a>不能实现一般意义的可变状态，参见<a href="https://www.researchgate.net/profile/Hayo-Thielecke/publication/2487383_Contrasting_Exceptions_and_Continuations/links/53e12dba0cf2235f352738e5/Contrasting-Exceptions-and-Continuations.pdf">这里</a>的推论 5.13 。</p>
<p>　　因为同一性可以在引入状态时被编码而在之后不需改变，使用有界续延等非一等的状态可支持实现状态的同一性。因此，在此不对是否基本要求作出限定。</p>
<p>　　但是，使用有界续延实现状态仅仅是实现细节，且通常具有一些非预期的实现性质：</p>
<ul>
<li>这在控制状态和支持一等状态的实现之间建立的不对等（地位不同，相互之间交换后不等效）的偶然耦合；这种耦合不存在简化实现等益处而具有必要性。
<ul>
<li><strong>注释</strong> 例如，一等状态可能直接使用对应的<em>寄存器(register)</em> 实现。实现控制状态则通常需要更复杂的实现。</li>
<li>尽管理论可行，没有必要只是用其中一种作为另一种的实现的基础实现。
<ul>
<li>在现有实现普遍提供状态的原生支持（存储器）的常见情况下，单独通过其它方式编码状态反而会付出本不必要的代价。</li>
</ul>
</li>
</ul>
</li>
<li>这实质要求实现同一性无界续延具有区分同一性的能力（相当于 [ISO C++] 的左值），而引起不正交的内部设计。</li>
</ul>
<p>　　为满足非常规的实现环境或更优先的原则（如<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>和<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>），派生实现仍可使用有界续延派生一等状态，同时提供访问更基本的不依赖可变状态的接口，以使上述影响不再是非预期的。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>仍不被禁止使用这种方式自行提供类似的实现，以确保<a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">不约定一等状态作为基本的内建特性时</a>，语言的设计不违反 <a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">G1b</a> 。</p>
<p><strong>注释</strong></p>
<p>　　实现在一般实体上支持的<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">隐藏状态</a>不被程序可编程地指定，不是一等状态。</p>
<p>　　允许和特定对象关联的求值时的不透明的副作用的一个实例是 [ISO C] 和 [ISO C++] 的 <code>volatile</code> 类型对象。</p>
<h4 id="一等作用"><a class="header" href="#一等作用">一等作用</a></h4>
<p>　　语言可指定特定的求值自动创建对象。</p>
<p>　　基于此规则可在传递时附加不同的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>，即实现可随一等对象传递的<em>一等作用(first-class effect)</em> 。</p>
<p><strong>原理</strong></p>
<p>　　典型地，<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值传递</a>时，被传递后的对象和<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">实际参数</a>表示的对象具有不同的同一性，即按值传递时创建<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">新的对象</a>。</p>
<p>　　基于被创建的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">副本</a>的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">不变性</a>，这里的一等作用可包括用于维护对象的<a href="Features/../Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">不变性</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>，<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E5%8F%98%E7%8A%B6%E6%80%81%E5%92%8C%E6%99%AE%E9%81%8D%E6%80%A7">包括可能的副作用</a>，作为<a href="https://zh.wikipedia.org/zh-cn/%E5%A5%91%E7%BA%A6%E5%BC%8F%E8%AE%BE%E8%AE%A1">契约式编程(programming by contract)</a> 的基础实现方式。</p>
<p>　　这种不变性可包括对象的生存期。通过限制特定表达式求值的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用域</a>内销毁对象以确保对象生存期有限，即基于作用域的对象管理(scope-based object management) 。</p>
<p>　　基于作用域的对象管理可直接对应有限资源的普遍性质，使一等对象作为资源的抽象，确保资源的创建和销毁的副作用符合资源操作的语义，同时避免隐式的泄漏。</p>
<p>　　配合<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">一等状态</a>，对象语言中的一等对象允许直接表示超过程序运行时自身的生存期的状态。这允许不在程序运行时持久储存的数据能直接被一等对象进行操作，而不需要依赖外部系统的约定并减少冗余操作（例如，从外部持久的“文件”上打开“流”以及其上的持久化操作），更符合<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>。</p>
<p><strong>注释</strong></p>
<p>　　这里的资源抽象的惯用法在 C++ 中称为 RAII(resource aquisition is initialization) 。</p>
<h4 id="所有权抽象"><a class="header" href="#所有权抽象">所有权抽象</a></h4>
<p>　　配合<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E4%BD%9C%E7%94%A8">一等作用</a>，实体的<em>所有权(ownership)</em> 自然地适用对抽象为对象的资源进行约束。</p>
<p>　　使用对象代表资源，则<em>所有者(owner)</em> 约束被其所有的其它对象的创建和销毁的时机。被所有的对象的生存期是所有者的生存期的并集的子集，且：</p>
<ul>
<li>被所有的对象的生存期的起始不<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序</a>所有者的生存期起始。</li>
<li>被所有的对象的生存期的终止不<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">后序</a>所有者的生存期终止。</li>
</ul>
<p>　　NPL 的设计避免要求对象语言隐含单一的<em>根(root)</em> 所有者作为其它资源的所有者。</p>
<p><strong>原理</strong></p>
<p>　　避免单一所有者适应抽象不同系统的需要，并满足<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>：</p>
<ul>
<li>当不需要这样的所有者时，保持设计的<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>，同时满足<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>和<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>。</li>
<li>当需要这样的所有者时，仍然允许实现或派生实现引入。</li>
</ul>
<p>　　注意<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">规约</a>允许蕴含<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>的所有者用于提供规约时不在对象语言中可抽象为一等对象访问的资源，这样的所有者不需要是全局的；若实现为在不同规约实例乃至全局共享的资源，也不应在对象语言被依赖。</p>
<p>　　只要程序没有明确要求所有者，单一的全局所有者违反<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E4%BE%9D%E8%B5%96%E5%8E%9F%E5%88%99">最小依赖原则</a>，且不支持不清楚所有者状态时对特定对象之间进行所有权的局部推理(local reasoning) ：</p>
<ul>
<li>这种情形若不配合原始的明确目的（而间接明确资源的所有者）的设计说明，人类读者直接阅读实现理解和验证其正确性是困难的，即损失了可读性。
<ul>
<li>一种解决方式是读者自行模拟运行程序再从中推理出可简化的资源所有关系，这首先相当于要求读者模拟非确定性垃圾回收(GC, garbage collection) 的运行机制。这通常是困难的工作。</li>
</ul>
</li>
<li>而机器通常更无法推理这些问题，因为设计和抽象的目的一般不是以机器可读的方式编码的。
<ul>
<li>GC 可以回收资源，但无法准确统计哪些回收是必要的，也无法准确追溯原始实现并推理出应当在何种情况下静态地插入释放资源的操作，因为 GC 自始至终缺乏“允许任意延迟释放操作”以外的程序变换的<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">保持语义不变</a>的证明所需的程序元信息（包括目的）。</li>
</ul>
</li>
</ul>
<p>　　为满足<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>，当需要表达局部所有权关系时，使用单一的全局所有者使用户无法直接在对象内嵌(embedding) 这种关系而需另行编码所有权信息，这存在以下问题：</p>
<ul>
<li>使整体设计直接违反<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>。</li>
<li>要求局部所有权以和全局默认机制的不一致的方式表达，损失<a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">统一性</a>并放弃<a href="Features/NPL.zh-CN.html#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99">局域性</a>而在满足需求时造成接口<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F">抽象泄漏</a>。</li>
</ul>
<p>　　此外，即便使用时不要求区分对象的局部所有权关系，全局的分配释放机制也比局部的机制有更大的实现复杂性和约束。为实现对内部有限的资源的有效管理，局部所有权在实现中仍是必要的。</p>
<p>　　在使用全局所有者如全局的垃圾回收的实现中，这种必要性被隐藏在全局所有者内部实现，语言的整体设计不会更<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单</a>。</p>
<p>　　使用全局所有者的资源管理假定启发式(heuristic) 策略以节约现实中无法接受的非预期性开销。这仍无法保证总是对不同的场景同样有效，以至于默认存在以下问题：</p>
<ul>
<li>设计至少违反变化的自由和<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>之一。</li>
<li>在不引入支持用户配置策略的扩充设计时，违反变化的自由总是无法避免的。</li>
<li>若引入其它设计支持用户配置策略，简单性违反难以避免，且实际基本上没有被避免。</li>
<li>即便能通过扩充设计避免违反简单性，也不能避免<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">不必要付出的代价</a>。</li>
<li>不论是否引入扩充设计，都会使资源管理的一般开销更难以估计，而使设计整体的可用性评估更困难，容易使用户决策和避免不必要付出的代价冲突。</li>
</ul>
<h3 id="一等引用"><a class="header" href="#一等引用">一等引用</a></h3>
<p>　　NPL 的一等对象即对象自身，不要求区分引用和<em>被引用对象(referent)</em> 的普遍概念。</p>
<p>　　反之，通过使引用和其它一些非引用的对象同为<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">一等对象</a>，NPL 支持作为一等对象的<em>一等引用(first-class reference)</em> 。</p>
<p>　　一等引用支持一等对象作为被引用对象。除非另行指定，若实现允许<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>作为被引用对象，可作为被引用对象的非一等对象由实现定义。</p>
<p>　　特定的操作可能预期非引用，或总是隐含通过引用<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>被引用对象，这不改变引用被作为一等对象使用的普遍支持。</p>
<p>　　一等引用的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">相等关系</a>定义为被引用对象的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">名义同一性相等</a>。</p>
<p>　　一等对象的使用仍然可以通过要求引用访问以避免在任意上下文中需要不同的对象副本。但这并不应排除其它形式的一等对象操作。</p>
<p><strong>原理</strong></p>
<p>　　尽管满足 [R<sup>n</sup>RK] Appendix B 的准则(criteria) ，一等对象和 [R<sup>n</sup>RK] 及 Java 等语言要求的设计不同。</p>
<p>　　注意有引用的语言的语义中不能排除被引用对象，否则无法确定引用对象的值的表达式的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>（例如来自对象<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">存储的值</a>）以表达<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算</a>；相反，无视引用而直接对值操作仍然能实现一些足够有意义的程序。</p>
<p>　　因此，若存在引用，无法忽略非引用（即便非引用不能在对象语言被直接使用）。</p>
<p>　　另一方面，引用可以由不指定为引用的一般对象上添加语义规则区分，而作为一般的对象的特例。</p>
<p>　　要求语言操作的一等对象总是关联到引用的设计实质上使对象语言的一等对象都是引用。但这不表示引用是自然的一等实体，因为引用的作用仅是操作被引用对象，不要求引用自身能被作为一等对象。</p>
<p>　　一等引用的相等性定义允许在相等的引用上推理<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">引用透明性</a>。</p>
<p>　　考虑此设计决策时关注的有以下几节中的依据。其它依据参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h4 id="共享引用"><a class="header" href="#共享引用">共享引用</a></h4>
<p>　　共享引用是共享资源的引用。共享的资源（通常是存储空间）自身具有同一性，以<em>位置(location)</em> 标记。共享不同位置（即作为不同一等对象的）的引用可能引用同一个被引用对象。</p>
<p><strong>原理</strong></p>
<p>　　合理的共享引用可以节约实现占用的资源，提供更好的性能。但共享引用的实现仍可能有附加的开销，因此并不能保证使用共享引用一定能提供更好的性能。通常这种情形至少包括一些典型的对资源独占一次使用（具有独占所有权(unique ownership) ）的情况。</p>
<p>　　更重要地，并非任意引用的共享都不改变程序的语义和行为，不合理的使用可能造成非预期的作用。</p>
<p>　　任意地引入共享引用而使用户不便预测其作用破坏<a href="Features/NPL.zh-CN.html#%E9%80%82%E7%94%A8%E6%80%A7">适用性</a>：</p>
<ul>
<li>这包含直接破坏<a href="Features/NPL.zh-CN.html#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测性</a>，并在需要排除共享的场景中缺乏<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>。</li>
<li>特别地，这和具有副作用的<em>非确定性(non-deterministic)</em> 编程冲突。</li>
<li>典型的<a href="Features/NPL.zh-CN.html#%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0">多线程并发执行</a>若需对象上的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>，需要保护和排除不必要的共享，确保独占<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权</a>以避免<em>竞争条件(race condition)</em> 。</li>
<li>也有其它的一些类似的容易被忽略的<a href="https://okmij.org/ftp/continuations/map-story.html">非确定性地破坏假设的场景</a>。</li>
<li>另见共享改变。</li>
</ul>
<p>　　区分是否需要表达共享的情形一般不能由语言实现预知。和<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">使用全局所有者的问题</a>类似，使对象默认共享的设计若需避免违反<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>，在此相对不默认共享引用的设计违反<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>。</p>
<p>　　默认共享引用可能是隐式的，即语言的实现不通过程序<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">代码</a>中的显式标注的操作而引入共享的引用，且往往无法保证通过一等对象上的操作避免被引用的对象被其它一等对象引用——无法使用对象语言的操作排除共享引用（即便是新创建的对象也没有保证，尽管实现上不必要）。</p>
<p>　　在要求一等对象都是引用的设计中，一般地，只有不要求名义同一性的非对象的实体才能安全地共享引用，但在非对象实体上的类似引用的机制并没有保证通过一等引用提供为语言特性。</p>
<p>　　其它情形中，允许引用之间的隐式的共享使<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">不相同的对象</a>可能共享状态而破坏<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">同一性的行为保证</a>：程序无法可靠地避免共享状态导致的对<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>的影响，此时共享状态的改变非预期地影响其它对象，其行为不具有<a href="Features/NPL.zh-CN.html#%E4%B8%80%E8%87%B4%E6%80%A7">一致性</a>。</p>
<p>　　为了排除破坏同一性和适用性的问题，语言的设计需要限制引起问题的操作的可用性（例如，[R<sup>n</sup>RK] 和 [R<sup>n</sup>RS] 不提供使用一等引用的改变操作以保证变化能通过程序<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源代码</a>中有限的语法上下文被推理），但这样的策略限制设计的<a href="Features/NPL.zh-CN.html#%E5%85%B6%E5%AE%83%E6%8E%A8%E8%AE%BA%E5%92%8C%E6%AF%94%E8%BE%83">通用性</a>。</p>
<p>　　因为共享引用的影响的普遍性，不提供可避免隐式共享引用的设计的造成的缺陷也是普遍的。</p>
<p>　　由于显式的引用可以由用户控制在局部使用，更容易推理其影响，可避免类似的缺陷。</p>
<p>　　关于共享改变和程序无法可靠地避免共享状态导致的对可观察行为的影响，参见参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>注释</strong></p>
<p>　　一些语言的设计指定或隐含的规则在程序代码操作的一等对象上普遍地引入隐式共享的引用，如：</p>
<p>　　[R<sup>n</sup>RK] 中的引用和被引用对象明确地分离，且 <code>$define!</code> 和 <code>set-car!</code> 等<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">改变操作</a>要求设置对象引用的其它对象为特定的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>确定的被引用对象，无法排除被设置的引用被共享；这实质要求所有可能包含其它引用的可被改变的对象中的引用都需要能构成隐式的共享。</p>
<p>　　[R<sup>n</sup>RS] 明确指出特定的空对象的唯一性（即便因为不保证具有位置，不一定保证以位置决定的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">名义同一性</a>），蕴含这些对象上总是可构造或超过一个引用必须构造隐式的共享引用；其它变量引用(variable reference) 未指定排除隐式的共享。</p>
<h5 id="对象别名"><a class="header" href="#对象别名">对象别名</a></h5>
<p>　　除非在语言规则中添加复杂的约束（如通过<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型</a>的机制）以证明特定上下文可避免共享引用，无法避免引用引入不必要的对象<em>别名(aliasing)</em> 。</p>
<p>　　若公开这样的性质作为接口约束，违反<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>。</p>
<p>　　隐式的共享使涉及<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">修改</a>的操作的特性更难设计，参见共享改变。</p>
<p>　　关于共享改变，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　对象别名一旦引入，通常难以在所有被别名的对象生存期结束前消除。</p>
<p>　　证明对象不被别名是困难的，因为这逻辑上要求在局部知悉所有被别名的对象的存在性，而不具有<a href="Features/NPL.zh-CN.html#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99">局域性</a>。</p>
<h3 id="自引用数据结构和循环引用"><a class="header" href="#自引用数据结构和循环引用">自引用数据结构和循环引用</a></h3>
<p>　　特定的数据结构在逻辑上要求内部具有相互指涉的引用，即<em>自引用(self-referencing)</em> 。</p>
<p>　　自引用可实现为一等对象集合内的<em>循环引用(cyclic reference)</em> ，即允许对象属于有限次迭代访问被引用对象的操作的传递闭包（非空的<em>链(chain)</em> ，称为引用对象链）的构造。</p>
<p>　　NPL 的不保证支持这种方式实现自引用。</p>
<p><strong>原理</strong></p>
<p>　　NPL 的设计不保证支持通过循环引用实现自引用，以避免一些固有缺陷。即便派生语言允许提供扩展支持，但本节讨论的原理仍然适用。</p>
<p>　　避免自引用的构造使实体构成的数据结构由一般的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">图</a>退化为（可共享节点的）树形数据结构，即 DAG（Directed Acyclic Graph ，有向无环图）。</p>
<p>　　这样的设计在实现上避免外部所有者（如<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">全局 GC</a> ）。</p>
<p>　　避免一般的循环引用的普遍理由是：<a href="https://zh.wikipedia.org/zh-cn/%E9%9D%9E%E7%9B%B4%E8%B0%93%E6%80%A7"><em>非直谓性(impredicativity)</em></a> 并非是抽象上必要的普遍特性。一般的循环引用在抽象上即应通过特殊进行归纳，这并非<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F">泄漏抽象</a>。</p>
<p>　　反之，需求决定的抽象上不必要的情形下，假定循环引用的存在反而妨碍抽象的构造，可能避免某些有用的普遍性质（例如，保证程序可终止；另见<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">强规范化性质</a>），而违反<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>、<a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">统一性</a>和<a href="Features/NPL.zh-CN.html#%E9%80%82%E7%94%A8%E6%80%A7">适用性</a>，并引起若干具体设计问题。</p>
<p>　　关于通过任意对象支持循环引用的问题，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h4 id="一般引用数据结构的一般实现"><a class="header" href="#一般引用数据结构的一般实现">一般引用数据结构的一般实现</a></h4>
<p>　　通过一些替代原语，在不支持循环引用的情形仍可支持自引用数据结构。</p>
<p>　　语言可以提供在不支持一般的循环引用的对象构造中保存无所有权的一等实体引用其它实体，构造出不蕴含所有权的仅以特定对象构成的循环引用，而在外部引入对象作为所有这些构成引用的对象的所有者的机制。</p>
<p>　　在这个基础上，一般的自引用或循环引用需要的附加指涉仍然可通过添加不蕴含所有权语义的引用解决。这些引用是<em>弱引用(weak reference)</em> ，区分于具有所有权的引用是<em>强引用(strong reference)</em> 。</p>
<p>　　强引用总是可转换为弱引用使用。弱引用通过<em>解析(resolve)</em> 取得强引用。解析可能失败，以允许弱引用指涉已经不存在的对象，而避免影响对象<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>和所有权关系。</p>
<p>　　若支持这种受限形式的循环引用，具体特性由派生实现定义。</p>
<p><strong>原理</strong></p>
<p>　　没有理由表明通过任意对象支持循环引用是自引用数据结构的唯一实现方式，不论使用自引用数据结构的普遍程度。</p>
<p>　　自引用数据结构可通过在更高的抽象层次上编码，转换为由用户（而不是语言实现）指定明确的外部所有者的形式消除上述所有问题，同时对外部保证同等的功能<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>。</p>
<p>　　使用受限的循环引用同时避免带有所有权的循环引用也是 C 和 C++ 等语言惯用的实现图(graph) 的数据结构的合理方式。</p>
<h3 id="实体类型"><a class="header" href="#实体类型">实体类型</a></h3>
<p>　　NPL 不要求预设具体的实体及对象类型的设计，因此不要求用户使用语言体现整体上的<a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">可扩展性</a>。</p>
<p>　　特别地，NPL 不要求表达式具有预设的不同<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型</a>。</p>
<p><strong>原理</strong></p>
<p>　　放弃对预设类型的要求允许由派生实现指定类型的外延而满足<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>。</p>
<p>　　除不必涉及<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>外，[R<sup>n</sup>RK] 中定义的封装的(encapsulated) 类型的概念及类型<a href="Features/NPL.zh-CN.html#%E5%B0%81%E8%A3%85">封装性</a>（ [R<sup>n</sup>RK] 原则 G4 ）仍然适用，且一般仍然需要满足；差异是派生实现因为扩展不满足的情形也不影响此实现的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E6%A8%A1%E5%9E%8B">一致性</a>（尽管使用扩展的程序可能不可移植）。</p>
<p>　　尽管<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">值类别</a>可抽象为特殊的类型，表达式中的对象的类型和值类别的规则应分别讨论，因为两者正交：两者的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">确定</a>和<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">检查</a>机制都相互独立。</p>
<h2 id="名称规则"><a class="header" href="#名称规则">名称规则</a></h2>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0">名称</a>和能标识特定含义、符合<a href="Features/NPL.zh-CN.html#%E8%AF%8D%E6%B3%95%E8%A7%84%E5%88%99">名称词法约束</a>的表达式一一对应。</p>
<p>　　具体的外延由派生实现定义。</p>
<p>　　表示名称的表达式不同于名称，但在无歧义时，语言中可直接以名称代指表达式和对应的词法元素。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>中对名称的处理应满足本节的要求。</p>
<p><strong>原理</strong></p>
<p>　　名称规则约定通过程序<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源代码</a>确定的静态的语法性质。</p>
<p>　　部分规则中的概念定义和约定仅为便于描述这些性质。和这些约定对应的结构不一定需要在求值算法的实现中出现。</p>
<h3 id="声明区域约定"><a class="header" href="#声明区域约定">声明区域约定</a></h3>
<p>　　对引入名称 <code>n</code> 的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">声明</a> <code>D</code> ，对应的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">声明区域</a>始于紧接 <code>n</code> 的位置，终于满足以下条件的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">记号</a><code>)</code>（若存在）或<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95%E6%A6%82%E5%BF%B5">翻译单元</a>末尾（不存在满足条件的记号 <code>)</code> ）：</p>
<ul>
<li>记号 <code>)</code> 和与之匹配的记号 <code>(</code> 构成的表达式包含 <code>D</code> 。</li>
<li>此记号之前不存在满足上一个条件的其它的记号 <code>)</code> 。</li>
</ul>
<h3 id="可见名称"><a class="header" href="#可见名称">可见名称</a></h3>
<p>　　名称隐藏规则：若<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">声明</a> <code>D</code> 是表达式 <code>E</code> 的子集，且不存在 <code>D</code> 的子集声明同一个名称，则 <code>D</code> 声明了<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">有效名称</a>，隐藏了 <code>E</code> 中其它同名的名称。</p>
<p>　　在<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">声明区域</a>中，没有被隐藏的名称是<em>可见(visible)</em> 的。有效名称实质蕴含可见名称。</p>
<h3 id="名称解析"><a class="header" href="#名称解析">名称解析</a></h3>
<p>　　<em>名称解析(name resoultion)</em> 是通过名称确定名称指定的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">实体</a>的操作。</p>
<p>　　不保证名称解析总是成功。</p>
<p>　　除非另行指定，成功的名称解析没有<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>。</p>
<p>　　除非另行指定，直接作为求值算法步骤的不成功的名称解析<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　一般地，名称解析包括<em>名称验证(name verification)</em> 和<em>名称查找(name lookup)</em> 两个阶段。</p>
<p>　　名称验证确定名称是<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E8%A7%81%E5%90%8D%E7%A7%B0">可见名称</a>，同时可能排除部分无效名称。</p>
<p>　　名称查找进一步确定名称唯一指称的实体的（蕴含确定名称有效），仅在名称验证成功后进行。</p>
<p>　　不同名称经过名称查找的结果可能等效。等效的有效名称视为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一的</a>，规则由派生实现定义。</p>
<p>　　名称解析从保存名称的目标中查找名称。若查找失败，解析可继续从替代的其它目标中进行。这种机制称为<em>重定向(redirection)</em> 。重定向后的解析可继续包含名称验证和名称查找的步骤。</p>
<p>　　以上约定以外的具体规则以及失败的行为由派生实现定义。</p>
<h3 id="命名空间"><a class="header" href="#命名空间">命名空间</a></h3>
<p>　　<em>命名空间(namespace)</em> 是<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">实体</a>。命名空间可以由名称指称。</p>
<p>　　是否实现命名空间为程序中可由用户指定可变的实体及<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">求值环境</a>，由派生实现定义。</p>
<h4 id="命名空间指称"><a class="header" href="#命名空间指称">命名空间指称</a></h4>
<p>　　总是没有名称<em>指称(denotation)</em> 的命名空间是<em>匿名命名空间(anonymous namespace)</em> 。</p>
<p>　　没有有效名称指称的命名空间是<em>未命名命名空间(unnamed namespace)</em> 。</p>
<p>　　NPL 定义一个抽象的匿名命名空间，称为<em>根命名空间(root namespace)</em> 。未命名命名空间的支持由派生实现定义。</p>
<p>　　NPL 约定一个在实现中的有效名称总是指称一个命名空间。有效名称指称的命名空间的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>和<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">有效名称的同一性</a>对应。</p>
<p><strong>注释</strong></p>
<p>　　匿名命名空间和未命名命名空间不同。前者可能是一个系统的默认约定，一般整体唯一存在（如<em>全局(global)</em> 命名空间）；后者只是对某些接口隐藏，可以有多个。</p>
<h4 id="命名空间成员"><a class="header" href="#命名空间成员">命名空间成员</a></h4>
<p>　　除了用于指称的名称外，一个命名空间可以和若干其它名称关联。</p>
<p>　　通过派生实现定义的对命名空间的操作可以取得的名称是这个命名空间的<em>成员(member)</em> 。</p>
<p>　　若无歧义，命名空间的成员指称的实体也称为这个命名空间的成员。</p>
<p>　　命名空间直接包含成员，称为直接成员。</p>
<p>　　除了根命名空间和其它派生实现定义外，命名空间可以作为另一个命名空间的成员，此时命名空间内的成员（若存在）是包含其的命名空间的间接成员。</p>
<p>　　命名空间对成员的直接包含和间接包含总称为包含，是反自反的、反对称的、传递的二元关系。</p>
<h4 id="简单名称和限定名称"><a class="header" href="#简单名称和限定名称">简单名称和限定名称</a></h4>
<p>　　命名空间的直接<a href="Features/NPL.zh-CN.html#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%88%90%E5%91%98">成员</a>的标识符在这个命名空间中是有效名称，称为<em>简单名称(simple name)</em> 。</p>
<p>　　命名空间及其成员按包含关系依次枚举标识符组成的序列是一个名称，称为在这个命名空间中的<em>限定名称(qualified name)</em> 。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%8C%87%E7%A7%B0">根命名空间</a>的限定名称称为<em>全限定名称(fully qualified name)</em> 。</p>
<p>　　限定名称的语法由派生实现定义。</p>
<p><strong>注释</strong></p>
<p>　　限定名称的语法的一个实例是标识符之间作为逻辑上的<a href="Features/NPL.zh-CN.html#%E5%88%86%E9%9A%94%E7%AC%A6">分隔符</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">记号</a>。</p>
<h2 id="规约规则和求值"><a class="header" href="#规约规则和求值">规约规则和求值</a></h2>
<p>　　对象语言的<a href="Features/NPL.zh-CN.html#%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E6%96%B9%E6%B3%95">操作语义</a>可通过作为计算模型的<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E9%87%8D%E5%86%99%E7%B3%BB%E7%BB%9F">项规约系统的规约规则</a>中由规约规则描述的规约<em>步骤(step)</em> 指定。</p>
<p>　　除非派生实现另行指定，规约蕴含 NPL 程序的执行，可完全表示程序执行的语义。</p>
<p>　　推论：NPL 规约规则形式地蕴含 NPL 语义规则。</p>
<p>　　为表达明确的目的，<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>也可约定<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E9%80%89%E6%B1%82%E5%80%BC%E8%A7%84%E5%88%99">其它更抽象形式的求值规则</a>，以蕴含这些规约规则，而不是直接描述规约规则的形式语义。</p>
<p>　　描述 NPL 对象语言的操作语义也可被视为<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">特定的对象语言</a>，其规约可以视为求值。但除非另行指定，以下表达式仅指对象语言的表达式，其求值仅指关于对象语言中表达式的求值，而非一般的规约。</p>
<p>　　规约规则可要求被规约的项符合一定的结构（如具有特定类型的值）作为前提，否则规约出错，程序执行中止。</p>
<p>　　根据规约规则描述的行为是否对应对象语言中的求值，规约分为两类：表达式的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值规约</a>和<a href="Features/NPL.zh-CN.html#%E7%AE%A1%E7%90%86%E8%A7%84%E7%BA%A6">管理规约</a>。</p>
<h3 id="求值规约"><a class="header" href="#求值规约">求值规约</a></h3>
<p>　　一个规约可以描述表达式的求值。直接表达一个表达式求值的规约是一个求值规约。</p>
<p>　　以<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项重写系统</a>描述，求值规约的输入是作为表达式的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>，称为<em>待求值项(evaluating term)</em> 。</p>
<p>　　待求值项经求值规约取得<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>。</p>
<p>　　除非另行指定，求值结果是通过<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值计算</a>取得的值。</p>
<p><strong>原理</strong> 求值结果也可能是<a href="Features/NPL.zh-CN.html#%E5%BC%82%E5%B8%B8">异常</a>退出的等其它作用对应的实体。这些求值结果可能需要派生实现定义的不同规则的处理。</p>
<p>　　以下项称为<em>被规约项(reduced term)</em> ：</p>
<ul>
<li>待求值项。
<ul>
<li><strong>注释</strong> 因为可附加等价<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">空求值</a>的恒等规约，不需要区分项是否已被规约。即使表达式从未被求值，其表示也可视为待求值项。</li>
</ul>
</li>
<li>规约步骤的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">中间表示</a>中完全依赖求值规约的输入的子集的项。</li>
<li>表示<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>的项。</li>
</ul>
<p>　　求值规约规则构成对象语言的<em>求值算法(evaluaton algorithm)</em> 。</p>
<p>　　求值算法的输入是被求值的表达式和支持<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">上下文相关求值</a>中的上下文。</p>
<p>　　求值的基本操作以满足特定规则的<em>替换(substituion)</em> 规则或其组合表示。</p>
<p>　　除非另行指定，以下讨论的排除求值副作用的重写系统具有<a href="Features/NPL.zh-CN.html#%E6%BC%94%E7%BB%8E%E8%A7%84%E5%88%99">汇聚性</a>。</p>
<p>　　这保证求值满足值替换规则：表达式的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值计算</a>通过已知的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">子表达式</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>替换决定。</p>
<p>　　除非派生实现另行指定，子表达式的值仅由求值得到。</p>
<p><strong>注释</strong> 此时<a href="Features/NPL.zh-CN.html#%E9%80%92%E5%BD%92%E8%95%B4%E5%90%AB%E8%A7%84%E5%88%99">递归蕴含规则</a>中的求值依赖规则是这个规则的推论。</p>
<h3 id="管理规约"><a class="header" href="#管理规约">管理规约</a></h3>
<p>　　求值规约以外的规约称为<em>管理(administrative)</em> 规约。</p>
<p>　　管理规约可以是一个不完整的求值规约，或者和求值规约的步骤没有交集。</p>
<p>　　管理规约可使用对象语言不可见和不可直接操作的非<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">一等状态</a>的<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">管理状态</a>。</p>
<p>　　表示非<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>的项的规约总是管理规约。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">抽象求值</a>中不在对象语言<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>中可表达的中间规约是管理规约实现。</p>
<p><strong>注释</strong></p>
<p>　　管理规约描述语言的表达式以外的<a href="Features/NPL.zh-CN.html#%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E6%96%B9%E6%B3%95">操作语义</a>。</p>
<p>　　实现也可使用的管理规约描述特定于实现的（而在对象语言中未指定的）语义性质。</p>
<h3 id="规约顺序"><a class="header" href="#规约顺序">规约顺序</a></h3>
<p>　　<em>先序(sequenced before)</em> 关系是两个规约之间存在的一种<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">严格偏序关系</a>，对实现中规约之间的<em>顺序(order)</em> 提供约束。</p>
<p>　　<em>后序(sequenced after)</em> 是先序的逆关系。</p>
<p>　　<em>非决定性有序(indeterminately sequenced)</em> 是先序或后序的并集。</p>
<p>　　<em>无序(unsequenced)</em> 是非决定性有序在求值二元关系全集上的补集。</p>
<p>　　规约规则的顺序直接适用于求值，其顺序为<em>求值顺序(evaluation order)</em> 。</p>
<p>　　规约规则的顺序也适用在能以其形式描述相对顺序的<em>事件(event)</em> 上。<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">程序</a>中蕴含的这些事件称为<em>规约事件(reduction event)</em> ，包括：</p>
<ul>
<li>求值。</li>
<li>对象的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>的起始或终止。</li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>的<a href="Features/NPL.zh-CN.html#%E4%BD%9C%E7%94%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99">起始</a>和<a href="Features/NPL.zh-CN.html#%E4%BD%9C%E7%94%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99">完成</a>。</li>
<li>不涉及副作用的完成<a href="Features/NPL.zh-CN.html#%E4%BD%9C%E7%94%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99">在求值结束后存在</a>时，某个<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">计算作用</a>的存在。</li>
<li>派生实现定义的其它事件。</li>
</ul>
<p>　　一些事件的顺序是通过推理具有<em>因果性(causality)</em> 的<em>依赖(dependency)</em> 关系决定的，包括：</p>
<ul>
<li>规约中<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值计算</a>依赖规约的输入，即被求值的表达式和其它可能影响规约的状态。</li>
<li>被副作用的起始决定的其它作用依赖这个副作用。</li>
<li>从一个实体上确定作为值的属性的<em>读(read)</em> 依赖这个属性。</li>
<li>在一个实体上可以作为值保留的属性的<em>写(write)</em> 被这个属性依赖。</li>
<li>由派生实现定义的其它情形。</li>
</ul>
<p><strong>注释</strong> 外部<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>作为实体的读取和写入是这里的属性的特例。</p>
<p>　　为了确定相关的值，依赖关系可直接替换为后序关系。</p>
<p>　　由二元关系的一般性质（特别地，偏序关系的传递性），可推导其它一些事件之间的确定顺序，如同一个实体属性上的读依赖（已知的）决定了这个属性的先前的写。</p>
<p>　　作为先序和后序的扩展，规约事件可符合<em>在先发生(happens before)</em> 和<em>在后发生(happens after)</em> 的严格偏序关系，满足：</p>
<ul>
<li>对同一个<a href="Features/NPL.zh-CN.html#%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0">执行线程</a>中的事件，在先发生和在后发生分别同先序和后序。</li>
<li>组合在先发生或在后发生的关系的不存在<em>环(cycle)</em> 。</li>
<li>派生实现定义的其它要求。</li>
</ul>
<p>　　NPL 约定以下非决定性规约规则：除因果性和二元关系的一般性质的推论外，任意项之间的规约之间无序。</p>
<p>　　应用在求值顺序上，有以下推论（非决定性求值规则）：除因果性和二元关系的一般性质的推论外，任意表达式的求值之间无序。</p>
<p><strong>原理</strong></p>
<p>　　在先发生和在后发生可描述系统中的<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">并发的</a>事件。<a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/Time-Clocks-and-the-Ordering-of-Events-in-a-Distributed-System.pdf">原始定义</a>包括对<em>时钟(clock)</em> 的抽象，但此处不要求指定。</p>
<p>　　[ISO C++] 和 [Rust] 等使用类似的方式描述并发的求值的支持。这些设计中，不同执行线程中具有特定的操作定义具体的顺序关系。其中具体规则的设计可能不同而不保证完全一一对应。</p>
<p>　　因<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">可扩展</a>和<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a> NPL 不在此明确指定此类具体操作，而由派生实现定义。</p>
<p>　　及非决定性规约规则允许在语言中表达<a href="Features/NPL.zh-CN.html#%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0">并发实现</a>。</p>
<p><strong>注释</strong></p>
<p>　　读和写作为影响可观察行为的事件结果，具有因果性。此外，也可以抽象为计算作用并由程序操作；这里不做要求。</p>
<h3 id="求值性质"><a class="header" href="#求值性质">求值性质</a></h3>
<p>　　两个具体求值等价，当且仅当两者的作用相等。</p>
<p>　　两个求值等价，当且仅当作为具体求值时等价，或其中每个求值的变换实质蕴含另一个。</p>
<p>　　没有<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>的求值是<em>纯的(pure)</em> 。</p>
<p><strong>注释</strong> 推论：纯求值仅有<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值计算</a>或抽象求值。</p>
<p>　　值为被求值的表达式自身的具体求值或不包含变换为存在不等价求值的表达式的抽象求值为<em>恒等(identity)</em> 求值。</p>
<p>　　恒等的纯求值是<em>空求值(empty evaluation)</em> 。</p>
<p>　　作用是空集的表达式求值是<em>空作用求值(null effect evaluation)</em> 。</p>
<p><strong>注释</strong> 推论：空作用求值是空求值。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E8%AF%AD%E6%B3%95%E5%BD%A2%E5%BC%8F">语法形式</a>固定且求值总是空求值的表达式是<em>空表达式(empty expression)</em> ，这仅由派生实现可选提供。</p>
<h3 id="范式"><a class="header" href="#范式">范式</a></h3>
<p>　　<em>规范化形式(normalized form)</em> ，或简称<em>范式(normal form)</em> ，是由派生实现定义的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>，被一组<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">规约</a>规则确定，满足：</p>
<ul>
<li>通过有限的规约步骤后得到。</li>
<li>按规约规则，规范形式上不存在不<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">和空求值等价</a>的进一步规约。</li>
</ul>
<p>　　在具有 <a href="Features/NPL.zh-CN.html#%E6%BC%94%E7%BB%8E%E8%A7%84%E5%88%99">Church–Rosser 属性的重写系统</a>中，一个对象若具有范式则唯一。</p>
<p>　　表达式在得到规范形式后规约终止，且蕴含求值终止。</p>
<p>　　得到范式的规约步骤称为<em>规范化(normalization)</em> 。</p>
<p>　　若表达式规约总是能得到规范形式（求值总是能在有限规约步骤后终止），则具有<em>强规范化(strong normalization)</em> 性质。</p>
<p>　　实现应避免引起对象语言的语义表达以外的无法保证强规范化性质的操作（如直接无条件的递归规约调用）。</p>
<p>　　除非派生实现另行指定，不保证强规范化性质。</p>
<p>　　保证得到范式的规约是规范化规约。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">具体求值</a>得到的范式若可作为表达式，其<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>是和被求值的项等价的表达式的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>，即仅允许<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">恒等求值</a>而仍是范式；这样的项称为<em>自求值项(self-evaluating term)</em> 。</p>
<p>　　作为表达式的自求值项是<em>自求值表达式(self-evaluating expression)</em> 。</p>
<p>　　重复求值直至取得自求值项的求值结果是<em>最终求值结果(final evaluation result)</em> 。</p>
<p><strong>注释</strong></p>
<p>　　推论：最终求值结果上可能的求值是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>。因此，取得最终求值结果后，即排除具有<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>的继续求值。</p>
<h3 id="规范化中间表示"><a class="header" href="#规范化中间表示">规范化中间表示</a></h3>
<p>　　第一个<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">子表达式</a>（头表达式）是<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">范式</a>的表达式是 HNF（Head Normal Form ，头范式）。</p>
<p>　　头表达式是可直接求值为范式的表达式是 WHNF（Weak HNF，弱头范式）。</p>
<p><strong>注释</strong> 约定求值到 WHNF 提供保证<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">强规范化性质</a>的一般手段，可用于<a href="Features/NPL.zh-CN.html#%E4%B8%A5%E6%A0%BC%E6%80%A7">非严格求值</a>。</p>
<p>　　WHNF 的头表达式是<em>操作符(operator)</em> ，存在对应 HNF 的头表达式的<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">最终求值结果</a>。</p>
<p><strong>注释</strong> 详见<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>。</p>
<p>　　WHNF 中除了操作符以外的子表达式是<em>操作数(operand)</em> 。</p>
<p>　　操作数以具有限定顺序或不限定顺序的数据结构表示。</p>
<p>　　按操作数的数据结构对应有<em>操作数列表(operand list)</em> 和<em>操作数树(operand tree)</em> 。其中操作数树是有限的树形数据结构的 <a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">DAG</a> ，其具体构造和表示由派生实现定义。</p>
<p><strong>注释</strong> 操作数树和 [R<sup>n</sup>RK] 类似。语言可能进一步约定有序的数据结构表示操作数的组成部分之间在求值上不等价。</p>
<p>　　这种能以操作符和操作数的组合表达的计算形式是<em>操作(operation)</em> 。</p>
<p>　　操作的<em>结果(result)</em> 是表达规约步骤得到的范式；操作的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>是取得对应结果的规约步骤的作用。</p>
<p><strong>注释</strong> <a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>中可蕴含操作的结果，也可<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%9D%A1%E4%BB%B6">具有其它作用</a>。若操作的结果存在，则同时是这个合并子的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">调用</a>的结果，即<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>。</p>
<p>　　若操作的结果不依赖<a href="Features/NPL.zh-CN.html#%E7%AE%A1%E7%90%86%E8%A7%84%E7%BA%A6">管理规约</a>，操作的结果和作用即这种可求值为 WHNF 表达式的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>和作用。</p>
<p><strong>注释</strong> 另见<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>。</p>
<p>　　关于 DAG ，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h3 id="组合求值"><a class="header" href="#组合求值">组合求值</a></h3>
<p>　　表达式和<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">子表达式</a>之间的求值需满足一定约束。</p>
<h4 id="递归蕴含规则"><a class="header" href="#递归蕴含规则">递归蕴含规则</a></h4>
<p>　　表达式和子表达式之间的求值满足以下递归蕴含规则：</p>
<ul>
<li>求值依赖规则：除非另行指定，表达式被求值实质蕴含子表达式被求值。</li>
<li>顺序依赖规则：求值子表达式的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值计算</a><a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序</a>所在的表达式的值计算。</li>
<li>平凡求值规则：指定一个表达式是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>或<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">空求值</a>对应实质蕴含其子表达式的求值被指定为纯求值或空求值。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　一般地，一些<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">求值策略</a>可以不遵循求值依赖规则。</p>
<p>　　顺序依赖规则是<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">因果性</a>的具体表现之一。对不被求值的表达式，此规则不生效。构造不同的表达式进行计算可实现和直接违反此规则等效的作用，但因为是不同的表达式，实际上不违反此规则。</p>
<p>　　附加的顺序依赖规则可由特定的实体构成的表达式的求值隐含指定。相同的表达式可能在不同上下文中使用不同的规则。</p>
<h4 id="严格性"><a class="header" href="#严格性">严格性</a></h4>
<p>　　若表达式的任意子表达式的求值总是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">非空求值</a>且<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序</a>表达式求值，则这个表达式的求值是<em>严格的(strict)</em> ；反之，求值是<em>非严格的(non-strict)</em> 。</p>
<p>　　推论：严格求值满足<a href="Features/NPL.zh-CN.html#%E9%80%92%E5%BD%92%E8%95%B4%E5%90%AB%E8%A7%84%E5%88%99">顺序依赖规则</a>。</p>
<p>　　非严格求值在规约时可保留未引起作用（通常即未被求值）的部分子表达式，允许实现根据先序的求值作用确定的选择性求值，即包括未指定是否作为<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">空求值</a>的子表达式求值，如分支判断或短路求值。</p>
<p><strong>注释</strong> 例如：ISO C++ 的条件表达式存在可能未被求值的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>，属于非严格求值；<code>++</code> 表达式不作为<em>完全表达式(full expression)</em> 时，副作用可超出此表达式的求值（不满足顺序依赖规则），也是非严格求值。</p>
<p>　　表达式经过<em>严格性分析(strictness analysis)</em> 确定是否严格求值，通过<em>严格性分析器(strictness analyzer)</em> 在<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">语义分析</a>时实现。</p>
<p>　　<em>中间值(thunk)</em> 是保留不直接实现<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">具体求值</a>的部分子表达式的特定的数据结构。</p>
<p><strong>注释</strong> 例如，通过保留中间值待延迟求值，可实现子表达式值的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按需传递</a>。</p>
<h4 id="顺序求值"><a class="header" href="#顺序求值">顺序求值</a></h4>
<p>　　明确的词法顺序可为同一个表达式的若干子表达式提供一致的有序<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">求值策略</a>：从左到右或从右到左。为一致性，不需要考虑其它特定顺序作为一般规则。</p>
<p>　　递归文法表示的表达式和子表达式之间存在相对内外顺序：子表达式在表达式的内部。此求值顺序可对应表达式树的遍历顺序。</p>
<h4 id="替换策略"><a class="header" href="#替换策略">替换策略</a></h4>
<p>　　对应项的规约规则的表达式的重写规则由派生实现定义，典型的可选项包括：</p>
<ul>
<li>名称替换：保证替换前后项对应的<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0">名称</a>不变。</li>
<li>实体替换：保证替换前后项关联的实体不变。</li>
<li>值替换：保证替换前后项关联的表达式的值满足实现定义的相等关系。这包括以下不同的变体：
<ul>
<li>值副本替换：保证替换前后项关联的表达式的值满足值替换的关系，且以实现定义的方式引用不同的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">实体的副本</a>。</li>
<li><a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>替换：保证替换前后项关联的表达式的值满足值替换的关系，且以实现定义的方式引用同一实体。</li>
</ul>
</li>
</ul>
<h4 id="求值策略"><a class="header" href="#求值策略">求值策略</a></h4>
<p>　　组合严格、顺序求值和替换策略可得到不同性质的求值策略。</p>
<p>　　除非派生实现约定，表达式求值策略可以随具体<a href="Features/NPL.zh-CN.html#%E8%AF%AD%E6%B3%95%E5%BD%A2%E5%BC%8F">语法形式</a>不同而不同。</p>
<p>　　典型性质组合如下：</p>
<ul>
<li>严格求值：
<ul>
<li>应用序(applicative order) ：以<em>最左最内(leftmost innermost)</em> 优先的顺序求值。
<ul>
<li>最左的顺序仅在操作数是<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">有序数据结构</a>时有意义；不考虑操作数内部构造时，仅表示操作数作为子表达式总是被求值，和严格求值等价。</li>
</ul>
</li>
<li>按值传递(pass by value) ：使用值替换的严格求值。
<ul>
<li>按值的副本传递(pass by value copy) ：创建<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">值的副本</a>进行替换的严格求值。</li>
<li>按<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>传递(pass by reference) ：使用引用替换的严格求值。</li>
</ul>
</li>
<li>共享对象传递(pass by shared object) ：使用的共享机制以及对象和值或引用的关系由派生实现定义。</li>
<li>部分求值(partial evaluation) ：允许求值分为多个<em>阶段(phase)</em> 分别进行。</li>
</ul>
</li>
<li>非严格求值：
<ul>
<li>正规序(normal order) ：以<em>最左最外(leftmost outmost)</em> 优先的顺序求值。
<ul>
<li>最左的顺序的意义同应用序。</li>
</ul>
</li>
<li>按名传递(pass by name) ：使用名称替换且保持作为名称的表达式最后被替换的求值。</li>
<li>按需传递(pass by need) ：按名传递但允许合并作用相同的表达式。</li>
</ul>
</li>
<li><a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">非决定性</a>求值：
<ul>
<li>完全归约(full reduction) ：替换不受到作用之间的依赖的限制。</li>
<li>按预期传递(pass by future) ：并发的按名传递，在需要使用参数的值时同步。</li>
<li>乐观求值(optimistic evaluation) ：部分子表达式在未指定时机部分求值的按需求值，若超出约定时限则放弃并回退到按需求值。</li>
</ul>
</li>
</ul>
<h3 id="可选求值规则"><a class="header" href="#可选求值规则">可选求值规则</a></h3>
<p>　　应满足的本节上述约定的最小求值规则和语义外的具体求值的规则和语义由派生实现定义。</p>
<p>　　派生实现的求值可满足以下节指定语义，此时应满足其中约定的规则。</p>
<p>　　若可选求值规则逻辑上蕴含规约规则，则被蕴含的规约规则的直接表述可在语言规则中被省略。</p>
<h3 id="上下文相关求值"><a class="header" href="#上下文相关求值">上下文相关求值</a></h3>
<p>　　在被求值的表达式以外，对应的规约规则在实现此规约的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>中可能是<a href="Features/../Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">上下文</a>相关的，这种附加依赖的上下文为<em>求值上下文(evaluation context)</em> 。</p>
<p>　　求值上下文被作为元语言实现对象求值规则时的输入，可指定项所在的位置等不被被规约的项必然蕴含的附加信息。</p>
<p>　　由派生实现定义的特定求值上下文称为<em>尾上下文(tail context)</em> 。以尾上下文求值可提供附加的保证。</p>
<p>　　作为<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E9%87%8D%E5%86%99%E7%B3%BB%E7%BB%9F">项重写系统的上下文</a>的实例，元语言中，一般的求值上下文 <code>C</code> 形式化为具有占位符 <code>[]</code> 和可选前缀 <code>v</code> 及可选后缀 <code>e</code> 的递归组合的串：</p>
<pre><code class="language-xbnf">C ::= [] | Ce | vC
</code></pre>
<p>　　其中 <code>e</code> 是被求值表达式，<code>v</code> 是作为<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">范式</a>的值。</p>
<p>　　除非另行指定，NPL 对象语言的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>使用的求值上下文总是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">求值环境</a>。</p>
<p><strong>原理</strong></p>
<p>　　通过附加适当的求值规则保证对象语言中的表达式总是可唯一地被分解为这种表示，抽象的求值上下文可直接实现对象语言的求值。但语义描述和实现的基准都以<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机</a>替代，因为：</p>
<ul>
<li>抽象机语义允许不依赖<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源程序</a>的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>和构造（如特定的表达式的文法）。</li>
<li>这种分解一般要求遍历对象语言的源程序而难以具有较好的可实现性质，如<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算复杂度</a>。</li>
<li>为满足良好的可实现性质，需描述实现中可能具有的离散状态与只和其中个别状态关联的局部的求值规则时，这种分解通常会渐进演化为某种抽象机的表示。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　使用求值环境作为默认的上下文确保一般的求值总是能支持变量的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">绑定</a>。</p>
<p>　　对象语言的实现同时能够支持其它上下文，即使它不在求值算法中出现。这样的上下文可能被求值上下文蕴含而可被推理确定。</p>
<h2 id="λ-完备语义和对应语法"><a class="header" href="#λ-完备语义和对应语法">λ 完备语义和对应语法</a></h2>
<p>　　作为通用语言，求值规则表达的系统可具有和<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9E%8B">无类型 λ 演算</a>对应的形式和计算能力。</p>
<p>　　基于此语义的派生实现应允许以下几种互不相交的表达式集合：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">名称表达式</a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">匿名函数</a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数应用</a></li>
</ul>
<p>　　NPL 不要求以上表达式中函数以外的表达式求值的<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">强规范化</a>。</p>
<p><strong>注释</strong></p>
<p>　　无类型 λ 演算保证名称表达式（变量）和函数（ λ 抽象）的规约的强规范化，但不保证函数应用规约的强规范化。</p>
<p>　　扩展的 λ 演算（如<a href="https://zh.wikipedia.org/zh-cn/%E7%AE%80%E5%8D%95%E7%B1%BB%E5%9E%8B%CE%BB%E6%BC%94%E7%AE%97">简单类型 λ 演算</a>）可保证规约函数应用的强规范化。</p>
<h3 id="名称表达式"><a class="header" href="#名称表达式">名称表达式</a></h3>
<p>　　<em>名称表达式(name expression)</em> 是表示变量的 λ 项。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%8E%9F%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F">原子表达式</a>的由派生实现定义的非空子集是名称表达式。其它作为名称表达式的表达式<a href="Features/NPL.zh-CN.html#%E8%AF%AD%E6%B3%95%E5%BD%A2%E5%BC%8F">语法形式</a>由派生实现定义。</p>
<p>　　名称表达式不被进一步规约；其求值是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">值替换规则</a>的平凡形式。</p>
<h3 id="函数"><a class="header" href="#函数">函数</a></h3>
<p>　　<em>函数(function)</em> 是一种参与特定规约规则的实体，也可以指求值为函数实体的表达式。</p>
<p>　　一般地，函数表达式在 <a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">WHNF</a> 下作为<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作符</a>被求值，其<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">最终求值结果</a>为函数实体，或函数对象（若函数在语言中允许作为对象）。</p>
<p>　　NPL 中，作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>的函数表达式的最终求值结果是<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>。</p>
<p>　　一个函数表达式是以下两种表达式之一：</p>
<ul>
<li>保持<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">等价地</a>求值到其它函数表达式上的<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">名称表达式</a>，称为<em>具名函数表达式(named function expression)</em> ，简称<em>具名函数(named function)</em> 。</li>
<li>满足本节以下规则的由派生实现定义的<em>匿名函数表达式(anonymous function expression)</em> ，简称<em>匿名函数(anonymous function)</em> 。</li>
</ul>
<p>　　函数应确定替换重写规则<a href="Features/NPL.zh-CN.html#%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5">被替换的目标</a>，即<em>函数体(function body)</em> 。</p>
<p>　　除非派生实现另行指定，函数不需要被进一步规约，此时其求值是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">值替换规则</a>的平凡形式。</p>
<p>　　在<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">类型系统</a>中，函数可被指派<em>函数类型(function type)</em> 。函数类型能蕴含<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">参数</a>和结果的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型</a>。</p>
<p><strong>注释</strong> 例如，在简单类型 λ 演算中，函数类型是<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型构造器</a> <code>→</code> 组合输入（参数）和结果（输出）类型的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">复合类型</a>。</p>
<h4 id="函数内部的变量"><a class="header" href="#函数内部的变量">函数内部的变量</a></h4>
<p>　　匿名函数可以显式指定（<em>绑定(bind)</em> ）包含若干变量使之成为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">约束变量</a>的语法构造。</p>
<p>　　通过创建函数时的显式的语法构造引入的这种变量称为函数的<em>形式参数(formal parameter, parameter)</em> 。</p>
<p>　　除绑定外，匿名函数蕴含<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E9%87%8D%E5%86%99%E7%B3%BB%E7%BB%9F">上下文</a>可以<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E9%87%8D%E5%86%99%E7%B3%BB%E7%BB%9F">捕获</a>若干在函数体以外的同名的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">自由变量</a>。</p>
<p>　　通过绑定或捕获引入的变量允许在函数体中允许使用。</p>
<p>　　使用<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83%E6%8F%90%E4%BE%9B%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">词法作用域</a>时，若匿名函数所在<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用域</a>的存在同名的<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0">名称</a>，则被捕获的名称被<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">隐藏</a>。形式参数隐藏被捕获的<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">变量名</a>。</p>
<p>　　派生实现的语义规则应满足和 λ 演算的语义的 α-转换(alpha-conversion) 规则不矛盾。</p>
<p><strong>注释</strong> <a href="Features/NPL.zh-CN.html#vau-%E6%8A%BD%E8%B1%A1">Vau 演算</a>在没有限定<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">环境</a>时不考虑一般意义上的自由变量。</p>
<p>　　函数应用的求值决定被绑定的变量和函数体内的变量之间的关系，参见<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>。此时，<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">求值策略</a>蕴含的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">替换策略</a>蕴含被绑定的变量和函数体内的变量之间的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>。</p>
<p>　　类似地，在被捕获的变量到函数体内捕获的变量之间，也有和替换策略一一对应的不同捕获策略。</p>
<p>　　除非另行指定，变量被<em>按引用捕获(captured by reference)</em> 而非<em>按值的副本捕获(captured by value copy)</em> ，即通过捕获引入的变量是被捕获变量的引用而不是副本。</p>
<p><strong>原理</strong></p>
<p>　　捕获为引用而不是副本，保持被捕获的变量和函数体内同名变量的同一性，在实体是对象时不影响可观察行为。若这些捕获未被使用，可被实现直接移除。</p>
<h4 id="过程"><a class="header" href="#过程">过程</a></h4>
<p>　　<em>过程(procedure)</em> 是操作符<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">具现</a>的<em>可调用(callable)</em> 的实体，决定特定的可提供求值的作用（包括决定求值结果）的<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算</a>。</p>
<p>　　函数表达式的<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">最终求值结果</a>由过程实体的作用中的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">结果</a>决定，以派生实现定义的方式关联。</p>
<p>　　通过函数表达式可指定可选的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">实际参数</a>，发生过程<em>调用(call)</em> 。过程的调用蕴含计算。</p>
<p>　　过程中和过程外的计算的组合满足<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">因果性</a>：</p>
<ul>
<li>以求值描述的过程中的作用整体非<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">后序</a>于引起过程中作用的外部环境的计算。</li>
<li>以求值描述的过程中的任意作用非后序于取得对应结果的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值计算</a>，即结果是决定值的作用的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">依赖</a>。</li>
</ul>
<p>　　<em>主调函数(caller function)</em> 等<em>调用者(caller)</em> 或其它引起过程中的计算的实体<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">转移</a>计算蕴含的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制</a>到过程中的计算而使之<em>进入(enter)</em> 到<em>被调用者(callee)</em> 的过程。</p>
<p>　　过程可能被限制只有<em>一次(one-shot)</em> 调用有效；其它过程是<em>多次(multi-shot)</em> 的。</p>
<p>　　多次过程调用时控制可能通过调用被再次转移，即<em>嵌套调用(nested call)</em> 。</p>
<p>　　一些被多次调用的过程可能被多次进入，即<em>重入(reenter)</em> 。</p>
<p>　　一个调用中的重入相同或不同过程的次数称为调用的<em>深度(depth)</em> 。</p>
<p>　　推论：嵌套调用是深度大于 1 的调用。</p>
<p>　　通过嵌套调用直接（总是以自身作为调用者）或间接（通过其它调用者转移控制）的重入是<em>递归调用(recursive call)</em> 。</p>
<p>　　过程可以<em>返回(return)</em> 取得计算的值并可同时改变<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制状态</a>，影响之后的计算。</p>
<p><strong>原理</strong></p>
<p>　　一次过程，特别是在其内部涉及和<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">续延</a>或<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83%E6%8F%90%E4%BE%9B%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">闭包</a>的实现交互时，相对多次过程可能具有因其对持有资源的要求较宽松，而具有较小的性能开销。</p>
<p><strong>注释</strong></p>
<p>　　对象语言中的过程在描述操作语义的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>中可表示为函数，其应用可对应对象语言中过程的隐式调用。</p>
<p>　　违反一次过程调用有效地约束的程序典型地<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　注意过程不一定可作为可被对象语言直接表达的<em>一等(first-class)</em> 函数，但同时在元语言中仍然可能可行。如<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">无界续延</a>，因为可能不符合<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数的类型要求</a>，详见<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延的捕获和调用</a>中的原理。</p>
<p>　　一次重入的过程调用分配的资源对应一个<a href="Features/NPL.zh-CN.html#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">活动记录帧</a>。</p>
<h4 id="过程调用的计算顺序"><a class="header" href="#过程调用的计算顺序">过程调用的计算顺序</a></h4>
<p>　　按计算的顺序约束和默认返回控制的方式，可能有不同的形式。</p>
<p>　　<em>例程(routine)</em> 的求值不<em>交叉(interleave)</em> ，即例程中的计算和例程外的计算<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">非决定性有序</a>。</p>
<p><strong>注释</strong> 典型地，例程中的计算通过例程作为函数实体创建时的函数体确定。</p>
<p>　　作为不同的例程，不考虑例程中的计算的<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">续延</a>被保存时：</p>
<ul>
<li><em>子例程(subroutine)</em> 在返回一次后不<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">重入</a>。</li>
<li><em>协程(coroutine)</em> 则可能被多次重入并引起多次返回。</li>
</ul>
<p>　　和子例程的<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%9D%A1%E4%BB%B6">正常控制</a>不同，即便其中的计算不涉及显式地改变控制状态，协程可能蕴含控制从协程中的计算到协程外的计算的<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">转移</a>：</p>
<ul>
<li>引起多次返回对应改变<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制作用</a>。</li>
<li>转移控制后，函数体中的计算被<em>暂停(suspended)</em> 。</li>
<li>重入的协程可<em>恢复(resume)</em> 被暂停的计算。
<ul>
<li>不排除可被重入的协程作为函数实体，是<em>可恢复函数(resumable function)</em> 。</li>
</ul>
</li>
<li>可被暂停和恢复的计算是<em>异步的(asynchrnous)</em> 。这和正常控制的<em>同步的(synchronous)</em> 的计算相对。</li>
</ul>
<p>　　一般的续延支持返回多次并可能支持和调用者并发的计算，包括异步的计算；而协程蕴含的控制作用的改变对应不同续延的替换，也能实现类似的支持。</p>
<p>　　语言的语法可显式指定例程创建协程，也可以当前的控制状态创建和现有的例程没有直接对应的协程。后者类似<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延捕获</a>。</p>
<p>　　NPL 支持函数求值得到过程。对象语言中的过程可能支持使用这些形式的一种或多种，具体形式由派生实现指定。</p>
<p>　　协程可能限制转移向下一步骤的计算转移的方向，即调用者和被调用者被通过创建其的语法构造确定，而不能在之后改变。</p>
<p>　　根据是否只提供一种不区分转移方向的原语，协程分为<em>对称(symmetric)</em> 和<em>非对称(asymmetric)</em> 协程：</p>
<ul>
<li>对称协程转移控制到另一个协程，不需要单独区分不同的操作。
<ul>
<li>转移控制的源和目标之间没有<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">调用者</a>和<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">被调用者</a>的相对关系。</li>
</ul>
</li>
<li>非对称协程对控制的转移分为<em>调用(invoke)</em> 和<em>出让(yield)</em> 操作，其中：
<ul>
<li>调用操作从调用者转移控制到被调用者，恢复之前保存的上下文（若有）或创建时的初始上下文。</li>
<li>出让操作暂停和保存当前上下文并返回（转移）控制到它的调用者。
<ul>
<li>一般地，转移控制的具体时机未指定，可蕴含（对应续延的）<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">调度</a>和<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">并发</a>执行。</li>
</ul>
</li>
</ul>
</li>
<li>一些协程称为<em>半(semi)</em> 异步协程（半协程），以体现实现异步计算的控制转移形势受限的非典型性。对应地，没有此类限制的协程被称为<em>全(full)</em> 异步协程（全协程）。
<ul>
<li>通常半协程指对控制的转移（相对传统的例程调用）受限，不能仅通过调用而需要单独的出让操作实现计算的暂停。这是非对称协程的同义词。</li>
<li>但半协程也可能指特指暂停在特定上下文受限的协程实现。</li>
<li><strong>注释</strong> 另见<a href="http://www.lua.org/pil/9.1.html">这里</a>的说明。</li>
</ul>
</li>
</ul>
<p>　　根据是否协程持有<a href="Features/NPL.zh-CN.html#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">活动记录帧</a>，协程分为<em>有栈(stackful)</em> 和<em>无栈(stackless)</em> 的。</p>
<ul>
<li>两者提供不同的资源<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权</a>，而可能影响使用这些特性的程序中的资源的<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>。</li>
<li>特别地，无栈协程不保证活动记录的可用性，无法直接支持创建的协程作为一等对象使用。</li>
</ul>
<p>　　因为具有类似的改变控制的能力，有栈的、可作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>的<em>全协程(full coroutine)</em> 可替代<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">一等续延</a>。</p>
<p><strong>原理</strong></p>
<p>　　协程可视为是在计算上<a href="Features/NPL.zh-CN.html#%E5%AE%8C%E6%95%B4%E6%80%A7">可表达性</a>等价的<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">一次续延</a>：</p>
<ul>
<li>参见<a href="http://www.cs.tufts.edu/comp/250RTS/archive/roberto-ierusalimschy/revisiting-coroutines.pdf">这里</a>。</li>
<li>其中，对称协程类似一次<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">无界续延</a>，非对称协程类似一次<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">有界续延</a>。
<ul>
<li>对称协程可通过非对称协程补充操作实现。
<ul>
<li><strong>注释</strong> 一个这种设计的例子参见 <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0913r0.html">[WG21 P0913R0]</a> 。</li>
</ul>
</li>
<li>类似地，有界续延可<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">通过添加显式的界限实现无界续延</a>。</li>
<li>但是，这种功能相似不表示一一对应。
<ul>
<li><strong>注释</strong> 参见以下关于出让操作使用续延实现的讨论。</li>
</ul>
</li>
</ul>
</li>
<li>在核心语言支持<em>存储(store)</em> 即<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">可修改</a>的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">一等状态</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>的前提下，非对称协程和对称协程在可表达性上等价。
<ul>
<li>有界续延可不依赖其它副作用表达状态，但<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">无界续延无法表达</a>。</li>
</ul>
</li>
<li>一等续延和协程在一定条件下可互相实现。
<ul>
<li>对称协程可实现一次续延。
<ul>
<li><strong>注释</strong> 另见<a href="http://www.inf.puc-rio.br/~roberto/docs/MCC15-04.pdf">这里</a>，但这个实现没有检查续延调用内部可能的非预期重入，且不满足 [Hi90] 中的 <a href="Features/NPL.zh-CN.html#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C-ptc">PTC 要求</a>。</li>
<li>因此，作为一等对象时，协程可作为一等续延的替代实现方式。</li>
</ul>
</li>
<li>非对称协程的出让操作可通过无界续延实现。
<ul>
<li>虽然可实现出让操作的<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延捕获</a>并非<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延调用</a>，但续延调用对控制的转移不必然蕴含区分调用和调用者。
<ul>
<li>事实上，使用 <code>call/cc</code> 捕获续延创建的是无界续延。</li>
</ul>
</li>
<li>有界续延可实现无界续延，因此出让操作也可使用有界续延实现。</li>
<li><strong>注释</strong> 另见<a href="https://cs.indiana.edu/~sabry/papers/yield.pdf">这里</a>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　典型的设计中，函数表达式默认创建例程，而协程使用特设的语法标记过程得到。特设的关键字（如 <code>yield</code> ）提供语法，对应非对称协程中的出让操作。</p>
<p><strong>注释</strong></p>
<p>　　关于过程的参数和过程调用之间的计算顺序，参见<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">求值策略</a>。</p>
<h4 id="λ-抽象"><a class="header" href="#λ-抽象">λ 抽象</a></h4>
<p>　　λ 抽象(lambda abstraction) 是 λ 演算中的基本构成之一，提供匿名函数。</p>
<p><strong>注释</strong> λ 抽象的语法包含的形式是典型的操作符。</p>
<p>　　在原始的无类型 λ 演算中，λ 抽象<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">不支持蕴含副作用</a>，子表达式求值顺序任取而不改变<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">范式</a>的存在性和值。</p>
<p>　　在使用<a href="Features/NPL.zh-CN.html#%CE%BB-%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">热情求值</a>的语言中，λ 抽象创建的过程是应用<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>。</p>
<h4 id="vau-抽象"><a class="header" href="#vau-抽象">vau 抽象</a></h4>
<p>　　Vau 抽象(vau abstraction) 是 vau 演算 ([Shu10]) 中的基本构成之一。</p>
<p>　　Vau 抽象创建的过程是操作<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>。</p>
<p><strong>注释</strong> 使用 vau 抽象可实现引入 λ 抽象的操作符，如 [R<sup>n</sup>RK] 提供的 <code>$vau</code> 操作合并子。</p>
<h3 id="函数合并"><a class="header" href="#函数合并">函数合并</a></h3>
<p>　　具有操作符和操作数的项的组合可被特定的方式进行规约。这种组合是<em>函数合并(function combination)</em> ，包含：</p>
<ul>
<li>具有至少一个约定位置的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">子项</a> <code>E1</code> 的<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F">复合表达式</a> <code>E</code> ，当且仅当 <code>E1</code> 是被求值作为<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作符</a>的函数时，<code>E</code> 是<em>函数合并表达式(function combination expression)</em> 。</li>
<li>其它具有操作符和操作数的项是非表达式形式的函数合并。以下操作符和操作数记作 <code>E1</code> 和 <code>E2</code> 。</li>
</ul>
<p>　　以下规则中，非表达式形式的函数合并也可被视为表达式求值。</p>
<p>　　求值函数合并时，子项 <code>E1</code> 总是被求值。</p>
<p>　　除 <code>E1</code> 外表达式的剩余子项 <code>E2</code> 是<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>，在 E 被求值时以操作数决定的值等效<em>替换(substitute)</em> 函数的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">形式参数</a>。</p>
<p>　　替换形式参数的值是<em>实际参数(actual argument, argument)</em> 。</p>
<p>　　函数合并的求值是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">值替换规则</a>的非平凡形式。</p>
<p>　　若替换操作数 <code>E2</code> 在合并中被求值，函数合并 E 是函数应用表达式，简称<em>函数应用(function application)</em> 。</p>
<p>　　若操作符是 λ 抽象，<code>E2</code> 视为一个整体，则函数应用替换规则对应 λ 演算的 β-规约(beta-reduction) 规则。</p>
<p>　　其它函数合并使用的替换规则由派生实现指定。</p>
<p>　　派生实现应指定函数合并<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">规约</a>的结果是<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">规范形式</a>，它对应的值是函数合并的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>替换被求值的表达式的实体，称为<em>函数值(function value)</em> 。</p>
<p>　　函数应用匹配实际参数和对应的引入形式参数的构造。匹配可能失败。确定匹配参数成功的条件是等价关系，称为参数匹配一致性，由参数匹配的等价关系指定。</p>
<p>　　匹配成功的每个实际参数和被匹配的目标（可能是形式参数）具有一对一或多对一的对应关系。</p>
<p>　　伴随参数匹配，实现可引入其它必要的操作（如为匹配分配资源和确定上述对应关系）。这些操作可具有和确定参数对应关系的匹配之间<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">非决定性有序</a>的副作用。</p>
<p>　　仅当上述必要操作及所有实际参数的匹配成功，替换 <code>E1</code> 决定的某个关联表达式中和形式参数结构一致的子表达式为实际参数。替换参数的结构一致性是等价关系。</p>
<p>　　表达式相等蕴含参数匹配一致性和替换结构一致性。实现可分别定义其它规则扩充这些等价关系的外延。</p>
<p>　　替换参数的值蕴含对实际参数的计算的依赖，即参数若被求值，其<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值计算</a><a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序</a>函数应用的求值；但其它求值顺序没有保证。</p>
<p><strong>注释</strong></p>
<p>　　一般地，根据 <code>E1</code> 的值，操作数或操作数的值计算的结果被作为实际参数。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">过程</a>及其调用在其操作语义的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>中通常表达为函数及函数合并。</p>
<p>　　若过程的结果被忽略，则通常表达为<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">单元类型</a>的值。</p>
<p>　　此外，一些语言中忽略过程的结果是<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">空类型</a>，以检查错误的使用。NPL 不要求语言具有<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态类型</a>规则，也不要求这些检查。</p>
<h4 id="函数调用"><a class="header" href="#函数调用">函数调用</a></h4>
<p>　　求值函数合并包含子表达式的求值：总是求值操作符，并可能求值操作数。若这些求值都没有退出，则发生函数<em>调用(call)</em> ，函数是<em>被调函数(called function)</em> 。</p>
<p>　　若被调函数存在形式参数，函数调用首先以操作数的直接子表达式作为实际参数，匹配实际参数和形式参数。</p>
<p>　　若实际参数匹配的目标可指定一个变量，则伴随参数匹配的操作包括以特定规则<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">绑定</a>的形式参数。</p>
<p>　　绑定的实际参数和对应的形式参数作为不同的实体时，作为伴随参数匹配的必要操作的一部分，发生<em>参数传递(parameter passing)</em> 。参数传递使形式参数具有作为实际参数值的副本。参数传递可能使和实际参数相关的资源被复制或转移。</p>
<p>　　实现在函数合并的求值中应提供函数调用的支持。</p>
<p>　　函数调用确定副作用的边界：保证参数表达式在函数应用被求值之前被求值。</p>
<p>　　在控制<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">返回</a>时，函数调用内部确定的值最终替换被求值的函数合并而作为函数值，即为<em>返回值(return value)</em> 。</p>
<p>　　若函数是<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">过程</a>，对应的函数调用是<em>过程调用(procedure call)</em> 。</p>
<p>　　若一个函数的调用仍待返回，则该函数调用是<em>活动的(active)</em> 。</p>
<p>　　调用总是不蕴含非<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>的函数是<em>纯函数(pure function)</em> 。</p>
<p>　　函数调用的中蕴含的求值对应的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E8%A7%84%E5%88%99%E5%92%8C%E6%B1%82%E5%80%BC">规约步骤</a>的集合是它的<em>动态范围(dynamic extent)</em> 。</p>
<p>　　函数中被<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">捕获</a>的实体的引用和求值函数中的计算创建的对象的引用构成函数计算的结果时，引用可能<em>逃逸(escape)</em> ，即在调用的动态范围以外可访问。</p>
<p>　　派生实现可能约定附加的名义特征区分其它情形相同的调用，称为<em>调用约定(calling convention)</em> 。</p>
<p><strong>注释</strong></p>
<p>　　典型实现的函数指称过程，函数调用是过程调用。</p>
<p>　　一般地，被调用的函数及函数调用的作用的等价性通常不能被确定。</p>
<p>　　一个重要的子类是<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">不能确定具体表示</a>的情形，参见<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>。其它函数一般也有类似限制。</p>
<p>　　关于函数调用中的求值，另见函数调用的<a href="Features/NPL.zh-CN.html#%E7%BB%88%E6%AD%A2%E4%BF%9D%E8%AF%81">终止保证</a>。</p>
<p>　　和 [R<sup>n</sup>RS] 不同，动态范围仅对求值定义，而不是关于环境中的绑定显示<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">计算作用</a>的属性。这种属性事实上对象的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>，仅对对象而非更一般的实体有效。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">续延</a>可用其动态范围表示。</p>
<p>　　本文档的动态范围的概念定义和 [R<sup>n</sup>RK] §7.1 的定义兼容，但不依赖其对续延的描述，也适用<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机语义</a>，是 [R<sup>n</sup>RK] 的一般化。</p>
<p>　　[Racket] 使用求值的规约步骤在表达式上定义动态范围。NPL 不在表达式上采用类似的定义，因为：</p>
<ul>
<li>类似 [R<sup>n</sup>RK] ，NPL 强调支持对象语言中的<a href="Features/NPL.zh-CN.html#%E5%85%B6%E5%AE%83%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8F%82%E8%80%83">显式求值风格</a>及表达式求值前后的不同。</li>
<li>类似 [R<sup>n</sup>RK] ，进一步地，NPL 派生语言（如 NPLA1 ）可明确支持在对象语言中指定<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">求值环境</a>而改变求值的上下文，表达式不能被预期通常以<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">上下文</a>无关的方式被求值。</li>
</ul>
<p>　　调用约定可提升实现细节，为<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>提供接口保证，避免非预期的不兼容实现的混合。</p>
<h4 id="合并子"><a class="header" href="#合并子">合并子</a></h4>
<p>　　除非另行指定，NPL 假定函数合并满足以下典型情形，即函数合并的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作符</a>求值为以下类型的<em>合并子(combiner)</em> 之一：</p>
<ul>
<li>对操作数的直接<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作</a>（而不要求对操作数求值）的合并子是<em>操作合并子(operative combiner)</em> ，简称<em>操作子(operative)</em> 。</li>
<li>进行函数应用的合并子是<em>应用合并子(applicative combiner)</em> ，简称<em>应用子(applicative)</em> 。</li>
<li>由派生实现定义的<em>扩展合并子(extended combiner)</em> 。</li>
</ul>
<p>　　合并子的函数应用（依赖对操作数进行至少一次求值）是<em>合并子应用(combiner application)</em> 。</p>
<p>　　合并子应用使用<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">应用序</a>。</p>
<p>　　应用子总是对应一个<em>底层(underlying)</em> 合并子，可通过底层合并子上的一元的<em>包装(wrap)</em> 操作得到；其逆操作为<em>解包装(unwrap)</em> 。</p>
<p>　　解包装结果不是扩展合并子的合并子称为<em>真合并子(proper combiner)</em> 。</p>
<p>　　合并子上可以定义若干等价关系，这些等价关系蕴含关于函数应用替换的基本形式：</p>
<p>　　若对任意上下文，替换一个应用中的合并子为另一个不改变函数应用替换的结果，则这两个合并子等价（对应 λ 演算的 β-等价）。</p>
<p><strong>注释</strong></p>
<p>　　合并子被<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">调用</a>时通常<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">返回</a>且仅返回一次。</p>
<p><strong>注释</strong> 详见<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延的捕获和调用</a>。</p>
<p>　　由于程序可能引入未知具体表示的合并子（如从其它模块链接），以上等价可能无法判定，不要求实现提供。</p>
<p>　　因为本设计不依赖 λ 抽象的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">内部表示</a>（特别是支持<a href="Features/NPL.zh-CN.html#%CE%BB-%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">惰性求值</a>为目的的），不依赖 η-变换的<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>，也不要求支持更强的 βη-等价。</p>
<p>　　派生实现可按需定义较弱的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">等价谓词</a>，保证其判定结果蕴含上述等价关系的结果。</p>
<h4 id="续延的捕获和调用"><a class="header" href="#续延的捕获和调用">续延的捕获和调用</a></h4>
<p>　　语言可提供作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等实体</a>的<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">续延</a>即<em>一等续延(first-class continuation)</em> 。</p>
<p>　　续延的<em>捕获(capture)</em> <a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">具现</a><a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">当前续延</a>为对象语言中可操作的一等续延。</p>
<p>　　类似<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">过程</a>，续延可被<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">一次或多次调用</a>，称为<em>续延调用(continuation call)</em> 。</p>
<p>　　续延调用接受一个<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">实际参数</a>作为传递给后继<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E8%A7%84%E5%88%99%E5%92%8C%E6%B1%82%E5%80%BC">规约步骤</a>使用的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>。除非另行指定，续延参数被<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值传递</a>。被调用的续延可<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>参数并执行其蕴含的其余规约步骤。</p>
<p>　　和接受实际参数对应，续延可被假定关联一个等效的<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">应用子</a>，具有一个<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">形式参数</a>，这个应用子的<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">底层合并子</a>被<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">调用</a>时<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%9D%A1%E4%BB%B6">非正常地</a>传递它的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>给关联的续延。</p>
<p>　　对象语言可支持符合<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数类型要求</a>的一等续延作为函数。作为一等续延的函数可直接作为<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>构成<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>进行<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>，而实现续延调用。</p>
<p>　　除非派生实现另行指定，NPL 的一等续延不是函数。</p>
<p>　　函数应用（如<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">合并子调用</a>）可隐含（<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>的）续延调用。</p>
<p>　　续延调用的其它的具体形式由派生实现定义。</p>
<p>　　除非在捕获的续延上存在特定的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制作用</a>，合并子被调用时以当前续延<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回</a>且仅返回一次。</p>
<p>　　类似<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数应用表达式</a>，<em>续延应用(continuation application)</em> 表达式是求值时蕴含<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延调用</a>的表达式。</p>
<p><strong>原理</strong></p>
<p>　　在 Scheme 中，一等续延即过程。</p>
<p>　　在限制<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>的函数不蕴含控制作用时，类似 Scheme 等支持的无界<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">续延</a>不是函数。一个理由不能以常规方式为无界续延指定是函数<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型</a>。参见<a href="https://okmij.org/ftp/continuations/undelimited.html#introduction">这里</a>的介绍。</p>
<p>　　在 Kernel 和其它一些语言中，续延不是过程，而具有不同的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义类型</a>。这种不同于 Scheme 的设计是有意的。</p>
<p>　　NPL 一等续延不限制是否和函数类型同一，因此无界续延仍可被视为函数（或更确切地，即程序入口作为边界的有界续延）。</p>
<p>　　类似 [R<sup>n</sup>RK] 的设计，因为一等续延的调用可引起和更常见的过程调用显著不同的控制作用，续延调用有必要和过程调用在对象语言的语法上显式区分以满足<a href="Features/NPL.zh-CN.html#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测性</a>，因此一等续延一般不是函数。</p>
<p>　　续延关联的等效应用子的原理同 [R<sup>n</sup>RK] §7 和 §7.2.5（应用子 <code>continuation-&gt;applicative</code>）的原理，但略有不同：</p>
<ul>
<li>作为一等对象的续延和续延的实际参数是否求值无关，因此不是合并子，<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>不需要支持续延作为函数合并被求值；但续延可通过特定的操作转换为应用子。</li>
<li>续延和操作子在被调用时都接受一个实际参数对象。
<ul>
<li>对前者，对象典型地表示计算的结果，即已被求值。</li>
<li>对后者，对象是操作数。典型地，操作子作为应用子的底层合并子，操作数已被作为应用子的实际参数被求值算法求值。</li>
<li>类似 [R<sup>n</sup>RK] 而和 [R<sup>n</sup>RS] 不同，因为<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>可接受<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">非真列表</a>作为参数，非列表的操作数可以和非列表的续延实际参数直接对应。
<ul>
<li>因为函数合并的这种性质，续延关联的应用子的应用和续延应用存在直接的一一对应关系。</li>
</ul>
</li>
</ul>
</li>
<li>但是，为避免和<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>冲突，[R<sup>n</sup>RK] 的<em>选择器(selector)</em> 支持在此未被要求。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　类似过程，续延及其调用在其操作语义的元语言中能表示为元语言的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数应用</a>，通常表达为<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数</a>及<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>。</p>
<p>　　续延捕获在语法上类似函数对变量的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">捕获</a>。被捕获的实体通常以引用保存。被捕获的实体通常是隐式的，即不在对象语言程序中出现。</p>
<p>　　在支持一等续延且捕获的续延可被复制的语言中，实现需要考虑活动记录的复制，参见 [Hi90] 。</p>
<p>　　关于控制作用，另见续延调用<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%9D%A1%E4%BB%B6">对程序控制的改变</a>。</p>
<h4 id="活动记录"><a class="header" href="#活动记录">活动记录</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">活动的</a>合并子分配的对象称为<em>活动记录(activation record)</em> 。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>以活动记录引用涉及的变量。每个调用的活动记录中可保存多个变量。活动记录可能因此持有状态，即便不一定可被函数调用外的操作直接修改。</p>
<p>　　嵌套的函数调用具有多次分配的活动记录。为强调其中的对应关系，每一个调用关联其中的一个<em>帧(frame)</em> 。</p>
<p>　　在确定一次分配的一个活动记录对应一次函数调用的实现中，一个活动记录和一个活动记录的帧同义。</p>
<p>　　活动记录的集合可能构成特定的数据结构。例如限制只支持嵌套的子例程调用（而不支持一般的<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延调用</a>）时，具有后入先出(LIFO, last-in-first-out) 的栈的结构。</p>
<h3 id="λ-求值策略"><a class="header" href="#λ-求值策略">λ 求值策略</a></h3>
<p>　　在<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">变量</a>绑定值后，兼容 λ 演算规约语义（特别地，β-规约）的表达式的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">具体求值</a>根据是否传递操作数对使用<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按需传递</a>的情形分为三类：</p>
<ul>
<li>（完全）<em>惰性求值(lazy evaluation)</em></li>
<li>部分惰性求值</li>
<li><em>热情求值(eager evaluation)</em></li>
</ul>
<p>　　其中，惰性求值总是使用按需传递，热情求值总是不使用按需传递，部分惰性求值不总是使用或不适用按需传递。</p>
<p>　　在保证不存在非<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>时这些求值的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">计算作用</a>没有实质差异。存在非纯求值时，使用的 λ 求值策略由派生实现定义。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E4%B8%A5%E6%A0%BC%E6%80%A7">非严格求值</a>严格蕴含惰性求值。两者经常但不总是一致，例如，实现可能<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">并行地</a>热情求值，并舍弃部分结果以实现非严格求值。</p>
<p>　　热情求值蕴含<a href="Features/NPL.zh-CN.html#%E4%B8%A5%E6%A0%BC%E6%80%A7">严格求值</a>。两者也经常但不总是一致，例如，实现可能使用应用序严格求值。但因为非严格的热情求值缺乏性能等可局部优化的实用动机，这种不一致的情况通常不作为附加的语言特性提供（而仅为简化实现默认作为全局策略使用）。</p>
<p><strong>注释</strong></p>
<p>　　由于实现可能确定特定表达式的作用对约定必须保持的<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">程序行为</a>没有影响而可能省略求值，按<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机</a>语义的严格求值在实际实现中通常是不必要的。</p>
<p>　　惰性求值可通过中间值<a href="Features/NPL.zh-CN.html#%E4%B8%A5%E6%A0%BC%E6%80%A7">延迟求值</a>实现。</p>
<h2 id="上下文"><a class="header" href="#上下文">上下文</a></h2>
<p>　　<em>上下文(context)</em> 是表达式关联的状态的特定集合。</p>
<p><strong>注释</strong> 这里不是<a href="Features/../Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">自指概念</a>。</p>
<p>　　一个上下文是<em>显式的(explicit)</em> ，当且仅当它可以通过<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">名称表达式</a>访问。</p>
<p>　　一个上下文是<em>隐式的(implicit)</em> ，当且仅当它不是显式的。</p>
<p>　　隐式的上下文通常是<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">管理状态</a>。</p>
<p>　　确定上下文的状态或对可变上下文的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">修改</a>是对上下文的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>。</p>
<p>　　规约规则中，以未指定子项参数化的项是一个上下文。</p>
<p>　　本节以外其它关于上下文的具体规则由派生实现定义。</p>
<p><strong>注释</strong></p>
<p>　　参数化的子项可在（<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>的）语法上被表示为一个<em>洞(hole)</em> ，详见<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">上下文相关求值</a>中的语法 <code>[]</code> 。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">过程实体</a>能影响<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">函数表达式</a>关联的上下文，参见<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">函数和函数应用的求值环境</a>。</p>
<h3 id="求值环境"><a class="header" href="#求值环境">求值环境</a></h3>
<p>　　<em>求值环境(evaluation environment)</em> 是在求值时可访问的隐式上下文，提供可通过<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>访问的变量的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">绑定</a>。</p>
<p>　　不和<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">实现环境</a>相混淆的情况下，求值环境简称（变量或对应的局部绑定所在的）为<em>环境(environment)</em> 。</p>
<p>　　具有<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E8%A7%81%E5%90%8D%E7%A7%B0">可见名称</a>的绑定是<em>可见的(visible)</em> 。</p>
<p>　　环境<em>包含(contain)</em> 若干个<em>局部绑定(local binding)</em> ，即不通过其它环境即保证可见的<em>被绑定实体(bound entity)</em> 。</p>
<p>　　环境<em>展示(exhibit)</em> 可见的绑定。</p>
<p>　　一个环境是<em>空环境(empty environment)</em> ，当且仅当其中包含的局部绑定集合是空集。</p>
<p><strong>注释</strong></p>
<p>　　按绑定的定义，求值环境的局部绑定集合即变量的名称和通过声明引入的被变量表示的实体构成的映射。</p>
<p>　　可见绑定可能被通过名称解析成功访问变量。</p>
<p>　　包含和展示的定义同 [R<sup>n</sup>RK] 。除此之外，<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境对象具有直接包含的绑定的所有权</a>。</p>
<h4 id="实现环境提供的求值环境"><a class="header" href="#实现环境提供的求值环境">实现环境提供的求值环境</a></h4>
<p>　　实现环境可能在实现以外提供附加的求值环境作为任务通信的机制，如环境变量。</p>
<p>　　除非派生实现另行指定，语言支持的求值环境和这些机制蕴含的求值环境的交集为空。语言可以库的形式提供 <a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 另行支持。</p>
<h4 id="函数和函数应用的求值环境"><a class="header" href="#函数和函数应用的求值环境">函数和函数应用的求值环境</a></h4>
<p>　　在典型的对象语言中 <a href="Features/NPL.zh-CN.html#%CE%BB-%E6%8A%BD%E8%B1%A1">λ 抽象</a>中指定的替换构造具有<em>局部作用域(local scoping)</em> ，其中可访问 λ 抽象外部词法意义上<em>包含的(enclosing)</em> 求值环境的变量，对应求值环境为<em>局部环境(local environment)</em> 。</p>
<p>　　在基于<em>词法作用域(lexical scoping)</em> 的对象语言中，引入 λ 抽象对应的语言构造支持<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">捕获</a>引入函数时所在的作用域的环境，称为<em>静态环境(static environment)</em> 。</p>
<p>　　相对地，<em>动态作用域(dynamic scoping)</em> 根据求值时的状态指定指称。</p>
<p>　　<a href="Features/NPL.zh-CN.html#vau-%E6%8A%BD%E8%B1%A1">Vau 抽象</a>进一步支持在局部环境中提供访问<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数应用</a>时的求值环境，即<em>动态环境(dynamic environment)</em> 的机制。</p>
<p>　　除非另行指定，按<em>词法闭包(lexical closure)</em> 规则捕获，即只根据词法作用域确定捕获的指称；若需要支持依赖求值状态动态确定指称时，使用派生实现提供的对求值环境的操作，而不依赖动态作用域。</p>
<p>　　作为<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">过程</a>的实现，词法闭包规则捕获实体创建<em>闭包(closure)</em> 。</p>
<p>　　除非另行指定，NPL 只存在一种作用域，即所有作用域都使用相同的<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>和捕获规则。</p>
<p><strong>注释</strong></p>
<p>　　历史上，闭包首先在 <a href="https://academic.oup.com/comjnl/article-pdf/6/4/308/1067901/6-4-308.pdf">SECD 抽象机</a>中引入。术语闭包来自 λ 演算的<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E9%87%8D%E5%86%99%E7%B3%BB%E7%BB%9F">闭项</a>。</p>
<h3 id="互操作上下文"><a class="header" href="#互操作上下文">互操作上下文</a></h3>
<p>　　用于<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>的和求值关联的隐式上下文是<em>互操作上下文(interoperation context)</em> 。</p>
<p>　　除非派生实现另行指定，语言不提供访问互操作上下文的公开接口。</p>
<p><strong>注释</strong></p>
<p>　　一个典型的实例：由 <a href="Features/NPL.zh-CN.html#%E8%A1%A5%E5%85%85%E9%A2%86%E5%9F%9F%E5%AE%9A%E4%B9%89">ISA</a>约定的通用架构寄存器的状态，可能需要在<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>或任务切换过程中保存和重置。</p>
<h2 id="类型"><a class="header" href="#类型">类型</a></h2>
<p>　　<em>类型(type)</em> 是上下文中和特定的实体直接关联或间接关联的元素，满足<a href="Features/NPL.zh-CN.html#%E9%98%B6%E6%AE%B5%E4%B8%8D%E5%8F%98%E9%87%8F%E7%BA%A6%E6%9D%9F">某个执行阶段的不变量约束</a>。</p>
<p>　　<em>类型规则(type rule)</em> 是和类型相关的对象语言的语义规则。</p>
<p>　　实体关联的类型可能被显式地指定，或通过隐式的限定规则推断确定。符合指定和限定要求的类型可有任意多个。</p>
<p>　　实体的类型是被显式指定的实体关联的类型。实体具有实体的类型以及通过其它规则限定的类型。实体是类型的<em>实例(instance)</em> 。</p>
<p>　　类型可用集合<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>。集合的元素是具有其表示的类型的实体。</p>
<p>　　表示类型的集合为空时，表示类型没有实例，是<em>空类型(empty type)</em> 。</p>
<p>　　推论：由集合的形式表达，空类型是唯一的。</p>
<p>　　表示类型的集合只有一个元素时，类型只有一个不可区分的实例，这样的类型是<em>单元类型(unit type)</em> 。</p>
<p>　　和表达式直接关联的类型满足起始阶段不变量约束，称为<em>静态类型(static type)</em> 。</p>
<p>　　和表达式的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>关联的类型满足<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">运行阶段</a>的不变量约束，称为<em>动态类型(dynamic type)</em> 。</p>
<p>　　其它可能存在类型或实现执行阶段的扩展由派生实现定义。</p>
<p>　　除非另行指定，对象的类型是<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">对象的值</a>的类型。</p>
<p>　　NPL 对象类型和<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">存储的值</a>的类型之间的关联未指定。</p>
<p>　　类型在描述类型规则的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>中可作为对象。</p>
<p>　　生成对象的元语言函数是<em>类型构造器(type constructor)</em> 。类型构造器的参数是类型，的函数值是组合这些参数得到的<em>复合类型(compound type)</em> 。</p>
<h3 id="类型系统和类型机制"><a class="header" href="#类型系统和类型机制">类型系统和类型机制</a></h3>
<p>　　称为类型的具体实体和之间的关联由派生实现的<em>类型系统(type system)</em> 规则指定。</p>
<p>　　默认类型系统不附加约束，所有表达式或关联的项都<em>没有指定类型(untyped)</em> ，为退化的<em>平凡类型系统(trivial type system)</em> 或<em>单一类型系统(unityped system)</em> ，实质上是动态类型。</p>
<p>　　对类型系统的分类中，类型也指确定类型的过程称为<em>类型机制(typing discipline)</em> ，其中确定类型的过程称为<em>定型(typing)</em> 。</p>
<p>　　在静态类型之后阶段确定的类型机制是<em>动态定型(dynamic typing)</em> 。</p>
<p>　　除非另行指定，被确定的静态类型的阶段是翻译时阶段；被确定的动态类型的阶段是翻译时之后，即<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">运行时</a>。</p>
<p>　　语言可提供<a href="https://en.wikipedia.org/wiki/Typing_rule">定型规则(typing rule) (en-US)</a> ，指定<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>作为实体在特定的<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87">上下文</a>（称为<em>类型环境(typing environment)</em> ）中的类型。项是类型在这个上下文中的<em>居留(inhabitant)</em> 。</p>
<p>　　类型环境确定<em>类型指派(type assignment)</em> ，即项和类型的之间的<em>定型关系(typing relation)</em> 。定型确定的这种定型关系的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">实例</a>即<em>定型判断(typing judgement)</em> 。</p>
<p>　　不违反类型系统规则下的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">良定义的</a>程序构造是<em>良型的(well-typed)</em> 。</p>
<p>　　根据是否要求项首先都是良型的再指派语义，带有类型的形式系统可具有<a href="https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus#Intrinsic_vs._extrinsic_interpretations"><em>内在(intrinsic)</em> 和<em>外在(extrinsic)</em> 的解释</a>。</p>
<p>　　除非另行指定，NPL 使用外在的解释。</p>
<p><strong>原理</strong></p>
<p>　　默认使用外在解释的理由是：</p>
<ul>
<li>类型的外在解释允许在一个没有指定具体类型系统设计的单一类型系统为基础扩展不同的类型系统，能满足语言自身<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">可扩展</a>的需要。
<ul>
<li>扩展通用目的语言特性的顺序应是从简单到复杂的，而不是相反，因为并不存在已知的万能语言可供裁剪。</li>
<li>这也符合历史顺序：无类型 λ 演算被扩展到不同的有类型 λ 演算，而不是相反；因为有类型 λ 演算的规则明显较无类型 λ 演算多且复杂。</li>
<li>从无类型 λ 演算可以扩展到的一些特性更丰富其它系统，如 <a href="https://en.wikipedia.org/wiki/Lambda-mu_calculus">λμ 演算 (en-US)</a> 和 vau 演算，首先都是无类型的，并不存在可用的内在解释。</li>
</ul>
</li>
<li>为了描述类型规则，外在解释最终需要在整个系统中引入和对象语言不同的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>，而增加复杂性。
<ul>
<li>即便存在强调可扩展的对象语言（如 <a href="https://arxiv.org/abs/0910.2654">MLPolyR</a>），至少语言规范中定义的元语言没有被证明可以和被描述类型规则的对象语言合并。</li>
<li>即便能证明可以合并，这种方式也显著地大大增加了设计的复杂性，违反<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>。</li>
<li>根本上，这种方式损害对象语言设计的<a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">光滑性</a>，很可能大大削弱对象语言的<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>。</li>
</ul>
</li>
<li>没有确切的充分依据证明引入类型系统带来的性质是通过非类型论的直接扩展演绎系统的方式不能实现或者其实现有现实困难的。
<ul>
<li>因此先验地要求类型的存在缺乏必要性。即便可实现需求，在通用目的上通常是舍近求远的过度设计。</li>
<li>即便引入类型的方式有现成的工程实践而可以提升工程效率，也可能是<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E6%88%90%E7%86%9F%E7%9A%84%E4%BC%98%E5%8C%96">过早的优化</a>。</li>
<li>更何况现实并没有证据表明存在这样的成功实践。</li>
</ul>
</li>
<li>跳出先验地引入类型的做法，使用先验的内在解释而排除不够清晰明确的含义(meaning) 的语法的方式，在历史上存在更显著的失败。
<ul>
<li>[Chu41] §18 试图排除原始的 λ 演算（称为 λ-K-转换，在 [Bare84][Shu10] 中称为 λ<em>K</em> 演算）中无法取得<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">范式</a>的项（以使之更适用于符号逻辑的目的）：限制 λ 抽象中的约束变量是第二子项的自由变量。
<ul>
<li>非正式地，这在语法上要求每个<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数体</a>中的每个<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">变量</a>必须是某个唯一的函数的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">形式参数</a>，且这个函数的函数体是语法上包含这个变量的表达式，即语言在语法上禁止出现（在声明以外）未使用的形式参数。</li>
<li>限制的 λ 演算在现代（如 [Bare84][Shu10] ）称为 λ<em>I</em> 演算，不支持表达 <a href="https://zh.wikipedia.org/zh-cn/%E7%BB%84%E5%90%88%E5%AD%90%E9%80%BB%E8%BE%91">K 组合子</a>。</li>
</ul>
</li>
<li>[Bare84] §2.2 指出 λ<em>I</em> 演算具有的一些问题，如：
<ul>
<li>对应的理论 <strong>λ<em>I</em></strong> 翻译到<a href="https://zh.wikipedia.org/zh-cn/%E7%BB%84%E5%90%88%E5%AD%90%E9%80%BB%E8%BE%91">组合子逻辑</a>的理论 <strong>CL</strong> 时，项能取得<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">范式</a>的性质不被保持。</li>
<li>范式的概念过于侧重语法，所以在<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">模型</a>中不确定含义。</li>
<li>试图识别编码<a href="https://en.wikipedia.org/wiki/Partial_function">偏函数(partial function) (en-US)</a> 需要的“未定义”的项是不可能的。</li>
<li>λ<em>I</em> 演算定义的偏函数的组合对应的项不一定是 λ<em>I</em> 演算定义的被组合的偏函数的项的组合。</li>
</ul>
</li>
<li>[Bare84] §2.2 指出，这些问题都来自 [Chu41] 选择用无法取得范式的项编码“未定义”的概念。
<ul>
<li>定义可解性(solvability) ，以不可解代替不能取得范式编码“未定义”可解决这个问题。
<ul>
<li>项的可解性定义为存在有限的项序列使前者在后者顺序应用得到 <a href="https://zh.wikipedia.org/zh-cn/%E7%BB%84%E5%90%88%E5%AD%90%E9%80%BB%E8%BE%91">I 组合子</a>（即 λ<em>x</em>.<em>x</em> ）。</li>
</ul>
</li>
<li>在 λ<em>I</em> 演算中，不可解等价不能取得范式。而在 λ 演算中，不可解等价不能取得 <a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">HNF</a> 。</li>
<li>λ 演算没有 λ<em>I</em> 演算的上述问题。</li>
<li>λ<em>I</em> 表述的 Church–Turing 论题仅限于<a href="Features/NPL.zh-CN.html#%E7%BB%88%E6%AD%A2%E4%BF%9D%E8%AF%81">全函数</a>，而 λ 函数表述的论题能扩展到一般形式的偏函数。</li>
</ul>
</li>
<li>即便不考虑上述整体性质，尽管计算上 λ<em>I</em> 演算是 <a href="Features/NPL.zh-CN.html#%E5%AE%8C%E6%95%B4%E6%80%A7">Turing 完备</a>的，它不能编码<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">常量</a>函数。
<ul>
<li>因为也不包含<a href="Features/NPL.zh-CN.html#%E7%AE%A1%E7%90%86%E8%A7%84%E7%BA%A6">管理规约</a>规则，它实际上无法编码<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察性质的项</a>，除非平凡地指定所有项都是可观察的。</li>
</ul>
</li>
<li>以上问题一定程度上揭示了去除似乎冗余但实际在语义上可能非平凡的语法构造是<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E6%88%90%E7%86%9F%E7%9A%84%E4%BC%98%E5%8C%96">不成熟的简化</a>，损害系统的<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>。</li>
<li>要求（可被类型检查的）类型系统直接排除不能取得范式的项，在这个意义上比 λ<em>I</em> 演算对去除特定的项的组合更彻底。
<ul>
<li>即便类型系统能引入其它语义，这以引入不能被对象语言表达的规则为代价，通常需要元语言。</li>
<li>相比之下，同样是引入对象语言表达式无法表达的语义，管理规约是对象语言规则能直接蕴含的，相对具有更小的（工作量和避免兼容问题上的）代价。</li>
</ul>
</li>
<li><strong>注释</strong> 内在解释又被称为 Church 风格的。</li>
</ul>
</li>
<li>哲学意义上，内在解释或本体论上的(ontological) 解释，相比外在解释或语义上的(semantical) 解释需要更强的假设。
<ul>
<li>本体论上的逻辑，如 <a href="https://en.wikipedia.org/wiki/Frege%E2%80%93Church_ontology">Frege-Church 本体论 (en-US)</a>，可能解决一些悖论。</li>
<li>但根本上，没有充分动机指出，不涉及<a href="Features/NPL.zh-CN.html#%E6%BC%94%E7%BB%8E%E8%A7%84%E5%88%99">演绎规则</a>的悖论必须在通用语言内部直接提供规则消除，而不能通过其它方式（例如，由<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>补充前提）解决。
<ul>
<li>指定管理规约可以编码非平凡的表达语言规则外的语义的项可以对这样的前提建模并在语言中适当编码表达。</li>
<li>编码表达这种方式是 NPL 强调 <a href="Features/NPL.zh-CN.html#%E8%AF%8D%E6%B3%95%E8%A7%84%E5%88%99">N(name)</a> 和其它实体分离的主要理由。</li>
</ul>
</li>
<li>本体论假设要求名称以外附加实体以使假设生效。一般地，这些假设以不同语言的陈述作为断言实现。这些陈述涉及特称对象时，在完备性上是可疑的，且容易和<a href="Features/NPL.zh-CN.html#%E5%BC%80%E6%94%BE%E6%80%A7">开放世界假定</a>冲突。</li>
<li>约定不涉及的语言规则的本体论假设在这些意义上也可被认为在效用上的<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E6%88%90%E7%86%9F%E7%9A%84%E4%BC%98%E5%8C%96">不成熟的优化</a>。</li>
</ul>
</li>
</ul>
<p><strong>注释</strong></p>
<p>　　在元语言的意义上，类型系统包含语法和对应的语义，但在对象语言中，定型规则和其它推理规则（如<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>规则）作为语言规则是语义规则，和语法相对独立。</p>
<p>　　实体的类型可被指定为未指定类型，以明确类型的存在性，但不明确具体的类型的构造和表示。</p>
<p>　　形式地，在类型系统中，类型环境和项作为前提，通过定型规则(typing rule) 得到定型判断。定型规则在逻辑上可以是公理或定理。</p>
<p>　　在数理逻辑中，使用结构主义数学方法，集合可以作为描述类型规则的理论（句子集合）的模型，和理论支持描述的类型一一对应。</p>
<h3 id="类型等价性"><a class="header" href="#类型等价性">类型等价性</a></h3>
<p>　　通过显式指定标识（如名称）的方式定义类型的方法是<em>名义类型(nominal typing)</em> ，否则是<em>结构化类型(structrual typing)</em> 。</p>
<p>　　除非另行指定，不同的名义类型不蕴含等价关系。结构化类型之间的等价关系由实现定义。</p>
<p>　　类型的相等关系是一种类型之间的等价关系。两个类型相等，当且仅当它们的实例作为元素的两个集合对应相等。</p>
<p>　　除非另行指定，相等的类型不在语言中区分，且元语言（描述对象语言的规则）中类型作为实体的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>即类型相等性。</p>
<p>　　推论：除非另行指定，不同的类型不等价。</p>
<p>　　除非另行指定，对象语言使用类型相等性实现类型等价性。</p>
<p><strong>原理</strong></p>
<p>　　对象语言中的类型实质上是类型的一种间接的表示，作为实体仍然可以具有不同的同一性。</p>
<p>　　这避免程序可能需要枚举类型的外延（即精确实现出表示它的集合）才能确保确切表示出这个类型这样的计算上不可行的困难。</p>
<p>　　因为可支持的表示的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%85%A8%E9%9B%86">类型全集</a>不同，类型相等是相对的，依赖类型系统的具体实现。一个类型系统可能支持无法在另一个类型系统中精确表示的类型。</p>
<p><strong>注释</strong></p>
<p>　　本节的主要例外参见<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%BA%8F">公共子类型</a>。</p>
<h3 id="类型标注"><a class="header" href="#类型标注">类型标注</a></h3>
<p>　　根据是否需要特定的文法元素指定和项关联的类型即<em>类型标注(type annotation)</em> ，对确定类型的机制可进行分类。</p>
<p>　　类型系统可使用<em>显式类型(explicit typing)</em> ，即在<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">定型</a>时要求类型标注。</p>
<p>　　不使用类型标注的方式是<em>隐式类型(implicit typing)</em> 。</p>
<p>　　在引入实体（特别地，如<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">变量</a>）时指定实体的显式类型标注称为<em>清单类型(manifest typing)</em> 。</p>
<p>　　不使用清单类型而使隐式引入的实体（如值）关联具体类型的机制称为<em>潜在类型(latent typing)</em> 。</p>
<p>　　清单类型是显式类型的实例；除此之外，显式类型还包括<em>铸型(casting)</em> ，即显式指定表达式求值的结果应具有的类型。</p>
<p>　　潜在类型是隐式类型的实例；除此之外，隐式类型还包括<em>类型推断(type interferece)</em> ，即通过隐含的上下文信息判断表达式关联的类型。</p>
<p>　　类型推断的逆过程是<em>类型擦除(type erasure)</em> 。类型擦除支持使一个<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">良型</a>的程序中的已被定型的实体表示擦除前按类型规则不允许表示的其它实体。</p>
<p>　　若类型机制可保证在某个<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">执行阶段</a>内有确定<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">强规范化性质</a>的算法确定类型，则类型机制在该阶段是<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态定型</a>。</p>
<p><strong>注释</strong> 强规范化性质的算法保证终止。</p>
<p>　　语言可能个别指定引入这些类型相关的规则，在保持逻辑相容的前提下可混合使用。</p>
<p>　　显式类型可编码接口的要求，即<em>类型签名(type signature)</em> 。</p>
<p>　　类型签名通常直接指定<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义类型</a>，但同时也可允许非特定的满足结构类型约束的类型。这些类型和类型签名<em>兼容(compatible)</em> 。</p>
<p><strong>原理</strong></p>
<p>　　历史上，表达式的类型和变量的类型在<a href="Features/NPL.zh-CN.html#%CE%BB-%E5%AE%8C%E5%A4%87%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AF%B9%E5%BA%94%E8%AF%AD%E6%B3%95">简单类型 λ 演算</a>中同时被引入。后者修饰 λ 抽象中的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">自由变量</a>，而前者限定剩余的所有项。</p>
<p>　　即便从<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项重写系统</a>中两者是形式上统一的，在实际语用中具有很不同的差异。这集中体现在后者是<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义的</a>，除非附加其它不同的语法设施，并不具有结构化推导的性质，原则上只适合描述接口；而前者能兼容<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">结构化类型</a>，同时适合描述接口及其实现。</p>
<p>　　作为接口的名义类型在作为自由变量以外的上下文中重新复用为不关心其类型（并消除依赖这些信息的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">其它机制</a>）的其它程序构造（一般意义上的表达式），通常需要类型擦除等更复杂的机制和支持的类型系统规则，以消去不再预期和其它类型系统规则交互的类型。</p>
<p>　　和 [R<sup>n</sup>RK] 类似，NPL 不要求使用清单类型，以避免一些一般意义上的全局设计缺陷。这些缺陷包括：</p>
<ul>
<li>过于积极地（非预期地）排除危险但对程序有用的使用，而违反<a href="Features/NPL.zh-CN.html#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测性</a>。</li>
<li>因为移除类型标注需要上述的复杂机制和类型系统规则，具体的清单类型阻碍派生语言定义其它不容易冲突的类型标注规则而使语言具有更好的<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">可扩展性</a>。</li>
<li>因为名义类型的相关规则更容易直接拒绝一些和类型规则不兼容的程序构造而难以简单地变通，往往对程序构造的组合具有更多直接的<a href="Features/NPL.zh-CN.html#%E5%AE%8C%E6%95%B4%E6%80%A7">可表达性</a>限制而破坏通用计算意义上的<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>。
<ul>
<li><strong>注释</strong> 例如，许多类型系统不允许表达 <a href="https://zh.wikipedia.org/zh-cn/%E4%B8%8D%E5%8A%A8%E7%82%B9%E7%BB%84%E5%90%88%E5%AD%90#Y%E7%BB%84%E5%90%88%E5%AD%90">Y 组合子</a>的构造<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">良型</a>。</li>
</ul>
</li>
</ul>
<p>　　若有必要，派生语言仍可限定使用清单类型。一般仍然建议仅在局部引入而避免全局复杂性和因此带来的限制。</p>
<p><strong>注释</strong></p>
<p>　　类型签名来自数理逻辑术语。</p>
<h3 id="类型检查"><a class="header" href="#类型检查">类型检查</a></h3>
<p>　　<em>类型检查(typechecking)</em> 解答程序是否满足类型规则的判定性问题。</p>
<p>　　使用<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">翻译时</a>的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">语义分析</a>或<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">运行时</a>的类型检查分别为静态类型检查和动态类型检查。</p>
<p>　　静态类型检查规则是<a href="Features/NPL.zh-CN.html#%E7%BF%BB%E8%AF%91%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%A7%84%E5%88%99">可诊断语义规则</a>。</p>
<p>　　语言可能个别指定引入类型检查相关的规则，在保持逻辑相容的前提下可混合使用。</p>
<p>　　类型检查失败引起的<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">错误</a>称为<em>类型错误(type error)</em> 。</p>
<p><strong>注释</strong></p>
<p>　　注意静态类型检查和<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态定型</a>以及动态类型检查和<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">动态定型</a>的区别。类型检查和类型机制是不同的规则，不必然包含蕴含关系。</p>
<p>　　类型检查的一个典型的使用场景是<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">类型签名的兼容性</a>校验。</p>
<h3 id="类型全集"><a class="header" href="#类型全集">类型全集</a></h3>
<p>　　<em>类型全集(type universe)</em> 是语言规则中允许表达的类型的总称。</p>
<p><strong>注释</strong> 表达类型的规则构成的模型的语言是语言规则的子集。</p>
<p>　　NPL 避免限定类型全集。派生语言可指定不同的规则。</p>
<p>　　除非派生实现另行指定，程序的用户不能依赖语言规则的限定枚举类型全集中的所有类型。</p>
<p><strong>原理</strong></p>
<p>　　类型全集是<a href="Features/NPL.zh-CN.html#%E5%BC%80%E6%94%BE%E6%80%A7">论域</a>的实例。避免限定类型全集符合<a href="Features/NPL.zh-CN.html#%E5%BC%80%E6%94%BE%E6%80%A7">开放世界假定</a>。</p>
<h4 id="类型谓词"><a class="header" href="#类型谓词">类型谓词</a></h4>
<p>　　判断值是否满足类型<em>居留(inhabitant)</em> 的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">谓词</a>是<em>类型谓词(type predicate)</em> 。</p>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RK] 的基本类型谓词不同，类型谓词定义为只接受一个参数。</p>
<h3 id="类型序"><a class="header" href="#类型序">类型序</a></h3>
<p>　　类型之间可具有序关系。</p>
<p>　　被<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">定型</a>的类型的实体可完全地满足其它类型的约束。前者具有后者的<em>子类型(subtype)</em> 。</p>
<p>　　<em>子类型(subtyping)</em> 关系是一种<a href="https://zh.wikipedia.org/zh-cn/%E9%A2%84%E5%BA%8F%E5%85%B3%E7%B3%BB">预序(preorder) 关系</a>，即自反的、反对称的二元关系。</p>
<p>　　相等的类型符合子类型关系，是<em>平凡的(trivial)</em> 。排除平凡的子类型关系是严格子类型关系。</p>
<p>　　严格子类型是严格预序关系，即反自反、反对称的二元关系。</p>
<p>　　子类型和严格子类型对应的逆关系是<em>超类型(super typing)</em> 和<em>严格超类型(strict supertyping)</em> 关系。</p>
<p>　　多个类型可具有公共的（严格）超类型。这些类型同为一个类型的子类型而<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">等价</a>。</p>
<p>　　除非另行指定，在程序的行为不依赖其中特定的个别不相等的类型而具有差异时，具有相等超类型的等价的子类型视为相同的类型。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">复合类型</a>中其中一部分的类型替换为其子类型，得到的结果和原复合类型可能有如下<a href="https://zh.wikipedia.org/zh-cn/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98#%E5%BD%A2%E5%BC%8F%E5%AE%9A%E4%B9%89">变化(variance)</a> 的对应关系之一：</p>
<ul>
<li><em>协变(covariant)</em> ：类型序被保持，即结果类型是原复合类型的子类型。</li>
<li><em>逆变(contravariant)</em> ：类型序的逆被保持，即结果类型是原复合类型的超类型。</li>
<li><em>不变(invariant)</em> ：不保持类型序，即结果类型和原复合类型之间没有确定的子类型关系。</li>
</ul>
<p>　　同时存在以下派生归类：</p>
<ul>
<li><em>互变(bivariant)</em> ：同时协变和逆变。</li>
<li><em>可变(variant)</em> ：至少协变或逆变之一。</li>
</ul>
<p>　　对接受参数类型得到结果类型的函数<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型构造器</a> → ，以下关系是确定的：</p>
<ul>
<li>参数类型对函数类型逆变。</li>
<li>结果类型对函数类型协变。</li>
</ul>
<p>　　把<a href="Features/NPL.zh-CN.html#%E5%B0%81%E8%A3%85">LSP</a>要求子类型经替换前后保持性质的谓词视为类型构造器，则 LSP 要求的性质是协变的。</p>
<p><strong>注释</strong></p>
<p>　　关于 → 的变化关系的陈述通常直接被作为类型系统中的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">定型规则</a>表达的公理，以和 → 既有的定型规则兼容。</p>
<p>　　一些非普遍的局部类型序的构造器，如数组的下标 <code>[]</code> ，也可对参数有确定的可变关系。</p>
<p>　　在 LSP 的<a href="https://www.cs.cmu.edu/~wing/publications/LiskovWing94.pdf">原始论文</a>提供了两个满足 LSP（文中称为子类型要求(subtype requirement) ）的在<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">过程</a>的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">签名</a>定义子类型的方法，兼容以上传统的函数类型构造器的子类型变化关系，是 → 上的上述关系的扩展：这些定义还支持表达过程的具体前置条件(precondition) 和其中引发的<a href="Features/NPL.zh-CN.html#%E5%BC%82%E5%B8%B8">异常</a>。</p>
<p>　　对一般的谓词，LSP 的行为多态(behavioral polymorphism) 是不可判定的。因此，一般的 LSP 无法被<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>。在<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">类型系统</a>中应用 LSP 需依赖具体能表达性质的谓词，如使用的类型构造器。</p>
<h4 id="类型边界元素"><a class="header" href="#类型边界元素">类型边界元素</a></h4>
<p>　　一个类型系统可指定唯一的<a href="https://en.wikipedia.org/wiki/Bottom_type"><em>底类型(bottom type)</em> (en-US)</a> 作为其它任何不同类型的严格子类型，记作⊥。若类型全集包含空类型，则底类型是<a href="https://en.wikipedia.org/wiki/Empty_type"><em>空类型(empty type)</em> (en-US)</a> 。</p>
<p>　　一个类型系统可指定唯一的<a href="https://en.wikipedia.org/wiki/Top_type"><em>顶类型(top type)</em> (en-US)</a> 作为其它任何不同类型的严格超类型，记作⊤。这种类型即<em>通用类型(universal type)</em> 。</p>
<p>　　NPL 支持空类型作为底类型，但不要求在对象语言中支持其表示。</p>
<p>　　NPL 避免要求唯一的顶类型的存在以符合<a href="Features/NPL.zh-CN.html#%E5%BC%80%E6%94%BE%E6%80%A7">开放世界假设</a>。</p>
<p>　　派生语言可指定不同的规则。</p>
<p><strong>原理</strong></p>
<p>　　以空类型作为子类型在类型序的推理上是自然的。</p>
<p>　　就非特定的类型全集，通用类型的的构造和表示不唯一，因此不能直接断言其存在。</p>
<p>　　否则，假定存在这种类型，则断言不存在其超类型，这可能和其它语义规则冲突。</p>
<p>　　即使在名义上定义具体的超类型（如 Java 的 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html"><code>java.lang.Object</code></a>），也面临不能向上扩展（得到比 <code>Object</code> 更基本的类型）的问题，违反<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>和<a href="Features/NPL.zh-CN.html#%E5%85%B6%E5%AE%83%E6%8E%A8%E8%AE%BA%E5%92%8C%E6%AF%94%E8%BE%83">通用性</a>。</p>
<p>　　具体的顶类型在断言当前类型系统不存在公共超类型可能仍然有实用意义；此时，顶类型即<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等实体</a>构成的类型，而不需要定义具体<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义类型</a>。</p>
<h3 id="多态类型"><a class="header" href="#多态类型">多态类型</a></h3>
<p>　　特定的类型系统支持<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">类型签名</a>能对应多种不同的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">兼容</a>类型。这样的类型是<em>多态的(polymorphic)</em> 。</p>
<p>　　一般地，类型上的<em>多态(polymorphism)</em> 有：</p>
<ul>
<li><em>特设(ad-hoc)</em> 多态：仅对项上局部的项上的类型作用使之满足上下文兼容要求的多态：
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数</a><em>重载(overload)</em> ：同一个<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">名称</a>对应的不同的函数实体，允许按<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">实际参数</a>的类型选择调用不同的函数。</li>
<li><em>强制(coercion)</em> ：求值时使值向某个上下文要求的类型的隐式转换。</li>
</ul>
</li>
<li><em>参数(parameteric)</em> 多态：接口签名指定以具体类型作为值的变量，组合为函数或者其它接口对应实体的类型。</li>
<li><a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>多态：接口签名编码接受子类型关系作为兼容类型。</li>
<li><em>行(row)</em> 多态：对组成具有名称和实体对构成的元素作为<em>成员(member)</em> 的实体，兼容限定部分成员的类型。</li>
</ul>
<p>　　<em>多型(polytipic)</em> 的接口在同一个接口签名上以结构化类型的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">隐式类型</a>构造支持不同的类型而支持多态。</p>
<p><strong>注释</strong></p>
<p>　　重载在一些语言中自动地对函数对应的具体<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">可调用实体</a>适用。</p>
<p>　　行多态以<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">结构化类型</a>约束取代通常通过<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义类型</a>指定的子类型关系。</p>
<h3 id="类型种类"><a class="header" href="#类型种类">类型种类</a></h3>
<p>　　<em>种类(kind)</em> 是<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态类型系统</a>的语法表示中具有特定类型模式(pattern) 的分类。</p>
<p>　　一定意义上，种类是类型系统的元语言中一种元静态类型。</p>
<p>　　一般地，实体类型的种类记作 <code>*</code> 。</p>
<p>　　除非另行指定，作为项的函数应具有函数类型，即符合类型种类为 <code>* → *</code> 的结果的类型，如为<a href="Features/NPL.zh-CN.html#%CE%BB-%E5%AE%8C%E5%A4%87%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AF%B9%E5%BA%94%E8%AF%AD%E6%B3%95">简单类型 λ 演算</a>兼容的函数类型实例。</p>
<p>　　其中，<code>→</code> 是函数类型的类型构造器。</p>
<p>　　种类作为元语言中的<a href="Features/NPL.zh-CN.html#%E5%A4%9A%E6%80%81%E7%B1%BB%E5%9E%8B">类型多态</a>，实现<em>种类多态(kind polymorphism)</em> ：接口签名接受类型的编码中对应位置具有不同种类的类型。</p>
<p><strong>注释</strong></p>
<p>　　在实现中，种类也被作为<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">互操作</a>的归类，如视为<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>的<a href="https://www.microsoft.com/en-us/research/uploads/prod/2020/03/kacc.pdf">调用约定</a>。</p>
<p>　　但这不足以涵盖一般的形式定义；特别地，<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">调用</a>是仅仅关于<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">过程</a>这类实体的互操作，而种类适合一般实体的静态类型。例如，在不考虑进一步地实现时，<a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/levity-pldi17.pdf">多变(levity) 多态</a>的类型不需要限定过程（函数）。</p>
<p>　　类型系统中的种类也可扩展到特定的计算作用的<em>作用系统(effect system)</em> 上以描述<a href="Features/NPL.zh-CN.html#%E4%BD%9C%E7%94%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99">作用的种类</a>，此处从略。</p>
<h3 id="一等类型"><a class="header" href="#一等类型">一等类型</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E8%AF%AD%E4%B9%89">一等对象</a>的类型是<em>一等类型(first-class type)</em> 。</p>
<p>　　非一等类型的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">居留</a>可能不在对象语言中可表达，即对象语言中无法构造这些类型的值。</p>
<p>　　非一等类型仅用于构造其它类型（可能是一等类型）和类型检查等依赖类型的推理。</p>
<p><strong>注释</strong></p>
<p>　　一个典型的非一等类型的例子是 [ISO C] 和 [ISO C++] 等语言支持的类型 <code>void</code> 。</p>
<p>　　在语义的角度上，<code>void</code> 可视为依赖<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">翻译阶段</a>把<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>时得到的对应 <code>void</code> 居留的表示替换为表示语义错误的单元类型，并在翻译结束前拒绝接受带有这种居留的程序，而这种居留在对象语言中始终不可取得。</p>
<p>　　若不限制翻译阶段，可通过在<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">传递</a>时始终限制<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%9D%A1%E4%BB%B6">正常控制</a>的值实现类似的效果，例如不考虑类型消除时 [ISO C++] 中在复制或转移构造函数始终抛出异常的类类型。</p>
<h2 id="程序的控制执行条件"><a class="header" href="#程序的控制执行条件">程序的控制执行条件</a></h2>
<p>　　程序的执行可被<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制作用</a>影响。蕴含这些影响的条件即<em>执行条件(execution condition)</em> 。</p>
<p>　　程序的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制状态</a>决定<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>使用的<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">续延</a>。</p>
<p><strong>注释</strong> 这和<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">过程的调用</a>类似。</p>
<p>　　更一般地，规约规则指定语言的实现决定程序行为时使用的（对程序不保证可见的）续延，这种在实现中对应的控制状态称为控制执行条件。</p>
<p>　　和控制状态不同，控制执行条件描述语言提供的不同控制机制的分类，而不被作为语言可编程的特性提供。</p>
<p>　　除非另行指定，仅由<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>中蕴含的规约规则决定的执行条件是<em>正常(normal)</em> 的。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">合并子调用以当前续延返回</a>是正常执行的。</p>
<p><strong>注释</strong> 这是正常控制执行条件的一个主要实例。</p>
<p>　　改变程序的正常的控制要求存在控制作用，此时，控制执行条件是<em>非正常(abnormal)</em> 的。</p>
<p>　　除非另行指定，隐含在求值算法中蕴含的规约规则确定的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数应用</a>外的<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延调用</a>是非正常的。</p>
<p><strong>注释</strong> 这是非正常控制执行条件的一个主要实例。</p>
<p>　　具有规约语义的语言总是支持正常控制条件。NPL 中，非正常的控制条件的支持是可选的。</p>
<h3 id="异常"><a class="header" href="#异常">异常</a></h3>
<p>　　由派生实现定义的非正常的控制条件是<em>异常(exceptional)</em> 条件。</p>
<p>　　<em>异常(excpetion)</em> 是通过<em>抛出(throw)</em> 实体（称为异常实体）同时表达满足异常条件的控制作用的语言构造。</p>
<p>　　语言的实现或用户通过特定操作（如求值一个表达式）指定程序满足异常条件，使程序的控制进入<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">异常执行状态</a>，允许程序具有正常条件下可分辨不同行为。</p>
<p>　　程序通过<em>捕获(catch)</em> 并<em>处理(handle)</em> 被抛出的实体，程序可满足不同的恢复正常执行的条件。</p>
<p>　　进入违反<a href="Features/NPL.zh-CN.html#%E7%BF%BB%E8%AF%91%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%A7%84%E5%88%99">翻译时正确性规则</a>的异常执行状态时，由语言实现提供的异常执行机制实现行为。</p>
<p><strong>注释</strong> 这些行为至少蕴含满足翻译时正确性规则要求的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">诊断</a>。</p>
<p>　　进入其它异常执行状态的异常条件包括所有<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">运行时</a>异常条件和直接引起程序异常的用户操作。</p>
<p>　　这些异常条件的具体行为和正常条件下的不同由派生实现指定的运行时状态或直接引起异常（改变程序的控制）或语言构造的语义决定。此时，由实现定义使用的异常执行机制。</p>
<p><strong>注释</strong> 其它异常条件的异常执行机制可能和上述相同或不同。</p>
<p>　　派生语言实现可指定以下规则：</p>
<ul>
<li>符合以上约定的判断改变（进入和退出）异常执行状态的执行机制。</li>
<li>包括抛出和捕获的语言构造和其它可选的引起改变异常条件的上下文。</li>
</ul>
<p>　　若派生实现不指定以上要求的执行机制和上下文，则不支持异常。</p>
<p>　　除非派生实现另行指定，异常的控制作用总是<em>被同步(synchronized)</em> 的，即：</p>
<ul>
<li>在初始化异常实体时，保证存在与异常条件关联且可确定单一的<a href="Features/NPL.zh-CN.html#%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0">执行线程</a>的状态作为引起控制状态改变即引发异常的来源。</li>
<li>异常条件的满足不依赖未和引发异常状态同步的程序中的其它的执行状态（包括其它未同步的线程的状态）。</li>
<li>确认满足异常条件和进入异常执行状态之间，上述执行线程内程序仅在引发异常的线程上的程序允许存在<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">计算作用</a>（这保证不被引起可观察行为改变的其它线程的操作中断）。</li>
</ul>
<p>　　除非派生实现另行指定，未捕获的异常总是确定性地(deterministically) 持续引发异常的执行线程中引起控制的转移：</p>
<ul>
<li>若捕获操作有效的上下文，控制转移捕获构造处理对应异常的<em>异常处理器(exception handler)</em> 。</li>
<li>否则，若在活动函数调用中，则单向地从<a href="Features/NPL.zh-CN.html#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">当前活动的函数</a>向其<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">主调函数</a>转移控制，使后者活动。</li>
<li>否则，若没有找到剩余的活动函数调用，则程序异常终止。</li>
</ul>
<p>　　除非派生实现另行指定，上述转移活动函数若成功（包括异常在活动的主调函数嵌套的特定语言构造中被捕获），先前不再活动的活动记录中的资源在控制成功转移后应立即被释放。</p>
<p>　　典型的设计中，求值规则使的正常状态的函数调用要求的活动记录分配和释放满足 FIFO（Last-In First-Out ，后入先出）的顺序，构成了<em>栈(stack)</em> ，活动记录是<em>栈帧(stack frame)</em> 。</p>
<p>　　除非派生实现另行指定，活动函数的转移释放资源，应保证按和创建被其所有的实体的顺序的相反顺序一致的形式释放。这种释放活动记录占用资源的机制称为<em>栈展开(stack unwinding)</em> 。</p>
<h3 id="终止保证"><a class="header" href="#终止保证">终止保证</a></h3>
<p>　　特定的求值具有（确定性地）<em>终止(termination)</em> 保证，当且仅当预期求值总是在有限计算步骤内可描述的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">计算作用</a>。</p>
<p>　　具有终止保证的求值总是取得值或通过非正常控制的计算作用退出求值。</p>
<p>　　不具有终止保证的求值可能不终止，此时它具有取得值以外的计算作用；这种计算作用是<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>。</p>
<p>　　若一个函数的调用总是具有终止保证，则此函数是<em>终止函数(terminating function)</em> 。</p>
<p>　　若一个函数的调用总是取得值，则此函数是<em>全函数(total function)</em> 。</p>
<p><strong>注释</strong> 全函数总是终止函数。</p>
<h1 id="npla"><a class="header" href="#npla">NPLA</a></h1>
<p>　　当前维护的主要派生语言为 <strong>NPLA</strong> ，是 NPL 的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">抽象语言实现</a>和<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">派生实现</a>。</p>
<p>　　NPLA 的参照实现 <a href="Features/NPL.zh-CN.html#npla1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80">NPLA1</a> 是具体语言实现，约定特定于当前参照实现的附加规则和实现。</p>
<p>　　作为原型设计，NPLA 重视可扩展性。</p>
<p>　　作为 NPL 的派生实现，NPLA <a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>的设计遵循 NPL <a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E6%A8%A1%E5%9E%8B">符合性规则</a>，并满足如下要求或附加限制。</p>
<p><strong>注释</strong></p>
<p>　　<a href="Features/NPL.zh-CN.html#npla1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80">NPLA1</a> 是 NPLA 的一个派生实现。</p>
<h2 id="npla-领域语义支持"><a class="header" href="#npla-领域语义支持">NPLA 领域语义支持</a></h2>
<ul>
<li>位(bit) ：表示二进制存储的最小单位，具有 0 和 1 两种状态。</li>
<li>字节(byte) ：<a href="Features/NPL.zh-CN.html#%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2">基本字符集</a>中一个字符需要的最少的存储空间，是若干位的有序集合。</li>
<li>八元组(octet) ：8 个位的有序集合。</li>
</ul>
<h2 id="npla-整体约定"><a class="header" href="#npla-整体约定">NPLA 整体约定</a></h2>
<h3 id="npla-实现环境"><a class="header" href="#npla-实现环境">NPLA 实现环境</a></h3>
<p>　　NPLA 使用<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>为 [ISO C++11]（及其之后的向前兼容的版本）的简单实现模型 <a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">NPL-EMA</a> 。</p>
<p>　　以下要求和<a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>一致：</p>
<ul>
<li>一<a href="Features/NPL.zh-CN.html#npla-%E9%A2%86%E5%9F%9F%E8%AF%AD%E4%B9%89%E6%94%AF%E6%8C%81">字节</a>占用的位（至少占用 8 个二进制位）。</li>
<li>作为事件顺序的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">在先发生和在后发生</a>和宿主语言中的定义一致。
<ul>
<li><strong>注释</strong> 为<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>，一般应避免和之后的（受实现支持的）[ISO C++] 版本冲突。</li>
</ul>
</li>
</ul>
<p>　　NPLA 实体的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">内部表示</a>是宿主语言中可表达的数据结构。</p>
<p>　　NPLA 实体的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">外部表示</a>是宿主语言中可通过输入/输出操作处理的数据。</p>
<p>　　除非另行指定，NPLA 使用宿主语言提供的异常作为<a href="Features/NPL.zh-CN.html#%E5%BC%82%E5%B8%B8">异常执行机制</a>。</p>
<p>　　除非另行指定，程序不使用使宿主语言<em>区域指定的行为(locale-specific behavior)</em> 改变的特性。</p>
<p><strong>原理</strong></p>
<p>　　默认避免改变区域指定行为简化设计约定。</p>
<p><strong>注释</strong></p>
<p>　　关于类似的对宿主语言程序的要求，另见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/LanguageConvention.txt"><code>doc/LanguageConvention.txt</code></a> 。</p>
<h3 id="附加功能"><a class="header" href="#附加功能">附加功能</a></h3>
<p>　　NPLA 支持<em>数值(numerical value)</em> ，但不要求支持具体的数值计算。</p>
<p>　　NPLA 实现为派生实现提供<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">数值类型</a>和相关的操作的基本支持。</p>
<p>　　除非另行指定，若派生实现支持数值计算，其实现兼容 <a href="Features/NPL.zh-CN.html#npla-%E6%95%B0%E5%AD%A6%E5%8A%9F%E8%83%BD">NPLA 数学功能</a>的实现。</p>
<h3 id="npla-词法和语法"><a class="header" href="#npla-词法和语法">NPLA 词法和语法</a></h3>
<p>　　词法分析可接受多字节文本编码的字符串形式的源代码，但不假设其编码中除 0（空字符 NUL ）以外的具体代码点被编码的数值，不<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">转换编码</a>。</p>
<p>　　使用可选的语法预处理和 <a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">NPL-GA 语法</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2">字符集</a>的约定同<a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>。</p>
<h3 id="npla-标识符"><a class="header" href="#npla-标识符">NPLA 标识符</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">NPL 标识符</a>外的以下<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">词素</a>也是 NPLA 标识符：</p>
<ul>
<li>在构成 NPL 标识符的词素中插入有限个非 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">NPL 分隔符</a>的字符且不构成 <a href="Features/NPL.zh-CN.html#npla-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F">NPLA 扩展字面量</a>的词素。</li>
<li>全由 <code>+</code> 或 <code>-</code> 构成的词素。</li>
</ul>
<h3 id="npla-扩展字面量"><a class="header" href="#npla-扩展字面量">NPLA 扩展字面量</a></h3>
<p>　　NPLA <a href="Features/NPL.zh-CN.html#%E5%AD%97%E9%9D%A2%E9%87%8F">扩展字面量</a>包括：</p>
<ul>
<li>以 <code>#</code> 、<code>+</code> 或 <code>-</code> 起始的但不全是 <code>+</code> 或 <code>-</code> 构成的、长度大于 1 的词素。</li>
<li>十进制数字字符起始的词素（当被支持时）。</li>
</ul>
<p>　　全由十进制数字字符的词素表示十进制<a href="Features/NPL.zh-CN.html#%E9%99%84%E5%8A%A0%E5%8A%9F%E8%83%BD">数值</a>。派生实现可定义其它作为数值的词素。这些词素作为字面量时，是<em>数值字面量(numerical literal)</em> 。</p>
<h3 id="npla-名称和字面量求值"><a class="header" href="#npla-名称和字面量求值">NPLA 名称和字面量求值</a></h3>
<p>　　名称仅被实现为和<a href="Features/NPL.zh-CN.html#%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>的一个真子集一一对应的表示（参见<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">类型映射</a>）。</p>
<p>　　除非派生实现另行指定，只有<a href="Features/NPL.zh-CN.html#%E5%AD%97%E9%9D%A2%E9%87%8F">代码字面量</a>不是<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">自求值表达式</a>，其余字面量都求值为<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">右值</a>。</p>
<p>　　代码字面量求值时解释为名称。</p>
<p>　　数据字面量是自求值的字符串的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">外部表示</a>。</p>
<p>　　数值字面量是自求值的数值的外部表示。</p>
<p>　　存在不保证先求值的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">子表达式</a>的<a href="Features/NPL.zh-CN.html#%E8%AF%AD%E6%B3%95%E5%BD%A2%E5%BC%8F">语法形式</a>是<em>特殊形式(special form)</em> 。</p>
<p>　　特定的名称是<em>保留名称(reserved name)</em> 。</p>
<p>　　除非另行指定，在<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源代码</a>中使用保留名称作为实体的名称的程序<a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">行为未定义</a>。</p>
<h3 id="npla-求值的表示"><a class="header" href="#npla-求值的表示">NPLA 求值的表示</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">规范形式</a>是特定<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型</a>的 [ISO C++] 对象。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>失败可被忽略而不<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">终止</a>实现演绎；保证名称表达式求值的<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">强规范化</a>。</p>
<p>　　不要求提供<a href="Features/NPL.zh-CN.html#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">命名空间</a>实现的可变实体。</p>
<p>　　不保证求值都是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>；非<a href="Features/NPL.zh-CN.html#npla-%E5%90%8D%E7%A7%B0%E5%92%8C%E5%AD%97%E9%9D%A2%E9%87%8F%E6%B1%82%E5%80%BC">特殊形式</a>使用<a href="Features/NPL.zh-CN.html#%CE%BB-%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">热情求值</a>；其它情形使用热情求值或<a href="Features/NPL.zh-CN.html#%CE%BB-%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">惰性求值</a>的方式由具体特殊形式约定。</p>
<p>　　对象语言的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数</a>默认为<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">过程</a>，过程默认实现为<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E7%9A%84%E8%AE%A1%E7%AE%97%E9%A1%BA%E5%BA%8F">子例程</a>。过程指定的计算结果和函数表达式<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">最终求值结果</a>的<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">关联</a>是<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">过程调用</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">结果</a>的恒等映射。</p>
<p><strong>注释</strong> 即过程调用的结果总是同函数值。</p>
<p>　　除非另行指定，实现<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数</a>的宿主数据结构<a href="Features/NPL.zh-CN.html#npla-%E5%9F%BA%E7%A1%80%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">生存期要求</a>默认同<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>。</p>
<p>　　除非另行指定，<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值传递</a>支持<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96">复制初始化</a>对象的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E4%BD%9C%E7%94%A8">一等作用</a>。</p>
<p><strong>原理</strong></p>
<p>　　NPLA 函数不支持类似 [ISO C++] 的类型退化(decay) 。作为动态类型语言，需要被转换的值在<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作</a>内部实现，不需要在<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>上另行附加转换。</p>
<p>　　按值传递的复制初始化和宿主语言的对应语义类似。</p>
<h3 id="npla-类型系统"><a class="header" href="#npla-类型系统">NPLA 类型系统</a></h3>
<p>　　NPLA 使用<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">隐式类型</a>而非<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">显式类型</a>。</p>
<p>　　NPLA 使用<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">潜在类型</a>：<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>具有类型；不指定<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">动态类型</a>以外的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">显式类型（如清单类型）</a>的机制可由派生实现指定可选地引入。<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>也可能添加类型标注和不同的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">类型机制</a>的支持。</p>
<p>　　除非派生实现另行指定，引入的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态类型</a>应和<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">动态类型</a>一一对应。</p>
<p>　　NPLA 使用和<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>相容的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">动态类型检查</a>。除非派生实现另行指定或<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">类型映射</a>的需要，使用的类型检查规则和宿主语言一致。</p>
<p>　　宿主语言对象的值描述状态，且宿主语言要求的对 <code>volatile</code> 左值的操作属于<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>。</p>
<h2 id="npla-互操作支持"><a class="header" href="#npla-互操作支持">NPLA 互操作支持</a></h2>
<p>　　NPLA 的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>应能提供 NPLA 及派生实现的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">本机实现</a>。</p>
<p>　　NPLA 的派生实现提供特定的和宿主语言的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>支持，可其中和 NPLA 提供的关于互操作的具体行为不同的部分应由实现定义。</p>
<p><strong>注释</strong> 对派生实现，NPLA 约定的具体默认互操作特性是可选的。但是，一般的约定如<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">开放类型系统</a>仍被要求。</p>
<p>　　NPLA 和派生实现可约定互操作的具体实现的要求，以确保实现的状态可预测。</p>
<p>　　本机实现可以具有 C++ 的实现兼容的二进制接口的函数提供，这些函数称为<em>本机函数(native function)</em> 。</p>
<p>　　本机实现可直接支持本机函数在实现中被调用。若被支持，具体接口由派生实现指定。</p>
<p>　　本机函数作为函数的实现，其调用的求值可具有和非本机的函数一致的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">作用</a>，但不需要具有可被对象语言表达的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数体</a>。</p>
<p>　　为确保函数求值的作用可能保持一致，本机函数应符合和本机函数调用时使用的规约一致的方式使用，即在宿主语言的意义上至少符合以下规约<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">调用约定</a>：</p>
<ul>
<li>被调用时的子项被作为以 <a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">WHNF</a> 形式表示的被调用的表达式使用。</li>
<li>调用后具有项被重写为必要的值以表示<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>。</li>
</ul>
<p>　　本机函数的返回值应能表达任意的非本机函数调用的返回值，即通过求值函数调用中函数体的非本机函数的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>。</p>
<p><strong>原理</strong></p>
<p>　　<a href="Features/NPL.zh-CN.html#npla-%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83">实体的内部表示和外部表示满足实现环境的要求</a>允许在宿主语言程序中直接实现关于<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>的操作，简化了互操作机制的设计和实现。</p>
<p><strong>注释</strong></p>
<p>　　宿主语言自身的调用约定（通常和实现的 <a href="Features/NPL.zh-CN.html#%E8%A1%A5%E5%85%85%E9%A2%86%E5%9F%9F%E5%AE%9A%E4%B9%89">ISA</a> 相关）作为 C++ 实现自身的 <a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">ABI</a> ，在此是中立的，没有提供特设的支持的要求。</p>
<p>　　另见 <a href="Features/NPL.zh-CN.html#npla-%E5%9F%BA%E7%A1%80%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">NPLA 基础存储和对象模型</a>。</p>
<h3 id="类型映射"><a class="header" href="#类型映射">类型映射</a></h3>
<p>　　<em>类型映射(type mapping)</em> 指定对象语言和宿主语言之间的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%9E%8B">实体类型</a>之间的关系，是前者中的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型</a>到后者中的类型的映射。</p>
<p>　　作为类型映射目标的宿主语言类型或其<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>称为<em>宿主类型(hosted type)</em> 。</p>
<p>　　作为宿主语言类型的宿主类型是典型的。其它宿主类型是非典型的。</p>
<p>　　具有特定<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">动态类型</a>的对象语言的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>在宿主语言具有宿主类型，以宿主语言的值表示，称为<em>宿主值(hosted value)</em> 。</p>
<p>　　在<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>的意义上，宿主值在作为对象语言的值的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>中以<em>宿主对象(hosted object)</em> 的形式被保存并可在宿主语言中访问。</p>
<p>　　对象语言的值被对象语言的实体类型表示蕴含它被映射的宿主类型表示，反之亦然。</p>
<p>　　类型映射可以是非空的多对一、一对多或一一映射。</p>
<p>　　若类型映射是一一映射，其类型等价性同宿主语言的语义规则；否则，由类型的语义规则约定。</p>
<p>　　因需提供与作为宿主语言的 [ISO C++] 的互操作支持，所以明确约定实现中部分实体类型对应的 C++ 类型：</p>
<ul>
<li>用于条件判断的单一值的宿主类型是 <code>bool</code> 。</li>
<li><a href="Features/NPL.zh-CN.html#%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a>的宿主类型都是 <code>string</code> 类型。</li>
<li>和字符串的子集一一对应的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">词素</a>的宿主类型是能映射到 <code>string</code> 的另一种类型。</li>
</ul>
<p><strong>注释</strong> <code>string</code> 是占位符，不要求是和 <a href="https://eel.is/c++draft/string.classes#basic.string">[ISO C++] 的 <code>std::basic_string</code></a> 相关的类型。但一般地，<code>string</code> 类型应具有和 <code>std::string</code> 相近的操作以便实现对象语言语义及支持互操作。</p>
<p>　　推论：字符串和词素可直接比较相等性或排序。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E9%99%84%E5%8A%A0%E5%8A%9F%E8%83%BD">NPLA 数值</a>在对象语言中具有<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">数值类型</a>，具体类型映射未指定，但在 NPLA 数学功能提供可选实现。派生实现可显式扩充或替换定义其它数值类型的类型映射。</p>
<p>　　其它宿主类型<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">由实现定义</a>。具体宿主类型参见以下各节和对象语言类型对应的描述。</p>
<p>　　宿主类型在对应的 C++ <a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 中可能以类型别名的形式引入。</p>
<p><strong>原理</strong></p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">类型系统</a>是<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%85%A8%E9%9B%86">开放</a>的，可能提供不被对象语言支持的宿主语言类型和值。</p>
<p>　　但符合已指定的类型的实体需能被视为同种类型的实体使用，即子类型。</p>
<p><strong>注释</strong></p>
<p>　　非典型的宿主类型可以是特定的宿主类型的值的子集，即便这样的类型不被宿主语言的类型系统直接表示。</p>
<p>　　不被对象语言支持的值的一个例子是实现使用的<em>中间值(thunked value)</em> 。</p>
<p>　　关于中间值、<code>string</code> 类型的具体要求、NPLA 数学功能的规格说明和由实现定义的命名空间，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h2 id="npla-未定义行为"><a class="header" href="#npla-未定义行为">NPLA 未定义行为</a></h2>
<p>　　一般地，NPLA 规则不排除<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未定义行为</a>。其中，<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>的未定义行为是非特定体系结构或其它 [ISO C++] 意义上不可预测或不可移植的行为。</p>
<p>　　除非派生实现另行指定，NPLA 约定仅有具有以下情形的程序引入未定义行为：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>中引起宿主语言的未定义行为或不满足<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">约定的要求</a>而可能引入派生实现定义的未定义行为。
<ul>
<li><strong>注释</strong> 例如，<a href="Features/NPL.zh-CN.html#npla-%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE">没有被支持的并发访问</a>引起宿主语言的未定义行为。</li>
</ul>
</li>
<li><a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>无法提供资源而引起宿主语言的未定义行为（如宿主语言的实现无法提供宿主语言函数调用的自动对象隐式使用的资源）。</li>
<li>违反<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">资源所有权语义</a>约束的操作，包括但不限于：
<ul>
<li>违反<a href="Features/NPL.zh-CN.html#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>的操作。
<ul>
<li><strong>注释</strong> 例如，违反按<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象和关联对象所有权</a>的推论不能确保满足<a href="Features/NPL.zh-CN.html#npla-%E5%9F%BA%E7%A1%80%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">生存期要求</a>的操作。</li>
</ul>
</li>
<li>除非另行指定，构造任意的循环引用。</li>
</ul>
</li>
<li>使用特定的词法构造。</li>
</ul>
<p>　　除非派生实现另行指定，NPLA 约定：</p>
<ul>
<li>若程序的执行蕴含宿主语言中不保证排除未定义行为的操作，执行可包含宿主语言的未定义行为。</li>
<li>否则，非互操作引入的<a href="Features/NPL.zh-CN.html#%E7%AE%A1%E7%90%86%E8%A7%84%E7%BA%A6">管理规约</a>可能存在未定义行为，当且仅当它是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值规约</a>的一部分且求值规约可能存在未定义行为。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　满足<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">错误条件</a>的程序可能<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起错误</a>，也可引起未定义行为而不要求引起错误。这允许减少实现的复杂性。</p>
<p>　　对宿主语言的未定义行为的单独处理允许描述互操作。</p>
<p>　　程序的执行允许宿主语言的未定义行为，同时允许形式上不可靠，但仍可通过宿主的外部环境提供附加保证的实现，而保留可实现性：</p>
<ul>
<li>典型地，宿主语言不保证调用的活动记录总是可用。
<ul>
<li>例如，[ISO C++] 指定程序在自动对象无法分配时具有未定义行为。</li>
<li>这种情形形式上无法排除，但不影响实用（否则，任意 [ISO C++] 程序都是不可移植的）。</li>
</ul>
</li>
<li>实现仍应保守使用资源，以尽可能地避免引起宿主语言的未定义行为。</li>
<li>通过宿主的外部提供附加保证的实现类似保证为<a href="Features/NPL.zh-CN.html#%E5%AE%8C%E6%95%B4%E6%80%A7">完整性</a>的前提下通过加入附加的限制来使设计符合要求。</li>
</ul>
<p>　　对管理规约的约定同时蕴含对 NPLA 实现的要求。这保证未定义行为不会被任意地在对象语言以外被引入。</p>
<p><strong>注释</strong></p>
<p>　　为简化互操作实现，部分 NPLA 未定义行为可能在实现中被检查以预防（尽可能避免）宿主语言的未定义行为，但这种检查不保证完全覆盖所有引起未定义行为的条件，不应预期其行为可移植。</p>
<p>　　关于构造循环引用可能引起的问题，另见<a href="Features/NPL.zh-CN.html#%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F">内存泄漏</a>。</p>
<h3 id="常规宿主资源分配要求"><a class="header" href="#常规宿主资源分配要求">常规宿主资源分配要求</a></h3>
<p>　　一般地，本机实现要求资源分配失败时，引起（可能派生）<code>std::bad_alloc</code> 或另行指定的宿主异常而非宿主语言的未定义行为；但因为宿主语言缺乏保证，可能并非所有宿主语言实现都能保证实现这项特性。</p>
<p>　　实际的实现中非极端条件下（如宿主调用栈接近不可用）通常可支持实现这些行为。</p>
<p>　　宿主语言实现支持时，具有可预期的失败（而 NPLA 或宿主语言的非未定义行为）的 NPLA 实现的要求称为常规宿主资源分配要求。</p>
<h3 id="嵌套调用安全"><a class="header" href="#嵌套调用安全">嵌套调用安全</a></h3>
<p>　　宿主语言的 <a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 提供<em>嵌套调用安全(nested call safety)</em> ，当且仅当：</p>
<p>　　若调用没有宿主语言无法分配资源的未定义行为，则同时避免因宿主语言的嵌套调用<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">深度</a>过大时引起的这样的未定义行为。</p>
<p>　　嵌套调用安全应包括支持可能通过对象语言构造的输入使对应宿主语言的操作中的嵌套调用不保证的情形。</p>
<p>　　对象语言的实现可假定限制避免无限创建<a href="Features/NPL.zh-CN.html#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">活动记录</a>即满足嵌套调用安全的要求。</p>
<p><strong>原理</strong></p>
<p>　　嵌套调用安全允许不限制嵌套深度的可靠的调用，如递归调用。</p>
<p>　　宿主语言实现在宿主语言的<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">尾上下文</a>可能支持<a href="Features/NPL.zh-CN.html#tco-%E5%AE%9E%E7%8E%B0%E7%AD%96%E7%95%A5%E6%A6%82%E8%BF%B0">宿主 TCO</a> 而使递归调用满足嵌套调用安全，但这并不是语言提供的保证，不应在可移植的实现中依赖。</p>
<p>　　[ISO C++] 并没有明确指定关于深度的限制，嵌套调用可能因资源耗尽而引起未定义行为。</p>
<p>　　严格来说，这种未指定深度是可移植性上的缺陷，因为任意小的深度的调用（甚至深度为 1 的非嵌套调用）都可引起未定义行为而不需要遵循任何 [ISO C++] 的要求，却仍然满足实现的<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">符合性</a>。</p>
<p>　　[ISO C] 也有相同的问题。</p>
<p>　　实际实现中，具体深度限制依赖实现。在宿主语言缺乏保证的状况下，添加附加假定对可实现性是必要的。</p>
<p><strong>注释</strong></p>
<p>　　对应宿主语言的操作中的嵌套调用不保证的情形的主要例子是保证<a href="Features/NPL.zh-CN.html#%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%AB%8B">宿主语言中立</a>。</p>
<p>　　非嵌套调用安全的情形在过程嵌套调用深度过大时，可因为宿主语言的存储资源消耗导致的宿主语言实现的未定义行为，典型地包括实现中的<em>栈溢出(stack overflow)</em> 。</p>
<p>　　不限深度的重入不一定引起无限的活动记录的创建：<a href="Features/NPL.zh-CN.html#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C-ptc">尾调用</a>应能保证嵌套调用安全。</p>
<h3 id="npla-并发访问"><a class="header" href="#npla-并发访问">NPLA 并发访问</a></h3>
<p>　　当前所有 NPLA 实现中都没有显式的<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">并发</a>访问控制，但可通过互操作引入。</p>
<p><strong>注释</strong></p>
<p>　　一般地，为避免并发访问引起的宿主语言的未定义行为，需要通过本机实现在外部使用不同的资源实例或附加适当的同步。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E5%AE%89%E5%85%A8">并发访问安全</a>。</p>
<h2 id="npla-一等对象类型"><a class="header" href="#npla-一等对象类型">NPLA 一等对象类型</a></h2>
<p>　　除<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">类型映射</a>，NPLA 约定能作为一等对象的类型支持的抽象的类型，作为实现的最小要求的一部分。</p>
<p>　　以下章节扩充 NPLA 的其它类型，这些类型中的一部分可能作为一等对象。</p>
<p>　　基于<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">开放类型系统</a>，派生实现可定义其它类型，不论是否被<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>支持。</p>
<p><strong>原理</strong></p>
<p>　　这些类型在<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>等规则的描述中适用。</p>
<h3 id="有序对"><a class="header" href="#有序对">有序对</a></h3>
<p>　　两个不同对象可作为<em>元素(element)</em> 构成<em>有序对(ordered pair, pair)</em> 。</p>
<p>　　有序对的元素是<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>。</p>
<p>　　当且仅当若有序对的两个元素不同，交换元素得到的有序对和原有序对不同。</p>
<p><strong>注释</strong></p>
<p>　　一些编程语言中，构造有序对的操作称为 <code>cons</code> ，有序对又称为 cons 对。</p>
<h3 id="广义列表"><a class="header" href="#广义列表">广义列表</a></h3>
<p>　　<em>列表(list)</em> 一种<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型</a>，它的对象可能具有<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>。</p>
<p>　　<em>空列表(empty list)</em> 是不含有子对象的列表。其它列表是<em>非空(nonempty)</em> 列表。</p>
<p>　　每个非空列表是一个<a href="Features/NPL.zh-CN.html#%E6%9C%89%E5%BA%8F%E5%AF%B9">有序对</a>对象，满足：</p>
<ul>
<li>有序对对象的第一个元素是列表的元素。</li>
<li>若有序对对象的第二个元素是有序对，则这个有序对对象的第一个元素是列表的元素；否则，最后一个不是有序对对象的子对象是列表的元素。</li>
</ul>
<p><strong>注释</strong> 推论：同一个列表的元素不是另一个元素的子对象；不同元素之间不具有所有权，生存期不相交。</p>
<p>　　从非空列表对象中取得元素<em>分解(decompose)</em> 列表对象。若经有限次分解，不再可取得列表对象的元素，则列表对象被完全分解。</p>
<p>　　完全分解的列表的最后一个元素之外的其它元素是列表的<em>前缀(prefix)</em> 元素。</p>
<p>　　对象具有前缀元素，当且仅当对象是列表且具有前缀元素。</p>
<p>　　<em>真列表(proper list)</em> 是空列表，或能经完全分解得到最后元素是空列表的列表。其它列表是<em>非真列表(improper list)</em> 。</p>
<p><strong>注释</strong> 推论：非真列表是非空列表。</p>
<p>　　<em>广义列表(generalized list)</em> 是真列表或非真列表。</p>
<p>　　广义列表的元素是<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>。广义列表对元素具有所有权。</p>
<p>　　广义列表是完全分解的元素的<em>序列(sequence)</em> 。</p>
<p>　　作为广义列表的非真列表是<em>无环的(acyclic)</em> ，不包含<em>环(cycle)</em> 。</p>
<p><strong>注释</strong> 同一般的 NPL 约定，NPLA 对象不支持<a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">自引用和循环数据结构</a>。</p>
<p>　　除非另行指定，以下列表指真列表。</p>
<p>　　<em>子有序对(subpair)</em> 是一个有序对完全分解的序列中的元素的真子集构成的子对象。</p>
<p>　　<em>子列表(sublist)</em> 是一个列表中的元素的真子集构成的列表子对象。</p>
<p><strong>注释</strong></p>
<p>　　无环非真列表和真列表类似，可通过 <code>cons</code> 逐次构造。</p>
<p>　　非列表的有序对的元素可能具有自引用，而不是广义列表的元素，因此不是广义列表。NPLA 的一等对象不支持这种情形。</p>
<h3 id="符号"><a class="header" href="#符号">符号</a></h3>
<p>　　<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80"><em>符号(symbol)</em></a> 是未被求值的非<a href="Features/NPL.zh-CN.html#%E5%AD%97%E9%9D%A2%E9%87%8F">字面量</a><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">记号</a>的类型。</p>
<p>　　符号值可构成<a href="Features/NPL.zh-CN.html#%CE%BB-%E5%AE%8C%E5%A4%87%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AF%B9%E5%BA%94%E8%AF%AD%E6%B3%95">名称表达式</a>。</p>
<h2 id="存储和对象模型"><a class="header" href="#存储和对象模型">存储和对象模型</a></h2>
<p>　　NPLA 使用统一的模型对存储和<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">对象</a>进行抽象，并提供关于存储、对象和作为对象的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>以及<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">子项</a>的若干保证。</p>
<p>　　对象语言的存储被视为资源进行管理，称为<em>存储资源(memory resource)</em> 。</p>
<p><strong>原理</strong></p>
<p>　　语言中<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">默认不引入非一等对象</a>。因此，存储和对象模型作用到所有实体，有助于保持<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>。</p>
<p><strong>注释</strong></p>
<p>　　一等对象的使用可能受到其它规则的限制，不总是能同时通过对象语言的构造创建和访问。</p>
<p>　　NPL <a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">允许派生实现引入实体的规则</a>不受限制。</p>
<h3 id="npla-基础存储模型和对象模型"><a class="header" href="#npla-基础存储模型和对象模型">NPLA 基础存储模型和对象模型</a></h3>
<p>　　因需提供<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a><a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作支持</a>，除不支持<em>静态(static)</em> 存储和没有提供支持的存储操作外，NPLA 的基础存储模型和对象模型和 [ISO C++11] 相同。</p>
<p>　　当前不支持的存储操作包括<em>分配函数(allocation function)</em> 取得的存储和<em>线程局部(thread-local)</em> 存储。</p>
<p>　　NPLA 还允许类似对象具有未指定的存储或不需要存储的实体，以使<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E8%AF%AD%E4%B9%89">一等实体</a>可涵盖宿主语言在功能上等价的非对象类型（如 C++ 的引用）。这些实体若被支持，其存储实现和互操作接口由派生实现定义。</p>
<p>　　NPLA 中不是<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">一等实体</a>仅由派生实现定义。</p>
<p>　　保证存储性质的差异不被依赖时，不区分一等实体和一等对象的实现方式。</p>
<p>　　在此情况下对象都是<em>固定(pinned)</em> 的，即对象在<em>存储期(storage duration)</em> 内具有宿主语言意义上的确定不变的地址。派生实现可约定扩展作为例外。</p>
<p>　　推论：若一等实体不是一等对象，存储可能和一等对象的存储方式不同。派生实现可在必要时约定与其它一等实体存储的差异。</p>
<p>　　对象的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>是存储期的子集。创建对象基于已确保可访问的存储；销毁对象结束后释放存储。</p>
<p>　　NPLA <a href="Features/NPL.zh-CN.html#%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">支持特定的非一等对象</a>作为<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>。</p>
<p><strong>注释</strong> 和宿主语言类似。</p>
<p>　　作为一等对象相同方式传递的一等实体都视为一等对象。仅当不依赖一等对象的性质时，实现以<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>的方式实现一等实体的操作。</p>
<p><strong>原理</strong></p>
<p>　　<a href="Features/NPL.zh-CN.html#npla-%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83">实体的内部表示满足实现环境的要求</a>决定和 NPLA 和宿主语言之间共享一些基本的假定。</p>
<h3 id="间接值"><a class="header" href="#间接值">间接值</a></h3>
<p>　　特定的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>是<em>间接值(indirect value)</em> 。</p>
<p>　　间接值可以<em>关联(associated)</em> 一个对象。通过间接值可以间接<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>这个对象。</p>
<p>　　间接值可能是<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>或<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>。</p>
<p>　　非一等对象的间接值由实现定义，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p>　　派生实现可以定义其它间接值，称为 NPLA 扩展间接值。</p>
<p>　　一个间接值<em>有效(valid)</em> ，当且仅当存在关联的对象且访问对象不引起<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未定义行为</a>。</p>
<p>　　其它间接值是<em>无效(invalid)</em> 的。</p>
<p>　　除非另行指定，通过无效的间接值试图间接访问关联的对象不满足<a href="Features/NPL.zh-CN.html#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>而引起未定义行为。</p>
<p>　　有效的引用值可能被<em>无效化(invalidate)</em> 而不再有效。</p>
<p>　　派生实现可指定能使间接值无效化的操作。</p>
<p>　　因关联的对象<a href="Features/NPL.zh-CN.html#npla-%E5%9F%BA%E7%A1%80%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">存储期</a>结束而被无效化的间接值是<em>悬空(dangling)</em> 的。</p>
<p><strong>原理</strong></p>
<p>　　间接值可用于代替非间接值，避免求值时改变<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境</a>所有的非<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">所有权</a>。</p>
<p>　　间接值可实现和 [ISO C++] 引用类型的表达式类似的行为。</p>
<p>　　间接访问默认没有对象的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>检查，因此不是安全的。这可能被具体的间接值的规则改变。</p>
<p>　　限制具体的操作能避免或减少在可能访问间接值的操作随意引入具有潜在未定义行为风险。</p>
<p><strong>注释</strong></p>
<p>　　作为一等对象的间接值可能允许复制或转移关联的对象以恢复对应的非间接值作为一等对象直接访问。</p>
<p>　　在<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">使用约定</a>后，本节以下约定要求被 NPLA 实现支持作为一等对象的间接值。非一等对象的间接值由实现定义。派生实现可以定义其它的 NPLA 扩展间接值。</p>
<h4 id="间接值使用约定"><a class="header" href="#间接值使用约定">间接值使用约定</a></h4>
<p>　　间接值生存期规则：被规约对象中间接值的生存期被引用的环境中的对象的生存期的子集。</p>
<p>　　不满足间接值生存期规则的情形，除非提供派生实现定义的其它保证，不保证<a href="Features/NPL.zh-CN.html#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>。</p>
<p>　　以含间接值的项替代不含间接值的项，称为<em>引入(introduce)</em> 间接值。</p>
<p>　　包含间接值的项可被不含引用值的项替代，称为<em>消除(eliminate)</em> 间接值。</p>
<p>　　在特定的适当情形下实现应复制或转移间接值关联的对象以保证<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">满足生存期要求</a>，包括：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%B1%80%E9%83%A8%E9%97%B4%E6%8E%A5%E5%80%BC%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">局部间接值安全保证</a>描述的操作，包括<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>。</li>
<li>为<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>目的，实现定义的其它情形。</li>
<li>派生实现可能定义的其它情形。</li>
</ul>
<p>　　除非另行指定<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起错误</a>，若不能满足上述适当情形条件，则<a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">行为未定义</a>。</p>
<p>　　派生实现可基于本节约定其它规则。</p>
<p><strong>原理</strong></p>
<p>　　为保证间接访问关联对象的内存安全，约定间接值生存期规则。</p>
<p>　　参见局部间接值安全保证和返回值转换。</p>
<p><strong>注释</strong></p>
<p>　　如需直接<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">替换项</a>表示的值，需消除间接值。否则，没有必要提前对项进行操作以提前移除间接值。</p>
<p>　　关于实现定义和派生实现定义的其它情形，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p>　　另见被求值的<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">被规约项中的对象的所有权</a>。</p>
<h4 id="环境间接值"><a class="header" href="#环境间接值">环境间接值</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境引用</a>间接访问<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境对象</a>。</p>
<h4 id="引用间接值"><a class="header" href="#引用间接值">引用间接值</a></h4>
<p>　　<em>项引用(term reference)</em> 作为间接值引用一个项，访问这个以这个项作为表示的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>作为关联对象。</p>
<p>　　项引用具有<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">标签</a>。</p>
<h3 id="求值和对象所有权"><a class="header" href="#求值和对象所有权">求值和对象所有权</a></h3>
<p>　　被求值的表达式的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">内部表示</a>中的对象具有 NPLA 对象的<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权</a>。</p>
<p>　　这些内部表示包括<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境对象</a>或<a href="Features/NPL.zh-CN.html#npla-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E4%B9%89">被求值的表达式中的项</a>的情形。</p>
<p>　　对象是表示它的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">被规约项</a>的<em>项对象(term object)</em> 。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">NPLA 临时对象</a>的存储未指定，但<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">部分临时对象被项所有</a>。</p>
<p>　　求值结束而不被使用的项的资源在求值终止时被释放，包括被项独占所有权的这些临时对象。</p>
<p>　　求值终止包括可被实现确定的<a href="Features/NPL.zh-CN.html#%E5%BC%82%E5%B8%B8">异常</a>退出。</p>
<p>　　对名义上被项所有的临时对象，必要时实现可分配内部存储转移项（包括在环境中分配），以满足附加要求（如<a href="Features/NPL.zh-CN.html#%E7%94%9F%E5%AD%98%E6%9C%9F%E9%99%84%E5%8A%A0%E7%BA%A6%E5%AE%9A">生存期附加约定</a>）。</p>
<p>　　对象的所有权随可随对象被转移，参见<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">对象的复制和转移</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>可以是：</p>
<ul>
<li>作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值计算</a>的结果的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>，称为<em>结果对象(result object)</em> 。</li>
<li>传递异常的状态的实体。</li>
<li>派生实现可定义的其它实体。</li>
</ul>
<p><strong>注释</strong> 按<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值规约</a>，其它的求值结果的存在未指定，若存在则可能需要其它处理，可能依赖和处理一等对象的值不同的语义规则。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>时以<a href="Features/NPL.zh-CN.html#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">活动记录</a>保持<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的所有权。活动记录及其帧的具体结构、维护方式和生存期由派生实现定义。</p>
<p>　　除非另行指定，NPLA 只有一种<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">作用域</a>，这种作用域中的名称由<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">环境</a>提供。</p>
<p>　　除非另行指定，NPLA 的活动记录不需要和<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>的结构保证直接对应关系。</p>
<p><strong>原理</strong></p>
<p>　　因为宿主语言函数调用实现（典型地，<em>调用栈(call stack)</em> 及其中的栈帧）不提供可移植的<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>，不要求实现提供活动记录之间的映射关系。</p>
<p><strong>注释</strong></p>
<p>　　临时对象的存储未指定、异常退出和所有权转移类似宿主语言。</p>
<p>　　结果对象和 [ISO C++17]（由提案 [WG21 P0135R1] 引入）中的概念对应。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境对象</a>和<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境引用</a>对其中的对象的所有权。</p>
<h4 id="项对象和关联对象所有权"><a class="header" href="#项对象和关联对象所有权">项对象和关联对象所有权</a></h4>
<p>　　仅在<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">泛左值</a>中允许引入可能访问关联对象的间接值。</p>
<p>　　推论：泛左值的项对象和它作为间接值可关联的对象（若存在）不是临时对象，被环境所有。</p>
<p>　　通常纯右值作为其它项的子项而被独占所有权，求值时可能通过<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">临时对象实质化转换</a>标识创建的<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%A8%E7%A4%BA">表示临时对象的项</a>被纯右值所有，也间接被其它项所有。</p>
<p>　　特定的纯右值可能被<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">环境</a>所有，但应只通过复制等方式访问其值而不依赖所有权关系。</p>
<p>　　关于实现中项的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>和构成以及纯右值被环境所有的例子，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　基于<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>的性质，为保证<a href="Features/NPL.zh-CN.html#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>，避免非预期地超出存储期的间接值访问，限制引入间接值的表达式的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">值类别</a>。</p>
<p>　　因<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%A8%E7%A4%BA">临时对象可能具有和一等对象不同的表示</a>，在此特设规则约定。</p>
<h3 id="并发访问安全"><a class="header" href="#并发访问安全">并发访问安全</a></h3>
<p>　　蕴含按<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机语义</a>不等价副作用的并发的访问是<em>冲突的(conflict)</em> 。</p>
<p>　　不共享相同的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制状态</a>的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">无序</a>的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">规约事件</a>是<em>潜在并发的(potentially concurrent)</em> 。</p>
<p>　　若程序包含<a href="Features/NPL.zh-CN.html#%E4%BD%9C%E7%94%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99">蕴含</a>冲突的作用的潜在并发的求值，且这些求值之间没有附加的<em>数据竞争避免(data race avoidence)</em> 保证，程序的执行包含<em>数据竞争(data race)</em> ，不满足并发访问的内存安全。其中，以下机制数据竞争避免保证：</p>
<ul>
<li>所有潜在并发的求值都是宿主实现提供的<em>原子操作(atomic operation)</em> 时，避免数据竞争。</li>
<li>派生实现另行指定的数据竞争避免机制。</li>
</ul>
<p>　　并发访问相关的概念和 [ISO C++11] 相容。</p>
<h3 id="内存安全"><a class="header" href="#内存安全">内存安全</a></h3>
<p>　　（非并发）<em>内存安全(memory safety)</em> 是存储资源避免特定类型不可预测错误使用的性质。</p>
<p>　　基本的内存安全保证蕴含非<a href="Features/NPL.zh-CN.html#npla-%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE">并发访问</a>时不引入<a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">未定义行为</a>。这至少满足：</p>
<ul>
<li>对存储的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>总是在提供存储的对象的存储期内，除非有其它另行指定的机制（如<a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>的<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>）保证存储的访问不违反其它语义规则。</li>
<li>宿主环境中不访问未被初始化的值。</li>
</ul>
<p><strong>注释</strong> 实现仍可能因其它规则引起未定义行为；特别地，这包括<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>无法提供资源的未定义行为。</p>
<p>　　派生实现可能扩展内存安全，提供语言规则避免非预期的内存访问错误，提供更一般的高级<em>安全(security)</em> 保证。</p>
<p><strong>注释</strong> 例如，<em>保密性(secrecy)</em> 和<em>完整性(integrity)</em> 。</p>
<p>　　除非另行指定，派生实现不提供扩展的内存安全保证。</p>
<p>　　不满足<a href="Features/NPL.zh-CN.html#%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E5%AE%89%E5%85%A8">并发访问安全</a>的访问是非内存安全的。</p>
<p><strong>原理</strong></p>
<p>　　关于内存安全含义的讨论，另见<a href="https://arxiv.org/abs/1705.07354">这里</a>。</p>
<p><strong>注释</strong></p>
<p>　　用户代码应注意避免违反内存安全的访问，包括非并发的，以及并发访问的内存冲突。</p>
<h4 id="非内存安全操作"><a class="header" href="#非内存安全操作">非内存安全操作</a></h4>
<p>　　非内存安全操作是不保证内存安全的操作，在对象语言中即可能引起违反内存安全。</p>
<p>　　这些操作违反内存安全时，引起 <a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">NPLA 未定义行为</a>，且可能未被实现检查而同时引起<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>的未定义行为。</p>
<p>　　对象语言中的非内存安全特性可能直接调用这些操作。NPLA 外依赖此类操作的其它操作也具有类似的性质。</p>
<p><strong>注释</strong></p>
<p>　　派生实现或<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>可能使用补充检查等方式避免未定义行为。</p>
<h4 id="npla-对象语言内存安全保证"><a class="header" href="#npla-对象语言内存安全保证">NPLA 对象语言内存安全保证</a></h4>
<p>　　NPLA 中，确定地引入具有<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">非内存安全操作</a>的对象的操作应仅只包括引入特定的<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>或其它派生实现指定类型的值的操作：</p>
<ul>
<li>调用引入不保证内存安全的间接值的 NPLA <a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 。</li>
<li>调用 NPLA 中其它取<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">对象</a>的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">内部表示</a>的值的间接值使之被<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">修改</a>的 API 。</li>
</ul>
<p>　　排除非内存安全操作以及非内存安全的本机实现，NPLA 实现的对象语言提供基本内存安全保证。</p>
<h4 id="npla-内存安全保证"><a class="header" href="#npla-内存安全保证">NPLA 内存安全保证</a></h4>
<p>　　满足 <a href="Features/NPL.zh-CN.html#npla-%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">NPLA 对象语言内存安全保证</a>同时排除引起宿主语言未定义行为的非内存安全的操作，NPLA 实现提供基本内存安全保证。</p>
<p><strong>注释</strong> 宿主语言未定义行为的非内存安全的操作如超出<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>。</p>
<p>　　除非通过接口约束另行指定，使用 NPLA 实现的派生实现应提供相同的保证。</p>
<p><strong>注释</strong> 例如，添加<a href="Features/NPL.zh-CN.html#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A5">断言检查</a>可能改变<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">实现行为</a>。</p>
<h4 id="运行时内存安全检查"><a class="header" href="#运行时内存安全检查">运行时内存安全检查</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">运行时</a>检查可能帮助排查内存安全的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">实现行为</a>。这包括蕴含运行时检查的接口约束（失败时抛出异常或断言）。</p>
<p>　　此外，实现可能提供可选的运行时检查。这些可选的检查帮助排查未定义行为，而不应被程序实现依赖。</p>
<h4 id="局部间接值安全保证"><a class="header" href="#局部间接值安全保证">局部间接值安全保证</a></h4>
<p>　　访问间接值涉及维护<a href="Features/NPL.zh-CN.html#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全保证</a>时，可能需要<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">提升项</a><a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">消除间接值</a>，以移除允许<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">非内存安全访问</a>的间接值。</p>
<p><strong>原理</strong></p>
<p>　　使用<a href="Features/NPL.zh-CN.html#%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5">删除策略</a>实现<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">过程调用</a>时，其中分配的<em>局部(local)</em> 资源随包含资源引用的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>返回可能<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">逃逸</a>。一般的间接值也有类似的逃逸问题。</p>
<p>　　若其<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">关联</a>的对象（如<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">项引用</a>关联的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>）在调用后不再存在，则间接值不再有效，构成<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">悬空间接值</a>。若这些间接值被<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">调用者</a>获取（如被作为<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>传递），继续<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>这个间接值关联的对象非内存安全。</p>
<p>　　为维护内存安全保证，这些情形应被避免，如通过：</p>
<ul>
<li>通过分析调用处的代码证明确保不存在这样的内存不安全访问。</li>
<li>通过间接值的消除移除这些间接值使这种悬空间接值在调用者中自始不存在。</li>
</ul>
<p>　　替代消除间接值的方式包括通过<em>逃逸分析(escape analysis)</em> 替换间接值，这也能减少间接值的访问而提供更优化的实现。例如，通过对<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境中被绑定对象的使用</a>进行逃逸分析提供优化实现。</p>
<p>　　但是，这不在 NPLA 中被要求，因为：</p>
<ul>
<li>逃逸分析需要完整的所有权信息，这需要附加的开销，否则不总是可行（例如涉及跨多个过程的调用）。</li>
<li>对删除策略，逃逸分析也没有提供不可替代的优化。</li>
</ul>
<h3 id="资源泄漏"><a class="header" href="#资源泄漏">资源泄漏</a></h3>
<p>　　<em>资源泄漏(resource leak)</em> 是不能预期地（决定性地）访问之前被分配的资源的情形。</p>
<p>　　<em>内存泄漏(memory leak)</em> 是存储资源的泄漏。</p>
<p>　　强内存泄漏状态是指存在存储无法通过任何途径访问的状态。若存在存储不被任意对象或其它另行指定的代替对象的实体（如<a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>）所有权的传递闭包包含，即所有权依赖<em>不可达(unreachable)</em> ，则存在强内存泄漏。</p>
<p>　　弱内存泄漏是除了强内存泄漏以外的内存泄漏，和具体预期相关。</p>
<p><strong>原理</strong></p>
<p>　　一般意义下，[Cl98] 中定义的任一空间复杂度类都可以作为形式的预期。因为内存作为存储资源被空间复杂度类度量，满足某个空间复杂度类的无<em>空间泄漏(space leak)</em> 蕴含对应的无内存泄漏。</p>
<p>　　弱内存泄漏的预期的可实现性和实现细节相关，因此 NPLA 不指定具体预期。</p>
<h4 id="资源回收策略"><a class="header" href="#资源回收策略">资源回收策略</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">单一作用域</a>内的资源回收有<em>删除(deletion)</em> 和<em>保留(retention)</em> 的策略。</p>
<p>　　NPLA 不限定具体使用的回收策略，但要求应支持：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">释放一等对象时允许具有副作用</a>。</li>
<li>确保副作用作用时机的确定性，即除<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>指定外，不在<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机语义</a>中延迟副作用的起始。</li>
</ul>
<p>　　为简化语义规则同时避免限制特定的可用资源（如系统中剩余的内存）的变化被派生实现抽象为副作用，除非派生实现指定，不对内存使用保留策略，不使内存超出对象<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>。</p>
<p>　　NPLA 要求实现完全避免除用户程序显式管理资源的资源泄漏以外的强内存泄漏。</p>
<p>　　除非另行指定，NPLA 释放资源的作用顺序未指定。NPLA 不依赖释放的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>的顺序。</p>
<p>　　派生实现可以要求使用不同的规则：</p>
<ul>
<li>指定释放资源的顺序。</li>
<li>可选地支持非确定的释放资源的副作用。</li>
</ul>
<p>　　NPLA释放可能具有的副作用顺序的存储资源和其它资源共享更普遍的所有权抽象资源的<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权语义</a>上的操作：</p>
<p>　　使用删除策略时，<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">活动的过程调用</a>对其中分配的资源具有所有权。</p>
<p>　　注意多个对象构成的系统中，仅存在<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">平等的所有权</a>时的<a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>造成强内存泄漏：除非即从循环引用的对象中区分出具有不同类所有权的对象子集实现所有权正规化，总是存在无法被释放资源的对象。</p>
<p>　　NPLA 不要求实现 GC 等机制避免这类循环引用。</p>
<p>　　关于循环引用避免，另见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　NPLA 不要求实现 <a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">GC</a>。</p>
<p>　　未指定的资源释放的作用顺序使其中可能具有的副作用影响的可观察行为成为<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定行为</a>。</p>
<p>　　除非派生实现要求使用不同的规则支持非确定的资源的副作用，NPLA 的实现不依赖不保证确定性释放资源的副作用顺序的<em>追踪(tracing)</em> GC 。这使追踪 GC 可能被可选地添加(opted-in) 到实现支持特性中。这允许自动资源管理机制中一定程度的<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>。[ISO C++11] 起直至 [ISO C++20] ，C++ 语言规则支持类似的策略。</p>
<p>　　资源释放副作用的确定性要求和作用顺序未指定的规则不影响实现使用基于引用计数的 GC 策略。这允许实现以简单的方式以用户程序不直接可见的方式引入共享资源，在避免资源泄漏的意义上兼顾<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>和<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>。但为<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">避免单一所有者</a>，此时在对象语言应提供特性使用户程序可以创建隔离共享者的资源实体。</p>
<p>　　基于非预期的循环引用不可避免地造成实现开销而违反<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>（即使这种开销可能并不总是可观察）NPLA 不要求实现 GC 和对一般对象区分强弱引用等机制避免循环引用。此时，程序应自行避免所有权意义上的<a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>以避免资源泄漏。</p>
<p>　　由于 GC 通常基于具有特定操作的单一资源所有权的所有者的对象池的这一实现特例，不依赖共享所有者的 GC 的设计一般也更容易满足<a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">统一性</a>、<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>和<a href="Features/NPL.zh-CN.html#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99">关注点分离原则</a>。</p>
<p>　　以上规则允许程序中：</p>
<ul>
<li>不依赖释放可能具有的副作用顺序的资源。</li>
<li>使存储资源和其它资源共享基于更普遍的<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权抽象</a>的资源所有权语义的操作的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E4%BD%9C%E7%94%A8">作用</a>，以一致的方式实现资源管理。</li>
</ul>
<p>　　关于不同的资源回收策略（其中一部分可能引起存储空间资源泄漏）的讨论，详见 [Cl98] 。</p>
<p>　　使用所有权抽象活动记录的资源能更好地满足资源管理机制和具体操作的<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7">可复用性</a>和<a href="Features/NPL.zh-CN.html#%E4%BD%9C%E7%94%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99">作用使用原则</a>的要求。</p>
<h4 id="资源回收安全性"><a class="header" href="#资源回收安全性">资源回收安全性</a></h4>
<p>　　派生实现可补充定义规则在资源回收的作用上提供更强的安全保证。</p>
<p><strong>原理</strong></p>
<p>　　内存泄漏是和<a href="Features/NPL.zh-CN.html#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>不同的另一类非预期的问题，表明语言设计、实现或程序存在缺陷。</p>
<p>　　即便不违反内存安全保证，涉及弱化空间复杂度类预期的内存泄漏仍可损害程序的<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>而引起安全(security) 问题。</p>
<p>　　内存泄漏和违反内存安全同属违反特定的存储访问不变量的<em>错误条件(error condition)</em> ，但因为不论在语言还是程序的设计和实现中，避免的机制相当不同，在此被区分对待。</p>
<p>　　即便不扩展规则提供更强的内存安全保证，仅在资源回收的作用上避免错误条件也是有意义的。</p>
<p>　　存在其它语言使用类似的区分内存泄漏和<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">非内存安全</a>的设计，如 [Rust]（详见<a href="https://doc.rust-lang.org/book/second-edition/ch15-06-reference-cycles.html">相关文档</a>）。</p>
<h3 id="子对象"><a class="header" href="#子对象">子对象</a></h3>
<p>　　对象的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">子实体</a>是对象时，子实体是对象的<em>子对象(subobject)</em> 。</p>
<p>　　除非另行指定，子对象及其性质同宿主语言的约定：在宿主语言的表示中表现为子对象的对象语言中的对象，也是对象语言的子对象。</p>
<p>　　对象语言的其它具有子对象的情形由派生实现定义。</p>
<p>　　对象对它的子对象具有平凡的<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权</a>。</p>
<p>　　对象的子对象的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>不<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序</a>对象的生存期起始，对象的子对象的生存期结束不<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">后序</a>对象的生存期结束。</p>
<p>　　对象的子对象的生存期起始后序对象的生存期起始，对象的子对象的生存期结束先序对象的生存期结束。</p>
<p>　　除非另行指定，同一个的对象不同子对象的存储期起始、存储期结束、生存期起始、生存期结束之间分别无序。</p>
<p>　　对象对其存储期和生存期的其它约束和宿主语言相同。</p>
<p>　　对象可通过<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子对象引用</a>关联和与其生存期相关或无关的其它对象。</p>
<p>　　通过子对象访问的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>上的<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">副作用</a>是否蕴含对象上的副作用未指定。</p>
<p>　　关于内部对象，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　子对象不一定支持<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">可修改</a>的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">一等状态</a>。修改子对象可能导致或不导致对象或先前通过相同方式取得的子对象的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">改变</a>。</p>
<p>　　[ISO C++] 通过类型定义具有的隐含的对象布局共享同类对象的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">内部表示</a>。与之不同，为简化<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>表示的项上的操作，子对象之间不一定共享表示。</p>
<p>　　特别地，通过<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E8%A1%A8%E7%A4%BA">子对象引用项</a>访问的对象的子对象之间不一定具有<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>。</p>
<p>　　关于具体表示，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>注释</strong></p>
<p>　　作为支持子对象作为内部对象的逻辑前提，NPLA 不支持<a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>。</p>
<p>　　[ISO C++] 允许 <code>const</code> 成员提供不支持修改的状态。<a href="Features/NPL.zh-CN.html#npla-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F">NPLA 不要求类似的类型系统支持</a>，没有类似的设计。</p>
<h4 id="项的子对象"><a class="header" href="#项的子对象">项的子对象</a></h4>
<p>　　作为对象的子项是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象</a>的子对象。</p>
<p>　　因为子项可以递归地具有子项，项对象作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">数据结构</a>构成<em>树(tree)</em> 。项对象是树的节点，即<em>项节点(term node)</em> 。</p>
<p>　　项节点具有如下互斥的基本分类：</p>
<ul>
<li><em>枝节点(branch node)</em> 或<em>非叶节点(non-leaf node)</em> ：具有子节点的节点。</li>
<li><em>叶节点(leaf node)</em> ：不具有子节点的节点。</li>
</ul>
<p>　　除子项外，项具有<em>值数据成员(value data member)</em> 作为其子对象。</p>
<p>　　表示项对象的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">被规约项</a>的值数据成员提供时间复杂度为 <tt>O(1)</tt> 的操作判断：</p>
<ul>
<li>项对象是否为<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">有序对</a>。</li>
<li>项对象是否为<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>。</li>
<li>非有序对的项对象具有的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>。</li>
</ul>
<p>　　值数据成员可能具有空值。</p>
<p>　　值数据成员和子项可构成<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">对象的内部表示</a>：</p>
<ul>
<li><em>列表节点(list node)</em> 是值数据成员为空的节点，表示真列表。</li>
<li><em>空节点(empty node)</em> 同时是叶节点和列表节点，表示<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">空列表</a>。</li>
<li>实现可定义其它的节点作为其它的内部表示。</li>
</ul>
<p>　　若项存在其它子对象，作为对象内部表示的具体规则由实现定义。</p>
<p>　　满足以下条件的替换变换替代项或其子对象，称为项的<em>提升(lifting)</em> ：被提升的项（源）是提升后得到的项（目标）的一个直接、间接子项或项的子对象变换得到的项。</p>
<p>　　提升可能包含附加检查，检查失败时可能<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起错误</a>而不实际进行提升。</p>
<p>　　除非另行指定，提升项<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">修改</a>被替换的对象。</p>
<p><strong>原理</strong></p>
<p>　　项的子对象确定的表示可能被具体的<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>依赖。</p>
<p>　　项的提升可以视为作为语法变换的消去 <a href="Features/NPL.zh-CN.html#%CE%BB-%E5%AE%8C%E5%A4%87%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AF%B9%E5%BA%94%E8%AF%AD%E6%B3%95">λ 抽象</a>的 <a href="https://en.wikipedia.org/wiki/Lambda_lifting">lambda 提升 (en-US)</a> 的一般化，但此处和 λ 抽象没有直接关联。</p>
<p>　　项的提升的变换可以是恒等变换，即直接以子对象作为替换的来源。其它变换如创建<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>和取间接值关联的对象，对应的提升<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">引入和消除间接值</a>。</p>
<p>　　项的提升的检查可包括为满足接口行为的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">语义检查</a>和实现为预防<a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">宿主语言的未定义行为</a>的附加检查。</p>
<p>　　被提升的项往往被<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">转移</a>，因此一般地，需要在宿主语言中<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">可修改</a>。若被提升的项表示对象语言的值，一般也需要在对象语言中可修改。</p>
<h3 id="对象属性"><a class="header" href="#对象属性">对象属性</a></h3>
<p>　　除以上性质外，对象可关联其它元数据以指定对象的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">属性</a>。</p>
<p>　　和属性对应的可组成对象的表示的非一等实体统称为<em>标签(tag)</em> 。</p>
<p>　　对象具有的标签决定以下<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E4%BA%A4%E6%80%A7">正交</a>的性质：</p>
<ul>
<li>唯一(unique) 引用：指定<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">对象的值</a>关联到自身以外的不被其它对象<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%88%AB%E5%90%8D">别名</a>的对象。
<ul>
<li>以唯一引用关联的对象进行<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96">复制初始化</a>时，不需要保留关联的对象的值。</li>
</ul>
</li>
<li>不可修改(nonmodifying) ：指定对象的值保持不变。
<ul>
<li>若操作需要修改此对象，则<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起错误</a>。</li>
</ul>
</li>
<li>临时(temporary) 对象：指定对象的值被临时使用。</li>
</ul>
<p>　　唯一引用和不可修改是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>的属性。对象语言中，引用值以外的对象是否具有这些属性未指定。为<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>目的可能具有实现定义的更强的假设。派生实现也可定义更强的假设。</p>
<p>　　临时对象属性类似唯一引用，但限定的可以是对象自身而非关联的其它对象，即引用值自身和<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>可以分别具有临时对象属性。但除了引用值属性外，临时对象属性仅限在<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>上出现。</p>
<p><strong>注释</strong></p>
<p>　　不可修改的对象类似 [ISO C++] 的 <code>const</code> 类型的对象。[ISO C++] 的非类和非数组类型的对象不具有 <code>const</code> 修饰。</p>
<p>　　对象的标签不在大多数对象中可见。另见<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用值的属性</a>。</p>
<h2 id="npla-环境"><a class="header" href="#npla-环境">NPLA 环境</a></h2>
<p>　　<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">求值环境</a>维护<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0">名称</a>和作用域。</p>
<p>　　<em>变量名(variable name)</em> 即<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">变量</a>的<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0">名称</a>。</p>
<p>　　除非另行指定，环境维护的名称都是变量名。</p>
<p>　　NPLA 的求值环境可以是：</p>
<ul>
<li><em>一等环境(first-class environment)</em> ，即作为对象语言中的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">一等对象</a>的环境。</li>
<li>作为 NPLA <a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>的<em>环境记录(environment record)</em> 。</li>
</ul>
<p>　　环境可引用若干个关联的其它环境为<em>父环境(parent environment)</em> ，用于<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">重定向</a>。</p>
<p>　　除非派生实现另行指定：</p>
<ul>
<li>环境可引用有限多个父环境，其数量的上限未指定。</li>
<li>父环境在创建时指定，作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">实体</a>，之后<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">不可变</a>。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　如<a href="Features/NPL.zh-CN.html#%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0">需求</a>中指出的，本设计<a href="https://github.com/FrankHB/pl-docs/blob/master/en-US/calling-for-language-features.md#namespace-separation">避免命名空间隔离</a>，因此只有一种被环境支持且被<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>统一处理的名称。</p>
<p>　　若派生实现需要，可修改环境的内部表示和求值算法的<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>步骤以对不同的名称添加支持。相反，在已有多种名称的设计中还原为一种设计是更复杂和不可行的。因此，在本设计中不预设多种名称。</p>
<h3 id="环境对象"><a class="header" href="#环境对象">环境对象</a></h3>
<p>　　环境作为可保持<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">可变状态</a>的对象，是<em>环境对象(environment object)</em> 。</p>
<p>　　环境对象包含变量名到表示<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">被绑定实体</a>的映射，称为<em>名称绑定映射(name binding map)</em> ，实现<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">变量绑定</a>。</p>
<p>　　被绑定实体是对象时，称为<em>被绑定对象(bound object)</em> 。NPLA 环境对象中的被绑定实体包含一等对象，因此被绑定实体总是被绑定对象。</p>
<p>　　环境对象对其中的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">名称绑定映射</a>具有独占的<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权</a>。名称绑定映射对其中的对象可具有独占或共享的所有权。因此，环境对象可对包括被绑定实体的名称绑定映射中的对象具有独占或共享的所有权。</p>
<p>　　环境记录之间共享所有权，以<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境引用</a>访问。</p>
<p>　　环境对象是<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>时查找名称的<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">目标</a>。</p>
<p>　　父环境可共享环境记录。通过共享环境记录实现重定向的环境表示是<em>链接的(linked)</em> 而非<em>平坦的(flat)</em> 。</p>
<p><strong>原理</strong></p>
<p>　　仅在可证明符合语义要求等价时，使用平坦的环境表示。</p>
<p>　　对支持一等对象语义的设计，因为明确要求区分<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>，对象的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">存储</a>不能被任意地复制。</p>
<p>　　一般地，仅在可证明父环境对应的环境记录在对象语言和实现内部都不被共享访问（不具有<a href="Features/NPL.zh-CN.html#%E5%85%B1%E4%BA%AB%E5%BC%95%E7%94%A8">共享引用</a>且不被<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%88%AB%E5%90%8D">别名</a>），且不存在任意派生实现定义的对释放顺序引起的可观察行为差异时，才能唯一具有这个父环境的环境为平坦的表示而<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">保持语义不变</a>。</p>
<p><strong>注释</strong></p>
<p>　　变量名通过以和字符串一一对应的值表示，没有直接的值的限制，可能为空串。</p>
<p>　　若环境记录直接持有<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>，则这些对象是环境记录的<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>。</p>
<h3 id="环境引用"><a class="header" href="#环境引用">环境引用</a></h3>
<p>　　环境引用是对象语言中访问环境记录的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">一等对象</a>。</p>
<p><strong>注释</strong> 环境引用不是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>。后者关联的被引用对象是一等对象。</p>
<p>　　环境引用共享环境对象的<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权</a>。</p>
<p>　　根据所有权管理机制的不同，环境引用包括<a href="Features/NPL.zh-CN.html#%E4%B8%80%E8%88%AC%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%80%E8%88%AC%E5%AE%9E%E7%8E%B0">环境强引用</a>和<a href="Features/NPL.zh-CN.html#%E4%B8%80%E8%88%AC%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%80%E8%88%AC%E5%AE%9E%E7%8E%B0">环境弱引用</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境强引用</a>可能共享环境对象的所有权，对<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境对象的名称绑定映射</a>持有的项具有间接的所有权。</p>
<p>　　作为<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>，环境引用可被复制或转移。</p>
<p>　　复制或转移环境引用不引起被引用的环境对象被复制。因此，<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值传递</a>环境引用不引起其中所有的对象被复制。另见<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>。</p>
<p><strong>原理</strong></p>
<p>　　区分环境对象和环境引用在纯函数式语言不是必要的，因为不需要关心<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境中的子对象</a>的复制影响<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>。</p>
<p>　　否则，为支持影响可观察行为的环境的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">修改</a>，非环境记录的环境引用是必要的。</p>
<p>　　环境引用也是一种较简单且一般普遍高效的父环境的实现表示，可直接实现<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">链接的</a>环境而不需要证明和实现特设的其它内部表示能和<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机</a>意义上链接的环境保持语义等价。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延捕获</a>若复制续延，可能引起关联的环境的复制，影响可观察行为并引起不必要的实现开销。为此，区分环境引用是必要的。</p>
<p>　　以环境引用作为一等对象使访问<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>等环境记录的子对象时需要间接访问，在环境实际不需要被复制的大部分其它场景引起开销。这种开销是可接受的，因为：</p>
<ul>
<li>考虑到一等环境的普遍性，有必要有效支持对象语言中创建环境临时对象（而不仅仅是环境对象的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>）的使用使之避免复制。</li>
<li>实现可能提供附加的证明以在优化的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">翻译</a>过程中替换环境引用为环境记录或其它不需要间接访问的中间表示，以消除这些开销。</li>
</ul>
<p>　　不论这样的证明是否存在，环境强引用和弱引用仍在对象语言中区分，以明确接口上的<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权语义</a>。</p>
<p>　　引入环境弱引用作为一般的引用机制，且仅在必要时使用环境强引用，以避免过于容易<a href="Features/NPL.zh-CN.html#%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5">引入循环引用引起强内存泄漏</a>，符合<a href="Features/NPL.zh-CN.html#%E9%80%82%E7%94%A8%E6%80%A7">适用性</a>。</p>
<h3 id="当前环境"><a class="header" href="#当前环境">当前环境</a></h3>
<p>　　NPLA 对象语言中，表达式的求值隐含对应一个环境对象作为<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>需要的<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">上下文</a>输入，称为<em>当前环境(current environment)</em> 。</p>
<h2 id="npla-表达式语义"><a class="header" href="#npla-表达式语义">NPLA 表达式语义</a></h2>
<p>　　本节约定对象语言中的表达式相关的语义规则，特别是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值规则</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%88%97%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">列表表达式</a>作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>是<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">列表</a>。</p>
<h3 id="值类别"><a class="header" href="#值类别">值类别</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>归类为具有以下基本的<em>值类别(value category)</em> 之一：</p>
<ul>
<li><em>泛左值(glvalue)</em> ：求值用于决定被表示的对象的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>的表达式。</li>
<li><em>纯右值(prvalue)</em> ：求值不用于决定对象同一性（而仅用于<a href="Features/NPL.zh-CN.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a><a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>或计算对象中<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">存储的值</a>）的表达式。</li>
</ul>
<p>　　一个泛左值可能被标记为<em>消亡值(xvalue)</em> ，以提供基于不同的所有权的行为。</p>
<p>　　纯右值蕴含对象在<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>的意义上不被共享，类似不被别名的引用的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>不被<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%88%AB%E5%90%8D">共享</a>。</p>
<p>　　<em>左值(lvalue)</em> 是除了消亡值外的泛左值。</p>
<p>　　<em>右值(rvalue)</em> 是消亡值或纯右值。</p>
<p>　　基本的值类别、消亡值、左值和右值都是值类别。</p>
<p>　　求值涉及表达式的值类别仅在必要时约定。</p>
<p>　　表达式的值类别是上下文相关的，相同表达式构造在不同的上下文可能具有不同的值类别。</p>
<p>　　NPLA 表达式允许在源语言语法之外的形式被间接构造，这些表达式同样具有值类别。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值规约</a>可能重写一个表达式为具有不同值类别的为被规约项。即便不能被对象语言表达，只要不和其它语义规则冲突，它们在此被视为其它形式的表达式的表示，即<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象</a>也对应地具有值类别。</p>
<p>　　一般地，NPLA 的表达式不限定从<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">源代码</a>的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">翻译</a>确定，且一个表达式的求值结果不排除继续构成表达式而被求值，因此表达式的值也普遍具有值类别。</p>
<p>　　除非另行指定，若一个 NPLA 表达式没有指定未被求值，则其值类别是其<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>的值类别。</p>
<p><strong>原理</strong></p>
<p>　　值类别根据是否只关心表达式关联的（对象的或非对象的）值，在需要对象时提供区分<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">两类一等实体</a>的机制，同时避免在仅需要表达式关联的值时引入不必要的其它对象。</p>
<p><strong>注释</strong></p>
<p>　　对象语言表达式的值类别和 [ISO C++17]（由提案 [WG21 P0135R1] 引入的特性）类似。</p>
<p>　　值类别在 [ISO C++] 中实质上是一种<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态类型</a>系统。在 NPLA 中以更灵活的可在<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">运行时</a>访问的元数据代替，仍能体现类似的上下文相关性。</p>
<p>　　除了标记消亡值，附加其它元数据也允许区分不同的所有权行为。</p>
<p>　　NPLA 值类别和 [ISO C++] 也有显著的不同，体现在如下扩展：源语言语法外的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">被规约项</a>的项对象视为 NPLA 表达式，也具有值类别。</p>
<p>　　因此，作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>的表达式的值也普遍具有值类别。若存在<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">结果对象</a>，可直接<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B">通过其类型确定</a>。</p>
<p>　　作为静态语言，[ISO C++] 缺乏允许在运行时确定的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>特性，这些不同不在 [ISO C++] 中可用，可以被视为保守的扩展。</p>
<h4 id="类型系统和值类别"><a class="header" href="#类型系统和值类别">类型系统和值类别</a></h4>
<p>　　NPLA 中，值类别作为<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%9E%8B">实体类型</a>，被作为一种内建的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">类型系统</a>。</p>
<p><strong>注释</strong></p>
<p>　　这和 [ISO C++] 不同。[ISO C++] 的“类型”的定义排除值类别，尽管值类别具有类型论意义上所有可作为类型讨论的对象的性质。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用类型</a>。</p>
<h3 id="初始化"><a class="header" href="#初始化">初始化</a></h3>
<p>　　对象被创建后可通过<em>初始化(initialization)</em> 决定其值，并可能存在其它<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>。被决定的值是<em>初始值(initial value)</em> 。</p>
<p>　　决定初始化这些作用的表达式是初始化的<em>初值符(initializer)</em> 。</p>
<p>　　初值符的求值可能有<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>，其求值结果指定特定被初始化的对象的初始值。</p>
<p>　　初始化包括<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>的初始化和作为函数值的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>对象的初始化。</p>
<p>　　初始化被绑定对象可能以<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">修改操作</a>的形式体现，此时修改绑定具有副作用。若这样的副作用存在，每个被初始化的值<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">后序</a>于对应初始的计算。</p>
<p><strong>注释</strong></p>
<p>　　初值符的求值的副作用不属于初始化，其求值结果和对象的初始值不一定相同。</p>
<p>　　和宿主语言不同，初始化不是独立的依赖特定语法上下文的概念，但此处语义上的作用类似。</p>
<p>　　对象的初始化一般可蕴含<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的初始化。</p>
<h4 id="复制初始化和直接初始化"><a class="header" href="#复制初始化和直接初始化">复制初始化和直接初始化</a></h4>
<p>　　初始化包括<em>直接初始化(direct initialization)</em> 和<em>复制初始化(copy initialization)</em> 。</p>
<p>　　函数可能接受<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>参数和返回值，是对函数的形式参数或函数值的复制初始化；其它初始化是直接初始化。</p>
<p>　　复制初始化形式参数和函数值时，函数参数或返回值作为初值符。</p>
<p><strong>注释</strong></p>
<p>　　区分两者和宿主语言类似。</p>
<h4 id="函数参数和函数值传递"><a class="header" href="#函数参数和函数值传递">函数参数和函数值传递</a></h4>
<p>　　部分函数可保证<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">被初始化的对象副本</a>中的值和初值符的值及元数据一致。</p>
<p>　　这样的参数或返回值的初始化的求值称为<em>转发(forwarding)</em> 。</p>
<p>　　转发也包括只部分保留上述部分元数据的情形。</p>
<p>　　在允许保留元数据不变的上下文，转发在<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>中可直接通过<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">转移项</a>实现。</p>
<p>　　转发保持引入这些初始化的表达式（通常是被求值取得函数值的函数表达式）时，其求值结果（函数值）的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">值类别</a>和初值符保持一致。</p>
<p><strong>注释</strong></p>
<p>　　这里的元数据的一个例子是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用值的属性</a>。</p>
<p>　　转发类似宿主语言的<em>完美转发(perfect forwarding)</em> 。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">函数值传递</a>。</p>
<h4 id="对象的复制和转移"><a class="header" href="#对象的复制和转移">对象的复制和转移</a></h4>
<p>　　可使用初值符为参数进行复制或转移操作以<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96">复制初始化</a>对象，创建<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">对象的副本</a>。</p>
<p><strong>注释</strong> 这类似宿主语言中的类类型的值。其它情形另见<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4">复制消除</a>。</p>
<p>　　对象的复制和转移不改变被转移后的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型</a>。</p>
<p>　　对象的复制和转移对应蕴含其子对象被复制和转移。在<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>的意义上，若项<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">具有子对象的独占所有权</a>，这些子对象的复制构造函数和转移构造函数被对应调用。特别地，这里的子对象包括<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主值</a>。</p>
<p>　　可使用转移操作时，不对作为对象的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>进行复制，因此不要求其中的子对象可复制，而避免<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p><strong>注释</strong> 这类似 [ISO C++11] 起选择类的转移构造函数代替复制构造函数。</p>
<p>　　和 [ISO C++11] 起不同，上述可使用转移操作的条件和语法上下文无关：引起选择转移操作的条件由对初值符的谓词而非类似宿主语言的构造函数判断（详见<a href="Features/NPL.zh-CN.html#%E9%BB%98%E8%AE%A4%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2%E7%BA%A6%E5%AE%9A">默认值类别转换约定</a>）。</p>
<p><strong>注释</strong> 同宿主语言。</p>
<p>　　除非另行指定，需要创建实体的副本时：</p>
<ul>
<li>若对象满足<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%AF%E8%BD%AC%E7%A7%BB%E6%9D%A1%E4%BB%B6">可转移条件</a>，则转移而不是复制。</li>
<li>其它情形实体被复制。</li>
</ul>
<p><strong>注释</strong> 一个主要的实例是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值的副本传递</a>。</p>
<h4 id="项的转移"><a class="header" href="#项的转移">项的转移</a></h4>
<p>　　一定条件下，作为对象的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>可被整体转移，而避免其中包含的对象的初始化在对象语言中具有可见的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>。</p>
<p>　　在<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>的意义上，因作为对象的表示的项的转移，项及其子对象的转移构造函数会被调用，但项的<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">值数据成员</a>中的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>的转移构造函数不会被调用。</p>
<p><strong>注释</strong> 这一般要求实现使用某种<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">类型擦除</a>使子对象类型的转移构造函数的调用不蕴含宿主类型的转移构造函数的调用。</p>
<p>　　项的转移是<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">析构性转移</a>。</p>
<p>　　一般地，当对象需要被转移且没有约定<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">转移后要求类型不变</a>时，项的整体转移可代替<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">对象的转移</a>，避免初始化新的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主对象</a>，称为宿主对象转移消除。</p>
<p><strong>注释</strong> 若需调用<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>的转移构造函数，需明确避免在代替对象的转移的上下文中进行操作。派生实现可提供这些操作。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87">返回值转换上下文</a>的转移蕴含宿主对象转移消除。</p>
<p>　　若被<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4">复制消除</a>的对象来自不同的项，则复制消除蕴含宿主对象转移消除。这包括所有对象转移的返回值转换上下文的情形。</p>
<h3 id="引用值"><a class="header" href="#引用值">引用值</a></h3>
<p>　　在对象语言中，<em>引用值(reference value)</em> 是作为<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>，可保存在一等对象中。这样的一等对象是<em>引用对象(reference object)</em> 。</p>
<p>　　引用值和引用对象的值具有<em>引用类型(reference type)</em> 。</p>
<p>　　在特定上下文中，引用和其它<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">一等对象</a>的值的相同具有不同的语义，主要体现在引用值被按值直接初始化传递和<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按引用传递</a>时。</p>
<p><strong>注释</strong> 差异和 [ISO C++] 中使用对象类型和引用类型作为参数类似。</p>
<p>　　NPLA 引用值总是假定和<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>关联。</p>
<p><strong>注释</strong> 和宿主类型类似，引用类型没有空值。</p>
<p>　　仅当以下情形中，NPLA 引用值的被引用对象是非<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">一等对象</a>：</p>
<ul>
<li>作为<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　由于<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象</a><a href="Features/NPL.zh-CN.html#%E9%A1%B9%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">被环境所有</a>，为允许<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">规约求值</a>其中的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>，需要不被环境所有的（其它不同的）<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">被规约项</a>作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">表示</a>的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象</a>作为中间值。</p>
<p>　　这种中间值通过间接引用作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>使用，也是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">一种间接值</a>，即引用值。</p>
<h4 id="子对象引用"><a class="header" href="#子对象引用">子对象引用</a></h4>
<p>　　特定的引用值是<em>子对象引用(subobject reference)</em> ，其被引用对象是被另一个对象所有的、作为这个对象的<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的一等对象。</p>
<p>　　子对象引用对特定操作可表现和其它一等对象不同的行为。</p>
<p>　　以下引用是子对象引用：</p>
<ul>
<li><em>子有序对引用(subpair reference)</em> 是<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">子有序对</a>作为被引用对象的引用。</li>
<li><em>子列表引用(sublist reference)</em> 是<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">子列表</a>作为被引用对象的引用。</li>
</ul>
<p>　　语言可能引入其它的子对象引用。</p>
<h4 id="引用值的有效性"><a class="header" href="#引用值的有效性">引用值的有效性</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">作为</a>一种<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>，引用值有效当且仅当访问被引用对象不引起未定义行为。</p>
<p>　　以下约定要求被 NPLA 实现支持的有效的引用值总是无条件地允许访问对象。</p>
<p>　　有效的引用值应通过特定的构造方式引入，包括：</p>
<ul>
<li>在对象语言通过被引用对象初始化引用值。</li>
<li><a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>引入的保证不引起未定义行为的引用值。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　一些对象语言的操作可能引起引用值无效。例如，<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">改变</a>被引用对象可以使已被初始化的有效的引用值成为<em>悬空引用(dangling reference)</em> 。</p>
<h4 id="多重引用"><a class="header" href="#多重引用">多重引用</a></h4>
<p>　　被引用对象也可以是引用值。</p>
<p>　　被引用对象不是引用值的引用值是<em>完全折叠(fully collapsed)</em> 的。</p>
<p>　　除非另行指定，<em>未折叠的(uncollapsed)</em> 引用值指未完全折叠的引用值。</p>
<p><strong>注释</strong></p>
<p>　　这和宿主语言不同。</p>
<h4 id="引用值的属性"><a class="header" href="#引用值的属性">引用值的属性</a></h4>
<p>　　引用值可以具有和作为引用值<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">表示</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>保存的<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">属性</a>相互独立的属性，保存其作为一等对象的状态。</p>
<p>　　属性不可分割：一个引用值明确具有或者不具有一种属性。</p>
<p>　　和<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">对象属性</a>对应，NPLA 指定的引用属性可以是：</p>
<ul>
<li>唯一引用。</li>
<li>不可修改引用。</li>
<li><a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>引用。</li>
</ul>
<p>　　引用值属性指定通过引用对<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的访问假定允许具有的性质，即便被引用对象自身没有具有这些属性。</p>
<p>　　特定的操作使用引用值作为操作数，根据不同的属性决定行为，包括在违反属性引入的假定时<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　在本节要求以外，除非派生实现另行指定，违反这些假定不引起 <a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">NPLA 未定义行为</a>。</p>
<p>　　具体的引用属性满足以下语义规则：</p>
<ul>
<li>唯一引用允许通过引用值访问被引用对象时，对象可被假定不被其它引用而仅通过这个途径访问，即便实际存在其它途径的引用时可能引起不同的行为；在假定的基础上程序具有何种可能的行为是未指定的。</li>
<li>唯一引用可被假定不被共享，被引用对象不被<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%88%AB%E5%90%8D">别名</a>。</li>
<li>通过不可修改引用的左值的对象访问不包含<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">修改</a>。否则，若没有引起错误，程序<a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">行为未定义</a>；但除非另行指定，不引起<a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">宿主语言的未定义行为</a>。</li>
<li>具有临时对象引用属性的引用值是临时对象的引用值，其被引用对象是临时对象。</li>
</ul>
<p><strong>原理</strong> 宿主语言的互操作不被总是要求保证对象语言程序的可移植性，但不应引起实现自身的行为无法预测。</p>
<p>　　对引用值的操作<em>传播(propagate)</em> 特定的引用属性，当且仅当：</p>
<p>　　若操作数是具有特定引用属性的引用值，且结果是引用值时，结果具有和操作数相同的特定属性。</p>
<p><strong>注释</strong></p>
<p>　　引用值属性和对象属性相互独立，类似 [ISO C] 和 [ISO C++] 在指针和引用等复合类型的 <code>const</code> 等限定独立于指向的对象或被引用对象上的类型不同。通过 <code>const</code> 等属性可以在指针或引用类型上单独限制类型，而不影响对应的被间接访问的对象。</p>
<p>　　唯一引用蕴含的假定类似 [ISO C] 约定的 <code>restrict</code> 关键字，但程序违反假定的约束时不引起未定义行为。</p>
<p>　　和 [ISO C++] 核心语言（但不是 <a href="https://eel.is/c++draft/res.on.arguments">[res.on.arguments]</a> 中的标准库绑定到右值引用实际参数的约定）的右值引用类似，唯一引用不总是表示被引用对象不被共享。</p>
<p>　　接受唯一引用的操作可能只假定被引用对象的<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>不被共享，也可能完全不进行假定，这依赖具体操作的语义。若需要和具体操作无关的无条件非共享假定，使用<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>而非作为左值的唯一引用。</p>
<p>　　和宿主语言的 <code>const</code> 限定类型类似，不可修改引用仅针对特定左值的访问；通过共享的其它未被限定的引用仍可修改对象。</p>
<p>　　违反不可修改引用引入的假定的错误可能通过<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>或其它方式引起。</p>
<p>　　临时对象引用类似 [ISO C++] 的<em>转发引用(forwarding reference)</em> 中保留在表达式声明中的类型信息。</p>
<p>　　因为 NPLA 不支持声明元数据，这些信息保存在对象的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>中，且在初始化时被引用值保存；也因此<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">这些元数据可跟随一等对象传递</a>。对临时对象，<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">绑定操作</a>可确保<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">元数据被添加</a>。</p>
<p>　　这也和宿主语言不同。在宿主语言中：</p>
<ul>
<li>无论是标记消亡值的右值引用类型还是标记是否可转发的引用的转发引用推断的类型信息（左值引用或右值引用）都是静态的。</li>
<li>并且，转发的类型信息只在函数模板的局部有效，而不存在对应的跨过程传递机制。</li>
</ul>
<h4 id="引用值的消除"><a class="header" href="#引用值的消除">引用值的消除</a></h4>
<p>　　作为<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>，引用值可被<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">消除</a>，即被其<a href="Features/NPL.zh-CN.html#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">（可能多重）引用</a>关联的被引用对象替代。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">未折叠的引用值</a>消除一次引用值，结果仍是引用值。</p>
<p>　　消除<a href="Features/NPL.zh-CN.html#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">完全折叠的引用值</a>的结果总是<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">右值</a>。</p>
<p>　　推论：因为引用值不<a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>自身，除非引用值<a href="Features/NPL.zh-CN.html#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">已完全折叠</a>，继续消除引用值得到的值和引用值是不同的值。</p>
<p><strong>原理</strong></p>
<p>　　特定的引用值消除可蕴含对不可修改的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">传播</a>的要求。这和 [ISO C++] 初始化引用时遵循的 <code>const</code> 安全性，属于类型安全性的一种。</p>
<p>　　但是，消除引用不一定总是预期这种性质，特别当折叠不被预期时。</p>
<p>　　例如，[ISO C++] 内建指针的不同级 <code>const</code> 不会被隐式转换直接折叠合并。消除间接的指针值不是隐式的（而依赖内建一元 <code>*</code> 操作符），这是因为指针作为类型构造器自身的类型安全需要；是否消除 <code>const</code> 限定符仍然需要基于其它理由考虑。</p>
<p>　　而当被引用对象实现子对象时，修饰被指向的类型的 <code>const</code> 不会自动传播到子对象的类型中，此时可有 <code>std::experimental::propagate_const</code> 可选引入这种性质。</p>
<p>　　对具有非间接访问的子对象的类型，这相当于 [ISO C++] 的 <code>mutable</code> 修饰符，可实现<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">内部可变性</a>。而允许子对象以外直接不传播不可变性，是一种结构性的平凡的扩展：这允许把被引用对象直接视为一种子对象的实现，而非要求引入新的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义类型</a>。</p>
<p>　　在 NPLA 这样没有要求显式类型编码是否可变的语言中，首先要求总是具有不可修改的传播性质会显著增加规则形式上的复杂性。若具体操作需要传播不可修改性，仍可进一步约定。</p>
<p><strong>注释</strong></p>
<p>　　典型地，消除引用值包括：</p>
<ul>
<li>当<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">引用值提升转换</a>的操作数是引用值时，消除被提升的引用值。</li>
<li>当<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">引用折叠</a>的操作数是引用值时，消除被折叠的引用值。</li>
</ul>
<p>　　和引用折叠不同，引用值提升转换不满足对不可修改引用属性的传播性质。</p>
<h4 id="引用折叠"><a class="header" href="#引用折叠">引用折叠</a></h4>
<p>　　和 [ISO C++] 类似，引用值在 NPLA 中默认不被继续引用，使用引用初始化引用会引用到<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>上，即<em>引用折叠(reference collapse)</em> 。</p>
<p>　　引用值被折叠后结果和原引用值不同，当且仅当原引用值是<a href="Features/NPL.zh-CN.html#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">未折叠的引用值</a>。</p>
<p>　　和 [ISO C++] 不同，NPLA 不限制派生实现利用未折叠的引用值。</p>
<p><strong>注释</strong> 特定的操作可能区分未折叠的引用值。</p>
<p>　　引用折叠的结果是不可修改引用，若引用值和作为引用值的被引用对象之一是不可修改引用。</p>
<p>　　引用折叠的结果满足不可修改<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用属性的传播性质</a>。推论：</p>
<ul>
<li>引用折叠的结果是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">唯一引用</a>，当且仅当引用值和作为引用值的被引用对象都是唯一引用。</li>
<li>引用折叠的结果是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">临时对象引用</a>，当且仅当被引用对象是临时对象引用。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　内部表示可支持间接的引用，以允许在对象语言中实现<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">一等引用</a>。</p>
<p>　　引用折叠对不可修改的传播性质的要求和 [ISO C++] 的引用折叠对 <code>const</code> 限定符的处理类似。</p>
<p>　　引用折叠对唯一引用的要求和 [ISO C++] 的右值引用仅通过被折叠的引用都是右值引用类型折叠类似。注意 [ISO C++] 右值引用推断仅用于推断转发引用(forwarding reference) 参数，而非直接声明特定的右值引用类型。</p>
<p>　　和唯一引用不同，临时对象相对唯一引用更接近 [ISO C++] 的声明的右值引用类型信息（而非推断值类别时使用的消亡值表达式的右值引用类型），一般不预期被折叠。</p>
<p><strong>注释</strong></p>
<p>　　未折叠的引用值被折叠时，用于初始化的被引用对象可能仍然是未折叠的引用值。</p>
<h4 id="对象的可转移条件"><a class="header" href="#对象的可转移条件">对象的可转移条件</a></h4>
<p>　　根据项是否具有特定元数据的引用值可判断使用复制代替<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">对象转移的条件</a>。</p>
<p>　　对象的<em>可转移(movable)</em> 条件的判断基于首先基于<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B">值的类型</a>：</p>
<ul>
<li>非引用值（纯右值）总是可转移的。</li>
<li>否则，对象是引用值。可转移由<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用值的属性</a>决定：当引用值是唯一引用且非不可修改，引用值是可转移引用，对应的被引用对象是可转移的。</li>
</ul>
<h4 id="引用值的表示"><a class="header" href="#引用值的表示">引用值的表示</a></h4>
<p>　　作为引用值的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>，<em>引用项(reference term)</em> 是包含<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">项引用</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>。</p>
<p>　　引用项中的项引用对象引用一个（其它的）项，即<em>被引用项(referenced term)</em> ，用于在必要时引入可被引用的一个项而不在 TermNode 中直接储存这个项的值。</p>
<p>　　被引用项表示引用项作为引用值对应的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>。</p>
<p>　　引用项在作为<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象</a>外，<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">保存标签</a>作为<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用值的属性</a>的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>可作为引用值的被引用对象。</p>
<p>　　与此不同，非临时对象的引用值可作为一等对象而总是需要区分作为不同对象的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>。</p>
<p>　　带有<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">临时对象属性</a>的引用值可在特定的操作中被视为和临时对象引用近似的引用值。</p>
<p>　　子对象引用的表示是<em>子对象引用项(subojbect reference term)</em> ，和本节中的其它引用类型的表示兼容，但不完全相同。</p>
<p>　　关于引用项的构成，另见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　因为<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象不是一等对象</a>，临时对象的引用值可代替关联的被引用对象使之作为一等对象被访问。</p>
<p>　　为在对象语言中区分引用值和非引用值的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>是必要的，引用项这样的特设表示是必要的。</p>
<p>　　非引用项的表示则是针对临时对象的一种优化，因为使<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>总是在作为引用值的表示而：</p>
<ul>
<li>相比通常的间接值，避免间接<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>关联的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的开销。</li>
<li>避免<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7">悬空引用</a>。</li>
</ul>
<p>　　带有临时对象属性的引用值和临时对象的引用值不同，参见<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">绑定临时对象属性</a>。</p>
<h4 id="引用值的子类型"><a class="header" href="#引用值的子类型">引用值的子类型</a></h4>
<p>　　根据表示和属性，引用类型具有如下<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>：</p>
<ul>
<li><em>左值引用(lvalue reference)</em> ：以引用项表示的非<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">唯一引用</a>。</li>
<li><em>右值引用(rvalue reference)</em> ：以引用项表示的唯一引用。</li>
</ul>
<p>　　引用值是否作为<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>使用取决于上下文。除非另行指定，引用值都是左值。</p>
<p><strong>注释</strong> 在要求右值的上下文发生<a href="Features/NPL.zh-CN.html#%E9%BB%98%E8%AE%A4%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2%E7%BA%A6%E5%AE%9A">左值到右值转换</a>。</p>
<p>　　引入不同的引用子类型后，NPLA 一等对象的值的类型和<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">值类别</a>存在以下一一对应关系：</p>
<ul>
<li>若类型是左值引用，则对应的值类别是左值。</li>
<li>若类型是右值引用，则对应的值类别是消亡值。</li>
<li>否则，对应的值类别是右值。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　左值引用和左值引用与宿主语言中的对象类型的左值引用与右值引用分别类似。</p>
<p><strong>注释</strong></p>
<p>　　在要求右值的上下文，作为左值的引用值发生<a href="Features/NPL.zh-CN.html#%E9%BB%98%E8%AE%A4%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2%E7%BA%A6%E5%AE%9A">左值到右值转换</a>。</p>
<h4 id="不安全引用值"><a class="header" href="#不安全引用值">不安全引用值</a></h4>
<p>　　特定的引用值是<em>不安全引用值(unsafe reference value)</em> ，可能和常规的其它引用值具有不同的内部表示。</p>
<p>　　若实现支持不安全引用值，和其它引用值的行为不同由实现定义。</p>
<p>　　派生实现可能添加更多对不安全引用值的假设。</p>
<p><strong>原理</strong></p>
<p>　　不安全引用值可能放弃常规的引用具有元数据而能被更高效地访问。</p>
<h3 id="值类别转换"><a class="header" href="#值类别转换">值类别转换</a></h3>
<p>　　具有特定值类别的表达式可转换为不同值类别的表达式：</p>
<ul>
<li>除非另行指定，泛左值总是允许作为纯右值使用。从泛左值取对应右值的操作称为<em>左值到右值转换(lvalue-to-rvalue conversion)</em> 。</li>
<li>从纯右值<a href="Features/NPL.zh-CN.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a>可被对象语言作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>使用的<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的引用值作为<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">消亡值</a>，称为<em>临时对象实质化转换(temporary materialization conversion)</em> 。</li>
</ul>
<p>　　左值到右值转换没有<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">副作用</a>。临时对象实质化转换没有副作用，当且仅当其中初始化临时对象时没有副作用。</p>
<p>　　临时对象实质化转换中，纯右值被<em>实质化(materialized)</em> 。</p>
<p>　　在求值子表达式时，按表达式具有的语义，必要时（如按<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%80%BC%E7%B1%BB%E5%88%AB">相关规则</a>判断上下文的值类别）进行值类别转换。</p>
<p>　　NPLA 还提供可能使结果具有不同的值类别的<em>引用值提升转换(reference value lifting conversion)</em> 。以下规则确定引用值提升转换的结果：</p>
<ul>
<li>若操作数是引用值，则结果是操作数的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>。</li>
<li>否则，结果是操作数。</li>
</ul>
<p>　　引用值提升转换蕴含引用<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">提升</a>，即使用被引用对象替换操作数。</p>
<p><strong>原理</strong></p>
<p>　　为支持<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>作为一等对象（特别是<a href="Features/NPL.zh-CN.html#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">未折叠的引用值</a>），NPLA 提供比左值到右值转换更精细的引用值提升转换。</p>
<p>　　值类别转换在特定求值中适用，因此不影响构造性的规则。</p>
<p>　　特别地，列表左值（列表的引用值）不能代替列表，因此以空列表的引用作为最后一个元素的嵌套有序对是<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">非真列表</a>。这和 [R<sup>7</sup>RS] 约定空列表总是同一对象不同。</p>
<p>　　这种设计使语言规则更容易在局部一致，同时显著减少实现（对象内部表示）的复杂性，并有助于提升实现性能的可预测性。</p>
<p><strong>注释</strong></p>
<p>　　不同值类别表达式的转换和宿主语言中的部分标准转换类似。</p>
<p>　　根据引用值的性质，易知左值到右值转换的规约是引用值提升转换的规约的传递闭包，即：</p>
<ul>
<li>若操作数是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">已完全折叠的引用值</a>，则引用值提升转换等价左值到右值转换。</li>
<li>否则，有限次的引用值提升转换等价左值到右值转换。</li>
</ul>
<p>　　引用值提升转换不<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">传播引用值的属性</a>，参见<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%B6%88%E9%99%A4">引用值的消除</a>。</p>
<p>　　引用值提升转换不传播不可修改属性，类似 [ISO C++] 非引用值的转换在结果中不保留源操作数中的 <code>const</code> 类型。</p>
<p>　　临时对象实质化可实现为空操作，因为项在先前（如<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>蕴含的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">引用值提升转换</a>对<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E8%A1%A8%E7%A4%BA">引用项</a>的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">提升操作</a>的实现中）已被创建。</p>
<p>　　互操作可能引入不以项表达的右值而需要首先创建项。</p>
<h4 id="默认值类别转换约定"><a class="header" href="#默认值类别转换约定">默认值类别转换约定</a></h4>
<p>　　除非另行指定：</p>
<ul>
<li>作为<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作符</a>的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>没有值类别转换。</li>
<li>作为<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>的表达式仅在必要时进行一次左值到右值转换。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　类似宿主语言规则，并非所有上下文都需要转换。类似地，宿主语言的操作符（括<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>的第一个子表达式）可直接使用左值而不需要转换。但和宿主语言不同，因为<a href="Features/NPL.zh-CN.html#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">多重引用</a>，不确定次数的连续的转换结果不同。因此除了上下文要求，有必要约定默认仅转换一次，而非确保转换结果到右值。</p>
<p>　　必要时，具体<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作</a>仍可指定不同的规则。</p>
<p>　　值类别和左值到右值转换在一些上下文的行为类似箱和自动拆箱，约定存在默认转换并不利于维护<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>：</p>
<ul>
<li>特别地，和宿主语言不同，函数不包含充分的信息（参数类型）推断是否接受左值操作数，因此在不提供针对函数的<em>重载(overloading)</em> 一般机制的前提下，<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>不能预知输入的操作数是否是左值，通常需分别支持左值和右值的操作数。</li>
<li>即便提供重载，仍然较单一的值类别更复杂。</li>
</ul>
<p>　　但 NPLA 的设计中，值类别转换已被通过<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确</a>反映需求的<a href="Features/NPL.zh-CN.html#%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">存储和对象模型</a>的设计隐含在项的内部性质中，因此不是可选的。</p>
<p>　　由<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性的优先规则</a>，<a href="Features/NPL.zh-CN.html#%E5%AE%8C%E6%95%B4%E6%80%A7">完整性</a>应先于简单性被满足。</p>
<p>　　而考虑<a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">统一性</a>，对存储和对象模型的设计，用户自行的实现仍要求这些设施（尽管更困难）。</p>
<p>　　关于箱和自动装箱，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h4 id="返回值转换"><a class="header" href="#返回值转换">返回值转换</a></h4>
<p>　　<em>返回值转换(return value conversion)</em> 是一次引用值提升转换和可选的一次临时对象实质化转换的顺序复合。</p>
<p>　　返回值转换用于在对象语言中确定函数调用的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>可包含<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数体</a>的求值结果到返回值的转换。</p>
<p>　　引用值作为间接值，适用<a href="Features/NPL.zh-CN.html#%E5%B1%80%E9%83%A8%E9%97%B4%E6%8E%A5%E5%80%BC%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">局部间接值安全保证</a>。在<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87">返回值转换上下文</a>中确定函数返回值的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E8%B4%A8%E5%8C%96%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87">实质化转换上下文</a>的部分操作<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%B6%88%E9%99%A4">消除引用值</a>，即返回值转换，是这种情形的主要实例。</p>
<p>　　这可约束作为间接值的<a href="Features/NPL.zh-CN.html#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">完全折叠的引用值</a>不<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">逃逸</a>（因此<a href="Features/NPL.zh-CN.html#%E5%B1%80%E9%83%A8%E9%97%B4%E6%8E%A5%E5%80%BC%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">访问被引用对象的值可不超出指向对象的存储期</a>），而保证只考虑项可能是引用值时的内存安全。</p>
<p>　　除非证明不需要<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>，返回值转换中初始化临时对象作为返回值的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象</a>，否则临时对象被<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4">复制消除</a>。是否存在复制消除是未指定行为。</p>
<p>　　不论是否存在返回值转换，返回值的项对象来自返回的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">右值</a>关联的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">临时对象实质化转换</a>。这可能在返回值转换蕴含的<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">项提升</a>操作或之前的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值规约</a>中蕴含。</p>
<p><strong>注释</strong></p>
<p>　　返回值转换不保证<a href="Features/NPL.zh-CN.html#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">未折叠的引用值</a>在消除引用值后的结果不逃逸。</p>
<p>　　为确保内存安全，程序仍需要保证被引用的对象的间接引用的对象生存期结束后，不能访问间接引用的对象。</p>
<p>　　其它间接值的内存安全需要另行保证。</p>
<p>　　是否需要返回值转换由实质化转换上下文中的被调用的函数而非上下文是否需要使用右值决定，无关被转换的表达式是否是左值，因此返回值转换不是<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">左值到右值转换</a>。</p>
<p>　　当前未实现是否需要临时对象的证明。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象和关联对象所有权</a>和<a href="Features/NPL.zh-CN.html#%E5%B1%80%E9%83%A8%E9%97%B4%E6%8E%A5%E5%80%BC%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">局部间接值安全保证</a>。</p>
<h3 id="临时对象"><a class="header" href="#临时对象">临时对象</a></h3>
<p>　　特定的 <a href="Features/NPL.zh-CN.html#npla-%E5%9F%BA%E7%A1%80%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">NPLA 非一等对象</a>是<em>临时对象(temporary object)</em> 。</p>
<p>　　NPLA 允许（但不要求对象语言支持）一等对象构成的表达式通过特定的求值，在中间结果中蕴含这种非一等对象。</p>
<p><strong>注释</strong> 这样的非一等对象不在源语言中可见，一般仅用于<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>。</p>
<p>　　临时对象的<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>不是临时对象。</p>
<p>　　NPLA 对象语言在特定的上下文引入其它临时对象，包括：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%AE%9E%E8%B4%A8%E5%8C%96%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87">实质化转换上下文</a>。</li>
<li><a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87">返回值转换上下文</a>。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　为简化规约和互操作机制的设计，和 [ISO C++17] 不同，引入临时对象不包括延迟初始化或异常对象的创建。</p>
<p>　　关于临时对象的子对象的规则，参见<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">绑定临时对象</a>中的原理。</p>
<p><strong>注释</strong></p>
<p>　　关于临时对象的存储和所有权，参见<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">求值和对象所有权</a>。</p>
<p>　　关于临时对象的表示，参见<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%A8%E7%A4%BA">临时对象的表示</a>。</p>
<p>　　关于避免特定相关对象的<a href="Features/NPL.zh-CN.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a>的要求，参见<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4">复制消除</a>。</p>
<p>　　引入临时对象的一些上下文的和宿主语言类似。</p>
<h4 id="实质化转换上下文"><a class="header" href="#实质化转换上下文">实质化转换上下文</a></h4>
<p>　　可具有（但不保证具有）<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">临时对象实质化转换</a>的上下文包括：</p>
<ul>
<li>使用纯右值初始化被绑定为<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>的变量（如函数的引用类型的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">形式参数</a>）。</li>
<li>求值<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>以初始化<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　一般地，被绑定为引用值的变量在<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">活动调用</a>关联的环境分配临时对象。此时，对象被调用表达式的项独占所有权，同时被绑定的环境独占资源所有权，并实现<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4">复制消除</a>。</p>
<p>　　在不具有转换时，优化的实现可能消除函数调用（内联(inline) 展开）而不分配关联的环境，把临时对象分配到其它环境或者语言不保证可见的存储（如 CPU 寄存器）中，并同时实现复制消除。</p>
<p>　　临时对象实质化转换引入临时对象的规则和 [ISO C++17] 不同：</p>
<ul>
<li>不论表达式是否作为子表达式使其值被使用（未使用的情形对应 [ISO C++] 中的 discarded-value expression ），都允许存在临时对象。</li>
<li>要求复制消除而避免特定对象的<a href="Features/NPL.zh-CN.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a>。</li>
</ul>
<h4 id="返回值转换上下文"><a class="header" href="#返回值转换上下文">返回值转换上下文</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>可引入实质化的临时对象，其中<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%AF%E8%BD%AC%E7%A7%BB%E6%9D%A1%E4%BB%B6">可能转移求值</a>的中间结果；否则，对象被复制。</p>
<p>　　此处被转移对象符合<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">求值和对象所有权</a>规则中的临时对象的定义，但除非另行指定，被转移的对象不在对象语言中可被访问。</p>
<p>　　仅在对象被复制且复制具有副作用时，返回值转换具有等价复制的副作用。</p>
<h4 id="复制消除"><a class="header" href="#复制消除">复制消除</a></h4>
<p>　　NPLA 要求特定上下文中的<em>复制消除(copy elision)</em> ，排除复制或转移操作且保证被消除操作的源和目的对象的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">同一性</a>。</p>
<p>　　复制消除仅在以下转换上下文中被要求，即直接使用被转换的源表达式中的对象作为实质化的对象而不初始化新的临时对象：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%AE%9E%E8%B4%A8%E5%8C%96%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87">实质化转换上下文</a>。</li>
<li>引起对象转移至<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>的<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87">返回值转换上下文</a>。</li>
</ul>
<p>　　非<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>函数的函数体内指定的返回值不属于上述的确定返回值的上下文，但也不要求被复制消除。</p>
<p>　　实现仍可根据<a href="Features/NPL.zh-CN.html#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>来判断是否在允许消除对象复制的上下文中，而进行复制消除。</p>
<p>　　复制消除不在被初始化对象以外引入新的对象语言可见的对象。</p>
<p><strong>原理</strong></p>
<p>　　为维护语言规则的<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>和使用这些规则的程序的行为的<a href="Features/NPL.zh-CN.html#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测性</a>，NPLA 的复制消除限于临时对象的消除。</p>
<p>　　在完成实质化转换前的不完整的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E8%A7%84%E5%88%99%E5%92%8C%E6%B1%82%E5%80%BC">求值规约</a>中的临时对象在逻辑上不需要作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>存在，但纯右值作为对象<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>中的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">子项</a>，随纯右值在宿主语言中作为对象存在，以允许互操作。</p>
<p>　　复制消除的目的 [ISO C++17] 类似。同时，提供语言支持也允许更简单地实现 C++ 互操作性。</p>
<p>　　和 [ISO C++17] 不同的一些要求可简化语言规则和实现，例如：</p>
<ul>
<li>不区分求值结果是否被作为<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>或求值是否为常量表达式。</li>
<li>非<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>函数的规则不要求 <code>return</code> 语句中的特定的表达式，而不需要依赖特定上下文的语法性质。</li>
<li>同时，NPLA 不限制对象的类型（[ISO C++17] 则要求特定的 C++ 类类型）。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　在实现中，被转换的源表达式中的对象是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">待求值项</a>的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象</a>。</p>
<p>　　当前未实现按当前环境判断是否在允许消除对象复制的上下文中进行复制消除。</p>
<h4 id="生存期扩展"><a class="header" href="#生存期扩展">生存期扩展</a></h4>
<p>　　在使用<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>初始化<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>时，<em>扩展(extend)</em> 源表达式的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象</a>的<a href="Features/NPL.zh-CN.html#%E7%94%9F%E5%AD%98%E6%9C%9F%E9%99%84%E5%8A%A0%E7%BA%A6%E5%AE%9A">生存期</a>使之比其它规则决定的生存期延长。</p>
<p>　　这和初始化非引用值类似，但实现需区分是否初始化的是延长生存期的临时对象，以确保之后能区分引用值初始化时是否<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按引用传递</a>。</p>
<h4 id="绑定临时对象属性"><a class="header" href="#绑定临时对象属性">绑定临时对象属性</a></h4>
<p>　　若<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E8%B4%A8%E5%8C%96%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87">实质化转换上下文</a>支持<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">绑定临时对象</a>，按引用绑定（即绑定初始化使用<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按引用传递</a>）的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>是<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>。</p>
<p>　　引入引用值的形式参数需要满足的要求由引入绑定的操作或派生实现指定。</p>
<p><strong>原理</strong></p>
<p>　　绑定临时对象时指定临时对象属性允许区分<a href="Features/NPL.zh-CN.html#%E7%94%9F%E5%AD%98%E6%9C%9F%E6%89%A9%E5%B1%95">通过引用绑定延长生存期的临时对象</a>和非引用绑定的对象。</p>
<p>　　一般地，表达式中的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>（非引用值）被绑定为临时对象，即被绑定的对象在初始化后具有<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">临时对象属性</a>。</p>
<p>　　这对应宿主语言中的转发引用参数（如 <code>std::forward</code> ）中的情形：</p>
<ul>
<li>若模板参数 <code>P</code> 对应转发引用函数参数 <code>P&amp;&amp;</code> ，其中 <code>P</code> 是对象或对象的右值引用类型，保留从实际参数<em>推导(deduce)</em> 得到的但不是实际参数类型的信息。</li>
<li>没有绑定临时对象属性的对象则同一般的非引用类型的对象类型参数（非转发引用）。</li>
</ul>
<p>　　<code>P</code> 在宿主语言中通过值类别推断，但不表示值类别。</p>
<p>　　类似宿主语言，这种操作数表达式的值类别以外的形式是一种<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">类型推断</a>。因为推断规则和宿主语言的<em>类型推导(type deducing)</em> 相似，这种上下文可支持类似宿主语言的参数转发。但和宿主语言的 <code>std::forward</code> 不同，此处推断的右值除了是<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">消亡值</a>外，也可以是<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>。</p>
<p>　　临时对象属性在绑定特定形式的参数时具有和 <code>P</code> 编码的附加信息类似的作用：</p>
<ul>
<li>不具有临时对象属性的引用值作为<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>，在初始化临时对象的引用时被视为<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>（不影响其余属性）。</li>
<li>其它表达式的推断结果是右值。</li>
</ul>
<p>　　带有临时对象属性的引用值和临时对象的引用值不同。特别地，作为引用属性值的临时对象属性允许在<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">运行时</a>作为对象的元数据<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>以及跟随对象被跨过程传递，这无法被宿主语言支持，因为 <code>P</code> 表示的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态类型</a>信息不在函数外可用，仅在模板的类型参数 <code>P</code> 中而不在运行时可访问的元数据中（事实上，也不在对象的动态类型中）保留。关于其应用，参见<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">进一步讨论</a>。</p>
<p><strong>注释</strong></p>
<p>　　因为宿主语言的引用折叠，以上 <code>P</code> 和 <code>P&amp;&amp;</code> 一致。</p>
<p>　　被绑定的这些对象可作为临时对象引用关联的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">绑定操作</a>。</p>
<h4 id="临时对象的表示"><a class="header" href="#临时对象的表示">临时对象的表示</a></h4>
<p>　　作为一等对象的临时对象和其它一等对象表示方式一致。</p>
<p>　　非一等对象临时对象包括：</p>
<ul>
<li>所有权可<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">被项独占</a>而不能作为一等对象访问的对象。</li>
<li>具有<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">临时对象标签</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>作为内部表示的对象。</li>
</ul>
<p>　　对临时标签对象决定的非一等对象，去除临时对象标签后，应具有一等对象表示。</p>
<p>　　在<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E8%A1%A8%E7%A4%BA">项引用</a>以外的临时对象标签仅在<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>上存在。</p>
<p>　　关于一等对象表示，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　至少在逻辑上，临时对象作为对象语言中不可见的对象和一等对象相同的宿主类型（即项）作为内部表示。因此，区分其内部表示并非通过宿主语言中的类型，而需通过运行时性质确定。</p>
<p>　　一些表示可能仅出现在临时对象中，而不是合法的一等对象表示。实现可据此进行一定运行时检查，以排除<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>或者错误实现中的误用。</p>
<p>　　对临时对象标签决定的非一等对象和一等对象表现之间的要求简化实现的一些操作，使<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">实质化</a>不需依赖另行分配的资源。</p>
<p>　　临时对象的子对象不是临时对象，简化对临时对象的一些操作，也减少可能使临时对象标签扩散（到非预期的上下文影响一等对象表示）而误用。</p>
<p>　　关于被绑定对象的规则，参见<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">绑定临时对象</a>中的原理。限制标签的使用范围以使之不和其它表示冲突。</p>
<p>　　关于实现中项的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>和简化实现的例子，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>注释</strong></p>
<p>　　直接构成项的非一等对象可以是通过<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源代码</a>中的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">外部表示</a>经<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">翻译</a>变换得到的具有内部表示的数据结构的非一等对象，参见上述实现中项的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>。</p>
<h3 id="表达式的类型"><a class="header" href="#表达式的类型">表达式的类型</a></h3>
<p>　　NPLA 的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">类型系统</a>使用<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">隐式类型</a>；默认使用<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">潜在类型</a>，保证<a href="Features/NPL.zh-CN.html#npla-%E6%95%B4%E4%BD%93%E7%BA%A6%E5%AE%9A">表达式的值具有类型</a>。</p>
<p>　　NPLA 表达式的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型</a>是表达式<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>的类型。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">空求值</a>的求值结果要求未求值的<a href="Features/NPL.zh-CN.html#%E7%BF%BB%E8%AF%91%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%A7%84%E5%88%99">合式的</a>表达式应具有和<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">语法分析</a>的实现的输出兼容的类型。</p>
<p>　　实现对特定的上下文的表达式可使用<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">类型推断</a>。由此确定的类型类似宿主语言的表达式的类型。</p>
<p>　　表达式具有<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">值类别</a>。值类别的指派规则作为<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">定型规则</a>是<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%80%BC%E7%B1%BB%E5%88%AB">类型系统的一部分</a>。但除非另行指定，值类别和 NPLA 及派生语言规则中描述的表达式的类型<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E4%BA%A4%E6%80%A7">正交</a>。</p>
<p>　　关于语法分析的实现和其中处理的类型，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>注释</strong></p>
<p>　　类型系统和 Scheme 及 Kernel 语言类似；除了表达式具有值类别这点和 Scheme 和 Kernel 不同而类似宿主语言。</p>
<p>　　表达式的类型和 [R<sup>7</sup>RS] 的 expression type 无关，后者是<a href="Features/NPL.zh-CN.html#%E8%AF%AD%E6%B3%95%E5%BD%A2%E5%BC%8F">语法形式</a>的约定（在 [R<sup>5</sup>RS] 和 [R<sup>7</sup>RS] 中称为 form ）；因为存在<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>的类型，不需要这种约定。</p>
<p>　　NPLA 中值类别和表达式的类型正交，这类似宿主语言。这简化了相关<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型规则</a>的描述。</p>
<h2 id="生存期附加约定"><a class="header" href="#生存期附加约定">生存期附加约定</a></h2>
<p>　　和宿主语言不同，NPLA 子表达式的求值顺序可被不同的函数（特别允许显式指定对特定<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>求值的<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">操作子</a>）中的求值调整，不需要特别约定。</p>
<p>　　NPLA 不存在宿主语言意义上的<a href="Features/NPL.zh-CN.html#%E4%B8%A5%E6%A0%BC%E6%80%A7">完全表达式</a>，但在按宿主语言规则判断生存期时，使用<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>的<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">函数合并</a>视同宿主语言的完全表达式，其本机函数调用不引起函数内创建的对象的生存期被延长。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的<a href="Features/NPL.zh-CN.html#npla-%E5%9F%BA%E7%A1%80%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">生存期</a>同时约束隐含的隐式宿主函数调用（如复制构造）。</p>
<p>　　为保证求值表达式取得的临时对象的<a href="Features/NPL.zh-CN.html#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>，函数合并同时满足以下规则：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作符</a>和未被求值的操作数的直接或间接子表达式关联的对象以及求值操作数的子表达式引入的临时对象的生存期结束的作用应不<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">后序</a>于<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">活动调用</a>结束。</li>
<li>生存期起始和结束的顺序被确定(determined) 时，和对应所在的表达求值之间的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序</a>关系同构；否则，其顺序满足<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">非决定性有序</a>关系。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　生存期的顺序约束确保引入临时对象时，其生存期不会任意地被<a href="Features/NPL.zh-CN.html#%E7%94%9F%E5%AD%98%E6%9C%9F%E6%89%A9%E5%B1%95">扩展</a>而超过<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>的求值。</p>
<p>　　具体操作可在以上约束下指定被求值的操作数可能引入的临时对象的生存期。</p>
<h2 id="尾上下文约定"><a class="header" href="#尾上下文约定">尾上下文约定</a></h2>
<p>　　NPLA 表达式<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值规约</a>中最后一个规约步骤中的上下文是<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">尾上下文</a>。</p>
<p>　　尾上下文在 NPLA 中可满足一些附加的性质。</p>
<h3 id="真尾规约"><a class="header" href="#真尾规约">真尾规约</a></h3>
<p>　　尾上下文涉及的存储在特定情况下满足调用消耗的空间有上界（即空间复杂度 <tt>O(1)</tt> ）。</p>
<p>　　满足这种情况下的规约称为<em>真尾规约(proper tail reduction)</em> 。</p>
<h3 id="尾调用和-ptc"><a class="header" href="#尾调用和-ptc">尾调用和 PTC</a></h3>
<p>　　在尾上下文规约的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">调用</a>是<em>尾调用(tail call)</em> 。</p>
<p>　　以<a href="Features/NPL.zh-CN.html#%E7%9C%9F%E5%B0%BE%E8%A7%84%E7%BA%A6">真尾规约</a>的实现尾调用允许具有不限定数量的(unbounded) <a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">活动调用</a>，称为 PTC（proper tail call ，真尾调用）。</p>
<p>　　PTC 占用<a href="Features/NPL.zh-CN.html#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">活动记录</a>满足真尾规约的上界的要求。</p>
<p>　　当宿主语言提供函数调用支持 PTC 时，可直接使用宿主语言的 PTC 调用，否则，需要使用其它替代实现机制确保 PTC 。</p>
<p>　　非对象语言的调用的上下文中，若被调用时间接使用，也仍需要保证 PTC 。</p>
<p>　　PTC 确保仅有一个<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">活动</a>的调用。不满足 PTC 的情形下，语言没有提供用户访问非<a href="Features/NPL.zh-CN.html#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">活动记录帧</a>资源的手段，因此可以认为是资源泄漏。但为简化语义规则，NPLA <a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">不要求避免相关的弱内存泄漏</a>。</p>
<p>　　NPLA 不添加保证活动记录帧中保存引用，销毁活动记录的帧可能影响环境中的变量生存期而改变语义。</p>
<p><strong>注释</strong> NPL 不保证一般对象存在<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>。</p>
<p>　　因此，除非依赖本节中以下的规则，NPLA 不保证提供 PTC 支持；实现更一般的 PTC 依赖派生实现定义的附加规则。</p>
<p>　　除非另行指定，NPLA 要求至少在被<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>中蕴含的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数应用</a>的求值支持 PTC 。</p>
<p>　　为满足 PTC ，在<a href="Features/NPL.zh-CN.html#%E7%94%9F%E5%AD%98%E6%9C%9F%E9%99%84%E5%8A%A0%E7%BA%A6%E5%AE%9A">生存期附加约定</a>的基础上，尾上下文内可以确定并调整对象生存期结束时机：</p>
<ul>
<li>作为<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>及其参数可以<a href="Features/NPL.zh-CN.html#%E7%94%9F%E5%AD%98%E6%9C%9F%E6%89%A9%E5%B1%95">延长生存期</a>至多到尾上下文结束。</li>
<li>被证明不再需要之后引用的对象，或未被绑定到活动记录上的项中的对象，可以缩短生存期。</li>
<li>被延长生存期的对象生存期起始和结束的相对顺序保持不变。</li>
<li>被缩短生存期的不同对象生存期结束的相对顺序保持不变。</li>
</ul>
<p>　　推论：被缩短生存期和延长生存期的对象的生存期结束的相对顺序保持不变。这由没有被调整生存期的对象与被调整生存期对象之间的生存期结束的<a href="Features/NPL.zh-CN.html#%E5%B0%BE%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BA%A6%E5%AE%9A">顺序关系</a>的传递性保证。</p>
<p>　　延长临时对象生存期和宿主语言中允许扩展非完全表达式内的临时对象的效果类似，但条件不同。</p>
<p><strong>原理</strong></p>
<p>　　要求 PTC 主要用例是支持 <a href="Features/NPL.zh-CN.html#ptr">PTR</a> 。相对 PTR ，PTC 更具有一般性，也适合对象语言<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>以外的普遍性质。</p>
<p><strong>注释</strong></p>
<p>　　以上规则中被调整生存期的对象一般仅是参数和函数体内创建的对象。因此，不保证理论上允许的尾上下文的都满足 PTC 。一个例子是合并子中可以保存<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">动态环境</a>，这个环境可能被递归的调用引用，而无法提前释放。</p>
<p>　　理论上 PTC 不要求延长生存期，仅要求特定情形下缩短生存期，且其它情形被释放的对象生存期不延长到尾上下文外。</p>
<p>　　允许延长生存期是<a href="Features/NPL.zh-CN.html#%E7%94%9F%E5%AD%98%E6%9C%9F%E9%99%84%E5%8A%A0%E7%BA%A6%E5%AE%9A">生存期附加约定</a>的结果。</p>
<h3 id="ptr"><a class="header" href="#ptr">PTR</a></h3>
<p>　　PTC 的活动记录性质也在一般的递归规约时体现，被称为 PTR（proper tail recursion ，真尾递归）。</p>
<p>　　和 PTC 不同，PTR 要求的递归规约不一定是对象语言中的调用，以 PTR 描述时仅强调递归，不考虑尾上下文的适用性。</p>
<p>　　通过特定的保持语义等价的变换，对象语言可要求尾上下文作用于函数调用以外的上下文中（例如非<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>的语法上下文）使用真尾规约实现。</p>
<p>　　除非派生实现另行指定，NPLA 对象语言不指定使函数调用以外的上下文作为尾上下文的要求；函数调用以外的尾上下文规约的仅可能用于实现的元语言中的<a href="Features/NPL.zh-CN.html#%E7%AE%A1%E7%90%86%E8%A7%84%E7%BA%A6">管理规约</a>；非管理规约的真尾规约都用于尾调用。</p>
<p>　　此时，PTR 等价被递归调用的 PTC 。但由于支持 PTC 在非递归规约情形时也影响语言实现的一般构造，所以描述要求时一般不以 PTR 代替 PTC 或真尾规约。</p>
<p>　　关于 PTR 在 Scheme 为基础的形式模型，参见 [Cl98] 。</p>
<p>　　PTR 的一个更激进的实现优化方式是 evlis tail recursion ，参见以下文献和参考资料：</p>
<ul>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.83.8567&amp;rep=rep1&amp;type=pdf">Continuation-Based Program Transformation Strategies</a></li>
<li>[Cl98]</li>
<li><a href="https://www.akalin.com/evlis-tail-recursion">Evlis tail recursion</a></li>
</ul>
<p>　　因为 NPLA 使用<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">链接的环境</a>，不支持实现其中更激进的 safe-for-space 保证。</p>
<p><strong>原理</strong></p>
<p>　　支持 PTR 使<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">重入</a>的函数调用保持较小的空间开销。这允许使用递归的函数调用代替尾上下文中特设的<em>循环(loop)</em> 和迭代语法实现等效的算法功能，满足<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>和<a href="Features/NPL.zh-CN.html#%E5%85%B6%E5%AE%83%E6%8E%A8%E8%AE%BA%E5%92%8C%E6%AF%94%E8%BE%83">通用性</a>。</p>
<p>　　与<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">控制状态和支持一等状态的实现之间具有的偶然耦合</a>不同，使用支持 PTR 的递归函数调用代替循环的耦合可以是足够必要的：它排除了特设的循环语法的需要，同时也能满足实现自身的<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>，也因此可能更高效。</p>
<p>　　为支持<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">一等对象</a>，可被共享的环境一般不支持<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">平坦的表示</a>。</p>
<p>　　不具有 safe-for-space 保证时，实现对程序的闭包变换(closure conversion) 可能创建多余的<a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>且无法被运行时有效地分辨，而造成<a href="Features/NPL.zh-CN.html#%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F">资源泄漏</a>。通过明确支持这类保证的变换（如<a href="http://flint.cs.yale.edu/flint/publications/escc.pdf">这里描述的设计</a> ）可避免变换引起资源泄漏。</p>
<p>　　只要捕获自由变量的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">静态环境</a>可被程序在创建函数时明确指定，safe-for-space 保证就不是必须的：避免在<a href="Features/NPL.zh-CN.html#%E7%94%9F%E5%AD%98%E6%9C%9F%E6%89%A9%E5%B1%95">语义规则约定</a>之外的生存期延长和资源泄漏是<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>的责任；NPLA 程序可精确控制对象生存期，同时应当避免<a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">循环引用</a>。</p>
<p>　　对 safe-for-space 保证的证明（如 [Cl98] 和 <a href="https://zoep.github.io/icfp2019.pdf">Closure Conversion Is Safe for Space</a> ），隐含要求和上述一等对象支持冲突的条件：环境中引用的对象总是可被复制的没有可观察行为的值。这实质上要求支持<a href="Features/NPL.zh-CN.html#%E5%85%B1%E4%BA%AB%E5%BC%95%E7%94%A8">共享引用</a>乃至可能要求一等对象都是<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>。</p>
<p>　　因为使用链接的环境的要求，一般情形<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">不支持</a>对 safe-for-space 的变换。</p>
<p>　　即便允许类似的变换，这也仅保证不存在<a href="Features/NPL.zh-CN.html#%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F">不可达</a>，仍然不保证资源被及时回收——<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">全局机制</a>可能具有不确定的延迟而造成的实时资源泄漏。</p>
<h3 id="tco"><a class="header" href="#tco">TCO</a></h3>
<p>　　TCO（Tail Call Optimization ，尾调用优化）是在以尾上下文规约时，允许减少修改规约状态的优化。</p>
<p>　　一般地，TCO 可重新排列规约过程中的被语义允许调整的副作用和其它不影响可观察行为的<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">状态</a>的调用，减小空间开销。</p>
<p>　　TCO 的这种性质可以在宿主语言不支持 <a href="Features/NPL.zh-CN.html#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C-ptc">PTC</a> 时用于实现<a href="Features/NPL.zh-CN.html#%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%AB%8B">对象语言的 PTC</a> 。</p>
<p><strong>注释</strong></p>
<p>　　关于 TCO 和 PTC 的差异，另见<a href="https://groups.google.com/d/msg/comp.lang.lisp/AezzhxTliME/2Zsq7HUn_ssJ">这里</a>。</p>
<h4 id="宿主语言中立"><a class="header" href="#宿主语言中立">宿主语言中立</a></h4>
<p>　　C++ 不要求实现支持 PTC ，也不保证支持 TCO 。因此，对象语言的 PTC 要求显式的 TCO 实现。</p>
<p>　　为可移植地支持 TCO ，NPLA 不依赖宿主语言中不可移植的<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>的活动记录（通常是体系结构相关的栈）。</p>
<p><strong>注释</strong></p>
<p>　　尾调用可避免尾上下文中非<a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8%E5%AE%89%E5%85%A8">嵌套调用安全</a>的情形的<a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8%E5%AE%89%E5%85%A8">宿主语言实现的未定义行为</a>，但不保证非尾上下文中具有类似的性质。</p>
<h4 id="tco-实现策略概述"><a class="header" href="#tco-实现策略概述">TCO 实现策略概述</a></h4>
<p>　　TCO 包括以下形式：</p>
<ul>
<li>静态 TCO ：实现时替换宿主语言中不保证满足 PTC 的构造为满足 PTC 的构造。</li>
<li>动态 TCO ：运行时调整直接或间接表示对象语言构造的数据结构和状态，使状态占用的空间复杂度满足 PTC 要求。</li>
</ul>
<p>　　静态 TCO 也适合非对象语言的调用的<a href="Features/NPL.zh-CN.html#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C-ptc">上下文</a>。</p>
<p>　　不依赖宿主语言特性的静态 TCO 包括以下形式：</p>
<ul>
<li>替换宿主语言实现中的不保证满足 PTC 的递归调用为满足 PTC 的结构（如循环结构），包括直接编码和自动的变换(transformation) ，称为宿主(host) TCO 。</li>
<li>替换不满足 PTC 的对象语言原语为满足 PTC 的表达形式，称为目标(target) TCO 。</li>
</ul>
<p>　　不依赖宿主语言特性的动态 TCO 包括以下形式：</p>
<ul>
<li>通过合并不同<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">活动调用</a>中活动记录占用的冗余状态，减少宿主语言的活动调用同时占用的总空间，称为 TCM（Tail Call Merging ，尾调用合并）。</li>
<li>引入具有便于操作<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制作用</a>的构造，同时作为一些其它优化的基础，以消除部分活动记录状态的分配，称为 TCE（Tail Call Elimination ，尾调用消除）。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　本节的内容不影响对象语言的语义，但可能影响<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>的接口兼容性和实现质量。</p>
<p>　　关于对实现的具体影响，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h2 id="npla-数学功能"><a class="header" href="#npla-数学功能">NPLA 数学功能</a></h2>
<p>　　NPLA 数学功能（模块 NPLAMath ）提供数学功能和相关支持。</p>
<p>　　关于 NPLA 数学功能的规格说明的其它部分，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h3 id="数值类型"><a class="header" href="#数值类型">数值类型</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#%E9%99%84%E5%8A%A0%E5%8A%9F%E8%83%BD">NPLA 数值</a>是 NPLA 对数学意义上的<em>数(number)</em> 的建模。</p>
<p>　　被建模的数是 NPLA 数值的<em>真值(true value)</em> 。</p>
<p>　　NPLA 数值的集合到真值的集合的映射是满射；除此之外，也存在不被 NPLA 数值建模的数，这些数可能被 NPLAMath 未来的版本支持作为真值。</p>
<p>　　除非另行指定，NPLA 数值的行为由对应的真值的数学含义决定。</p>
<p>　　基于宿主语言的类型系统，NPLA 支持以下按数值范围从小到大排列的本机整数和浮点数作为<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>：</p>
<ul>
<li><code>signed char</code></li>
<li><code>unsigned char</code></li>
<li><code>signed short</code></li>
<li><code>unsigned short</code></li>
<li><code>int</code></li>
<li><code>unsigned</code></li>
<li><code>long</code></li>
<li><code>unsigned long</code></li>
<li><code>long long</code></li>
<li><code>unsigned long long</code></li>
<li><code>float</code></li>
<li><code>double</code></li>
<li><code>long double</code></li>
</ul>
<p>　　文法表示：</p>
<p>　　支持的数值类型以 <code>&lt;number&gt;</code> 表示，具有以下表示数值的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>：</p>
<ul>
<li><code>&lt;complex&gt;</code> ：复数。</li>
<li><code>&lt;real&gt;</code> ：实数。</li>
<li><code>&lt;rational&gt;</code> ：有理数。</li>
<li><code>&lt;integer&gt;</code> ：整数。</li>
</ul>
<p>　　其子类型由数学定义蕴含，即以上类型中，后者依次是前者的子类型。</p>
<p>　　当前所有数值都是 <code>&lt;real&gt;</code> ，因此暂时没有针对 <code>&lt;number&gt;</code> 值是否属于 <code>&lt;real&gt;</code> 和 <code>&lt;complex&gt;</code> 的类型检查。</p>
<p>　　和数学意义上的实数不同，<code>&lt;real&gt;</code> 也包含以下可带符号(sign) 的<em>特殊值(special value)</em> ：</p>
<ul>
<li>无限大值。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/NaN">NaN(not a number)</a> 值。</li>
</ul>
<p>　　对应地，<code>&lt;complex&gt;</code> 也包含实部和/或虚部是上述特殊值的特殊值。</p>
<p><strong>注释</strong> 当前所有复数都是实数，因此虚部总是 0 。</p>
<p>　　根据数值是否完全保留真值在数学上的唯一性即<em>精确性(exactness)</em> ，数值分为<em>精确数(exact number)</em> 和<em>不精确数(inexact number)</em> 。</p>
<p>　　精确数和对应的真值总是相等；不精确数和真值不严格相等。</p>
<p>　　有限的不精确数的偏离程度可通过实数描述，即（绝对）<em>误差(error)</em> 。精确数的误差恒等于 0 。</p>
<p>　　除非另行指定，特定不精确数的具体的误差是未指定的。</p>
<p>　　数值的绝对<em>精度(precision)</em> 是其内部表示蕴含的误差的上界的倒数。对确定使用进位制的表示，精度也指精确表示的数值位数。</p>
<p>　　数值的<em>任意精度(arbitrary precision)</em> 指除<a href="Features/NPL.zh-CN.html#%E8%B5%84%E6%BA%90%E5%8F%AF%E7%94%A8%E6%80%A7%E5%9F%BA%E6%9C%AC%E7%BA%A6%E5%AE%9A">实现环境的可用资源（一般即存储空间）限制</a>外，不限制精度。</p>
<p><strong>注释</strong> 为支持更多数学上有意义的真值，未来可能引入其它类型来表示任意精度的整数、有理数及数学意义上的扩展（如复数和四元数）。</p>
<p>　　数值的内部表示中能以实数描述的度量应至少具有整数数量级精度，即误差不大于 1 。</p>
<p>　　精确数和不精确数在数值上可能相等，而<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">类型不同</a>。</p>
<p>　　宿主类型中的本机整数和浮点类型是数值类型的子类型，分别称为 fixnum 和 flonum 。这些类型在项的内部表示预期直接占据本机存储而不需要动态分配。</p>
<p>　　Fixnum 总是精确数；flonum 总是不精确数。</p>
<p><strong>注释</strong> 当前实现中，所有数值是 fixnum 或 flonum 之一。两者分别是宿主的整数类型（排除字符和 <code>bool</code> 类型）以及浮点数类型。</p>
<p>　　Flonum 支持带符号的无限大值以及 NaN 值作为特殊值。其它值都是有限值。特殊值可能具有不唯一的内部表示，但和有限值的表示都不同。</p>
<p>　　Flonum 中可存在小的非零数，可能和其它数值不同的内部表示而更容易在计算中损失精度，即非规格化(denormalized) 数值。</p>
<p>　　整数值的数值具有整数类型。这包括所有的 fixnum ，以及 flonum 中是整数的数值。这不和宿主类型直接对应。</p>
<p><strong>注释</strong> 一个 flonum 是整数，当且仅当它的值取整后结果和原值相等。这里的取整使用可使用任意的舍入。[R<sup>7</sup>RS] 对不精确数有类似的定义（仅使用 round ）。</p>
<p>　　对 fixnum ，<code>+0</code> 和 <code>-0</code> 是相等的数值。Flonum 不同符号的零值在值的表示中可以不同，但在数学意义上相等，表示同一个数。实现中的其它和具体表示无关的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">等价谓词</a>是否表现这种不同是未指定的。</p>
<p><strong>注释</strong></p>
<p>　　NPLA 的不同的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义</a>数值类型的集合到宿主类型的集合的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">类型映射</a>是满射，即本节指定的宿主类型总是关联至少一个能表示它的值的 NPLA 数值类型。</p>
<p>　　同时，NPLA 数值类型可以映射到其它类型，特别地，NPLA 整数的类型映射目标是宿主语言整数类型和包含整数值的非典型<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>的并。所以，NPLA 数值整体的类型映射不构成简单的一对多或多对多关系。</p>
<p>　　特殊值同 ISO/IEC 10967–1 (LIA–1) 定义，引用 [IEC 60559] (IEEE-754) 的具体值，仅适用于浮点数。</p>
<p>　　无限大值在数学上属于<em>超实数(hyperreal number)</em> ，在浮点数实现中属于<em>扩展实数(extended real number)</em> 。</p>
<p>　　无限大值的符号在数学意义上是必要的，因此也被要求区分。</p>
<p>　　精确性、fixnum 和 flonum 等区分同 [R<sup>6</sup>RS] ，但具体实现要求不尽相同。</p>
<p>　　NaN 不是数学意义上的数，表示特定的没有数学定义的计算结果。NaN 和任何数值比较总是不相等。</p>
<p>　　NPLA 的宿主语言支持的 NaN 值带有符号。不是所有实现都区分符号，如 [ECMAScript] 。</p>
<p>　　整数精度外的数量级精度仅在确定使用的进位制底数时和绝对精度可比较，因此常用于描述特定实现的内部表示（例如，[ISO C] 定义的浮点数精度即有效数字的位数）。但是，不比较具体大小时，有限的数量级精度和绝对精度性质可以一致，这种上下文可不区分两者。</p>
<p>　　大多数不精确数的浮点表示的高效实现使用底数 2 。</p>
<p>　　参照 [IEC 60559] ，浮点格式的无限大值和有限数值是浮点数；NaN 不是浮点数。两者统称为<em>浮点数据(floating-point datum)</em> 。</p>
<p>　　宿主类型中实现为 [IEC 60559] 的<em>非规格化(denormalized)</em> 浮点数是具有不唯一的内部表示的小的非零数值。使用 IEEE-754 2008 以来的定义，这些数是<em>非规格(subnormal)</em> 数。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，本文档没有指定可选的模块，也没有指定精确的 ±∞ 值。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，不精确数不指定边界和<em>主值(primary value)</em> ，NaN 值被显式提供而不是唯一的 <code>#undefined</code> 值，非规格数不作为 <code>#undefined</code> 。这同时不要求在任意的操作中检查 <code>#undefined</code> 值并<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　尽管容易损失精度，区分不同的非规格数的数值仍然有意义。同时，也避免和 NaN 用以表示数学上未定义操作的结果（如 0 除以 0 ）引起混淆。</p>
<p>　　数值相等和一般对象相等可使用不同的等价谓词。和一般对象比较不同，数值相等比较可对参数要求数值类型，否则引起错误。两者比较结果可能也不总是相同。如 Scheme 的 <code>=</code> 和 <code>eqv?</code> 以及 Kernel 的 <code>=?</code> 和 <code>equal?</code> 。</p>
<h3 id="数值操作约定"><a class="header" href="#数值操作约定">数值操作约定</a></h3>
<p>　　在对象语言中，数值操作是可使用数值作为算法输入的值的操作。NPLA1 提供本机 API 支持这些操作的实现。</p>
<p>　　数值操作数和非数值操作数分别是具有和不具有数值类型的操作数。</p>
<p>　　数值操作蕴含对应的数值计算，接受至少一个数值或非数值操作数，预期得到<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">计算结果</a>。</p>
<p><strong>注释</strong> 非预期情形可<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　其中，计算结果依赖影响计算结果的操作数，并依赖至少一个数值操作数。</p>
<p>　　除非另行指定：</p>
<ul>
<li>在数学上有意义的前提下，数值操作同时支持以上尽可能多的数值类型的操作数。</li>
<li>数值操作对预期的数值操作数进行<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>，失败时出错。</li>
<li>数值操作不区分数值操作数中对应的真值相等的精确数或不精确数。</li>
<li>可假定数值操作数和计算过程中不出现 <a href="https://en.wikipedia.org/wiki/NaN#Signaling_NaN">SNaN(signaling NaN) (en-US)</a> 值。</li>
<li>若作为操作数的精确数决定计算结果在数学上未定义，则引起错误。</li>
<li>不精确数计算中的舍入方式未指定。</li>
<li>若计算结果是数值，则：
<ul>
<li>若被计算结果依赖的任一操作数中具有 NaN 值，则依赖这个操作数的数值操作结果也是 NaN 值。</li>
<li>输出的类型的值域能表示操作结果；除操作的语义和本节的其它规则蕴含外，具体类型未指定。</li>
<li>若作为操作数的精确数决定的计算结果是不精确数表示的有限数值，则这个不精确数应是所有相同内部表示的数值中和结果的真值误差最小的数值。</li>
<li>对数学上封闭的计算，结果具有不超过所有数值操作数范围的数值类型。</li>
<li>除非不能在结果类型中表示计算结果的范围：
<ul>
<li>若数值操作的所有数值操作数都是精确数，结果不是不精确数。</li>
<li>数值操作的实现不损失按数学定义得到的中间结果的<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">精度</a>；结果的<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">误差</a>仅来自其依赖的数值操作数引入的累积误差。</li>
</ul>
</li>
<li>若计算结果是不精确数，则：
<ul>
<li>若计算结果是小于最小可唯一表示的 <code>&lt;real&gt;</code> 值，则对应的数值操作结果是不精确数 0 。</li>
<li>计算结果中真值等于 0 的数值以及 NaN 值的符号是未指定的。</li>
<li>若计算结果中无限大数值不能通过数学上有意义的方式确定符号，则对应的数值操作结果是无限大值或 NaN 之一，具体选择未指定。</li>
</ul>
</li>
<li>数值的宿主类型未指定。</li>
</ul>
</li>
</ul>
<p><strong>原理</strong></p>
<p>　　因为典型的高效实现实现依赖<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">外部环境</a>对浮点数的支持，设计策略以保持<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>的便利性相关。</p>
<ul>
<li>NPLAMath 实现不访问 SNaN 值，也不需要访问宿主语言的浮点环境，但不假设总是使用默认浮点环境。
<ul>
<li>这不阻止和使用 SNaN 的<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>的程序链接和调用，这有助于保持互操作性。</li>
<li>NPLAMath 实现不保证检查访问浮点环境的副作用是否存在。若互操作需要改变浮点环境，应避免破坏实现的假设。</li>
</ul>
</li>
<li>不依赖零值的符号、NaN 的符号以及 SNaN 的处理和许多<a href="Features/NPL.zh-CN.html#%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0">宿主实现</a>的默认情形一致而能简化一般的实现，如：
<ul>
<li><a href="https://gcc.gnu.org/wiki/FloatingPointMath">GCC</a> 。</li>
<li><a href="https://docs.microsoft.com/cpp/build/reference/fp-specify-floating-point-behavior">Microsoft VC++</a> 。</li>
<li>不要求使用 GCC 时启用 <code>-ffloat-store</code> 。Microsoft VC++ 默认的 <code>/fp:precise</code> 的类似语义也不被依赖。</li>
</ul>
</li>
</ul>
<p><strong>注释</strong></p>
<p>　　数值操作可能允许非数值的操作数，这些操作数也可被计算结果依赖。</p>
<p>　　因为 <a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">flonum</a> 能表示所有实数数值范围，所以实数范围以内的操作不会引入操作数以外的其它 flonum 类型。</p>
<p>　　数值操作抛出异常的要求不一定在每一个实现数值操作的 <a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 中蕴含，因为这些 API 不一定是数值操作的完整实现。</p>
<p>　　抛出异常和<a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>的异常和浮点异常没有直接关联。</p>
<p>　　若数值操作指定非数值计算结果（如<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">布尔值</a>）或者不能表示的 NaN 值的计算结果，则即使依赖 NaN 数值操作数，也不是 NaN 值。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，数值操作不支持不同的全局模式。</p>
<p>　　特定情形下，精确数可能替换计算结果中的不精确数：</p>
<ul>
<li>当按数学定义能被精确表示时，计算结果可以是符合要求的任意一个类型的精确数。</li>
<li>否则，当实现能证明不精确数值足够小到不足以影响结果的表示，且存在真值相等的可用的精确数时，可使用这个精确数代替不精确数。</li>
<li>当前实现没有这类证明机制。</li>
</ul>
<p>　　IEEE-754 使用<em>渐进下溢(gradual underflow)</em> ，使零值和相邻的非零浮点数的真值之差不会显著大于其它两个浮点数真值的差，而使小的非零浮点数之间的差不等于零。这体现了支持<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">非规格化数</a>的实际作用。但一般数值计算仍需要累积误差。</p>
<p>　　虽然可能影响结果，浮点数实现的内部状态（如舍入模式）的访问不被直接支持。</p>
<p>　　浮点数 0 和 0 之差的符号可能取决于舍入模式。数值操作一般不保证结果 0 的符号，但以依赖<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E8%A1%A8%E7%A4%BA">表示的形式</a>仍可确定符号。</p>
<p>　　除满足必要的精度要求的前提外，互操作以外目的的数值的宿主类型的具体选择在维持计算正确性的意义上通常不重要，因此默认不要求指定。</p>
<p>　　对特殊值，因为 [R<sup>n</sup>RS] 只要求 <code>.0</code> 后缀的特殊值字面量，需保持兼容时，程序可只使用这些形式的字面量。为此，实现可使用带有 <code>.0</code> 后缀特殊值的数值字面量的对应的宿主类型，以减少潜在的可移植问题。</p>
<p>　　关于派生实现支持的数值字面量，参见 <a href="Features/NPL.zh-CN.html#npla1-%E6%95%B0%E5%80%BC%E5%AD%97%E9%9D%A2%E9%87%8F">NPLA1 数值字面量</a>。</p>
<h3 id="数值表示"><a class="header" href="#数值表示">数值表示</a></h3>
<p>　　支持解析的数值以字符串作为外部表示。作为字面量时，构成<a href="Features/NPL.zh-CN.html#npla-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F">数值字面量的词法</a>。</p>
<p>　　数值的外部表示和内部表示应支持<em>往返(round-trip)</em> 转换，即转换的内部或者外部表示输出可被输入接受。</p>
<p>　　往返转换中，精确数转换保持任意（无限）精度；不精确数经有限次转换不继续损失精度。</p>
<p><strong>注释</strong> 即便损失精度，也应总是满足结果至少不低于<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">整数精度</a>。</p>
<p>　　支持的外部表示和对应的含义具体包括：</p>
<ul>
<li>数值的外部表示中起始的一个 <code>+</code> 或 <code>-</code> 字符指定符号。
<ul>
<li>这可能是可选的。若符合规则的数值字面量没有指定符号，则隐含为 <code>+</code> 。</li>
<li><strong>注释</strong> 不精确数可能在内部表示支持不同符号的<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">零值</a>。</li>
</ul>
</li>
<li>以下优先匹配较长的模式。</li>
<li>匹配<a href="https://zh.wikipedia.org/zh-cn/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a> <code>(+|-)?[0-9]+</code> ：十进制整数值。
<ul>
<li>不论符号，当前精确数数值字面量默认都具有<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a> <code>int</code> ，除非其绝对值太大而无法被表示，使用其它类型代替。</li>
<li>除非精确数字面量的数值超过所有 <a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">fixnum</a> 的可表示范围，都具有 fixnum 值。</li>
<li>除非精确数字面量的数值超过所有支持的精确数的可表示范围，都是精确数。</li>
<li><strong>注释</strong> 当前精确数的表示范围是 fixnum 中宿主类型的值域的并集，因此超过 fixnum 可表示范围的数值不是精确数。</li>
</ul>
</li>
<li>匹配正则表达式 <code>(+|-)?[0-9]+\.[0-9]*</code> 或 <code>(+|-)?[0-9]+(\.[0-9]*)?(E|e|S|s|F|f|D|d|L|l)(+|-)?[0-9]+</code> ：十进制不精确数数值。
<ul>
<li>不精确数数值字面量的解析使用未指定的浮点数舍入模式，其<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">误差</a>不大于最后一个在规格化范围内表示的十进制小数位为 1 时的绝对值的真值大小。</li>
<li>解析不精确数外部表示得到的真值和内部表示可具有误差。
<ul>
<li><strong>注释</strong> 误差和具体宿主语言支持相关，通常以任意可能符合宿主语言要求的舍入模式下的最大值计。</li>
</ul>
</li>
<li>第一种形式是直接记法。</li>
<li>第二种形式是<a href="https://zh.wikipedia.org/zh-cn/%E7%A7%91%E5%AD%A6%E8%AE%B0%E6%95%B0%E6%B3%95">科学记数法(scientific notation)</a> ，在指示指数的指数字母前后匹配的数字序列分别是有效数字(significand) 和指数(exponent) 。
<ul>
<li>指数字母表示作为 <a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">flonum</a> 的不同精度：
<ul>
<li><code>E</code> 或 <code>e</code> ：默认精度。</li>
<li><code>S</code> 或 <code>s</code> ：短(short) 精度。</li>
<li><code>F</code> 或 <code>f</code> ：单精度(float) 。</li>
<li><code>D</code> 或 <code>D</code> ：双精度(double) 。</li>
<li><code>L</code> 或 <code>l</code> ：长精度(long) 。</li>
<li>同组的字母含义等价。以上精度中，默认精度不低于双精度，其它精度依次不低于之前的一个。</li>
</ul>
</li>
<li>精度可影响内部存储的宿主类型。</li>
</ul>
</li>
<li>若字面量指定的数值小于或大于使用的类型的数值表示范围，则值为对应类型具有相同符号的零值或<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">无限大值</a>。</li>
</ul>
</li>
<li>匹配正则表达式 <code>(+|-)(inf|nan)\.(0|f|t)</code> ：带符号的 flonum 特殊值。
<ul>
<li>其中，<code>inf</code> 指定无限大值，<code>nan</code> 指定 NaN 值。</li>
<li>后缀指定精度：
<ul>
<li><code>0</code> ：默认精度。</li>
<li><code>f</code> ：单精度。</li>
<li><code>t</code> ：扩展(extended) 精度。</li>
<li>以上精度中，默认精度不低于双精度，扩展精度不低于默认精度。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　除非派生实现另行指定，以上要求外的数值的子类型和内部表示未指定。</p>
<p><strong>原理</strong></p>
<p>　　浮点数解析存在不同精度的算法。</p>
<p>　　若以二进制浮点数和经过舍入的十进制表示相互转换不损失精度为前提，宿主语言的 <a href="http://eel.is/c++draft/numeric.limits"><code>std::numeric_limits</code></a> 的 <a href="http://eel.is/c++draft/numeric.limits.members#14"><code>max_digits10</code></a> 位十进制数字足够表示。</p>
<p>　　（对 [IEC 60559] 的二进制浮点数情形的证明参见<a href="https://www.itu.dk/~sestoft/bachelor/IEEE754_article.pdf">这里</a>的 Theorem 15 。）</p>
<p>　　但是，对任意有效输入的结果误差都不大于 1 <a href="https://zh.wikipedia.org/zh-cn/%E6%9C%80%E5%90%8E%E4%B8%80%E4%BD%8D%E4%B8%8A%E7%9A%84%E5%8D%95%E4%BD%8D%E5%80%BC">ULP(unit in the last place)</a> 的不经舍入的值完全精确值(full precision) 的精确解析算法，对实现的要求较高，且性能可能明显较低，故不作要求。</p>
<p>　　（对 [IEC 60559] 的二进制浮点数的情形，需要数十倍的中间存储，参见<a href="https://stackoverflow.com/questions/554063/62542806">这里</a>。）</p>
<p>　　和宿主语言的 <code>std::strtod</code> 不同，允许使用宿主语言中的任意浮点数舍入模式，而不要求不同浮点数舍入模式下的结果一致性。</p>
<p>　　浮点数精度的 <code>float</code> 和 <code>double</code> 在典型实现中的内部表示格式同 [IEC 60559] 的二进制的单精度和双精度浮点数。</p>
<p><strong>注释</strong></p>
<p>　　串模式 <code>(+|-)</code> 表示带有可选前缀符号（仅限一个），影响值的数值。</p>
<p>　　同 klisp 而不同于 [R<sup>n</sup>RS] 的字面量词法，小数点不能出现在词素中符号以外的第一个字符；但 klisp 的 <code>string-&gt;number</code> 没有这个限制。</p>
<p>　　同 [R<sup>n</sup>RS] 而不同于 klisp（两者包括字面量词法和 <code>string-&gt;number</code> ），小数点允许出现在词素的结尾。</p>
<p>　　当前不精确数数值都具有宿主类型 <code>double</code> 。即便 <code>long double</code> 可能具有更大的数值范围，也不能通过解析数值表示直接取得。</p>
<p>　　类似地，[Racket] 默认不启用 <a href="https://docs.racket-lang.org/reference/extflonums.html">extflonum</a>。关于数值操作也类似，参见<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">数值操作约定</a>。</p>
<p>　　当前允许在<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主值</a>不能完全存储不精确数的字面量数字时，解析十进制不精确数字面量存储的值可能和字面量的数值的真值之间具有超过 1ULP 的误差。这可能影响和精确数之间的比较。</p>
<p>　　当前实现使用四舍五入。</p>
<p>　　关于宿主语言中 <a href="http://www.eel.is/c++draft/cstdlib.syn#lib:strtod"><code>std::strtod</code></a>（同 [ISO C] 标准库的 <code>strtod</code> ）舍入要求的一些问题，参见：</p>
<ul>
<li><a href="https://www.exploringbinary.com/incorrectly-rounded-conversions-in-gcc-and-glibc/">Incorrectly Rounded Conversions in GCC and GLIBC</a></li>
<li><a href="https://www.sourceware.org/bugzilla/show_bug.cgi?id=3479">Incorrect rounding in <code>strtod()</code></a></li>
</ul>
<p>　　数值字面量的词法同 [R<sup>n</sup>RS] 的一个子集。</p>
<p>　　[R<sup>n</sup>RS] 指出实现可能允许用户修改不同的默认精度。这指出精度不是固定的，但不是实现要求。
　　[R<sup>n</sup>RK] 的有限数的对应子集接近 [R<sup>n</sup>RS] 的设计，但没有明确指定字面量词法规则。其中对精度的表述略有不同：</p>
<ul>
<li>没有指定大写字母。</li>
<li>指定 <code>s</code> 、<code>f</code> 、<code>d</code> 和 <code>l</code> 的精度递增，没有显式允许不同的精度映射到相同的内部格式。</li>
<li>没有显式允许用户指定的默认精度。</li>
</ul>
<p>　　但是，SINK 和 klisp 实际上都不符合前两点，而更符合 Scheme 的实现。[R<sup>n</sup>RK] 在此可能不完善或表述有误。</p>
<p>　　当前 klisp 的实现不允许 <code>E</code> 和 <code>e</code> 之前没有小数点，且在存在 <code>E</code> 或 <code>e</code> 时省略之后的指数的任意部分，和 SINK 以及 [R<sup>n</sup>RS] 都不同。本设计遵循后者。</p>
<p>　　当前 NPLAMath 精度对应的宿主类型指派如下：</p>
<ul>
<li>非特殊值：
<ul>
<li><code>e</code> ：同 <code>d</code> 。</li>
<li><code>s</code> ：同 <code>f</code> 。</li>
<li><code>f</code> ：<code>float</code> 。</li>
<li><code>d</code> ：<code>double</code> 。</li>
<li><code>l</code> ：<code>long double</code> 。</li>
</ul>
</li>
<li>特殊值：
<ul>
<li><code>0</code> ：<code>double</code> 。</li>
<li><code>f</code> ：<code>float</code> 。</li>
<li><code>t</code> ：<code>long double</code> 。</li>
</ul>
</li>
</ul>
<p>　　指定特殊值的精度的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">词素</a>语法兼容 [Racket] 。</p>
<h1 id="npla1-核心语言"><a class="header" href="#npla1-核心语言">NPLA1 核心语言</a></h1>
<p>　　NPL 是独立设计的，但其派生语言和其它一些语言有类似之处；这些语言和 NPL 方言之间并不具有派生关系。但为简化描述，部分地引用这些现有<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">语言规范</a>中的描述，仅强调其中的不同。</p>
<p>　　NPLA1 符合 NPL 和 NPLA 的语言规则，其<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">实现环境</a>还应提供本章起的其它程序接口。</p>
<p>　　互操作中的一些接口处理的值可约定<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>。但这些类型不一定在<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>层次上稳定，可能在之后的版本变化。稳定性由具体实现提供的附加规则（若存在）保证。</p>
<p>　　NPLA1 和 Kernel 语言（即 [R<sup>n</sup>RK] ）的特性设计（如 <a href="Features/NPL.zh-CN.html#vau-%E6%8A%BD%E8%B1%A1">vau</a>和作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>的环境表达<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">过程抽象</a>）有很多类似之处，因此许多概念是通用的；但从<a href="Features/NPL.zh-CN.html#%E9%A2%86%E5%9F%9F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">设计哲学</a>到本章介绍的各个细节（如<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">默认求值规则</a>）都存在深刻的差异。</p>
<p>　　部分名称指定的操作和 [R<sup>n</sup>RS] 或 <a href="http://klisp.org/docs/index.html">klisp</a> 指定的类似。</p>
<p>　　以下章节主要介绍和 Kernel 约定不同的设计。各节的通用约定不再在之后的各个接口单独说明。</p>
<h2 id="npla1-对象语言约定"><a class="header" href="#npla1-对象语言约定">NPLA1 对象语言约定</a></h2>
<p>　　NPLA1 仅使用<a href="Features/NPL.zh-CN.html#npla-%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83">宿主语言</a>的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型</a>和<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>作为在对象语言可表达的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">状态</a>。</p>
<p>　　在 <a href="Features/NPL.zh-CN.html#npla">NPLA</a> 的基础上，NPLA1 要求对象语言支持以一等对象作为表达式并被<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">类型等价性</a>基于<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">类型映射</a>及其实现，由 [ISO C++] 的语义规则定义。</p>
<p>　　值等价性由<a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>的 <code>==</code> 表达式的结果定义。</p>
<p>　　除非另行指定，所有类型的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">外部表示</a>都是允许从作为内部表示的<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">项节点</a>确定的同<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>的空字符结尾的字符串（即 [ISO C++] 的 <a href="https://eel.is/c++draft/defns.ntcts">NTCTS</a> ）。</p>
<p>　　关于作为表达式的求值和类型映射的实现，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h3 id="标识符附加规则"><a class="header" href="#标识符附加规则">标识符附加规则</a></h3>
<p>　　当前仅支持<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">标识符</a>作为<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0">名称</a>。</p>
<p>　　部分名称是<a href="Features/NPL.zh-CN.html#npla-%E5%90%8D%E7%A7%B0%E5%92%8C%E5%AD%97%E9%9D%A2%E9%87%8F%E6%B1%82%E5%80%BC">保留名称</a>：含有 <code>$$</code> 的名称保留给宿主交互使用；含有 <code>__</code> 的名称保留给 NPLA1 实现。</p>
<p>　　在 <a href="Features/NPL.zh-CN.html#npla-%E6%95%B4%E4%BD%93%E7%BA%A6%E5%AE%9A">NPLA 规则</a>的基础上，在<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">内部表示</a>中显式使用保留给实现的标识符的程序<a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">行为未定义</a>。</p>
<p><strong>注释</strong> 这包含在源代码以外的中间表示使用的情形，但不包含作为用户输入的数据。</p>
<h2 id="npla1-互操作约定"><a class="header" href="#npla1-互操作约定">NPLA1 互操作约定</a></h2>
<p>　　基本规则参见 <a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">NPLA 互操作支持</a>。</p>
<p>　　非 NPLA1 实现提供的类型的宿主 <code>==</code> 操作不要求支持<a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8%E5%AE%89%E5%85%A8">嵌套调用安全</a>。</p>
<p>　　作为 NPLA1 嵌套调用安全的约定的扩展，若存在 == 操作不支持嵌套调用安全的类型，具体类型由派生实现的定义。</p>
<p>　　对象语言操作和互操作不修改对象语言中已经可见的<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">一等环境</a>的<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">父环境</a>。</p>
<p><strong>原理</strong></p>
<p>　　NPLA1 中提供的类型仍需要支持嵌套调用安全，以满足嵌套调用安全的约定中的要求。</p>
<p>　　关于 NPLA1 嵌套调用安全的具体约定和其它实现原理，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p>　　避免修改已在对象语言可访问的一定对象的父环境符合同 [R<sup>n</sup>RK] 的环境<a href="Features/NPL.zh-CN.html#%E5%B0%81%E8%A3%85">封装性</a>对对象语言的要求。这允许实现假定仅在有限的上下文中父环境可修改，而减少优化实现的难度。</p>
<h2 id="npla1-程序实现"><a class="header" href="#npla1-程序实现">NPLA1 程序实现</a></h2>
<p>　　本章指定 NPLA1 对象语言的<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">核心语言特性</a>。包含<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">库特性</a>的其它设计参见 <a href="Features/NPL.zh-CN.html#npla1-%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83">NPLA1 参照实现环境</a>。</p>
<p><strong>原理</strong></p>
<p>　　一般的语言能支持不同实现形式的库，包括<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源程序</a>和其它无法判断是否和特定源程序关联的翻译后的程序。</p>
<p>　　复用这些程序时，可能需要根据不同的形式而分别处理：源代码被读取和<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>而加载，而其它格式的翻译形式可能直接映射存储后经特定的检查即被加载。</p>
<p>　　但是在可复用的意义上，这些不同的形式是一致的，都视为库。</p>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RK] 不同，库不限定其实现形式。[R<sup>n</sup>RK] 指定的库实质上是可使用对象语言派生实现的库。</p>
<p>　　典型的静态语言不保证程序执行时能对源程序进行翻译，因此加载程序的限制通常更大，可能无法处理源程序形式的库而首先需要分离翻译为其它格式。NPL 一般不具有这个限制。</p>
<p>　　关于对象语言的<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">派生实现</a>，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h3 id="npla1-程序外部环境"><a class="header" href="#npla1-程序外部环境">NPLA1 程序外部环境</a></h3>
<p>　　基于 <a href="Features/NPL.zh-CN.html#npla-%E6%95%B4%E4%BD%93%E7%BA%A6%E5%AE%9A">NPLA 整体约定</a>，由 <a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">NPL-EMA</a> ，NPLA 的实现不假定存在多线程执行环境。</p>
<p>　　但是，宿主语言可支持多线程环境执行，<a href="Features/NPL.zh-CN.html#npla-%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE">可引起宿主语言的未定义行为</a>。</p>
<p>　　作为 NPLA 的派生，NPLA1 对象语言程序也具有相同的性质，除非另行指定需要和<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">外部环境</a>交互的特定操作，不需要假定 NPLA1 引入存在多线程执行环境。</p>
<h3 id="附加元数据"><a class="header" href="#附加元数据">附加元数据</a></h3>
<p>　　NPLA1 实现可提供和<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">实现环境</a>或具体 NPLA 对象关联的附加的资源，用于提供程序运行时可得到的附加信息，如源代码位置。</p>
<p>　　是否存在这些<em>附加元数据(extra metadata)</em> 和附加元数据的具体内容可影响特定的行为。</p>
<p><strong>注释</strong> 如符合<a href="Features/NPL.zh-CN.html#%E8%AF%8A%E6%96%AD">诊断</a>中要求的实现的具体行为。</p>
<p>　　这些影响是未指定的，但除 NPLA1 程序直接依赖具体数据而进行的操作外，不应影响程序的其它语义（例如，引起程序终止）。</p>
<h3 id="npla1-扩展支持"><a class="header" href="#npla1-扩展支持">NPLA1 扩展支持</a></h3>
<p>　　本章中除<a href="Features/NPL.zh-CN.html#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>的限制外，不支持的特性可能会在之后的实现中扩展并支持。</p>
<h3 id="npla1-未定义行为"><a class="header" href="#npla1-未定义行为">NPLA1 未定义行为</a></h3>
<p>　　NPLA1 对象语言程序中的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未定义行为</a>包括 <a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">NPLA 未定义行为</a>和以下扩展 NPLA 未定义行为：</p>
<ul>
<li>特定情形下<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">访问被修改的环境中绑定的对象</a>。</li>
<li>特定情形下违反对环境的使用要求。
<ul>
<li><strong>注释</strong> 参见<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7">环境的稳定性</a>。</li>
</ul>
</li>
<li>特定情形下违反对外部实现环境假定的使用要求。
<ul>
<li><strong>注释</strong> 参见<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%8A%A0%E8%BD%BD">模块的初始化和加载</a>。注意虽然可能通过环境实现，但这在接口的意义上独立于环境的稳定性。</li>
</ul>
</li>
<li>NPLA1 库约定的未定义行为。
<ul>
<li><strong>注释</strong> 有些未定义行为不需要被显式约定，例如不支持的并发访问<a href="Features/NPL.zh-CN.html#npla1-%E7%A8%8B%E5%BA%8F%E5%A4%96%E9%83%A8%E7%8E%AF%E5%A2%83">可引起宿主语言的未定义行为</a>，属于 NPLA 未定义行为。</li>
</ul>
</li>
</ul>
<p>　　派生语言可约定其它未定义行为。</p>
<p><strong>原理</strong></p>
<p>　　扩展 NPLA 未定义行为可提供更严格的要求使实现更简化。</p>
<p>　　关于环境的一些未定义行为可视为违反<a href="Features/NPL.zh-CN.html#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>，而不需要单独实现。</p>
<h2 id="接口文法约定"><a class="header" href="#接口文法约定">接口文法约定</a></h2>
<p>　　为描述对象语言规则和程序接口，本节约定<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">文法</a>形式。</p>
<p><strong>注释</strong> 这仅用于描述接口，不依赖 NPL 语言的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95">基本文法</a>。</p>
<p>　　元语言文法：</p>
<pre><code class="language-xbnf">&lt;left-constraint-bound&gt; ::= &lt;
&lt;right-constraint-bound&gt; ::= &gt;
&lt;constraint&gt; ::= &lt;left-constraint-bound&gt;&lt;constraint-name&gt;&lt;right-constraint-bound&gt;
&lt;prefix&gt; ::= .
&lt;suffix&gt; ::= ? | ...
&lt;trailing-constraint&gt; ::= &lt;constraint&gt; | &lt;constraint&gt;&lt;suffix&gt; | &lt;prefix&gt;&lt;trailing-constraint&gt;
&lt;sequence&gt; ::= &lt;constraint&gt;*&lt;trailing-constraint&gt;
&lt;left-sequence-bound&gt; ::= (
&lt;right-sequence-bound&gt; ::= )
&lt;form&gt; := &lt;sequence&gt; | &lt;left-sequence-bound&gt;&lt;sequence&gt;&lt;right-sequence-bound&gt;
</code></pre>
<p>　　规约操作中<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>的约束通过具有同类<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">名称</a>（即 <code>&lt;constraint-name&gt;</code> 元素）的前后以 <code>&lt;</code> 和 <code>&gt;</code> 作为边界的文法元素表示，即 <code>&lt;constraint&gt;</code> 文法元素。</p>
<p>　　为区分同类约束的不同项，约束的名称后（在 <code>&gt;</code> 之前）的可带有以 1 起始的正整数序数。除非另行指定，这些序数仅用于区分不同的同类约束项，无其它附加含义。</p>
<p>　　本节描述的项是被用于<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>（参见<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值算法</a>）的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>或它们的直接文法组合。前者应能涵盖<a href="Features/NPL.zh-CN.html#%E5%8E%9F%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F">原子表达式</a>、其<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>以及预期在对象语言中实现<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">对象语言求值算法</a>所需的 <a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">NPLA1 用户程序</a>构造。</p>
<p>　　库可参照本节的方式约定通过项的文法，以支持仅在特定库使用的操作数。</p>
<p>　　除非另行指定，本节的对应要求同时适用于本节中和这些库中引入的项。</p>
<h3 id="元文法基本约定"><a class="header" href="#元文法基本约定">元文法基本约定</a></h3>
<p>　　描述接口的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>的文法具有以下含义：</p>
<ul>
<li>表达操作的文法是 <code>&lt;sequence&gt;</code> ，表示匹配项的文法元素 <code>&lt;constraint&gt;</code> 或 <code>&lt;trailing-constraint&gt;</code> 的序列。</li>
<li>当 <code>&lt;sequence&gt;</code> 不存在具有非空 <code>&lt;prefix&gt;</code> 的 <code>&lt;trailing-constraint&gt;</code> 时，序列是<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>。</li>
<li><code>.</code> 仅在序列的最后一个文法元素中出现，表示后继的项和可选的文法元素后缀是有序对的最后一个元素。</li>
<li>文法元素后缀的含义如下：
<ul>
<li><code>...</code> ：Kleene 星号，重复之前修饰的 <code>&lt;constraint&gt;</code> 0 次或多次。</li>
<li><code>+</code> ：重复之前修饰的 <code>&lt;constraint&gt;</code> 1 次或多次。</li>
<li><code>?</code> ：重复之前修饰的 <code>&lt;constraint&gt;</code> 0 次或 1 次。</li>
</ul>
</li>
</ul>
<p><strong>注释</strong></p>
<p><code>...</code> 一般在结尾出现，表示元素构成列表。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，不使用 <code>.</code> 分隔有序对，不使用元素名称的复数表示列表。</p>
<h3 id="实体元素文法约定"><a class="header" href="#实体元素文法约定">实体元素文法约定</a></h3>
<p>　　指定具名的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数</a>的文法中，第一项以<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>的形式在所在的环境中提供，指定求值结果指称为<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>的函数的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">名称</a>；其后指定的文法中不同的元素对应合并子的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>或其被作为调用时的<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">形式参数树</a>的子项。</p>
<p>　　除非另行指定，在操作数可能是左值时，仅当对应以 <a href="Features/NPL.zh-CN.html#%E5%85%83%E6%96%87%E6%B3%95%E5%9F%BA%E6%9C%AC%E7%BA%A6%E5%AE%9A"><code>...</code> 或 <code>?</code> 形式</a>中最后的一项（若存在）时，支持匹配作为<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的有序对的非<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">前缀元素</a>不是空列表的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>的情形。</p>
<p>　　名义不同的约束可能蕴含相同的<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF%E6%A3%80%E6%9F%A5">检查</a>。</p>
<p>　　除非另行指定，应用子的操作数的约束也适用其<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">底层合并子</a>。</p>
<p><strong>注释</strong> 这意味着意味着按求值算法，被求值的应用子的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>对象不能是<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">非真列表</a>。特别地，<code>...</code> 形式的结尾序列一般被要求是真列表，除非是其底层操作子被求值且具有存在 <code>.</code> 前缀的最后一个文法元素。</p>
<p>　　文法形式上，使用本节约定指定<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">应用子的操作数</a>时，指定表达式形式的求值结果。</p>
<p><strong>注释</strong> 这和 [R<sup>n</sup>RK] 和 [Shu10] 中的斜体标识符的标记不同，但含义（表示语义变量(semantic variable) ）和效果实质相同。</p>
<p>　　操作数可能是左值或右值，按具体操作的需要，在必要时可被转换。</p>
<p>　　除可能具有的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>关系，本节约定的不同类型的操作数构成的集合之间不相交。一般规则参见<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB">类型分类</a>。</p>
<p>　　根据是否可作为操作子中指定不被求值的函数参数，本节的操作数及其<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">子项</a>分为<a href="Features/NPL.zh-CN.html#%E6%9C%AA%E6%B1%82%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">未求值的操作数</a>和<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">求值得到的操作数</a>。</p>
<p><strong>原理</strong></p>
<p>　　约束可用于区分特定的含义，但不直接指定和具体的<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF%E6%A3%80%E6%9F%A5">检查</a>对应，以便被实现优化，例如合并名义不同的检查。</p>
<p>　　文法形势的匹配应避免歧义。</p>
<p><strong>注释</strong></p>
<p>　　对非<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">前缀元素</a>的支持和<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">绑定匹配</a>规则对应。其中：</p>
<ul>
<li>仅<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">结尾序列</a>支持匹配以空列表以外的值的引用值作为非前缀元素的<a href="Features/NPL.zh-CN.html#%E6%9C%89%E5%BA%8F%E5%AF%B9">有序对</a>操作数左值的被引用对象中的非前缀元素<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>。</li>
<li>非结尾序列的元素因计算前缀元素数而被要求在同一个对象的前缀元素中。</li>
<li>作为操作数被绑定时，若元素是引用值：
<ul>
<li>它不被<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%B6%88%E9%99%A4">消除</a>。</li>
<li>它的被引用对象中的元素（若存在）不被视为初始化<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>中的其它<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>的子对象。</li>
</ul>
</li>
<li>若有序对操作数的非前缀元素是空列表的引用值，则有序对操作数构成列表。
<ul>
<li>有序对操作数的非前缀元素不会匹配<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">形式参数树</a>中的<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>而被绑定到变量。</li>
</ul>
</li>
<li>关于操作数匹配的规则避免匹配操作数序列时对文法元素的对应关系可能具有歧义。</li>
</ul>
<h4 id="未求值的操作数"><a class="header" href="#未求值的操作数">未求值的操作数</a></h4>
<p>　　未求值的操作数的文法约定如下：</p>
<ul>
<li><code>&lt;symbol&gt;</code> ：<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号</a>。
<ul>
<li><strong>注释</strong> 内部使用和 <a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;string&gt;</code></a>一一对应的表示，不提供符号和外部表示的其它映射关系。</li>
</ul>
</li>
<li><code>&lt;symbols&gt;</code> ：元素为 <code>&lt;symbol&gt;</code> 的列表，形式为 <code>(&lt;symbol&gt;...)</code> 。</li>
<li><code>&lt;eformal&gt;</code> ：表示可选提供的环境名称的 <code>&lt;symbol&gt;</code> 或 <a href="Features/NPL.zh-CN.html#npla1-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F"><code>#ignore</code></a> ，或这些值的引用值。
<ul>
<li><strong>注释</strong> 通常为动态环境。</li>
</ul>
</li>
<li><code>&lt;expression&gt;</code> ：待求值的表达式。
<ul>
<li><strong>注释</strong> 这是 <a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">NPL 语法</a>的直接实现。作为右值，它是词法元素的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>，或这些元素的<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>。</li>
</ul>
</li>
<li><code>&lt;expressions&gt;</code> ：形式为 <code>&lt;expression&gt;...</code> 的待求值形式。
<ul>
<li>求值时，<code>&lt;expressions&gt;</code> 被作为单一表达式（即视为求值 <code>(&lt;expression&gt;...)</code> ）。</li>
</ul>
</li>
<li><code>&lt;binding&gt;</code> ：绑定列表的元素，形式为 <code>&lt;symbol&gt; &lt;body&gt;</code> ，用于指定被求值的表达式和绑定参数的符号值。
<ul>
<li>和 Kernel 不同，<code>&lt;symbol&gt;</code> 后不要求是整个 <code>&lt;expression&gt;</code> 。</li>
</ul>
</li>
<li><code>&lt;binding&gt;</code> 绑定列表，形式为 <code>&lt;symbol&gt; &lt;expressions&gt;</code> ，用于指定被求值的表达式和绑定参数的符号值。</li>
<li><code>&lt;bindings&gt;</code> ：绑定列表，即元素为 <code>&lt;binding&gt;</code> 的列表，形式为 <code>(&lt;binding&gt;...)</code> 。</li>
<li><code>&lt;body&gt;</code>： 出现在元素的结尾 <code>&lt;expressions&gt;</code> 形式。
<ul>
<li><strong>注释</strong> 一般用于<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数体</a>等替换求值的目标。</li>
</ul>
</li>
<li><code>&lt;expression-sequence&gt;</code> ：同 <code>&lt;expression&gt;...</code> 但蕴含顺序求值其中的子项。
<ul>
<li>求值 <code>&lt;expression-sequence&gt;</code> 的结果是求值其最后一个子表达式（若存在）的结果，或当不存在子表达式时为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">未指定值</a>。</li>
</ul>
</li>
<li><code>&lt;consequent&gt;</code> ：同 <code>&lt;expression&gt;</code> ，仅用于 <a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;test&gt;</code></a> 求值结果经<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">左值到右值转换</a>不为 <code>#f</code> 时。</li>
<li><code>&lt;alternative&gt;</code> ：同 <code>&lt;expression&gt;</code> ，仅用于 <code>&lt;test&gt;</code> 求值结果经左值到右值转换为 <code>#f</code> 时。</li>
<li><code>&lt;ptree&gt;</code> ：形式参数树，是包含符号值或 <code>#ignore</code> 及其它形式参数树构成的 <a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">DAG</a> 的表达式。
<ul>
<li>语法要求由上下文无关文法描述：<code>&lt;ptree&gt; ::= &lt;symbol&gt; | #ignore | () | (&lt;ptree&gt;...)</code> 。</li>
</ul>
</li>
<li><code>&lt;definiend&gt;</code> ：被绑定项的目标的 <code>&lt;ptree&gt;</code> 。
<ul>
<li>引入绑定时，蕴含按<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">绑定规则</a>附加 <code>&lt;ptree&gt;</code> 以外的<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">绑定匹配</a>等语义检查。</li>
</ul>
</li>
<li><code>&lt;formals&gt;</code> ：作为形式参数的 <code>&lt;ptree&gt;</code> 。同 <code>&lt;definiend&gt;</code> 但允许<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">派生实现</a>定义更多检查。</li>
<li><code>&lt;clauses&gt;</code> ：元素为条件分支的列表，形式为 <code>(&lt;test&gt; &lt;body&gt;)...</code> 。</li>
<li><code>&lt;variable&gt;</code> ：<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">变量</a>。用于表示被<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">声明</a>的名称。
<ul>
<li>同 <code>&lt;symbol&gt;</code> ，其中的处理与作为非列表的 <code>&lt;formals&gt;</code> 相同。</li>
</ul>
</li>
</ul>
<p>　　关于 <code>eval</code> ，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　以 <code>&lt;expressions&gt;</code> 代替 <code>&lt;expression&gt;</code> 可避免语法中要求过多的括号及 <code>eval</code> 等求值形式中显式构造列表的需要。</p>
<p>　　因为 <code>&lt;body&gt;</code> 存在元素的结尾，明确元素中的其它词法元素后即可自然确定边界。</p>
<p>　　<code>&lt;body&gt;</code> 可以是多个表达式的词法组合，允许具体使用时不需要附加括号即可实现整体求值。</p>
<p>　　特别地，作为其它 <code>&lt;body&gt;</code> 嵌套的 <code>&lt;body&gt;</code> 实例在这种情况下，可以更有效地减少嵌套一层以上的括号。</p>
<p>　　<code>&lt;body&gt;</code> 整体求值的一个必要条件：构成 <code>&lt;body&gt;</code> 的表达式不被以其它方式分别求值，如蕴含<a href="Features/NPL.zh-CN.html#%E6%96%87%E6%B3%95%E5%85%83%E7%B4%A0%E8%A1%A5%E5%85%85%E7%BA%A6%E5%AE%9A">顺序求值</a>。</p>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RK] 不同，<code>&lt;body&gt;</code> 可以是多个表达式的词法组合。</p>
<p>　　尽管 <code>&lt;body&gt;</code> 不保证可直接构成一个表达式（而是构成某个表达式的所在元素中的多个子表达式），一般仍被作为一个整体求值。</p>
<p>　　被整体求值时，这些表达式被视为某个假想的表达式，这个表达式包含被整体求值的表达式作为子表达式。</p>
<p>　　若 <code>&lt;body&gt;</code> 存在超过一个子表达式，按求值算法的 <a href="Features/NPL.zh-CN.html#npla1-%E8%A7%84%E8%8C%83%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">NPLA1 规范求值算法步骤</a>，表达式分别作为合并子和之后的参数。</p>
<p>　　若 <code>&lt;body&gt;</code> 不存在子表达式，则结果是 <code>()</code> 而不是 <code>#inert</code> 。这和 [R<sup>n</sup>RK] 的经重定义而隐含 <code>$sequence</code> 的 <code>$vau</code> 以及 <code>$let</code> 等合并子不同，但和 <code>eval</code> 仍然相同。</p>
<h4 id="求值得到的操作数"><a class="header" href="#求值得到的操作数">求值得到的操作数</a></h4>
<p>　　求值得到的操作数的文法约定如下：</p>
<ul>
<li><code>&lt;object&gt;</code> ：一般对象，包括引用对象的<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8">引用值</a>。</li>
<li><code>&lt;reference&gt;</code> ：对象引用值。</li>
<li><code>&lt;pair&gt;</code> ：<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">有序对</a>。
<ul>
<li><strong>注释</strong> 可构成<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表或非真列表</a>。</li>
</ul>
</li>
<li><code>&lt;list&gt;</code> ：<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">列表</a>：空列表或第二个元素为空列表的有序对。</li>
<li><code>&lt;lists&gt;</code> ：元素都是列表的列表。</li>
<li><code>&lt;boolean&gt;</code> ：<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">布尔值</a>，值为 <code>#t</code> 或 <code>#f</code> 的集合。
<ul>
<li>是<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">类型映射</a>指定的用于条件判断的单一值的类型。</li>
<li>推论：<code>&lt;boolean&gt;</code> 对应的宿主类型是 <code>bool</code> 。</li>
</ul>
</li>
<li><code>&lt;test&gt;</code> ：类似 <code>&lt;object&gt;</code> ，通常预期为 <code>&lt;boolean&gt;</code> ，作为条件。
<ul>
<li>当<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>非 <code>#f</code> 时条件成立。</li>
<li><strong>原理</strong> 和 Scheme 类似但和 Kernel 不同，非 <code>#t</code> 的值在决定分支时视同 <code>#f</code> ，以允许在 <code>&lt;boolean&gt;</code> 外自然扩展的逻辑代数操作。</li>
<li><strong>原理</strong> 和 Common Lisp 不同，不使用空列表（或符号值 <code>nil</code> ）代替 <code>#f</code> ，以避免需要特设的规则以特定的其它类型的值（如 Common Lisp 的符号值 <code>t</code> ）表示逻辑真（这在逻辑非操作中不可避免）。</li>
</ul>
</li>
<li><code>&lt;combiner&gt;</code> ：<a href="Features/NPL.zh-CN.html#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>。</li>
<li><code>&lt;applicative&gt;</code> ：<a href="Features/NPL.zh-CN.html#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">应用子</a>。</li>
<li><code>&lt;operative&gt;</code> ：<a href="Features/NPL.zh-CN.html#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">操作子</a>。</li>
<li><code>&lt;predicate&gt;</code> ：<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">谓词</a>，是应用操作数的求值结果的值为 <code>&lt;test&gt;</code> 的 <code>&lt;applicative&gt;</code> 。
<ul>
<li><strong>注释</strong> 通常实现结果是 <code>&lt;boolean&gt;</code> 的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>。</li>
</ul>
</li>
<li><code>&lt;environment&gt;</code> ：<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">一等环境</a>。</li>
<li><code>&lt;parent&gt;</code> ：指定环境的<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">父环境</a>的值，包括：
<ul>
<li>环境引用值：<code>&lt;environment&gt;</code> 或以 <code>&lt;environment&gt;</code> 值作为被引用对象的 <code>&lt;reference&gt;</code> 。</li>
<li>元素为环境引用值的 <code>&lt;list&gt;</code> 。</li>
<li><a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>是元素为环境引用值的 <code>&lt;list&gt;</code> 的 <code>&lt;reference&gt;</code> 。</li>
</ul>
</li>
<li><code>&lt;string&gt;</code> ：字符串。
<ul>
<li>字符串是包括<a href="Features/NPL.zh-CN.html#npla-%E5%90%8D%E7%A7%B0%E5%92%8C%E5%AD%97%E9%9D%A2%E9%87%8F%E6%B1%82%E5%80%BC">数据字面量</a>作为表示的值的类型。</li>
<li>字符串的内部表示在具体实现中保持一致。除非另行指定，使用 <a href="https://www.iso.org/standard/76835.html">ISO/IEC 10646</a> 定义的 UCS 的 UTF-8 编码，其值不包含空字符（编码数值为 0 的 UCS 代码点）。</li>
<li>关于当前实现，另见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</li>
<li><strong>注释</strong> 为<a href="Features/NPL.zh-CN.html#npla1-%E4%BA%92%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">互操作</a>的兼容性，一般建议实现使用兼容 [ISO C++] 中定义的 <a href="https://eel.is/c++draft/multibyte.strings#2">NTMBS(null-terminated multibyte string)</a> 的方式表达。</li>
</ul>
</li>
<li>此外，支持的数值操作数参见 <a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">NPLA 数值类型</a>。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　<code>&lt;object&gt;</code> 等求值得到的操作数不保证是语法意义上连续的词法组合，不能由多个表达式构成，因此即便出现在元素末尾，也不能如 <code>&lt;body&gt;</code> 一样减少括号。</p>
<p>　　<code>&lt;object&gt;</code> 作为<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%85%A8%E9%9B%86">类型全集</a>，其元素可被断言在<a href="Features/NPL.zh-CN.html#%E5%BC%80%E6%94%BE%E6%80%A7">论域</a>内，即任何其它类型都是 <code>&lt;object&gt;</code> 的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>。<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>可对此进行验证。</p>
<p>　　和 [R<sup>n</sup>RK] 的理由不同，允许布尔代数以外扩展的比较判断在此不认为是易错的，而是有意的设计(by design) 。这避免预设地假定类型的名义语用作用（“角色(role) ” ），也避免限制语言和派生语言的类型全集的设计。</p>
<p><strong>注释</strong></p>
<p>　　空列表构成的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">单元类型</a>是真列表的子类型，而不是有序对的子类型。</p>
<p>　　非空真列表是有序对的子类型。</p>
<h4 id="文法元素补充约定"><a class="header" href="#文法元素补充约定">文法元素补充约定</a></h4>
<ul>
<li>除非另行指定，以 <code>&lt;symbols&gt;</code> 指定的值被作为 <code>&lt;definiend&gt;</code> 或 <code>&lt;formals&gt;</code> 使用时不引起错误。
<ul>
<li><strong>注释</strong> <code>&lt;symbols&gt;</code> 在被其它上下文使用时仍可能引起错误。</li>
</ul>
</li>
<li><code>&lt;symbols&gt;</code> 形式的符号列表在绑定<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">变量名</a>时支持引用标记字符 <a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6"><code>&amp;</code> 和 <code>%</code></a>。符号作为被绑定的初值符时，移除符号中发现的这些引用标记字符。</li>
<li><code>&lt;definiend&gt;</code> 和 <code>&lt;formals&gt;</code> 不要求重复符号值检查。另见<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">绑定操作</a>。</li>
<li>使用 <code>&lt;formals&gt;</code> 的情形包括合并子基本操作和可通过这些操作派生的操作在对应位置的操作数。
<ul>
<li><strong>原理</strong> [R<sup>n</sup>RK] 和 [Shu10] 都没有显式区分 <code>&lt;definiend&gt;</code> 和 <code>&lt;formals&gt;</code> ，两者在上下文中实质可互换，差别仅在 [R<sup>n</sup>RS] 中的 define 形式中定义的位置可具有和 <code>&lt;formals&gt;</code> 不兼容的扩展形式。</li>
<li><strong>注释</strong> 这实质等价使用 [Shu09] 中的记法，即 <code>&lt;formals&gt;</code> 用于除和 [Shu09] 的 <code>$define!</code> 类似外的所有操作（包括 <code>$set!</code> 和 <code>$let</code> 等，而不论是否对应 <code>&lt;body&gt;</code> ）。这些上下文中总是隐含了上述的可派生实现的要求。</li>
</ul>
</li>
<li><code>&lt;body&gt;</code> 不蕴含顺序求值子项。
<ul>
<li><strong>原理</strong> 这也允许 <code>&lt;body&gt;</code> 中的表达式被<a href="Features/NPL.zh-CN.html#%E6%9C%AA%E6%B1%82%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">整体求值</a>。</li>
</ul>
</li>
</ul>
<p>　　关于合并子基本操作，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　和传统 Lisp 方言（包括 [R<sup>n</sup>RS] 和 [R<sup>n</sup>RK] ）的函数体不同，<code>&lt;body&gt;</code> 的各个表达式之间不蕴含顺序求值。</p>
<p>　　因此，和 [R<sup>n</sup>RK] 不同，<code>$vau</code> 不需要在基本操作之后再次派生。这使操作的功能更加正交。</p>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RK] 不同，<code>&lt;symbols&gt;</code> 、<code>&lt;definiend&gt;</code> 和 <code>&lt;formals&gt;</code> 具有一些附加的约定支持；<code>&lt;body&gt;</code> 不蕴含顺序求值子项；NPLA1 的符号可通过<a href="Features/NPL.zh-CN.html#npla-%E5%90%8D%E7%A7%B0%E5%92%8C%E5%AD%97%E9%9D%A2%E9%87%8F%E6%B1%82%E5%80%BC">代码字面量求值</a>得到。</p>
<h2 id="npla1-对象语言语法"><a class="header" href="#npla1-对象语言语法">NPLA1 对象语言语法</a></h2>
<p>　　基于 NPLA 基本语法约定参见 <a href="Features/NPL.zh-CN.html#npla-%E6%95%B4%E4%BD%93%E7%BA%A6%E5%AE%9A">NPLA 整体约定</a>。</p>
<p>　　NPLA1 表达式符合 <a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">NPL 表达式语法</a>。</p>
<p><strong>注释</strong></p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">NPL-GA</a>包含的<a href="Features/NPL.zh-CN.html#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90">转义规则</a>中包含 <code>&lt;char-escape-seq&gt;</code> 的 <code>&lt;char-seq&gt;</code> 要求类似 [R<sup>6</sup>RS] 在字符串中的元素；其中仅有 \ 和 " 被 [R<sup>5</sup>RS] 直接支持，而 [R<sup>7</sup>RS] 不支持 \v 。</p>
<p>　　后者支持的其它转义字符序列词法可被派生实现以 <code>&lt;$literal-char&gt;</code> 的形式另行指定（其中 [R<sup>7</sup>RS] 可涵盖对应 <code>&lt;char-escape-seq&gt;</code> 的功能）。</p>
<h3 id="npla1-字面量"><a class="header" href="#npla1-字面量">NPLA1 字面量</a></h3>
<p>　　基于 <a href="Features/NPL.zh-CN.html#npla-%E8%AF%8D%E6%B3%95%E5%92%8C%E8%AF%AD%E6%B3%95">NPLA 词法规则</a>，本节指定<a href="Features/NPL.zh-CN.html#%E5%AD%97%E9%9D%A2%E9%87%8F">字面量</a>的词素集合。</p>
<p>　　派生实现可指定不同的字面量，但不应和已指定词法构造的记号冲突，包括本节指定的字面量。</p>
<p>　　NPLA1 字面量都是<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>，但总是允许<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">实质化转换</a>为消亡值并引入允许<a href="Features/NPL.zh-CN.html#npla1-%E4%BA%92%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">互操作</a>的<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>。</p>
<p><strong>注释</strong> 这和宿主语言的字符串字面量是左值不同。当前 NPLA1 对象语言不提供能引起互操作差异的接口（字符串字面量不被修改），以后可能改变。</p>
<h4 id="字符串字面量"><a class="header" href="#字符串字面量">字符串字面量</a></h4>
<p>　　字符串字面量的类型为 <a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;string&gt;</code></a>。</p>
<h4 id="npla1-数值字面量"><a class="header" href="#npla1-数值字面量">NPLA1 数值字面量</a></h4>
<p>　　基于 <a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">NPLA 数值类型</a>和<a href="Features/NPL.zh-CN.html#npla-%E5%90%8D%E7%A7%B0%E5%92%8C%E5%AD%97%E9%9D%A2%E9%87%8F%E6%B1%82%E5%80%BC">数值字面量</a>，NPLA1 数值字面量的类型为 <code>&lt;number&gt;</code> 。</p>
<p>　　除非另行指定，数值的具体宿主类型未指定。</p>
<p><strong>注释</strong> 部分数值可指定具体的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>。</p>
<p>　　NPLA1 支持 <code>&lt;integer&gt;</code> 类型的精确数数值字面量和 <a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">flonum</a> 不精确数数值字面量。</p>
<p>　　支持的字面量包括词素符合 NPLAMath <a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E8%A1%A8%E7%A4%BA">数值表示</a>的字面量。</p>
<p>　　派生实现可定义其它数值字面量。</p>
<p><strong>注释</strong></p>
<p>　　以上字面量包含十进制数值的字面量。其它字面量是 <a href="Features/NPL.zh-CN.html#npla-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F">NPLA 扩展字面量</a>。</p>
<p>　　无限大值和 NaN 值同 <a href="https://docs.racket-lang.org/reference/numbers.html">[Racket] 的字面量词法</a>，除这些类型总是启用，且使用明确属于 flonum 且对应明确宿主类型的 long double 代替不被作为一般 flonum 的 extflonum 。</p>
<p>　　<a href="https://srfi.schemers.org/srfi-73/srfi-73.html">[SRFI-73]（已撤消）</a>提出扩展 [R<sup>5</sup>RS] 的带有 <code>#e</code> 或 <code>#i</code> 前缀的精确数和不精确数无限大值字面量，其中<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">前缀及精确数的支持</a>和 [R<sup>n</sup>RK] 类似。NPLA1 不支持无限大值精确数。</p>
<p>　　关于无限大值的在 [R<sup>n</sup>RS] 的一些实现情形，另见<a href="https://people.csail.mit.edu/jaffer/III/RAWI">这里</a>。</p>
<h4 id="npla1-扩展字面量"><a class="header" href="#npla1-扩展字面量">NPLA1 扩展字面量</a></h4>
<p>　　NPLA1 支持 <a href="Features/NPL.zh-CN.html#npla-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F">NPLA 扩展字面量</a>作为部分数值字面量。</p>
<p>　　NPLA1 还支持以下以 <code>#</code> 起始的扩展字面量：</p>
<ul>
<li><code>#t</code> ：<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">布尔值</a>逻辑真，类型为 <code>&lt;boolean&gt;</code> 。</li>
<li><code>#f</code> ：布尔值逻辑假，<code>&lt;boolean&gt;</code> 。</li>
<li><code>#true</code> ：同 <code>#t</code> 。</li>
<li><code>#false</code> ：同 <code>#f</code> 。</li>
<li><code>#inert</code> ：类似 Kernel 的 <code>#inert</code> 字面量，</li>
<li><code>#ignore</code> ：类似 Kernel 的 <code>#ignore</code> 字面量。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　<code>#inert</code> 和 <code>#ignore</code> 类似 [R<sup>n</sup>RK] 。</p>
<p>　　从表达上，<code>#inert</code> 和 <code>#ignore</code> 仍都可以被视为特定<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">单元类型</a>的值：等价的类型判断谓词可以直接使用值的相等关系确定。</p>
<p>　　和 [R<sup>n</sup>RS] 及 klisp 不同，不需要因兼容性支持扩展字面量中不同的大小写变体，特别是 [R<sup>6</sup>RS] 的 <code>#T</code> 和 <code>#F</code> 。</p>
<p>　　和 [R<sup>n</sup>RS] 类似而和 [R<sup>n</sup>RK] 不同，NPLA1 表达<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">结果</a>结果通常不依赖 <code>#inert</code> ，而直接使用<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">未指定值</a>。这避免用户必须引入 <code>#inert</code> 等具体的值实现相同隐式效果而违反<a href="Features/NPL.zh-CN.html#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99">关注点分离原则</a>。</p>
<p>　　尽管在接口意义上通常是不必要的，若有需要（如派生结果等效 <code>#inert</code> 的操作），<code>#inert</code> 的值仍可被显式使用。</p>
<p><strong>注释</strong></p>
<p>　　[R<sup>5</sup>RS] 和 [R<sup>n</sup>RK] 指定 <code>#t</code> 和 <code>#f</code> 。[R<sup>7</sup>RS] 指定同义的 <code>#true</code> 和 <code>#false</code>（参见 <a href="https://small.r7rs.org/ticket/219/">R<sup>7</sup>RS ticket 219</a> ）。</p>
<p>　　后者被认为可提供若干可读性，但<a href="https://small.r7rs.org/ticket/526/">具有冗余</a>。本文档中，以下不使用 <code>#true</code> 和 <code>#false</code> 替代 <code>#t</code> 和 <code>#f</code> 。</p>
<p>　　派生实现可扩展支持，提供非 <code>&lt;boolean&gt;</code> 类型的布尔值，使用与这些字面量不同的对应表示。</p>
<h3 id="npla1-函数合并"><a class="header" href="#npla1-函数合并">NPLA1 函数合并</a></h3>
<p>　　以下使用 <a href="Features/NPL.zh-CN.html#%E5%85%83%E6%96%87%E6%B3%95%E5%9F%BA%E6%9C%AC%E7%BA%A6%E5%AE%9A"><code>...</code></a>作为函数的操作数时，可支持没有操作数的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>。此情形下应用表达式仍需要前缀 <code>()</code> ，但不在以下规约文法中显式地表示。</p>
<p><strong>注释</strong></p>
<p>　　和 Scheme 及 Kernel 不同，求值算法决定求值为<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并表达式</a>的语法表达不需要括号，且具有不同的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6%E6%B1%82%E5%80%BC">函数合并形式</a>。</p>
<h2 id="对象语言内存安全保证"><a class="header" href="#对象语言内存安全保证">对象语言内存安全保证</a></h2>
<p>　　对象语言可能提供关于<a href="Features/NPL.zh-CN.html#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>的检查。</p>
<p>　　除非另行指定，假定实现进行<a href="Features/NPL.zh-CN.html#npla1-%E4%BA%92%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">互操作</a>无法保证内存安全。</p>
<h3 id="对象语言基本内存安全保证"><a class="header" href="#对象语言基本内存安全保证">对象语言基本内存安全保证</a></h3>
<p>　　对象语言提供关于内存安全的基本保证：不存在违反内存安全相关的要求以外的未定义行为（包括<a href="Features/NPL.zh-CN.html#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>等）、不存在不保证内存安全的互操作且不存在<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E5%AE%89%E5%85%A8%E9%97%B4%E6%8E%A5%E5%80%BC%E8%AE%BF%E9%97%AE">不安全间接值访问</a>时，对象语言的程序执行保证内存安全。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">非内存安全操作</a>在对象语言中以不安全间接值访问的一部分情形体现。</p>
<h3 id="不安全操作"><a class="header" href="#不安全操作">不安全操作</a></h3>
<p>　　<em>不安全(unsafe)</em> 操作是可能在程序的执行中引入<a href="Features/NPL.zh-CN.html#npla1-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">未定义行为</a>的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作</a>。</p>
<p>　　这里的未定义行为包含在操作中直接引入的未定义行为，以及因为操作被执行而使程序在之后无法确保排除的未定义行为。</p>
<p>　　不安全操作是实现可选提供的。</p>
<p>　　当前对象语言不支持<a href="Features/NPL.zh-CN.html#npla-%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE">并发访问</a>对象。数据竞争仅可由和宿主语言的互操作引入。</p>
<h3 id="不安全间接值访问"><a class="header" href="#不安全间接值访问">不安全间接值访问</a></h3>
<p>　　对象语言的不安全<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值访问</a>包括：</p>
<ul>
<li>通过<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">无效的间接值</a>的间接访问。</li>
<li>通过<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E5%AE%89%E5%85%A8%E5%BC%95%E7%94%A8%E5%80%BC">不安全引用值</a>的间接访问。</li>
<li>通过可能由实现定义的其它不安全间接值访问。</li>
</ul>
<h4 id="无效的环境引用"><a class="header" href="#无效的环境引用">无效的环境引用</a></h4>
<p>　　环境对象被销毁导致<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E9%97%B4%E6%8E%A5%E5%80%BC">作为间接值的环境引用</a>被<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">无效化</a>。</p>
<p><strong>注释</strong></p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E7%94%9F%E5%AD%98%E6%9C%9F">环境生存期</a>。</p>
<h4 id="无效的引用值"><a class="header" href="#无效的引用值">无效的引用值</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">作为间接值的引用值</a>是间接值的实例，因此无效的间接值包含无效的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>，通过无效间接值访问包括无效的引用值的访问。</p>
<p>　　对象语言不提供<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7">悬空引用</a>以外构造无效引用值的操作。</p>
<p>　　对象语言中可引入悬空引用的情形包括：</p>
<ul>
<li>调用可能返回引用值的合并子，且没有另行保存函数体求值所在的<a href="Features/NPL.zh-CN.html#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>，<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>对应的对象不在生存期内：
<ul>
<li>绑定到形式参数的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">右值</a>保存在过程调用的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">局部环境</a>中，退出<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数体</a>的求值，局部环境被释放后，返回的其引用是悬空引用。</li>
<li>实现等效上述情形的派生操作的使用，如：
<ul>
<li><a href="Features/NPL.zh-CN.html#%E6%9C%AA%E6%B1%82%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">绑定列表</a><a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">传递引用</a>且<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">传递的引用值被求值</a>使用。</li>
<li>间接保留引用值可能提供变量绑定，这些绑定的目标对象可能依赖环境（如合并子的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">静态环境</a>），被销毁时访问被依赖的环境（如合并子调用求值函数体）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　关于间接保留引用值和互操作可能引入悬空引用的情形，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>注释</strong></p>
<p>　　另见<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8">对象语言的引用值</a>。</p>
<h4 id="其它无效的间接值"><a class="header" href="#其它无效的间接值">其它无效的间接值</a></h4>
<p>　　使用其它不保证内存安全的操作可引入<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">不具有内存安全保证的间接值</a>访问实体。</p>
<p>　　这些间接值可能因为和<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7">悬空引用</a>相同的情形<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">无效化</a>。</p>
<h3 id="保留间接值"><a class="header" href="#保留间接值">保留间接值</a></h3>
<p>　　对象的（直接或间接）<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>是间接值时，对象包含间接值。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>对象为间接值或使之包含间接值时，对象保留间接值。</p>
<p>　　被保留的间接值是对应的通过修改得到或包含的间接值。</p>
<p>　　本节中的概念对应适用于具体的间接值，如被保留的引用值和函数<a href="Features/NPL.zh-CN.html#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E7%9B%AE%E6%A0%87">在结果中保留引用值</a>。</p>
<h4 id="被保留的引用值的目标"><a class="header" href="#被保留的引用值的目标">被保留的引用值的目标</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>返回（在对象语言中允许出现的，下同）间接值或包含间接值的对象时，在<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>中保留间接值。</p>
<p>　　函数调用修改环境使<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境对象</a>保留间接值（绑定间接值或包含间接值作为子对象的对象作为<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>）时，在环境中保留间接值。</p>
<p>　　函数调用修改<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>或其子对象，使之保留间接值时，在对象中保留间接值。</p>
<p>　　在函数值中保留间接值、在环境中保留间接值、在对象中保留间接值的函数保留间接值。</p>
<p>　　被保留的间接值被函数调用的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>蕴含时，函数在结果中保留间接值。</p>
<p><strong>注释</strong></p>
<p>　　函数调用的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">求值结果</a>排除<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>即函数值。</p>
<p>　　在结果中保留间接值包含以下情形：</p>
<ul>
<li>在函数值中保留间接值。</li>
<li>在环境中保留间接值，环境是函数值或其子对象。</li>
<li>在对象中保留间接值，对象是函数值的子对象。</li>
</ul>
<h4 id="被保留的引用值的来源"><a class="header" href="#被保留的引用值的来源">被保留的引用值的来源</a></h4>
<p>　　函数返回包含间接值的对象由参数的值决定时，保留参数中的间接值。</p>
<p>　　按被保留的间接值的来源，这分为以下两个子类：</p>
<ul>
<li>直接保留间接值：接受间接值参数。</li>
<li>间接保留间接值：接受的参数或参数在特定环境中被求值得到的结果决定是否直接保留间接值。
<ul>
<li><strong>注释</strong> 如合并子或构成<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">形式参数树</a>的可能带有<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">引用标记字符</a>的<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>。</li>
</ul>
</li>
</ul>
<h4 id="保留间接值的操作"><a class="header" href="#保留间接值的操作">保留间接值的操作</a></h4>
<p>　　操作可保留间接值：</p>
<ul>
<li>使用函数调用实现的操作可通过<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>保留间接值。</li>
<li>其它实现方式可等效地保留间接值。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　在结果中保留间接值的操作不区分被保留的间接值的来源和目标。但多数情形下，这通过函数值保留参数中的间接值蕴含。</p>
<h4 id="保留间接值和内存安全"><a class="header" href="#保留间接值和内存安全">保留间接值和内存安全</a></h4>
<p>　　保留间接值操作的内存安全的一个必要条件是所有被保留的间接值在之后的使用中都满足内存安全。</p>
<p>　　保留间接值在操作后可能因<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值无效</a>（如<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7">悬空引用</a>），无法继续保证内存安全。</p>
<p>　　在环境中保留间接值时，应保证环境具有足够的生存期，以避免间接值依赖无效的环境引用导致访问环境中对象的未定义行为。</p>
<h3 id="对象语言接口的安全保证机制"><a class="header" href="#对象语言接口的安全保证机制">对象语言接口的安全保证机制</a></h3>
<p>　　对象语言接口的安全保证机制提供不同接口的分类，通过允许区分是否具有内存安全保证的接口帮助程序利用<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">对象语言基本内存安全保证</a>。</p>
<p>　　通过避免或限制使用<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">不安全操作</a>，实现上述安全保证。</p>
<p>　　因为允许引入 <a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">NPLA 未定义行为</a>，无法提供安全证明的<a href="Features/NPL.zh-CN.html#npla1-%E4%BA%92%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">互操作</a>应视为不安全操作。</p>
<p>　　基于<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值算法</a>的安全保证的非形式的证明框架概述如下：</p>
<ul>
<li>任意步骤中，访问间接值指定的目标对象是安全的，仅当间接值是安全的。</li>
<li><a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>的求值是安全的，仅当引用的环境是安全的。</li>
<li>合并子调用的求值是安全的，仅当合并子、操作数及调用的操作是安全的。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　满足安全保证的推理如下：</p>
<ul>
<li>因为 NPLA 实现的非互操作引入的、非求值规约的<a href="Features/NPL.zh-CN.html#%E7%AE%A1%E7%90%86%E8%A7%84%E7%BA%A6">管理规约</a>不存在未定义行为，以上求值算法中的步骤中通过排除不安全的实体能保证规约中不存在未定义行为。</li>
<li>因为<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E8%A7%84%E5%88%99%E5%92%8C%E6%B1%82%E5%80%BC">规约决定程序执行的语义</a>，在求值中排除不安全的实体可以保证不存在未定义行为，而满足安全保证。</li>
</ul>
<h4 id="安全性附加证明"><a class="header" href="#安全性附加证明">安全性附加证明</a></h4>
<p>　　一些不安全操作是否蕴含未定义行为可能依赖具体调用使用的操作数。</p>
<p>　　若能证明特定的前提保证任意的调用实例中的操作数满足附加的安全假设，则这些不安全操作的调用仍可保证安全。</p>
<p>　　排除不确保安全性假设的互操作时，NPLA1 提供附加调用安全：若不存在<a href="Features/NPL.zh-CN.html#%E9%9A%90%E8%97%8F%E7%8E%AF%E5%A2%83">隐藏环境</a>中绑定的可修改对象的引用，则仅因可能违反<a href="Features/NPL.zh-CN.html#%E8%A2%AB%E7%BB%91%E5%AE%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%80%BC%E5%92%8C%E5%8F%AF%E8%A7%82%E5%AF%9F%E8%A1%8C%E4%B8%BA">值稳定性</a>的不安全操作的调用是安全的。</p>
<p>　　派生实现可对特定调用附加使用限制以便提供证明，或定义其它的调用并提供更强的保证。</p>
<h2 id="诊断"><a class="header" href="#诊断">诊断</a></h2>
<p>　　NPLA1 的特定<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值步骤</a>可引起<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">诊断</a>。</p>
<p>　　引起诊断时<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>被终止，或在失败可被恢复时以其它派生实现定义的方式继续求值。</p>
<p>　　其它引起诊断的条件可被派生实现补充指定。</p>
<p><strong>注释</strong> 注意<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未定义行为</a>取消对诊断的要求。</p>
<p>　　本节以外的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">诊断消息</a>的其它形式未指定。</p>
<p><strong>注释</strong></p>
<p>　　引起诊断的求值包括：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">抽象求值</a>的失败。
<ul>
<li>例如，REPL(read-eval-print loop) 中进行的翻译。</li>
</ul>
</li>
<li>在<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">环境</a>中访问指定名称的对象失败时。</li>
<li>特定的函数应用。</li>
</ul>
<p>　　其它求值条件详见具体操作的规定。</p>
<h3 id="npla1-错误"><a class="header" href="#npla1-错误">NPLA1 错误</a></h3>
<p>　　NPLA1 中的<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">错误</a>是按接口的约定不符合预期的<a href="Features/NPL.zh-CN.html#%E5%BC%82%E5%B8%B8">正常条件</a>（如<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF%E6%A3%80%E6%9F%A5">不被正常处理的操作数类型</a>）引起的诊断。</p>
<p>　　求值特定的表达式可<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起错误</a>，包括：</p>
<ul>
<li>违反<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值算法</a>步骤中的要求而直接引起的<em>语法错误(syntax error)</em> 。</li>
<li>其它情形引起的<em>语义错误(semantic error)</em> 。</li>
</ul>
<p>　　以<a href="Features/NPL.zh-CN.html#%E6%8E%A5%E5%8F%A3%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">接口文法约定</a>的形式约定的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作</a>中，除<a href="Features/NPL.zh-CN.html#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>外，<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96">绑定初始化</a>之前的<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">参数绑定</a>失败是语法错误。</p>
<p>　　语法错误包含两类：</p>
<ul>
<li>总是依赖程序运行时确定的值不满足特定操作的要求引起动态语法错误。</li>
<li>其它语法错误违反<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">语法正确性</a>要求，是静态语法错误。</li>
</ul>
<p>　　类似地，语义错误包含两类：</p>
<ul>
<li>总是依赖程序运行时确定的值不满足特定操作的要求引起动态语义错误。</li>
<li>其它语义错误违反<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">语义正确性</a>要求，是静态语义错误。</li>
</ul>
<p>　　静态语法错误可能通过语法分析从源代码决定。</p>
<p>　　引起动态语法错误或动态语义错误依赖的值是合并子的具体实际参数的值，以及派生实现可选指定的其它的值。</p>
<p>　　引起动态语法错误或动态语义错误的情形包括求值特定的函数应用，由具体操作指定。</p>
<p>　　程序可通过<em>引发(raise)</em> 一个<em>错误对象(error object)</em> 指定引起诊断。</p>
<p>　　除非另行指定，NPLA1 的错误对象不需要是 NPLA1 支持的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">对象</a>，而可以仅在<a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>中可见。</p>
<p>　　因果性引起的错误可构成错误之间具有依赖关系。</p>
<p>　　错误对象的其它具体形式由派生实现指定。</p>
<h3 id="npla1-异常"><a class="header" href="#npla1-异常">NPLA1 异常</a></h3>
<p>　　NPLA1 的当前诊断使用的<a href="Features/NPL.zh-CN.html#%E5%BC%82%E5%B8%B8">异常</a>执行机制由宿主语言支持，通过宿主语言中的异常类型区分不同的异常条件。</p>
<p>　　NPLA1 约定的所有要求引起异常的诊断情形都是错误。</p>
<p><strong>注释</strong> 用户操作引起异常不一定是错误。</p>
<p>　　不引起未定义行为的翻译失败应<a href="Features/NPL.zh-CN.html#%E5%BC%82%E5%B8%B8">抛出异常</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">引发错误对象</a>可能通过抛出异常实现。此时，被抛出的宿主语言异常对象是错误对象。被抛出的异常类型可具有被显式指定的 <code>public</code> 基类，这些基类应无歧义以允许宿主语言捕获。</p>
<p>　　若存在<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">依赖错误</a>且引发被依赖的错误对象使用抛出异常实现，使用宿主语言标准库的<em>嵌套异常(nested error)</em> 机制实现依赖错误。</p>
<p>　　当前没有提供相关操作，但抛出的宿主异常在具有<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>的意义上是 NPLA1 的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>。</p>
<p>　　关于抛出异常的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>，参见项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h3 id="运行时错误条件"><a class="header" href="#运行时错误条件">运行时错误条件</a></h3>
<p>　　除非另行指定，实现应对以下全局的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">运行时</a><a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">错误条件</a>按要求引起诊断。</p>
<p>　　当实现无法提供需要的资源，<em>资源耗尽(resource exhaustion)</em> 。此时，引发特定的关于资源耗尽的错误对象。</p>
<p>　　除非另行指定，上述表示资源耗尽的错误对象满足宿主语言的以下类型的异常对象：</p>
<ul>
<li>宿主资源耗尽时，异常类型满足<a href="Features/NPL.zh-CN.html#%E5%B8%B8%E8%A7%84%E5%AE%BF%E4%B8%BB%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E8%A6%81%E6%B1%82">常规宿主资源分配要求</a>的类型。</li>
<li>否则，同<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%82%E5%B8%B8">异常</a>。</li>
</ul>
<p><strong>注释</strong> [ISO C++] 的本机实现宿主资源耗尽时，一般抛出派生 <code>std::bad_alloc</code> 的异常对象。这不包括<a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">本机实现无法提供资源的未定义行为</a>。</p>
<h3 id="错误检查"><a class="header" href="#错误检查">错误检查</a></h3>
<p>　　<em>检查(check)</em> 是限定成功的操作应满足的（必要非充分）条件引起诊断的操作。检查失败时要求引起诊断。</p>
<p>　　<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">良定义的</a>检查应具有<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">强规范化性质</a>，以保证有限数量的检查总在有限的计算步骤内终止。在进行检查的<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">上下文</a>，实现假定检查良定义。</p>
<p><strong>注释</strong> 实现不需在此之前对检查的这个性质附加检查。</p>
<p>　　检查条件限定检查的通过或失败。除非另行指定，通过的检查没有<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>，失败时总是具有作用。</p>
<p><strong>注释</strong> 检查失败通常可引起<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>。</p>
<p>　　NPLA1 要求在特定上下文进行<a href="Features/NPL.zh-CN.html#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>。派生实现可定义其它检查。</p>
<p>　　函数操作的语义可单独指定检查，具体形式由具体操作指定。</p>
<h4 id="npla1-类型检查"><a class="header" href="#npla1-类型检查">NPLA1 类型检查</a></h4>
<p>　　基于<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义类型</a>，对象语言实现应具有语义规则指定的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>，以确保程序的执行符合操作的必要前置条件。</p>
<p>　　操作的语义可要求以下的类型检查：</p>
<ul>
<li>对<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">求值得到的操作数</a>，按<a href="Features/NPL.zh-CN.html#%E6%8E%A5%E5%8F%A3%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">文法约定</a>的约束进行类型检查。</li>
<li>根据特定对象状态，指定<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">动态类型</a>的检查。
<ul>
<li><strong>注释</strong> 可通过类型检查规则明确要求对象具有特定的属性，例如<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">可修改</a>。</li>
</ul>
</li>
</ul>
<p>　　实现可能添加其它不违反语义要求的类型检查。</p>
<p>　　基于<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B">表达式的类型</a>，对应对象语言表达式的表示实体的元素可指定操作数上明确的类型要求。</p>
<p>　　部分实体从属于其它实体类型而构成<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>关系；部分的规约操作取得求值结果保证结果中的值可能具有的特定类型集合，这些类型也一并在以下描述中给出；其它情形不指定类型。</p>
<p>　　规约预期符合约束。若违反由项的表示的对象的动态类型不匹配导致，则求值失败；否则，行为未指定。</p>
<p>　　类型检查的完成应<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序</a>依赖被检查特定类型的值的访问。</p>
<p>　　除非另行指定，类型检查和程序中的其它作用（包括不同的其它类型检查）的顺序未指定。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型错误</a>引发错误对象。</p>
<p>　　若<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">合并子调用</a>不接受<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">非真列表</a>参数构成<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>，检查参数是<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>，即<em>参数列表(parameter list)</em> 。对参数列表的类型检查的完成应先序于其中任意子表达式的求值。</p>
<p><strong>原理</strong></p>
<p>　　类型检查有助于维护程序的正确性，并及早发现编程错误。</p>
<p>　　但是，类型检查自身存在开销；在一个阶段中集中检查类型的限制不是必要的。特别地，<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">静态类型检查</a>不被要求。</p>
<p>　　这些设计同时确保程序容易在程序在实现的不同<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">执行阶段</a>重现相同的检查逻辑乃至直接复用其实现。</p>
<p>　　为减小开销等目的，实现可能合并不同类型检查，而不改变程序的<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>。</p>
<p>　　对子表达式的求值需<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>子表达式。因此，对参数列表的检查蕴含顺序要求。</p>
<p><strong>注释</strong></p>
<p>　　一个值可被多次针对不同的对象进行类型检查。</p>
<p>　　不同的类型检查中，对特定类型的值的访问之间没有必然的隐含联系。</p>
<h2 id="npla1-外部表示"><a class="header" href="#npla1-外部表示">NPLA1 外部表示</a></h2>
<p>　　<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">外部表示</a>若被确定，由实现和派生实现定义。</p>
<p>　　NPLA1 不要求对象和其它实体存在外部表示，也不要求外部表示唯一。</p>
<p><strong>注释</strong></p>
<p>　　对外部表示的存在性要求和 [R<sup>n</sup>RK] 不同。</p>
<p>　　NPLA1 当前直接使用其它已被指定的表示规则，如<a href="Features/NPL.zh-CN.html#npla1-%E4%BA%92%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">互操作</a>隐含的宿主语言对象表示。</p>
<p>　　NPLA1 当前不提供可移植的互操作接口（包括一些基本 I/O 操作），也不约定其涉及的外部表示形式。</p>
<h2 id="表达式语义"><a class="header" href="#表达式语义">表达式语义</a></h2>
<p>　　表达式具有和<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">语法构造</a>不直接相关的且可能<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">上下文相关</a>的语义。</p>
<p>　　部分语义不需要通过<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>体现。</p>
<h3 id="npla1-规范求值算法"><a class="header" href="#npla1-规范求值算法">NPLA1 规范求值算法</a></h3>
<p>　　以<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">被求值的表达式</a>和所在的环境作为参数，NPLA1 使用以下<em>规范(canonical)</em> 求值算法取得表达式的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>：</p>
<ol>
<li><a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">自求值</a>：若被求值的表达式不是<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>且不是<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">有序对</a>，则求值结果是自身。</li>
<li><a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>：若被求值的表达式是一个符号值，则被视为<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">变量名</a>，求值结果是它在<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">上下文</a>（当前环境确定的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83%E6%8F%90%E4%BE%9B%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">词法作用域</a>）中变量绑定确定的对象的经<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">引用折叠</a>的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B">左值引用</a>。</li>
<li>否则：
<strong>注释</strong> 被求值的表达式是有序对。
<ol>
<li>若被求值的表达式是具有一个<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">元素</a>（<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">子表达式</a>）的<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">列表</a>，则求值结果是这个子表达式的求值结果。否则，继续以下求值步骤。
<strong>注释</strong> 被求值的表达式是具有不少于一个元素的列表或非真列表。</li>
<li>若被求值的表达式第一个子表达式是空列表，则移除，并继续以下求值。
<strong>注释</strong> 起始空列表的语法用于继续求值可能不提供<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">实际参数</a>的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>。具有实际参数的函数合并不一定需要起始空列表。</li>
<li>对第一个子表达式求值。</li>
<li>以第一个子表达式的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值计算</a>的求值结果作为<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作符</a>，以其余子表达式作为操作数，求值<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">合并</a>。</li>
</ol>
</li>
</ol>
<p>　　有序对以外的表达式被求值时：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">标识符</a>的值是构成标识符的符号值。</li>
<li><a href="Features/NPL.zh-CN.html#%E5%AD%97%E9%9D%A2%E9%87%8F">代码字面量</a>的值是去除其边界的 <code>'</code> 的标识符构成的符号值。
<strong>注释</strong> 代码字面量可表达直接作为标识符时不能作为符号值的词素的转义，例如 <code>''</code> 是一个空的符号值；而 <code>'#ignore'</code> 和 <code>42</code> 这样的形式允许其中的表达作为变量名，而不是字面量。</li>
<li><code>#t</code> 和 <code>#f</code> 求值为自身，是<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">布尔值</a>。</li>
<li><code>#ignore</code> 和 <code>#inert</code> 求值为自身，具有和其它值不同的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">单元类型</a>。</li>
<li>数值字面量求值为<em>数值(numerical value)</em> 。</li>
</ul>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">非空列表</a>和代码字面量以外的对象作为表达式，都是<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">自求值表达式</a>。</p>
<p><strong>原理</strong></p>
<p>　　NPLA1 规范<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>和 [R<sup>n</sup>RK] 中定义的 Kernel 求值算法（以及 [Shu10] 中定义的 <a href="Features/NPL.zh-CN.html#%E5%85%B6%E5%AE%83%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8F%82%E8%80%83">vau 演算</a>）类似，差异为：</p>
<ul>
<li>求值算法不直接约定取得 <a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">WHNF</a> 以外的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">子项</a>是否被求值，而由被调用的第一个子项决定。</li>
<li><a href="Features/NPL.zh-CN.html#%E8%AE%B0%E5%8F%B7%E6%B1%82%E5%80%BC">对符号值的求值</a>包含对<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>的区分。</li>
<li>要求一个子项的列表总是使用其列表元素求值。</li>
</ul>
<p>　　最后一个差异在对象语言中是实质性的，它决定<a href="Features/NPL.zh-CN.html#%E5%88%97%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">列表表达式</a>和其中的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">子表达式</a>的求值总是等价。</p>
<p>　　求值算法保持<a href="Features/NPL.zh-CN.html#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>。</p>
<p>　　NPLA1 翻译单元中，未求值的表达式满足以下性质：</p>
<ul>
<li>作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">记号</a>的标识符是<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号</a>类型的值。</li>
<li><a href="Features/NPL.zh-CN.html#%E5%88%97%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">列表表达式</a>中若不含有<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">子表达式</a>，则这个表达式是<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">空列表</a>；否则，是非空的<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>，子表达式是它的<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">元素</a>。</li>
</ul>
<p>　　NPLA1 规范求值算法和 [R<sup>n</sup>RK] 的求值算法具有近似的简单性。</p>
<p>　　因为 NPLA1 <a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">不支持存在环的非真列表</a>，<a href="Features/NPL.zh-CN.html#%E6%9C%89%E5%BA%8F%E5%AF%B9">cons 对</a>的描述被对应替换。</p>
<p>　　求值算法使用的环境同 [R<sup>n</sup>RK] 。</p>
<p>　　同 [R<sup>n</sup>RK] ，而非 [R<sup>n</sup>RS] ，NPLA1 规范求值算法避免对<em>顶层(top-level)</em> 的特殊引用，以避免<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">上下文相关性</a>的不同规则带来的复杂性和限制。</p>
<p>　　使用顶层的不同求值规则的限制可能简化一些编译实现需要的假设。但这泄漏了抽象，且在实际使用中<a href="https://gist.github.com/samth/3083053">引起大量问题</a>。</p>
<p>　　特别地，不同的顶层的特设规则相对更动态，反映<a href="https://calculist.blogspot.com/2009/01/fexprs-in-scheme.html">一些用户对 fexpr 的期望</a>，但在此这已被 vau 抽象替代。因此，使用不同的顶层求值规则以提供更强的动态性是多余的。</p>
<p>　　另一方面，当前环境一般允许被<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">具现</a>为<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">一等环境</a>在程序中可编程地访问而代表求值算法使用的上下文。为不同的上下文特设不同的顶层求值规则也是多余的。</p>
<p>　　关于实现，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p>　　以下各节补充描述 NPLA1 规范求值算法的局部性质。</p>
<p><strong>注释</strong></p>
<p>　　关于 WHNF 求值在 Kernel 中的描述，参见 [R<sup>n</sup>RK] 关于 <code>unwrap</code> 的 Rationale 的描述。</p>
<p>　　语法分析器的实现应使结果取得和这些性质兼容的中间表示。</p>
<h4 id="函数合并求值"><a class="header" href="#函数合并求值">函数合并求值</a></h4>
<p>　　求值算法向函数合并传递当前环境作为<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">函数合并的动态环境</a>。</p>
<p>　　为支持没有操作数的函数应用，需约定其它表达式表达求值为<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并的应用表达式</a>：</p>
<ul>
<li>当<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F">复合表达式</a>的第一个子表达式是空列表（<code>()</code>）时，求值为一个函数合并。
<ul>
<li><strong>注释</strong> 对没有操作数的情形，这是唯一被直接支持函数应用的语法</li>
</ul>
</li>
<li>否则，求值的作用同移除第一个子项 <code>()</code> 后的剩余形式。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　关于区分函数类型的替代设计（使用 <code>$</code> 作为第一个<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">子项</a>）的一个例子，参见<a href="https://eighty-twenty.org/2011/09/29/fexprs-remain-inscrutable#comment-422279775">这里</a>。</p>
<p>　　基于其中类似的对语义的影响（区分函数合并是否针对一个操作子）上的理由，这不被使用。</p>
<p>　　与此不同，尽管在对象语言中接受 <code>()</code> 的使用也需要求值算法的显式支持，这在目的上是纯语法意义上的——仅在无法避免语法歧义时，才必须使用。</p>
<p>　　只要能确定求值算法使用的环境，就能静态地区分复合表达式是否是函数合并。此时，其中的第一个子表达式是否显式为 <code>()</code> 不影响关于语义的推理。使用不同的内部中间表示可完全消除是否使用 <code>()</code> 的函数合并的差异；或者，也可以约定在代码中默认使用第一个子项是 <code>()</code> 的表达式作为函数合并的规范形式，而把第一个子项不是 <code>()</code> 的形式视为隐含 <code>()</code> 的语法糖。</p>
<p>　　因此，相对使用 <code>$</code> 而言，使用 <code>()</code> 的设计具有更少的缺陷（尽管需要更多的字符）。</p>
<h4 id="空列表求值"><a class="header" href="#空列表求值">空列表求值</a></h4>
<p>　　空列表 <code>()</code> 作为表达式是自求值表达式，而不是没有函数的空过程调用。</p>
<p><strong>原理</strong></p>
<p>　　关于 <code>()</code> 的求值规则避免这种简洁有用的语法导致<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">语法错误</a>。</p>
<p><strong>注释</strong></p>
<p>　　这和 [R<sup>n</sup>RS] 不同而同 [R<sup>n</sup>RK] 。在前者构造空列表需要 <code>'()</code> 。</p>
<p>　　和 Kernel 不同的函数合并求值规则使这个设计和函数求值字面上没有直接的关联，避免了 Kernel 中为什么 <code>()</code> 不是词法上类似的如 <code>(f x)</code> 这样的表达式的特例的问题。</p>
<p>　　注意以 <code>()</code> 作为前缀并不要求要求特定函数的子类型而可能破坏子类型<a href="Features/NPL.zh-CN.html#%E5%B0%81%E8%A3%85">封装性</a>的假设。</p>
<h4 id="记号求值"><a class="header" href="#记号求值">记号求值</a></h4>
<p>　　具有不同大小写字符的标识符不同。</p>
<p>　　可使用（能在求值时作为名称的）<a href="Features/NPL.zh-CN.html#npla-%E5%90%8D%E7%A7%B0%E5%92%8C%E5%AD%97%E9%9D%A2%E9%87%8F%E6%B1%82%E5%80%BC">代码字面量</a>即 '' 分隔）表达没有分隔符时被解释为字面量或其它值的符号值。</p>
<p>　　<a href="Features/NPL.zh-CN.html#npla-%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B">符号值</a>作为<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">名称表达式</a>，经<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>求值，访问当前环境中的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>。</p>
<p>　　其中，若被绑定对象是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>，结果是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">被折叠一次</a>的引用值；否则，结果是被绑定对象作为<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的引用值。</p>
<p>　　求值的结果是确保为<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>引用值。</p>
<p>　　结果不继续特别处理。引用值在此作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>，作为表达式时<a href="Features/NPL.zh-CN.html#%E9%BB%98%E8%AE%A4%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2%E7%BA%A6%E5%AE%9A">不发生左值到右值转换</a>。</p>
<p><strong>注释</strong></p>
<p>　　标识符大小写敏感的设计和 [R<sup>5</sup>RS] 及 klisp 不同，而和 [R<sup>6</sup>RS] 相同。和 [R<sup>7</sup>RS] 的默认行为相同，但不提供切换大小写不敏感的方法。</p>
<p>　　代码字面量和 klisp 使用 <code>||</code> 作为分隔符的语法不同，但作用类似。</p>
<p>　　和 klisp 不同，NPLA1 允许使用 <code>.</code> 作为<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">变量名</a>，但在特定的上下文不被求值时符号值 <code>.</code> 可被特别处理，如<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">绑定匹配</a>时忽略以 <code>.</code> 为符号值的绑定。</p>
<p>　　和 klisp 不同，NPLA1 允许使用 <code>++</code> 等全以 <code>+</code> 或 <code>-</code> 组成的字符序列构成标识符。</p>
<p>　　以 <code>#</code> 、<code>+</code> 或 <code>-</code> 起始的不能构成标识符的词素是 <a href="Features/NPL.zh-CN.html#npla-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F">NPLA 扩展字面量</a>。</p>
<h3 id="对象语言求值算法"><a class="header" href="#对象语言求值算法">对象语言求值算法</a></h3>
<p>　　除非另行指定，NPLA1 对象语言的求值总是使用 <a href="Features/NPL.zh-CN.html#npla1-%E8%A7%84%E8%8C%83%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">NPLA1 规范求值算法</a>。</p>
<p>　　在输入求值算法接受的语法形式之前，求值使用基于<a href="Features/NPL.zh-CN.html#%E4%B8%AD%E7%BC%80%E8%AF%AD%E6%B3%95">中缀语法</a>识别的分隔符进行处理。</p>
<p>　　由此引起的其它语法差异参见<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>。</p>
<h4 id="中缀语法"><a class="header" href="#中缀语法">中缀语法</a></h4>
<p>　　NPLA1 提供符合特定谓词指定的过滤条件的中缀分隔项替换为特定<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">名称表达式</a>指定的前缀操作形式的列表。</p>
<p>　　这些中缀变换作为预处理操作，可识别和接受 <a href="Features/NPL.zh-CN.html#%E8%AF%AD%E5%8F%A5">NPL-GA 语法</a>外的记号，即转换扩展的 <a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">NPL-GA 文法</a>输入为严格的 NPL-GA 语法要求的源语言。</p>
<p>　　中缀变换递归替换构成表达式的形如 <code>&lt;expression&gt; (&lt;infix&gt; &lt;expression&gt;)*</code> 的记号序列为 <code>&lt;transformed-infix&gt; &lt;expression&gt;+</code> 形式的记号序列。</p>
<p>　　其中，被支持的中缀记号 <code>&lt;infix&gt;</code> 是 <code>;</code> 或 <code>,</code> ，而 <code>&lt;transformed-infix&gt;</code> 是语法不可见的中缀变换函数。</p>
<p>　　其中，分隔符 <code>,</code> 优先组合。</p>
<p>　　分隔符对应的 <code>&lt;transformed-infix&gt;</code> 分别表示对被分隔的序列参数进行有序和无序列表求值（替换后合并子功能对应<a href="Features/NPL.zh-CN.html#npla1-%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83">参照实现环境</a>中函数 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$sequence</code></a> 和 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>list%</code></a> 求值后的合并子）。</p>
<p>　　对分隔符的处理使用和组合顺序相反的两遍分别对 <code>;</code> 和 <code>,</code> 遍历替换。</p>
<p>　　变换的不同 <code>&lt;expression&gt;</code> 的实例以相同的词法顺序在变换后的结果中被保存。</p>
<h4 id="求值算法实现风格"><a class="header" href="#求值算法实现风格">求值算法实现风格</a></h4>
<p><strong>原理</strong></p>
<p>　　和 Scheme 不同而和 Kernel 类似，求值通常使用显式的风格（详见 [Shu10] ）而不是依赖 <code>quote</code> 的隐式风格；这和不需要括号的语法特性无关。</p>
<h3 id="值类别和类型"><a class="header" href="#值类别和类型">值类别和类型</a></h3>
<p>　　基本内容参见 <a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">NPLA 值类别</a>和<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B">表达式的类型</a>。</p>
<p>　　特定的表达式维护<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">可修改性</a>。</p>
<p><strong>注释</strong> 这类似宿主语言的 <code>const</code> 类型限定，但只适合<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>且仅使用<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">隐式类型</a>。</p>
<p>　　特定的操作集合可约定关于确定结果值类别和类型的具体规则，如<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E7%BA%A6%E5%AE%9A">子对象访问约定</a>。</p>
<h3 id="绑定操作"><a class="header" href="#绑定操作">绑定操作</a></h3>
<p>　　绑定操作决定<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>或具有符号值的数据结构与项的对应关系，并<a href="Features/NPL.zh-CN.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a><a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>而引入<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">变量</a>。</p>
<p>　　作为<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数语法</a>的推广，两者分别由绑定操作使用<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">形式参数</a>和<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>指定。</p>
<p>　　操作数的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>具有树的构造，即<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数树</a>。</p>
<p>　　为决定形式参数对应的操作数，形式参数和操作数树或它们的<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的结构被比较，即绑定<em>匹配(match)</em> 。匹配操作数树的形式参数对应也可具有树的构造，即<em>形式参数树(formal parameter tree)</em> 。</p>
<p>　　被匹配的操作数是操作数树作为<a href="Features/NPL.zh-CN.html#%E6%9C%89%E5%BA%8F%E5%AF%B9">有序对</a>的<a href="Features/NPL.zh-CN.html#%E6%9C%89%E5%BA%8F%E5%AF%B9">元素</a>。类似地，形式参数是形式参数树作为有序对的元素。</p>
<p>　　绑定操作初始化对应的变量的名称和值分别由形式参数树和操作数树决定。</p>
<p>　　NPLA1 形式参数树具有特定的语法规则：树的叶节点为<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>、符号的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>或其它形式参数树构成的 <a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">DAG</a> 。若构造的形式参数树不符合语法规则，<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起错误</a>，不进行绑定。</p>
<p>　　成功的匹配决定形式参数对应的操作数或其<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">子项</a>，作为其<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">实际参数</a>。这种对应关系是单射但不一定是满射，即匹配成功后，每个参数总存在对应的操作数或其子项，而操作数和子项允许不对应形式参数而被忽略。</p>
<p>　　被绑定的项的操作数中的元素对应是<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>中的元素。</p>
<p>　　形式参数树中的引用值可能被间接访问其<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>一次，其余元素在匹配时被<a href="Features/NPL.zh-CN.html#%E9%BB%98%E8%AE%A4%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2%E7%BA%A6%E5%AE%9A">视为右值</a>。</p>
<p>　　绑定操作符合以下节的绑定规则。</p>
<p><strong>原理</strong></p>
<p>　　被绑定的参数可作为函数的形式参数。绑定操作对形式参数的处理也可以作为其它初始化变量的语法构造的基础。</p>
<p>　　作为推广，绑定操作也可以引入函数的形式参数以外的变量。</p>
<p><strong>注释</strong></p>
<p>　　形式参数树的节点可以是符号的引用值，但不支持<a href="Features/NPL.zh-CN.html#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">多重引用</a>。</p>
<p>　　关于对形式参数树的具体的语法要求，另见 <a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0"><code>&lt;ptree&gt;</code> 的定义</a>。</p>
<p>　　因为 NPLA1 支持的<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>都具有<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>的形式，操作数或其子项总能直接被作为函数的实际参数。</p>
<p>　　DAG 要求和 Kernel 类似。</p>
<p>　　和 Kernel 不同，操作数树同时支持作为<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用</a>的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>和非引用的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">右值</a>，在实现上需要解析引用。</p>
<h4 id="绑定初始化"><a class="header" href="#绑定初始化">绑定初始化</a></h4>
<p>　　绑定的对象节点的值和子节点元素被<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96">复制初始化</a>。</p>
<p>　　绑定前不对形式参数或实际参数中的元素求值。</p>
<p>　　除非另行指定，不同变量的绑定初始化之间<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">非决定性有序</a>。</p>
<p>　　绑定初始化不<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>形式参数，但可能因<a href="Features/NPL.zh-CN.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化转移初值符而修改操作数</a>。</p>
<p><strong>注释</strong></p>
<p>　　初始化元素类似宿主语言的参数传递中可发生初始化。</p>
<p>　　若形式参数或实际参数可能由求值得到，需在匹配前另行处理。</p>
<p>　　由<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">非决定性规约规则</a>，一般地，变量仅通过初值的求值决定的<a href="Features/NPL.zh-CN.html#%E9%80%92%E5%BD%92%E8%95%B4%E5%90%AB%E8%A7%84%E5%88%99">依赖关系</a>及<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>决定之间初始化的相对顺序。</p>
<p>　　因为绑定的初始化不负责实际参数的求值，一般地，即使初值符位于相邻的语法构造，也不保证隐含顺序；这和宿主语言不同。</p>
<p>　　初始化的顺序规则和宿主语言初始化不同的函数参数类似。</p>
<h4 id="绑定临时对象"><a class="header" href="#绑定临时对象">绑定临时对象</a></h4>
<p>　　被绑定的<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>不具有<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">临时对象属性</a>。</p>
<p><strong>原理</strong></p>
<p>　　因为<a href="Features/NPL.zh-CN.html#%E8%AE%B0%E5%8F%B7%E6%B1%82%E5%80%BC">记号求值</a>保证求值<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>是左值，被绑定的对象<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>最终得到的引用值不包含<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">唯一引用属性</a>。</p>
<p>　　这不清除绑定临时对象引入到表示被绑定对象的项或引用值中的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">其它属性</a>，因此其它属性可跟随一等对象<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">被跨过程传递</a>（若不经过<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>或其它操作）。</p>
<p>　　同<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">绑定临时对象属性</a>的讨论，被传递的属性类似宿主语言的指定转发引用参数类型，以下记作 <code>P</code> 。</p>
<p>　　特别地，被传递的属性包含临时对象属性。这对应宿主语言中 <code>P</code> 是左值引用。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">跨过程传递并不被宿主语言支持</a>。因此，一般仅限为了实现类似宿主语言的根据值类别和类型转发参数的<em>转发上下文(forwarding context)</em> 中使用。</p>
<p>　　通过从传递的属性中提取的<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">标签</a>访问引用<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用值的属性</a>代替保存<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境引用</a>并以其它底层的方式查询作为<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的被绑定对象的元数据能以更低的开销实现一些常见的相同的目的，如判断被引用对象是否表示可被转移的资源。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%A8%E7%A4%BA">临时对象的表示</a>、<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">非递归绑定</a>和<a href="Features/NPL.zh-CN.html#%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">递归绑定</a>。</p>
<p><strong>注释</strong></p>
<p>　　使用<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">引用标记字符</a>可保留来自引用值实际参数的作为引用值属性的临时对象属性。</p>
<p>　　使用引用标记字符 <code>&amp;</code> 可启用转发推断值类别。</p>
<h4 id="绑定匹配"><a class="header" href="#绑定匹配">绑定匹配</a></h4>
<p>　　绑定匹配以一个形式参数树和操作数树作为输入，比较两者的结构并尝试关联形式参数树中的子项到操作数蕴含的对象，以<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96">创建变量绑定</a>。</p>
<p>　　若绑定匹配成功，则可能进行以符号值为名称的对应变量的<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96">绑定初始化</a>；否则，绑定匹配失败，引起错误。</p>
<p>　　绑定匹配确定每一个符号值的过程<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序</a>这个符号值确定的变量的绑定初始化。</p>
<p>　　绑定匹配不<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>形式参数，在匹配成功进行绑定初始化前不修改操作数。</p>
<p>　　匹配使用如下算法搜索形式参数树和操作数的对应位置：</p>
<ul>
<li>初始化输入的形式参数树为当前形式参数，函数合并构成的操作数树作为当前操作数。</li>
<li>对每一对当前形式参数和当前操作数，比较两者（除非另行指定，操作数的值是引用值的，视为匹配<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>，下同）：
<ul>
<li>若两者都是有序对，则：
<ul>
<li>若形式参数有序对元素的结尾元素不是符号也不是有序对，则参数匹配失败。</li>
<li>若形式参数是列表，且元素的结尾元素是以 <code>.</code> 起始的符号值，则存在<em>省略(ellipsis)</em> ；保存移除	<code>.</code> 的符号值，并从子项中移除结尾元素，继续进行比较。</li>
<li>若形式参数和操作数的（直接）<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">前缀元素</a>数相等，或存在省略时移除结尾元素后的形式参数前缀元素数不大于操作数子节点的元素数，则：
<ul>
<li><strong>注释</strong> 直接比较前缀元素数，不计算有序对的非前缀元素是引用值且其被引用对象是非空列表时具有的元素数。</li>
<li>忽略形式参数中的省略的元素，以深度优先搜索从左到右逐一递归匹配两者的元素。</li>
<li>若存在省略的元素，若保存移除 <code>.</code> 的符号值非空，以移除 <code>.</code> 的符号值作为形式参数，匹配操作数构成的<em>结尾序列(trailing sequence)</em> 。</li>
<li>否则，若形式参数是非列表的有序对（最后的元素非空），匹配结尾序列。
<ul>
<li><strong>注释</strong> 结尾序列支持匹配有序对操作数的非前缀元素。这个元素可能是引用值，它的被引用对象被作为操作数继续匹配并进行<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">非递归绑定</a>。</li>
</ul>
</li>
<li>否则，若所在的形式参数列表的结尾元素是 <code>.</code> ，参数匹配成功，忽略结尾序列，不绑定对象。</li>
<li>否则，没有其余元素需要匹配，参数匹配成功。
<ul>
<li><strong>注释</strong> 先前对形式参数和操作数的节点数判断同时确保结尾序列为空。</li>
</ul>
</li>
<li>匹配结尾序列的规则参见非递归绑定。
<ul>
<li><strong>注释</strong> 结尾序列预期匹配的操作数是空列表或有序对。对操作数是列表的情形，结尾序列是<em>结尾列表(trailing list)</em> 。</li>
</ul>
</li>
</ul>
</li>
<li>否则，若不存在省略，列表的元素数不相等，参数匹配失败。</li>
<li>否则，操作数的子节点不足，参数匹配失败。</li>
</ul>
</li>
<li>若形式参数是空列表，则：
<ul>
<li>若实际参数不是空列表，则参数匹配失败。</li>
<li>否则，参数匹配成功。</li>
</ul>
</li>
<li>若形式参数是引用值且没有因为本条匹配规则递归进入匹配，则以其被绑定对象代替当前形式参数递归匹配。</li>
<li>若形式参数不是符号，则参数匹配失败。</li>
<li>若形式参数不是 <code>#ignore</code> ，则尝试绑定操作数到以符号值确定的名称的形式参数。
<ul>
<li>若符号值以一个<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6"><em>引用标记字符</em></a>起始，则被绑定的<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">变量名</a>中去除此前缀。</li>
<li>若去除前缀得到的符号为空，则忽略操作数，不绑定对象。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　绑定匹配时不检查重复的符号值。若形式参数树中出现重复的符号值，可被多次匹配成功。这可导致之后的绑定初始化中，只有其中某个未指定的绑定生效，其它绑定被覆盖。</p>
<p><strong>原理</strong></p>
<p>　　虽然可能匹配被引用对象，操作数匹配不蕴含时引用值不被<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%B6%88%E9%99%A4">消除</a>。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，明确直接比较前缀元素数，因为：</p>
<ul>
<li>这允许在元素数不同时给出更具有针对性的诊断，避免误用。</li>
<li>这能避免匹配在任何情形都总是顺序地依赖每一个操作数的值，允许<a href="Features/NPL.zh-CN.html#%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0">并发实现</a>。</li>
</ul>
<p>　　实现使用的表示允许访问元素数具有 <tt>O(1)</tt> 的时间复杂度，而访问前缀元素数具有 <tt>O(n)</tt> 时间复杂度。但限制不访引用值时，不会有较大的附加开销。</p>
<p><strong>注释</strong></p>
<p>　　函数合并构成的操作数树包括作为合并子的第一个子项和作为操作数的之后余下的子项。</p>
<p>　　数据结构和匹配算法类似 Kernel 中用于 <code>$define!</code> 和 <code>$vau</code> 等<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">操作子</a>的递归的匹配机制，但有以下不同（另见 <a href="Features/NPL.zh-CN.html#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">NPLA1 合并子</a>）：</p>
<ul>
<li>不支持 <a href="Features/NPL.zh-CN.html#%E6%9C%89%E5%BA%8F%E5%AF%B9">cons 对</a>的中缀 <code>.</code> ，但支持形式参数树中的列表最后以带省略的符号值匹配多个列表项的参数，绑定结尾序列。</li>
<li>对参数子项的符号值中可选的 <code>.</code> 起始以及之后可选的前缀作为标记字符作为引用标记进行处理。</li>
<li>不提供转义，若符号值去除可选的前缀及标记字符 <code>.</code> 后为空则忽略绑定。</li>
<li>若参数子项<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按引用传递</a>则间接访问并绑定<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>。</li>
<li>只支持<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">无环列表</a>，且不检查（因为 API 已经保证只支持真列表）。</li>
<li>列表外的 <code>.</code> 起始的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">词素</a>当前视为普通的符号，但此行为可能会在未来改变）。</li>
</ul>
<p>　　被忽略的绑定不保存绑定的对象。</p>
<p>　　不在列表内最后位置的带有前缀 <code>.</code> 的形式参数绑定的是普通的变量，不忽略绑定。</p>
<p>　　和 Kernel 不同，不检查重复符号值，且绑定匹配<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">对特定模式的形式参数进行不同的处理</a>。</p>
<p>　　其它一些不支持 cons 对的语言，如 [ECMAScript 2019] 的 <code>rest</code> 参数支持类似结尾列表的效果。</p>
<p>　　绑定匹配和创建绑定的初始化之间的顺序约定是必要的，因为这里约定的是一般的规约规则而非求值规则，<a href="Features/NPL.zh-CN.html#%E9%80%92%E5%BD%92%E8%95%B4%E5%90%AB%E8%A7%84%E5%88%99">递归蕴含规则</a>等求值的默认规则不适用。</p>
<p>　　绑定匹配允许<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">并行化</a>。</p>
<h4 id="引用标记字符"><a class="header" href="#引用标记字符">引用标记字符</a></h4>
<p>　　应用在形式参数树叶节点符号值的前缀 <code>%</code> 、<code>&amp;</code> 或 <code>@</code> 为标记字符表示名称绑定的可按需引入引用，称为引用<em>标记字符(sigil)</em> 。</p>
<p>　　绑定引用时，可使用引用推断规则：</p>
<ul>
<li>引用值<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值的副本传递</a>给形式参数，非引用值<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按引用传递</a>给<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">形式参数</a>。</li>
<li>否则，操作数按值的副本传递给形式参数。</li>
</ul>
<p>　　标记字符引起的绑定的差异为：</p>
<ul>
<li>不存在标记字符时，对操作数<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值的副本</a>绑定，实际参数的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">值的副本</a>传递给对应的形式参数。
<ul>
<li>若实际参数是<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">泛左值</a>，则实际参数上首先隐含<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">左值到右值转换</a>。</li>
</ul>
</li>
<li>存在标记字符 <code>%</code> 或 <code>&amp;</code> 时，按上述的引用推断规则直接绑定或转发操作数。
<ul>
<li>当实际参数是引用值时，在<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">可能对其它属性进行的处理</a>后，隐含一次<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">引用折叠</a>。</li>
</ul>
</li>
<li>存在标记字符 <code>@</code> 时，绑定以实际参数作为<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的引用值，不论操作数的类型和值类别。
<ul>
<li>初始化引用值时，没有<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%B6%88%E9%99%A4">引用值的消除</a>。</li>
</ul>
</li>
</ul>
<p><strong>注释</strong></p>
<p>　　除<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">复制消除</a>转移有序对操作数的子对象外，绑定时不修改被绑定操作数。</p>
<p>　　支持修改操作数的绑定的其它标记字符可能在未来支持。</p>
<h4 id="非递归绑定"><a class="header" href="#非递归绑定">非递归绑定</a></h4>
<p>　　非递归绑定在一次匹配之后创建对应的变量绑定。</p>
<p>　　合并使用或不使用<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">引用标记字符</a>的情形，非<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">结尾序列</a>的单一参数对象的<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96">绑定初始化</a>包含以下过程：</p>
<ul>
<li>若不存在标记字符 <code>@</code> ，则：
<ul>
<li>若操作数为<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%AF%E8%BD%AC%E7%A7%BB%E6%9D%A1%E4%BB%B6">可转移的</a>对象的引用值，则被绑定对象是按以下规则初始化的蕴含隐含的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">引用折叠</a>的引用值：
<ul>
<li>存在标记字符时，使用<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">引用推断规则</a>，被绑定对象是操作数直接初始化的引用值，其属性由操作数的（引用值）的属性决定：
<ul>
<li>当存在标记字符 <code>&amp;</code> 、绑定非结尾序列且作为操作数的引用值的属性包含<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">唯一引用属性</a>时，其中包含绑定<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象属性</a>。
<ul>
<li><strong>注释</strong> 使用 <code>%</code> 可避免操作数中的唯一引用属性在被绑定对象中蕴含<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">临时对象属性</a>。</li>
</ul>
</li>
<li>否则，被绑定对象的属性和作为操作数的引用值的属性相同。</li>
</ul>
</li>
<li>否则，被绑定对象是操作数<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96">复制初始化</a>（复制或转移）的值。</li>
</ul>
</li>
<li>否则，若<a href="Features/NPL.zh-CN.html#%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">操作数属性</a>指定可修改的临时值或有标记字符 <code>%</code> 时的临时值，操作数是可转移的非引用值，被绑定的对象是临时对象。</li>
<li>否则，当存在标记字符 <code>&amp;</code> 时，被绑定对象是操作数的引用值，其属性是操作数属性和<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">操作数项的属性</a>的并，但总是排除绑定临时对象属性。
<ul>
<li><strong>注释</strong> 此处的被绑定对象可在<a href="Features/NPL.zh-CN.html#%E8%AE%B0%E5%8F%B7%E6%B1%82%E5%80%BC">作为符号求值</a>时被折叠并在结果中<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">进一步去除</a>可能具有的<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">唯一引用属性</a>。</li>
</ul>
</li>
<li>否则，被绑定对象是复制自操作数的值。</li>
</ul>
</li>
<li>否则，被绑定对象的是操作数的引用值：
<ul>
<li>绑定操作数的引用时，要求引用的是列表中的项，否则引起错误。</li>
<li>被绑定的对象应是不唯一的值（直接绑定操作数右值以外的值），被绑定对象是操作数的引用值。</li>
</ul>
</li>
</ul>
<p>　　绑定结尾序列包含以下情形：</p>
<ul>
<li>若不存在标记字符 <code>@</code> ，则：
<ul>
<li>若操作数为可转移的对象的引用值，按非结尾序列的规则绑定操作数。</li>
<li>否则，若操作数属性指定可修改的临时值或有标记字符 <code>%</code> 时的临时值，按非结尾序列的规则绑定操作数。</li>
<li>否则，创建新的有序对，在其中以相应的标记字符（若存在）绑定各个元素子对象。</li>
</ul>
</li>
<li>否则，创建新的有序对，在其中以标记字符 <code>@</code> 绑定各个元素子对象。</li>
</ul>
<p>　　绑定结尾序列创建新的有序对并绑定元素子对象时，作为列表<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">完全分解</a>得到的每个元素组合的列表，满足：</p>
<ul>
<li>若操作数是临时对象，则操作数子项在绑定元素子对象时被<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4">复制消除</a>。</li>
<li>组合的列表是非真列表，当且仅当操作数是非真列表。</li>
<li>子对象的元素是对应的操作数以对应的引用标记字符（若存在）绑定单一参数得到的值。
<ul>
<li><strong>注释</strong> 若不存在引用标记字符，元素被对应复制初始化。</li>
</ul>
</li>
<li>若操作数是非真列表：
<ul>
<li><strong>注释</strong> 此时需初始化组合中的非列表结尾元素。</li>
<li>当不存在标记字符或存在标记字符 <code>%</code> 时，组合的最后一个元素是操作数中的最后一个元素的副本。</li>
<li>否则，组合中的最后一个元素是新创建的<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子对象引用</a>。
<ul>
<li>其被引用对象的表示中没有子项。</li>
</ul>
</li>
</ul>
</li>
<li>创建的有序对初始化完成后，参与初始化被绑定对象：
<ul>
<li>若存在标记字符 <code>&amp;</code> ，则创建子对象引用作为被绑定对象，其被引用对象是创建的有序对。
<ul>
<li>被创建的子对象引用的被引用对象的表示应避免复制初始化任何操作数一等对象。</li>
</ul>
</li>
<li>否则，创建的有序对直接被作为被绑定对象。
<ul>
<li>若存在标记字符，同时视为<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">绑定临时对象</a>，设置其表示的<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">临时对象标签</a>使之具有临时对象属性。</li>
</ul>
</li>
</ul>
</li>
<li>被绑定对象的元素总是不具有临时对象属性。
<ul>
<li><strong>原理</strong> 这使实现能<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">避免临时对象的子对象具有临时对象属性</a>。</li>
</ul>
</li>
</ul>
<p>　　绑定临时对象外的引用临时对象视为对被引用对象的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>。</p>
<p><strong>注释</strong> 这意味着除绑定临时对象外，若绑定操作数的初始化的引用值时实际引用临时对象，则<a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">因超出生存期的对象访问，行为未定义</a>。</p>
<p>　　仅在绑定临时对象且操作数可转移或使用标记字符 <code>%</code> 时使用复制消除。</p>
<p><strong>原理</strong></p>
<p>　　绑定的默认行为对引用值特殊处理，是为了满足 <a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">G1b</a> ，而不是像某些语言（如 [ISO C] 和 [Rust] ）仅通过内建的机制提供特定的<em>左值上下文(lvalue context)</em> 。</p>
<p>　　绑定的默认行为不使用<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">析构性转移</a>的操作（类似 [Rust] 的设计），原因是考虑到绑定的副作用影响操作数（即便因为对象被销毁而不一定是修改操作）和破坏<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">幂等性</a>（特别是指定<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">过程调用</a>的形式参数时）违反<a href="Features/NPL.zh-CN.html#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测性原则</a>。</p>
<p>　　为允许调用<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主对象</a>的<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">转移构造函数</a>，限制复制消除。初始化引用之外的参数创建也不是 [ISO C++17] 约定要求消除复制的上下文。</p>
<p>　　作为操作数的引用值中的唯一引用在使用 <code>&amp;</code> 引用标记字符时可同时蕴含<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">绑定临时对象属性</a>，这使绑定为变量的消亡值可能以名称表达式求值结果（不会是消亡值）的引用值访问时，能和其它引用值区分。提供这种设计的理由是：</p>
<ul>
<li>以下两种涉及<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">消亡值</a>的资源访问可被统一：
<ul>
<li>直接访问消亡值表达式。
<ul>
<li>消亡值表示即将被转移的资源。</li>
</ul>
</li>
<li>以消亡值初始化一个带有 <code>&amp;</code> 引用标记字符的非结尾序列变量，并以这个变量的名称作为表达式进行访问。
<ul>
<li>这通常需要使变量指称消亡值引用的资源，而不仅仅是表示即将被转移的消亡值自身。</li>
<li>具有临时对象属性的引用值通过右值初始化，相当于宿主语言中的右值引用，典型地表示能被转移的资源（而不一定需要立刻被转移）。</li>
<li>初始化变量同时转移资源，相当于宿主语言中复制初始化时调用转移构造函数转移操作数的资源到变量（对象或绑定到临时对象的引用），使之表示转移后的资源。</li>
</ul>
</li>
<li>尽管值类别可能不同，这两种表达式都可以表示蕴含被转移的资源的对象。</li>
</ul>
</li>
<li>直接求值名称表达式往往比其它替代方式更直接高效，但结果总是<a href="Features/NPL.zh-CN.html#%E8%AE%B0%E5%8F%B7%E6%B1%82%E5%80%BC">左值</a>而不具有<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">唯一引用属性</a>，而使用临时对象属性允许在求值的结果中被保留。
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">项引用</a>（而不是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">临时对象引用</a>）中的临时对象属性不影响值类别。</li>
<li>类似地，在宿主语言中，和值类别不同的状态以右值引用类型声明的形式编码在类型系统中。
<ul>
<li>引用值中的临时对象属性接近宿主语言中<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">转发引用</a>蕴含的静态类型。</li>
</ul>
</li>
<li>但和宿主语言不同，临时对象属性能随初始化后的引用值跨过程传递，而无需多次转发并在每次推导引用类型。</li>
</ul>
</li>
<li>基于上述规则，对象语言中特定的转发操作处理可统一的方式处理两种表达式以转移资源。这种设计能简化一般的使用。
<ul>
<li>引用值支持临时对象属性对有效的转发对象应用子的实现是必要的。
<ul>
<li>通过对象属性，转发对象操作可避免总是从实际的操作数提取值类别的需要，允许作为应用子而非<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">操作子</a>。</li>
<li>若不使用临时对象属性，则需要其它方式编码和值类别不同的状态以和消亡值区分，例如宿主语言的静态类型信息。
<ul>
<li>这会增加语言规则的复杂性。</li>
</ul>
</li>
</ul>
</li>
<li>需要转发资源时，一般只需要使用转发对象操作；其它情形可安全忽略引用值中的临时对象属性。</li>
<li>类似地，在宿主语言中，编码在类型系统中的状态在特定上下文中用于实现<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%80%BC%E4%BC%A0%E9%80%92">完美转发</a>。
<ul>
<li>宿主语言中，右值引用类型的变量作为左值（而不是消亡值）被访问，在大多数操作中没有和其它左值区分的意义。</li>
<li>在 <code>std::forward</code> 这样需要区分引用类型的转发操作（实例是一个函数，而不是宏）中，右值引用类型在局部是有意义的。</li>
<li>但是这仍然存在限制：因为没有跨过程传递的状态支持，明确具体类型还是需要程序显式指定 <code>std::forward</code> 的类型参数（或者宏），而不是 C++ 函数（应用子）的方式实现。</li>
</ul>
</li>
</ul>
</li>
<li>消亡值应和<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>在初始化其它变量时转移资源的作用一致，对应唯一引用属性和临时对象属性的相似处理。
<ul>
<li>通过唯一引用属性仍可区分一个具有临时对象属性的引用值以消亡值还是纯右值初始化。</li>
</ul>
</li>
<li>可使用 <code>&amp;</code> 以外的引用标记字符避免这里的行为而被初始化的被绑定对象（引用值）中引入非预期的临时对象属性。</li>
</ul>
<p>　　绑定结尾序列和非结尾序列的非递归绑定规则略有不同。</p>
<ul>
<li>特别地，除非被绑定对象是引用值，引用标记字符（不论是否存在）同时被作用到作为一等对象的元素上。这是因为：
<ul>
<li>此时，需要把操作数作为一等对象进行分解，使用引用标记字符或者不使用引用标记字符不破坏其它语义规则。</li>
<li>和非引用结尾序列相比，这使有序对的两个元素在初始化时的规则不同，但这具有合理性，因为：
<ul>
<li>有序对作为（非真）列表时，结尾元素和其它元素的地位不是相同的。</li>
<li>有序对的元素在 NPLA 对象表示中即已不对称，地位不可交换。</li>
<li>这种设计简化了一些重要的派生实现。</li>
</ul>
</li>
</ul>
</li>
<li>蕴含绑定<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">临时对象属性</a>的规则不适用绑定结尾序列中的元素，因为：
<ul>
<li>结尾序列的元素不具有名称，而不是通过绑定创建的能作为名称访问表达式的变量。访问元素需通过其它方式（如对象语言中的<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E7%BA%A6%E5%AE%9A">子对象访问操作</a>），方法和结果不唯一（如可能具有不同的值类别，可能即时转移资源等），不具有和消亡值的统一性。</li>
<li>引入附加的临时对象属性容易引起非预期的转移。除子对象访问时可能发生的直接转移（通常较明确），随引用值跨过程传递的临时对象属性在之后可能继续引起其它转移。因为首先通过子对象而非名称表达式访问，这种转移的存在性在创建变量绑定的位置通常不显然而无法预知，容易误用。</li>
<li>一旦不需要附加的临时对象属性，去除属性而得到引用值通常是较为困难的，需要对象语言提供特设的操作或绑定新的对象（尽管引入临时对象属性可能同样困难）。</li>
</ul>
</li>
</ul>
<p><strong>注释</strong></p>
<p>　　引用折叠的结果满足<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">不可修改引用属性的传播性质</a>。其它情形应满足 <a href="Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">NPLA1 引用值使用约定</a>。因此，仅有使用标记字符 <code>%</code> 进行消除引用时，被消除的引用值的不可修改属性被忽略。</p>
<p>　　绑定临时对象外不和 [ISO C++] 一样可能延长右值类类型<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的生存期。</p>
<p>　　具有引用标记字符的形式参数支持引入引用值并支持绑定引入<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的实际参数。</p>
<h4 id="递归绑定"><a class="header" href="#递归绑定">递归绑定</a></h4>
<p>　　形式参数树子项和操作数树的子项成功<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">匹配</a>后绑定子项。</p>
<p>　　递归的<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">绑定匹配</a>对应递归的绑定创建，允许以操作数树的子项对应初始化形式参数树的各个子项。</p>
<p><strong>注释</strong> 和形式参数树中的<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">结尾列表</a>的符号值被视为整体不同，递归绑定可包含项和其子项的多次递归的匹配。</p>
<p>　　绑定算法应确定和当前处理的操作数树的属性，即<em>操作数属性(operand property)</em> 。其中蕴含的表示操作数的项对应的<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">标签</a>，称为<em>操作数标签(operand tags)</em> 。</p>
<p>　　操作数属性和形式参数的引用标记字符结合决定是否<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按引用传递</a>初始化，并判断<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96">绑定初始化</a>时是否允许转移。</p>
<p>　　绑定匹配递归处理子项时，应确定子项的操作数标签，以指定子项可能具有的上下文相关的差异。</p>
<p>　　绑定初始时，操作数应为<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>。此时，以临时对象标签作为初始操作数标签。</p>
<p><strong>注释</strong> 这指定指定操作数是可被唯一使用的临时值。与此不同，若项表示作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>，应<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%A8%E7%A4%BA">不具有临时对象标签</a>。</p>
<p>　　一个项的子项的操作数标签由这个项的操作数标签（处理子项时，代表先前确定的所在的项的标签；以下称为当前操作数标签）和本节中以下约定的子项继承规则决定：</p>
<ul>
<li>若操作数子项不是引用值，则子项的操作数标签和当前操作数标签相同。</li>
<li>否则，匹配的子项是这个引用值的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>，子项的操作数标签以操作数子项中的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用值的属性</a>和当前操作数标签按以下引用项继承约束限定：
<ul>
<li>子项的操作数标签不包含<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">临时对象标签</a>。
<ul>
<li><strong>原理</strong> 这使实现能避免临时对象的子对象具有<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象标签</a>。</li>
</ul>
</li>
<li>子项的操作数标签是否包含<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">唯一引用标签</a>同引用值的属性。</li>
<li>子项的操作数标签是否包含其它标签同对应的当前操作数标签。</li>
<li>在以上基础上，引用值的属性向子项的操作数标签对应的属性<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">传播</a>：若前者包含不可修改属性，后者应包含不可修改标签。</li>
</ul>
</li>
</ul>
<p>　　绑定需转移子项（包括<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">绑定子项的复制消除</a>）时，使用<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">项的转移</a>。</p>
<p>　　绑定临时对象属性标签可影响<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">参数转发</a>。若需按类似宿主语言的成员表达式的值类别而不是成员是否为非左值引用进行转发，需确保被转发的值不是带有临时对象标签的引用值。</p>
<p>　　操作数标签中：</p>
<ul>
<li>唯一引用标签由所在的项单独决定。</li>
<li>临时对象标签仅在递归绑定时所在的所有列表项都是非引用值时包含。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用值的不可修改属性</a>标记不可修改项而避免非临时对象的转移。这和宿主语言中的非 <code>mutable</code> 类数据成员访问操作符决定 <code>const</code> 限定符的规则类似。</p>
<p>　　子项标签继承规则保证使用 <code>&amp;</code> 或 <code>%</code> <a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">标记字符</a>时，值类别的决定规则和宿主语言的成员访问操作符类似：</p>
<ul>
<li>列表左值中的元素总是被绑定为<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>。</li>
<li>列表右值的元素按元素是否为引用被绑定左值或<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">消亡值</a>。</li>
<li>特别地，<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">项引用</a>的临时对象标签不被继承到作为子项的被引用对象，因为即便被引用的列表对象是一个临时对象，它的元素不被作为纯右值匹配。这和宿主语言中成员访问操作符访问的右值是消亡值而不是纯右值类似。</li>
</ul>
<p>　　使用对象语言，若需判断列表左值中的元素是否为引用值，可直接绑定列表操作数为引用并按需转换为消亡值再递归绑定列表元素。</p>
<h3 id="绑定构造"><a class="header" href="#绑定构造">绑定构造</a></h3>
<p>　　部分<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>的求值包含<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">形式参数树</a>，通过<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">绑定规则</a>在<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">环境</a>中引入绑定，其调用指定<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">绑定操作</a>。具有这样的语法构造的表达式是<em>绑定构造(binding construct)</em> 。</p>
<p>　　一些绑定构造使用 <a href="Features/NPL.zh-CN.html#%E6%9C%AA%E6%B1%82%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;binding&gt;</code></a>提供在一个表达式多次出现的形式参数树和操作数树。</p>
<p><strong>注释</strong></p>
<p>　　绑定在<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>上的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>引入<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">变量</a>。</p>
<p>　　按<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96">绑定初始化</a>的约定，<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数树</a>的子节点初始化被绑定的形式参数树的对应子节点。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，各种绑定构造可使用 <a href="Features/NPL.zh-CN.html#%E6%9C%AA%E6%B1%82%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;body&gt;</code></a> 提供操作数。</p>
<p>　　对绑定项的处理和 [R<sup>n</sup>RK] 的其它不同参见<a href="Features/NPL.zh-CN.html#%E6%96%87%E6%B3%95%E5%85%83%E7%B4%A0%E8%A1%A5%E5%85%85%E7%BA%A6%E5%AE%9A">文法元素补充约定</a>。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a>。</p>
<h4 id="强递归绑定"><a class="header" href="#强递归绑定">强递归绑定</a></h4>
<p>　　除类似 Kernel 的常规绑定外，NPLA1 的部分绑定构造支持延迟附加的绑定的形式。</p>
<p>　　强递归绑定支持若同时绑定的递归<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>构成<a href="Features/NPL.zh-CN.html#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>，则递归绑定的值都是未指定的内部表示而不<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　强递归绑定是对象语言的绑定构造实现的附加机制，形式参数树的递归匹配仍使用<a href="Features/NPL.zh-CN.html#%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">递归绑定</a>。</p>
<h4 id="参数转发"><a class="header" href="#参数转发">参数转发</a></h4>
<p>　　绑定构造可支持<em>参数转发(argument forwarding)</em> ，根据实际参数确定形式参数中是否为引用值，保留<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E5%92%8C%E7%B1%BB%E5%9E%8B">值类别和可修改性</a>。</p>
<p><strong>注释</strong> 类似<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">宿主语言中的转发引用</a>参数。</p>
<h4 id="作用顺序"><a class="header" href="#作用顺序">作用顺序</a></h4>
<p>　　绑定构造引起的绑定初始化的作用<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">顺序</a>满足<a href="Features/NPL.zh-CN.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a>的约定。</p>
<p>　　若其中存在<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>，其顺序还满足：</p>
<ul>
<li>若存在同一形式参数树子节点的不同绑定的操作，则这些操作的副作用之间<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">非决定性有序</a>。</li>
<li>不同<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>的形式参数树子节点的绑定操作的副作用之间<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">无序</a>。</li>
<li>形式参数树的子节点上的绑定操作的副作用<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序</a>所在的节点上的绑定操作的其它副作用。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　这些规则允许<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">并行的</a>深度优先遍历的绑定实现。深度优先遍历使任一时刻成功完成绑定的对象集中，相对其它策略其状态更<a href="Features/NPL.zh-CN.html#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测</a>。</p>
<h2 id="对象语义"><a class="header" href="#对象语义">对象语义</a></h2>
<p>　　关于对象的存储，基本内容参见 <a href="Features/NPL.zh-CN.html#%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">NPLA 存储和对象模型</a>。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">对象语言内存安全保证</a>。</p>
<h3 id="npla1-对象同一性"><a class="header" href="#npla1-对象同一性">NPLA1 对象同一性</a></h3>
<p>　　NPLA1 的对象是<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>。由定义，NPLA1 的对象默认确保<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>。</p>
<p>　　例外参见 <a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">NPLA1 子对象</a>。</p>
<p>　　对象的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>通常不保证其作为<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>和其它对象都不同一，包括<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">唯一引用</a>的情形。但除非另行指定，作为函数实际参数的对象若是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B">右值引用</a>，则实现可假定被引用对象唯一。</p>
<p><strong>注释</strong></p>
<p>　　关于右值引用的保证类似 [ISO C++] <a href="https://eel.is/c++draft/res.on.arguments">[res.on.arguments]</a> 。注意这在对象语言而非宿主语言中适用。</p>
<h3 id="npla1-子对象"><a class="header" href="#npla1-子对象">NPLA1 子对象</a></h3>
<p>　　基本内容参见 <a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">NPLA 子对象</a>。</p>
<p>　　子对象可具有引用值，即<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子对象引用</a>。</p>
<p>　　子对象引用访问的被引用对象不保证具有同一性。</p>
<p><strong>原理</strong></p>
<p>　　和<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>不同，通过相同方式构造的子对象引用访问的被引用对象<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">未指定是否为同一对象</a>。</p>
<p>　　这允许实现使用和宿主语言不同的方式创建<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>作为子对象的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>。</p>
<p><strong>注释</strong></p>
<p>　　和宿主语言不同，NPLA1 对象语言不直接提供访问子对象的内建语法。</p>
<h4 id="子对象访问约定"><a class="header" href="#子对象访问约定">子对象访问约定</a></h4>
<p>　　作为<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">使用名称表达式访问对象</a>的推广，特定操作可使用非环境的其它对象显式地访问其子对象。</p>
<p>　　除非另行指定，这些<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>操作以本节约定的规则确定结果的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E5%92%8C%E7%B1%BB%E5%9E%8B">值类别和类型</a>。</p>
<p>　　若指称非环境对象的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a> <code>E1</code> 是访问操作的（被求值的）实际参数，子对象来自这个参数指定的对象；否则，子对象来自 <code>E1</code> 引用的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境对象</a>中的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>。</p>
<p>　　具体的访问操作确定具体的被访问的子对象。</p>
<p>　　访问操作中：</p>
<ul>
<li>若指定结果是引用值，或指定<a href="Features/NPL.zh-CN.html#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E7%9B%AE%E6%A0%87">（在结果中）保留引用值</a>且被访问的对象实际存在可被保留的引用值，则结果是被访问的子对象的可能经<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">引用折叠</a>的引用值。</li>
<li>否则，结果是被访问的被访问的子对象<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96">复制初始化</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>。
<ul>
<li>此时，按<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%AF%E8%BD%AC%E7%A7%BB%E6%9D%A1%E4%BB%B6">对象的可转移条件</a>判断复制或转移。</li>
</ul>
</li>
</ul>
<p>　　访问操作的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">结果</a>的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B">值的类型和值类别满足一一对应</a>，且结果经值类别转换后和被访问的子对象的类型相同。访问操作中没有明确指定的结果的值类别以此通过结果的类型推断。</p>
<p>　　若通过以上约定，仍没有明确结果的值类别，则按以下默认规则确定：</p>
<ul>
<li>若被访问的子对象是引用值，则结果是<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">泛左值</a>。</li>
<li>否则，若 <code>E1</code> 是<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>，则结果是左值。</li>
<li>否则，结果是<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">右值</a>。</li>
</ul>
<p>　　结果是具有被访问的子对象类型对应的值，它的更具体的值类别通过上述等价关系按结果的类型对应确定。</p>
<p>　　<code>E1</code> 或被访问的子对象的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">传播</a>引用值的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%B6%88%E9%99%A4">不可修改属性</a>。</p>
<p>　　被访问的子对象访问若具有影响值类别或被传播以外的其它属性被保留，对应在结果中出现。</p>
<p>　　<em>成员访问(member access)</em> 操作访问称为对象的<em>成员(member)</em> 的子对象，满足本节的约定。</p>
<p>　　具体操作可具有其它改变结果的值类别和类型的约定而实际使用不同的规则。</p>
<p><strong>原理</strong></p>
<p>　　确定结果的值类别和类型的方式类似按宿主语言的成员访问确定对表达式 <code>E1.E2</code> 的值类别和类型。<code>E1</code> 不一定是左值。</p>
<p>　　NPLA1 没有形如 <code>E1.E2</code> 的特设对象访问表达式语法，而以具体的访问操作代替，因此可具有近似但不同的规则。</p>
<p>　　特别地，除非 <code>E1</code> 引用环境，在 <code>E1.E2</code> 中显式指定被访问的子对象的表达式 <code>E2</code> 在访问操作中一般并不存在。代替这里的 <code>E2</code> 的是由具体访问操作指定被访问的子对象，其类型直接代替 <code>E2</code> 的类型。</p>
<p>　　其中，按有序对访问列表的最后一个元素时，被访问的子对象不是引用值，即视为<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>。这里不蕴含<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>，不会有<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">值类别转换</a>。</p>
<p>　　通过被访问的子对象的类型和 <code>E1</code> 的值类别确定结果的值类别的默认规则类似 C++ 成员访问表达式 <code>E1.E2</code> 确定值类别的规则，但略有不同：</p>
<ul>
<li>因为不保证存在名称表达式 <code>E2</code> ，不需要<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值算法</a>使用类似 C++ 的 <code>unqualified-id</code> 一致的方式使结果总是左值。</li>
<li>被访问的对象是右值引用值时，结果是右值引用值（即<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">消亡值</a>），而不一定是左值。</li>
<li>和 C++ 不同，NPLA 消亡值总是右值引用类型，NPLA 纯右值也此类似 C++ 纯右值实质化转换初始化的消亡值，因此逻辑上需要 C++ 消亡值的情形和此处的 NPLA 右值近似。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　初始化非引用值的复制初始化（包括以下的替换消亡值为右值）可能通过<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>实现。</p>
<p>　　在对象表示上，传播<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用值的不可修改属性</a>决定 <code>E1</code> 指定的被访问对象或被访问的子对象若具有<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">不可修改属性</a>，结果也具有不可修改属性。</p>
<p>　　典型地，被保留的其它属性包括<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">临时对象引用</a>。临时对象引用可被继续绑定而可实现<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">按需转发</a>被引用对象。</p>
<p>　　按默认规则访问相当于这些规则确定的值类似 C++ 表达式 <code>std::forward&lt;decltype(E1.E2)&gt;(E1.E2)</code> 的值。</p>
<p>　　具体操作可具有其它改变结果的值类别和类型的约定而实际使用不同的规则。</p>
<p>　　例如，推断结果的值类别的规则中的左值和消亡值可被替换为右值，则近似 C++ 表达式 <code>std::forward&lt;std::remove_cvref_t&lt;decltype(E1.E2)&gt;&gt;(E1.E2)</code> 。</p>
<p>　　传播引用值属性和宿主语言及<a href="Features/NPL.zh-CN.html#%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">递归绑定</a>规则类似。</p>
<p>　　关于子对象的修改，参见<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">对象的修改和改变</a>。</p>
<h3 id="对象的修改和改变"><a class="header" href="#对象的修改和改变">对象的修改和改变</a></h3>
<p>　　对象作为实体可修改和改变，可具有<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">可变数据状态</a>及<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">可变管理状态</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#npla-%E6%95%B4%E4%BD%93%E7%BA%A6%E5%AE%9A">NPLA 约定</a>的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>同<a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>的对象，其修改也同这些对象的修改。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">隐藏状态</a>在针对对象语言的的讨论中被排除。除非另行指定（由具体操作的语义蕴含），所有可变状态都不属于这些被排除的状态。</p>
<p>　　改变对象可引起<a href="Features/NPL.zh-CN.html#%E7%BF%BB%E8%AF%91%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%A7%84%E5%88%99">诊断</a>：</p>
<ul>
<li>对明确不可变的对象进行改变的操作<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">引起错误</a>。</li>
<li>具体操作的语义中，所有操作都允许的不要求诊断错误的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">改变操作</a>隐式地指定可变管理状态的改变。</li>
</ul>
<p>　　以下状态是可变管理状态：</p>
<ul>
<li>环境中的被绑定对象。</li>
</ul>
<p>　　除非另行指定，其余可变状态都是可变数据状态。</p>
<p>　　类似宿主语言（如关于 <code>const</code> 限定符的语义），生存期开始前或结束后的（可能并未完成构造的）对象中的子对象的修改不是对象的修改；对应地，此处的子对象的变化也不是对象的改变操作。</p>
<p>　　改变上述的被排除的状态的修改操作不被视为对象语言中的对象的改变操作。</p>
<p>　　对包含所有权的子对象的修改是对所在对象的修改。</p>
<p>　　除非另行指定，NPLA1 不限制任意对象不可修改。</p>
<p>　　等价关系和限制不可修改性的方法的方式不唯一，因此不可修改性也不唯一。</p>
<p>　　因为<a href="Features/NPL.zh-CN.html#npla1-%E5%A4%96%E9%83%A8%E8%A1%A8%E7%A4%BA">外部表示不唯一</a>，不需要基于此定义一种正规的关于外部表示的等价判断形式。</p>
<p>　　对象的不保证<a href="Features/NPL.zh-CN.html#npla1-%E5%AF%B9%E8%B1%A1%E5%90%8C%E4%B8%80%E6%80%A7">同一性</a>的<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的修改和改变不保证蕴含对对象的修改和改变。</p>
<p><strong>原理</strong></p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">开放类型映射</a>不保证非特定对象之间的不可修改性具有唯一的定义。</p>
<p>　　对象的修改和改变作用在确定的对象上。</p>
<p>　　若不同的对象之间不具有同一性，则作用之间无关。因此，修改和改变作为副作用，<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">不保证在不同一的对象之间共享</a>。</p>
<p><strong>注释</strong></p>
<p>　　所有对对象的状态的约定针对同一个对象。</p>
<p>　　对象的子对象作为可变管理状态，使不可变对象具有允许这些状态改变的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">内部可变性</a>而和对象的可变性不同。</p>
<p>　　对诊断的要求类似 [R<sup>n</sup>RK] 。</p>
<p>　　环境中的被绑定对象在仅讨论不可变性的意义外仍是数据对象。</p>
<p>　　引起对象内的可变管理状态的改变而不改变对象的操作在宿主语言<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">可通过类的 <code>mutable</code> 数据成员实现</a>，但 NPLA1 不提供特性使任意的<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的可修改性的限制如宿主语言的 <code>const</code> 限定符自动传播（而一般需要使用<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E7%BA%A6%E5%AE%9A">成员访问操作</a>），因此也不需要提供对应的类型检查修改机制。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，NPLA1 支持直接修改对象，而不只是通过指定子对象关联的被引用对象的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">改变操作</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%86%BB%E7%BB%93">冻结</a>操作是使环境对象上具有类似宿主语言的 <code>const</code> 传播约束的操作；和宿主语言不同，这不是静态类型系统约束。</p>
<h4 id="赋值"><a class="header" href="#赋值">赋值</a></h4>
<p>　　NPLA1 的<em>赋值(assignment)</em> 操作专指以引用值操作数指定对象且不引起同一性改变的<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">对象修改</a>。</p>
<p>　　被修改的对象由赋值操作的目的操作数决定，可能是操作数对象或其引用的对象。赋值操作后，被修改对象的值来自源操作数。</p>
<p>　　操作数和源操作数相同的赋值是<em>自赋值(self assignment)</em> 。</p>
<p>　　除非另行指定，赋值操作不保留源操作数的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E5%92%8C%E7%B1%BB%E5%9E%8B">值类别</a>和可修改性。</p>
<p>　　赋值可引起源操作数<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">对象的复制或转移</a>，分别称为<em>复制赋值(copy assignment)</em> 和<em>转移赋值(move assignment)</em> 。</p>
<p>　　复制赋值时不会<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4">复制消除</a>对象。若被赋值的源操作数的值在复制出错，目的操作数引用的对象不被修改。</p>
<p>　　通过对象的<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象引用</a>修改对象的子对象不保证作用在对象上。</p>
<p><strong>原理</strong></p>
<p>　　赋值不引起同一性改变的保证和区分复制赋值和转移赋值类似宿主语言。</p>
<p>　　宿主语言中，通过源操作数的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态类型</a>（左值或右值引用类型）明确区分两者，但 NPLA 不要求类型系统（尽管支持类似作用的<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">元数据</a>），两者区分实际依赖具体行为。</p>
<p>　　子对象引用不一定保证引用完整对象，而修改的副作用可能需要完整对象的信息：</p>
<ul>
<li>例如，修改作为列表的子对象的有序对时需要维护保持子对象关系的内部状态，而子有序对引用若不提供所在的列表的引用，则无法实现维护状态。</li>
<li>为维持子对象引用实现的<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>，不对这类情形进行一般要求。</li>
<li>特定操作可以提供更强的保证以允许满足<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　赋值操作可能伴随赋值以外的其它副作用，如<a href="Features/NPL.zh-CN.html#%E8%BD%AC%E7%A7%BB%E5%AF%BC%E8%87%B4%E7%9A%84%E4%BF%AE%E6%94%B9">转移导致的修改</a>。</p>
<p>　　特定的赋值操作可能不支持自赋值，指定自赋值具有<a href="Features/NPL.zh-CN.html#npla1-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">未定义行为</a>或引起错误。</p>
<p>　　注意避免使用引用值作为操作数的自赋值引起<a href="Features/NPL.zh-CN.html#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>：此时除非另行指定，引起 <a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">NPLA 未定义行为</a>。</p>
<p>　　不引起同一性改变的保证和 Kernel 的赋值操作包含以特定对象进行替换（可使用<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">项的转移</a>实现）而使对象被修改的情形不同。</p>
<p>　　赋值不保证子对象的同一性不被改变；子对象的引用仍可能被赋值<a href="Features/NPL.zh-CN.html#%E6%97%A0%E6%95%88%E5%8C%96">无效化</a>。</p>
<h4 id="转移导致的修改"><a class="header" href="#转移导致的修改">转移导致的修改</a></h4>
<p>　　转移可导致被转移对象的外部可见的修改。</p>
<p>　　转移不需要是直接显式求值特定的函数调用的副作用。</p>
<p><strong>注释</strong> 例如，使用<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">唯一引用</a>初始化对象，可<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">转移</a>表示<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的项。</p>
<p>　　和<a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>不同，当前实现不直接通过初始化<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">转移</a><a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主对象</a>。</p>
<p>　　被转移的对象在转移后具有<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">有效但未指定</a>的状态。</p>
<p><strong>注释</strong></p>
<p>　　当前实现中，当项被转移后，表示的值为 <code>()</code> 。这和<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>等引入<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">实质化临时对象</a>时可能具有的转移的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>（仅在互操作时可见）不保证相同。</p>
<p>　　作为<a href="Features/NPL.zh-CN.html#%E8%B5%8B%E5%80%BC">赋值规则</a>的推论，通过转移对象的<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象引用</a>修改对象的子对象不保证作用在对象上。但和其它修改不同，这同时被转移对象后的状态的规则覆盖。</p>
<h3 id="驻留"><a class="header" href="#驻留">驻留</a></h3>
<p>　　出现在表达式中多个位置的值在实现中可共享一个对象作为内部表示。这个对象被<em>驻留(intern)</em> 。</p>
<p>　　当前实现不使用对象驻留，以简化<a href="Features/NPL.zh-CN.html#%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">存储对象的互操作</a>。</p>
<p><strong>原理</strong></p>
<p>　　因为<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>允许通过引用值被直接<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>，驻留对象创建的共享可能影响<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>。</p>
<p>　　因此兼容 NPLA1 语义的驻留要求排除<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">可修改的操作</a>，且被驻留的值对应的对象的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>不被外部依赖。</p>
<p><strong>注释</strong></p>
<p>　　驻留的对象在实现上共享存储，但仍区分同一性。</p>
<p>　　一般地，驻留仅适合不可变对象，或改变后提供不同副本区分同一性的可变对象。</p>
<p>　　[R<sup>n</sup>RS] 等不可变的符号可被驻留，但没有特别要求。</p>
<p>　　[R<sup>7</sup>RS] 明确要求空列表的唯一性。和驻留一致，这可实现为全局共享对象。</p>
<h3 id="无效化"><a class="header" href="#无效化">无效化</a></h3>
<p>　　若对象的<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8">引用值保持有效</a>，则指称的左值的对象<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>不变。</p>
<p>　　作为<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>的派生实现，对象语言中的引用值的<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">无效化</a>包括以下情形：</p>
<ul>
<li>被引用的对象存储期已结束（此时引用值是<a href="Features/NPL.zh-CN.html#%E6%97%A0%E6%95%88%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC">悬空引用</a>）。</li>
<li>对象被除通过<a href="Features/NPL.zh-CN.html#%E9%87%8D%E7%BB%91%E5%AE%9A">重绑定</a>、<a href="Features/NPL.zh-CN.html#%E8%B5%8B%E5%80%BC">赋值</a>和另行指定的情形以外的方式<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>，而引起对象同一性的改变。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　对项的重绑定或赋值仍可能因为对子项的修改蕴含被替换的对象的销毁，引起<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">生存期结束</a>，而使其表示的对象的引用值无效化。</p>
<h3 id="类型分类"><a class="header" href="#类型分类">类型分类</a></h3>
<p>　　NPLA1 不要求支持任意<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型的集合表示</a>不相交，即<em>分区(partition)</em> 。</p>
<p>　　但除非另行指定，基于<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E5%85%83%E7%B4%A0%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">实体元素文法</a>引入的类型仍被分区。</p>
<p><strong>原理</strong></p>
<p>　　不要求分区这避免全局地假定<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%85%A8%E9%9B%86">类型全集</a>的具体表示，并支持开放的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">类型映射</a>。</p>
<p>　　NPLA1 的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E8%B0%93%E8%AF%8D">类型谓词</a>是一元谓词，<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E8%B0%93%E8%AF%8D">只接受一个参数</a>，以强调语言提供的接口的<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E4%BA%A4%E6%80%A7">正交性</a>。</p>
<p><strong>注释</strong></p>
<p>　　通过指定<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型关系</a>可使两个<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义类型</a>作为集合相交。</p>
<p>　　列表类型只包括<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>。</p>
<p>　　不要求分区、类型判断谓词、列表类型的设计都和 Kernel 不同。</p>
<h2 id="npla1-对象语言数据结构"><a class="header" href="#npla1-对象语言数据结构">NPLA1 对象语言数据结构</a></h2>
<p>　　本节指定在 NPLA1 允许以<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E8%AF%AD%E4%B9%89">一等实体</a>被使用的基本元素。</p>
<p>　　<a href="Features/NPL.zh-CN.html#npla-%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B">NPLA 一等对象</a>是 NPLA1 一等对象。</p>
<p><strong>注释</strong></p>
<p>　　部分设计原则和规则和 Kernel 不同。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E4%B9%89">对象语义</a>。</p>
<h3 id="npla1-引用"><a class="header" href="#npla1-引用">NPLA1 引用</a></h3>
<p>　　NPLA1 基于 NPLA <a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">项引用</a>支持实体的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用</a>。</p>
<p>　　NPLA1 语义中对<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">广义实体</a>的构成依赖的使用也被称为引用，这不限被对象语言中的引用值表达。另见<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境引用</a>。</p>
<p>　　NPLA1 <a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">明确允许不通过对象的引用保存对象</a>，但是也允许使用对象引用；即对象和对象的引用都可作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>。</p>
<p>　　这也允许子对象直接被所在的对象蕴含。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>都通过<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>表示。另见<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">一等引用</a>、<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>和<a href="Features/NPL.zh-CN.html#%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">存储和对象模型</a>。</p>
<p>　　引用值在创建时即引用在生存期内的对象。</p>
<p><strong>注释</strong></p>
<p>　　引用和 Kernel 及 Scheme 的引用类似。</p>
<p>　　明确允许不通过对象的引用保存对象和 Kernel 不同详见<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E8%AF%AD%E4%B9%89">实体语义</a>。</p>
<h4 id="npla1-引用值使用约定"><a class="header" href="#npla1-引用值使用约定">NPLA1 引用值使用约定</a></h4>
<p>　　除非另行指定：</p>
<ul>
<li>不在求值引入右值引用。</li>
<li>引用值的<a href="Features/NPL.zh-CN.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初始值</a>经过不超过一次<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">引用折叠</a>。</li>
<li>为在表达式的求值结果中取得折叠的引用值：
<ul>
<li>当<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>是<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>时，引用值被<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">折叠一次</a>。</li>
<li>否则，引用值通过蕴含一次<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">引用值提升转换</a>的方式被<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%B6%88%E9%99%A4">消除</a>一次。</li>
</ul>
</li>
<li>违反<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">不可修改引用</a>引入的假定的修改操作引起<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型错误</a>。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　按 <a href="Features/NPL.zh-CN.html#npla1-%E8%A7%84%E8%8C%83%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">NPLA1 规范求值算法</a>，隐含<a href="Features/NPL.zh-CN.html#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>直接求值名称表达式的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>是左值。这和宿主语言求值的 <code>unqualified-id</code> 在除了<em>枚举器(enumerator)</em> 外的大多数情形中类似。</p>
<p>　　在此，这被约定为默认情形。其它情形需要附加的规则指定。</p>
<p>　　特定的显式指定环境和名称表达式的操作访问环境中的被绑定对象，其求值结果可以是<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>或<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">消亡值</a>。这和宿主语言的涉及成员访问的表达式（形如 <code>E1.E2</code> 或 <code>E1-&gt;E2</code> ）类似。环境相当于宿主语言中形如 <code>E1</code> 的对象表达式。</p>
<p>　　因为类型系统的不同，类比成员访问的表达式时，忽略 C++ 的位域(bit-field) 、静态成员、成员函数和枚举器的访问规则。</p>
<p>　　此处 <code>E1</code> 总是被视为左值，所以类似宿主语言的规则，结果的值类别由环境中的对象类型确定：当且仅当对象是左值时，结果是左值；否则是消亡值。</p>
<p>　　因为 NPLA 的左值和消亡值是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B">引用值</a>，存在推论：</p>
<ul>
<li>当且仅当对象是左值时，显式指定环境的成员访问的结果是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B">左值引用</a>。</li>
<li>否则，结果是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B">右值引用</a>（<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">唯一引用</a>）。</li>
</ul>
<p>　　访问不作为被绑定对象的子对象时，通常并非如宿主语言为支持推断参数类型的方式使用引用折叠，构造折叠的引用值默认不直接使用<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">引用折叠的规则</a>（除临时对象标签外同 [ISO C++] ），而直接由被引用对象确定。</p>
<p>　　对访问列表中的子项构成的子对象引用，这也和宿主语言的涉及成员访问的表达式类似，除以下不同：</p>
<ul>
<li>元素是引用值时允许结果是唯一引用（而不是宿主语言的左值）。
<ul>
<li>这是因为在此唯一引用指定的是结果的值的类型，而非类似宿主语言声明的右值引用类型。</li>
</ul>
</li>
<li>元素是临时对象的引用值时，允许引用值上的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">临时对象属性</a>在访问中被区分（类似宿主语言以成员访问表达式作为 <code>decltype</code> 的操作数的结果）。</li>
</ul>
<p>　　访问被绑定对象使用引用值也满足<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">不可修改引用属性的传播性质</a>，避免被绑定对象被任意非预期地修改。</p>
<p>　　其它情形是否需要满足不可修改引用属性的传播性质和具体操作相关，因此不明确要求。</p>
<p>　　对违反不可修改引用引入的假定的修改操作要求错误<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">避免隐式的 NPLA 未定义行为</a>，因此引入类型错误作为<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">违反引用值的属性引入的错误</a>。</p>
<p><strong>注释</strong></p>
<p>　　<a href="Features/NPL.zh-CN.html#npla1-%E4%BA%92%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">互操作</a>可能引入右值引用。</p>
<p>　　访问子对象的具体规则参见<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E7%BA%A6%E5%AE%9A">子对象访问约定</a>。</p>
<p>　　作为列表或者环境中绑定对象的一部分，引用值可能通过<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>或对象语言提供的操作访问。这同时确定值类别。</p>
<p>　　蕴含一次引用值提升转换的方式包括<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>。</p>
<h4 id="循环引用"><a class="header" href="#循环引用">循环引用</a></h4>
<p>　　除非另行指定（如<a href="Features/NPL.zh-CN.html#%E5%BC%BA%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">强递归绑定</a>），对象中的循环引用引起 <a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">NPLA 未定义行为</a>。</p>
<p><strong>原理</strong></p>
<p>　　循环引用破坏一些实现的假设而引起非预期的访问。</p>
<p>　　不显式访问环境的操作也可能引入循环引用（而引起未定义行为），例如 <a href="Features/NPL.zh-CN.html#npla1-%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83">NPLA1 参照实现环境</a> 下：</p>
<pre><code class="language-npla1">$def! l ();
$def! l list% l;
</code></pre>
<p>　　典型实现中，具有所有权的循环引用可引起<a href="Features/NPL.zh-CN.html#%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F">资源泄漏</a>；无条件遍历访问循环引用<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的求值不具有<a href="Features/NPL.zh-CN.html#%E7%BB%88%E6%AD%A2%E4%BF%9D%E8%AF%81">终止保证</a>。</p>
<p>　　例如 NPLA1 参照实现环境下求值以下表达式：</p>
<pre><code class="language-npla1">$let ((nenv () make-environment)) $set! nenv self nenv
</code></pre>
<p>　　可引起被捕获的环境中存储的对象无法释放。</p>
<p>　　能同时保证避免资源泄漏的实现引起一般意义上更根本的设计限制，因此不被使用。详见<a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">自引用数据结构和循环引用</a>。</p>
<p>　　此外，为了避免 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$lambda</code></a> 等引起不经意的循环引用误用，根据<a href="Features/NPL.zh-CN.html#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测性原则</a>，这些<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>的<a href="Features/NPL.zh-CN.html#%E5%88%9B%E5%BB%BA%E5%92%8C%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0">构造器</a>默认不使用<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">强引用</a>作为静态环境。</p>
<p>　　若需保持静态环境的所有权，使用显式指定静态环境的构造器（如 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$lambda/e</code></a> ）和 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>lock-current-environment</code></a> 等。</p>
<p>　　否则，容易引起循环引用，如以下表达式：</p>
<pre><code class="language-npla1">$def! f $lambda ()
</code></pre>
<p>　　会相当于当前设计的：</p>
<pre><code class="language-npla1">$def! f $lambda/e (() lock-current-environment)
</code></pre>
<p>　　此处锁定的<a href="Features/NPL.zh-CN.html#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>的强引用被作为闭包的一部分绑定到当前环境中，引起循环引用。</p>
<p>　　而求值当前设计中等价的：</p>
<pre><code class="language-npla1">$def! f $lambda/e (() get-current-environment)
</code></pre>
<p>　　不引起未定义行为。</p>
<h4 id="自引用数据结构"><a class="header" href="#自引用数据结构">自引用数据结构</a></h4>
<p>　　因为不支持<a href="Features/NPL.zh-CN.html#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>，不支持引用自身的<a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">自引用数据结构</a>。</p>
<p><strong>注释</strong> 另见<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">列表</a>。</p>
<h3 id="npla1-环境"><a class="header" href="#npla1-环境">NPLA1 环境</a></h3>
<p>　　NPLA1 支持<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">一等环境</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境对象</a>也可能是语言中显式约定的和<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境引用</a>不同的非一等对象。</p>
<p>　　NPLA1 的环境关连的<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">父环境</a>的<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">重定向</a>使用 DFS（Depth-First Search ，深度优先搜索）遍历目标。</p>
<p>　　环境中的一等对象是环境对象的<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>。子对象是环境对象，即<em>环境子对象(environment subobject)</em> 。</p>
<p>　　语言实现可提供不是一等环境的环境对象，即<em>非一等环境(non-first-class environment)</em> 。</p>
<p><strong>注释</strong></p>
<p>　　除了支持非一等对象的环境，和 Kernel 类似。</p>
<h4 id="隐藏环境"><a class="header" href="#隐藏环境">隐藏环境</a></h4>
<p>　　总是不能被对象语言以一等对象访问的环境是<em>隐藏环境(hidden environment)</em> 。</p>
<p><strong>注释</strong> 推论：非一等环境是隐藏环境。</p>
<p>　　一般地，隐藏环境是某一个（非隐藏的）一等环境的直接或间接父环境（而能通过求值等间接操作被访问）。</p>
<h4 id="新环境"><a class="header" href="#新环境">新环境</a></h4>
<p>　　<em>新(fresh)</em> 环境是新创建的环境。</p>
<p>　　新环境和先前的其它的（特别地，包括<a href="Features/NPL.zh-CN.html#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>）不共享相同环境对象。</p>
<p>　　除非另行指定，新环境是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">空环境</a>。</p>
<p>　　创建新环境的一个例子是 <a href="Features/NPL.zh-CN.html#vau-%E6%8A%BD%E8%B1%A1">vau 抽象</a>实现<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">过程调用</a>。</p>
<h4 id="环境的稳定性"><a class="header" href="#环境的稳定性">环境的稳定性</a></h4>
<p>　　环境在特定情形保证<em>稳定性(stability)</em> ：一个环境是<em>稳定的(stable)</em> ，仅当总是可假定绑定维持一定意义的等价性，而可确保访问其中同名实体的<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为等价</a>。</p>
<p>　　违反关于环境的稳定性的要求的程序具有<a href="Features/NPL.zh-CN.html#npla1-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">扩展 NPLA 未定义行为</a>。</p>
<p>　　当前要求确保的稳定性包括：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E9%9A%90%E8%97%8F%E7%8E%AF%E5%A2%83">隐藏环境</a>的<a href="Features/NPL.zh-CN.html#%E9%87%8D%E7%BB%91%E5%AE%9A">绑定有效稳定性</a>和<a href="Features/NPL.zh-CN.html#%E8%A2%AB%E7%BB%91%E5%AE%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%80%BC%E5%92%8C%E5%8F%AF%E8%A7%82%E5%AF%9F%E8%A1%8C%E4%B8%BA">值稳定性</a>。</li>
<li>从构造时即明确要求的一等环境的稳定性，包括<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9D%97%E7%A8%B3%E5%AE%9A%E6%80%A7">模块稳定性</a>和可能由派生实现定义的其它稳定性。</li>
</ul>
<p>　　环境中的绑定的对象可以在引入后通过<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8">对象的引用</a>被修改(#对象的修改和改变)。</p>
<p><strong>原理</strong></p>
<p>　　一般地，环境的稳定性要求构造环境时不能依赖非特定的动态环境（作为被<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>访问的父环境），因为这些环境的绑定可能具有在构造环境之后确定的绑定，而不能确保环境中的名称具有可预知的含义。</p>
<p>　　环境的稳定性简化分析程序的推理过程，也在许多上下文中允许程序更易被优化。</p>
<p>　　从稳定的环境多次访问对象的计算作用是幂等的。这允许合并多次访问为一次而不改变程序的行为，允许具有较小的实现开销。</p>
<p>　　环境的稳定性不易被可靠地判定甚至不可能被判定（例如，一个无法检查但可信的来源提供的环境），因此语言规则在此不要求进行检查。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">环境基本操作</a>和<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">合并子基本操作</a>及基于这些操作的一些<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E7%A1%80%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">派生操作</a>的<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">操作数树</a>构造时不检查其中的非列表项是否都为<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号</a>或 <a href="Features/NPL.zh-CN.html#npla1-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F"><code>#ignore</code></a>（而延迟到匹配时检查）；匹配时不检查符号重复；若形式参数中的符号重复，则绑定的目标未指定。</p>
<p>　　此外，NPLA1 提供单独的递归绑定符号的机制，且明确支持<a href="Features/NPL.zh-CN.html#%E5%BC%BA%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">在操作数中同时递归绑定之前未被绑定的多个符号</a>。</p>
<p>　　要求隐藏环境稳定允许实现共享隐藏环境作为父环境而提供<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">标准环境</a>。</p>
<p><strong>注释</strong></p>
<p>　　[R<sup>n</sup>RK] 的 <code>make-kernel-standard-environment</code> 若通过共享基础环境作为隐藏的父环境实现，也具有这里的稳定性。</p>
<p>　　但是，[R<sup>n</sup>RK] 不提供<a href="Features/NPL.zh-CN.html#npla1-%E5%AF%B9%E8%B1%A1%E5%90%8C%E4%B8%80%E6%80%A7">同一性保证</a>，也没有通过对象的引用<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a><a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的操作，因此不需要支持<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">不可修改引用</a>即可保证值稳定性。</p>
<p>　　环境对象符合默认的等价比较规则以及绑定的对象可通过引用被修改和 [R<sup>n</sup>RK] 不同。</p>
<p>　　关于要求的环境稳定性，存在推论：稳定环境中的同名<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">被绑定实体</a>可证明排除通过对象的引用<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">使其改变的副作用（如被修改）</a>或总是具有<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>。</p>
<h4 id="环境生存期"><a class="header" href="#环境生存期">环境生存期</a></h4>
<p>　　对象语言的实现提供给<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>使用的<a href="Features/NPL.zh-CN.html#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">初始环境</a>的环境对象及其中的子对象满足：</p>
<ul>
<li>其创建<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序于</a>用户程序的对象的创建。</li>
<li>除非提供为不满足<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7">环境的稳定性</a>的环境中的被绑定对象，其销毁后序于用户程序的对象的销毁。</li>
</ul>
<p>　　程序引用环境中的名称时，应确保环境在生存期内。</p>
<p><strong>注释</strong></p>
<p>　　环境中不满足稳定性的被绑定对象可能被修改且具有外部可见的<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>。若这个对象是一个环境的唯一强引用，则对应的环境对象在替换为其它值时被销毁。</p>
<p>　　特别地，应注意使用函数时引入父环境的生存期。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">对象语言内存安全保证</a>。</p>
<h4 id="环境中的绑定"><a class="header" href="#环境中的绑定">环境中的绑定</a></h4>
<p>　　环境中的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">绑定</a>的抽象不依赖对象语言中表达的引用的概念，允许直接关联一个没有引用的值。</p>
<p>　　环境中的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">绑定对被绑定的对象具有所有权</a>。除在环境中绑定中间值的<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">不安全操作</a>，这种直接所有权是独占的。</p>
<p>　　绑定的<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">变量名</a>是<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>构成的<a href="Features/NPL.zh-CN.html#%CE%BB-%E5%AE%8C%E5%A4%87%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AF%B9%E5%BA%94%E8%AF%AD%E6%B3%95">名称表达式</a>，<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">解析</a>的结果总是<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>。</p>
<p><strong>注释</strong></p>
<p>　　环境中的绑定不依赖引用以及绑定所有权和 Kernel 的设计不同。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">一等引用</a>和<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>。</p>
<h4 id="重绑定"><a class="header" href="#重绑定">重绑定</a></h4>
<p>　　环境中允许变量以相同的名称被重新绑定，即<em>重绑定(rebinding)</em> 。</p>
<p><strong>注释</strong> 和 Scheme 类似。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>的<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8">引用</a>不因其引用的对象被重绑定操作替换值而被无效化。</p>
<p>　　重绑定替换被绑定对象的值，不改变对象的<a href="Features/NPL.zh-CN.html#npla1-%E5%AF%B9%E8%B1%A1%E5%90%8C%E4%B8%80%E6%80%A7">同一性</a>。若其中存在<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>，则子对象被销毁，任何子对象的引用值被<a href="Features/NPL.zh-CN.html#%E6%97%A0%E6%95%88%E5%8C%96">无效化</a>。</p>
<p>　　特别地，若继续访问已被<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值</a>指称的引用值引用的对象，则超出生存期访问而引起 <a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">NPLA 未定义行为</a>。</p>
<p>　　任意<a href="Features/NPL.zh-CN.html#%E9%9A%90%E8%97%8F%E7%8E%AF%E5%A2%83">隐藏环境</a> <tt>e</tt> 应满足以下绑定有效稳定性：通过引用值间接访问 <tt>e</tt> 中绑定的对象时绑定保持有效（蕴含不被移除或重绑定），保持被绑定对象的生存期和 <tt>e</tt> 对其<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权</a>。</p>
<p>　　这避免因为上述访问违反<a href="Features/NPL.zh-CN.html#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>而引起 NPLA 未定义行为。</p>
<p>　　关于无效化，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h4 id="被绑定对象的值和可观察行为"><a class="header" href="#被绑定对象的值和可观察行为">被绑定对象的值和可观察行为</a></h4>
<p>　　任意<a href="Features/NPL.zh-CN.html#%E9%9A%90%E8%97%8F%E7%8E%AF%E5%A2%83">隐藏环境</a>的 <tt>e</tt> 的任意<a href="Features/NPL.zh-CN.html#npla1-%E5%AF%B9%E8%B1%A1%E5%90%8C%E4%B8%80%E6%80%A7">同一</a>被绑定对象 <tt>o</tt> 应满足以下的<em>值稳定性(value stability)</em> ：若 <tt>o</tt> 上发生<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">使其改变的副作用（如被修改）</a>，则之后在以 <tt>e</tt> 或任意以 <tt>e</tt> 作为直接或间接父环境的环境中直接以<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>或 <tt>o</tt> 的引用值访问 <tt>o</tt> 时，<tt>o</tt> 的值和发生作用前的 <tt>o</tt> 的值在影响<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>的意义上等价。</p>
<p>　　若不满足值稳定性，访问副作用发生后的对象引起<a href="Features/NPL.zh-CN.html#npla1-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">扩展 NPLA 未定义行为</a>。</p>
<p>　　以下情形使对象<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">改变</a>的副作用不受值稳定性要求的约束：</p>
<ul>
<li>对象通过合并子调用的返回值或其中的<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子对象引用</a>指定（不论合并子是否是隐藏环境中的<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>）。</li>
<li>对象间接访问具有<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">内部可变性</a>的对象的<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">可变管理状态</a>。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　通过限制<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a><a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">不可修改</a>可以维护<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的值稳定性。</p>
<p>　　对象<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">间接访问具有内部可变性的对象的可变管理状态</a>的一类典型实例是一等环境中的绑定中的子对象（即便这个一等环境对象是隐藏环境中的子对象）。</p>
<h4 id="冻结"><a class="header" href="#冻结">冻结</a></h4>
<p>　　环境可进行<em>冻结(freeze)</em> 。<em>冻结的(frozen)</em> 环境中取得的绑定和引用值<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">不可修改</a>。</p>
<p>　　特定的环境<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>要求环境不在冻结状态以确保不变量，要求<a href="Features/NPL.zh-CN.html#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>。检查失败则<a href="Features/NPL.zh-CN.html#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">引起类型错误</a>。</p>
<p>　　冻结一个已被冻结的环境没有作用。</p>
<p><strong>注释</strong> 冻结环境是<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">幂等</a>操作。</p>
<p>　　NPLA1 <a href="Features/NPL.zh-CN.html#%E9%9A%90%E8%97%8F%E7%8E%AF%E5%A2%83">隐藏环境</a>是冻结的。</p>
<p>　　当前 NPLA1 对象语言不提供在已有环境撤销冻结或在冻结的环境中添加、移除绑定或<a href="Features/NPL.zh-CN.html#%E9%87%8D%E7%BB%91%E5%AE%9A">重绑定</a>的方法。</p>
<p>　　若程序中使用其它方法（附加初始化或提供本机实现操作）撤销冻结或在冻结的环境中添加、移除绑定或重绑定而使对象语言安全性保证失效，这种方法应由派生实现定义，否则程序<a href="Features/NPL.zh-CN.html#npla1-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">行为未定义</a>。</p>
<p>　　关于对象语言安全性保证，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　环境的冻结操作类似 [ECMAScript] 的对象的冻结操作。类似地，冻结环境不会冻结其中的变量绑定中可能存在的<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">环境子对象</a>。</p>
<h3 id="npla1-广义列表"><a class="header" href="#npla1-广义列表">NPLA1 广义列表</a></h3>
<p>　　NPLA1 的<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">广义列表</a>是<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>或者无环的<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">非真列表</a>，其<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">元素</a>不构成<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">环</a>。</p>
<p>　　列表的<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8">引用</a>构成其它对象时，也不构成<a href="Features/NPL.zh-CN.html#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">环</a>。</p>
<p><strong>原理</strong> 排除环使处理列表的操作不需要考虑一些复杂的<a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">自引用</a>情形。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>的<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">形式参数树</a>是可能是<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号</a>或真列表。</p>
<p><strong>注释</strong> 形式参数树可作为表达式直接在<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源程序</a>中表达。</p>
<p>　　通常意义的列表即<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>。</p>
<p>　　除非另行指定，NPLA1 列表类型指<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">真列表</a>。非真列表的类型是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">有序对</a>。</p>
<p><strong>原理</strong></p>
<p>　　和 Scheme 及 Kernel 不同，NPLA 支持的列表都是真列表。另见<a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">关于自引用数据结构和循环引用的分析</a>。</p>
<p>　　列表的这些特性确保基于列表的数据结构在对象语言逻辑上的简单性。也因此 NPLA1 对应的操作中，没有对环存在性的检查。</p>
<p>　　没有环的结构能保证所有权语义能按需嵌入(embed) 到列表中，即列表可保证表示为同构的具有对节点所有权的嵌套 <a href="Features/NPL.zh-CN.html#%E6%9C%89%E5%BA%8F%E5%AF%B9">cons 对</a>。</p>
<p>　　因为类似的理由，在语言特性中<a href="http://xahlee.info/UnixResource_dir/writ/lisp_problems.html">原生支持 cons 对被有的 Lisp 用户认为是传统 Lisp 设计的主要问题之一</a>。由于 cons 对只是一般的列表的实现细节，对 cons 对的依赖造成<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F">抽象泄漏</a>；为了支持接近一般列表的抽象，必须引入真列表。也因此 NPLA 避免直接依赖 cons 对的缺陷，尽管同时仍然提供<a href="Features/NPL.zh-CN.html#%E6%9C%89%E5%BA%8F%E5%AF%B9">有序对</a>且 NPLA 列表仍通过有序对定义，更一般情形可以避免对列表的依赖，如部分<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">库函数</a>可直接支持抽象列表。</p>
<h4 id="有序对的子对象和子对象引用"><a class="header" href="#有序对的子对象和子对象引用">有序对的子对象和子对象引用</a></h4>
<p>　　有序对的元素是有序对的<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>，有序对对作为元素的表示具有所有权。同一个有序对的元素节点之间没有所有权关系。</p>
<p>　　部分操作可能修改有序对的子对象。</p>
<p>　　除非另行指定，有序对的子对象被转移，使用<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">项的转移</a>。被转移的子对象在被转移后不在被转移的有序对中存在。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子有序对引用</a>可被<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>引入。</p>
<p>　　关于子对象被修改和转移，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　有序对的子对象是表示它的项的<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">子项和值数据成员</a>对应表示的对象。</p>
<p>　　对象被转移后通常其子对象不需要再被访问，此时保持子对象的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">同一性</a>和转移前的状态一一对应缺乏意义。作为<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">析构性转移</a>，使用项的转移可以复用已使用类型擦除或其它的间接存储方式持有的子对象，减小不必要的开销。</p>
<p>　　作为默认规则，明确要求项的转移，而不是未指定是否使用项的转移，以满足语言规则自身的<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>和<a href="Features/NPL.zh-CN.html#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测性</a>。这类似 [WG21 P0135R1] 引入强制复制消除(madatory copy elision) 对 [ISO C++] 的规则起到简化作用。不同的是，因为没有<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态类型</a>的限制，子对象的类型能在程序运行时改变，而不需要引入静态分析开销，这同时使实现也更简单。</p>
<p><strong>注释</strong></p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子有序对引用</a>和<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子列表引用</a>是<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子对象引用</a>。</p>
<p>　　当前有序对引用总是引用至少一个有序对的元素。</p>
<p>　　由绑定使用引用标记字符的<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">非递归绑定</a>的规则，绑定列表的子对象引用不直接共享操作数有序对对象，而共享元素是原容器元素的（<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">经折叠的</a>）引用值的有序对，是子有序对引用。</p>
<p>　　这类似宿主语言的容器对象一般不能转换为共享容器部分元素的 C++ 对象引用。</p>
<h3 id="npla1-合并子"><a class="header" href="#npla1-合并子">NPLA1 合并子</a></h3>
<p>　　除非另行指定（如<a href="Features/NPL.zh-CN.html#%E5%BC%BA%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">强递归绑定</a>），对象语言中的所有合并子都是<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">真合并子</a>。</p>
<p>　　NPLA1 对象语言不提供其它合并子的普遍操作。</p>
<p><strong>注释</strong> 但<a href="Features/NPL.zh-CN.html#npla1-%E4%BA%92%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">互操作</a>意义上的 NPLA1 API 可支持其它合并子。</p>
<p>　　合并子和操作数组合构成的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>是一个 NPLA1 对象，称为<em>函数合并对象(function combination object)</em> 。</p>
<p><strong>注释</strong> <a href="Features/NPL.zh-CN.html#npla1-%E8%A7%84%E8%8C%83%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值算法</a>可接受的函数合并对象是<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">有序对</a>。<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并表达式</a>作为函数合并对象是<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">列表</a>。</p>
<p>　　NPLA1 的合并子使用<em>包装数(wrapping count)</em> 存储可能需要求值操作数的次数。</p>
<p>　　在不出错时行为和不使用包装数而直接使用嵌套子对象实现的行为完全一致，但在到达实现支持的最大包装数时继续包装即<em>包装数溢出(wrapping count overflow)</em> ，行为可能不相同：</p>
<p>　　若某个操作使合并子超出上限，则符合<a href="Features/NPL.zh-CN.html#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF%E6%9D%A1%E4%BB%B6">非宿主资源耗尽的错误条件</a>。</p>
<p>　　实现支持的最大包装数应满足：若发生包装数溢出，则直接创建和包装数相同个数的合并子符合<a href="Features/NPL.zh-CN.html#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF%E6%9D%A1%E4%BB%B6">宿主资源耗尽的错误条件</a>。</p>
<p><strong>原理</strong></p>
<p>　　为<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E4%BF%AE%E6%94%B9%E6%80%A7">可修改性</a>，允许非真合并子。这可在互操作中表示类似合并子但在语言中不可见的非一等对象。</p>
<p>　　为维护语言规则的<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>，合并子默认是真合并子。</p>
<p>　　NPLA1 对象语言不提供其它合并子的普遍操作，这不保证完全满足类似 <a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">G1b</a> 的原则。</p>
<p>　　尽管<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%9E%8B">没有要求</a>，这种规约也更符合 G1b ；同时，这易于移植 Kernel 代码。</p>
<p><strong>注释</strong></p>
<p>　　Kernel 的合并子对应 NPL 的<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">真合并子</a>。</p>
<p>　　对最大包装数的要求需要实现支持包装数是能和宿主资源的空间相较规模的值，这保证使用包装数的实现的空间效率不弱于不使用包装数而直接分配合并子包装的实现。</p>
<p>　　这也表示通常<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>的操作不会发生包装数溢出：若包装操作的次数导致包装数溢出，则直接分配合并子的替代操作也应由于宿主资源耗尽而失败。</p>
<h3 id="npla1-数值"><a class="header" href="#npla1-数值">NPLA1 数值</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#%E9%99%84%E5%8A%A0%E5%8A%9F%E8%83%BD">数值支持</a>的实现兼容<a href="Features/NPL.zh-CN.html#npla-%E6%95%B0%E5%AD%A6%E5%8A%9F%E8%83%BD">NPLA 数学功能</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#npla1-%E6%95%B0%E5%80%BC%E5%AD%97%E9%9D%A2%E9%87%8F">NPLA1 数值字面量</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>是数值。</p>
<h2 id="函数的间接值使用约定"><a class="header" href="#函数的间接值使用约定">函数的间接值使用约定</a></h2>
<p>　　引用值作为间接值，首先符合作为实体的<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8">引用</a>的使用约定。</p>
<h3 id="间接值作为实际参数"><a class="header" href="#间接值作为实际参数">间接值作为实际参数</a></h3>
<p>　　除非另行指定，一般地，函数接受左值引用操作数，使用引用的对象的值和直接使用右值作用相同，但不会修改被左值引用的对象。</p>
<p>　　这等价隐含无副作用的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">左值到右值转换</a>，被视为蕴含左值到右值转换。</p>
<p><strong>注释</strong></p>
<p>　　另行指定的例子如<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91">函数参数转发</a>。</p>
<p>　　此处的左值引用和宿主语言中的（ <code>const</code> 非 <code>volatile</code> ）左值作用类似。</p>
<h3 id="间接值作为函数值"><a class="header" href="#间接值作为函数值">间接值作为函数值</a></h3>
<p>　　部分<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>总是非引用值。</p>
<p>　　这些操作对应的函数调用返回非引用值。</p>
<p>　　返回非引用值的行为应等价<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>。</p>
<p>　　其它操作可具有引用值结果，对应的函数调用可返回引用值。</p>
<p><strong>原理</strong></p>
<p>　　函数值非引用值可满足具体操作的语义要求（如非引用值的<a href="Features/NPL.zh-CN.html#%E5%88%9B%E5%BB%BA%E5%92%8C%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0">构造器</a>），减少误用的可能性，并帮助提供<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">内存安全保证</a>。</p>
<h3 id="保留引用值"><a class="header" href="#保留引用值">保留引用值</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E9%97%B4%E6%8E%A5%E5%80%BC">保留间接值</a>，包括<a href="Features/NPL.zh-CN.html#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%9D%A5%E6%BA%90">直接保留间接值和间接保留间接值</a>，适用<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>的情形，对应地称为保留引用值、直接保留引用值和间接保留引用值。</p>
<p>　　除非另行指定，被保留的引用值不被<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">折叠</a>。</p>
<p><strong>原理</strong></p>
<p>　　必要时要求引用折叠可避免引入非预期的引用的引用值。</p>
<p>　　被保留的引用值可能<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">逃逸</a>或不逃逸而通常不能直接证明具有<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">内存安全保证</a>。</p>
<h3 id="保留环境引用"><a class="header" href="#保留环境引用">保留环境引用</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E9%97%B4%E6%8E%A5%E5%80%BC">保留间接</a>值适用<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境引用</a>。</p>
<p><strong>注释</strong></p>
<p>　　和<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">保留引用值</a>的情形不同，因为只允许通过环境引用在对象语言中访问<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">环境对象</a>及其子对象，访问环境但不保留环境引用的操作<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">只可能在（不保证内存安全的）互操作中出现</a>。</p>
<h2 id="函数参数和函数值传递约定"><a class="header" href="#函数参数和函数值传递约定">函数参数和函数值传递约定</a></h2>
<p>　　函数可能<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0">接受引用值参数</a>和<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">返回引用值</a>，是对函数的形式参数或函数值的<a href="Features/NPL.zh-CN.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a>。</p>
<p>　　在复制初始化形式参数和<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>时，部分函数保证被初始化的值和<a href="Features/NPL.zh-CN.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初值符</a>的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E5%92%8C%E7%B1%BB%E5%9E%8B">值类别和可修改性</a>一致。这些初始化是<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%80%BC%E4%BC%A0%E9%80%92">转发</a>操作。</p>
<p><strong>注释</strong></p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%80%BC%E4%BC%A0%E9%80%92">函数参数和函数值传递</a>。</p>
<h3 id="传递非引用值参数"><a class="header" href="#传递非引用值参数">传递非引用值参数</a></h3>
<p>　　一些函数的参数进行<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">左值到右值转换</a>，实现参数的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值传递</a>。</p>
<p>　　这类似宿主语言中直接使用对象类型的形式参数。</p>
<h3 id="函数参数转发"><a class="header" href="#函数参数转发">函数参数转发</a></h3>
<p>　　一些求值为引用值的函数的部分实际参数被保留，而不进行<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">左值到右值转换</a>。</p>
<p>　　这些值以保留值类别不变的形式被直接作为操作数，用于调用其它合并子。这种参数被<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%80%BC%E4%BC%A0%E9%80%92">转发</a>。</p>
<p><strong>注释</strong></p>
<p>　　这些参数的转发类似<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>支持的<a href="Features/NPL.zh-CN.html#%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91">参数转发</a>。</p>
<p>　　参数转发的实现可判断<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">值类别</a>后分别对<a href="Features/NPL.zh-CN.html#%E4%BC%A0%E9%80%92%E9%9D%9E%E5%BC%95%E7%94%A8%E5%80%BC%E5%8F%82%E6%95%B0">传递非引用值</a>或直接传递引用值提供实现，或直接使用绑定构造。前者支持本机实现。</p>
<h3 id="返回非引用值"><a class="header" href="#返回非引用值">返回非引用值</a></h3>
<p>　　返回非引用值和参数的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值传递</a>类似：若初始化函数值的初值符是引用，复制或转移被引用对象的值而不是引用值。</p>
<p><strong>注释</strong></p>
<p>　　这类似宿主语言中返回 <code>auto</code> 类型。</p>
<h3 id="函数值转发"><a class="header" href="#函数值转发">函数值转发</a></h3>
<p>　　一些其它保留引用值的操作中，引用值来自参数，且难以通过自身的逻辑单独决定可否安全地直接返回引用值。</p>
<p>　　此时，在返回之前根据特定参数是否为引用值，可选地转换<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>以确定是否保留引用值，即进行转发。</p>
<p>　　特定的显式转发操作转发<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>使临时对象被转移，以转发的值作为结果，可不同于使用<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>：</p>
<ul>
<li>同返回值转换，转发转移右值，复制左值。</li>
<li>但当转发临时对象可确定唯一使用时，也转移临时对象。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　函数值转发使某些操作在默认情况下满足间接值生存期规则而保持内存安全，符合<a href="Features/NPL.zh-CN.html#%E9%80%82%E7%94%A8%E6%80%A7">适用性原则</a>。</p>
<p><strong>注释</strong></p>
<p>　　确定是否保留引用值的机制类似 [ISO C++14] 中从没有括号的 <code>id-expression</code> 上推断返回 <code>decltype(auto)</code> 类型是否为引用类型。</p>
<p>　　函数值转发的实现可通过判断是否需要转发引用而<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">按需决定返回引用值或非引用值</a>，或使用标准库的相关函数。前者支持本机实现。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%AF%E8%BD%AC%E7%A7%BB%E6%9D%A1%E4%BB%B6">对象的可转移条件</a>。</p>
<p>　　显式转发操作把右值、消亡值和带有<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">临时对象属性</a>的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B">左值引用</a>视为被转发的目标。</p>
<p>　　转发列表对象的<a href="Features/NPL.zh-CN.html#%E6%9C%89%E5%BA%8F%E5%AF%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子对象</a>可能转移这个对象。</p>
<h3 id="创建和访问对象的函数"><a class="header" href="#创建和访问对象的函数">创建和访问对象的函数</a></h3>
<p>　　<em>构造器(constructor)</em> 是用于创建对象的函数。</p>
<p>　　除非显式指定创建的对象具有引用值类型，构造器是<em>典型的(typical)</em> ，<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E9%9D%9E%E5%BC%95%E7%94%A8%E5%80%BC">返回非引用值</a>。</p>
<p>　　部分操作涉及对其它对象具有所有权的对象。</p>
<p>　　一部分对象的构造器创建的对象完全通过其它对象的引用或<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">对象的值</a>作为构造器的参数而决定，且创建的对象对这些参数具有所有权，这样的对象称为容器(container) 。</p>
<p>　　容器构造器的参数作为容器的<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>，是容器的<em>元素(element)</em> 。</p>
<p>　　以容器对象或其引用作为参数，取得容器元素对象或其引用的函数是容器元素<em>访问器(accessor)</em> 。</p>
<p>　　标准库提供一些属于构造器和访问器的操作。除非另行指定，标准库的访问器符合<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E7%BA%A6%E5%AE%9A">子对象访问约定</a>。</p>
<p><strong>注释</strong></p>
<p>　　容器的元素扩展了<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">有序对和列表的元素</a>的概念。</p>
<p>　　一些不是容器的对象（如<a href="Features/NPL.zh-CN.html#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">真合并子</a>）可通过非容器形式的构造器创建。</p>
<h3 id="转发参数或返回值的实现"><a class="header" href="#转发参数或返回值的实现">转发参数或返回值的实现</a></h3>
<p>　　没有约定需要转发的情形不使用显式的转发。</p>
<p><strong>注释</strong></p>
<p>　　可<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91">转发参数</a>或<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%80%BC%E8%BD%AC%E5%8F%91">转发返回值</a>的函数可包含以下实现方式：</p>
<ul>
<li>使用特定的操作，以需被转发的表达式作为其操作数。</li>
<li>（仅对参数转发）使用<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">标记字符</a> <code>%</code> 的<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">参数绑定</a>的变量。</li>
</ul>
<p>　　上述特定的操作可在被求值的表达式中构造显式的转发。</p>
<h1 id="npla1-参照实现环境"><a class="header" href="#npla1-参照实现环境">NPLA1 参照实现环境</a></h1>
<p>　　NPLA1 提供参照实现环境。其实现可在内部使用 NPLA1 <a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">库特性</a>，提供给 NPLA1 <a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>。</p>
<p>　　NPLA1 参照实现环境和用户程序遵循部分不同的要求和约定。</p>
<p>　　本章中的其它约定适用 NPLA1 参照实现环境，且可选地被用户程序使用。</p>
<h2 id="npla1-初始求值环境"><a class="header" href="#npla1-初始求值环境">NPLA1 初始求值环境</a></h2>
<p>　　NPLA1 以<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">环境对象</a>中的绑定作为公开的接口提供库特性，以进一步提供<em>初始环境(initial environment)</em> 作为<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">求值环境</a>，即用户程序初始的<a href="Features/NPL.zh-CN.html#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>。</p>
<p>　　这些环境包含两类：</p>
<ul>
<li><em>根环境(root environment)</em> ：提供<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">核心语言特性</a>的<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">非一等环境</a>。
<ul>
<li>根环境应能和<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">一等环境</a>在<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>中的作用一致：作为<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">父环境</a>。</li>
</ul>
</li>
<li><em>库环境(library environment)</em> ：作为库特性的一等环境。
<ul>
<li><strong>注释</strong> 通常是其它环境的<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>。</li>
</ul>
</li>
</ul>
<p>　　这些环境应按语言规范要求的方式<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">包含和展示</a>所有<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">可见的绑定</a>。</p>
<p>　　除非另行指定，这些环境对象初始化后在用户程序访问前被<a href="Features/NPL.zh-CN.html#%E5%86%BB%E7%BB%93">冻结</a>。</p>
<p>　　<em>基础环境(ground environment)</em> 是 NPLA1 程序可假定存在的一个根环境。</p>
<p>　　基础环境是<a href="Features/NPL.zh-CN.html#%E9%9A%90%E8%97%8F%E7%8E%AF%E5%A2%83">隐藏环境</a>。</p>
<p>　　除非另行指定：</p>
<ul>
<li>基础环境不展示名称语言规范要求的除<a href="Features/NPL.zh-CN.html#%E6%A0%87%E8%AF%86%E7%AC%A6%E9%99%84%E5%8A%A0%E8%A7%84%E5%88%99">保留名称</a>外的绑定。</li>
<li>根环境是否展示基础环境中的绑定未指定。</li>
</ul>
<p>　　初始环境是一个包含基础环境作为直接或间接父环境的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">空环境</a>。</p>
<p>　　实现可提供基础环境以外的根环境，允许派生实现定义在用户程序中<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改其中的绑定</a>的机制（而不一定是隐藏环境），直至被实现初始化参考环境的特定用户程序封装或冻结而避免进一步修改。</p>
<p>　　如有必要，用户程序可通过派生实现定义的方式引入其它根环境。</p>
<p><strong>原理</strong></p>
<p>　　这些环境对象设计为在参照实现环境提供，因为：</p>
<ul>
<li>不都保证能在用户程序中可移植地创建，而有必要在参照实现环境中提供。</li>
<li>提供的库特性在可移植程序中可能经常出现，而适合在参照实现环境中提供。</li>
</ul>
<p>　　根环境在功能上不需要展示基础环境中的绑定，这允许简化初始化。但允许展示基础环境中的绑定也使<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%BA%A6%E5%AE%9A">派生实现</a>能被简化。</p>
<p><strong>注释</strong></p>
<p>　　提供基础环境和 Kernel 类似。</p>
<p>　　<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>可能直接访问基础环境，这些操作应避免破坏实现和程序的假定。</p>
<p>　　特性设计注记：</p>
<ul>
<li>为避免依赖逻辑上复杂的形式，一些特性当前在当前设计中排除。
<ul>
<li>例如，依赖一阶算术的操作、其硬件加速形式的 ISA 表示的整数操作及依赖这些操作实现的<a href="https://en.wikipedia.org/wiki/Numerical_tower"><em>数值塔(numerical tower)</em> (en-US)</a> 被整体忽略。</li>
</ul>
</li>
<li>上述忽略的特性可由派生实现补充，在派生根环境后按需进行 AOT(ahead-of-time) 优化（如 Kernel 的 <code>$let-safe!</code> 中包含的内容，其中引用基础环境的符号不再可变），然后组成类似基础环境。</li>
</ul>
<p>　　通过派生实现定义的方式一般依赖<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>。</p>
<h3 id="npla1-实现环境初始化"><a class="header" href="#npla1-实现环境初始化">NPLA1 实现环境初始化</a></h3>
<p>　　<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">实现环境</a>的初始化完成初始环境的准备，包括蕴含所有初始环境依赖的资源<em>基础上下文(ground context)</em> 的初始化。</p>
<p>　　初始化基础上下文蕴含的根环境是<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值</a>默认使用的求值环境，初始化后可直接封装为基础环境使用。</p>
<p>　　派生实现可在以上初始化结束之后，在运行用户程序之前完成其它初始化。</p>
<p>　　初始化成功后，用户程序被运行；否则，程序非正常终止。</p>
<p>　　以上初始化同时可能提供<a href="Features/NPL.zh-CN.html#npla1-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F">扩展字面量</a>支持。</p>
<p><strong>注释</strong></p>
<p>　　对初始化失败而终止的程序，建议但不要求实现给出诊断。</p>
<h3 id="导入符号"><a class="header" href="#导入符号">导入符号</a></h3>
<p>　　在环境中定义另一个环境中的同名变量，使被定义的变量是后者的引用值或值的副本，则称指定此<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">变量名</a>的<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>在后者被<em>导入(import)</em> 前者。</p>
<p><strong>注释</strong> 用户程序可导入环境中的符号值使用库中的绑定。</p>
<h2 id="模块-1"><a class="header" href="#模块-1">模块</a></h2>
<p>　　NPLA1 以绑定提供的语言特性被分组归类为<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9D%97%E5%8C%96">模块</a>。</p>
<p><strong>注释</strong> 同 [R<sup>n</sup>RK] 。</p>
<p>　　模块的<em>源(source)</em> 提供特性的实现，可以是本机实现或者 NPLA1 程序。对应的模块分别是本机模块和<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源程序</a>模块。</p>
<p>　　模块的源可以是实现内建的，或位于实现环境提供的外部资源（如文件系统）。</p>
<p>　　因为模块以绑定的集合的形式提供，需被包含在可访问的环境，或包含环境作为<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的其它对象中。</p>
<p>　　以<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">环境对象</a>作为模块的源的模块化方式称为<em>环境作为模块(environment as module)</em> 。[R<sup>n</sup>RK] 的 <code>get-module</code> 的结果和<a href="Features/NPL.zh-CN.html#npla1-%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E6%89%A9%E5%B1%95%E7%8E%AF%E5%A2%83">参照实现扩展环境</a>的模块是这种方式的例子。</p>
<p>　　模块可能包含<em>子模块(submodule)</em> 提供其特性子集。以环境作为模块时，<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">环境子对象</a>可作为子模块。</p>
<p>　　从模块的源得到提供一个模块的所有绑定集合的环境对象的过程称为模块的<em>加载(loading)</em> 。</p>
<p>　　模块加载可能失败。失败的模块加载<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">根环境</a>加载的失败不被直接依赖这些环境的 NPLA1 用户程序处理（而视为实现初始化的运行时错误）。</p>
<p>　　一般地，模块和加载模块得到的环境对象不保证具有直接的对应关系：一个模块的绑定可以由一个或多个环境提供，一个已被加载的环境可能提供零个或多个程序可见的模块。但除非另行指定，一个模块的绑定不在超过一个的不相交的环境（之间没有直接或间接父环境关系）中提供。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">库</a>的实现可作为<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言实现</a>。<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">库特性</a>可以被模块化，在其中通过<a href="Features/NPL.zh-CN.html#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">库环境</a>一并被提供。</p>
<p>　　程序可通过加载外部模块来源取得模块。除非另行指定，这种模块以一个一等环境对象（可包含作为环境的直接或间接子对象）中的绑定提供。</p>
<h3 id="模块的初始化和加载"><a class="header" href="#模块的初始化和加载">模块的初始化和加载</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#npla1-%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96">实现环境初始化</a>时可提供模块，包含其中必要的使模块中特性可用的初始化。</p>
<p>　　实现环境初始化时，可访问不作为公开接口提供的模块的源，从源<em>加载(load)</em> 这些模块。</p>
<p><strong>注释</strong> 派生实现可同时以标准库以外形式提供这些源为公开接口，用户程序也可显式地加载这些源对应的模块。</p>
<p>　　待加载的源的位置可通过称为<em>加载路径(load path)</em> 的字符串指定。加载路径可精确指定确切的源，或提供使实现<em>搜索(search)</em> 特定的源的起点。具体可接受的加载路径格式以及加载路径映射到确切的源的规则由提供特性的实现定义。</p>
<p><strong>原理</strong> 有的语言实现直接使用加载路径作为搜索路径，如 <a href="https://www.gnu.org/software/guile/manual/html_node/Installing-Site-Packages.html">GNU Guile</a> 。有的语言实现基于不同的原语，称为<em>导入路径(import path)</em> ，如 <a href="https://docs.python.org/3/reference/import.html">Python</a> 。</p>
<p>　　除非另行指定：</p>
<ul>
<li>若这些源可能引起引入非公开的接口的副作用，则对应的模块不应被用户程序直接加载。</li>
<li>假定加载这些模块时，<a href="Features/NPL.zh-CN.html#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>是和<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">标准环境</a>或与其等价的其它环境。
　　* <strong>注释</strong> 关于标准环境，参见 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>make-standard-environment</code></a> 。
<ul>
<li>其中，等价指使用其它环境不引入程序<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>差异。</li>
<li><strong>注释</strong> 等价的环境的例子包括以标准环境为父环境的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">空环境</a>，以及这样的空环境<a href="Features/NPL.zh-CN.html#%E5%AF%BC%E5%85%A5%E7%AC%A6%E5%8F%B7">导入符号</a>的得到的结果。</li>
<li><strong>注释</strong> 若模块的加载不访问加载时初始的当前环境（通常仅在本机模块上适用），加载模块使用的环境可不影响可观察行为而不影响假定（即便和标准环境不等价）。</li>
</ul>
</li>
</ul>
<p>　　违反以上要求或假定的程序<a href="Features/NPL.zh-CN.html#npla1-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">行为未定义</a>。</p>
<p><strong>原理</strong></p>
<p>　　以源程序模块实现时，一般不要求检查<a href="Features/NPL.zh-CN.html#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">初始环境</a>。这能有效减少实现的复杂性。</p>
<p>　　因为标准环境不提供用户程序检查是否和其中定义的实体一致的直接的方法，通过替代的检查可能排除符合假定的初始环境。</p>
<p><strong>注释</strong></p>
<p>　　这里的初始化可包含派生实现定义的其它初始化。</p>
<p>　　虽然 NPLA1 标准库不作为接口保证提供这些源，这里的假定和 [ISO C++] <a href="https://eel.is/c++draft/using.headers">[using.headers]</a> 对引入标准库头的程序位置的限制类似：语言实现能有效地假定源程序中引入标准库头的上下文，因此标准库中的名称具有预期的含义。</p>
<h3 id="模块稳定性"><a class="header" href="#模块稳定性">模块稳定性</a></h3>
<p>　　提供模块绑定的环境依赖已知来源的绑定而确保<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7">稳定</a>。</p>
<p>　　除非另行指定，模块中的特性依赖提供模块绑定的环境的生存期。</p>
<p>　　除非另行指定，标准库实现应确保其中的模块在程序的生存期中可用。</p>
<p><strong>原理</strong></p>
<p>　　特性依赖性允许实现操作的模块中绑定的<a href="Features/NPL.zh-CN.html#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>可具有静态环境是提供模块绑定的环境的<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的合并子的实现。</p>
<p><strong>注释</strong></p>
<p>　　稳定要求同 [R<sup>n</sup>RK] 的 <code>get-module</code> 的约定。但因为<a href="Features/NPL.zh-CN.html#%E8%A2%AB%E7%BB%91%E5%AE%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%80%BC%E5%92%8C%E5%8F%AF%E8%A7%82%E5%AF%9F%E8%A1%8C%E4%B8%BA">值稳定性</a> ，<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7">和 Kernel 不同</a>，NPLA1 的稳定绑定<a href="Features/NPL.zh-CN.html#%E8%A2%AB%E7%BB%91%E5%AE%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%80%BC%E5%92%8C%E5%8F%AF%E8%A7%82%E5%AF%9F%E8%A1%8C%E4%B8%BA">一般不可修改</a>。</p>
<p>　　对标准库模块，稳定性要求一般表示其中的特性不能依赖用户程序运行时的非特定的<a href="Features/NPL.zh-CN.html#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>，而可依赖从<a href="Features/NPL.zh-CN.html#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">基础环境</a>及从基础环境派生的<a href="Features/NPL.zh-CN.html#%E6%96%B0%E7%8E%AF%E5%A2%83">新环境</a>。</p>
<p>　　生存期可用的规则一般要求标准库实现在初始化后保存<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境强引用</a>。</p>
<h2 id="库接口约定"><a class="header" href="#库接口约定">库接口约定</a></h2>
<p>　　<a href="Features/NPL.zh-CN.html#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">基础环境</a>的特性在<a href="Features/NPL.zh-CN.html#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">根环境</a>中直接绑定，统称根环境特性。</p>
<p>　　关于特性的约束作用于接口描述。不改变<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>时，实现可使用不同的未指定的根环境提供绑定。</p>
<p>　　描述模块接口的小节可以指定适用于该小节的模块约定。此时，描述的边界应能和其余的<a href="Features/NPL.zh-CN.html#%E5%BA%93%E6%8E%A5%E5%8F%A3%E5%AE%9E%E4%BD%93">实体</a>区分。</p>
<p>　　接口可能提供关于宿主语言<a href="Features/NPL.zh-CN.html#npla1-%E4%BA%92%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">互操作的约定</a>，作为对提供这些支持的实现的要求。</p>
<p><strong>注释</strong></p>
<p>　　具体特性参见 <a href="Features/NPL.zh-CN.html#npla1-%E6%A0%B9%E7%8E%AF%E5%A2%83%E7%89%B9%E6%80%A7">NPLA1 根环境特性</a>。</p>
<p>　　具体根环境的存在性未指定。在同一个环境中可见的不同变量可能来自不同的根环境。</p>
<p>　　接口描述的顺序同 [R<sup>n</sup>RK] §4 的原理，允许接口仅依赖先前出现的接口派生实现。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，库主要提供<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB">一元谓词</a>，也不需要为 <code>&lt;body&gt;</code> 隐含 <code>$sequence</code> 支持重新定义 <code>$vau</code> 等操作，不需要拆分 Kernel 的核心库特性到 [R<sup>n</sup>RK] §5 和 §6 。</p>
<h3 id="库接口实体"><a class="header" href="#库接口实体">库接口实体</a></h3>
<p>　　按实体区分，NPLA1 的库特性有两类：<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">对象</a>和<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作</a>。</p>
<p>　　对象语言中可实现的操作以<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数</a>的形式提供，可以是<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>函数或由现有操作派生的<a href="Features/NPL.zh-CN.html#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>。</p>
<p>　　除此之外，派生实现可指定提供对象或操作对应的<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E5%B8%B8%E8%A7%84%E5%87%BD%E6%95%B0">非常规函数</a>。</p>
<p>　　操作的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">结果</a>是对应的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>在<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%9D%A1%E4%BB%B6">正常控制</a>下取得的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>，即<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>；操作的作用即<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">函数调用的作用</a>。</p>
<p>　　根据操作的功能描述，对应的函数可能具有<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%9D%A1%E4%BB%B6">非正常的控制条件</a>。此时，函数调用不取得函数值，操作不具有结果。</p>
<p><strong>注释</strong> 非正常退出时，函数调用的求值结果可以是<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">错误对象</a>或派生实现定义的其它表示求值结果的实体。</p>
<p>　　除非另行指定，函数调用时具有的<a href="Features/NPL.zh-CN.html#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF%E6%9D%A1%E4%BB%B6">错误条件</a>是非正常的控制条件；其中，以<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%82%E5%B8%B8">异常</a>实现错误条件的情形具有<a href="Features/NPL.zh-CN.html#%E5%BC%82%E5%B8%B8">异常条件</a>。</p>
<p>　　特定的操作约定对应的函数是<a href="Features/NPL.zh-CN.html#%E7%BB%88%E6%AD%A2%E4%BF%9D%E8%AF%81">终止函数</a>或<a href="Features/NPL.zh-CN.html#%E7%BB%88%E6%AD%A2%E4%BF%9D%E8%AF%81">全函数</a>；这不适用于满足错误条件的情形。</p>
<p>　　特定的操作约定对应的函数<a href="Features/NPL.zh-CN.html#%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%BA%A6%E5%AE%9A">作为算法过程满足计算复杂度约定</a>。</p>
<p><strong>注释</strong> 排除错误条件，指定复杂度的函数是终止函数。</p>
<p>　　本章其余各节适用 NPLA1 对象语言中的这些操作。</p>
<p>　　操作中的大部分具有特定的名称，满足<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E7%BA%A6%E5%AE%9A">函数名称约定</a>。</p>
<p>　　其它操作不具有特定名称，可由上述操作间接地提供，如蕴含在某些操作涉及的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>中。</p>
<p><strong>注释</strong></p>
<p>　　在对象语言中不能直接表达的操作不能作为库特性，这些操作不对应库接口实体，其结果和作用仍照<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">更一般的规则</a>处理。</p>
<p>　　渐进复杂度常以 <a href="https://zh.wikipedia.org/zh-cn/%E5%A4%A7O%E7%AC%A6%E5%8F%B7"><tt>O</tt> 记号</a>指定上界。</p>
<p>　　若函数调用总是取得值，指定复杂度的函数同时是全函数。</p>
<h3 id="库特性实现分类"><a class="header" href="#库特性实现分类">库特性实现分类</a></h3>
<p>　　库特性分为<em>基本的(primitive)</em> 和<em>派生的(derived)</em> 。</p>
<p><strong>原理</strong></p>
<p>　　前者在设计上不分解为更小的其它特性的组合，通常需要本机实现；后者可由可移植的 NPLA1 源代码实现。</p>
<p><strong>注释</strong></p>
<p>　　区分基本和派生的特性在设计上类似 [R<sup>n</sup>RK] 中的基本和库特性。</p>
<p>　　注意和 [R<sup>n</sup>RK] 的库特性不同（而更接近宿主语言），NPLA1 的库特性是以 NPLA1 程序使用的接口而非实现的角度定义的，不总是使用对象语言实现，外延更广。</p>
<h3 id="标准库"><a class="header" href="#标准库">标准库</a></h3>
<p>　　本文档中要求的通过<a href="Features/NPL.zh-CN.html#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">基础环境</a>直接或间接提供的<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">库</a>总称<em>标准库(standard library)</em> 。</p>
<p>　　标准库的接口随语言规范在本章和<a href="Features/NPL.zh-CN.html#npla1-%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E6%89%A9%E5%B1%95%E7%8E%AF%E5%A2%83">参照实现扩展环境</a>约定。</p>
<p>　　<em>核心库(core library)</em> 是提供直接绑定在基础环境中的、保证可派生实现的接口的标准库模块。</p>
<p>　　在参照实现环境中的不同标准库模块的绑定都可在基础环境访问。</p>
<p>　　在参照实现扩展环境中的标准库模块以其它环境（通常作为基础环境的子对象提供）中的绑定和基础环境隔离。</p>
<p>　　派生实现可以库的形式提供语言扩展或其它功能特性，扩充标准库。</p>
<p><strong>注释</strong></p>
<p>　　因为<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">库的定义</a>和 [R<sup>n</sup>RK] 指定的不同，类似 [R<sup>n</sup>RK] §4 约定的基本特性，属于 NPLA1 <a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">库特性</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">基本派生特性</a>可能从<a href="Features/NPL.zh-CN.html#%E6%A0%B8%E5%BF%83%E5%BA%93">核心库</a>中迁移。因为绑定的来源不变，使用其中的接口程序仍然可能保持兼容。</p>
<h3 id="扩展库"><a class="header" href="#扩展库">扩展库</a></h3>
<p>　　基础环境也可提供的附带的其它接口，和标准库使用相同的约束。</p>
<p>　　一些操作的描述使用等价的表达式求值指定。除非另行指定，这些表达式中：</p>
<ul>
<li>若<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>和先前出现的函数同名，则指称对应的操作。</li>
<li>默认使用基础环境作为求值环境。</li>
</ul>
<h2 id="常规函数约定"><a class="header" href="#常规函数约定">常规函数约定</a></h2>
<p>　　本节提供<a href="Features/NPL.zh-CN.html#%E5%BA%93%E6%8E%A5%E5%8F%A3%E5%AE%9E%E4%BD%93">作为库特性的函数</a>的默认规则以简化库特性的描述。</p>
<p><strong>注释</strong> 库的一般派生实现和用户程序的实现也建议参照本节约定。</p>
<p>　　除非另行指定：</p>
<ul>
<li>操作以指定名称的变量的形式提供，求值为可参与<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>的一等实体（但函数合并不一定保证是<a href="Features/NPL.zh-CN.html#%E7%BF%BB%E8%AF%91%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%A7%84%E5%88%99">合式的</a>可求值的表达式）。</li>
<li>函数作为表达式，求值为<a href="Features/NPL.zh-CN.html#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>，其函数合并的求值蕴含<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>。</li>
<li>本文档约定的函数在其调用不依赖用户程序提供的非终止函数时，总是<a href="Features/NPL.zh-CN.html#%E7%BB%88%E6%AD%A2%E4%BF%9D%E8%AF%81">终止函数</a>。
<ul>
<li>若满足上述条件的函数不具有<a href="Features/NPL.zh-CN.html#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF%E6%9D%A1%E4%BB%B6">错误条件</a>，忽略因实现环境引发的错误（如<a href="Features/NPL.zh-CN.html#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF%E6%9D%A1%E4%BB%B6">宿主资源耗尽</a>），视为（对象语言中的）<a href="Features/NPL.zh-CN.html#%E7%BB%88%E6%AD%A2%E4%BF%9D%E8%AF%81">全函数</a>。</li>
</ul>
</li>
<li>本文档约定的函数蕴含以下情形时，调用非<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>：
<ul>
<li><a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起</a>操作或其它语言规则指定的<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">错误</a>。</li>
<li>引起<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">对象的修改和改变</a>。</li>
</ul>
</li>
<li>在指定对应的函数调用是纯求值的操作上，排除满足引起非纯求值的条件的作用的情形外的其余求值，仍应是纯求值。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　一些操作因不保证排除<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a> ，对应的调用非纯求值。</p>
<p>　　但通过补充约定，特定的作用可能视为<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定行为</a>，且不被程序的其它<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">行为</a>依赖（如<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">可变管理状态</a>的改变），仍可假定其求值是视为纯求值。</p>
<p><strong>注释</strong></p>
<p>　　无条件遍历访问<a href="Features/NPL.zh-CN.html#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用子对象</a>的程序具有 <a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">NPLA 未定义行为</a>，在讨论终止函数时已被排除。</p>
<p>　　对象的修改和改变可包括<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">转移</a>参数。</p>
<h3 id="函数值约定"><a class="header" href="#函数值约定">函数值约定</a></h3>
<p>　　除非另行指定：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>不是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>，以便通过保证满足<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>生存期规则维护<a href="Features/NPL.zh-CN.html#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>。</li>
<li>函数不在函数值中<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">保留引用值</a>，即<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">函数值经过返回值转换</a>。
<ul>
<li><strong>注释</strong> 保留引用值时，函数值仍可能是非引用值。</li>
</ul>
</li>
<li>若函数值保留引用值，引用值被<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">折叠</a>。</li>
</ul>
<h3 id="实际参数约定"><a class="header" href="#实际参数约定">实际参数约定</a></h3>
<p>　　除非另行指定：</p>
<ul>
<li>函数的实际参数的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">传递</a>不具有影响<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>。
<ul>
<li><strong>注释</strong> 这一般要求避免复制宿主语言中复制时具有副作用的对象。</li>
</ul>
</li>
<li>函数的实际参数若被求值，<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0">蕴含左值到右值转换</a>。</li>
</ul>
<h3 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h3>
<p>　　除非另行指定：</p>
<ul>
<li>若函数合并指定的操作的<a href="Features/NPL.zh-CN.html#%E6%8E%A5%E5%8F%A3%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">约束</a>或要求<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF%E6%A3%80%E6%9F%A5">检查</a>的条件不被满足，<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">引起错误</a>。</li>
<li>引起错误时<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%82%E5%B8%B8">抛出异常</a>。</li>
</ul>
<p>　　求值时引起的错误使求值中断，<a href="Features/NPL.zh-CN.html#%E4%BD%9C%E7%94%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99">可引起副作用</a>，这样的副作用总是<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">后序</a>于已被求值的表达式中引起的副作用。</p>
<p>　　被错误处理和检查的函数不<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>参数或者函数调用外创建的对象。</p>
<h3 id="非常规函数"><a class="header" href="#非常规函数">非常规函数</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">续延</a>是默认不符合<a href="Features/NPL.zh-CN.html#%E5%B8%B8%E8%A7%84%E5%87%BD%E6%95%B0%E7%BA%A6%E5%AE%9A">常规函数约定</a>的例外。</p>
<p>　　非常规函数归类为对象而非<a href="Features/NPL.zh-CN.html#%E5%BA%93%E6%8E%A5%E5%8F%A3%E5%AE%9E%E4%BD%93">操作</a>，但调用时<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">错误处理</a>同常规函数。</p>
<p><strong>注释</strong></p>
<p>　　类似 [R<sup>n</sup>RK] 而和 [R<sup>n</sup>RS] 不同，作为一等对象的续延和续延的实际参数是否求值无关，因此不是合并子，且默认<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值算法</a>不支持续延作为函数合并被求值；但续延可通过特定的操作转换为应用子。</p>
<h2 id="函数名称约定"><a class="header" href="#函数名称约定">函数名称约定</a></h2>
<p>　　除非另行指定，本文档以指定名称的函数表示具有名称的操作时，其命名由本节的规则约定。</p>
<p>　　<em>函数名(function name)</em> 即函数的名称。</p>
<p><strong>注释</strong> 除非派生实现另行指定，<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">函数名是变量名</a>。</p>
<p>　　为提供库的描述，本节同时约定这些函数名关联的函数具有的性质。</p>
<h3 id="函数名称前缀"><a class="header" href="#函数名称前缀">函数名称前缀</a></h3>
<p>　　确定为求值为操作子的函数名以 <code>$</code> 作为命名的前缀。</p>
<p><strong>原理</strong></p>
<p>　　同 [R<sup>n</sup>RK] ，操作子一般应在视觉上被强调而避免误用。<code>$</code> 来自 <strong>S</strong>pecial form 。</p>
<h3 id="函数名称后缀"><a class="header" href="#函数名称后缀">函数名称后缀</a></h3>
<p>　　函数名的最后的字符表示函数预期满足特定的约束或具有特定的目的。</p>
<p>　　以<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">引用标记字符</a>结尾的表示涉及引用的操作，参见<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D%E5%90%8E%E7%BC%80">以下</a>约定。</p>
<h4 id="谓词名称后缀"><a class="header" href="#谓词名称后缀">谓词名称后缀</a></h4>
<p>　　NPLA1 中的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">谓词</a>是 <a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;predicate&gt;</code></a>，即返回类型为 <a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;boolean&gt;</code></a> 的函数。</p>
<p>　　谓词的名称使用 <code>?</code> 结尾。</p>
<p><strong>注释</strong> 这类似 [R<sup>n</sup>RS] 和 [R<sup>n</sup>RK] 。</p>
<p>　　除非另行指定，以下引入的对象语言中的谓词对应的函数调用的求值是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>。</p>
<p>　　以下是谓词的典型实例：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E8%B0%93%E8%AF%8D">类型谓词</a>：接受一个 <a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;object&gt;</code></a> 参数，判断参数是特定的类型的对象。
<ul>
<li>调用这些类型谓词不引起错误。</li>
<li>仅当参数指定的对象具有对应类型时结果是 <code>#t</code> 。</li>
<li>除非另行指定，这些类型谓词忽略值类别的差异。</li>
</ul>
</li>
<li><a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">等价谓词</a>：接受两个参数，判断参数是否属于同一个等价类。</li>
</ul>
<p>　　因为 <code>&lt;boolean&gt;</code> 是 <a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;test&gt;</code></a>的<a href="Features/NPL.zh-CN.html#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">子类型</a>，按照返回值为 <code>&lt;test&gt;</code> 的函数可在不严格要求 <code>&lt;boolean&gt;</code> 的上下文中起类似的作用，视为<em>广义谓词(general predicate)</em> 。</p>
<p>　　谓词是广义谓词的子类型。</p>
<p><strong>注释</strong></p>
<p>　　大多数上下文接受 <code>&lt;test&gt;</code> 而不严格要求 <code>&lt;boolean&gt;</code> 。这<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">和 [R<sup>n</sup>RK] 不同</a>。</p>
<p>　　大多数类型谓词判断的类型一般同<a href="Features/NPL.zh-CN.html#%E6%8E%A5%E5%8F%A3%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">文法约定</a>，而无关<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E5%92%8C%E7%B1%BB%E5%9E%8B">值类别</a>。</p>
<p>　　以具名的函数提供的类型谓词，其函数名称通常和<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E5%85%83%E7%B4%A0%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">文法指定的类型</a>对应。</p>
<p>　　引起错误可具有副作用，其求值不保证是纯求值。</p>
<p>　　广义谓词不使用后缀 <code>?</code> 。另见 [R<sup>n</sup>RK] §6.1.2 关于 <code>$and?</code> 的原理及 [R<sup>6</sup>RS-Rationale] §15.1 。</p>
<h4 id="赋值函数名称后缀"><a class="header" href="#赋值函数名称后缀">赋值函数名称后缀</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>一个对象而不要求第一参数是引用值且不改变被赋值对象类型的<a href="Features/NPL.zh-CN.html#%E8%B5%8B%E5%80%BC">赋值操作</a>对应的函数名以 <code>&lt;-</code> 结尾。</p>
<p><strong>注释</strong></p>
<p>　　这通常和宿主语言的赋值操作对应，可能有附加的副作用而不是简单地替换值。</p>
<h4 id="修改函数名称后缀"><a class="header" href="#修改函数名称后缀">修改函数名称后缀</a></h4>
<p>　　除<a href="Features/NPL.zh-CN.html#%E8%B5%8B%E5%80%BC%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E5%90%8E%E7%BC%80">函数名以 <code>&lt;-</code> 结尾</a>外的操作中，为了蕴含（不直接通过求值操作数或其子表达式引起的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>的）<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>的函数是<em>修改函数(modification function)</em> ，其名称使用 <code>!</code> 结尾。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">可变管理状态的改变</a>不需要指示可修改；此外，类似地，不改变<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>的<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">隐藏状态</a>的修改不属于上述修改。</p>
<p><strong>注释</strong> 这类似 [R<sup>n</sup>RK] 。</p>
<p>　　这类操作同时是<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">改变操作</a>。</p>
<p><strong>注释</strong> 这类似 [R<sup>n</sup>RS] 和 [R<sup>n</sup>RK] 。</p>
<p>　　一些其它情形下，特定的函数不被视为改变操作但其调用仍可能引起副作用，这样的函数名不要求带有 <code>!</code> 后缀：</p>
<ul>
<li>直接求值操作数、其子表达式关联的对象可能引起副作用。
<ul>
<li><strong>注释</strong> 这和 [R<sup>n</sup>RK] 类似。</li>
</ul>
</li>
<li>一些操作可能非确定性地包含使操作数指称或引用的对象的值<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">有效但未指定</a>的修改。
<ul>
<li><strong>注释</strong> 这和 [R<sup>n</sup>RK] 不同。</li>
<li><strong>注释</strong> 如<a href="Features/NPL.zh-CN.html#%E8%BD%AC%E7%A7%BB%E5%AF%BC%E8%87%B4%E7%9A%84%E4%BF%AE%E6%94%B9">隐式的转移操作</a>。
<ul>
<li>这不包含预期成功时确定总是转移的操作。</li>
<li>排除不允许任何修改（如总是进行<a href="Features/NPL.zh-CN.html#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型错误</a>，要求操作数是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">不可修改引用</a>）的情形，即便转移后<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">状态不变</a>，仍被视为修改。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　修改函数的调用的求值可能因为不同的操作数的影响，而可能依赖具体的条件确定是否改变对象：</p>
<ul>
<li>当通过操作数直接指定的条件确定是否修改时。</li>
<li>当通过操作数确定被修改的对象时。</li>
<li>当通过操作数确定引起修改的对象时。</li>
</ul>
<p>　　这些函数的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>是<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">未指定值</a>。</p>
<p><strong>注释</strong></p>
<p>　　修改函数的调用不一定总是具有能视为修改的副作用，可能不改变任何对象。</p>
<p>　　这些函数的返回值的规定和 [R<sup>n</sup>RS] 相同，但和使用可用谓词 <code>inert?</code> 判断的<em>惰性(inert)</em> 值的 [R<sup>n</sup>RK] 不同。</p>
<h3 id="引用标记字符的函数名后缀"><a class="header" href="#引用标记字符的函数名后缀">引用标记字符的函数名后缀</a></h3>
<p>　　一些操作以（<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E5%90%8E%E7%BC%80">可能的 <code>!</code></a> 前）结尾<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">引用标记字符</a>和不以引用标记字符结尾的名称提供多个变体。其中不含结尾的引用标记字符的表示<a href="Features/NPL.zh-CN.html#%E5%BA%93%E6%8E%A5%E5%8F%A3%E5%AE%9E%E4%BD%93">操作的结果</a>不是引用值，要求<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值传递</a>。</p>
<p>　　其它一些操作可能只提供以 <code>%</code> 结尾的变体。</p>
<p>　　不使用引用标记字符的函数及其函数值时，不因引入引用值违反<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">内存安全</a>。</p>
<p><strong>原理</strong> 这允许通过避免公开带有引用标记字符后缀的操作提供一个内存安全的子集，以在派生实现对语言进行裁剪。</p>
<p>　　名称以引用标记字符结尾的操作属于以下分类之一：</p>
<ul>
<li>可能<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">直接保留引用值</a>的操作：操作的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">结果</a>及<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">作用</a>依赖实际参数（需要时经过隐含的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">左值到右值转换</a>）的值。</li>
<li>可能<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">间接保留引用值</a>的操作：可涉及不同的环境，结果和作用依赖实际参数（需要时经过隐含的左值到右值转换）在这些环境中被求值后确定。</li>
</ul>
<p>　　对可能在函数值中间接保留引用值的操作，以 <code>%</code> 结尾表示对应的函数返回时<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">不要求返回非引用值</a>。</p>
<p>　　其它可能在函数值中直接保留引用值的提供不同引用标记字符的多个变体的操作：</p>
<ul>
<li>以 <code>%</code> 结尾表示函数使用不进行<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">左值到右值转换</a>的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">折叠</a>的引用值参数，或返回折叠的引用值。</li>
<li>以 <code>&amp;</code> 结尾表示函数使用不进行左值到右值转换的折叠的引用值参数，或返回折叠的引用值。</li>
<li>以 <code>@</code> 结尾表示函数使用不进行左值到右值转换的<a href="Features/NPL.zh-CN.html#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">未折叠的引用值</a>参数，或返回未折叠的引用值。</li>
</ul>
<p>　　以上引用值参数的使用指以依赖这些参数的方式构成函数的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>和/或决定引起的相应的副作用；返回的引用值来自引用值参数（若存在）。</p>
<p><strong>原理</strong></p>
<p>　　为满足<a href="Features/NPL.zh-CN.html#%E9%80%82%E7%94%A8%E6%80%A7">适用性</a>，同时考虑避免误用和允许使用引用避免复制，对一些操作显式使用以 <code>%</code> 或 <code>&amp;</code> 结尾的函数名称以得到特别关注。</p>
<p>　　因为语义相关，结尾引用标记字符使用和绑定的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">引用标记字符</a>相同的字符，但不复用具体规则。</p>
<p>　　尽管设计时没有参照，使用函数结尾的引用标记字符和其它一些语言的类似特性的使用惯例也一致，如 <a href="https://www.php.net/references.return">PHP 的 function <code>&amp;</code> 语法</a>。</p>
<p><strong>注释</strong></p>
<p>　　按这些规则，函数名以 <code>%</code> 结尾的操作在取折叠的引用值时，可能同时实现<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的转发。这相当于被访问的被引用对象作为宿主语言的 <code>std::forward</code> 的参数后的调用结果作为操作的结果，但此处一般仍然保证支持 <a href="Features/NPL.zh-CN.html#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C-ptc">PTC</a> 。</p>
<p>　　函数名以 <code>&amp;</code> 结尾的操作取得的折叠的引用值可能是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">唯一引用</a>。</p>
<h4 id="引用折叠的约定"><a class="header" href="#引用折叠的约定">引用折叠的约定</a></h4>
<p>　　取得折叠的引用值的默认约定同<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">NPLA1 默认规则</a>。</p>
<p>　　以上函数<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>中：</p>
<ul>
<li>折叠的引用值对调用时引入的引用值（不论是否来自参数）有效。</li>
<li>除非另行指定，不对同一个对象引用折叠多次。</li>
<li><strong>注释</strong> 这些规则不保证结果是<a href="Features/NPL.zh-CN.html#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">完全折叠的引用值</a>。返回折叠引用值的函数可因未完全折叠的引用值参数等返回未折叠的引用值。</li>
</ul>
<p>　　这允许函数的内部实现引入一次引用值时，对来自每个参数的引用值至多只需要实现一次折叠。</p>
<p>　　推论：若参数都不是未折叠的引用值，调用名称不以 <code>@</code> 结尾的函数不引入未折叠的引用值。</p>
<p>　　若指定的操作按不同操作数可涉及或不涉及和当前不同环境下的求值，提供不保留引用值和保留引用值的多个变体的操作以便保证内存安全。</p>
<p><strong>注释</strong></p>
<p>　　提供不保留引用值和保留引用值的多个变体的操作以便保证内存安全的操作包括<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E6%8F%90%E4%BE%9B%E4%BB%A5%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%BB%93%E5%B0%BE%E5%8F%98%E4%BD%93%E7%9A%84%E5%87%BD%E6%95%B0">可提供以引用标记字符结尾变体的函数</a>和<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E6%8F%90%E4%BE%9B%E7%BB%93%E5%B0%BE%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E5%AF%B9%E5%BA%94%E5%8F%98%E4%BD%93%E7%9A%84%E5%87%BD%E6%95%B0">不提供结尾引用标记字符对应变体的函数</a>指定的操作。</p>
<h4 id="引用标记字符函数名与内存安全的关系"><a class="header" href="#引用标记字符函数名与内存安全的关系">引用标记字符函数名与内存安全的关系</a></h4>
<p>　　利用区分引用标记字符结尾的操作，可指定具体关于具体操作的<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81%E6%9C%BA%E5%88%B6">对象语言接口的安全保证机制</a>。</p>
<p><strong>原理</strong></p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E7%BA%A6%E5%AE%9A">函数名</a>结尾的引用标记字符用于强调无法总是保证内存安全的<a href="Features/NPL.zh-CN.html#%E9%80%82%E7%94%A8%E6%80%A7">危险操作</a>。</p>
<p>　　一般地，仅在明确需要引用值时使用引用标记字符结尾的操作，而避免返回悬空引用。这类似宿主语言函数的 <code>auto</code> 而非 <code>auto&amp;&amp;</code> 的返回类型，但宿主语言中返回非引用类型的表达式两者含义不同。</p>
<p>　　函数名不带有引用标记字符结尾的操作通过避免<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">保留引用值</a>提供一定的<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">内存安全保证</a>，而带有引用标记字符结尾的操作较容易引起注意。</p>
<p>　　这符合<a href="Features/NPL.zh-CN.html#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测性</a>。</p>
<p><strong>注释</strong></p>
<p>　　一个典型例子是在函数中<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">返回标识符求值</a>的表达式：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#npla1-%E8%A7%84%E8%8C%83%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">标识符求值后指称左值引用值</a>，这个引用值的有效性依赖<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">合并子调用</a>时创建的<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">新环境</a>的可被访问。</li>
<li>这个环境在调用后通常被销毁，若使用带有引用标记字符结尾的操作关于对应的函数返回引用值的语义，在函数值中保留引用值，返回为<a href="Features/NPL.zh-CN.html#%E6%97%A0%E6%95%88%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC">悬空引用</a>，容易误用。</li>
</ul>
<h4 id="保留引用值的约定"><a class="header" href="#保留引用值的约定">保留引用值的约定</a></h4>
<p>　　可能<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">直接保留引用值</a>的操作中，不带有引用标记字符的操作<a href="Features/NPL.zh-CN.html#%E4%BC%A0%E9%80%92%E9%9D%9E%E5%BC%95%E7%94%A8%E5%80%BC%E5%8F%82%E6%95%B0">传递非引用值参数</a>，其它函数<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91">转发参数</a>。</p>
<p>　　可能直接保留引用值的操作包括<a href="Features/NPL.zh-CN.html#%E5%88%9B%E5%BB%BA%E5%92%8C%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0">容器构造器或访问器</a>，以及可能<a href="Features/NPL.zh-CN.html#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E7%9B%AE%E6%A0%87">使对象中包含引用值</a>的<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改操作</a> 。</p>
<p>　　这些操作的<a href="Features/NPL.zh-CN.html#%E5%BA%93%E6%8E%A5%E5%8F%A3%E5%AE%9E%E4%BD%93">结果</a>或引起的副作用完全由实际参数（根据是否存在引用标记字符 <code>%</code> 指定是否不经过隐含的左值到右值转换）的值确定。</p>
<p>　　其中，带有引用标记字符结尾的操作是直接保留引用值操作。</p>
<p>　　容器构造器可在元素保留参数的引用值。作为结果的容器总是<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">作为非引用值返回</a>，即在结果中保留参数的引用值。</p>
<p><strong>原理</strong></p>
<p>　　以上操作是否确定地保留引用值在一些情形容易证明<a href="Features/NPL.zh-CN.html#%E5%AE%89%E5%85%A8%E6%80%A7%E9%99%84%E5%8A%A0%E8%AF%81%E6%98%8E">附加调用安全</a>，此时可放宽<a href="Features/NPL.zh-CN.html#%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C%E5%AD%90%E9%9B%86">安全特性子集</a>的条件确保安全性；在此不作要求。</p>
<p>　　对构造器及部分修改操作区分引用标记字符结尾可强调一些非预期保留引用值的容易误用情形；尽管总是返回非引用值。</p>
<p>　　因<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">转发参数而被保留的引用值</a>不会被<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">返回值转换</a>或类似的操作影响，在构造的容器对象作为非引用值返回时，仍会保留引用值。对应宿主语言中，可有更显著的差异，如构造器对应的 <code>std::tuple</code> 的 <code>std::make_tuple</code> 和 <code>std::forward_as_tuple</code> 。</p>
<h3 id="可提供以引用标记字符结尾变体的操作"><a class="header" href="#可提供以引用标记字符结尾变体的操作">可提供以引用标记字符结尾变体的操作</a></h3>
<p>　　部分操作使用<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D%E5%90%8E%E7%BC%80">以引用标记字符结尾的函数名</a>。</p>
<p>　　可提供不同变体的操作被严格限制，以避免过度区分造成在使用上不必要的复杂性。</p>
<h4 id="可能使结果包含引用值的容器构造器"><a class="header" href="#可能使结果包含引用值的容器构造器">可能使结果包含引用值的容器构造器</a></h4>
<p>　　容器构造器作为包括典型的构造器，可提供不同的变体（或其中之一）：</p>
<ul>
<li>不在函数值中保留引用值，实际参数发生左值到右值转换作为容器的元素，这减少误用<a href="Features/NPL.zh-CN.html#%E6%97%A0%E6%95%88%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC">悬空引用</a>的可能性。</li>
<li>在函数值中保留引用值，实际参数不发生左值到右值转换而直接作为容器的元素，是<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">不安全操作</a>，但可以确保构造的对象中包含参数指定的引用值。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　当只提供没有结尾引用标记字符对应名称的操作时，不需要满足<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E6%8F%90%E4%BE%9B%E7%BB%93%E5%B0%BE%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E5%AF%B9%E5%BA%94%E5%90%8D%E7%A7%B0%E7%9A%84%E6%93%8D%E4%BD%9C">以下</a>的约定。</p>
<p>　　在结果中保留参数的引用值的<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E7%BA%A6%E5%AE%9A">容器构造器</a>可能<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E9%97%B4%E6%8E%A5%E5%80%BC">保留可能无效的间接值</a>而属于不安全操作。</p>
<h4 id="可能使结果包含引用值的容器元素访问器"><a class="header" href="#可能使结果包含引用值的容器元素访问器">可能使结果包含引用值的容器元素访问器</a></h4>
<p>　　带有引用标记字符结尾的操作是<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">直接保留引用值</a>操作。</p>
<p>　　函数名不带有标记字符结尾的访问器属于<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91">参数转发操作</a>和<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%80%BC%E8%BD%AC%E5%8F%91">函数值转发操作</a>。</p>
<h4 id="可能使对象中包含引用值的修改操作"><a class="header" href="#可能使对象中包含引用值的修改操作">可能使对象中包含引用值的修改操作</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">修改对象或对象的子对象</a>可<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">无效化引用值</a>而影响内存安全。</p>
<p>　　对<a href="Features/NPL.zh-CN.html#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%9D%A5%E6%BA%90">可能保留参数中的引用值</a>的操作，内存安全也依赖这些操作的指定修改后的值的内存安全性。</p>
<p>　　在判定<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">内存安全</a>的意义上，以下操作的所有参数都可能是<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E9%97%B4%E6%8E%A5%E5%80%BC">被保留的间接值</a>：</p>
<ul>
<li><em>简单赋值(simple assignment)</em>（包含于<a href="Features/NPL.zh-CN.html#%E8%B5%8B%E5%80%BC">赋值操作</a>）。</li>
<li>列表元素<em>改变器(mutator)</em> 。</li>
</ul>
<p>　　修改的结果由实际参数（必要时经过隐含的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0%E7%BA%A6%E5%AE%9A">左值到右值转换</a>）的值确定。</p>
<p>　　以上操作都要求检查表示被修改的参数是左值。</p>
<p>　　以上操作中，带有引用标记字符结尾的操作<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">在对象中直接保留引用值</a>。</p>
<h4 id="可能间接保留引用值的操作"><a class="header" href="#可能间接保留引用值的操作">可能间接保留引用值的操作</a></h4>
<p>　　一些操作可涉及不同的环境，参数在这些环境中被求值可能得到引用值。</p>
<p>　　这些操作包括求值为操作子的以下函数：</p>
<ul>
<li>以求值 <code>&lt;body&gt;</code> 作为<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">尾上下文</a>的操作。</li>
<li>以求值 <code>&lt;expressions&gt;</code> 初始化 <code>&lt;defindiend&gt;</code> 指定的对象的<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>。</li>
<li>以求值 <code>&lt;expression&gt;</code> 或视为 <code>&lt;expression&gt;</code> 的 <code>&lt;object&gt;</code>（及可能发生的<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">返回值转换</a>）作为唯一作用的函数。</li>
</ul>
<p>　　以上操作中，带有引用标记字符结尾的操作是间接保留引用值操作，表示求值结果不要求<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值传递</a>并可<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">返回引用值</a>。</p>
<p><strong>原理</strong></p>
<p>　　不提供<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%80%BC%E8%BD%AC%E5%8F%91">函数值转发</a>的形式，因为：</p>
<ul>
<li>选用经过<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>得到的值已可保证避免求值结果中的<a href="Features/NPL.zh-CN.html#%E6%97%A0%E6%95%88%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC">悬空引用</a>。</li>
<li>直接返回可能是引用值的值具有更简明直观的语义。</li>
<li>若需转发，可直接<a href="Features/NPL.zh-CN.html#%E8%BD%AC%E5%8F%91%E5%8F%82%E6%95%B0%E6%88%96%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%AE%9E%E7%8E%B0">在被求值的表达式中显式构造</a>。</li>
<li>不需要假设求值结果<a href="Features/NPL.zh-CN.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初值符</a>作为函数值转发依据的参数。</li>
</ul>
<p>　　和此处直接在参数中给出被求值表达式不同，应用子中的一些求值的操作不属于上述操作，而不提供<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E8%83%BD%E9%97%B4%E6%8E%A5%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C">结尾引用标记字符对应名称的操作</a>。</p>
<h3 id="不提供结尾引用标记字符对应名称的操作"><a class="header" href="#不提供结尾引用标记字符对应名称的操作">不提供结尾引用标记字符对应名称的操作</a></h3>
<p>　　其它操作不使用<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D%E5%90%8E%E7%BC%80">以引用标记字符结尾的函数名</a>。</p>
<p>　　若这些操作的结果直接<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">来自操作数或其子对象</a>（和以 <code>%</code> 结尾操作的情形类似），则：</p>
<ul>
<li>可<a href="Features/NPL.zh-CN.html#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%9D%A5%E6%BA%90">保留参数中的引用值</a>并<a href="Features/NPL.zh-CN.html#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E7%9B%AE%E6%A0%87">在函数值中保留</a>。</li>
<li>不提供避免保留值的对应操作，或仅在此基础上提供总是包含等价<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">返回值转换</a>的对应操作。</li>
</ul>
<p>　　否则，这些操作不具有引用值结果。</p>
<p>　　部分操作的结果直接来自实际参数。此时，若不具有引用值结果，则<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0%E7%BA%A6%E5%AE%9A">蕴含左值到右值转换</a>。</p>
<p><strong>原理</strong> 这些操作不会使用<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>作为环境，所以不需要使用以引用标记字符结尾的变体要求注意区分返回引用值而避免误用。因此，不提供区分涉及引用的变体，这也使接口设计更清晰。</p>
<p>　　这些操作包括以下小节的情形。</p>
<p>　　部分操作涉及<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91">参数转发</a>和<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%80%BC%E8%BD%AC%E5%8F%91">函数值转发</a>。这些操作不包含可提供<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E6%8F%90%E4%BE%9B%E4%BB%A5%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%BB%93%E5%B0%BE%E5%8F%98%E4%BD%93%E7%9A%84%E6%93%8D%E4%BD%9C">以引用标记字符结尾变体的操作中的个别变体</a>。</p>
<p>　　其它不提供结尾引用标记字符对应名称的操作暂不保证支持保留引用值。</p>
<p>　　部分操作的内存安全性和可提供<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E6%8F%90%E4%BE%9B%E4%BB%A5%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%BB%93%E5%B0%BE%E5%8F%98%E4%BD%93%E7%9A%84%E6%93%8D%E4%BD%9C">以引用标记字符结尾变体的操作</a>类似，也是在函数值中保留引用值的不安全操作，但仅在引用值参数被保留且以此访问<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>时体现。</p>
<p>　　这包括<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">直接保留引用值和间接保留引用值</a>的不同情形。</p>
<p>　　除<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%9B%B4%E6%8E%A5%E4%BB%A5%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%9C%E4%B8%BA%E7%BB%93%E6%9E%9C%E7%9A%84%E6%93%8D%E4%BD%9C">可直接以引用值作为结果的操作</a>和其它节的操作不相交，以下分类对操作的参数和函数值分别约定，可能相交。</p>
<h4 id="可直接以引用值作为结果的操作"><a class="header" href="#可直接以引用值作为结果的操作">可直接以引用值作为结果的操作</a></h4>
<p>　　一些求值为操作子提供的函数选取特定的参数进行求值，作为控制操作。</p>
<p>　　操作数中被求值的参数直接决定是否为引用部分操作直接返回引用值。</p>
<p>　　被求值的 <code>&lt;test&gt;</code> <a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0">蕴含左值到右值转换</a>，其它被求值的参数不蕴含左值到右值转换，调用者需负责决定是否求值其它参数。</p>
<p><strong>注释</strong></p>
<p>　　这类似宿主语言中参数传递和返回 <code>auto&amp;&amp;</code> 类型。</p>
<h4 id="不以引用值作为结果的操作"><a class="header" href="#不以引用值作为结果的操作">不以引用值作为结果的操作</a></h4>
<p>　　部分操作类似<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%BB%93%E6%9E%9C%E5%8C%85%E5%90%AB%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AE%B9%E5%99%A8%E6%9E%84%E9%80%A0%E5%99%A8">容器构造器</a>保证<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E9%9D%9E%E5%BC%95%E7%94%A8%E5%80%BC">返回非引用值</a>，但并非直接以参数实现决定函数值：</p>
<p>　　若非构造器的操作总是返回列表和其它对元素具有所有权的容器对象，返回的对象总是按值传递。</p>
<p>　　为简化接口以及满足其它分类（如<a href="Features/NPL.zh-CN.html#%E7%9B%B4%E6%8E%A5%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91%E6%93%8D%E4%BD%9C">直接参数转发操作</a>），不提供不保留引用值的操作。</p>
<p>　　和提供不同的变体的作为构造器的操作不同，此处的情形的结果可能包含引用值（和以 <code>%</code> 结尾构造器的情形类似）。</p>
<p>　　若需要排除通过参数引入的引用值，应进行适当处理使参数中不含有会使这些操作引入引用值的构造。</p>
<p>　　类似保留引用值的容器构造器，这些操作<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E7%BA%A6%E5%AE%9A">可在结果中保留参数的引用值</a>。</p>
<h4 id="直接参数转发操作"><a class="header" href="#直接参数转发操作">直接参数转发操作</a></h4>
<p>　　部分<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91">不带有引用标记字符的参数转发操作</a>是<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">可能直接保留引用值的操作</a>，称为直接参数转发操作。</p>
<p>　　函数名不使用引用标记字符，和<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E6%8F%90%E4%BE%9B%E4%BB%A5%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%BB%93%E5%B0%BE%E5%8F%98%E4%BD%93%E7%9A%84%E6%93%8D%E4%BD%9C">可直接保留引用值的函数名</a>使用引用标记字符不一致：</p>
<ul>
<li>本节约定的函数和可直接保留引用值的函数名中带有 <code>%</code> 结尾的函数同属参数转发操作，但后者同时有不带有引用标记字符的变体。</li>
<li>本节不约定和可直接保留引用值的函数名中不带有引用标记字符结尾的函数对应的操作。</li>
</ul>
<p>　　这种不一致（和<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%80%BC%E8%BD%AC%E5%8F%91%E6%93%8D%E4%BD%9C">函数值转发操作</a>不同）是预期的特性：</p>
<p>　　和可直接保留引用值的操作不同：</p>
<ul>
<li>这些操作并非用于构造对参数具有所有权的对象，不适合提供不保留引用值的操作。</li>
<li>这些操作并非用于<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">取子对象</a>，返回值不一定是引用值，和具体操作相关，不适合使用引用标记字符区分。</li>
<li>为简化接口及满足其它分类（如<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E4%BB%A5%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%9C%E4%B8%BA%E7%BB%93%E6%9E%9C%E7%9A%84%E6%93%8D%E4%BD%9C">不以引用值作为结果的操作</a>），不适合提供不保留引用值的操作。</li>
</ul>
<p>　　本节约定的函数对引用标记字符的使用和可提供<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E6%8F%90%E4%BE%9B%E4%BB%A5%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%BB%93%E5%B0%BE%E5%8F%98%E4%BD%93%E7%9A%84%E6%93%8D%E4%BD%9C">以引用标记字符结尾变体的操作</a>的函数名的使用不一致，含义相当于前者的结尾的 <code>%</code> 。</p>
<p>　　以下的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%80%BC%E8%BD%AC%E5%8F%91%E6%93%8D%E4%BD%9C">函数值转发操作</a>同时也是直接参数转发操作。</p>
<p>　　其它函数的参数传递的一般规则参见<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0">引用值作为实际参数</a>、<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%80%BC%E4%BC%A0%E9%80%92%E7%BA%A6%E5%AE%9A">函数参数和函数值传递约定</a>和<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0%E7%BA%A6%E5%AE%9A">实际参数约定</a>。</p>
<h4 id="函数值转发操作"><a class="header" href="#函数值转发操作">函数值转发操作</a></h4>
<p>　　若其它情形确需非转发操作取得引用值，可使用<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E6%8F%90%E4%BE%9B%E4%BB%A5%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%BB%93%E5%B0%BE%E5%8F%98%E4%BD%93%E7%9A%84%E6%93%8D%E4%BD%9C">带有 <code>%</code> 或 <code>&amp;</code> 结尾的操作</a>及可直接<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%9B%B4%E6%8E%A5%E4%BB%A5%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%9C%E4%B8%BA%E7%BB%93%E6%9E%9C%E7%9A%84%E6%93%8D%E4%BD%9C">以引用值作为结果的操作</a>替代实现。</p>
<p>　　本节约定的函数不使用引用标记字符，和<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%BB%93%E6%9E%9C%E5%8C%85%E5%90%AB%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE%E5%99%A8">容器元素访问器</a>的函数名不使用引用标记字符一致：</p>
<p>　　本节约定的函数和上述容器元素访问器的函数名中不带有引用标记字符结尾的函数同属函数值转发操作，但后者同时有带有引用标记字符的变体。</p>
<p><strong>原理</strong></p>
<p>　　和<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%BB%93%E6%9E%9C%E5%8C%85%E5%90%AB%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AE%B9%E5%99%A8%E6%9E%84%E9%80%A0%E5%99%A8">容器构造器</a>引入引用值的情形不同，不带有后缀 <code>%</code> 相对不容易引起误用，因为返回值保留的引用<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">可以继续被返回值转换</a>影响。</p>
<p>　　例如，使用<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E8%83%BD%E9%97%B4%E6%8E%A5%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C">保证返回非引用值的涉及环境中求值的操作</a>，引用值会在引用的对象生存期结束前被返回值转换而不影响内存安全。</p>
<h4 id="可能间接保留引用值的无引用标记字符对应名称的操作"><a class="header" href="#可能间接保留引用值的无引用标记字符对应名称的操作">可能间接保留引用值的无引用标记字符对应名称的操作</a></h4>
<p>　　类似可提供<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E8%83%BD%E9%97%B4%E6%8E%A5%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C">以引用标记字符结尾变体的对应操作</a>，部分不带有引用标记字符的操作可能<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">间接保留引用值</a>。</p>
<p>　　这包括由类型为合并子的参数（而非 <code>&lt;body&gt;</code> 或 <code>&lt;expressions&gt;</code> ）决定是否保留引用值同时对其它参数进行转发的操作。</p>
<h3 id="函数名称中缀"><a class="header" href="#函数名称中缀">函数名称中缀</a></h3>
<p>　　中缀 <code>-&gt;</code> 在函数名中可能出现一次，表示其（移除前缀和后缀之后的函数名中的）左边为源类型名的值到右边为目标类型名的值的转换操作。</p>
<p>　　除作为源类型的值外，可能支持可选的附加其它参数。</p>
<p>　　除非另行指定，转换得到的值是<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>。</p>
<p>　　除非另行指定，转换函数调用的求值是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>。</p>
<p>　　除非另行指定，若被转换的<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">值的复制</a>可能影响<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>，被转换的值被<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91">转发</a>以<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">初始化返回值</a>。其中的右值被转移时，使用<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">对象的转移</a>或<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">项的转移</a>未指定。</p>
<p>　　除非另行转定，按<a href="Features/NPL.zh-CN.html#%E6%8E%A5%E5%8F%A3%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">接口文法约定</a>引入的操作数作为对应名称之间的转换，仅在引入其中之一的模块提供。具体规则如下：</p>
<ul>
<li>源或目标具有在同一个<a href="Features/NPL.zh-CN.html#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">根环境</a>或其中的环境引入的对象类型时，在根环境中提供转换函数的名称。</li>
<li>源或目标具有从根环境中的 <a href="Features/NPL.zh-CN.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BA%93"><code>std.strings</code></a> 以外的环境中引入的类型时，仅在引入其中之一提供转换函数的名称。</li>
<li>否则，在模块 <code>std.strings</code> 提供转换函数的名称。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　如有可能，被转换的值一般应避免被复制。在接口上要求转发右值避免不必要的复制。</p>
<p>　　标准库模块 <code>std.strings</code> 支持 <a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;string&gt;</code></a> 的值的有关操作。因为相关转换的潜在的普遍性，在此进行特殊约定。</p>
<p><strong>注释</strong></p>
<p>　　一般地，转换操作是源类型的值作为单一实际参数的转换目标类型的<a href="Features/NPL.zh-CN.html#%E5%88%9B%E5%BB%BA%E5%92%8C%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0">构造器</a>。</p>
<h2 id="不安全操作约定"><a class="header" href="#不安全操作约定">不安全操作约定</a></h2>
<p>　　除非另行指定，执行时蕴含以下操作的操作是<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">不安全操作</a>：</p>
<ul>
<li>以下不具有<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">内存安全保证</a>的操作：
<ul>
<li>使用<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E7%BA%A6%E5%AE%9A">函数名称约定</a>的<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E6%8F%90%E4%BE%9B%E4%BB%A5%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%BB%93%E5%B0%BE%E5%8F%98%E4%BD%93%E7%9A%84%E6%93%8D%E4%BD%9C">函数名带有后缀的操作</a>。</li>
<li>其它<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E9%97%B4%E6%8E%A5%E5%80%BC">保留间接值的操作</a>。</li>
</ul>
</li>
<li>以下可能引入循环引用的操作：
<ul>
<li>引入引用现有<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">环境对象</a>的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境强引用</a>的操作。</li>
<li>引入共享持有者的<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">值数据成员</a>而可能通过循环引用等引起未定义行为操作。</li>
</ul>
</li>
<li>和以上不安全操作等效的互操作。</li>
<li>其它另行指定的操作。</li>
</ul>
<p>　　按不安全操作引起不同的未定义行为和不同的<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E5%AE%89%E5%85%A8%E9%97%B4%E6%8E%A5%E5%80%BC%E8%AE%BF%E9%97%AE">间接值</a>，以下小节对不安全操作进行分类。</p>
<p>　　分类之间的关系详见<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E9%97%B4%E6%8E%A5%E5%80%BC">保留间接值</a>。</p>
<p>　　分类可能不完全的且可能相交的（不安全操作可能不属于任何一个分类或同时属于多个分类）。</p>
<h3 id="在函数值中保留引用值的操作"><a class="header" href="#在函数值中保留引用值的操作">在函数值中保留引用值的操作</a></h3>
<p>　　在函数值中保留引用值的操作包括按<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E7%BA%A6%E5%AE%9A">函数名称约定</a>具有引用标记字符结尾的操作。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">直接保留引用值</a>操作可配合带有<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>的操作，指定个别函数参数不再保留引用值。</p>
<p>　　这些操作可引起之后的<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E5%AE%89%E5%85%A8%E9%97%B4%E6%8E%A5%E5%80%BC%E8%AE%BF%E9%97%AE">不安全引用值访问</a>。</p>
<p>　　保留的引用值同时可能被构造<a href="Features/NPL.zh-CN.html#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>。</p>
<p><strong>注释</strong></p>
<p>　　一些修改操作<a href="Features/NPL.zh-CN.html#%E6%97%A0%E6%95%88%E5%8C%96">无效化</a>引用值。这些引用值若被保留且被访问，可引起未定义行为。</p>
<p>　　不引起被绑定对象无效的修改操作不被视为不安全操作，即便它们无效化<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的引用值。</p>
<h3 id="在函数值中保留环境引用的操作"><a class="header" href="#在函数值中保留环境引用的操作">在函数值中保留环境引用的操作</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E9%97%B4%E6%8E%A5%E5%80%BC">环境引用</a>被返回时，总是被<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">保留</a>。</p>
<p>　　创建<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境强引用</a>的操作是在函数值中保留环境引用的操作。</p>
<p>　　这些对象可能因为没有及时保存环境引用使环境对象和其中的绑定一并被销毁，而使引用值访问其中的对象的程序具有未定义行为。</p>
<p>　　通过非引用的形式引入环境循环引用的操作同时可破坏环境的资源所有权。</p>
<p><strong>注释</strong></p>
<p>　　直接返回有效的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境弱引用</a>的操作不引起环境失效，不在此列。</p>
<h3 id="在函数值中保留其它间接值的操作"><a class="header" href="#在函数值中保留其它间接值的操作">在函数值中保留其它间接值的操作</a></h3>
<p>　　特定的支持<a href="Features/NPL.zh-CN.html#%E5%BC%BA%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">强递归绑定</a>而在函数值中保留其它间接值，可能存在<a href="Features/NPL.zh-CN.html#%E5%85%B6%E5%AE%83%E6%97%A0%E6%95%88%E7%9A%84%E9%97%B4%E6%8E%A5%E5%80%BC">其它无效的间接值</a>。</p>
<p>　　在函数值中保留其它间接值的操作的强递归绑定过程中引用共享对象的中间值。</p>
<h3 id="在环境中保留环境引用的操作"><a class="header" href="#在环境中保留环境引用的操作">在环境中保留环境引用的操作</a></h3>
<p>　　环境中的被绑定对象可具有环境引用<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>，间接地在环境中保留环境引用。</p>
<p>　　这些操作使<a href="Features/NPL.zh-CN.html#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>或参数指定的环境（而不是<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">合并子调用</a>时创建的<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">新环境</a>）中的变量绑定包含间接值，后者可能依赖合并子调用时创建的新环境。</p>
<p>　　被绑定的对象中可能保留环境引用，而使用环境间接地保留对象中的引用。</p>
<p>　　使用这些操作时应总是注意被依赖的环境的可用性。</p>
<p>　　若环境对象销毁，所有直接和间接依赖环境对象的<a href="Features/NPL.zh-CN.html#%E6%97%A0%E6%95%88%E5%8C%96">间接值被无效化</a>。这些间接值的<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E5%AE%89%E5%85%A8%E9%97%B4%E6%8E%A5%E5%80%BC%E8%AE%BF%E9%97%AE">不安全间接值访问</a>引起未定义行为。</p>
<p><strong>注释</strong></p>
<p>　　绑定的对象中可能保留环境引用的典型的例子是合并子对象的静态环境。</p>
<p>　　创建合并子可在合并子中的环境中保留环境引用。</p>
<h3 id="无效化被绑定对象或环境引用的操作"><a class="header" href="#无效化被绑定对象或环境引用的操作">无效化被绑定对象或环境引用的操作</a></h3>
<p>　　特定的操作蕴含被绑定对象的存储期的结束而无效化它的引用值。</p>
<p>　　若<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的引用值已被绑定，这些引用值不需要通过其它不安全操作，而仅通过之后<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">访问标识符求值</a>的<a href="Features/NPL.zh-CN.html#npla1-%E8%A7%84%E8%8C%83%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">结果</a>即可引起未定义行为。</p>
<p>　　因为<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7">环境稳定性</a>要求，NPLA1 实现环境不提供这类绑定，因此这些操作不是不安全操作。</p>
<p>　　但派生实现可能在语言实现中提供不满足环境稳定性的一等环境，其中对象的子对象的引用值被绑定为变量，且前者可能被修改。</p>
<p>　　此时，这些操作可能允许无效化引用后的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>被访问，成为不安全操作。</p>
<p>　　类似地，无效化环境引用而无效化环境对象也可使其中包含的被绑定对象的引用无效化。</p>
<p>　　但<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E7%94%9F%E5%AD%98%E6%9C%9F">环境生存期</a>要求，除非作为不满足环境稳定性的环境的被绑定对象，NPLA1 实现环境不提供唯一的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境强引用</a>可被<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>修改而使环境对象被销毁。</p>
<p>　　在这个前提下，要通过使环境引用作为子对象被修改而结束环境对象的生存期，首先要求通过<a href="Features/NPL.zh-CN.html#%E5%9C%A8%E5%87%BD%E6%95%B0%E5%80%BC%E4%B8%AD%E4%BF%9D%E7%95%99%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C">在函数值中保留环境引用的操作</a>取得环境引用，得到包含环境引用作为子对象的对象，且保证只有这个对象保存<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境强引用</a>。</p>
<p>　　因此，若不存在其它不安全操作，即蕴含不存在在对象语言操作中无效化环境引用的情形。</p>
<p>　　类似地，派生实现可提供不满足环境生存期中的销毁顺序的环境，而使用户无效化对应的环境对象。</p>
<p>　　此时，这些操作可能允许无效化环境引用后的环境对象被访问，成为不安全操作。</p>
<h3 id="副作用可能引入循环引用的操作"><a class="header" href="#副作用可能引入循环引用的操作">副作用可能引入循环引用的操作</a></h3>
<p>　　一些操作不依赖其它不安全操作（保留引用值或环境引用）即可引入循环引用：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E8%B5%8B%E5%80%BC">自赋值</a>可能引入循环引用值。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　通过已有的不安全操作构造的引用值也可能引入循环引用（而引起未定义行为），但不是单一操作的副作用，不属于本节的实例。</p>
<p>　　例如<a href="Features/NPL.zh-CN.html#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>中使用 <code>list%</code> 的例子，<code>$def!</code> 或 <code>list%</code> 不会因此被视为此处的不安全操作，因为单一操作的语义不引入循环引用值。</p>
<h3 id="可能破坏环境稳定性的操作"><a class="header" href="#可能破坏环境稳定性的操作">可能破坏环境稳定性的操作</a></h3>
<p>　　通过引用值进行的<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改操作</a>可因破坏<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">环境稳定性</a>而引起<a href="Features/NPL.zh-CN.html#npla1-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">扩展 NPLA 未定义行为</a>（不一定违反<a href="Features/NPL.zh-CN.html#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>）。</p>
<p>　　这包括以下可无效化对象包含的引用值而使可通过环境访问的某个<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的同一性被改变，从而破坏<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">环境稳定性</a>的操作：</p>
<ul>
<li>对可能具有对象语言中可访问的子对象的对象的<a href="Features/NPL.zh-CN.html#%E8%B5%8B%E5%80%BC">赋值操作</a>。</li>
<li>可修改<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>的操作。
<ul>
<li>包括<a href="Features/NPL.zh-CN.html#%E9%87%8D%E7%BB%91%E5%AE%9A">重绑定</a> 。</li>
</ul>
</li>
</ul>
<h3 id="安全操作子集"><a class="header" href="#安全操作子集">安全操作子集</a></h3>
<p>　　作为<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81%E6%9C%BA%E5%88%B6">对象语言安全性保证</a>的一部分，用户程序通过限制或避免依赖特定的不安全操作，在特定情形下可实现<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">对象语言内存安全保证</a>，而不需要分析具体操作的语义：</p>
<ul>
<li>不依赖<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E7%BA%A6%E5%AE%9A">操作命名</a>约定的带有后缀的操作。</li>
<li>若使用保留环境引用的操作，总是保存被依赖的环境以确保相关的环境对象及其中的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>在间接访问对象时不被销毁。
<ul>
<li><strong>注释</strong> 如<a href="Features/NPL.zh-CN.html#%E5%9C%A8%E5%87%BD%E6%95%B0%E5%80%BC%E4%B8%AD%E4%BF%9D%E7%95%99%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C">在函数值中保留环境引用的操作</a>和<a href="Features/NPL.zh-CN.html#%E5%9C%A8%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BF%9D%E7%95%99%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C">在环境中保留环境引用的操作</a>。</li>
</ul>
</li>
<li>不使用引入最终不被保留的<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子有序对引用</a>以外其它间接值的操作。</li>
</ul>
<h2 id="参照实现约定"><a class="header" href="#参照实现约定">参照实现约定</a></h2>
<p>　　本节约定对 NPLA1 参照实现内部有效，不作用在用户程序。</p>
<p>　　除非另行指定，NPLA1 参照实现环境作为公开接口提供的变量在<a href="Features/NPL.zh-CN.html#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">根环境</a>中绑定。</p>
<p>　　除非另行指定，以变量绑定的提供接口没有严格的跨版本兼容性保证。</p>
<h3 id="参照实现接口描述"><a class="header" href="#参照实现接口描述">参照实现接口描述</a></h3>
<p>　　除非显式指定，空环境没有<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">父环境</a>。</p>
<p>　　约定的接口通过绑定在根环境中的名称提供，参见以下各节。</p>
<p>　　描述操作的上下文中，结果指<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作的结果</a>而非<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>。</p>
<p>　　除非是语义蕴含的操作结果或另行指定，所有取得函数值的<a href="Features/NPL.zh-CN.html#%E5%BA%93%E6%8E%A5%E5%8F%A3%E5%AE%9E%E4%BD%93">操作</a>满足：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">结果</a>是<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">未指定值</a>。
<ul>
<li>未指定值可以是 <a href="Features/NPL.zh-CN.html#npla1-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F"><code>#inert</code></a>或其它值，但满足忽略值时不引起<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>的改变。
<ul>
<li><strong>注释</strong> 这排除了引入 <code>volatile</code> 类型或非平凡析构的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主值</a>。</li>
</ul>
</li>
<li>若这些操作在 [R<sup>n</sup>RK] 或 klisp 中存在结果是 <code>#inert</code> 的对应的操作，且未指定作为函数值的结果，则结果是等于 <code>#inert</code> 的右值。</li>
</ul>
</li>
<li>这些操作若存在对应的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E7%BA%A6%E5%AE%9A">函数名</a>，满足<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E7%BA%A6%E5%AE%9A">函数名称约定</a>。</li>
<li>这些操作中隐式分配的和按接口约定转移所有权给操作实现的资源不存在<a href="Features/NPL.zh-CN.html#%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F">资源泄漏</a>。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　<a href="Features/NPL.zh-CN.html#npla1-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F"><code>#inert</code> 是单元类型的值</a>。但是，未指定值并不依赖单元类型的性质，而只是需要一种可在对象语言中判断是否为实现（如 [R<sup>n</sup>RK] 的 <code>inert?</code> ），而避免使用特设的规则。</p>
<p>　　取而代之，一些语言或运行时支持<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E7%B1%BB%E5%9E%8B">非一等</a>的特设返回类型：<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E7%B1%BB%E5%9E%8B"><code>void</code></a> ，在对象语言中无法构造其值。这种特性引起一些实用上的困难而被考虑改进，替换成一等类型，如：</p>
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0146r1.html">[WG21 P0146R1]</a></li>
<li><a href="https://github.com/dotnet/csharplang/discussions/1603">[Proposal] <code>System.Void</code> as a first-class type</a></li>
</ul>
<p>　　即便被改进，这仍只是<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">单元类型</a>，而不够清晰地反映未指定的意图。</p>
<p>　　未指定值蕴含的不确定性在对象语言中难以建模，因此直接通过语言规则约定直至作为内建的支持特性，能使语言的设计更<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单</a>。</p>
<p>　　未指定值的未指定性在接口意义上仍然不是一等实体，因为当前不提供如 <code>inert?</code> 这样的谓词。即便提供 <code>inert?</code> 也仅仅是判断值是否为 <code>#inert</code> ，而不是任意的未指定值。</p>
<p>　　相对 <code>inert?</code> ，这类谓词可能是有用的，例如元语言可能需要判断未指定性质以简化其派生实现。但这类需求和实现细节相关，且当前缺乏实例显示在对象语言中无条件提供的必要性。更重要的是，若要求提供这种谓词，限制派生实现在未指定值的类型上维持<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">开放类型</a>设计。</p>
<p>　　未指定值作为内建特性时，用户也无法直接提供这类谓词的派生（而不符合<a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">统一性</a>）。在需要这类谓词时，派生语言设计可能视具体实现需要满足的条件补充。</p>
<h3 id="操作符合性"><a class="header" href="#操作符合性">操作符合性</a></h3>
<p>　　除非另行指定，以下关于操作实现的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定行为</a>：</p>
<ul>
<li>对<a href="Features/NPL.zh-CN.html#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF%E6%9D%A1%E4%BB%B6">运行时错误条件</a>的<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF%E6%A3%80%E6%9F%A5">检查</a>及<a href="Features/NPL.zh-CN.html#%E8%AF%8A%E6%96%AD">诊断</a>的顺序。</li>
<li>满足运行时错误条件时，按要求诊断之后的操作内部分配的资源的状态。</li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">变量绑定</a>或其它可选地由派生实现定义的可调试实体的引入是否由<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>的机制提供。</li>
<li>是否存在不改变操作语义的附加的可被捕获的续延和这些续延的操作数。</li>
<li>操作的实现使用的续延或者其它<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">实体</a>为<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>和调试目的保留的名称。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　以上未指定行为允许同一操作的接口约定和实现之间及不同实现之间允许存在引起调用操作时的可观察行为不同的次要差异。</p>
<h3 id="实体实现约定"><a class="header" href="#实体实现约定">实体实现约定</a></h3>
<p>　　在实现的意义上，<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">库特性</a>提供的实体的方式分为两类：</p>
<ul>
<li>调用本机 API ，提供<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>。
<ul>
<li>直接调用本机 API 提供绑定和组合本机 API 实现功能的派生实现都是本机实现。</li>
</ul>
</li>
<li>通过组合既有对象语言提供的接口实现，即<em>派生(derivation)</em> 。</li>
</ul>
<p>　　因不预期通过派生实现，一些特性被设计为<em>基本(primitive)</em> 特性，总是通过直接调用本机 API 的本机实现提供。</p>
<p>　　其它特性都是派生特性，可通过<em>派生(derived)</em> 实现提供：通过组合基本特性及其它已提供实现的派生特性实现。</p>
<p>　　典型地，派生实现通常不依赖实现特定的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>接口的本机实现，这类派生实现是<em>非本机的(non-native)</em> ；其它的派生是本机的。</p>
<p>　　以下的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E7%A1%80%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">派生操作</a>应能以派生的方式提供。派生操作是否以派生的形式提供未指定。</p>
<p><strong>注释</strong></p>
<p>　　派生特性的实现方式可类似 [R<sup>n</sup>RK] 。</p>
<p>　　非本机的派生实现通常以求值特定的对象语言源代码引入。</p>
<p>　　非本机的实现最终依赖本机实现。</p>
<h4 id="预定义对象"><a class="header" href="#预定义对象">预定义对象</a></h4>
<p>　　除操作外，实现可定义特定名称的对象以变量绑定的形式在库中初始化，直接提供具有预设目的的可编程特性。</p>
<h1 id="npla1-根环境特性"><a class="header" href="#npla1-根环境特性">NPLA1 根环境特性</a></h1>
<p>　　本章指定在<a href="Features/NPL.zh-CN.html#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">根环境</a>提供的 <a href="Features/NPL.zh-CN.html#%E6%A0%87%E5%87%86%E5%BA%93">NPLA1 标准库特性</a>，即<a href="Features/NPL.zh-CN.html#%E5%BA%93%E6%8E%A5%E5%8F%A3%E7%BA%A6%E5%AE%9A">根环境特性</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E6%A0%B9%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7">根环境基本特性</a>是单独的模块。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E7%A1%80%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">基础派生特性</a>起的各节提供其余要求 NPLA1 实现直接支持的各个模块的操作。</p>
<p><strong>原理</strong></p>
<p>　　一些特性参照和类推扩展 [R<sup>n</sup>RK] 。</p>
<p>　　同 [R<sup>n</sup>RK] 的设计，<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>eval</code></a>和 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$vau</code></a>是体现对象语言设计的<a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">光滑性</a>的主要原语。</p>
<p>　　因为<a href="Features/NPL.zh-CN.html#%E5%9C%A8%E5%87%BD%E6%95%B0%E5%80%BC%E4%B8%AD%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C">保留引用值的不安全操作</a>的支持，类推 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>eval%</code></a>和 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$vau%</code></a>。</p>
<p>　　在本设计中，后者在逻辑意义上更基本，即便不指定为<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%BA%A6%E5%AE%9A">派生</a>。</p>
<p><strong>注释</strong></p>
<p>　　一些特性<a href="Features/NPL.zh-CN.html#npla1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80">可约定处理的值的宿主类型</a>。</p>
<h2 id="不安全函数索引"><a class="header" href="#不安全函数索引">不安全函数索引</a></h2>
<p>　　本节按<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">不安全操作约定</a>的分类对提供根环境中的<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">不安全操作</a>的函数进行归类。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%9C%A8%E5%87%BD%E6%95%B0%E5%80%BC%E4%B8%AD%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C">在函数值中保留引用值的不安全操作</a>已被<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E7%BA%A6%E5%AE%9A">命名</a>归纳和<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%88%86%E7%B1%BB">函数分类</a>枚举，此处从略。</p>
<p>　　不安全操作中，在参数以外直接引入间接值的操作仅有以下的在函数值中保留引用值的不安全操作：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>ref&amp;</code></a></li>
</ul>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%AE%89%E5%85%A8%E6%80%A7%E9%99%84%E5%8A%A0%E8%AF%81%E6%98%8E">附加调用安全</a>包括在函数值中保留引用值的不安全操作的调用。</p>
<p>　　当前，这种操作包括 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>assign!</code></a>。</p>
<p>　　隐藏环境排除可修改对象的引用，通过<a href="Features/NPL.zh-CN.html#%E5%86%BB%E7%BB%93">冻结</a>环境保证而提供静态的证明。</p>
<h3 id="在函数值中保留环境引用的函数"><a class="header" href="#在函数值中保留环境引用的函数">在函数值中保留环境引用的函数</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%9C%A8%E5%87%BD%E6%95%B0%E5%80%BC%E4%B8%AD%E4%BF%9D%E7%95%99%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C">在函数值中保留环境引用的操作</a>包括：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">基本操作</a>：
<ul>
<li><code>make-environment</code></li>
<li><code>copy-environment</code></li>
<li><code>lock-environment</code></li>
</ul>
</li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">派生操作</a>：
<ul>
<li><code>lock-current-environment</code></li>
<li><code>derive-current-environment</code></li>
<li><code>make-standard-environment</code></li>
<li><code>derive-environment</code></li>
<li><code>$provide/let!</code></li>
<li><code>$provide!</code></li>
</ul>
</li>
</ul>
<h3 id="在函数值中保留其它间接值的函数"><a class="header" href="#在函数值中保留其它间接值的函数">在函数值中保留其它间接值的函数</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%9C%A8%E5%87%BD%E6%95%B0%E5%80%BC%E4%B8%AD%E4%BF%9D%E7%95%99%E5%85%B6%E5%AE%83%E9%97%B4%E6%8E%A5%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C">在函数值中保留其它间接值的操作</a>包括：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>$defrec!</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$setrec!</code></a></li>
</ul>
<h3 id="在环境中保留环境引用的函数"><a class="header" href="#在环境中保留环境引用的函数">在环境中保留环境引用的函数</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%9C%A8%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BF%9D%E7%95%99%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C">在环境中保留环境引用的操作</a>包括<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">派生操作</a>：</p>
<ul>
<li><code>$provide/let!</code></li>
<li><code>$provide!</code></li>
</ul>
<h3 id="无效化被绑定对象的函数"><a class="header" href="#无效化被绑定对象的函数">无效化被绑定对象的函数</a></h3>
<p>　　当前不提供<a href="Features/NPL.zh-CN.html#%E6%97%A0%E6%95%88%E5%8C%96%E8%A2%AB%E7%BB%91%E5%AE%9A%E5%AF%B9%E8%B1%A1%E6%88%96%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C">无效化被绑定对象的操作</a>。</p>
<p>　　这可包含直接移除变量绑定的操作。</p>
<h3 id="副作用可能引入循环引用的函数"><a class="header" href="#副作用可能引入循环引用的函数">副作用可能引入循环引用的函数</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%89%AF%E4%BD%9C%E7%94%A8%E5%8F%AF%E8%83%BD%E5%BC%95%E5%85%A5%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C">副作用可能引入循环引用的操作</a>包括可能<a href="Features/NPL.zh-CN.html#%E8%B5%8B%E5%80%BC">自赋值</a>而引入循环引用值的操作：</p>
<ul>
<li><code>assign@!</code></li>
<li><code>assign%!</code></li>
</ul>
<h3 id="可能破坏环境稳定性的函数"><a class="header" href="#可能破坏环境稳定性的函数">可能破坏环境稳定性的函数</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E8%83%BD%E7%A0%B4%E5%9D%8F%E7%8E%AF%E5%A2%83%E7%A8%B3%E5%AE%9A%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C">可能破坏环境稳定性的操作</a>包括下列两类：</p>
<ul>
<li>对可能具有对象语言中可访问的<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的对象的<a href="Features/NPL.zh-CN.html#%E8%B5%8B%E5%80%BC">赋值操作</a>，包括：
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%8F%AF%E8%83%BD%E4%BD%BF%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%8C%85%E5%90%AB%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C">简单赋值</a>。</li>
<li><strong>注释</strong> 具体函数参见<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E8%83%BD%E4%BD%BF%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%8C%85%E5%90%AB%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E4%BF%AE%E6%94%B9%E5%87%BD%E6%95%B0">可能使对象中包含引用值的修改函数</a>。</li>
</ul>
</li>
<li>可直接修改<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>的操作，包括：
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>move!</code></a></li>
</ul>
</li>
</ul>
<h2 id="函数分类"><a class="header" href="#函数分类">函数分类</a></h2>
<p>　　本节对函数按名称和其它不同性质进行分类。</p>
<p>　　在 NPLA1 参照实现环境提供的函数具体详见根环境基本特性和基础派生特性。</p>
<p>　　除非另行指定，本节约定的函数属于 NPLA1 参照实现环境。</p>
<p>　　本节约定的函数提供的部分操作属于<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%80%BC%E4%BC%A0%E9%80%92%E7%BA%A6%E5%AE%9A">转发</a>。</p>
<p><strong>注释</strong></p>
<p>　　<a href="Features/NPL.zh-CN.html#%E8%BD%AC%E5%8F%91%E5%8F%82%E6%95%B0%E6%88%96%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%AE%9E%E7%8E%B0">转发参数或返回值的实现</a>中可使用 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>forward!</code></a>。</p>
<h3 id="可提供以引用标记字符结尾变体的函数"><a class="header" href="#可提供以引用标记字符结尾变体的函数">可提供以引用标记字符结尾变体的函数</a></h3>
<p>　　本节中的<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E6%8F%90%E4%BE%9B%E4%BB%A5%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%BB%93%E5%B0%BE%E5%8F%98%E4%BD%93%E7%9A%84%E6%93%8D%E4%BD%9C">可提供以引用标记字符结尾变体的操作</a>的以下分类不相交，但部分分类中<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E5%87%BD%E6%95%B0%E5%90%8D%E4%B8%8E%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E7%9A%84%E5%85%B3%E7%B3%BB">函数名不带有引用标记字符结尾的操作</a>可能和<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E6%8F%90%E4%BE%9B%E7%BB%93%E5%B0%BE%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E5%AF%B9%E5%BA%94%E5%8F%98%E4%BD%93%E7%9A%84%E5%87%BD%E6%95%B0">不提供结尾引用标记字符对应变体的函数</a>中的操作相交。</p>
<p>　　除非另行指定，符合以下分类的操作：</p>
<ul>
<li>不指定保留引用值时，不保留引用值。</li>
<li>指定保留引用值时，同指定<a href="Features/NPL.zh-CN.html#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E7%9B%AE%E6%A0%87">在结果中保留引用值</a>。</li>
<li>指定在结果中保留引用值时，根据结果是否为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">未指定值</a>，应总能直接区分<a href="Features/NPL.zh-CN.html#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%9D%A5%E6%BA%90">被保留的来源</a>和<a href="Features/NPL.zh-CN.html#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E7%9B%AE%E6%A0%87">目标</a>。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%80%BC%E7%BA%A6%E5%AE%9A">函数值约定</a>已指定函数值默认不保留引用值；这没有涵盖 <code>&lt;body&gt;</code> 的求值结果。</p>
<h4 id="可能使结果包含引用值的容器构造器函数"><a class="header" href="#可能使结果包含引用值的容器构造器函数">可能使结果包含引用值的容器构造器函数</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%BB%93%E6%9E%9C%E5%8C%85%E5%90%AB%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AE%B9%E5%99%A8%E6%9E%84%E9%80%A0%E5%99%A8">可能使结果包含引用值的容器构造器</a>包括：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E6%9C%89%E5%BA%8F%E5%AF%B9%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>cons</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E6%9C%89%E5%BA%8F%E5%AF%B9%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>cons%</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>wrap</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>wrap%</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>list</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>list%</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>list*</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>list*%</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>box</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>box%</code></a></li>
</ul>
<h4 id="可能使结果包含引用值的容器元素访问器函数"><a class="header" href="#可能使结果包含引用值的容器元素访问器函数">可能使结果包含引用值的容器元素访问器函数</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%BB%93%E6%9E%9C%E5%8C%85%E5%90%AB%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE%E5%99%A8">可能使结果包含引用值的容器元素访问器</a>包括<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">基本派生特性</a>中的以下操作：</p>
<ul>
<li><code>first</code></li>
<li><code>first@</code></li>
<li><code>first%</code></li>
<li><code>first&amp;</code></li>
<li><code>rest%</code></li>
<li><code>rest&amp;</code></li>
<li><code>restv</code></li>
</ul>
<p>　　注意 <code>restv</code> 和 <code>rest%</code> 总是构造列表，并不直接返回<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的引用（另见<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">引用值构造函数</a>）；其它访问器若带有引用标记字符，可直接返回引用值。</p>
<p>　　此外，标准库中的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%80%BC%E8%BD%AC%E5%8F%91%E5%87%BD%E6%95%B0">函数值转发操作</a>中部分函数也符合容器元素访问器的要求，但当前不提供带有后缀标记字符的变体。这些函数包括：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>unwrap</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>unbox</code></a></li>
</ul>
<h4 id="可能使对象中包含引用值的修改函数"><a class="header" href="#可能使对象中包含引用值的修改函数">可能使对象中包含引用值的修改函数</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E8%83%BD%E4%BD%BF%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%8C%85%E5%90%AB%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C">可能使对象中包含引用值的修改操作</a>包括：</p>
<ul>
<li>简单赋值：
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>assign@!</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>assign%!</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>assign!</code></a></li>
</ul>
</li>
<li>列表元素改变器：
<ul>
<li><a href="Features/NPL.zh-CN.html#%E6%9C%89%E5%BA%8F%E5%AF%B9%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>set-rest!</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E6%9C%89%E5%BA%8F%E5%AF%B9%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>set-rest%!</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>set-first!</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>set-first@!</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>set-first%!</code></a></li>
</ul>
</li>
</ul>
<h4 id="可能间接保留引用值的函数"><a class="header" href="#可能间接保留引用值的函数">可能间接保留引用值的函数</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E8%83%BD%E9%97%B4%E6%8E%A5%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C">可能间接保留引用值的操作</a>包括以求值 <code>&lt;body&gt;</code> 作为尾上下文的操作：</p>
<ul>
<li>结果是合并子或用于在环境中绑定合并子的构造器操作。</li>
<li><a href="Features/NPL.zh-CN.html#%E6%A0%B8%E5%BF%83%E5%BA%93">核心库函数</a>中的绑定操作。</li>
<li>在尾上下文中求值 <code>&lt;expression&gt;</code> 参数视为的 <code>&lt;object&gt;</code> 的函数，包括 <a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>eval@</code></a> 、<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>eval</code></a> 和 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>eval%</code></a>。</li>
</ul>
<p>　　参见<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">环境基本函数</a>和<a href="Features/NPL.zh-CN.html#%E6%A0%B8%E5%BF%83%E5%BA%93">核心库</a>。</p>
<p><strong>注释</strong></p>
<p>　　以上操作中的求值符合<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">词法闭包</a>规则。</p>
<h3 id="不提供结尾引用标记字符对应变体的函数"><a class="header" href="#不提供结尾引用标记字符对应变体的函数">不提供结尾引用标记字符对应变体的函数</a></h3>
<p>　　本节列举<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E6%8F%90%E4%BE%9B%E7%BB%93%E5%B0%BE%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E5%AF%B9%E5%BA%94%E5%90%8D%E7%A7%B0%E7%9A%84%E6%93%8D%E4%BD%9C">不提供结尾引用标记字符对应名称的操作</a>。</p>
<p><strong>注释</strong></p>
<p>　　派生实现中通常使用 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>forward!</code></a>进行<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91">转发</a>实现上述保证。</p>
<h4 id="可直接以引用值作为结果的函数"><a class="header" href="#可直接以引用值作为结果的函数">可直接以引用值作为结果的函数</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%9B%B4%E6%8E%A5%E4%BB%A5%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%9C%E4%B8%BA%E7%BB%93%E6%9E%9C%E7%9A%84%E6%93%8D%E4%BD%9C">可直接以引用值作为结果的操作</a>包括：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E6%8E%A7%E5%88%B6%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>$if</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$sequence</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$cond</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$when</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$unless</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$and</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$or</code></a></li>
</ul>
<h4 id="不以引用值作为结果的函数"><a class="header" href="#不以引用值作为结果的函数">不以引用值作为结果的函数</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E4%BB%A5%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%9C%E4%B8%BA%E7%BB%93%E6%9E%9C%E7%9A%84%E6%93%8D%E4%BD%9C">不以引用值作为结果的操作</a>的返回值总是按值传递的操作涉及的容器包括列表、<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">箱</a>或<a href="Features/NPL.zh-CN.html#%E5%B0%81%E8%A3%85%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">其它的封装类型</a>对象，包括：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>map1</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>list-concat</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>append</code></a></li>
</ul>
<h4 id="直接参数转发函数"><a class="header" href="#直接参数转发函数">直接参数转发函数</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%9B%B4%E6%8E%A5%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91%E6%93%8D%E4%BD%9C">直接参数转发操作</a>包括：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">合并子基本函数</a>：
<ul>
<li><code>unwrap</code></li>
</ul>
</li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">基本派生特性</a>：
<ul>
<li><code>accl</code></li>
<li><code>accr</code></li>
<li><code>foldr1</code></li>
<li><code>map1</code></li>
</ul>
</li>
</ul>
<p>　　基本派生特性和<a href="Features/NPL.zh-CN.html#%E6%A0%B8%E5%BF%83%E5%BA%93">核心库函数</a>中的绑定操作的非 <code>&lt;environment&gt;</code> 的形式参数支持转发。</p>
<p>　　参数形式上被转发但操作的语义并非总是转发到其它操作的操作不使用本节的名称约定，如以下仅有第二参数支持转发的操作是<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E6%8F%90%E4%BE%9B%E4%BB%A5%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%BB%93%E5%B0%BE%E5%8F%98%E4%BD%93%E7%9A%84%E5%87%BD%E6%95%B0">提供结尾引用标记字符对应名称的函数</a>，有<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">对象基本函数</a>中的：</p>
<ul>
<li><code>assign%!</code></li>
<li><code>assign@!</code></li>
</ul>
<p><strong>注释</strong></p>
<p>　　<code>map1</code> 同时是<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E4%BB%A5%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%9C%E4%B8%BA%E7%BB%93%E6%9E%9C%E7%9A%84%E5%87%BD%E6%95%B0">不以引用值作为结果的操作</a>。</p>
<h4 id="函数值转发函数"><a class="header" href="#函数值转发函数">函数值转发函数</a></h4>
<p>　　NPLA1 参照实现环境的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%80%BC%E8%BD%AC%E5%8F%91%E6%93%8D%E4%BD%9C">函数值转发操作</a>包括以下访问对象或<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>自身或<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的函数：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>unwrap</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>id</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>forward</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>forward!</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>unbox</code></a></li>
</ul>
<p>　　<a href="Features/NPL.zh-CN.html#%E6%A0%B9%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7">基本操作</a>的不具有名称的相关操作中参数和函数值原生支持的转发操作包括：</p>
<p>　　使用 <a href="Features/NPL.zh-CN.html#%E5%B0%81%E8%A3%85%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>make-encapsulation-type</code></a>返回的访问器合并子。</p>
<h4 id="可能间接保留引用值的函数-1"><a class="header" href="#可能间接保留引用值的函数-1">可能间接保留引用值的函数</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E8%83%BD%E9%97%B4%E6%8E%A5%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C">可能间接保留引用值的操作</a>包括：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>apply</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>apply-list</code></a></li>
</ul>
<h3 id="引用折叠相关函数"><a class="header" href="#引用折叠相关函数">引用折叠相关函数</a></h3>
<p>　　本节列举<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">引用折叠</a>相关操作。</p>
<p>　　只有<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D%E5%90%8E%E7%BC%80">函数名以 <code>@</code> 结尾</a>的函数可能引入<a href="Features/NPL.zh-CN.html#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">未折叠的引用值</a>，包括：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>assign@!</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>set-first@!</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>first@</code></a></li>
</ul>
<p>　　此外，在参数保留引用值的修改操作可能使现有的引用值成为未折叠的引用值，包括：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>assign@!</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>assign%!</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>set-first@!</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>set-first%!</code></a></li>
</ul>
<p>　　函数 <a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>uncollapsed?</code></a>区分未折叠的引用值。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0">蕴含左值到右值转换</a>的函数可以<a href="Features/NPL.zh-CN.html#%E5%B1%80%E9%83%A8%E9%97%B4%E6%8E%A5%E5%80%BC%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">消除引用值</a>，如：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>idv</code></a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>collapse</code></a></li>
</ul>
<p>　　其中，<code>collapse</code> 依赖 <code>uncollapsed?</code> 而针对未折叠的引用值消除引用值，实现引用折叠。</p>
<p>　　其它一些函数可能在非<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>中依赖未折叠引用但不在接口中体现，如 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>rulist</code></a> 。</p>
<h3 id="引用值构造函数"><a class="header" href="#引用值构造函数">引用值构造函数</a></h3>
<p>　　当前构造<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子对象引用</a>的操作有：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>unwrap</code></a>创建合并子的子对象引用。</li>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>rest&amp;</code></a> 创建列表的子对象引用。</li>
<li>使用带有<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">省略</a>的<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">形式参数树</a>（如 <a href="Features/NPL.zh-CN.html#%E6%9C%AA%E6%B1%82%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;formals&gt;</code></a>）绑定操作数为<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">结尾列表</a>，<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">创建列表的子对象引用</a>。</li>
</ul>
<h3 id="非引用值构造器函数"><a class="header" href="#非引用值构造器函数">非引用值构造器函数</a></h3>
<p>　　一些函数构造非引用值，包括：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">基本派生特性</a>转换函数：
<ul>
<li><code>$bindings/p-&gt;environment</code></li>
<li><code>$bindings-&gt;environment</code></li>
<li><code>symbols-&gt;imports</code></li>
</ul>
</li>
<li><a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E5%BA%93">续延库</a>转换函数：
<ul>
<li><code>continuation-&gt;applicative</code></li>
</ul>
</li>
</ul>
<p>　　其中，明确<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E4%B8%AD%E7%BC%80">转移而不是复制被转换的右值</a>的函数有：</p>
<ul>
<li><code>continuation-&gt;applicative</code></li>
</ul>
<h2 id="根环境基本特性"><a class="header" href="#根环境基本特性">根环境基本特性</a></h2>
<p>　　NPLA1 通过<a href="Features/NPL.zh-CN.html#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1">预定义对象</a>的形式提供<a href="Features/NPL.zh-CN.html#npla1-%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E6%89%A9%E5%B1%95%E7%8E%AF%E5%A2%83">可选的模块</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9D%97">根环境</a>基本特性是除了这些模块的以变量绑定形式提供的不要求可派生实现的特性。</p>
<p>　　根环境基本特性的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>包括<a href="Features/NPL.zh-CN.html#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">基础环境</a>提供的预定义对象和在<a href="Features/NPL.zh-CN.html#npla1-%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96">基础上下文</a>的根环境中初始化的<em>基础基本操作(grounded primitive operations)</em> 的实现。</p>
<p>　　派生实现可以通过提供不公开<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">不安全操作</a>的根环境，但不符合此处的<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">规格要求</a>。</p>
<p>　　若派生实现不提供<a href="Features/NPL.zh-CN.html#%E5%9C%A8%E5%87%BD%E6%95%B0%E5%80%BC%E4%B8%AD%E4%BF%9D%E7%95%99%E5%85%B6%E5%AE%83%E9%97%B4%E6%8E%A5%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0">在函数值中保留其它间接值的操作</a>，可以简化部分<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">对象基本函数</a>中与之关联的操作的实现。</p>
<p>　　当前在根环境中的直接提供绑定的特性不依赖 <a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B"><code>&lt;number&gt;</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　和 [R<sup>n</sup>RK] 不同，为简化设计，不提供可选(optional) 的合并子。</p>
<p>　　可选功能不应被必要功能依赖。</p>
<p>　　根环境的基本特性为组合其它实用特性提供，而数值在设计中不是必要的功能特性。</p>
<p>　　部分其它原理参见<a href="Features/NPL.zh-CN.html#%E6%A0%B9%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%B9%89">根环境对象定义</a>。关于引用值的处理另见<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%88%86%E7%B1%BB">函数分类</a>。</p>
<p><strong>注释</strong></p>
<p>　　部分可选的 Kernel 合并子被直接提供。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，一些函数显式地操作<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>，包括<a href="Features/NPL.zh-CN.html#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">未折叠的引用值</a>。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值算法</a>不直接处理对象的引用值。</p>
<p>　　为简化实现，部分提供 <a href="Features/NPL.zh-CN.html#%E5%8F%AF%E6%8F%90%E4%BE%9B%E4%BB%A5%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%BB%93%E5%B0%BE%E5%8F%98%E4%BD%93%E7%9A%84%E5%87%BD%E6%95%B0"><code>%</code> 等后缀的函数</a>不被派生。</p>
<p>　　因为设计原因，不提供以下 Kernel 合并子对应的操作：</p>
<ul>
<li><code>copy-es-immutable</code></li>
<li><code>inert?</code></li>
<li><code>ignore?</code></li>
</ul>
<p>　　考虑（可变对象的）一等引用和<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>绑定引用的的平摊复杂度，不提供需要同时转换不同层次子项的 <code>copy-es-immutable</code> 操作。</p>
<p>　　其它没有包含在以下节中的 Kernel 合并子对应的操作可能会在之后的版本中被支持。</p>
<h3 id="根环境对象定义"><a class="header" href="#根环境对象定义">根环境对象定义</a></h3>
<p>　　除<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9D%97">为提供根环境特性的模块</a>以外，当前根环境不定义对象。</p>
<p>　　以下各节引入的变量都表示操作。</p>
<h3 id="等价谓词基本函数"><a class="header" href="#等价谓词基本函数">等价谓词基本函数</a></h3>
<p><strong>模块约定：</strong></p>
<p>　　本节的操作不修改参数对象。</p>
<p>　　本节的操作的结果是 <code>&lt;boolean&gt;</code> 类型的纯右值。</p>
<p>　　用户定义的类型提供的等价谓词应满足和 NPLA1 提供的等价谓词的语义一致的等价关系，否则若谓词被求值，行为未指定。</p>
<p>　　一些具有<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">项节点</a>作为表示的对象的<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>具有递归相等性，仅当子对象符合以下递归相等关系：</p>
<ul>
<li>对不表示有序对的节点，同 <code>eqv?</code> 。</li>
<li>否则，同每个元素对应 <code>eqv?</code> 对应满足 <code>eqv?</code> 。</li>
</ul>
<p>　　判断子对象递归相等性的对象相等时，其续延未指定。</p>
<p>　　若右值之间 <code>eqv?</code> 比较结果是 <code>#t</code> ，<code>eq?</code> 比较结果未指定。</p>
<p><strong>操作：</strong></p>
<p><code>eq? &lt;object1&gt; &lt;object2&gt;</code></p>
<p>　　判断参数<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">同一</a>。</p>
<p>　　当且仅当两个参数是指定同一对象时，比较结果是 <code>#t</code> 。</p>
<p>　　<code>eq?</code> 的复杂度是 <tt>O(1)</tt> 。</p>
<p><code>eql? &lt;object1&gt; &lt;object2&gt;</code></p>
<p>　　判断表示参数的项的<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">值数据成员</a>相等。</p>
<p>　　忽略表示参数的项的值数据成员以外的子对象：若参数是列表，则视为空列表；若参数是有序对，则视为仅具有最后一个元素。</p>
<p>　　若参数是引用值，则被比较的项是表示它的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的项。</p>
<p>　　当且仅当被比较的项的值数据成员相等时，比较结果是 <code>#t</code> 。</p>
<p>　　值数据成员相等蕴含参数的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">动态类型</a><a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">相同</a>。</p>
<p><code>eqr? &lt;object1&gt; &lt;object2&gt;</code></p>
<p>　　判断表示参数的项的数据成员同一。</p>
<p>　　当且仅当表示被比较的项的值数据成员指定宿主语言中的同一对象（即引用相等）时，比较结果是 <code>#t</code> 。</p>
<p><code>eqv? &lt;object1&gt; &lt;object2&gt;</code></p>
<p>　　判断非<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">枝节点</a>表示的值相等。</p>
<p>　　若参数是引用值，则被比较的值是它的被引用对象。</p>
<p>　　根据项的内部表示：</p>
<ul>
<li>当表示值的项都是枝节点时，同 <code>eq?</code> 。</li>
<li>否则，若这两个参数的类型<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">不同</a>，则结果是 <code>#f</code> 。</li>
<li>否则，若这两个参数的 <code>eql?</code> 比较结果是 <code>#t</code> ，则结果是 <code>#t</code> 。</li>
</ul>
<p>　　若两个参数的 <code>eqv?</code> 比较结果是 <code>#f</code> ，则这两个参数以 <code>eq?</code> 比较结果总是 <code>#f</code> 。</p>
<p>　　除非<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>（参见以下描述）或派生实现另行指定，不<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">等价</a>的函数的 <code>eqv?</code> 比较结果是 <code>#f</code> 。</p>
<p>　　除以上规则确定的结果外，<code>eqv?</code> 对合并子或列表的比较结果未指定。</p>
<p>　　在互操作的意义上，当前 <code>eqv?</code> 定义的合并子的相等性由<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>的 <code>==</code> 或不影响可观察行为的其它宿主环境提供的 <code>==</code> 操作通过和 <code>eql?</code> 比较相同的方式确定。</p>
<p>　　除非另行指定，具有本文档引入的类型且不涉及互操作意义上用户自定义值的比较的操作数使用以上 <code>eq?</code> 以外的谓词比较的求值应保证能终止。</p>
<p><strong>原理</strong></p>
<p>　　除任何其它类型都可作为 <a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;object&gt;</code> 的子类型</a>，<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">开放类型映射</a>的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">类型系统</a>通常要求避免依赖 <code>&lt;object&gt;</code> 上的其它的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">良序和良基的理论</a>，以避免对现有类型系统的扩展时需要修改已有的类型的相关操作。</p>
<p>　　不需要依赖序的等价谓词可为<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义类型</a>提供直接的支持。</p>
<p>　　NPLA1 提供默认相等为<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">抽象相等</a>，对任意的值适用。</p>
<p>　　NPLA1 还提供对一等对象保证结果有意义的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">引用相等</a>操作。非一等实体的引用相等关系未指定。</p>
<p>　　当前 NPLA1 不支持 <a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">[EGAL]</a> ，因为 [EGAL] 要求存在分辨任意<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">对象的值</a>是否可被修改的元数据。</p>
<p>　　因为<a href="Features/../Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">对应等价的不变性</a>关系不具有<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">唯一性</a>，且可能允许不唯一的方式引起副作用（如缓存），和 [R<sup>n</sup>RK] 不同，不以基本操作提供 <code>equal?</code> 对任意对象提供一般的相等操作。</p>
<p>　　未指定 <code>eq?</code> 的比较结果可允许实现复用存储右值的<a href="Features/NPL.zh-CN.html#%E9%A9%BB%E7%95%99">驻留</a>对象。</p>
<p>　　<code>eql?</code> 实际比较宿主值的相等。允许 <code>eqv?</code> 和 <code>eql?</code> 的不同可允许<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">一对多的类型映射</a>下比较对象语言的值的相等。（而多对一的类型映射 <code>eql?</code> 和 <code>eqv?</code> 可一致地比较。）</p>
<p>　　但是，当前实现中，大多数一对多映射的类型（如环境）都没有引起使 <code>eql?</code> 和 <code>eqv?</code> 不同的比较实现，因为不同宿主值类型的对象具有足够显著的差异，在大多数上下文不通过一些具有不可忽略开销的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">转换机制</a>（如锁定<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境弱引用</a>转换为<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境强引用</a>），无法直接相互替换而保证行为差异可被忽略，因此逻辑上不适合定义为相等的。</p>
<p>　　而基于性能等理由，等其它一对多映射的类型（特别是可能基于宿主类型的值的子集的，如 <a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">NPLA 数值类型</a>中的 <code>&lt;integer&gt;</code> ）的值的比较也没有特别的处理，而引起 <code>eqv?</code> 和 <code>eql?</code> 的不同。</p>
<p>　　这些类型可能需要其它针对特定类型的等价谓词（如 <a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%AD%A6%E5%BA%93"><code>=?</code></a>）进行相等性的比较。</p>
<p>　　类似 [R<sup>n</sup>RS] ，不同类型决定 <code>eqv?</code> 的结果是 <code>#f</code> ，但此处类型相同的含义不通过<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB">类型分区</a>定义。</p>
<p>　　类似 [R<sup>n</sup>RS] ，行为不等价的函数的 <code>eqv?</code> 结果原则上应为 <code>#f</code> ，但这种等价性一般不可证明而无法保证，特别在关于语言实现以外的调用上。</p>
<p>　　为支持互操作使用<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>及避免限制合并子的子类型的<a href="Features/NPL.zh-CN.html#%E5%BC%80%E6%94%BE%E6%80%A7">开放性</a>，允许这些实现另行指定规则，假定引起程序可观察行为差异的函数调用调用名义等价。</p>
<p><strong>注释</strong></p>
<p>　　通常，等价谓词比较的求值应保证能终止且对非列表项和 <tt>n</tt> 个子项的列表分别具有 <tt>O(1)</tt> 和 <tt>O(n)</tt> 平摊复杂度。这是依赖数据结构实现的细节；语言不需要约束这个性质。</p>
<h3 id="控制基本函数"><a class="header" href="#控制基本函数">控制基本函数</a></h3>
<p><code>$if &lt;test&gt; &lt;consequent&gt; &lt;alternative&gt;</code></p>
<p>　　条件分支，按条件成立与否返回 <code>&lt;consequent&gt;</code> 或 <code>&lt;alternative&gt;</code> 之一，可能是引用值。</p>
<p><code>$if &lt;test&gt; &lt;consequent&gt;</code></p>
<p>　　省略第三操作数的条件分支，条件成立时返回 <code>&lt;consequent&gt;</code> 。</p>
<p>　　和 [R<sup>n</sup>RK] 不同而和 [R<sup>n</sup>RS] 类似，如 <code>&lt;test&gt;</code> 的求值结果非 <code>#f</code> 即选择 <code>&lt;consequent&gt;</code> ，且支持省略第三参数。</p>
<p>　　若省略 <code>&lt;alternative&gt;</code> 且 <code>&lt;test&gt;</code> 求值为 <code>#f</code> ，则<a href="Features/NPL.zh-CN.html#%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0">结果未指定</a> 。</p>
<p><strong>注释</strong></p>
<p>　　对 <code>&lt;test&gt;</code> 的处理的主要原理和 Kernel 的 <code>$and?</code> 不要求尾上下文的表达式求值检查类型一致。</p>
<p>　　若需要检查类型避免误用，可以派生提供其它函数；相反的派生无法利用更<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单</a>的实现。</p>
<p><strong>原理</strong></p>
<p>　　和 [R<sup>7</sup>RS] 类似，但和 [Racket] 及 [R<sup>n</sup>RK] 不同，省略 <code>&lt;alternative&gt;</code> 被支持。</p>
<p>　　和 [R<sup>7</sup>RK] 不同，不使用 <code>#inert</code> ，参见关于<a href="Features/NPL.zh-CN.html#%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0">参照实现接口描述</a>的原理。</p>
<p>　　和 [R<sup>n</sup>RK] 中的相关讨论结论不同，是否省略 <code>&lt;alternative&gt;</code> 的形式应是一致的。这是因为：</p>
<ul>
<li>NPLA1 不假设作为基本控制操作的 <code>$if</code> 的作用（仅要 <code>&lt;consequent&gt;</code> 或 <code>&lt;alternative&gt;</code> 求值的结果，或仅为了副作用）。</li>
<li><code>$if</code> 不假设用户对 <code>&lt;consequent&gt;</code> 和 <code>&lt;alternative&gt;</code> 顺序选择性偏好，以避免限制用户选择否定谓词简化 <code>&lt;test&gt;</code> ，从而支持<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>。</li>
</ul>
<p>　　此外，NPLA1 使用显式的 <code>&lt;expression-sequence&gt;</code>（而不是 <code>&lt;consequent&gt;</code> 和 <code>&lt;alternative&gt;</code> ）语法表示顺序求值，这不适合基本的控制操作子：</p>
<p>　　若分离二操作数和三操作数其它形式，则二操作数可以使用 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>&lt;expression-sequence&gt;</code> ，即 <code>$when</code></a> 。</p>
<p>　　但依赖 <code>&lt;expression-sequence&gt;</code> 的 <code>$when</code> 不应是比具有 <code>&lt;consequent&gt;</code> 的二操作数形式更基本的操作。</p>
<p>　　因此，仍然需要有 <code>$when</code> 以外的省略第三参数的基本控制操作子。基于<a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">统一性</a>，对应函数名仍然为 <code>$if</code> 。（尽管使用了相同的原则，这和 Kernel 的结论恰好相反。）</p>
<p>　　与此类似，和 <a href="https://stackoverflow.com/questions/10863192">[Racket] 的理由</a>不同，不因为 <code>$when</code> 提供只强调副作用的操作而取消 <code>$if</code> 的 <code>&lt;alternative&gt;</code> 。</p>
<p>　　NPLA1 不会如 [Racket] 一样在此避免遗漏 <code>&lt;alternative&gt;</code> 导致的非预期结果。这并不违反<a href="Features/NPL.zh-CN.html#%E9%80%82%E7%94%A8%E6%80%A7">适用性</a>，因为不使用 <code>&lt;alternative&gt;</code> 的结果非常显然，同时选择使用 <code>$if</code> 这样的基本控制操作而不是更特定派生控制操作或更高级的抽象已蕴含注意误用的必要性。</p>
<p>　　一般地，NPLA1 不提供强调只存在副作用的操作。返回未指定（而不要求被使用）的求值结果的情形<a href="Features/NPL.zh-CN.html#%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0">并不表示只有副作用</a>，因为副作用是否存在原则上依赖具体操作。这和 Kernel 的 <code>#inert</code> 以及 [Racket] 的 <code>#&lt;void&gt;</code> 值即便在实现上都一致，但含义不同。</p>
<p>　　另见 <code>$when</code> 的说明。</p>
<h3 id="对象基本函数"><a class="header" href="#对象基本函数">对象基本函数</a></h3>
<p><strong>模块约定：</strong></p>
<p>　　因为<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>的限制，列表左值只能引用完整的列表的对象，而不支持部分列表。</p>
<p>　　这影响 <code>set-rest!</code> 和 <code>set-rest%!</code> 的第一个参数。</p>
<p><strong>操作：</strong></p>
<p><code>null? &lt;object&gt;</code></p>
<p>　　判断操作数是否为空列表。</p>
<p><code>nullv? &lt;object&gt;</code></p>
<p>　　判断操作数是否为空列表纯右值。</p>
<p>　　同 <code>null?</code> ，但不支持引用值。</p>
<p><code>branch? &lt;object&gt;</code></p>
<p>　　判断操作数是否具有<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">枝节点</a>表示。</p>
<p><code>branchv? &lt;object&gt;</code></p>
<p>　　判断操作数是否为具有枝节点表示的纯右值。</p>
<p>　　同 <code>branch?</code> ，但不支持引用值。</p>
<p><code>pair? &lt;object&gt;</code></p>
<p>　　<code>&lt;pair&gt;</code> 的<a href="Features/NPL.zh-CN.html#%E8%B0%93%E8%AF%8D%E5%90%8D%E7%A7%B0%E5%90%8E%E7%BC%80">类型谓词</a>。</p>
<p><code>pairv? &lt;object&gt;</code></p>
<p>　　判断操作数是否为有序对纯右值。</p>
<p>　　同 <code>pair?</code> ，但不支持引用值。</p>
<p><code>symbol? &lt;object&gt;</code></p>
<p>　　<code>&lt;symbol&gt;</code> 的类型谓词。</p>
<p><code>reference? &lt;object&gt;</code></p>
<p>　　判断操作数是否为引用值。</p>
<p><code>unique? &lt;object&gt;</code></p>
<p>　　判断操作数是否为<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">唯一引用</a>。</p>
<p><code>modifiable? &lt;object&gt;</code></p>
<p>　　判断操作数是否为可修改对象或可修改对象的引用值。</p>
<p><code>temporary? &lt;object&gt;</code></p>
<p>　　判断操作数是否为<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>或临时对象的引用值。</p>
<p><code>bound-lvalue? &lt;object&gt;</code></p>
<p>　　判断操作数是否为被引用的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>左值。</p>
<p>　　绑定临时对象的引用类型的参数不被视为左值引用。</p>
<p>　　配合[<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>$resolve-identifier</code></a>和 <code>%</code> 引用标记<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">绑定</a>的变量，可确定实际参数是否为左值；参见 <code>$lvalue-identifier?</code>](#基本派生特性) 。</p>
<p>　　使用 <code>bound-lvalue?</code> 和 <code>&amp;</code> 引用标记字符绑定的变量，可确定实际参数是否为引用。</p>
<p><code>uncollapsed? &lt;object&gt;</code></p>
<p>　　判断操作数是否为未折叠的引用值。</p>
<p><code>deshare &lt;object&gt;</code></p>
<p>　　取指定对象取消共享的值。</p>
<p>　　同 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>idv</code></a> ，但显式转换操作数中具有共享持有者的<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">值数据成员</a>为不共享的值，且不转移<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主值</a>。</p>
<p><strong>原理</strong></p>
<p>　　因为提供<a href="Features/NPL.zh-CN.html#%E5%9C%A8%E5%87%BD%E6%95%B0%E5%80%BC%E4%B8%AD%E4%BF%9D%E7%95%99%E5%85%B6%E5%AE%83%E9%97%B4%E6%8E%A5%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0">在函数值中保留其它间接值的操作</a>，这个区别是必要的。否则，使用 <code>idv</code> 替代应不影响<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>。</p>
<p><code>as-const &lt;object&gt;</code></p>
<p>　　取指定对象的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">不可修改</a>的引用。</p>
<p>　　同 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>id</code></a> ，但当参数是引用值时，结果是和参数引用相同对象的不可修改的引用值。</p>
<p><code>expire &lt;object&gt;</code></p>
<p>　　取指定对象的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">消亡值</a>。</p>
<p>　　同 <code>id</code> ，但当参数是引用值时，结果是和参数引用相同对象的唯一引用。</p>
<p>　　可用于显式地指定之后被<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">转移</a>的对象，而不需要直接转移参数。</p>
<p>　　特别地，指定列表的引用值被转移时，不需要立即转移列表的每个元素，而允许之后通过<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>等方式选择转移的<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>。</p>
<p>　　可能包含立即转移的操作如 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>forward!</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　这不直接转移对象，而不是<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改操作</a>，<a href="Features/NPL.zh-CN.html#%E4%BF%AE%E6%94%B9%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E5%90%8E%E7%BC%80">函数名不以 <code>!</code> 结尾</a>。</p>
<p><strong>注释</strong></p>
<p>　　这个函数类似宿主语言标准库中作用在对象类型实际参数的 <code>std::move</code> ，可能减少没有经过<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4">复制消除</a>的<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">复制或转移</a>而改变使用这个函数的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">结果对象</a>的副作用。</p>
<p><code>move! &lt;object&gt;</code></p>
<p>　　转移对象。</p>
<p>　　若参数是不可修改的左值，则以复制代替转移；否则，直接转移<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">表示参数对象的项</a>。</p>
<p>　　结果是不经返回值转换的项。</p>
<p><strong>注释</strong> 另见<a href="Features/NPL.zh-CN.html#%E8%BD%AC%E7%A7%BB%E5%AF%BC%E8%87%B4%E7%9A%84%E4%BF%AE%E6%94%B9">转移的注意事项</a>。</p>
<p><code>transfer! &lt;object&gt;</code></p>
<p>　　转移对象。</p>
<p>　　同 <code>move!</code> ，但使用<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">对象的转移</a>，而不是<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">项的转移</a>，避免宿主对象转移消除而<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">允许调用宿主对象的转移构造函数</a>。</p>
<p><strong>注释</strong> 参数被转移后，和<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>等<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">引入实质化临时对象</a>时可能具有的转移的效果（仅在<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>时可见）可能相同。</p>
<p><code>ref&amp; &lt;object&gt;</code></p>
<p>　　取引用。</p>
<p>　　对引用值同 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>id</code></a> ；对具有共享持有者的值数据成员的对象也视为左值。通过后者构造的引用值不被检查。</p>
<p>　　取得的引用值是<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E5%AE%89%E5%85%A8%E5%BC%95%E7%94%A8%E5%80%BC">不安全引用值</a>。</p>
<p><strong>原理</strong></p>
<p>　　因为提供在函数值中保留其它间接值的操作，对共享持有者的值数据成员的对象使用不同的处理。否则，对引用值参数的情形，使用 <code>id</code> 替代应不影响可观察行为。</p>
<p><code>assign@! &lt;reference&gt; &lt;object&gt;</code></p>
<p>　　<a href="Features/NPL.zh-CN.html#%E8%B5%8B%E5%80%BC">赋值</a><code>&lt;reference&gt;</code> 的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>为指定对象的值，且 <code>&lt;object&gt;</code> 不<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0">蕴含左值到右值转换</a>且<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0">不被折叠</a>。</p>
<p>　　赋值被引用对象前首先检查 <code>&lt;reference&gt;</code> 是可修改的左值。</p>
<p>　　赋值对象直接<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>被引用的对象，但不<a href="Features/NPL.zh-CN.html#%E6%97%A0%E6%95%88%E5%8C%96">无效化</a>参数指定的引用。</p>
<p>　　支持修改 <code>&lt;reference&gt;</code> 指定的子对象引用的被引用对象。</p>
<p><strong>注释</strong> 被赋值替换的子对象的引用可被无效化。Scheme 的 <code>set!</code> 在 <a href="https://srfi.schemers.org/srfi-17/srfi-17.html">[SRFI-17]</a> 提供具有类似作用的支持，但第一操作数限于 set! 且为特定的过程调用；Kernel 没有类似的操作。另见<a href="Features/NPL.zh-CN.html#%E8%B5%8B%E5%80%BC">赋值的注意事项</a>。</p>
<h3 id="有序对基本函数"><a class="header" href="#有序对基本函数">有序对基本函数</a></h3>
<p><code>cons &lt;object1&gt; &lt;object2&gt;</code></p>
<p>　　构造参数指定的两个元素构成的有序对。</p>
<p>　　结果是 <code>&lt;pair&gt;</code> 类型的值。</p>
<p><strong>注释</strong></p>
<p>　　不保留 <code>&lt;object2&gt;</code> 的引用值，但这不涉及 <code>&lt;object2&gt;</code> 是有序对或有序对的引用值时其中可能具有的元素。</p>
<p>　　若 <code>&lt;object2&gt;</code> 中存在元素，直接被作为结果的元素，不经过返回值转换。</p>
<p><code>cons% &lt;object1&gt; &lt;object2&gt;</code></p>
<p>　　构造参数指定的两个元素构成的有序对，保留引用值。</p>
<p>　　同 <code>cons</code> ，但参数是引用值时，直接以其值作为元素的值，而不以其<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的值创建有序对。</p>
<p><strong>注释</strong> 这允许被构造的结果中存在和参数相等的引用值，而非其被引用对象的副本。</p>
<p><code>set-rest! &lt;pair&gt; &lt;object&gt;</code></p>
<p>　　修改列表的第一个以外的元素。</p>
<p><strong>注释</strong> 和 [R<sup>n</sup>RK] 的 set-cdr! 类似，但检查列表是左值，且不保留被添加元素中的引用值。</p>
<p><code>set-rest%! &lt;pair&gt; &lt;object&gt;</code></p>
<p>　　同 <code>set-rest!</code> ，但保留引用值。</p>
<p><strong>注释</strong> 和 [R<sup>n</sup>RK] 的 set-cdr! 类似，但检查列表是左值。</p>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RK] 不同，NPL 不支持列表中存在环。</p>
<p>　　不使用相同的对象左值的 <code>cons%</code> 调用或<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改操作</a>导致<a href="Features/NPL.zh-CN.html#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>，用户应自行避免<a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">未定义行为</a>。</p>
<p>　　结果具有的属性不被影响。</p>
<h3 id="符号基本函数"><a class="header" href="#符号基本函数">符号基本函数</a></h3>
<p><code>desigil &lt;symbol&gt;</code></p>
<p>　　移除符号中的引用标记字符 <a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6"><code>&amp;</code> 或 <code>%</code></a>。</p>
<p>　　判断符号非空且以 <code>&amp;</code> 或 <code>%</code> 起始，结果是移除起始字符的参数。否则，结果是参数。</p>
<p>　　不处理引用标记字符 <a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6"><code>@</code></a>。</p>
<h3 id="环境基本函数"><a class="header" href="#环境基本函数">环境基本函数</a></h3>
<p><strong>模块约定：</strong></p>
<p>　　为避免引入过于容易引入<a href="Features/NPL.zh-CN.html#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>，仅通过个别操作引入<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境强引用</a>：</p>
<ul>
<li><code>make-environment</code></li>
<li><code>lock-environment</code></li>
</ul>
<p><strong>操作：</strong></p>
<p><code>eval@ &lt;object&gt; &lt;environment&gt;</code></p>
<p>　　在参数指定的环境中求值，结果作为函数值。</p>
<p>　　<code>&lt;object&gt;</code> 在求值前被视为 <code>&lt;expression&gt;</code> 。</p>
<p>　　<code>&lt;object&gt;</code> 不<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0">蕴含左值到右值转换</a>。</p>
<p><code>eval-string% &lt;string&gt; &lt;environment&gt;</code></p>
<p>　　在参数指定的环境中求值作为外部表示的字符串。</p>
<p><strong>注释</strong></p>
<p>　　类似 <a href="http://klisp.org/docs/Environments.html#Environments">klisp 的同名操作</a>，但保留引用值。</p>
<p>　　不提供类似 <code>eval@</code> 的 <code>eval-string@</code> ，因为不论参数的值类别，求值总是依赖的参数字符串的值。</p>
<p><code>eval-unit &lt;string&gt;</code></p>
<p>　　规约字符串表示的翻译单元以求值。</p>
<p>　　直接使用当前环境，但其中求值不在<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">尾上下文</a>，也不改变当前续延。</p>
<p><strong>注释</strong></p>
<p>　　和 <code>eval-string%</code> 类似，但不支持指定环境，求值不在尾上下文，也不改变当前续延。</p>
<p>　　使用的实现环境可以是 <a href="Features/NPL.zh-CN.html#%E8%AF%8A%E6%96%AD">REPL</a> 环境。</p>
<p><code>bound? &lt;string&gt;</code></p>
<p>　　判断指定字符串对应的符号是否被绑定。</p>
<p><code>$resolve-identifier &lt;symbol&gt;</code></p>
<p>　　解析<a href="Features/NPL.zh-CN.html#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>中的标识符。</p>
<p>　　结果是解析结果中的项。</p>
<p><strong>注释</strong> 参数不按成员访问规则确定<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">值类别</a>，也不按<a href="Features/NPL.zh-CN.html#npla1-%E8%A7%84%E8%8C%83%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">解析名称表达式的规则确保结果总是左值</a>，可<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">保留消亡值</a>。</p>
<p><code>$move-resolved! &lt;symbol&gt;</code></p>
<p>　　转移解析标识符的对象。</p>
<p>　　和 <code>$resolve-identifier</code> 类似，但直接取<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>并尝试从环境中转移。</p>
<p>　　若环境被<a href="Features/NPL.zh-CN.html#%E5%86%BB%E7%BB%93">冻结</a>，则复制被绑定对象；否则，直接<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">转移对象的项</a>。</p>
<p>　　一般应仅用于被绑定的对象不需要再被使用时。</p>
<p><code>() copy-environment</code></p>
<p>　　递归复制当前环境。当前忽略特定的<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">父环境</a>。</p>
<p>　　结果是新创建的环境的强引用。</p>
<p><strong>警告</strong> 这个函数仅用于测试时示例构造环境，通常不应被用户程序使用，且可能在未来移除。未确定环境宿主值时可引起未定义行为。</p>
<p><code>freeze-environment! &lt;environment&gt;</code></p>
<p>　　冻结环境。</p>
<p>　　这个操作处理操作数指定的一等环境。</p>
<p><strong>注释</strong> 对<a href="Features/NPL.zh-CN.html#%E9%9A%90%E8%97%8F%E7%8E%AF%E5%A2%83">隐藏环境</a>初始化时的相同操作参见<a href="Features/NPL.zh-CN.html#%E5%86%BB%E7%BB%93">冻结操作</a>。</p>
<p><code>lock-environment &lt;environment&gt;</code></p>
<p>　　锁定环境：使用<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境弱引用</a>创建<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境强引用</a>。</p>
<p>　　检查参数是环境弱引用，若失败则引起<a href="Features/NPL.zh-CN.html#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型错误</a>。结果是对应的环境强引用。</p>
<p>　　强引用可能引起环境之间的不被检查的<a href="Features/NPL.zh-CN.html#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>，用户应自行避免<a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">未定义行为</a>。</p>
<p><code>make-environment &lt;environment&gt;...</code></p>
<p>　　创建以参数为父环境的环境。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，除对象类型外，没有对列表和绑定的附加检查。</p>
<p>　　结果是新创建的环境，是环境强引用，具有宿主值类型 <code>shared_ptr&lt;Environment&gt;</code> 。</p>
<p><code>weaken-environment &lt;environment&gt;</code></p>
<p>　　使用环境强引用创建环境弱引用。</p>
<p>　　检查参数是环境强引用，若失败则引起类型错误。结果是对应的环境弱引用。</p>
<p><strong>原理</strong> 因为 NPLA1 需要精确控制所有权而<a href="Features/NPL.zh-CN.html#%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5">不依赖 GC</a>，这可用于派生实现某些操作（如 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$sequence</code></a> 必要的）。</p>
<p><code>$def! &lt;definiend&gt; &lt;expressions&gt;</code></p>
<p>　　定义：修改当前环境中的绑定。满足<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>的约定。</p>
<p>　　<code>$def!</code> 和 <code>$defrec!</code> 在求值 <code>&lt;expressions&gt;</code> 后，进行<a href="Features/NPL.zh-CN.html#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>，确保环境没有被冻结后添加绑定。</p>
<p>　　对 <code>&lt;definiend&gt;</code> 中已存在的标识符的绑定，保证<a href="Features/NPL.zh-CN.html#%E9%87%8D%E7%BB%91%E5%AE%9A">直接替换对象的值，对象的引用不失效</a>。</p>
<p><strong>注释</strong></p>
<p>　　类似 [R<sup>n</sup>RK] ，对在 [<code>&lt;body&gt;</code>] 中某些未被直接求值的子表达式（如 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$lambda</code></a>的 <code>&lt;body&gt;</code>），因为其中的求值依赖 <code>$def!</code> 表达式求值后的环境，在之后仍可以实现递归。</p>
<p>　　类似 [R<sup>n</sup>RK] 的 <code>$define!</code> ，但绑定构造的约定存在不同规则。</p>
<p>　　求值 <code>&lt;body&gt;</code> 后进行类型检查和 [R<sup>n</sup>RK] 的 <code>$define!</code> 不同。</p>
<p>　　由于递归调用依赖环境中的绑定，修改以上定义引入的绑定后可影响被递归函数的调用。</p>
<p><code>$defrec! &lt;definiend&gt; &lt;expressions&gt;</code></p>
<p>　　递归定义：修改绑定，同 <code>$def!</code> ，但在绑定时针对 <code>&lt;definiend&gt;</code> 指定的<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">操作数树</a>中的绑定名称有附加的处理以支持直接递归。</p>
<p>　　除和 <code>$def!</code> 相同过程的常规绑定（求值 <code>&lt;expressions&gt;</code> 和绑定符号）外，支持<a href="Features/NPL.zh-CN.html#%E5%BC%BA%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">强递归绑定</a>，其操作数树的附加处理分为两阶段；每个阶段深度优先遍历 <code>&lt;definiend&gt;</code> 指定的操作数树，对每个符号进行附加处理：</p>
<ul>
<li>在常规绑定前，每个遍历的待绑定符号在目标环境（被定义影响的环境）中预先进行绑定，保证指称一个对默认对象的弱引用，其中默认对象具有调用总是抛出异常的<a href="Features/NPL.zh-CN.html#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">非真合并子</a>的值；和这个弱引用的共享的强引用被临时另行保存。</li>
<li>在常规绑定后，再次遍历操作数树，对每个实现支持的<a href="Features/NPL.zh-CN.html#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>的的值，替换之前在环境中保存的共享定义为默认对象的共享强引用，最后释放先前临时保存的默认对象的强引用。
<ul>
<li><strong>注释</strong> 这里的合并子包括<a href="Features/NPL.zh-CN.html#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">非真合并子</a>。</li>
</ul>
</li>
</ul>
<p>　　调用<a href="Features/NPL.zh-CN.html#%E5%BC%BA%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">默认对象</a>时：</p>
<ul>
<li>若默认对象的强引用存在，<a href="Features/NPL.zh-CN.html#%E5%BC%BA%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">引起错误</a>。</li>
<li>否则，违反生存期规则而具有未定义行为。
<ul>
<li><strong>注释</strong> 和 <a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E7%94%9F%E5%AD%98%E6%9C%9F">vau 抽象对环境的检查</a>类似，未定义行为不应被依赖。</li>
</ul>
</li>
</ul>
<p>　　常规绑定后转移未被 <code>&lt;expressions&gt;</code> 求值影响的绑定中的默认对象的所有权到环境中，但不影响绑定目标在对象语言中指称的值。</p>
<p>　　在环境中未被 <code>&lt;expressions&gt;</code> 求值替换的绑定，在 <code>$defrec!</code> 求值仍指称默认对象（而不会是持有<a href="Features/NPL.zh-CN.html#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">真合并子</a>的值），若被作为合并子<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">调用</a>，则显示存在循环递归调用。</p>
<p>　　和 <code>$def!</code> 不同，求值 <code>$defrec!</code> 的 <code>&lt;expressions&gt;</code> 前保证 <code>&lt;defindiend&gt;</code> 中的名称已存在默认定义，求值 <code>&lt;expressions&gt;</code> 可访问对应的名称而不因<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>失败而<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p><strong>注释</strong></p>
<p>　　和 <code>$def!</code> 不同，即使不计绑定修改环境的副作用，常规绑定后的操作使 <code>&lt;expressions&gt;</code> 不在尾上下文求值。</p>
<p>　　这允许递归定义的名称在绑定完成前指称对象。例如，派生<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">标准环境</a>，当前环境中未绑定变量 <code>a</code> 和 <code>b</code> 时：</p>
<ul>
<li>求值表达式 <code>$def! (a b) list b ($lambda () 1)</code> 因为被求值的 <code>b</code> 未被绑定而引起错误。</li>
<li>求值表达式 <code>$defrec! (a b) list b ($lambda () 1)</code> 不需要 <code>a</code> 或 <code>b</code> 已被绑定（即便 <code>b</code> 并不在 <code>$lambda</code> 的 <code>&lt;body&gt;</code> 中），求值后 <code>a</code> 为默认对象。</li>
<li>求值表达式 <code>$defrec! (b &amp;a) list ($lambda () 1) b</code> 绑定要求同上，但求值后 <code>a</code> 可能为默认对象（操作数树中的同级叶节点被未指定的绑定顺序影响）。</li>
</ul>
<p>　　这也允许在 <a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>$vau/e</code></a>等表达式的 <code>&lt;environment&gt;</code> 指定的静态环境使 <code>&lt;body&gt;</code> 不能访问目标环境时，直接定义递归函数。</p>
<p>　　递归定义的对象中的<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">值数据成员</a>可能具有共享的持有者。若为合并子，直接调用会利用替换的值重新访问所在的环境。复制和转移这样的值不会改变被访问的环境。若访问的环境失效，则抛出异常，或无限递归调用自身。</p>
<p>　　特定情形使用 <a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>deshare</code></a>可去除共享和避免以上可能非预期的行为。</p>
<p>　　另见]环境](#npla1-环境)。</p>
<h3 id="合并子基本函数"><a class="header" href="#合并子基本函数">合并子基本函数</a></h3>
<p>　　和 [R<sup>n</sup>RS] 及 [R<sup>n</sup>RK] 不同，<code>&lt;body&gt;</code> 可以是多个项，而不再派生另外的变体支持顺序求值。</p>
<p>　　引入合并子的操作子不求值 <code>&lt;body&gt;</code> ，后者在被调用时替换操作数以后被求值。这允许安全地使用 <code>$def!</code> 而不需要 <code>$defrec!</code> 进行<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">递归绑定</a>。</p>
<p>　　检查失败的<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">错误</a>是（可能依赖<a href="Features/NPL.zh-CN.html#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型错误</a>的）<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">语法错误</a>。</p>
<p><code>$vau/e &lt;parent&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　创建指定静态环境的 <a href="Features/NPL.zh-CN.html#vau-%E6%8A%BD%E8%B1%A1">vau 抽象</a>。</p>
<p>　　创建的对象是<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">操作子</a>。</p>
<p><code>$vau/e% &lt;parent&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$vau/e</code> ，但保留引用值。</p>
<p><code>wrap &lt;combiner&gt;</code></p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">包装</a>合并子为<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">应用子</a>。</p>
<p>　　包装应用子可能符合<a href="Features/NPL.zh-CN.html#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">包装数溢出的错误条件</a> 。</p>
<p><code>wrap% &lt;combiner&gt;</code></p>
<p>　　同 <code>wrap</code> ，但参数不蕴含左值到右值转换，<a href="Features/NPL.zh-CN.html#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E7%9B%AE%E6%A0%87">在结果中保留引用值</a>。</p>
<p><code>unwrap &lt;applicative&gt;</code></p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">解包装</a>应用子为<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">底层合并子</a>。</p>
<p>　　左值参数解包装的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">结果是合并子的子对象引用</a>。</p>
<p><strong>原理</strong></p>
<p>　　指定 <code>&lt;parent&gt;</code> 作为静态环境可通过被绑定实体的所有权控制一等对象的生存期。同时，在没有 safe-for-space 保证时，仍可有效避免<a href="Features/NPL.zh-CN.html#ptr">资源泄漏</a> 。</p>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RK] 不同，因为支持保存环境的所有权，提供 <code>$vau/e</code> 作为比 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$vau</code></a> 更基本的操作。</p>
<p>　　不考虑所有权时，<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>eval</code></a> 和 <code>$vau</code> 可派生 <code>$vau/e</code> 。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，参数是右值时解包装的<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>被复制。由这些合并子创建的操作子当前仍不足以取代内置的一等操作子，因为不支持只能转移而不能复制的对象。传递这些对象作为操作数会引起构造失败的异常。</p>
<h3 id="错误处理和检查基本函数"><a class="header" href="#错误处理和检查基本函数">错误处理和检查基本函数</a></h3>
<p>　　以下函数提供<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">错误处理</a>的相关支持。</p>
<p><code>raise-error &lt;string&gt;</code></p>
<p>　　<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%82%E5%B8%B8">引发</a>表示错误的<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%82%E5%B8%B8">异常</a>。</p>
<p><code>raise-invalid-syntax-error &lt;string&gt;</code></p>
<p>　　引发包含参数指定的字符串内容的<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">语法错误</a>。</p>
<p><code>raise-type-error &lt;string&gt;</code></p>
<p>　　引发包含参数指定的字符串内容的<a href="Features/NPL.zh-CN.html#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型错误</a>。</p>
<p><code>check-list-reference &lt;object&gt;</code></p>
<p>　　检查对象是否是列表引用：若检查通过转发参数作为结果，否则引发错误对象。</p>
<p><code>check-pair-reference &lt;object&gt;</code></p>
<p>　　检查对象是否是有序对引用：若检查通过转发参数作为结果，否则引发错误对象。</p>
<h3 id="封装基本函数"><a class="header" href="#封装基本函数">封装基本函数</a></h3>
<p><code>() make-encapsulation-type</code></p>
<p>　　创建封装类型。</p>
<p>　　和 [R<sup>n</sup>RK] 类似，结果是三个合并子组成的列表，其元素分别表示用于构造封装类型对象的<em>封装(encapsulate)</em> 构造器、判断封装类型的谓词和用于<em>解封装(decapsulate)</em> 的访问器：</p>
<ul>
<li>构造器直接使用参数，在结果（构造的封装对象）中保留参数的引用值，类似<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%BB%93%E6%9E%9C%E5%8C%85%E5%90%AB%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AE%B9%E5%99%A8%E6%9E%84%E9%80%A0%E5%99%A8%E5%87%BD%E6%95%B0">可能使结果包含引用值的容器构造器函数</a>中<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%BB%93%E6%9E%9C%E5%8C%85%E5%90%AB%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AE%B9%E5%99%A8%E6%9E%84%E9%80%A0%E5%99%A8">带有 <code>%</code> 的容器构造器</a>。</li>
<li>访问器根据参数的值类别转发被封装的值。</li>
</ul>
<p>　　创建的封装类型支持判断相等（参见 <a href="Features/NPL.zh-CN.html#%E7%AD%89%E4%BB%B7%E8%B0%93%E8%AF%8D%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>eqv?</code></a>），相等定义为被封装的对象的<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的<a href="Features/NPL.zh-CN.html#%E7%AD%89%E4%BB%B7%E8%B0%93%E8%AF%8D%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">递归相等性</a>。</p>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RK] 不同，使用构造器初始化封装的对象作为容器，具有作为其子对象的被封装的对象的所有权。</p>
<p>　　需要注意保存被构造的封装对象。</p>
<p>　　另见 <a href="https://small.r7rs.org/wiki/UniqueTypesSnellPym/">Unique Types</a> 和 <a href="https://srfi.schemers.org/srfi-137/srfi-137.html">[SRFI-137]</a> 。</p>
<p>　　和 [R<sup>n</sup>RK] 及 [R<sup>n</sup>RS] 的各种实现（如<a href="http://www.r6rs.org/r6rs-editors/2005-August/000831.html">这里</a>提到的）不同，对相同类型的封装对象，<code>eqv?</code> 和 <code>equal?</code> 基于被封装对象的子对象（及子对象被引用的对象）递归比较，即使用封装的对象的 equal? 定义 eqv? 结果。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">等价谓词的设计用例</a>。</p>
<h2 id="基础派生特性"><a class="header" href="#基础派生特性">基础派生特性</a></h2>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%BA%93%E6%8E%A5%E5%8F%A3%E7%BA%A6%E5%AE%9A">根环境特性</a>中，除<a href="Features/NPL.zh-CN.html#%E6%A0%B9%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7">根环境基本特性</a>的剩余接口是<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%BA%A6%E5%AE%9A">派生特性</a>。其中在基础环境中提供的特性是<em>基础派生特性(grounded derived feature)</em> 。</p>
<h3 id="基本派生特性"><a class="header" href="#基本派生特性">基本派生特性</a></h3>
<p>　　基本派生特性可使用派生实现。这可能蕴含使用根环境基本特性或已在基本派生特性中提供的特性中的部分非派生实现。</p>
<p><strong>模块约定：</strong></p>
<p>　　引入合并子的操作子对 <code>&lt;body&gt;</code> 的约定同<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">合并子基本函数</a>。</p>
<p>　　因互相依赖，一些操作实现为派生操作时，不能用于直接派生特定一些其它操作。</p>
<p>　　和 <a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>$vau/e</code> 或 <code>$vau/e%</code></a>以及 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$lambda/e</code> 或 <code>$lambda/e%</code></a>不同，不指定静态环境的合并子构造器隐含总是使用<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境弱引用</a>形式的静态环境，以避免过于容易引入<a href="Features/NPL.zh-CN.html#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>。</p>
<p>　　本节约定以下<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">求值得到的操作数</a>：</p>
<ul>
<li><code>&lt;box&gt;</code> ：<em>箱(box)</em> ：可包含<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>的容器。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　注意 <code>$let</code> 等函数的 <code>&lt;body&gt;</code> 形式和 [R<sup>n</sup>RK] 不同。</p>
<p><strong>操作：</strong></p>
<p><code>eval &lt;object&gt; &lt;environment&gt;</code></p>
<p>　　同 <a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>eval@</code></a> ，但 <code>&lt;object&gt;</code> <a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0">蕴含左值到右值转换</a>且不保留引用值。</p>
<p><strong>注释</strong></p>
<p>　　若 <code>&lt;object&gt;</code> 为元素中有引用值的列表，元素不会被特殊处理，<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0">不蕴含左值到右值转换</a>。</p>
<p>　　[R<sup>n</sup>RK] 中同名合并子的第一参数为 <code>&lt;expression&gt;</code> ，但这不是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">已求值的操作数</a>的类型。</p>
<p><code>eval% &lt;object&gt; &lt;environment&gt;</code></p>
<p>　　同 <code>eval@</code> ，但 <code>&lt;object&gt;</code> 蕴含左值到右值转换。</p>
<p><strong>注释</strong> 同 <code>eval</code> ，但保留引用值。</p>
<p><code>eval-string &lt;string&gt; &lt;environment&gt;</code></p>
<p>　　同 <a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>eval-string</code></a> ，但不保留引用值。</p>
<p><code>() get-current-environment</code></p>
<p>　　取<a href="Features/NPL.zh-CN.html#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>：取当前环境的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">弱引用</a>。</p>
<p><strong>注释</strong></p>
<p>　　派生需要非派生实现的 <code>$vau/e</code> 。</p>
<p><code>() lock-current-environment</code></p>
<p>　　锁定当前环境：取当前环境的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">强引用</a>。</p>
<p><code>$vau &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　创建 <a href="Features/NPL.zh-CN.html#vau-%E6%8A%BD%E8%B1%A1">vau 抽象</a>。</p>
<p>　　类似 <a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>$vau/e</code></a>，但以当前环境代替额外的求值环境作为静态环境。</p>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RK] 不同，可通过 <a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>$vau/e</code></a>和（非派生的）<code>get-current-environment</code> 派生，不是<a href="Features/NPL.zh-CN.html#%E6%A0%B9%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7">基本操作</a>。</p>
<p><code>$vau% &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$vau</code>，但保留引用值。</p>
<p><code>$quote &lt;expression&gt;</code></p>
<p>　　求值引用操作。结果是<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>后的未被求值的操作数。</p>
<p>　　考虑通常引用操作对符号类型未被求值的左值操作数使用，保留引用值没有意义，因此不提供对应保留引用值的操作。</p>
<p><code>id &lt;object&gt;</code></p>
<p>　　结果是不蕴含左值到右值转换的参数，在结果中保留引用值。</p>
<p>　　其作用等价返回值转换，<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87">可能引起对象转移</a>。</p>
<p><code>idv &lt;object&gt;</code></p>
<p>　　同 <code>id</code> ，但结果是返回值转换后的值。</p>
<p><strong>注释</strong> 使用 <code>idv</code> 可指定在函数值中<a href="Features/NPL.zh-CN.html#%E5%9C%A8%E5%87%BD%E6%95%B0%E5%80%BC%E4%B8%AD%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C">保留引用值的不安全操作</a> 的个别操作数不再保留引用值。</p>
<p><code>list .&lt;object&gt;...</code></p>
<p>　　创建列表（类型为 <code>&lt;list&gt;</code> ）对象。结果是操作数的元素经蕴含左值到右值转换的值。</p>
<p>　　<code>list</code> 的<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">底层合并子</a>接受 <code>&lt;pair&gt;</code>（而不要求是列表）作为函数合并对象，结果的类型是 <code>&lt;pair&gt;</code> 而不一定是 <code>&lt;list&gt;</code> 。</p>
<p><strong>注释</strong> 除元素的转换，类似 [R<sup>n</sup>RK] 的 <code>list</code> 。</p>
<p><code>$lvalue-identifier? &lt;symbol&gt;</code></p>
<p>　　解析当前环境中的标识符（同 <a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>$resolve-identifier</code></a>）并判断是否为左值（同 <a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>bound-lvalue?</code></a>）。</p>
<p><code>$expire-rvalue &lt;symbol&gt;</code></p>
<p>　　解析当前环境中的标识符，判断是否为左值（同 <code>$lvalue-identifier?</code> ），取对应的转换操作：</p>
<ul>
<li>若判断为左值，则转换操作同 <code>id</code> 。</li>
<li>否则，则转换操作同 <a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>expire</code></a> 。</li>
</ul>
<p>　　结果是在根环境求值转换操作对应的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E7%BA%A6%E5%AE%9A">函数名</a>得到的引用值。</p>
<p><strong>注释</strong> 结果相同即以 <a href="Features/NPL.zh-CN.html#%E7%AD%89%E4%BB%B7%E8%B0%93%E8%AF%8D%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>eq?</code></a> 和对应的值比较结果为 <code>#t</code> 。</p>
<p><code>forward! &lt;object&gt;</code></p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%80%BC%E8%BD%AC%E5%8F%91">转发</a><a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%80%BC%E8%BD%AC%E5%8F%91%E5%87%BD%E6%95%B0">可能是引用的值</a>。</p>
<p>　　转移可修改的右值操作数（包括消亡值和临时对象）。</p>
<p>　　其中，需转移时，使用使用<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">项的转移</a>。这和<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">对象的转移</a>不同，不保证调用宿主环境的转移构造函数。</p>
<p><strong>原理</strong> 和宿主语言不同，直接转移允许区分消亡值和纯右值，同等地作为一等对象（如作为列表的元素）。</p>
<p><strong>注释</strong></p>
<p>　　被转发的值若是<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">形式参数树</a>中的变量，一般应以<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">带有标记字符 <code>&amp;</code> 的形式绑定</a>；否则，转发的不是对应的实际参数，而可能是其按值绑定的副本。</p>
<p>　　这个函数类似宿主语言以对象类型参数和推断的函数参数类型作为模板参数调用 <code>std::forward</code> ，但若需转移，直接转移而非如 <a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>expire</code></a>返回指定结果是<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">消亡值</a>的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">唯一引用</a>。</p>
<p><code>list% .&lt;object&gt;...</code></p>
<p>　　同 <code>list</code> ，但每个参数都不蕴含左值到右值转换，<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%BB%93%E6%9E%9C%E5%8C%85%E5%90%AB%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AE%B9%E5%99%A8%E6%9E%84%E9%80%A0%E5%99%A8">在结果中保留参数的引用值</a>。</p>
<p>　　<code>list%</code> 的底层合并子接受 <code>&lt;pair&gt;</code> 作为操作数（而不要求是列表），结果的类型是 <code>&lt;pair&gt;</code> 而不一定是 <code>&lt;list&gt;</code> 。</p>
<p><strong>注释</strong> 类似 [R<sup>n</sup>RK] 的 <code>list</code> 。</p>
<p><code>rlist &lt;list&gt;</code></p>
<p>　　转换参数为引用列表元素的列表。</p>
<p>　　若参数是左值，则结果是参数的元素的左值引用值构成的列表；否则，结果同 <code>idv</code> 。</p>
<p><code>$remote-eval &lt;expression&gt; &lt;environment&gt;</code></p>
<p>　　在动态环境求值第二参数得到的环境中求值第一参数，结果作为函数值。</p>
<p><code>$remote-eval% &lt;expression&gt; &lt;environment&gt;</code></p>
<p>　　同 <code>$remote-eval</code> ，但保留引用值。</p>
<p><code>$deflazy! &lt;definiend&gt; &lt;expressions&gt;</code></p>
<p>　　修改绑定。</p>
<p>　　同 <code>$def!</code> ，但不求值参数；在添加绑定前仍<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">对冻结环境进行检查</a>。</p>
<p><code>$set! &lt;environment&gt; &lt;definiend&gt; &lt;expressions&gt;</code></p>
<p>　　设置：修改指定环境的变量绑定。</p>
<p>　　在当前环境求值 <code>&lt;environment&gt;</code> 和 <code>&lt;body&gt;</code> ，再以后者的求值结果修改前者的求值结果指定的环境中的绑定。绑定效果同使用 <a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">`$def!</a>。</p>
<p>　　类似 [R<sup>n</sup>RK] 的 <code>$set!</code> ，但明确使用 <code>&lt;definiend&gt;</code> 而不是 <code>&lt;formals&gt;</code> 。注意 <code>&lt;body&gt;</code> 的形式不同。允许的递归操作参见 <code>$def!</code> 。</p>
<p>　　和 [R<sup>n</sup>RK] 不同而和 NPLA1 的 <code>$def!</code> 等类似，在修改绑定前对冻结环境进行检查。</p>
<p><code>$setrec! &lt;environment&gt; &lt;definiend&gt; &lt;expressions&gt;</code></p>
<p>　　递归设置：修改指定环境的绑定，绑定效果同使用 <a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>$defrec!</code></a>。</p>
<p>　　同 <code>$set!</code> ，但允许不同的递归操作。</p>
<p><strong>注释</strong> 参见 <code>$defrec!</code> 。</p>
<p><code>$wvau &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　创建包装的 <a href="Features/NPL.zh-CN.html#vau-%E6%8A%BD%E8%B1%A1">vau 抽象</a>。</p>
<p>　　同 <code>$vau</code> ，但创建的是调用时对操作数的元素求值一次的<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">应用子</a>。</p>
<p>　　参数的作用同 <code>$vau</code> 的对应参数。</p>
<p><code>$wvau% &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$wvau</code> ，但允许函数体求值返回引用值。</p>
<p><code>$wvau/e &lt;parent&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$wvau</code> ，但支持显式指定求值环境参数作为静态环境。</p>
<p><code>$wvau/e% &lt;parent&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$wvau/e</code> ，但保留引用值。</p>
<p><code>$lambda &lt;formals&gt; &lt;body&gt;</code></p>
<p>　　创建 <a href="Features/NPL.zh-CN.html#%CE%BB-%E6%8A%BD%E8%B1%A1">λ 抽象</a>。</p>
<p>　　同 <code>$vau</code> ，但创建的是调用时对操作数的元素求值一次的应用子，且忽略动态环境。</p>
<p><strong>注释</strong> 可通过 vau 抽象或 <code>$lambda/e</code> 和（非派生的）<code>get-current-environment</code> 派生。</p>
<p>　　除未提供的 <code>&lt;eformal&gt;</code> ，参数的作用同 <code>$vau</code> 的对应参数。</p>
<p><code>$lambda% &lt;formals&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$lambda</code> ，但允许函数体求值返回引用值。</p>
<p><code>$lambda/e &lt;parent&gt; &lt;formals&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$lambda</code> ，但支持显式指定求值环境参数作为静态环境。</p>
<p><code>$lambda/e% &lt;parent&gt; &lt;formals&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$lambda/e</code> ，但保留引用值。</p>
<p><code>list? &lt;object&gt;</code></p>
<p>　　<code>&lt;list&gt;</code> 的<a href="Features/NPL.zh-CN.html#%E8%B0%93%E8%AF%8D%E5%90%8D%E7%A7%B0%E5%90%8E%E7%BC%80">类型谓词</a>。</p>
<p>　　若参数是列表或非真列表，时间复杂度不大于 <tt>O(n)</tt> ，其中 <tt>n</tt> 是其中的元素数。</p>
<p><strong>注释</strong> 本机实现可实现 <tt>O(1)</tt> 时间复杂度。</p>
<p><code>list* &lt;object&gt;+</code></p>
<p>　　在列表前附加元素创建对象或有序对。</p>
<p>　　类似 <code>cons</code> ，但支持一个和多个参数。</p>
<p>　　对一个参数的情形结果同参数，否则结果同右结合嵌套调用参数的数量减 1 次的 <code>cons</code> 。</p>
<p><strong>注释</strong> 一个参数的情形结果经<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">返回值转换</a>。因为不需要如 Kernel 支持派生 <code>$vau</code> ，可直接使用 <code>apply</code> 派生；但因底层合并子还需检查列表，所以可使用 <code>apply-list</code> 。而和 <code>apply-list</code> 内部共用实现的派生可能更高效。</p>
<p><code>list*% &lt;object&gt;+</code></p>
<p>　　同 <code>list*</code> ，但创建有序对类似 <code>cons%</code> ，且元素保留引用值。</p>
<p><strong>注释</strong> 一个参数的情形结果不经返回值转换。</p>
<p><code>apply &lt;applicative&gt; &lt;object&gt; &lt;environment&gt;?</code></p>
<p>　　转发第一参数指定的应用子和第二参数指定的参数构成<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>，在环境中<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">应用</a>。其中，环境是：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">新环境</a>，若第二参数不存在。</li>
<li>否则，第二参数指定的环境。</li>
</ul>
<p><strong>注释</strong> 检查 <code>&lt;environment&gt;</code> 和 [R<sup>n</sup>RK] 的参考派生不同。</p>
<p>　　<code>apply</code> 的函数值保留引用值。</p>
<p><code>apply-list &lt;applicative&gt; &lt;list&gt; &lt;environment&gt;?</code></p>
<p>　　转发第一参数指定的应用子和第二参数指定的<a href="Features/NPL.zh-CN.html#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">参数列表</a>构成函数合并，在环境中应用。其中，环境同 <code>apply</code> 中的方式指定。</p>
<p>　　同 <code>apply</code> ，但首先检查第二参数的类型，若失败则<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">引发错误</a>。</p>
<p><code>$sequence &lt;expression-sequence&gt;</code></p>
<p>　　顺序求值。</p>
<p>　　操作数非空时结果是最后的参数，可能是引用值。</p>
<p><strong>注释</strong> 类似 [R<sup>n</sup>RK] 的同名操作子。</p>
<p>　　求值每个 <code>&lt;object&gt;</code> 的副作用包括其中<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的销毁都被顺序限制。</p>
<p><strong>注释</strong> 这类似宿主语言的语句而不是保证子表达式中的临时对象的生存期延迟到完全表达式求值结束的逗号表达式。这也允许实现和 [R<sup>n</sup>RK] 同名操作类似的 PTC 要求。</p>
<p><code>collapse &lt;object&gt;</code></p>
<p>　　折叠可能是引用的值。</p>
<p><code>forward &lt;object&gt;</code></p>
<p>　　转发可能是引用的非临时对象的值。</p>
<p>　　同 <code>forward!</code> ，但对可修改的临时对象操作数，使用复制代替转移。</p>
<p><strong>注释</strong></p>
<p>　　按在所在的环境中解析的操作数的类型<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">可选地进行返回值转换</a>作为结果，其作用 <code>id</code> 或 <code>idv</code> 之一。</p>
<p>　　转移（而不是复制）可修改的右值操作数。</p>
<p>　　若右值操作数不可修改，复制不可复制构造的宿主对象会失败。</p>
<p><code>assign%! &lt;reference&gt; &lt;object&gt;</code></p>
<p>　　同 <a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>assign@!</code></a>，但 <code>&lt;object&gt;</code> 是引用值时赋值的源操作数是 <code>&lt;object&gt;</code> 折叠后的值。</p>
<p><code>assign! &lt;reference&gt; &lt;object&gt;</code></p>
<p>　　同 <code>assign%!</code> ，但 <code>&lt;object&gt;</code> 蕴含左值到右值转换。</p>
<p><strong>注释</strong></p>
<p>　　因为左值到右值转换，即便 <code>&lt;object&gt;</code> 指定的值来自 <code>&lt;reference&gt;</code> ，也可赋值而不因此引起未定义行为。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E8%B5%8B%E5%80%BC">赋值的注意事项</a>。</p>
<p><code>$defv! &lt;variable&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　绑定 vau 抽象，等价 <code>$def! &lt;variable&gt; $vau &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code> 。</p>
<p><code>$defv%! &lt;variable&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　绑定 vau 抽象，等价 <code>$def! &lt;variable&gt; $vau% &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code> 。</p>
<p><code>$defv/e! &lt;variable&gt; &lt;parent&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　绑定指定静态环境的 vau 抽象，等价 <code>$def! &lt;variable&gt; $vau/e &lt;parent&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code> 。</p>
<p><code>$defv/e%! &lt;variable&gt; &lt;parent&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　绑定指定静态环境的 vau 抽象，等价 <code>$def! &lt;variable&gt; $vau/e% &lt;parent&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code> 。</p>
<p><code>$defw! &lt;variable&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　绑定包装的 vau 抽象，等价 <code>$def! &lt;variable&gt; $wvau &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code> 。</p>
<p><code>$defw%! &lt;variable&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　绑定包装的 vau 抽象，等价 <code>$def! &lt;variable&gt; $wvau% &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code> 。</p>
<p><code>$defw/e! &lt;variable&gt; &lt;parent&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　绑定包装的指定静态环境的 vau 抽象，等价 <code>$def! &lt;variable&gt; $wvau/e &lt;parent&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code> 。</p>
<p><code>$defw/e%! &lt;variable&gt; &lt;parent&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　绑定包装的指定静态环境的 vau 抽象，等价 <code>$def! &lt;variable&gt; $wvau/e% &lt;parent&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code> 。</p>
<p><code>$defl! &lt;variable&gt; &lt;formals&gt; &lt;body&gt;</code></p>
<p>　　绑定 λ 抽象，等价 <code>$def! &lt;variable&gt; $lambda &lt;formals&gt; &lt;body&gt;</code> 。</p>
<p><code>$defl%! &lt;variable&gt; &lt;formals&gt; &lt;body&gt;</code></p>
<p>　　绑定 λ 抽象，等价 <code>$def! &lt;variable&gt; $lambda% &lt;formals&gt; &lt;body&gt;</code> 。</p>
<p><code>$defl/e! &lt;variable&gt; &lt;parent&gt; &lt;formals&gt; &lt;body&gt;</code></p>
<p>　　绑定指定静态环境的 λ 抽象，等价 <code>$def! &lt;variable&gt; $lambda/e &lt;parent&gt; &lt;formals&gt; &lt;body&gt;</code> 。</p>
<p><code>$defl/e%! &lt;variable&gt; &lt;parent&gt; &lt;formals&gt; &lt;body&gt;</code></p>
<p>　　绑定指定静态环境的 λ 抽象，等价 <code>$def! &lt;variable&gt; $lambda/e% &lt;parent&gt; &lt;formals&gt; &lt;body&gt;</code> 。</p>
<p><code>forward-first% &lt;applicative&gt; &lt;list&gt;</code></p>
<p>　　取列表的第一元素并转发给指定的应用子。</p>
<p>　　设参数列表 <code>(&amp;appv (&amp;x .))</code> ，作用同求值：</p>
<pre><code class="language-npla1">(forward! appv) (list% ($move-resolved! x))
</code></pre>
<p>　　其中，调用 <code>appv</code> 的<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">底层合并子</a>的当前环境同调用 <code>forward-first%</code> 的动态环境。</p>
<p><code>first &lt;pair&gt;</code></p>
<p>　　取有序对的第一个元素的值。</p>
<p>　　当 <code>&lt;list&gt;</code> 是左值时结果是折叠的引用值，否则结果是返回值转换后的值。</p>
<p><strong>注释</strong> 类似传统 Lisp 及 [R<sup>n</sup>RK] 的 <code>car</code> 。命名和 <a href="https://srfi.schemers.org/srfi-1/srfi-1.html">[SRFI-1]</a> 及 Clojure 等现代变体一致。</p>
<p><code>first@ &lt;pair&gt;</code></p>
<p>　　同 <code>first</code> ，但结果<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0">不被折叠</a>而总是<a href="Features/NPL.zh-CN.html#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">未折叠的引用值</a>。</p>
<p>　　首先同调用 <a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%92%8C%E6%A3%80%E6%9F%A5%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>check-pair-reference</code></a>的方式检查参数是有序对引用，对右值引发错误。</p>
<p><code>first% &lt;pair&gt;</code></p>
<p>　　同 <code>first</code> ，但结果总是转发的值。</p>
<p>　　转发的值是经过折叠但没有返回值转换的列表元素的值，无论参数是否为引用值。</p>
<p><code>first&amp; &lt;pair&gt;</code></p>
<p>　　同 <code>first@</code> ，但结果总是折叠的引用值。</p>
<p>　　若元素是引用值，在结果中保留元素中的唯一引用属性。</p>
<p><strong>原理</strong> 详见 <a href="Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">NPLA1 引用值使用约定</a>。</p>
<p><code>firstv &lt;pair&gt;</code></p>
<p>　　同 <code>first</code> ，但结果总是返回值转换后的值。</p>
<p><code>rest% &lt;pair&gt;</code></p>
<p>　　取有序对的第一个元素以外的元素值经过转发的值构成的有序对。</p>
<p>　　若结果构成<a href="Features/NPL.zh-CN.html#%E6%9C%89%E5%BA%8F%E5%AF%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子有序对</a>，可能引入<a href="Features/NPL.zh-CN.html#%E6%9C%89%E5%BA%8F%E5%AF%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子有序对引用</a>。</p>
<p><code>rest&amp; &lt;pair&gt;</code></p>
<p>　　取有序对的第一个元素以外的元素值的引用值构成的有序对的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">子对象引用</a>。</p>
<p>　　首先同调用 <code>check-pair-reference</code> 的方式检查参数是有序对引用，对右值引发错误。</p>
<p>　　若结果构成子有序对，引入子有序对引用。</p>
<p><code>restv &lt;pair&gt;</code></p>
<p>　　取有序对的第一个元素以外的元素值构成的有序对。</p>
<p>　　结果是有序对对象。</p>
<p><code>set-first! &lt;pair&gt; &lt;object&gt;</code></p>
<p>　　修改有序对的第一个元素。</p>
<p>　　和 [R<sup>n</sup>RK] 的 <code>set-car!</code> 类似，但可派生，检查列表是左值，且不保留引用值。</p>
<p><code>set-first@! &lt;pair&gt; &lt;object&gt;</code></p>
<p>　　同 <code>set-first%!</code> ，但<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0">保留未折叠的引用值</a>。</p>
<p><code>set-first%! &lt;pair&gt; &lt;object&gt;</code></p>
<p>　　同 <code>set-first!</code> ，但保留引用值。</p>
<p>　　不保证检查<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改操作</a>导致循环引用。</p>
<p><strong>注释</strong> 用户应自行避免<a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">未定义行为</a>。</p>
<p><code>equal? &lt;object1&gt; &lt;object2&gt;</code></p>
<p>　　判断一般相等。</p>
<p>　　类似 <a href="Features/NPL.zh-CN.html#%E7%AD%89%E4%BB%B7%E8%B0%93%E8%AF%8D%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>eqv?</code></a>，但同时支持表示中具有子项作为子对象的对象。</p>
<p>　　判断的相等定义为子对象的递归<a href="Features/NPL.zh-CN.html#%E7%AD%89%E4%BB%B7%E8%B0%93%E8%AF%8D%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">相等性</a>。</p>
<p><strong>注释</strong></p>
<p>　　类似 [R<sup>n</sup>RK] 和 [R<sup>n</sup>RS] 的同名的二元谓词，但在此保证可通过 <code>eqv?</code> 直接构造。：</p>
<p>　　因为<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">列表的性质</a>，不需要支持<a href="Features/NPL.zh-CN.html#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>，可以直接派生。后者被视为基本的抽象而非实现细节。</p>
<p>　　和 <a href="Features/NPL.zh-CN.html#%E5%B0%81%E8%A3%85%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>make-encapsulation-type</code></a>创建的对象的相等比较不同，本机实现和派生实现都依赖当前上下文，允许捕获续延，尽管续延是未指定的。</p>
<p><code>check-environment &lt;object&gt;</code></p>
<p>　　检查<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">环境</a>。</p>
<p>　　若参数是 <code>&lt;environment&gt;</code> 则检查通过，结果是转发的参数；否则，<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%82%E5%B8%B8">引发错误对象</a>。</p>
<p><strong>注释</strong> 当前实现中其它要求 <code>&lt;enviornment&gt;</code> 参数的操作中<a href="Features/NPL.zh-CN.html#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>失败和 <code>check-environment</code> 失败的行为一致。</p>
<p><code>check-parent &lt;object&gt;</code></p>
<p>　　检查作为环境的<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">父环境</a>的对象。</p>
<p>　　若参数是可以作为合并子环境的 <code>&lt;parent&gt;</code> 则检查通过，结果是转发的参数；否则，引发错误对象。</p>
<p>　　检查环境通过的条件同<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">创建合并子时的检查</a>。</p>
<p>　　引发错误对象的作用同<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">创建合并子时环境检查失败引起错误或引发其依赖</a>的错误对象（后者保证不是<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">语法错误</a>）。</p>
<p><code>$cond &lt;clauses&gt;</code></p>
<p>　　条件选择。</p>
<p>　　类似 [R<sup>n</sup>RK] 的同名操作子，但 <code>&lt;test&gt;</code> 的判断条件和 <code>&lt;body&gt;</code> 形式不同。</p>
<p><code>$when &lt;test&gt; &lt;expression-sequence&gt;</code></p>
<p>　　条件成立时顺序求值。</p>
<p>　　类似 klisp 的同名操作子，但若 <code>&lt;expression-sequence&gt;</code> 被求值，结果是 <code>&lt;expression-sequence&gt;</code> 的最后一个 <code>&lt;expression&gt;</code> 的求值结果，而不是 <code>#inert</code> 。</p>
<p><strong>注释</strong> 这类似 [Racket] 的 <code>when</code> 而和 [R<sup>7</sup>RS] 的 <code>when</code> 或 klisp 的同名操作不同，因为 <code>$when</code> 被作为和 <code>$sequence</code> 类似的操作处理（对应 Racket 中的 <code>when</code> 和 <code>begin</code> 并列）。</p>
<p><code>$unless &lt;test&gt; &lt;expression-sequence&gt;</code></p>
<p>　　条件不成立时顺序求值。</p>
<p>　　类似 klisp 的同名操作子，但若 <code>&lt;expression-sequence&gt;</code> 被求值，结果和设计原理同上。</p>
<p><code>not? &lt;object&gt;</code></p>
<p>　　逻辑非。</p>
<p>　　被求值的参数同 <code>&lt;test&gt;</code> ，进行左值到右值转换。</p>
<p>　　若参数非 <code>#f</code> 时结果是 <code>#f</code> ，否则结果是 <code>#t</code> 。</p>
<p><strong>注释</strong> 和 [R<sup>n</sup>RK] 不同而和 Scheme 类似，视所有非 <code>#f</code> 的值为 <code>#t</code> 。</p>
<p><code>$and &lt;test&gt;...</code></p>
<p>　　逻辑与。</p>
<p>　　顺序短路求值。操作数为空时结果是 <code>#t</code> ；参数求值存在 <code>#f</code> 时结果是 <code>#f</code> ；否则结果是最后一个参数的值。</p>
<p>　　结果保留引用值。</p>
<p><strong>原理</strong></p>
<p>　　[R<sup>n</sup>RK] 的 <code>$and?</code> 和 <code>$or?</code> 的实现使用 <code>apply</code> 和 <code>wrap</code> ，这没有必要：</p>
<ul>
<li>按 [R<sup>n</sup>RK] 的 <code>apply</code> 的原理，这种对任意合并子适用的操作 <code>combine</code> 容易实现且干扰意图的理解。</li>
<li>对 NPLA1 的 <code>apply</code> ，还保证在第一参数是空列表时，为适应合<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6%E6%B1%82%E5%80%BC">求值函数合并（前缀 <code>()</code> ）</a>，被继续求值的对象仍是有序对（即函数合并，而不是单独的函数），但这在 NPLA1 的 <code>$and</code> 和 <code>$or</code> 中不必要，因为对应的情形（即 <code>$and</code> 或 <code>$or</code> 没有参数时）应被单独处理。</li>
<li>对派生实现，<code>apply</code> 通常比 <code>eval%</code> 更低效（因为包含了无用的检查和更多的非本机实现）。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RK] 的 <code>$and?</code> 不同，不检查类型，也不保证结果类型是 <code>&lt;boolean&gt;</code> ，所以命名<a href="Features/NPL.zh-CN.html#%E8%B0%93%E8%AF%8D%E5%90%8D%E7%A7%B0%E5%90%8E%E7%BC%80">不以 <code>?</code> 结尾</a>。</p>
<p>　　和 [R<sup>n</sup>RK] 中的原理描述的不同，这同时允许直接的满足 <a href="Features/NPL.zh-CN.html#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C-ptc">PTC</a> 要求的派生实现。</p>
<p><code>$or &lt;test&gt;...</code></p>
<p>　　逻辑或。</p>
<p>　　顺序短路求值。操作数为空时结果是 <code>#f</code> ，参数求值存在不是 <code>#f</code> 的值时结果是第一个这样的值；否则结果是 <code>#t</code> 。</p>
<p>　　结果保留引用值。</p>
<p><strong>原理</strong></p>
<p>　　参见以上 <code>$and</code> 的原理。</p>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RK] 的 <code>$or?</code> 不同，具体差异参见以上 <code>$and</code> 的注释。</p>
<p><code>accl &lt;object1&gt; &lt;predicate&gt; &lt;object2&gt; &lt;applicative1&gt; &lt;applicative2&gt; &lt;applicative3&gt;</code></p>
<p>　　在抽象列表的元素上应用左结合的二元操作。</p>
<p>　　对 <code>&lt;object1&gt;</code> 指定的抽象列表进行处理，取得部分和。</p>
<p>　　当谓词 <code>&lt;predicate&gt;</code> 成立时结果是 <code>&lt;object2&gt;</code> ，否则继续处理抽象列表中余下的元素。</p>
<p>　　处理抽象的列表的操作通过余下的应用子分别定义：取列表头、取列表尾和部分和的二元合并操作。</p>
<p>　　参数 <code>&lt;applicative1&gt;</code> 和参数参数 <code>&lt;applicative2&gt;</code> 应接受两个参数，否则<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　参数 <code>&lt;applicative3&gt;</code> 应接受两个参数，否则引起错误。</p>
<p>　　调用参数中的应用子的 <code>&lt;object1&gt;</code> 实际参数在不同的应用子调用中可能<a href="Features/NPL.zh-CN.html#npla1-%E5%AF%B9%E8%B1%A1%E5%90%8C%E4%B8%80%E6%80%A7">同一</a>。</p>
<p>　　调用参数中的应用子的底层合并子的当前环境同调用 <code>accl</code> 的动态环境。</p>
<p><code>accr &lt;object1&gt; &lt;predicate&gt; &lt;object2&gt; &lt;applicative1&gt; &lt;applicative2&gt; &lt;applicative3&gt;</code></p>
<p>　　在抽象列表的元素上应用右结合的二元操作。</p>
<p>　　操作方式同 <code>accl</code> 。</p>
<p>　　和 <code>accl</code> 不同，可保证合并操作是尾调用；相应地，递归调用不是尾上下文而无法满足 <a href="Features/NPL.zh-CN.html#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C-ptc">PTC</a> 要求。</p>
<p><code>foldr1 &lt;applicative&gt; &lt;object&gt; &lt;list&gt;</code></p>
<p>　　作用同符合以下要求的 <code>accr</code> 调用：</p>
<ul>
<li>指定 <code>accr</code> 的参数为 <code>&lt;list&gt;</code> 、<code>null?</code> 、<code>(forward! &lt;object&gt;)</code> 、<code>first%</code> 、<code>rest%</code> 和 <code>&lt;applicative&gt;</code> 。</li>
<li>调用应用子 <code>rest%</code> 时不复制 <code>&lt;object&gt;</code> 或其子对象。</li>
</ul>
<p>　　参数指定的应用子的调用不添加或移除列表元素，否则<a href="Features/NPL.zh-CN.html#npla1-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">行为未定义</a>。</p>
<p><strong>注释</strong></p>
<p>　　类似 <a href="https://srfi.schemers.org/srfi-1/srfi-1.html">[SRFI-1]</a>) 的 <code>fold-right</code> ，但只接受一个<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>。</p>
<p>　　<code>foldr1</code> 名称中的 <code>1</code> 指 <code>&lt;list&gt;</code> 参数的个数。（更一般的其它形式可接受多个 <code>&lt;list&gt;</code> 。）</p>
<p><code>map1 &lt;applicative&gt; &lt;list&gt;</code></p>
<p>　　单列表映射操作：使用指定应用子对列表中每个参数进行调用，结果是其<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>的列表。</p>
<p>　　参数 <code>&lt;applicative&gt;</code> 应接受一个参数，否则引起错误。</p>
<p>　　操作中的应用子和列表构造的结果的确定满足过程调用的<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">因果性</a>；其余任意 <code>&lt;applicative&gt;</code> 调用的求值、列表构造操作和销毁列表中的元素的操作的相对顺序未指定。</p>
<p>　　<code>&lt;applicative&gt;</code> 的调用不添加或移除列表元素，否则行为未指定。</p>
<p><strong>注释</strong></p>
<p>　　类似 [R<sup>n</sup>RK] 的 <code>map</code> ，但只接受一个<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>。</p>
<p>　　<code>map1</code> 名称中的 <code>1</code> 的含义类似 <code>fold1</code> 。</p>
<p><code>first-null? &lt;list&gt;</code></p>
<p>　　复合 <code>first</code> 和 <code>null?</code> 操作。</p>
<p><code>rulist &lt;list&gt;</code></p>
<p>　　转换参数为可带有唯一引用的引用列表元素的列表。</p>
<p>　　同 <code>rlist</code> ，但在参数是左值时，参数中的非引用值元素在结果中对应转换为其唯一引用。</p>
<p><strong>注释</strong> 消亡值处理和 <code>rlist</code> 不同。</p>
<p><code>list-concat &lt;list&gt; &lt;object&gt;</code></p>
<p>　　顺序连接列表和对象。</p>
<p><strong>注释</strong> 当且仅当 <code>&lt;object&gt;</code> 实际参数是 <code>&lt;list&gt;</code> 值时，结果是 <code>&lt;list&gt;</code> 值。</p>
<p><code>append &lt;list&gt;...</code></p>
<p>　　顺序连接零个或多个列表。</p>
<p><strong>注释</strong> 若没有参数，结果是空列表。</p>
<p><code>list-extract-first &lt;list&gt;</code></p>
<p>　　以 <code>first</code> 在参数指定的 <code>&lt;pair&gt;</code> 的列表中选取并合并内容为新的列表。</p>
<p>　　设参数列表 <code>(&amp;l)</code> ，结果同在新环境中求值表达式 <code>map1 first l</code> ，其中 <code>map1</code> 和 <code>first</code> 是标准库函数。</p>
<p><code>list-extract-rest%! &lt;list&gt;</code></p>
<p>　　以 <code>rest%</code> 在参数指定的 <code>&lt;pair&gt;</code> 的列表中选取并合并内容为新的列表。</p>
<p>　　设参数列表 <code>(&amp;l)</code> ，结果同在新环境中求值表达式 <code>map1 rest% l</code> ，其中 <code>map1</code> 和 <code>rest%</code> 是标准库函数。</p>
<p><code>list-push-front! &lt;list&gt; &lt;object&gt;</code></p>
<p>　　在列表前插入元素。</p>
<p>　　要求 <code>&lt;list&gt;</code> 可修改，否则<a href="Features/NPL.zh-CN.html#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>失败。</p>
<p>　　参数 <code>&lt;object&gt;</code> 被转发。</p>
<p><code>$let &lt;bindings&gt; &lt;body&gt;</code></p>
<p>　　局部绑定求值：创建以当前环境为父环境的空环境，在其中添加 <code>&lt;bindings&gt;</code> 指定的变量绑定，再求值 <code>&lt;body&gt;</code> 。</p>
<p>　　在添加绑定前，<code>&lt;bindings&gt;</code> 中的<a href="Features/NPL.zh-CN.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初值符</a>被求值。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">返回非引用值</a>。</p>
<p><strong>注释</strong> 类似 [R<sup>n</sup>RK] 的同名操作子，但返回非引用值。</p>
<p><code>$let% &lt;bindings&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$let</code> ，但保留引用值。</p>
<p><code>$let/e &lt;parent&gt; &lt;bindings&gt; &lt;body&gt;</code></p>
<p>　　指定静态环境并局部绑定求值。</p>
<p><strong>原理</strong></p>
<p>　　显式控制 <code>&lt;parent&gt;</code> 以允许传递引用值并在外部确保环境（可以是<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境强引用</a>）被正确传递作为求值的父环境，而无需支持<a href="Features/NPL.zh-CN.html#%E7%94%9F%E5%AD%98%E6%9C%9F%E6%89%A9%E5%B1%95">扩展</a> <code>&lt;parent&gt;</code> 中的环境为右值时其中的环境临时对象的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>。</p>
<p>　　注意此时 <code>&lt;parent&gt;</code> 中的环境中创建的环境对象在表达式求值后仍会因引入的合并子生存期结束而被销毁。</p>
<p><strong>注释</strong></p>
<p>　　类似 [R<sup>n</sup>RK] 的 <code>$let-redirect</code> ，但使用 <code>$lambda/e</code> 而非 <code>$lambda</code> 作为抽象且支持 <code>&lt;parent&gt;</code> ，并返回非引用值。</p>
<p><code>$let/e% &lt;parent&gt; &lt;bindings&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$let/e</code> ，但使用 <code>$lambda/e%</code> 而非 <code>$lambda/e</code> 创建抽象，保留引用值。</p>
<p><code>$let* &lt;bindings&gt; &lt;body&gt;</code></p>
<p>　　顺序局部绑定求值。</p>
<p>　　同 <code>$let</code> ，但 <code>&lt;bindings&gt;</code> 中的被用于绑定的表达式从左到右顺序求值，被用于初始化变量的表达式在求值时可访问 <code>&lt;bindings&gt;</code> 中之前绑定的符号。</p>
<p><strong>注释</strong> 类似 [R<sup>n</sup>RK] 的同名操作。</p>
<p><code>$let*% &lt;bindings&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$let*</code> ，但保留引用值。</p>
<p><code>$letrec &lt;bindings&gt; &lt;body&gt;</code></p>
<p>　　允许递归引用绑定的顺序局部绑定求值。</p>
<p><strong>注释</strong> 类似 [R<sup>n</sup>RK] 的同名操作。</p>
<p>　　和 <code>$let</code> 及 <code>$let*</code> 不同，操作求值 <code>&lt;bindings&gt;</code> 的初值符时保证使用和求值 <code>&lt;body&gt;</code> 时的同一环境作为当前环境，因此可配合 <code>lock-current-environment</code> 传递具有所有权的环境。</p>
<p><code>$letrec% &lt;bindings&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$letrec</code> ，但保留引用值。</p>
<p><code>derive-current-environment &lt;environment&gt;...</code></p>
<p>　　创建当前环境的派生环境：以参数指定的环境和当前环境为<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">父环境</a>的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">空环境</a>。</p>
<p>　　当前环境以外的父环境顺序同参数顺序。当前环境是最后一个父环境。</p>
<p><code>() make-standard-environment</code></p>
<p>　　创建<a href="Features/NPL.zh-CN.html#%E6%96%B0%E7%8E%AF%E5%A2%83">新</a><em>标准环境(standard environment)</em> ：以<a href="Features/NPL.zh-CN.html#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">基础环境</a>为父环境的空环境。</p>
<p>　　类似 [R<sup>n</sup>RK] 的 <code>make-standard-kernel-environment</code> ，但创建的环境基于 NPLA1 基础环境。</p>
<p><strong>注释</strong> 标准环境同 [R<sup>n</sup>RK] 约定的定义。</p>
<p><code>derive-environment &lt;environment&gt;...</code></p>
<p>　　创建基础环境的派生环境：以参数指定的环境和基础环境为父环境的空环境。</p>
<p>　　当前环境以外的父环境顺序同参数顺序。基础环境是最后一个父环境。</p>
<p>　　创建的环境是标准环境，当且仅当没有实际参数。</p>
<p><strong>注释</strong> 类似 <code>make-standard-environment</code> ，但具有参数指定的环境作为其它的父环境。</p>
<p><code>$as-environment &lt;body&gt;</code></p>
<p>　　求值表达式以构造环境。</p>
<p>　　创建以当前环境为父环境的空环境，并在其中求值参数指定的表达式。</p>
<p>　　结果是创建的环境强引用。</p>
<p><code>$bindings/p-&gt;environment (&lt;environment&gt;...) &lt;binding&gt;...</code></p>
<p>　　转换绑定列表为以指定的环境列表中的环境为父环境的具有这些绑定的环境。</p>
<p>　　类似 [R<sup>n</sup>RK] 的 <code>$binding-&gt;environment</code> ，但指定父环境，且具有适当的所有权。</p>
<p>　　使用 <a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>make-environment</code></a>而不是 <code>$let/e</code> 等绑定构造实现。</p>
<p><code>$bindings-&gt;environment &lt;binding&gt;...</code></p>
<p>　　转换绑定列表为没有父环境的具有这些绑定的环境。</p>
<p><strong>注释</strong> 类似 [R<sup>n</sup>RK] 的同名操作子，但因为要求对内部父环境环境所有权，使用 <code>$bindings/p-&gt;environment</code> 而不是 <code>$let/e</code> 等绑定构造派生。</p>
<p><code>symbols-&gt;imports &lt;symbol&gt;...</code></p>
<p>　　转换符号列表为未求值的适合初始化符号<a href="Features/NPL.zh-CN.html#%E5%AF%BC%E5%85%A5%E7%AC%A6%E5%8F%B7">导入</a>列表的初值符列表。</p>
<p>　　结果是包含同 <a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>desigil</code></a>的方式移除<a href="Features/NPL.zh-CN.html#%E6%96%87%E6%B3%95%E5%85%83%E7%B4%A0%E8%A1%A5%E5%85%85%E7%BA%A6%E5%AE%9A">标记字符</a>后的参数作为间接子项的列表。</p>
<p>　　求值这个列表，结果是同 <code>forward!</code> 的方式转发每个符号的列表，其元素顺序和 <code>&lt;symbols&gt;</code>... 中的值的顺序对应。</p>
<p>　　结果的结构和使用满足以下约定：</p>
<ul>
<li>结果中可能存在合并子作为其子对象，其<a href="Features/NPL.zh-CN.html#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">包装数</a>未指定。</li>
<li>取结果中的子对象进行求值的行为未定义。</li>
<li>若结果被修改（如被转移），再求值时行为未定义。</li>
<li>若结果中的合并子在求值整个结果外的上下文被调用，行为未定义。</li>
</ul>
<p><strong>原理</strong> 这些约定可允许更有效的本机实现。</p>
<p><strong>注释</strong></p>
<p>　　类似 [R<sup>n</sup>RK] 的 <code>$provide!</code> 和 <code>$import!</code> 提供符号列表的方式，但有以下不同：</p>
<ul>
<li>支持移除引用标记字符。</li>
<li>支持转发参数。</li>
<li>不带有引用标记字符和符号指称的对象不是<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的默认情形复制值而不是初始化引用。</li>
</ul>
<p><code>$provide/let! &lt;symbols&gt; &lt;bindings&gt; &lt;body&gt;</code></p>
<p>　　指定局部绑定后在当前环境中提供绑定。</p>
<p>　　蕴含 <code>$let &lt;bindings&gt; &lt;body&gt;</code> ，在求值 <code>&lt;body&gt;</code> 后以结果作为操作数绑定到 <code>&lt;symbols&gt;</code> 的符号。</p>
<p>　　<code>&lt;symbols&gt;</code> 应能被作为 <code>&lt;definiend&gt;</code> 使用。</p>
<p>　　结果是对这些绑定具有所有权的环境强引用。</p>
<p>　　需要<a href="Features/NPL.zh-CN.html#%E5%AF%BC%E5%85%A5%E7%AC%A6%E5%8F%B7">导入符号</a>，即 <code>&lt;symbols&gt;...</code> 具有至少一个实际参数时，以同 <code>symbols-&gt;imports</code> 的方式确定初值符。其中，等效的 <code>symbols-&gt;imports</code> 的调用次数未指定。</p>
<p><strong>注释</strong> 绑定后的符号可通过作为 vau 抽象的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E7%94%9F%E5%AD%98%E6%9C%9F">父环境</a>等形式依赖这个环境，因此用户需适当保存<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>使<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E7%94%9F%E5%AD%98%E6%9C%9F">其生存期</a>覆盖在被使用的绑定符号指称的对象生存期。</p>
<p><code>$provide! &lt;symbols&gt; &lt;body&gt;</code></p>
<p>　　在当前环境中提供绑定。</p>
<p>　　同 <code>$provide/let!</code> ，但不指定单独的 <code>&lt;bindings&gt;</code> 。</p>
<p>　　作用同 <code>&lt;bindings&gt;</code> 为空列表的 <code>$provide/let!</code> 。</p>
<p>　　结果是创建的环境的强引用。</p>
<p>　　需要导入符号时，以同 <code>symbols-&gt;imports</code> 的方式确定初值符。其中，等效的 <code>symbols-&gt;imports</code> 的调用次数未指定。</p>
<p><strong>注释</strong> 类似 [R<sup>n</sup>RK] 的同名操作子，但结果是创建的环境的强引用，且确定初值符的方式被显式要求。</p>
<p>　　仅当 <code>&lt;symbols&gt;</code> 类型检查通过时求值 <code>&lt;body&gt;</code> 。</p>
<p>　　检查当前<a href="Features/NPL.zh-CN.html#%E5%86%BB%E7%BB%93">环境可修改</a>失败时的副作用和以上任一等效求值 <code>symbols-&gt;imports</code> 应用子的结果可能具有的副作用<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">非决定性有序</a>。</p>
<p><code>$import! &lt;environment&gt; &lt;symbol&gt;...</code></p>
<p>　　从指定的环境导入指定的符号。</p>
<p>　　对第一参数之后的其余参数指定的符号列表中的每个符号，修改第一参数指定的环境，创建和指定的符号具有相同的名称和值的变量绑定。</p>
<p>　　类似 [R<sup>n</sup>RK] 的同名操作子，但需要导入符号时，以同求值 <code>symbols-&gt;imports</code> 应用子的结果的方式确定初值符。其中，等效的 <code>symbols-&gt;imports</code> 的调用次数未指定。</p>
<p>　　当指定的环境中的指定符号对应的绑定以临时对象创建时，导入符号可修改指定的源环境的被绑定对象。</p>
<p><strong>注释</strong> 由于求值 <code>symbols-&gt;imports</code> 应用子的结果蕴含的转发语义，这和 [R<sup>n</sup>RK] 不同。</p>
<p>　　检查 <code>&lt;environment&gt;</code> 可修改失败时的副作用和以上任一等效求值 <code>symbols-&gt;imports</code> 应用子的结果可能具有的副作用非决定性有序。</p>
<p><code>$import&amp;! &lt;environment&gt; &lt;symbol&gt;...</code></p>
<p>　　从指定的环境以引用绑定导入指定的符号。</p>
<p>　　同 <code>$import!</code> ，但以 <a href="Features/NPL.zh-CN.html#%E6%A0%87%E5%87%86%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>ensigil</code></a>的方式指定绑定的符号。</p>
<p><code>nonfoldable? &lt;list&gt;</code></p>
<p>　　判断参数是否不可被继续折叠映射：存在空列表。</p>
<p>　　参数是同 [R<sup>n</sup>RK] 的 <code>map</code> 操作可接受的列表参数或空列表，但排除<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">非真列表</a>。</p>
<p>　　若参数是空列表，结果是 <code>#f</code> 。</p>
<p><code>assq &lt;object&gt; &lt;lists&gt;</code></p>
<p>　　取关联列表中和参数的引用相同的元素。</p>
<p>　　第二参数指定的列表中的元素应为有序对。</p>
<p>　　以 <code>eq?</code> 依次判断第二参数指定的列表中的每个元素的第一个元素是否和第一参数指定的元素等价。</p>
<p>　　若不存在等价的元素，结果为空列表右值；否则是同 <code>first%</code> 访问得到的等价的列表的值。</p>
<p><strong>原理</strong></p>
<p>　　和 [R<sup>n</sup>RK] 不同，NPLA1 只支持<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>，因此可以要求顺序，提供关于等价的元素的更强的保证。</p>
<p>　　尽管和 [R<sup>n</sup>RK] 相同而和 [R<sup>n</sup>RS] 不同，<a href="Features/NPL.zh-CN.html#%E6%8E%A7%E5%88%B6%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>&lt;test&gt;</code> 支持非布尔值</a>，不存在元素时的 <code>#f</code> 结果可以简化比较，但和 [R<sup>n</sup>RK] 的原理类似，这不利于提供清晰的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型错误</a>，且没有如空列表值这样作为求值算法的特殊值的自然推论。使用空列表值和传统 Lisp 也一致。</p>
<p><strong>注释</strong></p>
<p>　　类似 [R<sup>n</sup>RK] 的同名应用子，但保证顺序且转发参数。</p>
<p>　　类似 [R<sup>n</sup>RS] 的同名过程，但失败的结果不是 <code>#f</code> 。</p>
<p><code>assv &lt;object&gt; &lt;lists&gt;</code></p>
<p>　　取关联列表中和参数的值相等的元素。</p>
<p>　　第二参数指定的列表中的元素应为有序对。</p>
<p>　　以 <code>eqv?</code> 依次判断第二参数指定的列表中的第一个元素是否和第一参数指定的元素等价。</p>
<p>　　若不存在等价的元素，结果为空列表右值；否则是同 <code>first%</code> 访问得到的等价的列表的值。</p>
<p><strong>原理</strong> 参见 <code>assq</code> 。</p>
<p><strong>注释</strong></p>
<p>　　类似 [R<sup>n</sup>RK] 的 <code>assoc</code> ，但使用 <code>eqv?</code> 而不是 <code>equal?</code> ，保证顺序且转发参数。</p>
<p>　　类似 [R<sup>n</sup>RS] 的 <code>assv</code> ，但失败的结果不是 <code>#f</code> 。</p>
<p><code>box &lt;object&gt;</code></p>
<p>　　装箱：构造参数对象经左值到右值转换的箱（类型为 <code>&lt;box&gt;</code> 的对象）。</p>
<p><code>box% &lt;object&gt;</code></p>
<p>　　同 <code>box</code> ，但参数不蕴含左值到右值转换，<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%BB%93%E6%9E%9C%E5%8C%85%E5%90%AB%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AE%B9%E5%99%A8%E6%9E%84%E9%80%A0%E5%99%A8">在结果中保留参数的引用值</a>。</p>
<p><code>box? &lt;object&gt;</code></p>
<p>　　<code>&lt;box&gt;</code> 的<a href="Features/NPL.zh-CN.html#%E8%B0%93%E8%AF%8D%E5%90%8D%E7%A7%B0%E5%90%8E%E7%BC%80">类型谓词</a>。</p>
<p><code>unbox &lt;box&gt;</code></p>
<p>　　拆箱：从箱中还原对象。</p>
<p>　　作为<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%80%BC%E8%BD%AC%E5%8F%91%E5%87%BD%E6%95%B0">函数值转发操作</a>，保留引用值。</p>
<p><strong>注释</strong></p>
<p>　　以上 4 个函数除<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E7%BA%A6%E5%AE%9A">引用标记字符</a>对应处理引用值的差异外，功能和使用方式对应类似 <a href="https://srfi.schemers.org/srfi-111/srfi-111.html">[SRFI-111]</a> 的 3 个过程 <code>box</code> 、<code>box?</code> 和 <code>unbox</code> 。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB">类型分区</a>使 <code>box?</code> 对 <code>&lt;list&gt;</code> 类型的参数的结果总是 <code>#f</code> 。若没有这个限制，不考虑<a href="Features/NPL.zh-CN.html#%E5%B0%81%E8%A3%85">封装性</a>时，用 <code>&lt;list&gt;</code> 的相关操作可整体替换进行功能等价的代替：<code>list</code> 、<code>list%</code> 和 <code>first</code> 可代替 <code>box</code> 、<code>box%</code> 和 <code>unbox</code> 。</p>
<p>　　和 <a href="http://community.schemewiki.org/?scheme-faq-language">关于 Scheme 的装箱的描述</a>不同，这样的代替不一定保证有更好的性能。</p>
<p>　　以上这些函数可使用 <a href="Features/NPL.zh-CN.html#%E5%B0%81%E8%A3%85%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>make-encapsulation-type</code></a>实现。</p>
<p>　　和 Scheme 等不同，箱具有被装箱对象的所有权，因此使用 <code>box%</code> 和 <code>unbox</code> 时，需注意保存被构造的箱或被箱中引用值引用的对象。</p>
<h3 id="标准派生特性"><a class="header" href="#标准派生特性">标准派生特性</a></h3>
<p>　　<em>标准派生特性(standard derived feature)</em> 同<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">基本派生特性</a>，但其派生依赖<a href="Features/NPL.zh-CN.html#npla1-%E6%A0%B9%E7%8E%AF%E5%A2%83%E7%89%B9%E6%80%A7">标准库其它模块</a>。</p>
<p><code>ensigil &lt;symbol&gt;</code></p>
<p>　　修饰引用字符。</p>
<p>　　若参数非空且没有 <code>&amp;</code> 前缀，则结果是添加 <code>&amp;</code> 引用标记字符作为前缀的符号；否则是参数值。</p>
<p><code>$binds1? &lt;environment&gt; &lt;symbol&gt;</code></p>
<p>　　判断指定符号是否在指定表达式求值后指称的环境中绑定。</p>
<p><strong>注释</strong> 类似 [R<sup>n</sup>RK] 的 <code>$binds?</code> ，但只支持判断一个 <code>&lt;symbol&gt;</code> 操作数。</p>
<h3 id="核心库"><a class="header" href="#核心库">核心库</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#%E6%A0%87%E5%87%86%E5%BA%93">核心库</a>提供以下操作，即<em>核心库函数(core library function)</em> ：</p>
<p><code>map-reverse &lt;applicative&gt; &lt;list&gt;...</code></p>
<p>　　映射并反转结果。</p>
<p>　　参数 <code>&lt;applicative&gt;</code> 应满足以下要求，否则<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">引起错误</a>：</p>
<ul>
<li><code>&lt;list&gt;...</code> 中的参数的元素数都相等。</li>
<li><code>&lt;list&gt;...</code> 中的参数的元素数量等于 <code>&lt;applicative&gt;</code> 接受的形式参数的元数。</li>
</ul>
<p><strong>注释</strong> 类似 [R<sup>n</sup>RK] 的 <code>map</code> ，但支持空的 <code>&lt;list&gt;...</code> 且保证顺序。</p>
<p><code>for-each-ltr &lt;applicative&gt; &lt;list&gt;...</code></p>
<p>　　从左到右映射取副作用。</p>
<p><strong>注释</strong> 类似 [R<sup>n</sup>RK] 的 <code>for-each</code> ，但支持空的 <code>&lt;list&gt;</code> 且保证顺序。</p>
<h1 id="npla1-参照实现扩展环境"><a class="header" href="#npla1-参照实现扩展环境">NPLA1 参照实现扩展环境</a></h1>
<p>　　类似 <a href="Features/NPL.zh-CN.html#npla1-%E6%A0%B9%E7%8E%AF%E5%A2%83%E7%89%B9%E6%80%A7">NPLA1 根环境特性</a>，NPLA1 以<a href="Features/NPL.zh-CN.html#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">根环境</a>的形式提供其它一些<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9D%97">模块</a>的操作，但默认不以根环境中的绑定而是以其中的<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9D%97">环境子对象</a>中的绑定提供。</p>
<p>　　除非另行指定，这些环境子对象作为<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">库特性</a>的一部分时，是以 <code>std.</code> 为前缀的名称命名的<a href="Features/NPL.zh-CN.html#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">库环境</a>。</p>
<p>　　除非派生实现另行指定，这些模块都应被提供。</p>
<p>　　这些模块和 <a href="Features/NPL.zh-CN.html#npla1-%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83">NPLA1 参照实现环境</a>提供的特性一同构成<a href="Features/NPL.zh-CN.html#%E6%A0%87%E5%87%86%E5%BA%93">标准库</a>。</p>
<p>　　除非派生实现定义，每个标准库模块都不是可选的。否则，作为被加载的模块的环境的名称由派生实现定义。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>这些环境的程序<a href="Features/NPL.zh-CN.html#npla1-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">行为未定义</a>。</p>
<p>　　默认加载使用 <code>.</code> 分隔标识符得到的符号作为名称。</p>
<p>　　加载的模块依赖<a href="Features/NPL.zh-CN.html#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">初始化的根环境</a>。</p>
<p>　　当前实现中部分加载的环境依赖之前加载的环境，这些环境的名称是固定的。用户程序需要保证这些环境在加载时的静态环境中可用。</p>
<p>　　在调用其中的合并子时，可能求值符号引用依赖的环境。其中的环境可能在求值定义时不依赖而不作为对应的本机 API 的前置条件。</p>
<p>　　环境是否具有依赖的环境的绑定绑定是未指定的。</p>
<p>　　用户程序需保持加载为环境的模块具有适当的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E7%94%9F%E5%AD%98%E6%9C%9F">生存期</a>，以避免其中的<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">合并子调用</a>引起未定义行为。</p>
<p>　　本章的特性可使用<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>或<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%BA%A6%E5%AE%9A">非本机的派生实现</a>，分别符合<a href="Features/NPL.zh-CN.html#%E6%A0%B9%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7">根环境基本特性</a>和<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E7%A1%80%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">基础派生特性</a>的规则。具体使用何种实现是未指定的。</p>
<p>　　派生实现可定义更具体的实现要求，以便<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>的兼容性。</p>
<p><strong>原理</strong></p>
<p>　　这些绑定不需要被直接引入<a href="Features/NPL.zh-CN.html#npla1-%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96">基础上下文</a>的根环境中，因为：</p>
<ul>
<li>同时满足以下关于接口依赖的约束，而不必要以<a href="Features/NPL.zh-CN.html#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">基础环境</a>可访问的名称提供：
<ul>
<li>它们不是使用<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9D%97">作为环境的模块</a>时被依赖的主要操作。
<ul>
<li>为了使用非根环境的模块，需要绑定在根环境的函数引入其中的绑定。这样的接口应在根环境中提供而保证默认可访问，避免引入绑定这样的功能的在逻辑上的循环依赖。</li>
<li><strong>注释</strong> 这样的操作如 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$import!</code></a>。</li>
</ul>
</li>
<li>它们不被<a href="Features/NPL.zh-CN.html#npla1-%E6%A0%B9%E7%8E%AF%E5%A2%83%E7%89%B9%E6%80%A7">根环境特性</a>的在接口意义上依赖。
<ul>
<li><strong>注释</strong> 在实现上仍可选依赖，参见<a href="Features/NPL.zh-CN.html#%E6%A0%87%E5%87%86%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">标准派生特性</a>。</li>
</ul>
</li>
</ul>
</li>
<li>接口的功能不对一般的实体具有足够普遍性，而不需要以基础环境默认可访问的名称提供。</li>
</ul>
<p>　　判定上述的足够普遍性的具体规则包括：</p>
<ul>
<li>普遍性以实体类型体现为接口的功能对非特定类型的对象适用，最终不依赖具有更特定的类型特有的性质。
<ul>
<li><strong>注释</strong> 一般的实体作为一等对象，即具有 <a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;object&gt;</code></a>的值。<code>&lt;object&gt;</code> 是足够普遍的类型。</li>
<li><strong>注释</strong> <a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;reference&gt;</code></a>和 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>&lt;box&gt;</code></a>等由 <code>&lt;object&gt;</code> 构造的值最终依赖 <code>&lt;object&gt;</code> 的值，而非其它更特定类型特有的性质。</li>
</ul>
</li>
<li>在<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值算法</a>中出现决定具体步骤的具体实体类型，被认为是足够普遍的。
<ul>
<li><strong>注释</strong> 这包括 <a href="Features/NPL.zh-CN.html#%E6%9C%AA%E6%B1%82%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;symbol&gt;</code></a>、<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;list&gt;</code></a>和 <a href="Features/NPL.zh-CN.html#%E6%9C%AA%E6%B1%82%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;combiner&gt;</code></a>及其<a href="Features/NPL.zh-CN.html#%E6%9C%AA%E6%B1%82%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">子类型</a>。</li>
<li><strong>注释</strong> <a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B"><code>&lt;number&gt;</code></a>或 <a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;string&gt;</code></a>等其它比 <code>&lt;object&gt;</code> 更具体类型的值不在此列。</li>
</ul>
</li>
<li>若接口的功能仅依赖比一般的实体更具体的特定类型的值，则不以基础环境默认可访问的名称提供。
<ul>
<li><strong>注释</strong> 功能上的依赖包含区分这些特定类型的值，如<a href="Features/NPL.zh-CN.html#%E8%B0%93%E8%AF%8D%E5%90%8D%E7%A7%B0%E5%90%8E%E7%BC%80">类型谓词</a>。</li>
</ul>
</li>
<li>接口的功能描述涉及的类型的足够普遍性对以基础环境默认可访问的名称提供是必要非充分条件。
<ul>
<li>这些类型仅决定接口功能的一部分。</li>
<li><strong>注释</strong> 若接口的功能仅依赖足够普遍的类型，但功能不足以涵盖它的任何的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>或者值，也可在参照实现扩展环境中提供。</li>
<li><strong>注释</strong> 一个主要特例：足够普遍的具体类型的类型谓词涵盖所有值，因此类型的足够普遍性可直接作为对应的类型谓词的足够普遍性的充分必要条件。</li>
</ul>
</li>
</ul>
<p>　　具有足够普遍性而应在根环境而非参照实现扩展环境提供的操作具体包括以下几类：</p>
<ul>
<li>创建非特定的不同<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义类型</a>的对象使用的普遍机制的主要操作。
<ul>
<li><strong>注释</strong> 使用 <a href="Features/NPL.zh-CN.html#%E5%B0%81%E8%A3%85%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>make-encapsulation-type</code></a>可创建不同名义类型。</li>
</ul>
</li>
<li>不改变一般的实体可能蕴含的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">对象同一性</a>而同时附加非特定<a href="Features/NPL.zh-CN.html#%E4%BD%9C%E7%94%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99">种类</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>的操作。
<ul>
<li>同一性是所有对象的属性。显示同一性不依赖具体副作用的种类，因此要求特定种类的接口削弱普遍性。另见<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E5%8F%98%E7%8A%B6%E6%80%81%E5%92%8C%E6%99%AE%E9%81%8D%E6%80%A7">可变状态和普遍性</a>。</li>
<li><strong>注释</strong> 根环境中这样的操作如 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>box%</code> 和 <code>unbox</code></a>。</li>
</ul>
</li>
<li>不依赖特定对象类型，直接引入副作用的操作。
<ul>
<li>因为引入副作用可能是接口的关键功能及主要目的，此处的普遍性不限制非特定种类。</li>
<li><strong>注释</strong> 仅具有控制作用为副作用的操作仍被视为是普遍的。因此，可具有<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制作用</a>的 <a href="Features/NPL.zh-CN.html#%E6%8E%A7%E5%88%B6%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>$if</code></a>等函数仍在根环境中提供。</li>
<li><strong>注释</strong> 依赖<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">一等续延</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制作用</a>因续延类型而不视为足够普遍，因此根环境不直接提供一等续延关联的操作。</li>
</ul>
</li>
</ul>
<p>　　在此基础上，这些绑定被设计为<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">环境子对象</a>提供的<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9D%97">子模块</a>，因为以下的一个或多个原因：</p>
<ul>
<li>它们可能具有非全局含义的名称而更适合隔离在不同<a href="Features/NPL.zh-CN.html#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">命名空间</a>中以避免使用时的歧义。</li>
<li>它们可能仅关注（如作为操作的参数或返回类型）特定的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">求值得到的操作数</a>类型。</li>
<li>它们中的每一个模块具有足够或内聚性而不和其它子模块耦合，且绑定提供的实体关注相同的功能集合，适合被派生实现直接配置为可选的(#根环境基本特性)特性分组。</li>
<li>允许实现使用特殊的环境子类型<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9D%97">延迟加载</a>。
<ul>
<li><strong>注释</strong> 当前 NPLA1 没有提供支持。</li>
</ul>
</li>
</ul>
<p><strong>注释</strong></p>
<p>　　类似<a href="Features/NPL.zh-CN.html#npla1-%E6%A0%B9%E7%8E%AF%E5%A2%83%E7%89%B9%E6%80%A7">根环境特性</a>，一些特性可<a href="Features/NPL.zh-CN.html#npla1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80">约定处理的值的宿主类型</a>。</p>
<p>　　使用 <code>.</code> 分隔标识符得到的符号类似 <a href="http://wiki.call-cc.org/eggref/4/r7rs#import">CHICKEN Scheme 的转换 R7RS 的标准模块名</a>。</p>
<h2 id="续延库"><a class="header" href="#续延库">续延库</a></h2>
<p>　　提供<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">续延</a>支持。</p>
<p>　　默认加载为根环境下的 <code>std.continuations</code> 环境。</p>
<p><strong>模块约定：</strong></p>
<p>　　本节约定以下求值得到的操作数：</p>
<ul>
<li><code>&lt;continuation&gt;</code> ：<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">一等续延</a>。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　类似 Kernel 语言，NPLA1 续延不是合并子。这一设计的基本原理参见 [R<sup>n</sup>RK] §7（以及<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延的捕获和调用</a>），但理由不充分。更完整的分析如下：</p>
<ul>
<li>使用<em>守卫选择子(guard selector)</em> 是 Kernel 的具体特性的设计，不是一般求值算法中蕴含需要实现的选项，因此仅在 [R<sup>n</sup>RK] 内部生效。
<ul>
<li>这和类似的其它机制（如 [R<sup>n</sup>RS] 的 <code>dynamic-wind</code> thunk ）事实上都同以下关于续延组合性的理由类似，不需要单独列出。</li>
</ul>
</li>
<li>如 [R<sup>n</sup>RK] ，一般的合并子确实无法保证作为续延的父续延(parent continuation) 。
<ul>
<li>[R<sup>n</sup>RK] 在此没有进一步明确：
<ul>
<li>一般的合并子无法作为父续延的原因是因为（作为函数）不保证能接受操作数。</li>
<li>父续延对续延组合（接受两个续延结果是和两者连续调用等效的续延）操作是必要的输入。</li>
<li>更一般地，即便不支持续延组合操作，在抽象机语义描述续延的捕获得到一等续延依赖这种语义（即便父续延不是一等对象）。
<ul>
<li>只要描述依赖可组合的求值算法，除了最后一个<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">无界续延</a>，其它续延都对应可组合的求值步骤，因此这隐含续延的可组合性。</li>
</ul>
  <!-- markdownlint-disable-next-line MD034 -->
<ul>
<li>其它在求值算法以外的机制的描述也可能依赖这种组合性，如：https://docs.racket-lang.org/reference/eval-model.html#(part._mark-model) 。</li>
<li>最后一个无界续延可不考虑可组合性。但只要它不是唯一的，为作为一等续延被直接捕获和调用，它仍应当接受程序指定的操作数。
<ul>
<li>仅当这个续延唯一时可不提供单独的续延类型。
<ul>
<li>此时，这个续延被隐含而不当作一等续延，其中的操作数直接通过非续延的函数直接表示，如 [ISO C] 标准库的 <code>exit</code> 函数。</li>
<li>然而这样的设计要求其它续延是可组合的，否则根本不支持一等续延。</li>
</ul>
</li>
<li>可组合续延时，这个唯一的续延会被这作为被组合的其它续延的公共后缀。
<ul>
<li>此时仍然需要支持指定操作数，以便最后一个续延能表现程序指定的不同行为；否则，显式提供这样的续延缺少实际意义。</li>
</ul>
</li>
<li>[R<sup>n</sup>RK] 要求 <code>root-continuation</code> 和 <code>error-continuation</code> 这两个不同的一等无界续延能作为后缀，因此不是唯一的。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>所以，为符合<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>，一般的合并子不是续延的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>。</li>
</ul>
</li>
<li>因为<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">包装</a>是独立在具体合并子类型外的操作，[R<sup>n</sup>RK] 说明了一般续延不应作为应用子的子类型，而这并没有有效说明续延无法作为<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">操作子</a>的子类型。</li>
<li>一些观点认为无界续延不能作为函数。但这实际依赖具体对象语言的规则，同样无法说明一般的续延无法作为操作子的子类型。
<ul>
<li>典型的分析如<a href="https://okmij.org/ftp/continuations/undelimited.html#introduction">参见这里</a>。</li>
<li>这仅论述了<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">续延界限</a>和续延（调用）的某种可组合性(composablility) 的要求之间的关系。
<ul>
<li>特别地，此处的可组合性局限于取得函数值。</li>
</ul>
</li>
<li>因为这种可组合性的限制，这隐含一个前提：函数不能不返回。这对一般的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数</a>并不成立，因为一般的函数允许存在副作用，这种副作用不一定局限于蕴含此处可组合的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制作用</a>。</li>
<li>在类型系统中，不返回的函数仍可能是<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">良型的</a>，因为<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%A7%8D%E7%B1%BB">函数类型的构造器</a>是否接受<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E8%BE%B9%E7%95%8C%E5%85%83%E7%B4%A0">空类型</a>和具体类型系统的设计相关。
<ul>
<li>类型系统规则能保证编码可组合的函数的机制是确保语法上可构造可组合的嵌套函数调用（函数值可作为另一个函数的实际参数），以此构成传统数学函数复合的自然扩展，并保证作用可复合，但这不保证函数值可复合。
<ul>
<li>对总是不返回的函数，非终止(non-terminization) 是其作为后缀的一种单一副作用，吸收(absorb) 任何返回函数值的这一计算作用。这破坏函数调用具有返回值的预期，但并非在作用上不可组合。</li>
</ul>
</li>
<li>事实上，不提供一等控制作用机制的语言也可能允许这种类型规则。
<ul>
<li>如 [ISO C] 的 <code>_Noreturn</code> 函数实质上返回类型就是空类型（因为没有任何值可作为<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">居留</a>），尽管 C 的类型系统编码中 <code>_Noreturn</code> 函数返回类型并不唯一（返回类型这在转换等其它类型检查中仍然有效）且空类型不被检查（违反 _Noreturn 约束是未定义行为）而可能显得不典型。</li>
<li><strong>注释</strong> [ISO C] 仅提供 <code>setjmp</code>/<code>longjmp</code> 改变通常的控制状态。此外，[ISO C++] 的类似的 <code>[[noreturn]]</code> 用于标注总是抛出异常的函数，而提供异常的（替代）实现是一等控制操作符的一个典型使用场景。</li>
</ul>
</li>
</ul>
</li>
<li>根本地，使用这种值而非一般计算作用的可组合性定义的理由，仅来自某种描述语言规则的元语言上推理的要求或约定。
<ul>
<li><strong>注释</strong> 例如，为了便于使用等式理论(equational theory) 进行推理，证明被描述的对象语言总是符合某种静态的性质。</li>
<li>一般地，基于目的的不确定性，元语言不总是遵循这种约定。</li>
<li>对象语言更没有必要遵循这种约定，因为这蕴含对对象语言功能完整性的任意地、不必要的限制。</li>
<li>避免非预期的终止性可很容易通过对维护外部语言实现环境的运行时的互操作实现：添加一个破坏维护非终止的运行时条件的操作（例如，撤除硬件电源），即便需要按某种方式保留运行时状态，通常仍远远比提供静态的证明更容易。</li>
<li>此外，不论对象语言是否有必要表达，普遍的组合性不总是有益的，自身可能不被预期。
<ul>
<li>易于排除非终止这种计算作用的实现方法，正好是得益于语言实现和外部系统之间的计算作用不能自发维持组合性的直接应用。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>实际决定对象语言中区分续延和合并子（且续延明确不使用合并子表示）的设计有不同的其它理由：
<ul>
<li>求值算法对合并子的处理决定合并子对<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%9D%A1%E4%BB%B6">非正常控制</a>透明。作为引入非正常控制的机制，续延调用和遵循 <a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">β-规约</a>的合并子调用具有不同来源的语义规则，即便后者在元语言中可能实现前者。
<ul>
<li>因此，是否把续延表示为传统的过程或合并子等其它蕴含 β-规约的实体是实现细节。抽象上，这支持保持续延的表示不透明而和合并子相互独立。</li>
<li>对一等续延相关的控制操作的一种一般的语义描述参见<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.72.8645&amp;rep=rep1&amp;type=pdf">这里</a>。</li>
</ul>
</li>
<li>避免把续延作为合并子还有语用因素。具体地，续延调用通常使用<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延应用</a>的形式，而非操作子调用。续延应用不直接复用<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>的语法。
<ul>
<li>以操作子的方式类似进行续延调用可能依赖对象的内部表示而暴露不必要公开的抽象，并不常用，也并不被当前语言普遍支持。
<ul>
<li><strong>注释</strong> 大多数语言根本不支持操作子。</li>
<li>但禁用这种调用，在一等续延的调用规则中添加偶然耦合，阻碍功能<a href="Features/NPL.zh-CN.html#%E5%AE%8C%E6%95%B4%E6%80%A7">完整性</a>和设计的<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a> 。</li>
</ul>
</li>
<li>考虑到捕获的一等续延通过变量绑定提供，因为合并子不是应用子的子类型，若一等续延是合并子，只能是指称操作子的变量。
<ul>
<li>于是，程序中的续延应用总是要求对其包装后使用。</li>
<li>这种设计使程序的实现和简单性冲突，并违反多个<a href="Features/NPL.zh-CN.html#%E7%BB%93%E6%9E%84%E5%92%8C%E4%BE%9D%E8%B5%96%E5%8E%9F%E5%88%99">结构设计规则</a>，而削弱提供这些绑定的续延捕获特性的<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>。</li>
</ul>
</li>
<li>因此，一般的续延不是应用子的子类型，程序中一等续延的应用需转换续延为应用子。</li>
<li>推论：一般的续延不是合并子的子类型。</li>
</ul>
</li>
</ul>
</li>
<li>综上，结合以上合并子不是续延的子类型以及续延不是合并子的子类型，一般的续延和合并子类型是正交的。
<ul>
<li>但<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB">和 [R<sup>n</sup>RK] 要求的类型分区不同</a>，派生实现仍可能提供同时是某个合并子的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%BA%8F">严格子类型</a>的续延。</li>
</ul>
</li>
</ul>
<p>　　NPLA1 首先提供关于一等续延而不是<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E7%9A%84%E8%AE%A1%E7%AE%97%E9%A1%BA%E5%BA%8F">一等协程</a>的控制操作，因为：</p>
<ul>
<li>协程要求支持具有更多的原语，包括基于（而非并行于）一般的例程的创建操作（<a href="Features/NPL.zh-CN.html#%E5%88%9B%E5%BB%BA%E5%92%8C%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0">构造器</a>）。</li>
<li>具有相等的一等协程的内部表示逻辑上更加复杂（总是涉及可变状态），即便具体实现并不一定更复杂（和内部表示相关）。</li>
<li>使用非对称协程派生对称协程比使用<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">有界续延</a>派生无界续延在逻辑上依赖暴露更多的细节，如包含分支的跳板循环。</li>
</ul>
<p>　　尽管逻辑上有界续延能不依赖其它<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>而表达状态，提供有界续延或无界续延作为原语的差异相对次要，因为：</p>
<ul>
<li>NPLA1 不是<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">纯函数式语言</a>而支持<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">一等状态</a>在内的基本设计，在实现中不需要排除可变状态。</li>
<li>NPLA1 不提供特设的和续延并行的<a href="Features/NPL.zh-CN.html#%E5%BC%82%E5%B8%B8">异常</a>或者其它替代的<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%9D%A1%E4%BB%B6">非正常控制</a>机制，而不具有<a href="https://okmij.org/ftp/continuations/undelimited.html#delim-vs-undelim">控制作用之间的互操作难以组合的问题</a>。
<ul>
<li>异常基于续延提供，能确保可预测的互操作行为，尽管在基本操作中仍然可能使用异常作为实现。</li>
<li>这类似 <a href="https://docs.racket-lang.org/reference/eval-model.html#(part._exn-model)">[Racket] 的“异常是派生的概念”的描述</a>，但 NPLA1 异常并非如 [Racket] 内建，因为<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">抛出异常</a>只是<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">引起错误</a>的实现，而不是接口要求。</li>
</ul>
</li>
<li>尽管逻辑上引入<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">续延界限</a>可能是有益的，且有微妙的语义上的效果，这并没有简化用户程序和语言实现，因此当前不要求。
<ul>
<li>当前不支持<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">多次续延</a>和续延复制。
<ul>
<li>当续延仅在同一个上下文中捕获时，缺少续延界限不会是一个明显的问题，因为被调用的续延总是会重新引入共享的子续延。</li>
</ul>
</li>
<li>一些当前语言设计在 [R<sup>n</sup>RS] 的操作上扩展了界限。
<ul>
<li>例如，不同于 [R<sup>n</sup>RS] ，<a href="https://docs.racket-lang.org/reference/cont.html#(def._((quote._~23~25kernel)._call-with-current-continuation))">[Racket] 的 <code>call/cc</code> 也检查提示(prompt) 的存在</a>。</li>
</ul>
</li>
<li>缺少续延界限可能引起控制操作符关联的一些模型之间的语义不等价问题而<a href="http://ix.cs.uoregon.edu/~ariola/tpdc11.pdf">难以使用其中的一种严格准确地表达其中的另一种</a>。
<ul>
<li>在 SML/NJ 等语言中，因为不存在顶层的续延界限，这些问题容易成为在程序中真正阻碍使用有界续延的困难。</li>
<li>在 [R<sup>n</sup>RK] ，正常程序运行的顶层续延界限以 <code>root-continuation</code> 提供。此外，提供 <code>error-continuation</code> 处理错误。</li>
<li>在完善的设计中，提供一个顶层的续延界限并非困难。因此，可能缺少取得续延界限的方法的问题不是核心困难。此外，如 [R<sup>n</sup>RK] 的 <code>error-continuation</code> 显示了其它类似的续延的实用性。
<ul>
<li>类似的特性可能会被加入此处的设计中。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>注释</strong></p>
<p>　　类似 [R<sup>n</sup>RK] 而和 [R<sup>n</sup>RS] 不同，续延具有单独的类型，续延应用也不是蕴含过程调用的函数应用。</p>
<p><strong>操作：</strong></p>
<p><code>call/1cc &lt;combiner&gt;</code></p>
<p>　　捕获<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">一次续延</a>，<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">具现</a>为一等续延作为参数调用合并子。</p>
<p>　　续延首先在<a href="Features/NPL.zh-CN.html#%E5%B0%BE%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BA%A6%E5%AE%9A">尾上下文中</a>被<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">按引用捕获</a>，再作为操作数，调用 <code>&lt;combiner&gt;</code> 。</p>
<p>　　来自同一具现的一次续延的任何副本只允许一次显式（续延应用）或者隐式（如被函数调用的返回蕴含）地成功调用；否则，调用被<a href="Features/NPL.zh-CN.html#%CE%BB-%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">重入</a>，<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　捕获的续延之后允许被复制。</p>
<p><strong>注释</strong></p>
<p>　　<code>call1/cc</code> 的名称<a href="https://legacy.cs.indiana.edu/~dyb/pubs/call1cc.pdf">来源</a>同 Chez Scheme 。</p>
<p><code>continuation-&gt;applicative &lt;continuation&gt;</code></p>
<p>　　转换续延为<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">关联的等效</a>应用子。</p>
<p>　　结果是转换的 <code>&lt;applicative&gt;</code> 类型的值。</p>
<p>　　在构造结果时，<code>&lt;continuation&gt;</code> 被转发。</p>
<p>　　结果的底层合并子被调用时，传递操作数树给 <code>&lt;continuation&gt;</code> 。</p>
<p><code>apply-continuation &lt;continuation&gt; &lt;object&gt;</code></p>
<p>　　应用续延。</p>
<p>　　以第二参数作为参数，以 <code>apply</code> 应用第一参数指定的续延转换的应用子。</p>
<p><strong>原理</strong></p>
<p>　　同 [R<sup>n</sup>RK] ，<code>apply-continuation</code> 不接受可选的环境，因为非正常控制忽略动态环境。</p>
<p><strong>注释</strong></p>
<p>　　即同求值：<code>apply (continuation-&gt;applicative &lt;continuation&gt;) &lt;object&gt;</code> 。</p>
<p>　　<code>apply-continuation</code> 同 [R<sup>n</sup>RK] 。取得非 <code>&lt;list&gt;</code> 结果依赖 <code>apply</code> 对 <code>&lt;pair&gt;</code> 的支持，这在 Scheme 中无法实现。</p>
<h2 id="代理求值"><a class="header" href="#代理求值">代理求值</a></h2>
<p>　　代理求值支持保存求值为代理对象以实现延迟求值。</p>
<p>　　默认加载为根环境下的 <code>std.promises</code> 环境。</p>
<p><strong>模块约定：</strong></p>
<p>　　本节约定以下求值得到的操作数：</p>
<ul>
<li><code>&lt;promise&gt;</code> ：求值代理：表示可被求值而取得<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">结果对象</a>的对象。
<ul>
<li>保存待求值的表达式和这个表达式<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">求值时的动态环境</a>，或已求值的结果对象。</li>
</ul>
</li>
</ul>
<p><strong>原理</strong></p>
<p>　　代理求值的原语可实现惰性求值和透明的记忆化。</p>
<p>　　和一些流行的误解不同，尽管这些原语的原始设计是关于并行处理的，这不必然蕴含并发的投机执行(speculative execution) ，只是因为解析(resolve) 内部状态并不在用户程序中可见，而蕴含必要的最小同步。</p>
<p>　　由于<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">当前语言不支持并发访问</a>，即使对 <code>&lt;promise&gt;</code> 的<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改操作</a>导致变化，在语言中其状态也不可见，没有要求支持这种同步；未来可能会附加要求以提供更完善的并发支持。</p>
<p>　　关于 <a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 的设计，参见 [R<sup>n</sup>RK] §9 和 <a href="https://srfi.schemers.org/srfi-45/srfi-45.html">[SRFI-45]</a> 。</p>
<p><strong>注释</strong></p>
<p>　　在 <code>&lt;promise&gt;</code> 上的<a href="Features/NPL.zh-CN.html#npla-%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE">并发访问</a>并不具有特别的同步保证和要求。并发访问<a href="Features/NPL.zh-CN.html#npla1-%E7%A8%8B%E5%BA%8F%E5%A4%96%E9%83%A8%E7%8E%AF%E5%A2%83">可引起宿主语言的未定义行为</a>。</p>
<p>　　除 <code>$lazy/d</code> 外，同 [R<sup>n</sup>RK] 的 promises 模块。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，通过 <code>force</code> 引起 <code>&lt;promise&gt;</code> 对象的求值可能修改这个对象自身而使其中的状态失效（如通过 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>assign!</code></a>对这个对象赋值）。</p>
<p>　　因此，实现中需要重新访问状态，而重新进行类型检查。</p>
<p><strong>操作：</strong></p>
<p><code>promise? &lt;object&gt;</code></p>
<p>　　<code>&lt;promise&gt;</code> 的<a href="Features/NPL.zh-CN.html#%E8%B0%93%E8%AF%8D%E5%90%8D%E7%A7%B0%E5%90%8E%E7%BC%80">类型谓词</a>。</p>
<p><code>memoize &lt;object&gt;</code></p>
<p>　　记忆化求值：以参数作为已被求值的结果创建 <code>&lt;promise&gt;</code> 对象。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E7%BA%A6%E5%AE%9A">在结果中保留参数的引用值</a>。</p>
<p><code>$lazy &lt;body&gt;</code></p>
<p>　　惰性求值：以参数为待求值的表达式，以<a href="Features/NPL.zh-CN.html#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>作为这个表达式被求值的动态环境，创建 <code>&lt;promise&gt;</code> 对象。</p>
<p>　　当前环境的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境弱引用</a>的副本被保存到结果。</p>
<p><code>$lazy% &lt;body&gt;</code></p>
<p>　　同 <code>$lazy</code> ，但保留引用值。</p>
<p><code>$lazy/d &lt;environment&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$lazy</code> ，但以参数指定环境替代动态环境。</p>
<p><code>$lazy/d% &lt;environment&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$lazy%</code> ，但以参数指定环境替代动态环境。</p>
<p>　　参数指定的一等环境值的副本被保存到结果。</p>
<p><code>force &lt;object&gt;</code></p>
<p>　　若参数是 <code>&lt;promise&gt;</code> 值，立即求值指定的 <code>&lt;promise&gt;</code> 对象，得到的结果对象作为结果；否则，<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91">转发参数</a>作为结果。</p>
<p>　　若参数在求值时修改为非 <code>&lt;promise&gt;</code> 类型的值，需要继续迭代求值时，引起<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型错误</a>。</p>
<h2 id="数学库"><a class="header" href="#数学库">数学库</a></h2>
<p>　　数学库提供<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">数值类型</a>的操作和其它数学功能。</p>
<p>　　默认加载为根环境下的 <code>std.math</code> 环境。</p>
<p><strong>模块约定：</strong></p>
<p>　　以下操作中：</p>
<ul>
<li>除非另行指定，对应的函数调用的求值是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>。</li>
<li>涉及数值操作数的操作符合<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">数值操作约定</a>。</li>
<li>所有除法和取余数的计算符合<a href="Features/NPL.zh-CN.html#%E9%99%A4%E6%B3%95%E7%BA%A6%E5%AE%9A">除法约定</a>。</li>
</ul>
<p><strong>原理</strong></p>
<p>关于比较操作：</p>
<p>　　同 [R<sup>n</sup>RK] 而不同于 [R<sup>5</sup>RS] 、[R<sup>6</sup>RS] 和 [R<sup>7</sup>RS] ，比较操作不明确要求传递性（但精确数仍然因真值的数学性质而保证传递性），以允许操作数存在不精确数时，转换不精确数 flonum 的简单实现。</p>
<p>　　[R<sup>6</sup>RS] 继承了 [R<sup>5</sup>RS] 要求过程 <code>=</code> 具有传递性（注释指出传统类 Lisp 语言的实现不要求），而 [R<sup>7</sup>RS] 的对应注释指出这不能通过把所有操作数都转换为不精确数实现。</p>
<p>　　不要求不精确数的传递性和除法约定对除数为不精确数 0 值的处理兼容。</p>
<p>　　不同的语言在此<a href="https://codewords.recurse.com/issues/one/when-is-equality-transitive-and-other-floating-point-curiosities">可能有不同的规则</a>，可见：</p>
<ul>
<li>一些现代 Lisp 语言可能满足（即便不是 Scheme 实现，如 SBCL ）或不满足（即便是 Scheme 实现的派生，如 Racket ）此要求。</li>
<li>一些语言的不同版本的实现可能使用不同的规则（如 Ruby 1.8.7 和 Ruby 2.0 ）。</li>
</ul>
<p>　　使用以上链接中的测试用例，可发现一些 [R<sup>n</sup>RS] 的实现实际可能不符合 <code>=</code> 的传递性要求，如 x86-64 Linux 上：</p>
<ul>
<li>Chez Scheme 9.5.6 、Chibi Scheme 0.10.0 和 Gauche 0.9.11 不符合要求。</li>
<li>Chicken 5.3.0 、Guile 2.2.7 和 Gambit 4.9.4 符合要求。</li>
</ul>
<p>　　上述符合性问题已在以下实现中报告并被修复：</p>
<ul>
<li><a href="https://github.com/ashinn/chibi-scheme/issues/812">Chibi Scheme issue 812</a></li>
<li><a href="https://github.com/cisco/ChezScheme/issues/606">Chez Scheme issue 606</a></li>
<li><a href="https://github.com/shirok/Gauche/issues/805">Gauche issue 805</a></li>
</ul>
<p><strong>注释</strong></p>
<p>　　和数值操作约定不同，幂等操作要求超过一次应用时，结果和参数的宿主类型也相同。</p>
<p><strong>操作：</strong></p>
<p><code>number? &lt;object&gt;</code></p>
<p>　　<code>&lt;number&gt;</code> 的<a href="Features/NPL.zh-CN.html#%E8%B0%93%E8%AF%8D%E5%90%8D%E7%A7%B0%E5%90%8E%E7%BC%80">类型谓词</a>。</p>
<p><code>complex? &lt;object&gt;</code></p>
<p>　　<code>&lt;complex&gt;</code> 的类型谓词。</p>
<p><strong>注释</strong> 同 <code>number?</code> ，因为当前 <code>&lt;number&gt;</code> 值都是 <code>&lt;complex&gt;</code> 值。</p>
<p><code>real? &lt;object&gt;</code></p>
<p>　　<code>&lt;real&gt;</code> 的类型谓词。</p>
<p><strong>注释</strong> 同 <code>complex?</code> ，因为当前 <code>&lt;complex&gt;</code> 值都是 <code>&lt;real&gt;</code> 值。</p>
<p><code>rational? &lt;object&gt;</code></p>
<p>　　<code>&lt;rational&gt;</code> 的类型谓词。</p>
<p><strong>注释</strong> 当前实现仅需排除<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">无限大和 NaN 值</a>。</p>
<p><code>integer? &lt;object&gt;</code></p>
<p>　　<code>&lt;integer&gt;</code> 的类型谓词。</p>
<p><code>exact-integer? &lt;object&gt;</code></p>
<p>　　判断参数是否为 <code>&lt;integer&gt;</code> 类型的<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">精确数</a>对象。</p>
<p><code>fixnum? &lt;object&gt;</code></p>
<p>　　判断参数是否为 <a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">fixnum</a>对象。</p>
<p><code>flonum? &lt;object&gt;</code></p>
<p>　　判断参数是否为 <a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">flonum</a>对象。</p>
<p><code>exact? &lt;number&gt;</code></p>
<p>　　判断参数是否为精确数。</p>
<p><strong>注释</strong> 当前精确数都是 fixnum 。</p>
<p><code>inexact? &lt;number&gt;</code></p>
<p>　　判断参数是否为<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">不精确数</a>。</p>
<p><strong>注释</strong> 当前不精确数都是 flonum 。</p>
<p><code>finite? &lt;number&gt;</code></p>
<p>　　判断参数是否为<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">有限值</a>。</p>
<p><code>infinite? &lt;number&gt;</code></p>
<p>　　判断参数是否为无限大值。</p>
<p><code>nan? &lt;number&gt;</code></p>
<p>　　判断参数是否为 NaN 值。</p>
<p><code>=? &lt;number1&gt; &lt;number2&gt;</code></p>
<p>　　比较相等。</p>
<p><code>&lt;? &lt;real1&gt; &lt;real2&gt;</code></p>
<p>　　比较小于。</p>
<p><code>&gt;? &lt;real1&gt; &lt;real2&gt;</code></p>
<p>　　比较大于。</p>
<p><code>&lt;=? &lt;real1&gt; &lt;real2&gt;</code></p>
<p>　　比较小于等于。</p>
<p><code>&gt;=? &lt;real1&gt; &lt;real2&gt;</code></p>
<p>　　比较大于等于。</p>
<p><code>zero? &lt;number&gt;</code></p>
<p>　　判断参数是否为零值。</p>
<p><code>positive? &lt;real&gt;</code></p>
<p>　　判断参数是否为正数。</p>
<p><code>negative? &lt;real&gt;</code></p>
<p>　　判断参数是否为负数。</p>
<p><code>odd? &lt;real&gt;</code></p>
<p>　　判断参数是否为奇数。</p>
<p><code>even? &lt;real&gt;</code></p>
<p>　　判断参数是否为偶数。</p>
<p><code>max &lt;real1&gt; &lt;real2&gt;</code></p>
<p>　　计算参数中的最大值。</p>
<p><code>min &lt;real1&gt; &lt;real2&gt;</code></p>
<p>　　计算参数中的最小值。</p>
<p><code>add1 &lt;number&gt;</code></p>
<p>　　计算参数加 1 的值。</p>
<p><code>sub1 &lt;number&gt;</code></p>
<p>　　计算参数减 1 的值。</p>
<p><code>+ &lt;number1&gt; &lt;number2&gt;</code></p>
<p>　　加法：计算参数的和。</p>
<p><code>- &lt;number1&gt; &lt;number2&gt;</code></p>
<p>　　减法：计算参数的差。</p>
<p><code>* &lt;number1&gt; &lt;number2&gt;</code></p>
<p>　　乘法：计算参数的积。</p>
<p><code>/ &lt;number1&gt; &lt;number2&gt;</code></p>
<p>　　除法：计算参数的商。</p>
<p><code>abs &lt;real&gt;</code></p>
<p>　　计算参数的绝对值。</p>
<p>　　<code>abs</code> 是<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">幂等操作</a>。</p>
<p><strong>注释</strong> 同 [R<sup>n</sup>RS] 和 [R<sup>n</sup>RK] ，当前仅支持 <code>&lt;real&gt;</code> ，尽管数学上这对 <code>&lt;complex&gt;</code> 也有意义。</p>
<p><code>floor/ &lt;integer1&gt; &lt;integer2&gt;</code></p>
<p>　　数论除法：计算参数向下取整的整除的商和余数。</p>
<p><code>floor-quotient &lt;integer1&gt; &lt;integer2&gt;</code></p>
<p>　　数论除法：计算参数向下取整的整除的商。</p>
<p><code>floor-remainder &lt;integer1&gt; &lt;integer2&gt;</code></p>
<p>　　数论除法：计算参数向下取整的整除的余数。</p>
<p><code>truncate/ &lt;integer1&gt; &lt;integer2&gt;</code></p>
<p>　　数论除法：计算参数截断取整的整除的商和余数。</p>
<p><code>truncate-quotient &lt;integer1&gt; &lt;integer2&gt;</code></p>
<p>　　数论除法：计算参数截断取整的整除的商。</p>
<p><code>truncate-remainder &lt;integer1&gt; &lt;integer2&gt;</code></p>
<p>　　数论除法：计算参数截断取整的整除的余数。</p>
<p><code>inexact &lt;number&gt;</code></p>
<p>　　取和参数值最接近的不精确数：</p>
<ul>
<li>若参数是不精确数，则结果是参数值。</li>
<li>否则，若参数超过任意不精确数内部表示的有限值的范围，则结果是未指定宿主类型的对应符号的无限大值。</li>
<li>否则，若不存在和参数数值相等（以 <code>=?</code> 判断）的不精确数，则引起错误。</li>
<li>否则，结果是和参数数值相等的不精确数。</li>
</ul>
<p>　　<code>inexact</code> 是幂等操作。</p>
<p><strong>原理</strong></p>
<p>　　这里明确约定了<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">错误条件</a>，这和 [R<sup>n</sup>RK] 及 [R<sup>n</sup>RS] 宽松地允许引起错误（也允许不引起<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">要求诊断的错误</a>）不同。</p>
<p>　　允许返回无限大值使程序容易判断非预期值的原因。使用浮点数作为不精确数，无限大值的结果符合 [IEC 60559] 的定义。实际 [R<sup>n</sup>RS] 实现及 klisp 普遍使用这种实现。</p>
<p>　　对其它情形保证 <code>=?</code> 比较的后置条件允许用户定义严格相等的转换函数（通过对结果应用 <code>infinite?</code> 可发现并排除无限大值）。</p>
<p>　　典型实现中，当参数是 <a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">fixnum</a>值时，结果通常不超过不精确数能表示的范围，也不需要引起错误。</p>
<p><strong>注释</strong> 同 [R<sup>6</sup>RS] 和 [R<sup>7</sup>RS] 的同名过程，及 [R<sup>5</sup>RS] 的 <code>exact-&gt;inexact</code> ；因为当前实现不支持不是 <code>&lt;real&gt;</code> 的 <code>&lt;number&gt;</code> ，也同 [R<sup>n</sup>RK] 的 real-&gt;inexact 。关于 [R<sup>n</sup>RS] 中的命名，另见 <a href="https://small.r7rs.org/ticket/328/">R<sup>7</sup>RS ticket 328</a> 和 [R<sup>7</sup>RS] 的相关注释。</p>
<p><code>string-&gt;number &lt;string&gt;</code></p>
<p>　　转换字符串为数值。</p>
<p>　　若转换成功，结果是对应参数作为外部表示的数值。否则，结果是 <code>#f</code> 。</p>
<p>　　不因转换失败引起错误。</p>
<p>　　数值包括所有实现支持的值。</p>
<p><strong>注释</strong> 同 [R<sup>7</sup>RS] 的同名过程，但不支持附加的可选的进位制参数。</p>
<p><code>number-&gt;string &lt;number&gt;</code></p>
<p>　　转换数值为字符串。</p>
<p><strong>注释</strong> 同 [R<sup>7</sup>RS] 的同名过程，但不支持附加的可选的进位制参数且不因特定的参数值出错。</p>
<h3 id="除法约定"><a class="header" href="#除法约定">除法约定</a></h3>
<p>　　二元除法或者取余数的操作中，第一个参数是被除数，第二个参数是除数。</p>
<p>　　数论除法的结果中的数值具有整数类型。</p>
<p>　　当除数是不精确数 0 时：</p>
<ul>
<li>若被除数是非零有限数值或无限大值，则商的符号同被除数的符号。</li>
<li>否则，商的符号未指定。</li>
</ul>
<p>　　当被除数是不精确数时，若除数是精确数 0 ，则结果除符号外同除数是不精确数 0 的情形。</p>
<p>　　同时计算商和余数的操作的结果是商和余数构成的列表。</p>
<p><strong>原理</strong></p>
<p>　　Scheme 方言及实现中普遍存在不同的除零错误的条件。</p>
<p>　　[R<sup>5</sup>RS] 的过程 <code>/</code> 除以零的条件没有被明确约定。</p>
<p>　　[R<sup>6</sup>RS] 则明确要求过程 <code>/</code> 中：</p>
<ul>
<li>在所有参数为精确数，若除数存在零值时，引发条件类型为 <code>&amp;assertion</code> 的异常。</li>
<li>否则，以例子指定除数存在零值时的结果：
<ul>
<li>若被除数为非零有限数值，结果为符号同被除数的。</li>
<li>否则，结果为正的 NaN 值。</li>
</ul>
</li>
</ul>
<p>　　[R<sup>7</sup>RS] 中修订 [R<sup>5</sup>RS] 的过程 <code>/</code> 中存在精确数 0 作为除数的除法结果是错误，但这不要求引起错误。实现可以引起错误，或结果具有未指定的错误的值。</p>
<p>　　[R<sup>7</sup>RS] 实际维持 [R<sup>5</sup>RS] 的条件不变，而非 [R<sup>6</sup>RS] 附加更多的要求；参见 <a href="https://small.r7rs.org/ticket/367/">R<sup>7</sup>RS ticket 367</a> ，但其中关于 [R<sup>6</sup>RS] 实现可转换操作数为不精确数和其它操作一致有误，因为 [R<sup>6</sup>RS] 的过程 = 不能以此方式实现（参见以上关于比较操作的原理的讨论）。</p>
<p>　　不同的 Scheme 实现对零值的处理（包括除零错误的条件）另见<a href="https://small.r7rs.org/wiki/Zero/">这里</a> 。</p>
<p>　　[R<sup>n</sup>RK] 的合并子 <code>/</code> ，存在任意除数为零值则引起错误。</p>
<p>　　因为 [R<sup>n</sup>RK] 的不精确数是可选模块，不讨论除数的零值是否精确值而保持简单性是合理的。</p>
<p>　　[R<sup>n</sup>RS] 明确要求支持精确数和不精确数（存在不同的字面量），但是只有 [R<sup>6</sup>RS] 要求存在不精确值时的确切结果。</p>
<p>　　<a href="Features/NPL.zh-CN.html#npla-%E6%95%B0%E5%AD%A6%E5%8A%9F%E8%83%BD">NPLAMath</a>的数值操作约定和 [R<sup>7</sup>RS] 类似，但在此附加和 [R<sup>6</sup>RS] 类似的要求而覆盖数值操作约定，因为：</p>
<ul>
<li>不精确数 0 往往来自表示<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">下溢</a>的计算结果，而不是精确的真值 0 ，因此数学上商应存在定义。
<ul>
<li>参见 <a href="https://people.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF">IEEE-754 的分析</a>。</li>
<li>另见<a href="https://stackoverflow.com/a/14684474">这里</a>。</li>
</ul>
</li>
<li>同 [R<sup>n</sup>RS] ，NPLAMath 支持的不精确数允许自然地定义除数为不精确数 0 时的结果：
<ul>
<li>NPLAMath 明确要求支持不精确数（而非 [R<sup>n</sup>RK] 作为可选的特性提供），能区分不精确数 0 和精确数 0 的不同结果。</li>
<li>NPLAMath 的不精确数 0 允许支持符号据此确定作为商的无限值的符号（而非 [R<sup>n</sup>RK] 无法区分符号而无法按数学定义确定极限值的符号）。</li>
</ul>
</li>
<li>这些规则允许更优化的实现：
<ul>
<li>避免要求实现检查特定的精确数（在此是精确数 0 ）的存在，而允许更简单高效的直接使用 <a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">flonum</a>内部操作的实现。</li>
<li>不在此转换不精确数到精确数，和当前实现<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">没有提供精确数可能替换计算结果中的不精确数的机制</a>具有更好的一致性。</li>
</ul>
</li>
<li>不存在 [R<sup>n</sup>RS] 需要关心继续使用 [R<sup>6</sup>RS] 规则的<a href="https://small.r7rs.org/ticket/367/">一些问题</a>：
<ul>
<li>在被除数和除数都存在零值时，没有同 [R<sup>6</sup>RS] 的 / 的例子要求结果的符号，逻辑上仍然能保持一致。</li>
<li>NPLA1 不需要考虑不完全支持不精确数的（不满足 [R<sup>n</sup>RS] 符合性）的实现的兼容性等问题。</li>
</ul>
</li>
</ul>
<p><strong>注释</strong></p>
<p>　　同 [R<sup>7</sup>RS] ，若被除数是零值，且除数不是精确数 0 ，计算结果可能是精确数 0 。但当前实现没有提供精确数替换计算结果中的这种机制。</p>
<p>　　NPLA1 <code>std.math</code> 中名称以 <code>floor</code> 和 <code>truncate*</code> 起始的函数的语义同 [R<sup>7</sup>RS] 的定义，要求参数是整数。一些 Scheme 实现不严格要求整数。</p>
<p>　　[R<sup>6</sup>RS] 的整除基本操作（过程 <code>div</code> 、<code>mod</code> 、<code>div0</code> 、<code>mod0</code> ）没有严格定义，仅通过例子说明一些差异，但明确不要求整数。</p>
<p>　　[R<sup>n</sup>RK] 的整除同 [R<sup>6</sup>RS] ，但描述和 [R<sup>6</sup>RS] 矛盾；klisp 实现行为同 [R<sup>6</sup>RS] 。</p>
<p>　　更一般的定义参见 <a href="https://srfi.schemers.org/srfi-141/srfi-141.html">[SRFI-141]</a> 和其它相关参考文献：</p>
<!-- markdownlint-capture -->
<!-- markdownlint-disable MD034 -->
<ul>
<li>http://dl.acm.org/citation.cfm?id=128862</li>
<li>http://people.csail.mit.edu/riastradh/tmp/division.txt</li>
<li>https://www.gnu.org/software/guile/manual/html_node/Arithmetic.html</li>
<li>https://github.com/johnwcowan/r7rs-work/blob/master/WG1Ballot3Results.md#185-add-sixth-centered-division-operator</li>
<li>https://wiki.call-cc.org/eggref/5/srfi-141</li>
</ul>
<!-- markdownlint-restore -->
<h2 id="字符串库"><a class="header" href="#字符串库">字符串库</a></h2>
<p>　　提供字符串和正则表达式的相关操作。</p>
<p>　　默认加载为根环境下的 <code>std.strings</code> 环境。</p>
<p><strong>模块约定：</strong></p>
<p>　　本节约定以下求值得到的操作数：</p>
<ul>
<li><code>&lt;regex&gt;</code> ：正则表达式。</li>
</ul>
<p>　　为提供<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">宿主语言互操作</a>支持，正则表达式以 <code>std::regex</code> 类型表示，实现保证可通过 <code>&lt;string&gt;</code> 对应的 <a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84"><code>string</code></a> 值初始化。</p>
<p>　　除非另行指定，以上所有正则表达式的操作使用 [ISO C++11] 指定的默认选项，即：</p>
<ul>
<li><code>std::regex_constants::ECMAScript</code> 。</li>
<li><code>std::regex_constants::match_default</code> 。</li>
<li><code>std::regex_constants::format_default</code> 。</li>
</ul>
<p><strong>操作：</strong></p>
<p><code>string? &lt;object&gt;</code></p>
<p>　　<code>&lt;string&gt;</code> 的<a href="Features/NPL.zh-CN.html#%E8%B0%93%E8%AF%8D%E5%90%8D%E7%A7%B0%E5%90%8E%E7%BC%80">类型谓词</a>。</p>
<p><code>++ &lt;string&gt;...</code></p>
<p>　　字符串串接。</p>
<p><code>string-empty? &lt;string&gt;</code></p>
<p>　　判断字符串是否为空。</p>
<p><strong>注释</strong> 同 <a href="https://srfi.schemers.org/srfi-152/srfi-152.html">[SRFI-152]</a> 的过程 <code>string-null?</code> 。</p>
<p><code>string&lt;- &lt;string1&gt; &lt;string2&gt;</code></p>
<p>　　字符串<a href="Features/NPL.zh-CN.html#%E8%B5%8B%E5%80%BC">赋值</a>。</p>
<p>　　以第二参数为源，修改第一参数指定的目标。</p>
<p><code>string-trim &lt;string1&gt;</code></p>
<p>　　删除字符串中指定的连续前缀空白符。</p>
<p>　　空白符是 C++ 字符串中 <code>" \n\r\t\v"</code> 的字符之一。</p>
<p><strong>注释</strong> 同 [SRFI-152] 的过程 <code>string-trim-both</code> ，但不支持可选参数，且默认指定的空白符不同。</p>
<p><code>string-trim-left &lt;string1&gt;</code></p>
<p>　　删除字符串中指定的连续后缀空白符。</p>
<p>　　空白符同 <code>string-trim</code> 中的定义。</p>
<p><strong>注释</strong> 同 [SRFI-152] 的过程 <code>string-trim</code> ，但不支持可选参数，且默认指定的空白符不同。</p>
<p><code>string-trim-right &lt;string1&gt;</code></p>
<p>　　删除字符串中指定的连续前缀和后缀空白符。</p>
<p>　　空白符同 <code>string-trim</code> 中的定义。</p>
<p><strong>注释</strong> 同 [SRFI-152] 的同名过程，但不支持可选参数，且默认指定的空白符不同。</p>
<p><code>string-prefix? &lt;string1&gt; &lt;string2&gt;</code></p>
<p>　　判断第一参数是否包含第二参数作为前缀子串。</p>
<p><strong>注释</strong> 同 [SRFI-152] 的同名过程，但不支持可选参数。</p>
<p><code>string-suffix? &lt;string1&gt; &lt;string2&gt;</code></p>
<p>　　判断第一参数是否包含第二参数作为后缀子串。</p>
<p><strong>注释</strong> 同 [SRFI-152] 的同名过程，但不支持可选参数。</p>
<p><code>string-contains? &lt;string1&gt; &lt;string2&gt;</code></p>
<p>　　判断第一参数是否包含第二参数作为子串。</p>
<p><strong>注释</strong></p>
<p>　　一个串总是包含相等的串。空串被任何串包含，且总是不包含任何非空串。</p>
<p>　　同 [SRFI-152] 的过程 <code>string-contains</code> ，但不支持可选参数，且结果是 <code>#t</code> 或 <code>#f</code> 。</p>
<p><code>string-contains-ci? &lt;string1&gt; &lt;string2&gt;</code></p>
<p>　　判断第一参数是否包含第二参数作为子串，忽略大小写。</p>
<p>　　只在单字节字符集内的字符中区分大小写。</p>
<p><strong>注释</strong> 除不区分大小写外同 <code>string-contains?</code> 。</p>
<p><code>string-split &lt;string1&gt; &lt;string2&gt;</code></p>
<p>　　取第二参数分隔第一参数得到的字符串的列表。</p>
<p><strong>注释</strong> 同 [SRFI-152] 的同名过程，但不支持可选参数。</p>
<p><code>string-&gt;symbol &lt;string&gt;</code></p>
<p>　　转换字符串为符号。</p>
<p><code>symbol-&gt;string &lt;symbol&gt;</code></p>
<p>　　转换符号为字符串。</p>
<p>　　不检查值是否符合符号要求。</p>
<p><code>string-&gt;regex &lt;string&gt;</code></p>
<p>　　转换字符串为以这个字符串作为串的正则表达式。</p>
<p>　　若正则表达式无效，则<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p><code>regex-match? &lt;string&gt; &lt;regex&gt;</code></p>
<p>　　判断字符串中是否匹配正则表达式的模式串。</p>
<p>　　若 <code>&lt;string&gt;</code> 匹配 <code>&lt;regex&gt;</code> 指定的模式串，结果是 <code>#t</code> ，否则结果是 <code>#f</code> 。</p>
<p><code>regex-replace &lt;string1&gt; &lt;regex&gt; &lt;string2&gt;</code></p>
<p>　　替换字符串中的模式串，构造新字符串。</p>
<p>　　在 <code>&lt;string1&gt;</code> 的副本中搜索正则表达式指定的模式串的所有匹配，替换为 <code>&lt;string2&gt;</code> 指定的格式字符串。</p>
<p>　　结果是替换后的字符串。</p>
<p><strong>注释</strong></p>
<p>　　当前实现不处理实现抛出的 <code>std::regex_error</code> 异常。</p>
<h2 id="输入输出库"><a class="header" href="#输入输出库">输入/输出库</a></h2>
<p>　　提供输入/输出操作。</p>
<p>　　默认加载为根环境下的 <code>std.io</code> 环境。</p>
<p><strong>模块约定：</strong></p>
<p>　　文件系统中创建或移除项的函数的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>是表示操作是否成功的 <code>&lt;bool&gt;</code> 值。</p>
<p>　　除非另行指定：</p>
<ul>
<li>对创建目录的操作，在若目录已存在，则视为操作失败且无作用；否则，若创建失败，则<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">引起错误</a>。</li>
<li>对创建多个目录的操作，仅在所有目录都创建成功时操作成功。操作失败可能仍存在部分目录被创建成功。</li>
<li>对访问文件的操作，若读或写失败，则引起错误。</li>
<li>对访问文件系统路径的操作，除非另行指定，若<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">实现环境</a>支持跟随文件系统对象的链接，隐含跟随链接（即解析指定链接的文件系统路径到最终的非链接对象作为路径指定的资源）。
<ul>
<li>解析链接可能引起错误。</li>
<li><strong>注释</strong> 文件系统对象链接的实例如 POSIX 符号链接(symbolic link) 和 Windows 重解析点(reparse point) 。</li>
</ul>
</li>
</ul>
<p><strong>原理</strong></p>
<p>　　文件系统解析文件名可支持链接，但不是所有环境有同等支持。</p>
<p>　　<a href="https://scsh.net/docu/html/man-Z-H-4.html#node_idx_318">Scsh 的 <code>file-not-readable?</code></a> 等明确不支持 <code>chase?</code> 指定跟随链接，理由是不检查符号链接权限，但这并不充分。</p>
<p>　　事实上：</p>
<ul>
<li>对 POSIX 实现：
<ul>
<li><a href="https://pubs.opengroup.org/onlinepubs/9699919799.2008edition/">POSIX.1-2008</a> 和<a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/access.html">后续修订的 <code>faccessat</code></a> 不支持 <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/fcntl.h.html"><code>AT_SYMLINK_NOFOLLOW</code></a> 。</li>
<li><a href="https://man.freebsd.org/cgi/man.cgi?query=faccessat&amp;sektion=2&amp;n=1">FreeBSD 的 <code>faccessat</code></a> 也不支持 <code>AT_SYMLINK_NOFOLLOW</code> 。</li>
<li>但是，<a href="https://man7.org/linux/man-pages/man2/access.2.html">Linux (glibc)</a> 和 <a href="https://android-review.googlesource.com/c/platform/bionic/+/128582">bionic</a> 可支持 <code>AT_SYMLINK_NOFOLLOW</code> 。</li>
<li>于是，至少在特定的 POSIX 实现中，对链接自身的权限判断是有意义的。</li>
</ul>
</li>
<li>此外，Windows 也允许单独判断链接和不同链接目标的权限。</li>
</ul>
<p>　　因此，一般的 API 应当允许区分访问文件是否跟随链接。</p>
<p><strong>注释</strong></p>
<p>　　当前派生实现依赖可用的 <a href="Features/NPL.zh-CN.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BA%93"><code>std.strings</code></a>环境。</p>
<p>　　当前实现的文件系统操作失败可能修改宿主环境的 <code>errno</code> 。</p>
<p><strong>操作：</strong></p>
<p><code>file-exists? &lt;string&gt;</code></p>
<p>　　判断参数指定的文件名对应的文件是否存在。</p>
<p><strong>注释</strong></p>
<p>　　同：</p>
<ul>
<li>[R<sup>7</sup>RS] 的同名过程，但明确跟随链接。</li>
<li><a href="https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s141">Chez Scheme 的同名过程</a>，但不支持可选参数。
<ul>
<li>Chez Scheme（至少在截至版本 9.5.6 ）在 Windows 上<a href="https://github.com/cisco/ChezScheme/issues/716">并没有实现可选参数，实际总是不跟随链接</a>。</li>
</ul>
</li>
</ul>
<p><code>file-directory? &lt;string&gt;</code></p>
<p>　　判断参数指定的文件名对应的文件是否存在且为目录文件。</p>
<p><strong>注释</strong></p>
<p>　　同：</p>
<ul>
<li><a href="https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s143">Chez Scheme 的同名过程</a>，但不支持可选参数。
<ul>
<li>参见 <code>file-exists?</code> 的注释。</li>
</ul>
</li>
<li><a href="https://practical-scheme.net/gauche/man/gauche-refe/System-interface.html#index-file_002dis_002ddirectory_003f">Gauche</a> 和 <a href="https://stklos.net/Doc/html/stklos-ref-4.html#--index-entry-32817">STklos</a> 的 <code>file-is-directory?</code> ，但明确跟随链接。</li>
</ul>
<p><code>file-regular? &lt;string&gt;</code></p>
<p>　　判断参数指定的文件名对应的文件是否存在且为常规文件。</p>
<p><strong>注释</strong></p>
<p>　　同：</p>
<ul>
<li><a href="https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s142">Chez Scheme 的同名过程</a>，但不支持可选参数。
<ul>
<li>参见 <code>file-exists?</code> 的注释。</li>
</ul>
</li>
<li><a href="https://practical-scheme.net/gauche/man/gauche-refe/System-interface.html#index-file_002dis_002dregular_003f">Gauche</a> 和 <a href="https://stklos.net/Doc/html/stklos-ref-4.html#--index-entry-32813">STklos</a> 的 <code>file-is-regular?</code> ，但明确跟随链接。</li>
</ul>
<p><code>readable-file? &lt;string&gt;</code></p>
<p>　　判断参数指定的文件名对应的文件是否存在且可读。</p>
<p><strong>注释</strong></p>
<p>　　同：</p>
<ul>
<li><a href="https://scsh.net/docu/html/man-Z-H-4.html#node_idx_324">Scsh 的 <code>file-readable?</code></a>。</li>
<li><a href="https://practical-scheme.net/gauche/man/gauche-refe/Filesystem-utilities.html#index-file_002dis_002dreadable_003f">Gauche</a> 和 <a href="https://stklos.net/Doc/html/stklos-ref-4.html#--index-entry-32805">STklos</a> 的 <code>file-is-readable?</code> ，但明确跟随链接。</li>
</ul>
<p><code>readable-nonempty-file? &lt;string&gt;</code></p>
<p>　　判断参数指定的文件名对应的文件是否存在、可读且文件内容非空。</p>
<p><code>writable-file? &lt;string&gt;</code></p>
<p>　　判断参数指定的文件名对应的文件是否存在且可写。</p>
<p><strong>注释</strong></p>
<p>　　同：</p>
<ul>
<li><a href="https://scsh.net/docu/html/man-Z-H-4.html#node_idx_326">Scsh 的 <code>file-writable?</code></a>。</li>
<li><a href="https://practical-scheme.net/gauche/man/gauche-refe/Filesystem-utilities.html#index-file_002dis_002dwritable_003f">Gauche</a> 和 <a href="https://stklos.net/Doc/html/stklos-ref-4.html#--index-entry-32809">STklos</a> 的 <code>file-is-writable?</code> ，但明确跟随链接。</li>
</ul>
<p><code>() newline</code></p>
<p>　　输出换行并刷新缓冲。</p>
<p>　　若无法输出，则没有作用。</p>
<p><code>put &lt;string&gt;</code></p>
<p>　　输出字符串。</p>
<p><code>puts &lt;string&gt;</code></p>
<p>　　输出字符串和换行并刷新缓冲。</p>
<p><strong>注释</strong> 同 <code>put</code> 和 <code>newline</code> 的组合。</p>
<p><strong>原理</strong> 和 ISO C 的 <code>puts</code> 不同，保证刷新缓冲，以对交互式设备具有更友好的行为一致性。</p>
<p><code>load &lt;string&gt;</code></p>
<p>　　加载参数指定的翻译单元作为<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9D%97">源</a>的<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9D%97">模块</a>。</p>
<p>　　加载时在<a href="Features/NPL.zh-CN.html#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>读取翻译单元后求值，以求值后的这个环境对象作为调用的结果。</p>
<p>　　参数是指定源的确切位置的<a href="Features/NPL.zh-CN.html#npla1-%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E6%89%A9%E5%B1%95%E7%8E%AF%E5%A2%83">加载路径</a>。当前实现中，参数为文件系统路径。</p>
<p>　　被加载的翻译单元视为对象的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">外部表示</a>，经读取翻译为 NPLA1 对象。</p>
<p><strong>原理</strong></p>
<p>　　和 [R<sup>7</sup>RS] 不同，<code>load</code> 不支持指定环境，而总是使用当前环境。</p>
<p>　　类似 Kernel ，当前环境可通过不同机制改变，而不需由 <code>load</code> 提供特设的支持。例如，可使用 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>eval</code></a>指定蕴含 <code>load</code> 的调用的求值使用的环境。</p>
<p>　　和其它一些语言的类似命名的功能（如 Lua 的 <code>loadfile</code> ）不同，<code>load</code> 的语义隐含从外部来源取得求值构造(evaluation construct) 后在当前环境求值，其中的求值明确允许隐含副作用。在此，<code>load</code> 的求值被视为初始化加载的模块过程中的一部分。</p>
<p>　　因为当前不提供取得求值构造的读取(read) 等函数，不要求 <code>load</code> 具有非本机的派生实现。并且，取得求值构造可能有其它方式，如从二进制映像映射(map) 到内部表示等替代，这些实现通常不应被要求为总是具有本机派生实现而降低实现质量。</p>
<p><strong>注释</strong></p>
<p>　　参数一般指定视为外部翻译单元的文件名。</p>
<p>　　类似 klisp 的同名操作。类似地，不使用 klisp 的 <code>find-required-filename</code> 机制，直接以宿主的运行环境为基准使用路径。</p>
<p>　　和 klisp 不同，在尾上下文中求值被加载后读取的对象，并以其求值结果作为操作的结果，且错误不影响操作的结果。</p>
<p>　　[Shu09] 缺少 <code>load</code> 的详细描述而仅有标题。</p>
<p>　　另见以下关于 <code>get-module</code> 的说明。</p>
<p><code>get-module &lt;string&gt; &lt;environment&gt;?</code></p>
<p>　　创建标准环境并在其中加载模块。</p>
<p>　　创建<a href="Features/NPL.zh-CN.html#%E6%96%B0%E7%8E%AF%E5%A2%83">新</a>标准环境并以这个环境为当前环境加载 <code>&lt;string&gt;</code> 指定的翻译单元作为源的模块。</p>
<p>　　若第二参数非空，则在加载前首先绑定创建的环境中的 <code>module-parameters</code> 变量为第二参数的值。</p>
<p>　　结果在加载完成后取得，是先前被创建的标准环境。</p>
<p><strong>注释</strong></p>
<p>　　第一参数的作用同 <code>load</code> 的参数。</p>
<p>　　类似 klisp 和 [Shu09] 中的同名操作。</p>
<p>　　<a href="http://klisp.org/docs/Ports.html#Ports">klisp 文档中的 <code>load</code></a> 描述中求值环境有误：</p>
<ul>
<li>按 [Shu09] 一致的描述和 klisp 的实际实现，调用 <code>load</code> 时应在当前环境求值，而不同于 [Shu09] 的 <code>get-module</code> 中描述的使用创建的新标准环境进行求值。</li>
<li>否则，使用 [Shu09] 的 <code>get-module</code> 的派生不能实现 klisp 和 [Shu09] 中描述的 <code>get-module</code> 的预期语义。</li>
</ul>
<p><code>absolute-path? &lt;string&gt;</code></p>
<p>　　判断参数是否指定绝对路径。</p>
<p><strong>注释</strong></p>
<p>　　同：</p>
<ul>
<li><a href="https://practical-scheme.net/gauche/man/gauche-refe/Filesystem-utilities.html#index-absolute_002dpath_003f">Gauche 的同名过程</a>。</li>
<li><a href="https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s154">Chez Scheme 的 <code>path-absolute?</code></a> 。</li>
<li><a href="http://api.call-cc.org/5/doc/chicken/pathname#sec:absolute-pathname.3f">Chicken 的 <code>absolute-pathname?</code></a> 。</li>
<li><a href="https://www.gnu.org/software/guile/manual/html_node/File-System.html">Guile 的 <code>absolute-file-name?</code></a> 。</li>
</ul>
<p><code>path-parent &lt;string&gt;</code></p>
<p>　　参数字符串视为路径，结果是字符串指定的路径所在的父目录（当路径非根目录），或路径自身转换到的字符串值。</p>
<p>　　结果的路径不带有结尾分隔符。不检查路径实际存在。</p>
<p><strong>注释</strong></p>
<p>　　同：</p>
<ul>
<li><a href="https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s154">Chez Scheme 的同名过程</a>。</li>
<li><a href="http://api.call-cc.org/5/doc/chicken/pathname#sec:pathname-directory">Chicken 的 <code>pathname-directory</code></a> ，但对不包含目录的参数，结果是空串而不是 <code>#f</code> 。
<ul>
<li><strong>注释</strong> 文档没有显示指出结果是 <code>#f</code> 。</li>
</ul>
</li>
<li><a href="https://practical-scheme.net/gauche/man/gauche-refe/System-interface.html#index-sys_002ddirname">Gauche 的 <code>sys-dirname</code></a> ，但对不包含目录的参数，结果是空串而不是 <code>.</code> 。
<ul>
<li><strong>注释</strong> 文档没有显示指出结果是 <code>.</code> 。</li>
</ul>
</li>
<li><a href="https://www.gnu.org/software/guile/manual/html_node/File-System.html">Guile 的 <code>dirname</code></a> ，但对不包含目录的参数，结果是空串而不是 <code>.</code> 。</li>
</ul>
<p><code>remove-file &lt;string&gt;</code></p>
<p>　　移除参数指定的路径命名的文件。若成功结果为 <code>#t</code> ，否则结果为 <code>#f</code> 。</p>
<p><strong>注释</strong></p>
<p>　　同：</p>
<!-- markdownlint-disable-next-line MD034 -->
<ul>
<li>[STklos 的同名过程](https://stklos.net/Doc/html/stklos-ref-4.html#delete-file) ，但通过函数值指定调用失败而非引起错误。</li>
<li>[R<sup>7</sup>RS] 的 <code>delete-file</code> ，但通过函数值指定调用失败而非引起错误。</li>
</ul>
<p><code>create-directory &lt;string&gt;</code></p>
<p>　　创建参数指定的名称的文件系统目录。</p>
<p><strong>原理</strong></p>
<p>　　<code>create-directory</code> 在一些其它语言的实现中命名为 <code>make-directory</code> 。</p>
<p>　　NPLA1 中，作为非正式约定，<code>make</code> 前缀被预留给通过函数值得到创建的对象的过程。</p>
<p>　　这和 <a href="https://practical-scheme.net/gauche/man/gauche-refe/Filesystem-utilities.html">Gauche 不区分两者</a>不同。</p>
<p>　　使用 <code>create-directory</code> 的命名也和 <a href="https://srfi.schemers.org/srfi-170/srfi-170.html">[SRFI-170]</a> 一致，但 NPLA1 中，目录存在时不引起错误而以函数值 <code>#f</code> 指示。</p>
<p>　　此外，[ISO C++] 中存在类似名称的<a href="https://eel.is/c++draft/fs.op.funcs#fs.op.create.directory">函数 <code>std::filesystem::create_directory</code></a> 。</p>
<p><strong>注释</strong></p>
<p>　　类似：</p>
<ul>
<li><a href="http://api.call-cc.org/5/doc/chicken/file#def:create-directory">Checken 的同名过程</a>，但不支持可选参数且函数值不同。</li>
<li><a href="https://scsh.net/docu/html/man-Z-H-4.html#node_sec_3.3">Scsh 的同名过程</a>，但不支持包括权限的可选参数且函数值不同。</li>
<li><a href="http://www-sop.inria.fr/mimosa/fp/Bigloo/manual-chapter5.html#G17247">Bigloo 的 <code>make-directory</code></a> ，但可能引起错误。</li>
<li><a href="https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s146">Chez Scheme</a> 和 <a href="https://www.gnu.org/software/guile/manual/html_node/File-System.html">Guile</a> 的 <code>mkdir</code> ，但不支持可选的权限参数且函数值不同。</li>
<li><a href="https://docs.racket-lang.org/reference/Filesystem.html#%28def._%28%28quote._~23~25kernel%29._make-directory%29%29">[Racket] 的 <code>make-directory</code></a> ，但不支持非字符串参数和可选的权限参数，且通过函数值指定调用失败而非引起错误。</li>
</ul>
<p><code>create-directory* &lt;string&gt;</code></p>
<p>　　创建参数指定的名称的文件系统目录及其必要的父目录。</p>
<p>　　<code>create-directory</code> 和 <code>create-directory*</code> 只创建一级目录时的行为确保一致。</p>
<p><strong>注释</strong></p>
<p>　　类似：</p>
<ul>
<li><a href="http://www-sop.inria.fr/mimosa/fp/Bigloo/manual-chapter5.html#G17256">Bigloo 的 <code>make-directories</code></a> ，但可能引起错误。</li>
<li><a href="https://practical-scheme.net/gauche/man/gauche-refe/Filesystem-utilities.html#Directory-utilities">Gauche 的同名过程和 <code>make-directory*</code></a> ，但不支持可选的权限参数。</li>
<li><a href="https://docs.racket-lang.org/reference/Filesystem.html#%28def._%28%28lib._racket%2Ffile..rkt%29._make-directory%2A%29%29">[Racket] 的 <code>make-directory*</code></a> ，但不支持非字符串参数和可选的权限参数。</li>
</ul>
<p><code>create-parent-directory* &lt;string&gt;</code></p>
<p>　　创建参数指定的名称对应的父目录及其必要的父目录。</p>
<p><strong>注释</strong></p>
<p>　　类似 <a href="https://docs.racket-lang.org/reference/Filesystem.html#%28def._%28%28lib._racket%2Ffile..rkt%29._make-parent-directory%2A%29%29">[Racket] 的 <code>make-parent-directory*</code></a> ，但不支持非字符串参数和可选的权限参数。</p>
<p>　　当前实现中，若创建目录失败而引起错误，抛出 <code>std::system_error</code> 异常。</p>
<h2 id="系统库"><a class="header" href="#系统库">系统库</a></h2>
<p>　　提供和<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">实现环境</a>的交互功能。</p>
<p>　　默认加载为根环境下的 <code>std.system</code> 环境。</p>
<p><strong>对象：</strong></p>
<p><code>version-string</code></p>
<p>　　当前实现的版本字符串。</p>
<p>　　类型为 <code>&lt;string&gt;</code> 。</p>
<p><code>build-number</code></p>
<p>　　当前实现的构建版本号。</p>
<p>　　类型为 <code>&lt;integer&gt;</code> ，值为正整数。</p>
<p><code>revision-description</code></p>
<p>　　实现的版本说明。</p>
<p>　　类型为 <code>&lt;string&gt;</code> 。</p>
<p><strong>操作：</strong></p>
<p><code>() get-current-repl</code></p>
<p>　　取表示当前 REPL 环境的引用值。</p>
<p><code>() cmd-get-args</code></p>
<p>　　返回<a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>程序接受的命令行参数列表。</p>
<p>　　其中参数数组保存在实现内部访问的对象中。</p>
<p>　　传递给 REPL 的命令行参数通常是宿主程序中主函数的 <code>argv</code> 参数数组中处理后去除特定参数后的程序。</p>
<p>　　宿主程序复制 <code>argv</code> 到这个数组作为副本后，作为<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>的列表的来源。</p>
<p><code>env-get &lt;string&gt;</code></p>
<p>　　取宿主环境的环境变量字符串。</p>
<p>　　字符串参数指定环境变量的名称。</p>
<p><code>env-set &lt;string1&gt; &lt;string2&gt;</code></p>
<p>　　设置宿主环境的环境变量字符串。</p>
<p>　　两个字符串参数分别指定环境变量的名称和设置的值。</p>
<p>　　使用 <code>env-get</code> 和 <code>env-set</code> 及对应宿主环境的操作不保证线程安全。</p>
<p><code>env-empty? &lt;string&gt;</code></p>
<p>　　判断字符串指定名称的环境变量是否为空。</p>
<p><code>system &lt;string&gt;</code></p>
<p>　　以 <code>std::system</code> 兼容的方式调用外部命令。</p>
<p>　　结果是宿主环境命令返回的命令退出状态。</p>
<p><strong>注释</strong></p>
<p>　　类似 <a href="https://cisco.github.io/ChezScheme/csug9.5/foreign.html">Chez Scheme 的外部接口</a> ，但更接近 [ISO C] 和 [ISO C++] 的原始含义，当前不提供关于信号等依赖特定实现环境的保证。</p>
<p>　　使用 [ISO C] 和 <a href="https://eel.is/c++draft/basic.start.main#2">[ISO C++] 的宿主环境的命令退出状态是 <code>int</code> 值</a>。由 <a href="Features/NPL.zh-CN.html#npla-%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83">NPLA 实现环境</a>，这里的结果的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>是确定的。而 <a href="Features/NPL.zh-CN.html#npla1-%E6%95%B0%E5%80%BC">NPLA1 数值</a>使用 <a href="Features/NPL.zh-CN.html#npla-%E6%95%B0%E5%AD%A6%E5%8A%9F%E8%83%BD">NPLA 数学功能</a>确保其被<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">映射</a>为<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">确定的数值类型</a>。</p>
<p><code>system-get &lt;string&gt;</code></p>
<p>　　调用命令，返回命令调用结果。</p>
<p><strong>注释</strong> 在典型的 C++ 宿主实现中，命令的调用结果是来自标准输出的数据。</p>
<p>　　返回一个两个元素的列表，分别是管道输出字符串和宿主环境命令返回的命令退出状态。</p>
<p>　　调用命令和 <code>system</code> 的方式类似。</p>
<p><code>make-temporary-filename &lt;string1&gt; &lt;string2&gt;</code></p>
<p>　　取适合命名新创建的临时文件的随机文件名。</p>
<p>　　参数分别指定前缀和后缀。参数可能为空。随机文件名以生成的有限长度的随机字符串添加前缀和后缀组成。</p>
<p>　　生成的字符串只包含 C++ 基本字符串的可打印字符，且不使用大写字母，以兼容大小写不敏感的文件系统。</p>
<p>　　随机的文件名被打开以检查是否可访问。若失败则重试，若最终失败，则引起错误。</p>
<p><strong>注释</strong></p>
<p>　　功能类似 <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdio.h.html">POSIX <code>::tmpnam</code> 和 <code>::mkstemp</code></a> ，以及 <a href="https://www.gnu.org/software/guile/manual/html_node/File-System.html">Guile 对应的过程 <code>tmpnam</code> 和 <code>mkstemp</code></a> ，有以下不同：</p>
<ul>
<li>和 <code>tmpname</code> 类似，结果是文件名，而不是打开的文件或端口。</li>
<li>和 <code>mkstemp</code> 类似，使用模板字符串作为文件名，但模板不在参数中指定。</li>
</ul>
<p>　　	保证生成的文件名在不同<a href="Features/NPL.zh-CN.html#%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0">宿主实现</a>（文件系统）中的兼容性。</p>
<p>　　当前实现中的随机字符串长度为 6 。当前实现中重试的上限是 16 次（宿主平台）或 1 次（非宿主平台）。若最终失败，抛出 <code>std::system_error</code> 异常。</p>
<h2 id="模块管理"><a class="header" href="#模块管理">模块管理</a></h2>
<p>　　提供使用模块和其中符号的相关功能。</p>
<p>　　默认加载为根环境下的 <code>std.modules</code> 环境。</p>
<p><strong>模块约定：</strong></p>
<p>　　<em>需求字符串(requirement string)</em> 是具有 <code>&lt;string&gt;</code> 类型的非空字符串。</p>
<p>　　若操作的形式参数是需求字符串，实际参数是空字符串，则<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　本模块共享<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">可变管理状态</a>，以支持操作访问确定的模块字符串集合。</p>
<p>　　本模块隐含一个字符串的序列，其中的每个元素都是可<a href="Features/NPL.zh-CN.html#npla1-%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E6%89%A9%E5%B1%95%E7%8E%AF%E5%A2%83">指定搜索起点的模块的加载路径</a>，称为<em>需求字符串模板(requirement string template)</em> 。</p>
<p>　　除非派生实现另行指定，需求字符串模板序列在<a href="Features/NPL.zh-CN.html#npla1-%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96">实现环境初始化</a>后不可变。</p>
<p>　　初始化决定的需求字符串模板序列的内容由实现定义。</p>
<p>　　程序可通过本模块<em>注册(register)</em> 需求字符串。本模块维护已被注册的需求字符串的集合。若一个字符串的值和集合中的某个值相等，则这个字符串作为需求字符串已被注册。</p>
<p>　　注册新的需求字符串时，同时创建和保存：</p>
<ul>
<li>待加载结果的对象，其初始值为 <code>()</code> 。</li>
<li>可供加载使用的<a href="Features/NPL.zh-CN.html#%E6%96%B0%E7%8E%AF%E5%A2%83">新</a><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">标准环境</a>。</li>
</ul>
<p>　　本模块确保对不同的被维护的需求字符串，对应的上述资源不同一。</p>
<p><strong>原理</strong></p>
<p>　　参数的值和结果不需要保证一一对应。通过指定需求字符串模板序列，可以指定在文件系统不同位置的相同文件名模式的多个文件作为需求字符串对应的候选模块的源，按需选取其中之一指定其确切位置。</p>
<p>　　为避免名称污染等问题，不提供显式指定命名环境的模块创建操作，如 <a href="http://www.lua.org/manual/5.1/manual.html#pdf-module">Lua 5.1 的 <code>module</code> 函数</a>等<a href="http://lua-users.org/wiki/LuaModuleFunctionCritiqued">存在一些问题</a>。</p>
<p>　　不提供访问创建的环境的操作，以避免污染外部的访问。若需公开其中的变量绑定，可使用返回或模块参数。</p>
<p>　　提供较少的操作以简化规则，避免<a href="https://xkcd.com/1987/">多个运行时可能造成的混乱</a>。关于搜索规则，另见以下 <code>find-required-filename</code> 的说明。</p>
<p><strong>注释</strong></p>
<p>　　对内部共享状态的<a href="Features/NPL.zh-CN.html#npla-%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE">并发访问</a>并不具有特别的同步保证和要求。并发访问<a href="Features/NPL.zh-CN.html#npla1-%E7%A8%8B%E5%BA%8F%E5%A4%96%E9%83%A8%E7%8E%AF%E5%A2%83">可引起宿主语言的未定义行为</a>。</p>
<p>　　当前实现中，若环境变量 <code>NPLA1_PATH</code> 的值非空，则需求字符串模板序列是这个值以单字符子串 <code>;</code> 分隔后的结果串接组成的序列；否则，默认值是字符串 <code>./?</code> 和 <code>./?.txt</code> 构成的序列。</p>
<p>　　关于使用需求字符串模板序列搜索模块，参见以下 <code>find-required-filename</code> 的说明。</p>
<p>　　当前派生实现依赖可用的 <a href="Features/NPL.zh-CN.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BA%93"><code>std.strings</code></a>、<a href="Features/NPL.zh-CN.html#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%BA%93"><code>std.io</code></a>和 <a href="Features/NPL.zh-CN.html#%E7%B3%BB%E7%BB%9F%E5%BA%93"><code>std.system</code></a>环境。</p>
<p>　　通过不经过本模块的操作（如<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>）、重复字符串模板的重复项、符号链接和字符串大小写不敏感的文件名等可能绕过本模块的注册机制而重复加载同一个外部文件。本模块的操作不对这些情形进行任何检查。</p>
<p><strong>操作：</strong></p>
<p><code>registered-requirement? &lt;string&gt;</code></p>
<p>　　判断参数是否是已在本模块注册的需求字符串。</p>
<p><code>register-requirement! &lt;string&gt;</code></p>
<p>　　在本模块注册参数为需求字符串。</p>
<p>　　若参数指定的需求字符串已被注册，则引起错误；否则，创建并保存新标准环境。</p>
<p>　　结果是保存的环境的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">弱引用</a>。</p>
<p><code>unregister-requirement! &lt;string&gt;</code></p>
<p>　　在本模块解除注册参数为需求字符串。</p>
<p>　　若参数指定的需求字符串没有被注册，则引起错误；否则，移除与参数的值相等的需求字符串以及保存的关联的资源。</p>
<p><code>find-required-filename &lt;string&gt;</code></p>
<p>　　查找需求字符串对应的文件名。</p>
<p>　　在需求字符串模板序列中顺序地检查每一个元素：</p>
<ul>
<li>使用参数的值替换元素中的每个单字符子串 <code>?</code> 。</li>
<li>判断经替换得到的字符串是否构成指定一个可读文件的文件名。</li>
</ul>
<p>　　若不存在这样的文件名，则引起错误；否则，结果是第一个符合条件的文件名。</p>
<p>　　替换字符串时，每一个子串被同时一次替换；不对替换结果进一步递归地替换。</p>
<p><strong>原理</strong></p>
<p>　　类似 klisp 而和 Lua（ <a href="https://www.lua.org/source/5.3/loadlib.c.html"><code>require</code> 的实现</a>；没有<a href="https://www.lua.org/pil/8.1.html">在此</a>明确）及 <a href="https://www.haskell.org/hugs/pages/users_guide/module-commands.html">Haskell</a> 等不同，不替换名称中的 <code>.</code> 为路径分隔符，以简化对实现环境的假设。</p>
<p><strong>注释</strong></p>
<p>　　若需求字符串模板的元素中没有通配符 <code>?</code> ，则不需要替换，需求字符串模板直接是指定确切位置的结果文件名。</p>
<p><code>require &lt;string&gt; &lt;environment&gt;?</code></p>
<p>　　按需在新标准环境加载需求字符串对应的模块。</p>
<p>　　若第二参数非空，则在加载前首先绑定创建的环境中的 <code>module-parameters</code> 变量为第二参数的值。</p>
<p>　　按需加载包含以下步骤：</p>
<ul>
<li>若参数指定的需求字符串没有注册，则：
<ul>
<li>以同调用 <code>register-requirement?</code> 等价的方式注册需求字符串，确保注册时的环境被创建。</li>
<li>以同调用 <code>find-required-filename</code> 等价的方式确定待加载的源的文件名。</li>
<li>以同模块 <a href="Features/NPL.zh-CN.html#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%BA%93"><code>std.io</code> 中的 <code>load</code></a>相同的方式在注册时创建的环境加载上述文件名指定的源。</li>
<li>保存加载的结果。</li>
</ul>
</li>
<li>否则，不进行加载。</li>
<li>结果是已保存的加载的结果。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　先注册需求字符串允许重入调用 <code>require</code> ，即加载模块时求值的源代码包含和先前的字符串参数相同的 <code>require</code> 调用，而不至于无限递归。</p>
<p><strong>注释</strong></p>
<p>　　类似 klisp 的 ports 模块中的同名应用子，但有以下不同：</p>
<ul>
<li>同时保存创建的环境，以避免因程序没有保存环境引用而<a href="Features/NPL.zh-CN.html#%E6%97%A0%E6%95%88%E5%8C%96">无效化</a>，使访问变量绑定的程序具有未定义行为。</li>
<li>结果是加载结果（同模块 <code>std.io</code> 中的 <code>load</code> ）而不是 <code>#inert</code> 。</li>
<li>支持同 <a href="Features/NPL.zh-CN.html#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%BA%93"><code>std.io</code> 中的 <code>get-module</code></a> 的可选参数。</li>
</ul>
<h1 id="附录"><a class="header" href="#附录">附录</a></h1>
<h2 id="进一步阅读-1"><a class="header" href="#进一步阅读-1">进一步阅读</a></h2>
<p>　　关于 NPL 语言<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">派生实现</a>的具体实现，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h2 id="kernel-实现"><a class="header" href="#kernel-实现">Kernel 实现</a></h2>
<p>　　NPL 文法是 S-表达式语法和 Kernel 兼容语义的简化，某些 NPLA1 程序可以原封不动地作为 Kernel 程序运行。因为参考文献可用性以及相似性几乎独一无二，建议深入使用前参照 Kernel 相关的文档并实际使用，以和 NPL 进行比较（当前 NPL 开发文档也引用包括 [R<sup>n</sup>RK] 在内的一些规格说明）。现有较完整可用的一个 Kernel 实现是 <a href="http://klisp.org/">Klisp</a> 。</p>
<h2 id="计划支持特性"><a class="header" href="#计划支持特性">计划支持特性</a></h2>
<p>　　在 Kernel 中已存在但当前 NPLA1 未支持，而计划在未来添加的特性：</p>
<ul>
<li>一等续延(first-class continuation)
<ul>
<li><a href="http://okmij.org/ftp/continuations/against-callcc.html">基于一些显著的理论和实现可用性的理由</a>，需要考察<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">有界续延</a>（如 <code>shift</code>/<code>reset</code> ）而不是传统的 <code>call/cc</code> 的支持。</li>
<li>和 Klisp 的异步实现方式类似但不同，NPLA1 核心已使用一种同 <a href="http://www.ccs.neu.edu/home/dvanhorn/pubs/vanhorn-might-icfp10.pdf">CESK-style 的抽象机</a>的异步风格独立重新实现（<a href="http://www.brics.dk/RS/05/16/BRICS-RS-05-16.pdf">原理参考</a>），并兼容混合原有实现。并且状态支持已提供基本操作，但仍待更多测试。</li>
</ul>
</li>
<li><a href="http://klisp.org/docs/Promises.html#Promises">Promises</a>
<ul>
<li>虽然 NPLA1 之前有部分原生实现，但计划改用基于封装类型派生。</li>
</ul>
</li>
<li><a href="http://klisp.org/docs/Keyed-Variables.html#Keyed-Variables">Keyed Variables</a>
<ul>
<li>有效的 keyed dynamic varabile 实现可能依赖一等续延数据结构。</li>
<li>有效的 keyed static varabile 实现需要调整环境数据结构。</li>
</ul>
</li>
<li><a href="http://klisp.org/docs/Ports.html#Ports">Ports</a>
<ul>
<li>需要调查内存映射文件和其它系统支持。</li>
</ul>
</li>
<li><a href="http://klisp.org/docs/Libraries.html#Libraries">Libraries</a>
<ul>
<li>可能需要提供多种不同的接口。</li>
</ul>
</li>
</ul>
<p>　　已提供但考虑可能优化实现的特性：</p>
<ul>
<li><a href="http://klisp.org/docs/Encapsulations.html#Encapsulations">封装类型</a>
<ul>
<li>需要调查互操作相关的特性和持久化支持。</li>
</ul>
</li>
</ul>
<p>　　计划考虑提供其它设计替代选项的 Klisp 特性：</p>
<ul>
<li><a href="http://klisp.org/docs/Characters.html#Characters">Characters</a>
<ul>
<li>满足互操作要求的前提下，使用设计更合理的类型替代。</li>
</ul>
</li>
<li><a href="http://klisp.org/docs/Vectors.html#Vectors">Vectors</a>
<ul>
<li>使用更完善的用户自定义派生类型替代。</li>
</ul>
</li>
</ul>
<p>　　其它 NPL 计划实现特性：</p>
<ul>
<li>模块化框架</li>
<li>支持类型系统的子语言
<ul>
<li>类似 <a href="https://docs.racket-lang.org/ts-reference/index.html">Typed Racket</a> 。</li>
</ul>
</li>
<li>测试框架</li>
<li>基于 <code>$let-safe</code> 的静态环境操作替换优化</li>
<li>用于编译的中间代码格式和二进制代码生成框架
<ul>
<li>类似 <a href="https://www.scheme.com/">Chez Scheme</a> 对 <a href="http://nanopass.org/">Nanopass</a> 的使用。</li>
</ul>
</li>
<li><a href="https://en.wikipedia.org/wiki/Metacompilation">元编译(metacompilation)(en-US)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="概述-2"><a class="header" href="#概述-2">概述</a></h1>
<p>　　Sysroot 是具有特定逻辑布局根目录兼容的目录，一般在文件系统中实现。</p>
<p>　　Sysroot 主要用于本机程序的开发环境构建和部署，以后也可能用于<a href="Terminology.zh-CN.html#%E4%BE%9D%E8%B5%96%E5%92%8C%E5%A4%96%E5%BB%B6">交叉构建</a>。</p>
<p>　　在利用 Sysroot 开发之前有必要了解开发注意事项：</p>
<ul>
<li><a href="Build.zh-CN.html">构建</a></li>
<li><a href="Prerequisitions.zh-CN.html">先决条件</a></li>
</ul>
<p>　　Sysroot 使用的文件系统路径满足<a href="Run.zh-CN.html">运行</a>环境对外部文件的路径的约定。</p>
<p>　　当前 Sysroot 仅支持 MinGW 和 Linux 环境。</p>
<p>　　关于本文档讨论以外的脚本的其它行为，参见<a href="Tools/Scripts.zh-CN.html">脚本</a>的有关说明。</p>
<h1 id="布局"><a class="header" href="#布局">布局</a></h1>
<p>　　在满足前述要求的前提下，Sysroot 部署实例使用<a href="Run.zh-CN.html#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80">局部 FHS 目录布局</a>，具体子目录布局如下：</p>
<ul>
<li><code>.shbuild</code> ：使用 <a href="Tools/SHBuild.zh-CN.html">SHBuild</a> 构建时的临时目录（可以在部署后手动删除）。</li>
<li><a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_getsystemprefix">系统前缀字符串</a>指定的作为<a href="Tools/Scripts.zh-CN.html#toolsinstall-sysrootsh">安装路径前缀</a>的最后一个路径组件的目录文件名（如 <code>usr</code> ）：被部署的用户空间目录，其中的内容使用 <a href="http://www.tldp.org/LDP/Linux-Filesystem-Hierarchy/html/usr.html">Linux</a> 等现代 UNIX 变体类似的约定：
<ul>
<li><code>bin</code> ：二进制文件。</li>
<li><code>include</code> ：头文件。</li>
<li><code>lib</code> ：库文件。</li>
<li><code>share</code> ：共享的数据文件。
<ul>
<li><code>share/NPLA1</code> ：NPLA1 脚本部署位置。</li>
</ul>
</li>
<li><code>var</code> ：程序运行时可修改的数据。</li>
</ul>
</li>
</ul>
<p>　　其中，除 <code>var</code> 外，这些目录中的内容在安装或维护部署情形外通常应保持只读。</p>
<p>　　对 MSYS2 支持的宿主和目标平台，系统前缀字符串指定的路径和 MSYS2 构建系统的 <code>/etc/msystem</code> 脚本指定的 <code>MSYSTEM_PREFIX</code> 的值一致，直接构成<a href="https://www.msys2.org/docs/environments/">环境路径前缀</a>。</p>
<ul>
<li>对 MinGW32 和 MinGW64 ，这也对应 <a href="https://www.msys2.org/wiki/MSYS2-introduction/#subsystems">MSYS2 支持的子系统路径</a>。</li>
<li>MSYS2 可能支持其它平台的组合，可能直接可用，但并不保证每个配置都提供支持和被测试。详见<a href="Prerequisitions.zh-CN.html">先决条件</a>中关于平台的描述。</li>
</ul>
<p>　　上述 <code>bin</code> 目录可以加入<a href="Run.zh-CN.html">环境变量 <code>PATH</code></a> 中以便其中的程序被命令行执行。当前若使用 <a href="YDE.zh-CN.html">YDE</a> 构建脚本，这是必要的。</p>
<p>　　依赖 Sysroot 的程序可预期以上布局符合约定，且功能允许时可访问这些子目录或其它文件，而不被要求能在不符合预期的环境下正常运行。这些程序可能根据上述子目录中的内容判断需要的不同操作。安装或者维护 Sysroot 布局的程序提供附加的保证，不依赖全部或者部分路径符合预期，而在必要时可创建文件使布局满足这些预期。具体的操作可在不同程序的功能描述中明确。</p>
<p>　　没有在此约定的 Sysroot 中的子目录和其它文件路径为未来的版本保留：这些路径不被当前版本使用，但可能被之后的版本使用。依赖 Sysroot 的程序和用户应注意避免占用保留路径引起变更版本时引起的兼容问题。</p>
<p><strong>注意</strong> Sysroot 实例的布局<em>不是</em><a href="Features.zh-CN.html">版本库文件布局</a>。关于部署文件时有关被部署的文件的要求，参见版本库文件布局中的相关约定。</p>
<p><strong>原理</strong></p>
<p>　　文件系统子目录的约定和 <a href="Run.zh-CN.html#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%B7%AF%E5%BE%84">FHS</a> 类似。</p>
<p>　　对 NPLA1 文件，因为脚本并非二进制文件而对体系结构中立，使用 <code>share</code> 子目录。脚本不被视为可能依赖具体体系结构的二进制库文件（位于 <code>lib</code> 为前缀的子目录）。若未来需要部署二进制文件或作为库的二进制可执行文件，可部署到 <code>lib</code> 和 <code>libexec</code> 等子目录。这也类似 <a href="https://www.gnu.org/software/guile/manual/html_node/Installing-Site-Packages.html">Guile 等语言实现使用的惯例</a>；但当前没有指定其中的下级子目录。</p>
<p>　　在程序中实现局部 FHS 目录布局可能需要特定宿主环境的支持，以定位可执行文件映像路径，例如：</p>
<ul>
<li>Win32（实际依赖 Windows NT 实现）<a href="https://learn.microsoft.com/windows/win32/dlls/dynamic-link-library-search-order">加载动态库的搜索默认行为</a>以及运行时的 <a href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamew"><code>GetModuleFileNameW</code></a> 调用。</li>
<li>ELF 映像的依赖路径中的<a href="https://www.sco.com/developers/gabi/latest/ch5.dynamic.html#substitution">替换序列 <code>$ORIGIN</code></a> 。</li>
<li>Linux 运行时对<a href="https://man7.org/linux/man-pages/man5/proc.5.html">文件系统路径 <code>/proc/self/exe</code></a> 的访问（在某些 <a href="https://man7.org/linux/man-pages/man2/chroot.2.html">chroot</a> 环境中可能不可用）。</li>
<li>Mac OS X 运行时的 <a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dyld.3.html"><code>_NSGetExecutablePath</code></a> 调用。</li>
<li>FreeBSD 运行时的 <a href="https://man.freebsd.org/cgi/man.cgi?sysctl(3)"><code>sysctl</code></a>（构造参数向量 <code>CTL_KERN</code> 、<code>KERN_PROC</code> 、<code>KERN_PROC_PATHNAME</code> 和 <code>-1</code> ）调用。</li>
<li>FreeBSD（仅当启用 <a href="https://man.freebsd.org/cgi/man.cgi?query=procfs">procfs</a> 时）和 <a href="https://leaf.dragonflybsd.org/cgi/web-man?command=procfs">Dragonfly BSD</a> 运行时对文件系统路径 <code>/proc/curproc/file</code> 的访问。</li>
<li>NetBSD 运行时对<a href="https://man.netbsd.org/mount_procfs.8">文件系统路径 <code>/proc/curproc/exe</code> 或 <code>/proc/self/exe</code></a> 的访问。</li>
<li>Solaris（自从 10 ）运行时对<a href="https://docs.oracle.com/cd/E88353_01/html/E37852/proc-5.html">文件系统路径 <code>/proc/self/object/a.out</code> 或 <code>/proc/self/path/a.out</code></a> 的访问。</li>
<li><a href="https://docs.oracle.com/cd/E19253-01/816-5168/6mbb3hrb1/index.html">SunOS</a> 和 <a href="https://docs.oracle.com/cd/E86824_01/html/E54766/getexecname-3c.html">Solaris</a> 运行时（对动态加载的具有 <code>AT_SUN_EXECNAME</code> 的映像）的 <code>getexecname</code> 调用，或 Solaris（自从 11 ）对<a href="https://docs.oracle.com/cd/E88353_01/html/E37852/proc-5.html">文件系统路径 <code>/proc/self/execname</code></a> 的访问。</li>
</ul>
<p>　　若不存在这样的支持，则需在运行时配置中指定。</p>
<h1 id="安装脚本"><a class="header" href="#安装脚本">安装脚本</a></h1>
<p>　　YSLib 项目提供生成可打包的 Sysroot 的安装脚本，位于 <code>Tools/Scripts/install-sysroot.sh</code> 。输出的 Sysroot 的默认位置为版本库根目录下的 <code>sysroot</code> 目录。安装 Sysroot 时构建和部署多个项目，详见以下各节。</p>
<h2 id="基本安装"><a class="header" href="#基本安装">基本安装</a></h2>
<p>　　使用 <a href="Tools/SHBuild.zh-CN.html">SHBuild</a> 构建和部署运行环境，包括库和工具。</p>
<p><strong>建议阅读以下关于选项以及<a href="Tools/Scripts.zh-CN.html">脚本</a>说明后再运行命令。</strong></p>
<p>　　可进入 <code>bash</code> 运行以下 GNU bash 脚本：</p>
<pre><code class="language-shell">Tools/install-sysroot.sh
</code></pre>
<p>　　直接在默认输出位置构建和部署基础环境。</p>
<p><strong>注意</strong> 当前构建脚本默认使用 <code>uname</code> 判断构建系统的体系结构。对 MSYS2 等环境，结果为基本系统的体系结构而不一定和作为构建目标的宿主系统相同。如使用 64 位基本系统构建 32 位目标，需确保环境变量 <code>MSYSTEM</code> 设置为 <code>MINGW32</code>（在启动 MSYS2 提供的 shell 入口时应正确设置，但直接调用 <code>bash</code> 并不保证），或使用以下命令代替：</p>
<pre><code class="language-bash">SHBuild_Host_Arch=i686 Tools/install-sysroot.sh
</code></pre>
<p>　　此处<a href="Prerequisitions.zh-CN.html">自动环境检测</a>的机制同 shell 脚本 <code>Tools/Scripts/SHBuild-common.sh</code> 中的函数 <code>SHBuild_PrepareBuild</code> ，详见<a href="Tools/Scripts.zh-CN.html">脚本</a>的说明。</p>
<h2 id="自动下载安装外部依赖项"><a class="header" href="#自动下载安装外部依赖项">自动下载安装外部依赖项</a></h2>
<p>　　通过<a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-yslib-buildtxt">设置环境变量 <code>YSLib_DistDir</code> 为非空的路径</a> ，可在构建前自动按需获取源代码外的<a href="ProjectDependencies.zh-CN#%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96%E9%A1%B9">二进制库外部依赖项</a>。</p>
<p><strong>已知问题</strong> 启用 <a href="Prerequisitions.zh-CN.html#%E9%93%BE%E6%8E%A5%E6%97%B6%E4%BC%98%E5%8C%96lto">LTO</a> 的 release 配置的二进制文件可能依赖具体的工具链；具体参见 <a href="Development.zh-CN.html#%E5%87%86%E5%A4%87">YSLib 项目文档</a>的 <code>doc/Dependencies.txt</code> 。若使用不同的工具链，二进制文件不兼容，需要回退旧版不使用 LTO 构建的二进制库文件，而无法全自动支持 release 配置的构建。例如，对 Linux 平台，V0.9 后的<a href="Archives.zh-CN.html#external">归档</a>的 <code>External-0.9.7z</code> 都启用了 LTO 而不能保证和用户使用的工具链匹配，此时可能需要手动构建和部署其中的 <code>libFreeImage.a</code> 文件到<a href="ProjectDependencies.zh-CN.html#%E5%A4%96%E9%83%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%BA%93">源代码的 <code>YFramework/Linux/lib</code> 目录</a>下。</p>
<p><strong>注意</strong> 用 debug 配置的二进制文件 <code>libFreeImaged.a</code> 覆盖 <code>libFreeImage.a</code> 可能成功，但这种方式不被支持。</p>
<h2 id="构建和部署"><a class="header" href="#构建和部署">构建和部署</a></h2>
<p>　　构建过程包括 <code>SHBuild</code> 可用的<a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">多阶段构建</a>。</p>
<p>　　构建时在 Sysroot 输出目录种保存中间输出。当前不清理这些中间输出。</p>
<p>　　通过脚本选项，在 <a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 2 SHBuild</a> 需要的库时，也可生成其它的 YSLib 库（静态库和调试版本的库）。</p>
<p>　　YSLib 库和依赖的外部的第三方库的二进制文件和对应的头文件在构建后被部署到 Sysroot ，并在之后用于构建 stage 2 SHBuild 。</p>
<p>　　完成构建 stage 2 SHBuild 后，脚本部署 stage 2 SHBuild 和脚本（参见以下节）到 Sysroot 。</p>
<h3 id="脚本部署"><a class="header" href="#脚本部署">脚本部署</a></h3>
<p>　　在 stage 2 SHBuild 构建后，部署 SHBuild 同时安装（复制）版本库中的以下位置的 脚本文件（无视路径前缀）到 Sysroot 的对应安装路径：</p>
<ul>
<li>NPLA1 脚本安装到 <code>share/NPLA1</code> ：
<ul>
<li><code>Tools/Script/SHBuild-BuildApp.txt</code></li>
<li><code>Tools/Script/SHBuild-YSLib-common.txt</code></li>
</ul>
</li>
<li>Shell 脚本安装到 <code>bin</code> ：
<ul>
<li><code>Tools/Script/SHBuild-common.sh</code></li>
<li><code>Tools/Script/SHBuild-common-options.sh</code></li>
<li><code>Tools/Script/SHBuild-common-toolchain.sh</code></li>
<li><code>Tools/Script/SHBuild-BuildApp.sh</code></li>
<li><code>Tools/Script/SHBuild-BuildPkg.sh</code></li>
</ul>
</li>
</ul>
<h3 id="可选工具"><a class="header" href="#可选工具">可选工具</a></h3>
<p>　　通过脚本选项，在部署 stage 2 SHBuild 后，也可安装 <code>Tools</code> 下的其它工具：</p>
<ul>
<li><a href="Tools/RevisionPatcher.zh-CN.html">RevisionPatcher</a></li>
<li><a href="Tools/SXML2XML.zh-CN.html">SXML2XML</a></li>
<li><a href="Tools/ProjectGenerator.zh-CN.html">ProjectGenerator</a></li>
</ul>
<h2 id="构建中间文件"><a class="header" href="#构建中间文件">构建中间文件</a></h2>
<p>　　当前工具不对构建的中间文件显式管理。若需清理，可以手动删除对应的文件或所在的生成目录。一般生成的文件和源代码的目录结构对应。</p>
<p>　　若需要预编译头文件在后续重复构建时的性能提升，或者意图重新生成这些文件，可以手动清理这些文件。预编译头文件一般在对应项目生成其它的文件的顶层目录相同；可手动搜索构建目录中所有 <code>.gch</code> 文件并删除后再运行构建脚本。默认生成预编译头文件前硬链接被预编译的头文件并在同一个目录中生成，包括以下位置：</p>
<ul>
<li>存储库中的 <code>Tools/SHBuild</code>（即源代码目录），用于 <a href="Tools/SHBuild.zh-CN.html">stage 1 SHBuild</a> 构建。</li>
<li>安装 stage 1 SHBuild 后默认在<a href="Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">构建中间输出目录 <code>$SHBuild_BuildDir</code></a> 下的 <code>.shbuild</code> 等作为 SHbuild 输出目录的子目录。</li>
</ul>
<h2 id="构建时的诊断"><a class="header" href="#构建时的诊断">构建时的诊断</a></h2>
<p>　　一些构建时的诊断可被安全忽略：</p>
<ul>
<li><a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-buildsh">预编译头文件文件不匹配引起的编译器警告</a>。</li>
<li>在输出标记为 <code>(ignored)</code> 被忽略的链接器错误。
<ul>
<li>这些错误典型地出现在 <a href="https://bugs.launchpad.net/gcc-arm-embedded/+bug/1853451">MinGW 平台启用 LTO 时</a>。
<ul>
<li>这应不会影响生成的二进制文件。</li>
<li>默认以 release 配置构建时，启用 LTO 而可能引起错误。</li>
<li>设置启用 LTO 编译器和链接器选项时，<a href="Tools/SHBuild.zh-CN.html#%E5%BC%95%E5%AF%BC">引导 stage 1 SHBuild</a> 最后的链接器可能引起错误。</li>
<li>可<a href="https://github.com/official-stockfish/Stockfish/pull/2978">在链接器选项使用 <code>-save-temps</code></a>变通。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　若不需要使用预编译头文件或仅需要避免警告，可参考<a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-buildsh">脚本的说明设置变量跳过预编译头文件或添加忽略警告的选项</a>。</p>
<h1 id="sysroot-开发指令"><a class="header" href="#sysroot-开发指令">Sysroot 开发指令</a></h1>
<p>　　使用 Sysroot 开发，首先需安装 Sysroot 环境，参见以上<a href="Sysroot.zh-CN.html#%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC">安装脚本的说明</a>。</p>
<h2 id="应用程序构建脚本"><a class="header" href="#应用程序构建脚本">应用程序构建脚本</a></h2>
<p>　　YSLib 应用程序可使用 SHBuild 构建。为简化构建流程，使用应用程序构建脚本包装对 SHBuild 的调用。</p>
<p>　　应用程序构建脚本不限制实现使用的语言，但在版本库中提供的脚本应符合<a href="Tools/Scripts.zh-CN.html">公共的约定</a>；此外，具体脚本可能需要指定适当的 <code>PATH</code> 以确保外部的工具可被调用。</p>
<p>　　典型地，应用程序构建脚本是 shell 脚本，可依赖 Sysroot 环境已构建的 Sysroot 环境，并调用 NPLA1 脚本。</p>
<p>　　<a href="ProjectDependencies.zh-CN.html">YSTest</a> 支持使用脚本 <code>/YSTest/SHBuild-YSTest.sh</code> 构建，可作为例子参考。和其它在安装脚本部署的 stage 2 应用不同，当前默认情况下使用版本库中的 <code>build</code> 目录下的平台目录存放生成的文件（中间文件和生成的可执行程序示例）。</p>
<h2 id="部署"><a class="header" href="#部署">部署</a></h2>
<p>　　除安装脚本外，当前不提供直接部署程序。</p>
<p>　　参照<a href="Run.zh-CN.html">运行</a>确定二进制依赖项位置和调整运行时的配置。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述-3"><a class="header" href="#概述-3">概述</a></h1>
<p>　　YDE 是 YSLib Desktop Environment 的简称，预期作为一个基于 YFramework 的桌面环境。</p>
<p>　　当前是一个 YSLib 的顶级子项目，构建需要 <a href="Sysroot.zh-CN.html">Sysroot</a> 支持。</p>
<p>　　YDE 包含一系列的<em>包(package)</em> 在单独的目录中作为次级子项目。</p>
<h1 id="构建-2"><a class="header" href="#构建-2">构建</a></h1>
<p>　　当前只提供 <code>build-all.sh</code> 使用 <a href="Tools/Scripts.zh-CN.html">SHBuild-BuildApp.txt</a> 构建所有包。</p>
<h2 id="准备-5"><a class="header" href="#准备-5">准备</a></h2>
<ul>
<li>参见<a href="Development.zh-CN.html">开发说明</a></li>
<li>参见 <a href="Sysroot.zh-CN.html">Sysroot</a> 和<a href="GettingStarted.zh-CN.html">入门</a> 的说明配置环境，确保 Sysroot 部署的 <code>usr/bin</code> 目录在 <code>PATH</code> 中</li>
<li>运行 <code>build-all.sh</code> ，可以提供参数</li>
</ul>
<p>　　构建的结果参见 <code>SHBuild-BuildApp.txt</code> 的文档。</p>
<h1 id="包列表"><a class="header" href="#包列表">包列表</a></h1>
<ul>
<li>ImageBrowser 图像浏览工具</li>
<li>Clock 模拟时钟</li>
</ul>
<h1 id="运行-1"><a class="header" href="#运行-1">运行</a></h1>
<p>　　参见<a href="Run.zh-CN.html">运行</a>了解所有基于 YFramework 的程序的说明。</p>
<p><strong>使用配置 <code>yconf.txt</code> ，详见<a href="Run.zh-CN.html">关于运行的说明</a>。</strong></p>
<h2 id="imagebrowser"><a class="header" href="#imagebrowser">ImageBrowser</a></h2>
<p>　　运行程序会打开命令行第一个参数作为路径的文件。支持从资源管理器拖拽到程序。</p>
<p>　　支持 YFramework 支持的图像格式：</p>
<ul>
<li>BMP</li>
<li>GIF</li>
<li>PNG</li>
<li>非渐进 JPEG</li>
</ul>
<p>　　支持滚轮缩放。</p>
<p>　　单击右上角退出按钮退出程序。</p>
<p>　　右键单击界面其它部分弹出上下文菜单。有以下菜单项：</p>
<ul>
<li>退出：关闭窗口，退出程序。</li>
<li>查看原始大小：当显示的图像不是原始大小时，缩放图像到原始大小。</li>
<li>翻转：旋转 180° 。</li>
<li>顺时针旋转：顺时针旋转 90° 。</li>
<li>逆时针旋转：逆时针旋转 90° 。</li>
<li>复制：复制当前显示的（可能经过缩放的）图像内容到剪贴板。</li>
</ul>
<p>　　旋转时保持图像中心位置不变。</p>
<p>　　中键单击界面其它部分查看原始大小。</p>
<p>　　支持键盘快捷键：</p>
<ul>
<li><code>Ctrl+C</code> 复制</li>
</ul>
<h2 id="clock"><a class="header" href="#clock">Clock</a></h2>
<p>　　右键单击界面退出程序。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="概要-2"><a class="header" href="#概要-2">概要</a></h1>
<p>　　本文档记录<em>发布工程(release engineering)</em> 相关的规则、历史记录和相关计划。</p>
<p>　　发布策略控制版本更新。</p>
<p>　　关于<em>版本(revison)</em> 的详细规则参见 YSLib 项目文档 <code>doc/ProjectRules.txt</code> 。</p>
<h1 id="分支"><a class="header" href="#分支">分支</a></h1>
<p>　　一个项目可有多个<em>分支(branch)</em> ，包括至少一个保持工作进行的活动(active) 分支。</p>
<p>　　发布时使用活动分支，以项目版本库的分支为准。</p>
<p>　　当前只有<em>主分支(master branch)</em> 。</p>
<h1 id="标识"><a class="header" href="#标识">标识</a></h1>
<p>　　具体的<em>版本(version)</em> 和<em>修订版本(revision)</em> 可具有<em>标识(identification)</em> 以便明确地被引用和<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">指称</a>其中的状态。</p>
<p>　　<em>阶段(phase)</em> 是连续的版本的一种标识，描述一个分支在一个时期内版本的发布状态。</p>
<p>　　当前位于 Alpha 非正式发布阶段。</p>
<h2 id="迭代阶段"><a class="header" href="#迭代阶段">迭代阶段</a></h2>
<p>　　<em>迭代阶段(iteration phase)</em> 是工程意义上的版本标识，适用于所有在开发、测试和维护生命周期中的分支，包括仅包含开发和测试版本的场合。</p>
<p>　　PreAlpha 阶段不对 <a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 的稳定性进行任何保证。</p>
<p>　　Alpha 阶段尽量保证公开 API 的非向后兼容的修改最小化，但仍然不保证兼容。</p>
<p>　　Beta 阶段保证主要项目的 API 向后兼容性。非兼容的改动不再在当前迭代周期内引入，否则视为缺陷。</p>
<p>　　Beta 阶段开始提供面向非开发者的部署方案。</p>
<p>　　允许在每个迭代周期中按以上顺序补充新的阶段。</p>
<p>　　关于项目内的提交版本(revision) ，详见项目文档 <code>doc/Dependencies.txt</code> 的约定。</p>
<h2 id="发布阶段"><a class="header" href="#发布阶段">发布阶段</a></h2>
<p>　　<em>发布阶段(release phase)</em> 使用的版本标识是被用户用于区分产品特性的标识。</p>
<p>　　正式标记形式为以 <code>V</code> 起始，跟随符合<a href="http://semver.org/lang/zh-CN/">语义化版本</a>规范<strong>语法</strong>的版本号。作为扩展，表示分支的版本号中的 <code>.y</code> 或 <code>.y.z</code> 以及表示具体版本的非可选部分的后缀 <code>.0</code> 或 <code>.0.0</code> 可省略。对省略后缀 <code>.0</code> 或 <code>.0.0</code> 的具体版本号，视为和不省略这些后缀的版本具有等价的含义。</p>
<p><strong>注释</strong> 标记的大小写敏感。</p>
<p>　　<em>发布(release)</em> 提供<em>可重复分发(redistributable)</em> 的、和版本控制机制相对独立的、集成的项目输出，通常以<em>包(package)</em> 为单位。</p>
<p>　　典型的发布的包可以是：</p>
<ul>
<li>源代码包。</li>
<li>（二进制）目标文件包。</li>
</ul>
<p>　　公开提供版本标识发布的版本是<em>发布版本(released version)</em> 。</p>
<p>　　为发布准备的<a href="Releases.zh-CN.html#%E5%88%86%E6%94%AF">分支</a>是<em>发布分支(relase branch)</em> 。发布分支可使用语义化版本的版本号标记。</p>
<p>　　语义化版本之间能确定一个<a href="https://zh.wikipedia.org/zh-cn/%E5%85%A8%E5%BA%8F%E5%85%B3%E7%B3%BB">全序</a>，即<em>版本顺序(version order)</em> ，允许同一个项目目标的任意的不同版本之间全局地比较大小，以确定版本演进的拓扑顺序。</p>
<p>　　版本顺序不一定和发布时间顺序完全对应，但只有一个版本组件的不同的两个语义化版本之间，顺序和发布顺序应保持一致。</p>
<p><strong>原理</strong> 序是反自反(irreflexive) 的。这保证了同一个发布分支版本演进的因果性(causality) 。</p>
<p>　　版本号同时符合语义化版本规范的<strong>语义</strong>：在语言实现保持兼容的前提下，相同<em>主版本(major version)</em> 的发布应保持公开的命令行调用接口、API 和 ABI 向后兼容。主版本变化可引入不和先前迭代周期中保证兼容的改动。</p>
<p>　　由公开的<a href="Home.zh-CN.html">兼容性约定</a>，除非另行指定，作为公开的命令行接口的工具在相邻的<em>次版本(minor version)</em> 之间向后兼容。一般地，若工具实现的公开功能被继续支持，命令行工具不在提供向后兼容功能的替代工具前被移除。</p>
<p><strong>注意</strong> 非标记为发布版本的开发版本不需要保证以上要求。</p>
<p>　　不兼容未来计划的改动的特性可被标记为<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">废弃</a>以表示可能在之后不继续支持。</p>
<h3 id="非正式版"><a class="header" href="#非正式版">非正式版</a></h3>
<p>　　非正式版的版本号小于 <code>1.0.0</code> ，不保证任何 ABI（应用程序二进制接口）兼容性。</p>
<p>　　所有非正式版共享一组迭代阶段。</p>
<h3 id="正式版"><a class="header" href="#正式版">正式版</a></h3>
<p>　　正式版的初始版本号为 <code>1.0.0</code> 。</p>
<p>　　正式版提供版本检查的 API 。</p>
<p>　　正式版对应的开发和测试版本使用以上除 PreAlpha 以外的阶段，具有上述相同的要求。</p>
<h1 id="支持策略"><a class="header" href="#支持策略">支持策略</a></h1>
<p>　　支持策略基于发布规则。</p>
<p>　　当前仅对最新的非正式版及版本库活动开发分支上的最新提交版本(tip) 提供公开支持。</p>
<p>　　正式版适用的规则另行具体指定。</p>
<h1 id="持续集成"><a class="header" href="#持续集成">持续集成</a></h1>
<p>　　<em>持续集成(continuous integration)</em> 是支持使项目保持持续演进的开发流程和实践。</p>
<h2 id="构建-3"><a class="header" href="#构建-3">构建</a></h2>
<p>　　提供有限的<em>构建自动化(build automation)</em> 支持。</p>
<p>　　关于使用的构建工具，参见<a href="Prerequisitions.zh-CN.html">先决条件</a>，并参见<a href="Build.zh-CN.html">构建</a>过程。</p>
<p>　　在<a href="Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">宿主环境</a>下使用项目内自行开发的工具支持，参见 <a href="Tools/SHBuild.zh-CN.html">SHBuild</a> 和 <a href="Sysroot.zh-CN.html">Sysroot</a> 。</p>
<h1 id="里程碑和路线图"><a class="header" href="#里程碑和路线图">里程碑和路线图</a></h1>
<p>　　本节略述发布版本的参照目标，包括重要的特性实现。</p>
<p>　　关于包含较详细特性变更说明的发布版本的<em>发布注记(release note)</em> ，参见版本库中的文档 <code>doc/Dependencies.txt</code> ；关于提交版本的详细变更记录(change log) ，参见项目文档 <code>doc/ChangeLog.*.txt</code> 。</p>
<h2 id="已实现的重要特性"><a class="header" href="#已实现的重要特性">已实现的重要特性</a></h2>
<h3 id="prealpha"><a class="header" href="#prealpha">PreAlpha</a></h3>
<p>　　PreAlpha 阶段实现平台中立的基础设施和 GUI 。每个发布版本包含重要的新增特性。</p>
<ul>
<li><strong>PreAlpha 1</strong> 实现可在 DS 和 DeSmuME 运行的 GUI 程序。</li>
<li><strong>PreAlpha 2</strong> 完善 GUI 部件并提供框架。</li>
<li><strong>PreAlpha 3</strong> 支持 MinGW32 移植和动态库：平台中立设计的验证实现。</li>
<li><strong>PreAlpha 4</strong> 支持基于 <a href="Features/NPL.zh-CN.html">NPL</a> 的配置设置、构建工具 <a href="Tools/SHBuild.zh-CN.html">SHBuild</a> 和运行时加载的 GUI 。</li>
<li><strong>PreAlpha 5</strong> 支持桌面程序特性：界面风格、动画及分离构建等。</li>
</ul>
<h3 id="alpha"><a class="header" href="#alpha">Alpha</a></h3>
<p>　　Alpha 阶段仍包含若干重要特性改进，但发布版本不再以添加单一特性为重点，而侧重提升环境的整体可用性。</p>
<ul>
<li><strong>V0.6</strong> 完善项目结构并提升宿主环境下的开发可用性支持。
<ul>
<li>添加整体测试。</li>
<li>添加桌面环境 YDE 。
<ul>
<li>当前主要用于示例。</li>
</ul>
</li>
<li>添加和完善若干专用于支持开发的工具。
<ul>
<li>添加 <a href="Tools/ProjectGenerator.zh-CN.html">ProjectGenerator</a> ，支持生成 Code::Blocks 项目。</li>
<li>支持宿主环境下的 SHBuild 自举 <a href="Sysroot.zh-CN.html">Sysroot</a> 部署。</li>
</ul>
</li>
</ul>
</li>
<li><strong>V0.7</strong> 完善各个平台的实现行为和互操作接口。
<ul>
<li>替换 DS 的文件系统实现。</li>
<li>支持宿主环境下的 YSLib 多个映像实例共存。
<ul>
<li>每个映像实例包括动态库和配置文件等<a href="Run.zh-CN.html">运行时支持环境</a>。</li>
<li>映像实例可以是 Sysroot ，也可以手动部署。</li>
<li>不要求映像实例具有相同的版本。</li>
<li>当前对环境变量透明；必要时，仍需手动指定 <a href="Run.zh-CN.html"><code>PATH</code></a> 。</li>
<li>当前全面支持仅限 MinGW32 ：配置位置不再依赖当前工作目录。</li>
</ul>
</li>
<li>按独立的语言解释实现添加 NPL 接口。</li>
</ul>
</li>
<li><strong>V0.8</strong> 完善内部互操作性和部署。
<ul>
<li>改进运行时对象操作 API 。</li>
<li>扩充 NPLA/NPLA1 。
<ul>
<li>设计和实现新的求值规则。</li>
<li>提供较完整的 REPL 支持。</li>
</ul>
</li>
<li>在 SHBuild 中使用 NPLA1 代替系统默认的 shell 环境，用于实现部分 Sysroot 部署。</li>
</ul>
</li>
<li><strong>V0.9</strong> 增强 NPL 和部署环境。
<ul>
<li>继续完善 NPL 接口并提升实现性能。
<ul>
<li>默认使用异步调用实现，避免嵌套调用过深时的未定义行为，并支持 PTC 。</li>
<li>节点和环境等数据结构支持分配器。</li>
<li>显著优化分析器和求值的性能。</li>
<li>添加 NPLA1 源代码信息支持，并增强错误信息。</li>
<li>添加更多的标准库操作。</li>
</ul>
</li>
<li>增强配置管理。
<ul>
<li>支持后备路径。</li>
<li>支持检测<a href="Run.zh-CN.html#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80">类 FHS 的文件系统布局</a>。</li>
</ul>
</li>
<li>Sysroot 安装构建脚本。</li>
</ul>
</li>
</ul>
<h2 id="重点计划目标"><a class="header" href="#重点计划目标">重点计划目标</a></h2>
<ul>
<li><strong>V0.10</strong> 计划进一步增强 NPL 和构建环境。
<ul>
<li>继续完善 NPL 接口并提升实现性能。</li>
<li>支持多个运行时实例交互。</li>
<li>基于 Sysroot 的多平台自动化部署方案。</li>
</ul>
</li>
</ul>
<h1 id="待定事项todos"><a class="header" href="#待定事项todos">待定事项(TODOs)</a></h1>
<p>　　版本发布的待定事项参照上述目标。</p>
<p>　　<a href="Home.zh-CN.html">贡献到问题跟踪系统</a>的内容可能包含特性请求和没有立刻解决的缺陷记录，其实现会被考虑列入待定事项。</p>
<p>　　完整列表当前仅被内部参照，没有公开。</p>
<h1 id="版本发布记录"><a class="header" href="#版本发布记录">版本发布记录</a></h1>
<p>　　发布页可能包括后续开发信息。</p>
<p>　　关于被发布的资源，参见<a href="Archives.zh-CN.html">归档</a> 。</p>
<p>　　发布页基于历史因素归档。链接可能失效。</p>
<h2 id="prealpha-发布页"><a class="header" href="#prealpha-发布页">PreAlpha 发布页</a></h2>
<h3 id="prealpha-1"><a class="header" href="#prealpha-1">PreAlpha 1</a></h3>
<ul>
<li><a href="http://tieba.baidu.com/p/767225536">百度贴吧</a>。</li>
<li><a href="http://www.yayabo.cn/forum.php?mod=viewthread&amp;tid=3878">掌机开发者之家</a>。</li>
</ul>
<h3 id="prealpha-2"><a class="header" href="#prealpha-2">PreAlpha 2</a></h3>
<ul>
<li><a href="http://tieba.baidu.com/p/1043526998">百度贴吧</a>。</li>
<li><a href="http://www.yayabo.cn/forum.php?mod=viewthread&amp;tid=17543">掌机开发者之家</a>。</li>
</ul>
<h3 id="prealpha-3"><a class="header" href="#prealpha-3">PreAlpha 3</a></h3>
<ul>
<li><a href="http://tieba.baidu.com/p/1511876559">百度贴吧</a>。</li>
<li><a href="http://www.yayabo.cn/forum.php?mod=viewthread&amp;tid=22988">掌机开发者之家</a>。</li>
</ul>
<h3 id="prealpha-4"><a class="header" href="#prealpha-4">PreAlpha 4</a></h3>
<ul>
<li><a href="http://tieba.baidu.com/p/2288320823">百度贴吧</a>。</li>
<li><a href="http://www.yayabo.cn/forum.php?mod=viewthread&amp;tid=25961">掌机开发者之家</a>。</li>
</ul>
<h3 id="prealpha-5"><a class="header" href="#prealpha-5">PreAlpha 5</a></h3>
<ul>
<li><a href="http://tieba.baidu.com/p/3069607390">百度贴吧</a>。</li>
<li><a href="http://www.yayabo.cn/forum.php?mod=viewthread&amp;tid=26450">掌机开发者之家</a>。</li>
</ul>
<h2 id="alpha-发布页"><a class="header" href="#alpha-发布页">Alpha 发布页</a></h2>
<h3 id="06"><a class="header" href="#06">0.6</a></h3>
<ul>
<li><a href="http://tieba.baidu.com/p/3747376832">百度贴吧</a>。</li>
<li><a href="http://www.yayabo.cn/forum.php?mod=viewthread&amp;tid=26718">掌机开发者之家</a>。</li>
</ul>
<h3 id="07"><a class="header" href="#07">0.7</a></h3>
<ul>
<li><a href="http://tieba.baidu.com/p/4701412006">百度贴吧</a> 。</li>
</ul>
<h1 id="版本日程记录"><a class="header" href="#版本日程记录">版本日程记录</a></h1>
<p>　　记录的时间来自存档和提交记录，使用时区 UTC+8 。</p>
<p>　　发布版本的计划时间为截止时间。评估计划完成情况时，实际时间应早于此时间。</p>
<h2 id="prealpha-1"><a class="header" href="#prealpha-1">PreAlpha</a></h2>
<p>　　早期开发版本计划未定。发布版本为每 100 个开发更新版本中形成。</p>
<p>　　计划（追溯）及里程碑版本：</p>
<ul>
<li><strong>PreAlpha 0</strong> 2009-02 W3
<ul>
<li>PALibTest: 2009-10-10</li>
</ul>
</li>
<li><strong>PreAlpha 1</strong> 2010-03 W1
<ul>
<li>YSTest b98: 2010-05-05</li>
</ul>
</li>
<li>使用 <a href="https://www.mercurial-scm.org/">Mercurial</a>
<ul>
<li>YSLib b132 2010-07-13</li>
</ul>
</li>
</ul>
<p>　　使用版本控制，开发更新版本对应提交版本。提交版本仅主分支版本。更新频率逐步控制为 8 提交版本/月，其中月以自然月计，折合 4 周工作量。</p>
<p>　　计划及实际发布版本：</p>
<ul>
<li><strong>PreAlpha 2</strong> 2011-03 W4
<ul>
<li>YSLib b200: 2011-04-11</li>
</ul>
</li>
<li><strong>PreAlpha 3</strong> 2012-04 W2
<ul>
<li>YSLib b300: 2012-04-12</li>
</ul>
</li>
<li><strong>PreAlpha 4</strong> 2013-04 W4
<ul>
<li>YSLib b400: 2013-04-24</li>
</ul>
</li>
<li><strong>PreAlpha 5</strong> 2014-05 W2
<ul>
<li>YSLib b500: 2014-05-30</li>
</ul>
</li>
</ul>
<h2 id="alpha-1"><a class="header" href="#alpha-1">Alpha</a></h2>
<p>　　保持提交和发布版本更新频率不变。</p>
<p>　　计划及实际发布版本：</p>
<ul>
<li><strong>V0.6</strong> 2015-05 W4
<ul>
<li>YSLib b600: 2015-05-26</li>
</ul>
</li>
<li><strong>V0.7</strong> 2016-06 W2
<ul>
<li>YSLib b700: 2016-06-11</li>
</ul>
</li>
</ul>
<p>　　为便于特性整合和进度统计，2017 Q2 计划提交和发布版本基准周期增加 1 倍。</p>
<p>　　新的发布计划日程安排于 2017-07-01 启用。追溯 Alpha 发布历史并调整截止日程：</p>
<ul>
<li><strong>V0.6</strong> 2016-06 W2</li>
<li><strong>V0.7</strong> 2018-07 W2</li>
</ul>
<p>　　使用以下日程同步计划过渡到新的截止日期：</p>
<ul>
<li>同步目标外推 4 次，并对每个发布版本递增添加 4 周发布准备，至 <strong>V0.11</strong> 2027-01 W2 。</li>
<li>计划使用在新的基准周期外的至多和原提交周期相同的额外缓冲时间和截止日程同步。
<ul>
<li>因此，提交版本周期至多为原周期的 3 倍；即更新频率控制为至少 8/3 提交版本/月 。</li>
</ul>
</li>
<li>同时，抽取 6 周用于 <strong>V0.8</strong> 发布准备。
<ul>
<li>原计划外推 <strong>V0.8</strong> 发布时间为 2017-06 W4 ，推迟后为 2017-08 W2 。</li>
<li>新计划外推 1 次 2018-08 W2 ，同步版本后相差 24 月，补充到后续发布版本中。</li>
</ul>
</li>
<li><strong>V0.10</strong> 计划周期起每发布版本补充 8 周缓冲准备时间。
<ul>
<li>原计划外推 <strong>V0.10</strong> 发布时间为 2023-12 W2 ，推迟后为 2024-12 W2 。</li>
<li>新计划外推 1 次 2027-01 W2 ，同步版本后相差 4 月，补充到后续发布版本中。</li>
</ul>
</li>
</ul>
<p>　　随之改订的计划及待定发布版本：</p>
<ul>
<li><strong>V0.8</strong> 2017-08 W2
<ul>
<li>YSLib b800: 2017-08-10</li>
</ul>
</li>
<li><strong>V0.9</strong> 2020-10 W2
<ul>
<li>YSLib b900: 2020-10-13</li>
</ul>
</li>
<li><strong>V0.10</strong> 2024-02 W2
<ul>
<li>YSLib b1000: TBD</li>
</ul>
</li>
<li><strong>V0.11</strong> 2027-05 W2
<ul>
<li>YSLib b1100: TBD</li>
</ul>
</li>
</ul>
<h2 id="beta"><a class="header" href="#beta">Beta</a></h2>
<p>　　待定。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概要-3"><a class="header" href="#概要-3">概要</a></h1>
<p>　　归档文件目前存放于以下位置：</p>
<ul>
<li><a href="http://pan.baidu.com">百度云网盘</a>：进入 <a href="http://pan.baidu.com/s/1mgjxaY0#list/path=%2FShared%2FYSLib">YSLib 主仓库</a>查看所有发布的文件，可转存或直接下载。
<ul>
<li>因为分享限制，地址可能需要更新。</li>
</ul>
</li>
<li><a href="https://osdn.net">OSDN</a>：进入 <a href="https://osdn.net/projects/yslib/releases/">YSLib 项目下载页</a>查看发布的文件。</li>
</ul>
<p><strong>注意</strong> 作为归档的压缩包文件一般统一使用 7z ，但不同的归档使用不同的压缩算法和选项，对系统资源要求不尽相同。作为极端情况，V0.6 后的 <code>doc</code> 下的压缩包使用具有 1.5GiB 字典的 PPMd 达到约 5% 的压缩比，这一般也要求解压缩时需<strong>预留 20 倍压缩包大小的空余空间，以及 1.5GiB 空余（物理）内存</strong>。</p>
<h1 id="命名规约"><a class="header" href="#命名规约">命名规约</a></h1>
<p>　　文件名使用 <code>[平台环境标识-]包名-版本[-配置]</code>.后缀 。“<code>[]</code>”中为可选项。特定平台的目录名可参照此规约。</p>
<p>　　对于二进制文件和库文件，<a href="Terminology.zh-CN.html">平台环境标识</a>使用目标三元组分类：<code>archc-OS-toolchain</code> ；不限定体系结构的使用 "<code>any</code>" 。</p>
<p>　　发布时若文件没有更新，则不另行更新版本。若某个包不存在预期的版本，尝试使用之前最近的版本代替。</p>
<h2 id="顶级目录结构"><a class="header" href="#顶级目录结构">顶级目录结构</a></h2>
<ul>
<li><code>src</code> 可用于直接构建的源代码（包括外部依赖项的二进制库文件）包</li>
<li><code>example</code> 示例代码</li>
<li><code>doc</code> 文档（打包的 Doxygen 文档）</li>
<li><code>any</code> 体系结构中立的文件（头文件和数据文件）</li>
<li><code>arm-ds-eabi</code> DS 平台文件</li>
<li><code>i686-w64-mingw32</code> Win32 平台文件</li>
<li><code>arm-linux-androideabi</code> Android ARM 平台文件</li>
<li><code>x86_64-linux-gnu</code> Linux x64 平台文件</li>
</ul>
<p><strong>注意</strong> 因为包含所有平台的库文件过大且文件重复，考虑到存储和传输开销，V0.9 起不提供 YSLib 整体的源代码包（位于 <code>src</code>）。请直接参照<a href="GettingSources.zh-CN.html">获取源代码</a>中的来源，同步版本库或下载源代码，再下载所需平台的外部依赖项的归档文件，并按<a href="Development.zh-CN.html">开发说明</a>存储到相应位置。Sysroot 归档中仍包含对应的外部依赖项。</p>
<h2 id="包概要"><a class="header" href="#包概要">包概要</a></h2>
<p>以下为各个具体体系结构目录下的包的概要（并不一定保证每个体系结构具有所有这些包）。</p>
<ul>
<li><code>External</code> 外部依赖项</li>
<li><code>Sysroot</code> 打包的 Sysroot 文件</li>
<li><code>YSTest</code> YSTest 二进制文件</li>
<li><code>YDE</code> 二进制文件</li>
</ul>
<p>　　内容详见以下二进制文件说明。</p>
<p>　　以下为 <code>any</code> 目录下的包的概要。</p>
<ul>
<li><code>yslib-data</code> YSLib 运行时依赖的数据文件，参见<a href="Run.zh-CN.html">运行说明</a></li>
<li><code>ybase-header</code> YBase 头文件</li>
<li><code>yframework-header</code> YFramework 头文件</li>
</ul>
<p>V0.6 起不单独提供头文件，可使用源代码包或 Sysroot 包代替。</p>
<p>　　此外，源代码包名以 <code>-src</code> 为后缀，在 <code>src</code> 目录下；而 <code>Doxygen-html</code> 是通过 Doxygen 生成的 HTML/XHTML 文档的包名，在 <code>doc</code> 目录下。</p>
<h1 id="二进制文件说明"><a class="header" href="#二进制文件说明">二进制文件说明</a></h1>
<p>　　<a href="Releases.zh-CN.html">Beta 阶段</a>前，二进制文件不用于对所有被支持的平台提供完整可用的环境。</p>
<p>　　除以下另行指定，V0.6(build 600) 起，仅第一类支持（支持等级详见 YSLib 项目文档 <code>doc/ProjectRules.txt</code> ）且具有 Sysroot 的平台配置提供完整的二进制文件，包括库和示例项目等。</p>
<h2 id="external"><a class="header" href="#external">External</a></h2>
<p>　　单独<a href="Build.zh-CN.html#%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96%E9%A1%B9%E6%9E%84%E5%BB%BA">构建</a>的<a href="ProjectDependencies.zh-CN.html#%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96%E9%A1%B9">外部依赖项</a>，一般是<a href="ProjectDependencies.zh-CN.html#%E5%A4%96%E9%83%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%BA%93">二进制库文件</a>。对所有支持的平台提供。</p>
<p>　　V0.6(build 600) 起<a href="ProjectDependencies.zh-CN.html#%E5%A4%96%E9%83%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%BA%93">版本库中不再保持二进制文件</a>。源代码包 <code>src-*.7z</code> 中包括已经编译的外部依赖项。此外，各个平台目录下的 <code>External-*.7z</code> 单独对依赖项打包，可参照前文中的位置自行放置。</p>
<h2 id="sysroot"><a class="header" href="#sysroot">Sysroot</a></h2>
<p>　　自 build 600 起提供在 release 配置下构建部署的 MinGW <a href="Sysroot.zh-CN.html">Sysroot</a> ，包名为 <code>Sysroot</code> 。</p>
<p>　　因为归档文件限制，符号链接压缩为空文件。如需使用符号链接位置的库，可以手动恢复，流程参见<a href="Tools/Scripts.zh-CN.html">构建脚本</a>。</p>
<h2 id="ystest"><a class="header" href="#ystest">YSTest</a></h2>
<p>　　源代码中默认构建的<a href="Features.zh-CN.html">测试用示例项目</a>，按内容命名为 YReader 。</p>
<h2 id="yde"><a class="header" href="#yde">YDE</a></h2>
<p>　　自 build 600 起提供 release 配置下在 Sysroot 上构建的 <a href="YDE.zh-CN.html">YDE</a> 合集，包名为 <code>YDE</code> 。</p>
<p>　　其中的可执行文件依赖 YBase 和 YFramework 动态库。</p>
<h1 id="构建环境"><a class="header" href="#构建环境">构建环境</a></h1>
<p>　　<a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared">这里</a>提供了 YSLib 历史和当前版本使用的构建环境相关的归档，其中 YSLib 目录即上述发布仓库。</p>
<h2 id="基本环境和工具链"><a class="header" href="#基本环境和工具链">基本环境和工具链</a></h2>
<p>　　仅提供<a href="Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">宿主环境</a>操作系统为 Windows 的二进制文件。</p>
<p>　　这些资源仅作为存档以重现历史版本的构建。一般开发建议首先尝试使用最新版本的构建环境。</p>
<h3 id="mingw32-目标和宿主环境"><a class="header" href="#mingw32-目标和宿主环境">MinGW32 目标和宿主环境</a></h3>
<ul>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2Fsf.net%2Fmingwbuilds">mingw-builds</a></li>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2Fsf.net%2Fmingw-w64%2Fmingw-builds">合并到 mingw-w64 发布的 mingw-builds</a></li>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2Fsf.net%2FMSYS2%2FBase">MSYS2</a></li>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2Fsf.net%2FMSYS2%2FREPOS%2FMINGW">MSYS2 MinGW 包</a></li>
</ul>
<h3 id="ds-1"><a class="header" href="#ds-1">DS</a></h3>
<ul>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2Fsf.net%2FdevkitPro">devkitPro</a></li>
</ul>
<h3 id="android-1"><a class="header" href="#android-1">Android</a></h3>
<ul>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2FProgram%2FAndroid%2Fwindows-x86_64">Android 独立工具链和 SDK 工具</a></li>
</ul>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<ul>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2Farchlinux.org">ArchLinux 包</a></li>
</ul>
<h2 id="文档工具"><a class="header" href="#文档工具">文档工具</a></h2>
<ul>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2Fdoxygen.nl">Doxygen</a>
<ul>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2Fgraphviz.org">GraphViz</a></li>
</ul>
</li>
</ul>
<h2 id="外部依赖项的源代码"><a class="header" href="#外部依赖项的源代码">外部依赖项的源代码</a></h2>
<ul>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2Fsf.net%2Ffreetype">FreeType2</a></li>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2Fsf.net%2Ffreeimage%2FSource%20Distribution">FreeImage</a>
<ul>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2Fsf.net%2Flibjpeg-turbo">LibJPEG-Turbo</a></li>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2Fsf.net%2Flibpng">LibPNG</a>
<ul>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2Fsf.net%2Flibpng%2Fzlib">ZLib</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="shbuild"><a class="header" href="#shbuild">SHBuild</a></h1>
<p>　　位于 <code>Tools/SHBuild</code> ，是可以用来递归遍历目录编译链接本机程序和调用其它相关功能的命令行工具。当前仅支持 MinGW32/MinGW64 环境。其它平台详见以下章节。</p>
<p>　　直接（不带参数）运行 <code>SHBuild</code> 查询使用方法和选项等说明。</p>
<h2 id="构建-4"><a class="header" href="#构建-4">构建</a></h2>
<p>　　本节说明 SHBuild 的构建。关于使用 SHBuild 构建用户程序，参见前述概要和之后的章节。</p>
<p>　　除非另行指定，其它章节也适用于本节内构建的非最终阶段 SHBuild 。本章仅补充仅适用于这些 SHBuild 的特点和功能。</p>
<p>　　关于使用 <code>bash</code> 构建库、SHBuild 、测试项目和基于 SHBuild 上的用户程序，参见<a href="Tools/../Sysroot.zh-CN.html">关于 <strong>MinGW Sysroot</strong> 的说明</a>。</p>
<p>　　当前只支持<a href="Tools/../Terminology.zh-CN.html">本机构建</a>。</p>
<p>　　除了指定调用编译器等工具的名称外的其它情形对 SHBuild 是<em>透明(transparent)</em> 的，即 SHBuild 不使用<a href="Tools/../Terminology.zh-CN.html">目标平台的标识</a>执行不同逻辑。这样，也可能不经修改调用命令的情况下成功<a href="Tools/../Terminology.zh-CN.html">交叉构建</a>，但当前未测试。</p>
<h3 id="引导"><a class="header" href="#引导">引导</a></h3>
<p>　　SHBuild 支持<em>引导(bootstrapping</em>) ，即在受支持的构建环境中直接构建 SHBuild ，不依赖预先构建的 SHBuild 二进制映像。</p>
<p>　　运行脚本 <code>Tools/Scripts/SHBuild-build.sh</code> 生成 SHBuild 可执行文件。</p>
<p>　　脚本直接选取 YSLib 中的源文件作为依赖进行构建。因为直接调用编译器驱动链接，不支持显式指定并行编译，相对比较慢。编译的结果是静态链接的，二进制映像较大。</p>
<p>　　这个过程只需要 C++ 工具链和 shell ，不需要直接调用 <code>make</code> ，但 GCC 使用 <code>-flto</code> 进行优化仍然需要 GNU make 。</p>
<p>　　如能成功使用以下的多阶段构建方法（会按需调用引导脚本），一般不建议使用直接构建的版本。</p>
<h3 id="自举"><a class="header" href="#自举">自举</a></h3>
<p>　　SHBuild 支持<em>自举(self hosting)</em> ，即可使用构建的 SHBuild 继续构建自身。</p>
<p>　　除需 <code>SHBuild</code> 可执行程序外，对<a href="Tools/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">外部环境</a>的要求和<a href="Tools/SHBuild.zh-CN.html#%E5%BC%95%E5%AF%BC">引导</a>一致。</p>
<p>　　SHBuild 一直使用简单的源代码结构，设计初期即支持自举，现时仍不限制自举需要的版本。但由于仅测试相同版本的自举构建，因此一般建议使用相同版本。</p>
<p>　　以下<a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">多阶段构建</a>在<a href="Tools/SHBuild.zh-CN.html#%E5%BC%95%E5%AF%BC">引导</a>的基础上自举构建 SHBuild 。</p>
<p>　　此外，也可以直接使用 <code>SHBuild-self-host.sh</code> 和 <code>SHBuild-self-host-DLL.sh</code> 进行直接自举。这两个脚本主要用于内部测试。</p>
<h3 id="多阶段构建"><a class="header" href="#多阶段构建">多阶段构建</a></h3>
<p>　　使用<a href="Tools/Scripts.zh-CN.html">工具脚本</a>安装 <a href="Tools/../Sysroot.zh-CN.html">Sysroot</a> 时，按需<a href="Tools/SHBuild.zh-CN.html#%E6%9E%84%E5%BB%BA">构建 SHBuild</a> 。</p>
<p>　　运行<a href="Tools/Scripts.zh-CN.html#toolsinstall-sysrootsh">Sysroot 安装脚本</a>可直接完成以下多个阶段的构建和目标程序的部署(deployment) ：</p>
<ul>
<li>Stage 1 ，即第一阶段：<a href="Tools/SHBuild.zh-CN.html#%E5%BC%95%E5%AF%BC">引导</a>。
<ul>
<li>这个阶段运行 <a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-buildsh"><code>Tools/Scripts/SHBuild-build.sh</code></a> 构建 stage 1 SHBuild 。
<ul>
<li>若已存在构建了的 stage 1 SHBuild 可执行程序，Sysroot 安装脚本不再重新构建 stage 1 SHBuild 。
<ul>
<li>可指定非空的 <code>SHBuild_Rebuild_S1</code> 环境变量值以要求 Sysroot 安装脚本无视已存在的 stage 1 SHBuild 的可执行程序而重新构建。</li>
</ul>
</li>
<li>脚本检查 GNU parallel 的可用性。默认使用 GNU parallel 并行构建。</li>
<li><strong>原理</strong> 为可维护性，stage 1 SHBuild 的构建直接使用静态链接，且过程依赖避免<a href="Tools/../Terminology.zh-CN.html#%E5%B9%B3%E5%8F%B0%E6%A0%87%E8%AF%86">系统库</a>以外的<a href="Tools/../ProjectDependencies.zh-CN.html#%E5%A4%96%E9%83%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%BA%93">外部二进制依赖项</a>和<a href="Tools/../Run.zh-CN.html">通过文件系统以外的方式访问远程资源</a>。
<ul>
<li>不依赖外部工具的串行构建可能相当费时，但仍可被接受。</li>
</ul>
</li>
</ul>
</li>
<li>引导结果为 stage 1 SHBuild 程序，主要用于下一阶段使用，不保证具有所有 SHBuild 的功能特性。
<ul>
<li>可执行程序不被另行部署。</li>
<li>一般不建议直接使用。</li>
</ul>
</li>
<li><strong>原理</strong> 因为 stage 1 的目的是引导宿主构建的 SHBuild 并构建 YSLib 和其它依赖 YSLib 的应用，所以使用不依赖 YSLib 项目输出的原始的<a href="Tools/../Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">宿主环境</a>。
<ul>
<li>依照<a href="Tools/../Development.zh-CN.html">开发说明</a>配置的宿主环境是受支持的可用于运行构建工具的环境作为 stage 1 <a href="Tools/../Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">构建和运行环境</a>。
<ul>
<li>构建时依赖这个环境的脚本运行环境运行构建脚本，并依赖其中的工具链进行编译链接。</li>
</ul>
</li>
<li>显然地，stage 1 不使用已被部署的 <code>SHBuild</code> 可执行程序。</li>
<li>因为不假设 <a href="Tools/../Development.zh-CN.html#npla1-%E8%84%9A%E6%9C%AC">NPLA1</a> 实现（默认由 SHBuild 提供）的可用性，<a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-buildsh">构建 stage 1 SHBuild 的脚本</a>是 <a href="Tools/../Development.zh-CN.html#shell-%E8%84%9A%E6%9C%AC">shell 脚本</a>而非 <a href="Tools/../Development.zh-CN.html#npla1-%E8%84%9A%E6%9C%AC">NPLA1 脚本</a>。</li>
</ul>
</li>
</ul>
</li>
<li>Stage 2 ，即第二阶段：<a href="Tools/SHBuild.zh-CN.html#%E8%87%AA%E4%B8%BE">自举</a>。
<ul>
<li>这个阶段在 Sysroot 安装脚本内调用成功引导的 stage 1 SHBuild 使用<a href="Tools/SHBuild.zh-CN.html#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F">命令模式</a>运行 NPLA1 脚本程序继续构建。
<ul>
<li>继续构建通过运行 <a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-yslib-buildtxt"><code>Tools/Scripts/SHBuild-YSLib-build.txt</code></a> 实现，步骤包括：
<ul>
<li>构建 YBase 和 YFramework 库。</li>
<li>自举构建 <code>SHBuild</code> ，链接到之前构建的 YFramework 和 YBase 动态库。</li>
</ul>
</li>
<li>Sysroot 安装脚本可通过 <a href="Tools/../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><code>SHBuild</code> 环境变量</a>指定 YSLib 库构建过程中使用的 SHBuild 命令。
<ul>
<li>若不指定变量 <code>SHBuild</code> ，默认值是（先前应已被检查并确保按需构建的）stage 1 SHBuild 的路径。</li>
<li><strong>原理</strong> 默认不需要另行部署 SHBuild 即可完成自举和之后的安装。但若在当前宿主环境中已存在可用的 <code>SHBuild</code> 可执行程序，指定 <code>SHBuild</code> 可避免 Sysroot 安装脚本中默认的不必要的 stage 1 SHBuild 构建。</li>
</ul>
</li>
</ul>
</li>
<li>自举结果为 stage 2 SHBuild 。
<ul>
<li>这是当前最终生成的 SHBuild ，链接和运行依赖上述 YBase 和 YFramework 动态库。</li>
<li>当前 stage 2 SHBuild 总是需要 release 动态库，因此除非先前已部署（足够新版本的兼容的）对应配置的库，不包含这个目标时 stage 2 SHBuild 会符合预期地构建失败。</li>
</ul>
</li>
<li><strong>原理</strong> 构建 YSLib 库是整个 Sysroot 环境安装的主要目标，是构建 stage 2 SHBuild 前的必要步骤，整体一般比构建 stage 1 SHBuild 更加费时，但是：
<ul>
<li>借助 SHBuild ，这些构建目标的编译过程是确保可并行的。</li>
<li>NPLA1 脚本接收的环境变量可通过调用 Sysroot 安装脚本指定，允许更灵活地控制构建使用的并行任务数等选项，且同时允许选择性仅构建和安装部分构建配置（包括 debug 或 release 模式，静态或动态库）的目标而节约开销。</li>
</ul>
</li>
</ul>
</li>
<li>使用 SHBuild 运行当前 YSLib 存储库中的特定的 NPLA1 脚本可选地构建其它目标，包括 <code>Tools</code> 中的 <code>SHBuild</code> 以外的二进制工具。
<ul>
<li>默认使用新近生成的 stage 2 SHBuild 可执行程序。</li>
<li>可通过 <a href="Tools/../Development.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><code>SHBuild</code> 环境变量</a>指定使用的 SHBuild 命令以被 NPLA1 脚本递归地调用。</li>
</ul>
</li>
<li>安装 stage 2 SHBuild 和（可选的）其它工具。
<ul>
<li><a href="Tools/../Development.zh-CN.html#%E8%84%9A%E6%9C%AC">开发脚本</a>中的<a href="Tools/Scripts.zh-CN.html">一部分被部署到 Sysroot</a> 的 stage 2 运行环境，也可在开发 YSLib 应用以外的情形被直接运行。</li>
</ul>
</li>
</ul>
<p>　　两个 SHBuild 构建阶段需要的外部环境对应称为 <em>stage 1 环境(stage 1 environment)</em> 和 <em>stage 2 环境(stage 2 environment)</em> ，合称 <em>SHBuild 构建环境(SHBuild building environment)</em> ；部署 stage 2 SHBuild（和可选的目标）后的环境是<em>部署后环境(deployed environment)</em> 。</p>
<p><strong>注释</strong> 使用新近生成的 SHBuild 构建可选目标同时作为直接的部署后环境可用性测试，因而不提供指定其它 SHBuild 工具的选项。</p>
<p>　　作为更一般的开发环境和最终用户部署基于 Sysroot 的 YSLib 的应用的运行环境，stage 2 和部署后环境相对 stage 1 环境具有更多的假设和更少的限制：</p>
<ul>
<li>使用 <code>SHBuild</code> 构建时，假定 <code>PATH</code> 中存在兼容的 <code>SHBuild</code> 可执行程序的命令，或已通过 <a href="Tools/../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><code>SHBuild</code> 变量</a>指定 <code>SHBuild</code> 可执行程序。
<ul>
<li>在 Sysroot 构建 YSLib 的库时，默认使用先前 stage 1 SHBuild ，其它情形默认使用 stage 2 SHbuild 。</li>
<li>应确保 SHBuild 程序和使用的 NPLA1 脚本的版本匹配，一般来自同一个 Sysroot 安装。
<ul>
<li>若 <code>SHBuild</code> 没有与更新版本的脚本匹配，运行可能失败，这不被支持。
<ul>
<li>此时仍建议重新构建 stage 1 SHBuild ；参见以上 stage 1 的说明。</li>
</ul>
</li>
<li>但除非另行指定，NPLA1 脚本的内容不依赖具体实现环境，且仅通过 SHBuild 调用。</li>
<li>这些实际脚本通过可直接复制到兼容的安装的位置部署。
<ul>
<li>但这些位置不保证作为公开接口而保持不变；同时需注意在运行环境中具有可读权限。</li>
</ul>
</li>
<li>因此除非必要，一般仍建议使用 Sysroot 默认配置进行部署。</li>
</ul>
</li>
<li>除非另行指定，Sysroot 构建不依赖 stage 1 和 stage 2 的 SHBuild 中可能具有的差异。
<ul>
<li>因此，可（通过环境变量）指定任意的预先安装的和 NPLA1 脚本匹配版本的 SHBuild 程序。</li>
</ul>
</li>
<li>一般建议开发环境中把某个 Sysroot 的 <code>bin</code> 目录加入 <code>PATH</code> 环境变量，以使用其中的 <code>SHBuild</code> 命令。
<ul>
<li>使用这个环境开发时，运行环境和 stage 2 构建环境相同，且可使用 stage 2 SHBuild 和其它工具。</li>
<li>需要使用不同的 SHBuild 程序时仍可通过 <code>SHBuild</code> 环境变量指定。否则，变量 <code>SHBuild</code> 的默认值是 <code>SHBuild</code> ，因此 <code>PATH</code> 环境变量应存在名为 <code>SHBuild</code> 可执行程序。这被这个环境中默认满足。</li>
<li>在 Windows 系统中，被 Sysroot 构建和部署的 SHBuild 的可执行文件名总是 <code>SHBuild.exe</code> 。除非有同名的目录（在部署中不会出现），在 Windows 的命令行运行这个可执行文件不需要后缀。</li>
<li>在其它运行环境中，被 Sysroot 部署的 SHBuild 的可执行文件通常是 <code>SHBuild</code> 。但在此之前，<a href="Tools/SHBuild.zh-CN.html#%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%BC%8F">为避免和同名的目录冲突，使用 SHBuild 构建时直接得到的可执行文件总是带有 <code>.exe</code> 扩展名</a>。</li>
</ul>
</li>
</ul>
</li>
<li>这些环境使用 NPLA1 脚本而不是仅在 stage 1 环境可用的 shell 脚本提供主要的构建功能。
<ul>
<li>这些功能<a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-yslib-commontxt">部分相似但也有一定差异</a>。</li>
</ul>
</li>
</ul>
<p>　　由于<a href="Tools/../Terminology.zh-CN.html">多平台构建</a>的自然要求，这些环境需要相同（本机构建），或至少保持兼容性。当前工具脚本没有另行显示指定使用不同平台的接口，因此只支持本机构建。</p>
<h2 id="运行-2"><a class="header" href="#运行-2">运行</a></h2>
<p>　　通过以下方式调用 <code>SHBuild</code> 命令输出帮助消息并退出：</p>
<ul>
<li>没有命令行参数。</li>
<li>使用 <code>-h</code> 或 <code>--help</code> 作为命令行参数。</li>
</ul>
<p>　　通过以下方式调用 <code>SHBuild</code> 命令输出版本信息并退出：</p>
<ul>
<li>使用 <code>-V</code> 或 <code>--version</code> 作为命令行参数。</li>
</ul>
<p>　　其它情形调用 <code>SHBuild</code> ，使用参数执行命令，支持不同的运行模式：</p>
<ul>
<li>构建模式：调用递归扫描指定的目录以调用构建后端工具。</li>
<li>命令模式：执行内建的功能。</li>
</ul>
<p>　　命令模式以 <code>-xcmd,</code> 起始的选项指定。其它情形的运行使用构建模式。</p>
<p>　　命令行参数 <code>--</code> 钱的参数中，以 <code>-x</code> 起始的特定选项（详见帮助消息）被作为 SHBuild 选项。命令行参数 <code>--</code> 后的参数不被识别为 SHBuild 选项，而被传递给后端或作为命令模式的参数。</p>
<p>　　以下仅列出部分选项。关于环境、选项和退出状态等的详细说明参见帮助消息。</p>
<h3 id="构建模式"><a class="header" href="#构建模式">构建模式</a></h3>
<p>　　构建模式递归扫描指定的源代码目录，以其中符合内建规则要求的文件作为输入，调用相应的后端命令行构建。构建包括对符合内建规则的输入的编译，以及对得到的目标文件进行链接。除 SHBuild 选项的命令行参数直接传除递给后端编译器。若需要构建复杂项目，可以使用其它的脚本支持。</p>
<p>　　调用的构建后端工具的名称以及链接器命令行选项可使用<a href="Tools/../Development.zh-CN.html">环境变量</a>指定。此外，若环境变量 <code>SHBuild_CFLAGS</code> 和 <code>SHBuild_CXXFLAGS</code> 被定义为非空值，调用 C 和 C++ 编译器命令行时，变量的值会先于生成的命令选项以及上述命令行选项被传递。关于支持的环境变量，详见运行 <code>SHBuild</code> 的说明。</p>
<p>　　调用的后端命令行的不同的命令行选项之间应确保以空白符间隔。环境变量确定的选项不被检查；由 SHBuild 生成的命令行选项之间以一个空格分隔。</p>
<p>　　使用 SHBuild 构建若得到的库文件，则按<a href="Tools/../Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">宿主平台</a>确定添加的文件扩展名；而可执行文件总是带有 <code>.exe</code> 后缀，以避免递归扫描生成的输出文件目录和可执行文件重名导致无法生成。</p>
<p>　　构建模式支持以 <code>-xdef,</code> 起始的选项指定变量配置，可覆盖环境的值。</p>
<p>　　通过<a href="Tools/../Development.zh-CN.html#%E8%84%9A%E6%9C%AC">开发脚本</a>等方式部署 SHBuild 输出的文件时，可以调整安装的文件名。</p>
<h3 id="内建规则"><a class="header" href="#内建规则">内建规则</a></h3>
<p>　　遍历扫描目录时，不需要使用领域特定语言的外部脚本，<code>SHBuild</code> 识别名称符合特定模式串的文件。</p>
<p>　　当前支持后缀名区分源文件。</p>
<p>　　文件名符合以下通配符模式的文件视为 C 源文件：</p>
<ul>
<li><code>*.c</code></li>
</ul>
<p>　　文件名符合以下通配符模式的文件视为 C++ 源文件：</p>
<ul>
<li><code>*.cpp</code></li>
<li><code>*.cc</code></li>
<li><code>*.cxx</code></li>
</ul>
<p>　　对以上文件，对应的内建 C 和 C++ 编译器规则分别被调用。其它文件不被视为源文件。</p>
<p>　　和 <code>make</code> 类似，SHBuild 的内建规则依赖文件修改时间(mtime) 判断一个目标是否最新。</p>
<p>　　内建规则使用的编译器和环境变量参见帮助消息。</p>
<h3 id="命令模式"><a class="header" href="#命令模式">命令模式</a></h3>
<p>　　具体使用方式参见帮助消息。</p>
<p>　　另见 <a href="Tools/SHBuild.zh-CN.html#npl-%E6%94%AF%E6%8C%81">NPL 支持</a>。</p>
<h2 id="构建应用程序"><a class="header" href="#构建应用程序">构建应用程序</a></h2>
<p>　　使用 SHBuild 构建应用程序所需的环境和多阶段构建的最后一个阶段的相同。当前和自举时相同，即 stage 2 环境。</p>
<h2 id="其它平台"><a class="header" href="#其它平台">其它平台</a></h2>
<p>　　除构建 stage 1 SHBuild 外，当前未正式支持 Linux 。</p>
<p>　　因为 SHBuild 本身和直接依赖的代码已经保证了可移植性，所以静态链接可以成功。得到的可执行文件除了没有扩展名，用法和前述 MinGW 下相同。</p>
<p>　　使用进一步编译 YFramework 可能会出错，因为 YFramework 中宿主 GUI 支持未在 Linux 上实现。这不影响已经构建的 SHBuild 的可用性。</p>
<p><strong>已知限制</strong> 若系统时间不正确，可能导致冗余的重复构建或无法构建。若文件时间戳无法被正确更新（如编译器或者文件系统实现问题导致无法在命令执行后正确地更新被修改的文件时间，或者不恰当的缓存配置导致修改时间没有立即更新），可能导致冗余的重复构建。</p>
<p>　　当前不支持上述以外的其它平台。</p>
<h2 id="npl-支持"><a class="header" href="#npl-支持">NPL 支持</a></h2>
<p>　　SHBuild 运行 <code>-xcmd,RunNPL</code> 和 <code>-xcmd,RunNPLFile</code> <a href="Tools/SHBuild.zh-CN.html#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F">命令</a>作为 NPLA1 <a href="Tools/../Features/NPL.zh-CN.html#%E5%BD%93%E5%89%8D%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">REPL</a> 和 <a href="Tools/../Development.zh-CN.html#npla1-%E8%84%9A%E6%9C%AC">NPLA1 脚本</a>文件解释器，支持解释 <a href="Tools/../Features/NPL.zh-CN.html">NPLA1</a> 翻译单元。</p>
<p>　　调用方式详见帮助文本。</p>
<p>　　在命令行中指定的 NPLA1 翻译单元为文本文件的名称。当前支持文件头可选的 UTF-8 BOM 。若找到 BOM ，直接跳过继续读取文件内容。在 SHBuild 中不假设文件编码，直接以窄字符流透明地处理。后续编码内容格式按 <a href="Tools/../Features/NPL.zh-CN.html">YFramework 提供的当前实现</a>的方式支持。</p>
<p>　　一般建议使用 UTF-8 + BOM 编码。</p>
<p><strong>原理</strong> 参见<a href="Tools/Development.zh-CN.html#%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6">项目存储库中的文本文件的规则</a>。不带 BOM 的 UTF-8 编码的文本内容可能在不同的运行环境中识别为不同的编码。</p>
<h3 id="应用"><a class="header" href="#应用">应用</a></h3>
<p>　　当前 stage 1 SHBuild 构建 YSLib 库使用<a href="Tools/Scripts.zh-CN.html">脚本</a>已以此方式实现。Shell 脚本调用 stage 1 SHBuild 解释这些脚本，其中进一步调用 stage 1 SHBuild 执行其它构建命令。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="revisionpatcher"><a class="header" href="#revisionpatcher">RevisionPatcher</a></h1>
<p>　　位于 <code>Tools/RevisionPatcher</code> ，是开发过程中用于修改版本工具。</p>
<p>　　当前只支持从标准输入中提取版本号，内容要求为补丁文件。</p>
<p>　　默认使用标准输出打印结果，内容为从补丁文件提取的目标文件名以及新的版本号。</p>
<p>　　不修改任何其它文件。</p>
<p>　　版本号通过补丁内的信息计算。使用规则参见 YSLib 项目文档 <code>doc/ProjectRules.txt</code> 。</p>
<p>　　仅测试了 <code>hg diff</code> 导出的补丁文件。</p>
<h2 id="构建-5"><a class="header" href="#构建-5">构建</a></h2>
<p>　　依赖 YBase 和 YFramework 库，没有特别的构建支持，可以使用 stage 2 <a href="Tools/SHBuild.zh-CN.html"><code>SHBuild</code></a> ，详见 <a href="Tools/Scripts.zh-CN.html">sysroot 安装脚本</a> 。</p>
<h3 id="清单manifest-文件"><a class="header" href="#清单manifest-文件">清单(manifest) 文件</a></h3>
<p>　　因为文件名包含 <code>patch</code> ，<a href="https://github.com/bmatzelle/gow/issues/156">Windows 可能默认要求以管理员权限运行</a> 。安装脚本使用 manifest 文件指定免除此需要。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="revisionpatcher-1"><a class="header" href="#revisionpatcher-1">RevisionPatcher</a></h1>
<p>　　位于 <code>Tools/SXML2XML</code> ，用于转换 <a href="http://okmij.org/ftp/Scheme/xml.html">SXML</a> 文档到 <a href="http://www.w3.org/TR/rec-xml">XML</a> 文档。</p>
<p>　　当前只支持 UTF-8 编码，不支持 XML 命名空间。</p>
<p>　　默认使用标准输出打印结果。</p>
<h2 id="构建-6"><a class="header" href="#构建-6">构建</a></h2>
<p>　　依赖 YBase 和 YFramework 库，没有特别的构建支持，可以使用 stage 2 <a href="Tools/SHBuild.zh-CN.html"><code>SHBuild</code></a> ，详见 <a href="Tools/Scripts.zh-CN.html">sysroot 安装脚本</a> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="projectgenerator"><a class="header" href="#projectgenerator">ProjectGenerator</a></h1>
<p>　　位于 <code>Tools/ProjectGenerator</code> ，用于生成项目文件。</p>
<p>　　当前只支持 UTF-8 编码的 Code::Blocks <code>.cbp</code> 文件。</p>
<p>　　使用标准输出打印结果。</p>
<h2 id="构建-7"><a class="header" href="#构建-7">构建</a></h2>
<p>　　依赖 YBase 和 YFramework 库，没有特别的构建支持，可以使用 stage 2 <a href="Tools/SHBuild.zh-CN.html"><code>SHBuild</code></a> ，详见 <a href="Tools/Scripts.zh-CN.html">sysroot 安装脚本</a> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述-4"><a class="header" href="#概述-4">概述</a></h1>
<p>　　YSLib 项目提供一系列工具脚本。这些脚本主要集中位于 <code>Tools</code> 和 <code>Tools/Scripts</code> 。其余特定局部用途的脚本可能位于其它目录，这些脚本可能依赖版本库内的工具脚本或 YSLib 安装时部署的工具脚本。</p>
<p>　　关于脚本的解释环境和其它一般规则，参见<a href="Tools/../Development.zh-CN.html#%E8%84%9A%E6%9C%AC">关于脚本的开发说明</a>。关于 shell 脚本，同时参见 <a href="Tools/../Development.zh-CN.html#shell-%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E8%A7%84%E7%BA%A6">shell 语言使用规约</a>。</p>
<p>　　本文档附加约定，除非另行指定：</p>
<ul>
<li>公开的 shell 脚本和 NPLA1 脚本被 <a href="Tools/Scripts.zh-CN.html#toolsinstall-sysrootsh"><code>Tools/install-sysroot.sh</code></a> 分别部署到安装路径下的 <code>bin</code> 和 <code>share/NPLA1</code> 目录下。</li>
<li>除<a href="Tools/Scripts.zh-CN.html#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">用于构建选项的环境配置</a>外，提供的 shell 变量可能设置为只读。</li>
<li>脚本引入不具有后缀 <code>_</code> 的名称若不是被导出的变量，可在脚本之间使用，满足关于名称的约束，但不保证接口稳定性。</li>
</ul>
<p><strong>注释</strong> 维护者和开发者需要阅读开发说明，以保持脚本程序符合文档的描述。其中的一些信息（如关于环境变量等运行时环境的描述）也可能提供对脚本的非开发者用户有帮助的说明，作为<a href="Tools/../Run.zh-CN.html">运行环境</a>中说明的补充。</p>
<h1 id="tools"><a class="header" href="#tools">Tools</a></h1>
<p>　　未归类的工具目录。这个目录提供可用于整个项目或非特定子项目的工具，其中包含实现为脚本的工具。</p>
<p>　　工具脚本位于<a href="Tools/Terminology.zh-CN.html#%E7%89%88%E6%9C%AC%E5%BA%93">存储库</a>目录 <code>Tools</code> 及其子目录 <code>Scripts</code> 下。后者的工具脚本在设计上确定为脚本。</p>
<p>　　工具主要用于开发，包括构建和存储库维护。</p>
<p>　　一部分 <code>Scripts</code> 目录下的工具脚本也可被部署到 <a href="Tools/../Sysroot.zh-CN.html">Sysroot</a> 。在 <a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 2 SHBuild</a> 安装后运行的脚本可依赖安装的 Sysroot 实例的文件系统布局。支持维护存储库的开发脚本应保证在此之前（不依赖 Sysroot 的实例或仅依赖构建 <a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 1</a> 后可用的有限环境）可用。</p>
<h2 id="环境配置-1"><a class="header" href="#环境配置-1">环境配置</a></h2>
<p>　　一些环境变量可能被可选地在外部环境或在调用脚本的其它脚本中指定。若没有被指定为非空值，则可被特定上下文按需初始化。初始化后的值可能被断言非空，断言失败则非正常地退出脚本。</p>
<p>　　这些变量可能指定外部环境的配置。</p>
<p>　　在<a href="Tools/../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">开发文档中的环境变量</a>的基础上，以下各节补充指定适用于多个脚本的变量。在对应的脚本的文档中可能补充描述。</p>
<p>　　一些环境变量具有特定的命名模式：</p>
<ul>
<li><a href="Tools/../Development.zh-CN.html">开发文档</a>中的环境变量具有相同前缀的外部扩展环境变量：
<ul>
<li>具有前缀 <code>SHBuild_</code> ：可能适用于所有构建脚本流程。
<ul>
<li><strong>注释</strong> 具有前缀 <code>SHBuild_S1_</code> 和 <code>SHBuild_S2_</code> 的名称不指定环境变量，而是函数名称。</li>
</ul>
</li>
<li>具有前缀 <code>YSLib_</code> ：指定和 YSLib 库相关的环境和配置。</li>
<li><strong>注释</strong> 这些前缀的变量通常在开发文档中指定。仅在个别脚本中适用或不在 shell 脚本（而仅在 <a href="Tools/../Development.zh-CN.html#npla1-%E8%84%9A%E6%9C%AC">NPLA1 脚本</a>）适用时，在本文档指定扩展。</li>
</ul>
</li>
<li>具有前缀 <code>SS_</code> ：<a href="Tools/Scripts.zh-CN.html#%E5%85%AC%E5%85%B1%E6%9E%84%E5%BB%BA%E9%85%8D%E7%BD%AE%E5%8F%98%E9%87%8F">公共构建配置变量</a>。
<ul>
<li><strong>注释</strong> 环境变量名称中的 <code>SS</code> 前缀表示 <a href="Tools/SHBuild.zh-CN.html">SHBuild</a> 设置(settings) 。</li>
</ul>
</li>
<li>具有前缀 <code>S1_</code> ：在 <a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 1 SHBuild</a> 构建流程中作用的变量。
<ul>
<li><strong>注释</strong> 环境变量名称中的 <code>S1</code> 前缀表示 Stage 1 。</li>
</ul>
</li>
<li>具有前缀 <code>CFLAGS</code> 、<code>CXXFLAGS</code> 和 <code>LDFLAGS</code> 等：指定构建工具使用的选项。
<ul>
<li><strong>注释</strong> 在 shell 环境中这主要通过 <a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-common-optionssh"><code>Tools/Scripts/SHBuild-common-options.sh</code></a> 配置。</li>
</ul>
</li>
</ul>
<h3 id="公共构建配置变量"><a class="header" href="#公共构建配置变量">公共构建配置变量</a></h3>
<p>　　以下配置行为的环境变量可在多个构建脚本中被支持且具有一致的含义：</p>
<ul>
<li><code>SS_DebugEnv</code> 启用脚本执行时系统环境相关的调试输出。</li>
<li><code>SS_DirectExtract</code> 启用直接解压缩。</li>
<li><code>SS_NoParallel</code> 不使用并行命令调用。</li>
<li><code>SS_Offline</code> 离线模式：不使用互联网。</li>
<li><code>SS_Verbose</code> 启用详细消息输出。</li>
</ul>
<p>　　除非另行指定，这些变量的值当且仅当非空表示启用特性。</p>
<p>　　具体作用在具体脚本的说明中详细描述。</p>
<h3 id="stage-1-共享变量"><a class="header" href="#stage-1-共享变量">Stage 1 共享变量</a></h3>
<p>　　以下变量影响 stage 1 的多个构建脚本的行为。</p>
<ul>
<li><code>S1_BuildConf</code> 内部配置名称。
<ul>
<li>通常指定不同的值对应不共享的构建配置组合。</li>
<li><strong>注释</strong> 可影响默认构建目录。</li>
</ul>
</li>
<li><code>S1_BuildDir</code> Stage 1 SHBuild 构建和输出文件目录路径。</li>
<li><code>S1_CacheFile</code> Stage 1 缓存文件名。</li>
<li><code>S1_CacheMode</code> Stage 1 缓存模式。
<ul>
<li>可选模式是如下子模式的组合：
<ul>
<li>读模式：加载缓存时，无条件忽略或不忽略缓存之一。</li>
<li>默认写模式：保存缓存且缓存文件不存在时，不写入、写入空文件或写入缓存之一。</li>
<li>覆盖写模式：保存缓存且缓存文件存在时，不写入、写入空文件、覆盖写入缓存或清除缓存文件之一。</li>
</ul>
</li>
<li>组合模式如下：
<ul>
<li>加载缓存时忽略：
<ul>
<li>默认不写入：
<ul>
<li><code>disable</code> 禁用缓存：不覆盖写入。</li>
<li><code>reset</code> 复位为空文件：覆盖写入空文件。</li>
<li><code>update</code> 只更新：覆盖写入。</li>
<li><code>clean</code> 清理：清除缓存文件。</li>
</ul>
</li>
<li>默认写入空文件：
<ul>
<li><code>touch</code> 只创建空文件：不覆盖写入。</li>
<li><code>mark</code> 标记：覆盖写入空文件。</li>
</ul>
</li>
<li>默认写入：
<ul>
<li><code>create</code> 只创建新文件：不覆盖写入。</li>
<li><code>writeonly</code> 只写：覆盖写入。</li>
</ul>
</li>
</ul>
</li>
<li>加载缓存时不忽略：
<ul>
<li>默认不写入：
<ul>
<li><code>readonly</code> 只读：不覆盖写入。</li>
<li><code>clear</code> 清除：覆盖写入空文件。</li>
<li><code>writeback</code> 写回：覆盖写入。</li>
<li><code>purge</code> 清洗：清除缓存文件。</li>
</ul>
</li>
<li>默认写入空文件：
<ul>
<li><code>move</code> 转移：不覆盖写入。</li>
<li><code>absorb</code> 吸收：覆盖写入空文件。</li>
</ul>
</li>
<li>默认写入：
<ul>
<li><code>keep</code> 保持：不覆盖写入。</li>
<li><code>force</code> 强制：覆盖写入。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>别名：
<ul>
<li><code>disabled</code> 同 <code>disable</code> 。</li>
<li><code>false</code> 同 <code>disable</code> 。</li>
<li><code>ignore</code> 同 <code>disable</code> 。</li>
<li><code>n</code> 同 <code>disable</code> 。</li>
<li><code>no</code> 同 <code>disable</code> 。</li>
<li><code>none</code> 同 <code>disable</code> 。</li>
<li><code>once</code> 同 <code>purge</code> 。</li>
<li><code>overwrite</code> 同 <code>force</code> 。</li>
<li><code>skip</code> 同 <code>disable</code> 。</li>
<li><code>writethrough</code> 同 <code>update</code> 。</li>
<li>其它值的含义同未设置此变量，默认启用缓存，同 <code>keep</code> ：加载和保存缓存，但不覆盖已有缓存。</li>
</ul>
</li>
</ul>
</li>
<li>前缀为 <code>S1_Cached_</code> 的变量是可在外部指定的缓存项。作为配置项的变量支持以下值：
<ul>
<li><code>disable</code> 禁用：不使用。</li>
<li><code>disabled</code> 同 <code>disable</code> 。</li>
<li><code>false</code> 同 <code>disable</code> 。</li>
<li><code>n</code> 同 <code>disable</code> 。</li>
<li><code>no</code> 同 <code>disable</code> 。</li>
<li><code>none</code> 同 <code>disable</code> 。</li>
<li>其它非空值视为 <code>true</code> ，指定启用库：使用库配置参数。</li>
<li>空值（未缓存）：自动检查可用性并确定配置项的变量值，之后可写入缓存。</li>
</ul>
</li>
<li><code>S1_DistDir</code> Stage 1 SHBuild 可执行程序目录路径。</li>
<li><code>S1_SHBuild</code> Stage 1 SHBuild 可执行文件路径。
<ul>
<li><strong>注释</strong> Win32 平台实际的可执行文件可隐含后缀 <code>.exe</code> 。</li>
</ul>
</li>
</ul>
<p>　　具体作用可在具体脚本的说明中详细描述。</p>
<h3 id="版本控制系统支持"><a class="header" href="#版本控制系统支持">版本控制系统支持</a></h3>
<p>　　部分脚本使用以下方式检查和识别版本控制系统。</p>
<p>　　以下环境变量提示使用 Mercurial 或 Git ：</p>
<ul>
<li>若<a href="Tools/../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量 <code>SHBuild_VCS_hg</code></a> 非空，则检查 <code>hg</code> 命令可用。</li>
<li>否则，若<a href="Tools/../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量 <code>SHBuild_VCS_git</code></a> 非空，则检查 <code>git</code> 命令可用。</li>
<li>否则，依次检查 <code>hg</code> 和 <code>git</code> 命令可用，若 <code>hg</code> 可用则不再检查 <code>git</code> 。</li>
</ul>
<p>　　命令可用需要满足以下条件：</p>
<ul>
<li>被检查的命令应在 <code>$PATH</code> 中。
<ul>
<li>若在 Windows 中使用 shell ，可能需要提前设置环境以确保继承环境变量。</li>
<li><strong>注意</strong> MSYS2 提供的 <code>mercurial</code> 包的可执行文件是脚本而不是可执行文件，不被 NPLA1 脚本调用的 Windows 命令行支持。</li>
<li><strong>注释</strong> 不使用 <code>HG</code> 环境变量，因为可能设置为不被支持的 <code>hg</code> 程序路径。事实上，MSYS2 的包 <code>mercurial</code> 安装到 <code>/etc/profile.d/mercurial.sh</code> 设置 <code>HG</code> 为脚本，覆盖从其它位置继承的 <code>hg.exe</code> 。</li>
</ul>
</li>
<li>且当前工作目录求在对应的版本库中，同时确定仓库的顶层目录路径。
<ul>
<li>对 Git ，要求存在工作区。</li>
</ul>
</li>
</ul>
<h2 id="toolsinstall-sysrootsh"><a class="header" href="#toolsinstall-sysrootsh">Tools/install-sysroot.sh</a></h2>
<p>　　Sysroot 安装脚本。用于直接构建和部署基础环境。</p>
<p>　　构建时会调用 <code>Tools/Scripts</code> 目录下的脚本，按需构建 <a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 1 SHBuild</a> 后间接调用 <code>SHBuild</code> 构建 <code>YBase</code> 和 <code>YFramework</code> 的静态库和动态库，再构建依赖于动态库的 <code>SHBuild</code> ：</p>
<ul>
<li>按需初始化<a href="Tools/../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">变量 <code>SHBuild_ToolDir</code></a> 。</li>
<li>包含脚本 <a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-commonsh"><code>Tools/Scripts/SHBuild-common.sh</code></a> 以按需初始化确定默认构建位置依赖的环境变量。</li>
<li>设置<a href="Tools/Scripts.zh-CN.html#stage-1-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">变量 <code>S1_BuildConf</code></a> 的值，并调用<a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_s1_initconf">函数 <code>SHBuild_S1_InitConf</code></a> 初始化必要的变量，以允许判断是否在预期位置存在 stage 1 SHBuild 。</li>
<li>按需构建 stage 1 SHBuild 。</li>
<li>间接调用 stage 1 SHBuild 构建 <code>YBase</code> 和 <code>YFramework</code> 的静态库和动态库。</li>
<li>再构建依赖于动态库的 <code>SHBuild</code> 。</li>
</ul>
<p>　　构建使用<a href="Tools/../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">变量 <code>SHBuild_BuildDir</code></a> 指定的路径作为中间输出目录。</p>
<p><strong>注释</strong> 另见 <a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-bootstrapsh"><code>Tools/Scripts/SHBuild-bootstrap.sh</code></a> 。</p>
<p>　　构建脚本同时可安装文件，完成 Sysroot 所需文件的部署。安装的起始目标位置由称为<strong>安装路径</strong>的目录路径指定，其字符串形式去除结尾分隔符的目录文件名为<strong>安装路径前缀</strong>。安装过程在必要时可创建 Sysroot 根目录、安装路径指定的目录及其子目录。安装路径的确定方式详见以下的使用方式。</p>
<p>　　部署时使用 stage 1 SHBuild 更新文件和目录，在必要时创建符号链接或硬链接，若失败则改为普通复制。仅当被部署的文件为中间目标启用硬链接，以免后续操作意外覆盖源文件。注意在 Windows 上创建符号链接可能因为权限不足失败，取决于用户和组策略。建议使用系统管理权限运行以避免可能的权限问题。</p>
<h3 id="基本使用"><a class="header" href="#基本使用">基本使用</a></h3>
<p>　　脚本接受在 stage 2 使用的 <code>SHBuild</code> 命令行中的选项为命令行参数，如</p>
<pre><code class="language-shell">Tools/install-sysroot.sh -xj,2
</code></pre>
<p>　　使用 2 个并行线程构建。</p>
<p>　　脚本也支持变量配置构建使用的路径，默认相当于使用如下 bash 命令配置变量：</p>
<pre><code class="language-bash">: ${SHBuild_SysRoot:="$YSLib_BaseDir/sysroot"}
: ${SHBuild_BuildDir:="$YSLib_BaseDir/build/$(SHBuild_GetBuildName)"}
</code></pre>
<p>　　其中：</p>
<ul>
<li><a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_preparebuild"><code>SHBuild_PrepareBuild</code></a> 是 <code>Tools/Scripts/SHBuild-common.sh</code> 中的函数。</li>
<li>各个变量参见<a href="Tools/../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">开发文档中的环境变量的说明</a>。</li>
</ul>
<p>　　在 stage 1 SHBuild 构建调用 NPLA1 脚本 <code>Tools/Scripts/SHBuild-YSLib*.txt</code> ，调用方式和接受的配置（构建目标等）、具体默认设置和注意事项见对应 shell 脚本的文档相关章节。</p>
<h1 id="toolsscripts"><a class="header" href="#toolsscripts">Tools/Scripts</a></h1>
<p>　　这个目录的脚本可用于整个项目或项目核心部分的构建工具使用。</p>
<p>　　当前有以下脚本忽略重复的 <code>.</code> 或 <code>source</code> 命令：</p>
<ul>
<li>SHBuild-common.sh</li>
</ul>
<p>　　以前缀 <code>SHBuild_</code> 起始的名称保留使用。</p>
<p>　　其中，前缀 <code>SHBuild_Env_</code> 总是表示环境配置的只读变量名。这些变量若未被指定，可在第一次访问时（具体时机未指定）初始化为：</p>
<ul>
<li><code>SHBuild_Env_Arch</code> ：参见函数 <code>SHBuild_CheckUName</code> 。</li>
<li><code>SHBuild_Env_OS</code> ：参见函数 <code>SHBuild_CheckUName</code> 。</li>
<li><code>SHBuild_Env_TempDir</code> ：缓存函数 <code>SHBuild_GetTempDir</code> 的输出。</li>
<li><code>SHBuild_Env_uname</code> ：缓存命令 <code>uname</code> 的输出。</li>
<li><code>SHBuild_Env_uname_m</code> ：缓存命令 <code>uname -m</code> 的输出。</li>
</ul>
<h2 id="toolsscriptsgenerateprojectssh"><a class="header" href="#toolsscriptsgenerateprojectssh">Tools/Scripts/GenerateProjects.sh</a></h2>
<p>　　调用 <a href="Tools/ProjectGenerator.zh-CN.html">ProjectGenerator</a> 生成项目文件。</p>
<p>　　当前支持生成所有 <code>.cbp</code> 文件。</p>
<p>　　要求可使用 <code>hg</code> 或 <code>git</code> 命令取版本库根目录，否则不保证输出到正确的路径。</p>
<h3 id="变量-projectgenerator"><a class="header" href="#变量-projectgenerator">变量 ProjectGenerator</a></h3>
<p>　　调用 RevisionPatcher 的命令。默认直接使用 <code>type -P ProjectGenerator</code> 的结果，一般要求可执行文件在环境变量 <code>PATH</code> 中。</p>
<h2 id="toolsscriptspatchrevisionsh"><a class="header" href="#toolsscriptspatchrevisionsh">Tools/Scripts/PatchRevision.sh</a></h2>
<p>　　开发过程中使用 <a href="Tools/RevisionPatcher.zh-CN.html">RevisionPatcher</a> 维护源文件中版本号的脚本。</p>
<p>　　当前只支持 Mercurial 或 Git 版本库的已添加或修改的未提交文件。</p>
<p>　　使用的版本控制系统会被检查。通过检查的条件、确定使用的版本控制的机制及支持的控制检查的环境变量参见<a href="Tools/Scripts.zh-CN.html#%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E6%94%AF%E6%8C%81">版本控制系统支持</a>。</p>
<p>　　若检查都失败，则脚本出错，不再继续运行。</p>
<p>　　脚本利用 <code>hg</code> 或 <code>git</code> 命令把未提交的这些修改导出为补丁备份到版本库根目录的 <code>bak.patch</code> ，然后使用这些内容调用 RevisionPatcher 取得文件和对应的新的版本号列表，最后使用 <code>sed</code> 查找对应文件并更新版本号。</p>
<p>　　脚本依赖 <code>sed</code> 命令。使用的 <code>sed</code> 应支持 <code>-b -i</code> 选项。可使用 Linux 或 MSYS2 的发行版中的 sed 4.8 程序。</p>
<p><strong>警告</strong> 某些 Win32 版本的 <code>sed</code> ，如 MSYS2 MinGW64 sed 4.4 可能损坏文本文件的行尾。有些替代版本可能解决<a href="https://stackoverflow.com/questions/4652652">这一问题</a>。</p>
<p><strong>注释</strong> 当前不检查特定版本 <code>sed</code> 对选项的支持。</p>
<p>　　若没有找到 <code>\version r</code> 模式的版本号前缀则忽略写入版本号。写入的版本号不影响换行符。</p>
<p><strong>注释</strong> 这个脚本可用于自动化。例如，在 Mercurial 仓库的 <code>hgrc</code> 的 <code>[hooks]</code> 节中添加 <code>precommit.PatchRevision = bash Tools/Scripts/PatchRevision.sh</code> 可在每次提交前调用这个脚本。在 YSLib 中，仅在主分支版本中启用。</p>
<h3 id="变量-patchbegin"><a class="header" href="#变量-patchbegin">变量 PatchBegin</a></h3>
<p>　　匹配版本号的起始行，应为一个表示行数的正整数。默认值为 <code>"1"</code> 。</p>
<h3 id="变量-patchend"><a class="header" href="#变量-patchend">变量 PatchEnd</a></h3>
<p>　　匹配版本号的结束行，应为一个表示行数的正整数。默认值为 <code>"20"</code> 。</p>
<h3 id="变量-revisionpatcher"><a class="header" href="#变量-revisionpatcher">变量 RevisionPatcher</a></h3>
<p>　　调用 RevisionPatcher 的命令。默认值为 <code>type -P RevisionPatcher</code> 的结果。</p>
<p><strong>注释</strong> 可执行文件可以在环境变量 <code>PATH</code> 中。</p>
<h3 id="变量-patchhg"><a class="header" href="#变量-patchhg">变量 PatchHg</a></h3>
<p>　　指定使用 Mercurial 。参见以上确定使用 Mercurial 或 Git 的说明。</p>
<h3 id="变量-patchgit"><a class="header" href="#变量-patchgit">变量 PatchGit</a></h3>
<p>　　指定使用 Git 。参见以上确定使用 Mercurial 或 Git 的说明。</p>
<h2 id="toolsscriptsshbuild-bootstrapsh"><a class="header" href="#toolsscriptsshbuild-bootstrapsh">Tools/Scripts/SHBuild-bootstrap.sh</a></h2>
<p>　　编译 <a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 1 SHBuild</a> 时被包含的脚本。</p>
<p>　　脚本执行构建配置的环境初始化。其中指定静态链接需要依赖的 YSLib 源文件以及头文件路径等的必要变量。</p>
<p>　　脚本按需设置<a href="Tools/Scripts.zh-CN.html#stage-1-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">变量 <code>S1_BuildConf</code></a> 的值，以确保部分变量之后在包含 <a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-yslibsh"><code>Tools/Scripts/SHBuild-YSLib.sh</code></a> 时能被按需初始化。默认值为 <code>stage1</code> 。</p>
<ul>
<li><strong>注释</strong> 有的脚本如 <a href="Tools/Scripts.zh-CN.html#toolsinstall-sysrootsh"><code>Tools/install-sysroot.sh</code></a> 在此之前应已初始化部分变量。其它脚本可能依赖这里的初始化。</li>
</ul>
<p>　　包含 <code>Tools/Scripts/SHBuild-YSLib.sh</code> 后，<a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-yslibsh">被缓存的变量</a>的值可首先从持久存储的缓存文件中获取。</p>
<p>　　以下在这个脚本中可被使用的 stage 1 共享变量属于被缓存的变量：</p>
<ul>
<li><code>S1_Cached_quadmath</code> 支持使用 quadmath ，作为<a href="Tools/Scripts.zh-CN.html#stage-1-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">配置项</a>。</li>
</ul>
<p>　　配置结束后，通过调用<a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_savecache">函数 SHBuild_SaveCache</a>写入所有被缓存的变量。</p>
<h2 id="toolsscriptsshbuild-buildsh"><a class="header" href="#toolsscriptsshbuild-buildsh">Tools/Scripts/SHBuild-build.sh</a></h2>
<p>　　编译 <a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 1 SHBuild</a> 的脚本。</p>
<p>　　以下<a href="Tools/Scripts.zh-CN.html#%E5%85%AC%E5%85%B1%E6%9E%84%E5%BB%BA%E9%85%8D%E7%BD%AE%E5%8F%98%E9%87%8F">公共构建配置变量</a>影响脚本的特定行为：</p>
<ul>
<li><code>SS_NoParallel</code> 的作用当前包括：
<ul>
<li>不检查并行命令的可用性。</li>
<li>不使用并行命令构建。</li>
</ul>
</li>
<li><code>SS_Verbose</code> 的作用当前包括：
<ul>
<li>调用命令前回显。</li>
</ul>
</li>
</ul>
<p>　　使用变量 <code>SHBuild_Output</code> 指定输出路径。默认值为 <code>SHBuild</code> ，即在当前工作目录下生成名为 <code>SHBuild</code> 的可执行文件（视宿主平台不同可能带后缀如 Win32 带 <code>.exe</code> ）。</p>
<p>　　调用函数 <code>SHBuild_CheckPCH</code> 检查预编译头：若变量 <code>SHBuild_NoPCH</code> 非空则跳过预编译头，否则使用预编译头包含标准库头。预编译的头文件目标由 YBase 下的 <code>stdinc.h</code> ，之后构建时包含预编译头路径为 <code>$SHBuild_PCH_stdinc_h</code> 。后者的默认路径为当前工作目录下的 <code>stdinc.h</code> 。</p>
<p>　　因为升级或更换编译器和/或选项，可导致预编译头文件（ <code>.gch</code> 文件）不和生成的环境匹配而不被识别。</p>
<p><strong>注意</strong> 预编译头文件不保证对不同的操作系统版本兼容，参见<a href="Tools/../Prerequisitions.zh-CN.html">先决条件</a>中 PC(Win32) 平台关于操作系统版本的说明。</p>
<p>　　不被识别的预编译头文件通常：</p>
<ul>
<li>可引起编译器警告，并忽略预编译头文件。
<ul>
<li>若仅需避免产生警告，确保编译器命令行使用恰当选项，如添加 <code>-Wno-invalid-pch</code> 。</li>
</ul>
</li>
<li>可能引起无法构建的错误。</li>
</ul>
<p>　　一般仍然需要避免使用不匹配的预编译头文件。若无法保证预编译头文件和使用的工具链和选项匹配：</p>
<ul>
<li>可设置变量 <code>SHBuild_NoPCH</code> 的值非空以跳过预编译头文件的使用。</li>
<li>可以手动删除生成的预编译头文件。在没有设置变量 <code>SHBuild_NoPCH</code> 的情形下构建通常会默认自动生成。
<ul>
<li><strong>注释</strong> 具体的支持和生成预编译头文件的位置参见具体构建目标的说明，如 <a href="Tools/../Sysroot.zh-CN.html#%E6%9E%84%E5%BB%BA%E4%B8%AD%E9%97%B4%E6%96%87%E4%BB%B6">Sysroot</a> 。</li>
</ul>
</li>
</ul>
<p><strong>已知缺陷</strong> 构建时不自动更新预编译头。</p>
<p>　　除非环境变量 <code>SS_NoParallel</code> 的值非空，构建前可选地检查可用的并行命令。支持如下：</p>
<ul>
<li>支持 <a href="https://www.gnu.org/software/parallel/">GNU parallel</a> 命令 <code>parallel</code> 。</li>
<li>不支持 <a href="https://manpages.debian.org/testing/moreutils/parallel.1.en.html">moreutils <code>parallel</code></a> 且 <code>parallel</code> 命令的可用性会忽略。</li>
<li>不对并行数指定选项。
<ul>
<li><strong>原理</strong> 默认应已能充分使用宿主环境的计算资源。</li>
</ul>
</li>
</ul>
<h2 id="toolsscriptsshbuild-buildappsh"><a class="header" href="#toolsscriptsshbuild-buildappsh">Tools/Scripts/SHBuild-BuildApp.sh</a></h2>
<p>　　应用程序构建脚本。这个脚本被保留，不再具有实际功能。</p>
<p>　　<strong>这个脚本是公开的工具</strong>，被安装脚本部署。</p>
<h2 id="toolsscriptsshbuild-buildpkgsh"><a class="header" href="#toolsscriptsshbuild-buildpkgsh">Tools/Scripts/SHBuild-BuildPkg.sh</a></h2>
<p>　　包构建脚本。当前只支持构建应用程序，具体步骤和使用的参数参见 <a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-buildapptxt"><code>Tools/Script/SHBuild-BuildApp.txt</code></a> 。</p>
<p>　　<strong>这个脚本是公开的工具</strong>，被安装脚本部署。</p>
<h2 id="toolsscriptsshbuild-commonsh"><a class="header" href="#toolsscriptsshbuild-commonsh">Tools/Scripts/SHBuild-common.sh</a></h2>
<p>　　被应用程序构建脚本包含的脚本，提供公共基础功能。</p>
<p>　　<strong>这个脚本是公开的工具</strong>，被安装脚本部署。</p>
<p><strong>注意</strong> 这个脚本包含 <code>INC_SHBuild_common</code> 守卫变量检查，默认重复包含只被执行一次。</p>
<h3 id="函数-shbuild_popd"><a class="header" href="#函数-shbuild_popd">函数 SHBuild_Popd</a></h3>
<p>　　同 <code>bash</code> 内建 <code>popd</code> 但不回显标准输出。</p>
<h3 id="函数-shbuild_pushd"><a class="header" href="#函数-shbuild_pushd">函数 SHBuild_Pushd</a></h3>
<p>　　同 <code>bash</code> 内建 <code>pushd</code> 但不回显标准输出。</p>
<h3 id="函数-shbuild_put"><a class="header" href="#函数-shbuild_put">函数 SHBuild_Put</a></h3>
<p>　　使用 <code>printf</code> 输出非格式字符串。</p>
<p>　　使用 <code>$*</code> 形式传递字符串，此时 <code>IFS</code> 是默认值。</p>
<h3 id="函数-shbuild_puts"><a class="header" href="#函数-shbuild_puts">函数 SHBuild_Puts</a></h3>
<p>　　使用 <code>printf</code> 输出非格式的换行的字符串。</p>
<p>　　使用 <code>$*</code> 形式传递字符串，此时 <code>IFS</code> 是默认值。</p>
<p>　　换行符由变量 <code>SHBuild_EOL</code> 指定。若值为空，则首先初始化为全局只读变量。当前默认值通过检查 <code>$COMSPEC</code> 是否定义，以确保 Windows 环境（包括 MSYS ）使用 CR+LF ，其它情况使用 LF 。</p>
<p>　　这个函数在可用时可用于代替 <code>echo</code> ，以取得对环境更好的适应性。</p>
<p><strong>注意</strong> 具体的检查逻辑实现可能在以后改变。</p>
<h3 id="函数-shbuild_puts_err"><a class="header" href="#函数-shbuild_puts_err">函数 SHBuild_Puts_Err</a></h3>
<p>　　同<a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_puts">函数 <code>SHBuild_Puts</code></a>，但重定向标准输出到标准错误。</p>
<h3 id="函数-shbuild_puts_exit"><a class="header" href="#函数-shbuild_puts_exit">函数 SHBuild_Puts_Exit</a></h3>
<p>　　第一参数指定错误码，以之后的参数调用<a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_puts_exit">函数 <code>SHBuild_Puts_Exit</code></a>，然后以错误码退出。</p>
<h3 id="函数-shbuild_puts_verbose"><a class="header" href="#函数-shbuild_puts_verbose">函数 SHBuild_Puts_Verbose</a></h3>
<p>　　当<a href="Tools/Scripts.zh-CN.html#%E5%85%AC%E5%85%B1%E6%9E%84%E5%BB%BA%E9%85%8D%E7%BD%AE%E5%8F%98%E9%87%8F">变量 <code>SS_Verbose</code></a> 的值非空时，调用<a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_puts">函数 <code>SHBuild_Puts</code></a>。</p>
<h3 id="函数-shbuild_assertnonempty"><a class="header" href="#函数-shbuild_assertnonempty">函数 SHBuild_AssertNonempty</a></h3>
<p>　　断言第一参数为名称的变量非空，否则显示出错并退出。</p>
<p>　　使用 <code>eval</code> 实现。</p>
<h3 id="函数-shbuild_checkedcall"><a class="header" href="#函数-shbuild_checkedcall">函数 SHBuild_CheckedCall</a></h3>
<p>　　检查第一参数为名称的命令存在，否则显示出错并退出。</p>
<p>　　使用 <code>hash</code> 实现以优化性能。</p>
<h3 id="函数-shbuild_checkedcallsilent"><a class="header" href="#函数-shbuild_checkedcallsilent">函数 SHBuild_CheckedCallSilent</a></h3>
<p>　　同 SHBuild_CheckedCall ，但不显示错误外的标准输出。</p>
<h3 id="函数-shbuild_initreadonly"><a class="header" href="#函数-shbuild_initreadonly">函数 SHBuild_InitReadonly</a></h3>
<p>　　断言第一参数为名称的变量非空，若空则使用 <code>eval</code> 对后续求值并初始化第一参数指定的只读变量。</p>
<p>　　初始化时在当前 shell 中求值初值。</p>
<p>　　若发生初始化且<a href="Tools/Scripts.zh-CN.html#%E5%85%AC%E5%85%B1%E6%9E%84%E5%BB%BA%E9%85%8D%E7%BD%AE%E5%8F%98%E9%87%8F">变量 <code>SS_Verbose</code></a> 的值非空，则在标准输出中显示。</p>
<p><strong>已知限制</strong> 当前实现使用临时文件 <code>/tmp/InitReadonly</code> 暂存作为初值的调用结果。需确保这个临时文件所在的目录和这个文件可写。</p>
<p><strong>原理</strong></p>
<p>　　保证当前 shell 中求值允许初值中调用可能修改当前 shell 环境的 shell 函数。这使一个 <code>SHBuild_InitReadonly</code> 调用中，间接的嵌套调用可使用先前已通过同一个调用者初始化的变量。</p>
<h3 id="函数-shbuild_2m"><a class="header" href="#函数-shbuild_2m">函数 SHBuild_2m</a></h3>
<p>　　接受 1 个表示路径的参数，调用 <code>cygpath</code> 转换路径到 Windows 混合风格路径。</p>
<p>　　当 <code>cygpath</code> 不存在时返回原路径。</p>
<h3 id="函数-shbuild_2u"><a class="header" href="#函数-shbuild_2u">函数 SHBuild_2u</a></h3>
<p>　　接受 1 个表示路径的参数。</p>
<p>　　调用 <code>cygpath</code> 转换 Windows 路径到 UNIX 路径。</p>
<p>　　当 <code>cygpath</code> 不存在时返回原路径。</p>
<h3 id="函数-shbuild_echoescape"><a class="header" href="#函数-shbuild_echoescape">函数 SHBuild_EchoEscape</a></h3>
<p>　　当标准输出使用终端时调用 <code>echo -ne</code> 输出参数指定的 ANSI 转义序列。</p>
<p><strong>已知缺陷</strong> 不检查 <code>$TERM</code> 支持。</p>
<h3 id="函数-shbuild_echostring"><a class="header" href="#函数-shbuild_echostring">函数 SHBuild_EchoString</a></h3>
<p>　　接受 2 个参数，输出转义序列指定格式的内容，包含以下步骤：</p>
<ul>
<li>使用 <code>SHBuild_EchoEscape</code> 输出第二参数指定的转义序列。</li>
<li>使用 <code>SHBuild_Put</code> 输出第一参数的内容。</li>
<li>使用 <code>SHBuild_EchoEscape</code> 输出复位格式的转义序列。</li>
</ul>
<h3 id="函数-shbuild_echovar"><a class="header" href="#函数-shbuild_echovar">函数 SHBuild_EchoVar</a></h3>
<p>　　接受 2 个参数 <code>x</code> 和 <code>y</code> ，以特定颜色显示为 <code>x = "$y"</code> 的形式，其中 <code>$y</code> 是 <code>y</code> 的值。</p>
<p>　　第二参数一般是字符串。</p>
<h3 id="函数-shbuild_echovar_n"><a class="header" href="#函数-shbuild_echovar_n">函数 SHBuild_EchoVar_N</a></h3>
<p>　　接受 1 个参数 <code>x</code> ，调用 <code>SHBuild_EchoVar</code> 显示为 <code>x = $x</code> 的形式。</p>
<p>　　右侧求值时会替换参数中的 <code>.</code> 为 <code>_</code> 。</p>
<p>　　参数一般是字符串。</p>
<h3 id="函数-shbuild_echovara"><a class="header" href="#函数-shbuild_echovara">函数 SHBuild_EchoVarA</a></h3>
<p>　　接受 2 个参数 <code>x</code> 和 <code>y</code> ，以特定颜色显示为 <code>x = ($y)</code> 的形式，其中 <code>$y</code> 是 <code>y</code> 的值。</p>
<p>　　第二参数一般是数组。</p>
<h3 id="函数-shbuild_echovara_n"><a class="header" href="#函数-shbuild_echovara_n">函数 SHBuild_EchoVarA_N</a></h3>
<p>　　接受 1 个参数 <code>x</code> ，调用 <code>SHBuild_EchoVarA</code> 显示为 <code>x = $x</code> 的形式。</p>
<p>　　右侧求值时会替换参数中的 <code>.</code> 为 <code>_</code> 。</p>
<p>　　参数一般是数组。</p>
<h3 id="函数-shbuild_checkuname"><a class="header" href="#函数-shbuild_checkuname">函数 SHBuild_CheckUName</a></h3>
<p>　　调用 <code>SHBuild_CheckedCall</code> 按需初始化只读变量 <code>SHBuild_Env_OS</code> 和 <code>SHBuild_Env_Arch</code> 的值。</p>
<p>　　变量 <code>SHBuild_Env_OS</code> 的值通过分类系统的值（一般即 <code>SHBuild_Env_uname</code> 的值）标识操作系统：</p>
<ul>
<li><code>OS_X</code> ：输入匹配 <code>*Darwin*</code> ，用于标识 OS X 系统。</li>
<li><code>Win32</code> ：输入匹配 <code>*MINGW*</code> 或 <code>*MSYS*</code> ，用于标识 Windows 系统。</li>
<li><code>Linux</code> ：输入匹配 <code>*Linux*</code> ，用于标识 Linux 系统。</li>
<li><code>unknown</code> ：不支持的系统。</li>
</ul>
<p>　　变量 <code>SHBuild_Env_Arch</code> 的值通过分类输入的处理器体系结构的值（一般即 <code>SHBuild_Env_uname_m</code> 的值）标识体系结构：</p>
<ul>
<li><code>x86_64</code> ：输入匹配 <code>x86_64</code> 或 <code>i*86-64</code> 。</li>
<li><code>i*86</code> ：输入匹配 <code>i*86</code> ，使用原值。</li>
<li><code>aarch64</code> ：输入是 <code>aarch64</code> 。</li>
<li><code>unknown</code> ：不支持的体系结构。</li>
</ul>
<p>　　若同时指定环境变量 <code>SHBuild_Env_Arch</code> 和 <code>SHBuild_Env_OS</code> ，不进行<a href="Tools/../Prerequisitions.zh-CN.html">自动环境检测</a>，不依赖 <code>uname</code> 。</p>
<h3 id="函数-shbuild_gettempdir"><a class="header" href="#函数-shbuild_gettempdir">函数 SHBuild_GetTempDir</a></h3>
<p>　　取临时目录的路径。</p>
<p>　　依次检查以下环境变量的值，若非空则作为结果：</p>
<ul>
<li><code>TMPDIR</code></li>
<li><code>TEMP</code></li>
<li><code>TMP</code></li>
</ul>
<p>　　若这些环境变量都没有非空值，则使用经过 <code>SHBuild_2m</code> 转换的 <code>/tmp</code>（被 <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap10.html#tag_10_01">POSIX.1 要求支持</a>）作为结果。</p>
<p><strong>注意</strong> 以上过程在所有平台上都一致。这是自适应环境的基本接口，因此不对环境变量的值的合法性进行判断。若结果不表示一个可访问的目录，在访问以此构造的文件路径时可能引发错误。应用程序一般需自行检查或保证使用的环境中这些路径可访问。</p>
<p><strong>说明</strong> 以上检查中，支持的环境变量符合<a href="https://en.wikipedia.org/wiki/TMPDIR">惯例(en-US)</a> 。检查环境变量的顺序（偶然地）和一些类似功能的实现（如 <a href="https://dev.mysql.com/doc/refman/8.0/en/temporary-files.html">MySQL 在 Windows 上</a>）一致，和其它一些特定平台的 API（如 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-gettemppathw">Win32 API</a> ）及另一些不作为公开行为的实现（如 <a href="https://gcc.gnu.org/onlinedocs/gcc-4.8.5/libiberty/Functions.html#index-choose_005ftmpdir-66">libiberty 的 <code>choose_tmpdir</code></a> ）可能不一致。被支持的环境变量可用性举例：</p>
<ul>
<li><code>TMPDIR</code> ：<a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html">POSIX.1 要求的环境变量</a> 。</li>
<li><code>TEMP</code> ：被 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-gettemppathw">Win32 文件 API</a> 等使用。</li>
<li><code>TMP</code> ：被 Win32 文件 API 和 <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/tempnam-wtempnam-tmpnam-wtmpnam?view=msvc-160">Microsoft C 运行时 API</a> 等使用。</li>
<li>另见<a href="https://devblogs.microsoft.com/oldnewthing/20150417-00/?p=44213">对 MS-DOS 和 Microsoft Windows 使用的临时目录环境变量解释</a>。</li>
</ul>
<p><strong>已知限制</strong> 不检查路径是否表示实际可写的目录。另见文件访问约定。</p>
<p>　　当前脚本实现假定临时目录可写，不满足条件时，文件操作可能失败。脚本使用的临时文件前也不保证检查文件可写。若此文件不可写（例如，在之前被 <code>root</code> 等高权限用户创建），则依赖文件可写的操作可能失败。对构建脚本，这可能导致依赖临时文件进行检查判断失效，而使错误的选项被使用。</p>
<p>　　一般地，脚本可使用特定的例程（如 Shell 脚本可选地使用<a href="https://stackoverflow.com/questions/2792675">在许多环境中可用的 <code>mktemp</code> 命令</a>）随机化文件名减少冲突。若需要更可靠地避免上述问题，可在运行脚本前清理临时目录，或预先设置 <code>SHBuild_GetTempDir</code> 访问的环境变量指定确保可写的空目录，同时避免并发调用脚本导致不安全并发访问此目录中的临时文件。脚本不使用其它方法确定直接使用的临时目录，但脚本间接调用的外部工具仍可能导致不安全的访问，而无法保证可靠。</p>
<h3 id="函数-shbuild_platform_detect"><a class="header" href="#函数-shbuild_platform_detect">函数 SHBuild_Platform_Detect</a></h3>
<p>　　通过参数指定的操作系统和体系结构名，结合环境变量，确定平台名称，检查非空并返回。</p>
<p>　　第一和第二参数分别指定操作系统名和体系结构名，接受的取值参见<a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_checkuname">函数 <code>SHBuild_CheckUName</code></a> 。</p>
<p>　　当前 <code>Win32</code> 系统外的结果和 <code>SHBuild_CheckUName</code> 初始化 <code>SHBuild_Env_OS</code> 的结果一致。处理如下：</p>
<ul>
<li>若操作系统名为 <code>Win32</code> ：
<ul>
<li>若环境变量 <code>MSYSTEM</code> 设置为 <a href="https://www.msys2.org/docs/environments/">MSYS2 支持的环境</a>，结果对应如下：
<ul>
<li><code>MINGW64</code>：<code>MinGW64</code> 。</li>
<li><code>MINGW32</code>：<code>MinGW32</code> 。</li>
<li><code>CLANG64</code>：<code>MinGW_Clang64</code> 。</li>
<li><code>CLANG32</code>：<code>MinGW_UCRT64</code> 。</li>
<li><code>CLANGARM64</code>：<code>MinGW_ClangARM64</code> 。</li>
<li><code>UCRT64</code>：<code>MinGW_UCRT64</code> 。</li>
</ul>
</li>
<li>否则，若体系结构为 <code>x86_64</code> ，则结果为 <code>MinGW64</code> 。</li>
<li>否则，结果为 <code>MinGW32</code> 。</li>
</ul>
</li>
<li>否则，结果为操作系统名。</li>
</ul>
<h3 id="函数-shbuild_preparebuild"><a class="header" href="#函数-shbuild_preparebuild">函数 SHBuild_PrepareBuild</a></h3>
<p>　　准备构建环境。按以下方式初始化变量使之具有非空值：</p>
<ul>
<li>调用<a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_gettempdir">函数 <code>SHBuild_GetTempDir</code></a> 初始化 <code>SHBuild_Env_TempDir</code> 。</li>
<li>调用<a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_checkuname">函数 <code>SHBuild_CheckUName</code></a> 初始化 <code>SHBuild_Env_OS</code> 和 <code>SHBuild_Env_Arch</code> 。</li>
<li>初始化 <code>SHBuild_Host_OS</code> 为 <code>SHBuild_Env_OS</code> 的值。</li>
<li>当变量 <code>SHBuild_Host_OS</code> 的值是 <code>Win32</code> 时，且环境变量 <code>MSYSTEM</code> 的值是 <a href="https://www.msys2.org/docs/environments/">MSYS2 支持的环境</a>支持的值，初始化 <code>SHBuild_Host_Arch</code> 对应的目标体系结构；否则，初始化 <code>SHBuild_Host_Arch</code> 为 <code>SHBuild_Env_Arch</code> 的值。</li>
</ul>
<h3 id="函数-shbuild_getbuildname"><a class="header" href="#函数-shbuild_getbuildname">函数 SHBuild_GetBuildName</a></h3>
<p>　　取用于进一步初始化构建路径的构建名称。</p>
<p>　　首先调用<a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_preparebuild">函数 <code>SHBuild_PrepareBuild</code></a> 按需初始化变量 <code>SHBuild_Env_Arch</code> 和 <code>SHBuild_Env_OS</code> 为非空值。</p>
<p>　　结果为以变量 <code>SHBuild_Env_OS</code> 和 <code>SHBuild_Env_Arch</code> 的值作为参数调用<a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_platform_detect">函数 <code>SHBuild_Platform_Detect</code></a> 的结果。</p>
<h3 id="函数-shbuild_buildgch"><a class="header" href="#函数-shbuild_buildgch">函数 SHBuild_BuildGCH</a></h3>
<p>　　构建 GNU 预编译头文件，依次执行：</p>
<ul>
<li>以第二参数指定的路径附加 <code>.gch</code> 后缀确定输出路径。</li>
<li>检查输出路径是否已存在文件，若存在则视为目标已被构建，输出消息并跳过以下步骤。</li>
<li>确保输出路径所在的目录被创建。</li>
<li>输出开始构建的消息。</li>
<li>硬链接第一参数指定输入的头文件路径到第二参数指定的安装路径。</li>
<li>按第一参数指定的输入路径和输出路径调用第三个参数指定构建命令。</li>
<li>输出构建完成的消息。</li>
</ul>
<p><strong>已知限制</strong> 构建命令仅支持 GNU 兼容工具链。</p>
<h3 id="函数-shbuild_checkpch"><a class="header" href="#函数-shbuild_checkpch">函数 SHBuild_CheckPCH</a></h3>
<p>　　检查和按需构建 GNU 预编译头文件并设置变量，依次执行：</p>
<ul>
<li>检查变量 <code>SHBuild_NoPCH</code> 的值，若为空值，则：
<ul>
<li>以第一参数、第二参数和 <code>$CXX -xc++-header $CXXFLAGS</code> 调用 <code>SHBuild_BuildGCH</code> 生成 GNU 风格预编译头文件。</li>
<li>设置内部变量 <code>SHBuild_IncPCH</code> 为合适的命令行选项的数组（以 <code>"-include"</code> 和头文件名作为其元素）用于包含生成的预编译头文件。</li>
</ul>
</li>
<li>否则：
<ul>
<li>输出跳过消息。</li>
<li>设置 <code>SHBuild_IncPCH</code> 的值为空数组。</li>
</ul>
</li>
</ul>
<p><strong>已知限制</strong> 构建命令仅支持 GNU 兼容工具链。</p>
<h3 id="函数-shbuild_2w"><a class="header" href="#函数-shbuild_2w">函数 SHBuild_2w</a></h3>
<p>　　接受 1 个表示路径的参数，调用 <code>cygpath</code> 转换 UNIX 路径到 Windows 路径。</p>
<p>　　当 <code>cygpath</code> 不存在时返回原路径。</p>
<h3 id="函数-shbuild_install"><a class="header" href="#函数-shbuild_install">函数 SHBuild_Install</a></h3>
<p>　　接受 2 个表示路径的参数，安装前者指定的文件到后者。</p>
<p>　　首先调用 <code>rsync</code> ，若失败调用 <code>cp</code> 。</p>
<p><strong>注意</strong> 防火墙可能导致 <code>rsync</code> 超时失败。</p>
<h3 id="函数-shbuild_installdir"><a class="header" href="#函数-shbuild_installdir">函数 SHBuild_InstallDir</a></h3>
<p>　　接受 2 个表示路径的参数，安装前者指定的目录到后者。</p>
<p>　　首先调用 <code>rsync</code> ，若失败调用 <code>cp</code> 。</p>
<p><strong>注意</strong> 防火墙可能导致 <code>rsync</code> 超时失败。</p>
<h3 id="函数-shbuild_install_exe"><a class="header" href="#函数-shbuild_install_exe">函数 SHBuild_Install_Exe</a></h3>
<p>　　接受 2 个表示路径的参数，安装前者指定的可执行文件到后者。</p>
<p>　　首先调用 <code>SHBuild_Install</code> ，然后在目标上设置可执行权限。</p>
<h3 id="函数-shbuild_install_hardlink"><a class="header" href="#函数-shbuild_install_hardlink">函数 SHBuild_Install_HardLink</a></h3>
<p>　　接受 2 个表示路径的参数，安装前者指定的文件到后者为硬链接。</p>
<p>　　首先删除目标，其次调用 Windows 命令解释器的 <code>mklink</code> ，若失败调用 <code>ln</code> 。</p>
<h3 id="函数-shbuild_install_hardlink_exe"><a class="header" href="#函数-shbuild_install_hardlink_exe">函数 SHBuild_Install_HardLink_Exe</a></h3>
<p>　　接受 2 个表示路径的参数，安装前者指定的可执行文件到后者为硬链接。</p>
<p>　　首先调用 <code>SHBuild_Install_HardLink</code> ，然后在目标上设置可执行权限。</p>
<p><strong>注意</strong> <code>mklink</code> 需要 Windows Vista 后的命令解释器(<code>cmd</code>) 的支持。硬链接需要文件系统（如 NTFS ）支持。</p>
<h3 id="函数-shbuild_install_link"><a class="header" href="#函数-shbuild_install_link">函数 SHBuild_Install_Link</a></h3>
<p>　　接受 2 个表示路径的参数，安装前者指定的文件到后者为符号链接。</p>
<p>　　首先删除目标，其次调用 Windows 命令解释器的 <code>mklink</code> ，若失败调用 <code>ln</code> 。</p>
<p><strong>注意</strong> <code>mklink</code> 需要 Windows Vista 后的命令解释器(<code>cmd</code>) 的支持。符号链接需要文件系统（如 NTFS ）支持。权限不足可能导致 <code>mklink</code> 创建符号链接失败，可在组策略改变相关默认行为。在一些版本的系统上，可能需要<a href="https://support.microsoft.com/en-us/kb/2856739/en-us">进一步的配置</a>以通过链接执行文件。</p>
<h3 id="函数-shbuild_loadcache"><a class="header" href="#函数-shbuild_loadcache">函数 SHBuild_LoadCache</a></h3>
<p>　　加载环境缓存。</p>
<p>　　函数接收 2 个参数，分别是缓存文件路径和被缓存的变量名的正则表达式模式的数组。</p>
<p>　　<a href="Tools/Scripts.zh-CN.html#stage-1-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">变量 <code>S1_CacheMode</code></a> 可配置模式控制缓存行为：</p>
<ul>
<li>若配置忽略，则无作用。</li>
<li>否则加载缓存。</li>
</ul>
<p>　　加载缓存通过解析文件内容验证后包含实现。</p>
<p>　　文件的内容应为可执行的 shell 赋值代码。当前检查支持的格式如下：</p>
<ul>
<li>每行一个条目，忽略首尾空白符。</li>
<li>若条目的形式是 <code>if ... then; ASSIGNMENT; fi</code> ，简化为 <code>ASSIGNMENT</code> 进行下一步检查，忽略其余部分。</li>
<li>进一步地，若条目的形式是 <code>declare -X VAR=...</code> ，其中 <code>X</code> 是匹配正则表达式模式 <code>(-|[Aagirx]+)</code> 的属性之一，简化为 <code>VAR</code> 进行下一步检查，忽略其余部分。
<ul>
<li><strong>注释</strong> 作为全局变量，<code>declare</code> 条目一般应具有 <code>-g</code> 属性，否则声明为局部变量，实际没有加载配置。</li>
</ul>
</li>
<li>进一步地，<code>VAR</code> 应为合法的标识符，匹配正则表达式模式 <code>[A-Za-z_][A-Za-z_0-9]*</code> 。</li>
</ul>
<p>　　若任意检查失败，则缓存格式无效，内容不会被加载；否则，包含缓存文件，以执行其中的赋值代码。</p>
<p>　　函数的返回值如下：</p>
<ul>
<li><code>0</code> ：成功。</li>
<li><code>1</code> ：内容无效。</li>
<li><code>2</code> ：指定的缓存文件无法读取。</li>
</ul>
<h3 id="函数-shbuild_savecache"><a class="header" href="#函数-shbuild_savecache">函数 SHBuild_SaveCache</a></h3>
<p>　　保存环境缓存。</p>
<p>　　函数接受的参数及其含义和<a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_loadcache">函数 <code>SHBuild_LoadCache</code></a> 一致。</p>
<p>　　<a href="Tools/Scripts.zh-CN.html#stage-1-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">变量 <code>S1_CacheMode</code></a> 可配置缓存模式控制缓存行为：</p>
<ul>
<li>若配置忽略，则无作用。</li>
<li>若缓存模式配置为清除缓存文件则删除缓存文件。</li>
<li>否则保存缓存。</li>
</ul>
<p>　　保存缓存操作如下：</p>
<ul>
<li>打开并清空缓存文件。</li>
<li>若缓存模式配置为清除缓存内容则打开文件成功时直接视为成功。</li>
<li>否则，继续解析 <code>declare -p</code> 结果，把其中变量名匹配第二参数中任意的正则表达式且内容满足函数 <code>SHBuild_LoadCache</code> 格式要求的行写入指定的缓存文件。
<ul>
<li>写入前，替换内容中的 <code>declare --</code> 或 <code>declare -</code> 为 <code>declare -g</code> 以确保声明全局变量。</li>
<li><strong>注释</strong> 不要求支持 <code>declare -p</code> 结果中的所有变量属性。不支持的属性被忽略。</li>
</ul>
</li>
</ul>
<p>　　函数的返回值如下：</p>
<ul>
<li><code>0</code> ：成功。</li>
<li><code>2</code> ：指定的缓存文件无法写入。</li>
</ul>
<h3 id="函数-shbuild_getsystemprefix"><a class="header" href="#函数-shbuild_getsystemprefix">函数 SHBuild_GetSystemPrefix</a></h3>
<p>　　转换参数指定的平台名称字符串为系统前缀字符串。</p>
<p>　　系统前缀用于在文件系统中安装部署。</p>
<p>　　通常系统前缀因为之前仍有非空的其它前缀（如 <a href="Tools/../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><code>SHBuild_SysRoot</code></a> 指定的值）而不是绝对路径的前缀。因此，系统前缀以 <code>/</code> 起始而不需要考虑所在的环境是否符合<a href="Tools/../Run.zh-CN.html#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80">局部 FHS 目录布局</a> 的问题。</p>
<p>　　当前支持的结果包括：</p>
<ul>
<li>参数为 <code>MinGW64</code> 时，结果为 <code>/mingw64</code> 。</li>
<li>参数为 <code>MinGW32</code> 时，结果为 <code>/mingw32</code> 。</li>
<li>否则，结果为 <code>/usr</code> 。</li>
</ul>
<p>　　本函数的结果支持 <a href="Tools/../Sysroot.zh-CN.html#%E5%B8%83%E5%B1%80">Sysroot 的目录布局</a>。</p>
<p><strong>注释</strong> 参数典型地来自调用<a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_platform_detect">函数 <code>SHBuild_Platform_Detect</code></a> 的结果。</p>
<h3 id="函数-shbuild_s1_initconf"><a class="header" href="#函数-shbuild_s1_initconf">函数 SHBuild_S1_InitConf</a></h3>
<p>　　初始化 <a href="Tools/../Sysroot.zh-CN.html">stage 1 Sysroot</a> 构建配置，依次执行：</p>
<ul>
<li>断言<a href="Tools/../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">变量 <code>SHBuild_ToolDir</code></a> 非空。</li>
<li>按需初始化<a href="Tools/../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">变量 <code>YSLib_BaseDir</code></a> ，默认值为 <code>"$SHBuild_ToolDir/../.."</code> 。
<ul>
<li><strong>注释</strong> Stage 1 环境下总是可通过脚本所在目录推断 YSLib 源代码和存储库中的其它源文件的位置。</li>
</ul>
</li>
<li>尝试以切换当前目录的方式访问 <code>$YSLib_BaseDir</code> 。</li>
<li>按需初始化<a href="Tools/../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">变量 <code>SHBuild_BuildDir</code></a> ，默认值为 YSLib 版本库根目录下的 <code>build/$(SHBuild_GetBuildName)</code> 。</li>
<li>确保变量 <code>SHBuild_BuildDir</code> 指定的目录被创建，并尝试以切换当前目录的方式访问。</li>
<li>若<a href="Tools/Scripts.zh-CN.html#stage-1-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">变量 <code>S1_BuildDir</code></a> 的值为空，断言<a href="Tools/Scripts.zh-CN.html#stage-1-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">变量 <code>S1_BuildConf</code></a> 的值非空。
<ul>
<li><strong>注释</strong> 这排除以下的初始化默认值使用非预期路径。</li>
</ul>
</li>
<li>按需初始化变量 <code>S1_BuildDir</code> ，默认值为 <code>"$SHBuild_BuildDir/.$S1_BuildConf"</code> 。</li>
<li>按需初始化<a href="Tools/Scripts.zh-CN.html#stage-1-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">变量 <code>S1_DistDir</code></a> ，默认值为 <code>"$S1_BuildDir/.stage1"</code> 。</li>
<li>按需初始化<a href="Tools/Scripts.zh-CN.html#stage-1-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">变量 <code>S1_SHBuild</code></a> ，默认值为 <code>"$S1_DistDir/SHBuild"</code> 。</li>
<li>确保变量 <code>S1_BuildDir</code> 指定的目录被创建，并尝试以切换当前目录的方式访问。</li>
<li>确保变量 <code>S1_DistDir</code> 指定的目录被创建，并尝试以切换当前目录的方式访问。</li>
</ul>
<p>　　以上变量初始化后只读。</p>
<h3 id="函数-shbuild_s2_prepare"><a class="header" href="#函数-shbuild_s2_prepare">函数 SHBuild_S2_Prepare</a></h3>
<p>　　准备 <a href="Tools/../Sysroot.zh-CN.html">stage 2 Sysroot</a> 环境，依次执行：</p>
<ul>
<li>确保变量 <code>SHBuild_SysRoot</code> 的初始化。
<ul>
<li>使用第一参数作为这个变量的默认值。若这个变量未被设置，则以默认值赋值。</li>
</ul>
</li>
<li>断言这个变量的值非空，以其值作为创建目录，若指定的目录已存在则忽略。</li>
<li>初始化变量 <code>SHBuild_SystemPrefix</code> 。
<ul>
<li><strong>注释</strong> 参见 <a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-yslib-buildtxt"><code>Tools/Scripts/SHBuild-YSLib-build.txt</code></a> 的说明。</li>
</ul>
</li>
<li>初始化变量 <code>SR_Prefix</code> 的值为 <code>"$SHBuild_SysRoot$SHBuild_SystemPrefix"</code> 。</li>
</ul>
<h3 id="函数-shbuild_s2_prepare_build"><a class="header" href="#函数-shbuild_s2_prepare_build">函数 SHBuild_S2_Prepare_Build</a></h3>
<p>　　准备 stage 2 Sysroot 构建环境，依次执行</p>
<ul>
<li>以第一参数调用 <code>SHBuild_S2_Prepare</code> 。</li>
<li>导出变量 <code>SHBuild</code> 的值为 <code>"$SR_Prefix/bin/SHBuild"</code> 。</li>
</ul>
<h2 id="toolsscriptsshbuild-common-optionssh"><a class="header" href="#toolsscriptsshbuild-common-optionssh">Tools/Scripts/SHBuild-common-options.sh</a></h2>
<p>　　被应用程序构建脚本包含的基础功能，提供默认的编译器和链接器命令行选项。</p>
<p>　　若某个变量提供默认值且执行脚本时没有非空值，则设置为脚本提供的默认值。</p>
<p>　　<strong>这个脚本是公开的工具</strong>，被安装脚本部署。</p>
<p>　　包含 <code>Tools/Scripts/SHBuild-common-toolchain.sh</code> 确定工具链。</p>
<p><strong>注意</strong> G++ 和 Clang++ 不完全兼容。以下部分变量通过 <code>Tools/Scripts/SHBuild-common-toolchain.sh</code> 中的例程判断 G++ 和 Clang ，并自动使用不同的选项默认值。因此直接通过名称和符号链接等方式伪装会失效而可能导致错误。</p>
<p>　　以下所有变量仅在外部环境设置为空或未设置时提供默认值，按顺序被指定。可在外部设置为非空值以避免被本脚本中的值覆盖。以下仅列出部分相对不容易变动的默认值，其它默认值参见脚本源代码。若不需要默认值，可以提前设置非空值或在 <code>.</code> 指令后直接设置其它（可能为空的）值。</p>
<h3 id="变量-shbuild_debug"><a class="header" href="#变量-shbuild_debug">变量 SHBuild_Debug</a></h3>
<p>　　默认值为空。</p>
<p>　　非空时，指定变量的值：</p>
<pre><code class="language-shell">CXXFLAGS_OPT_DBG='-O0 -g -D_GLIBCXX_DEBUG_PEDANTIC'
LDFLAGS_OPT_DBG=' '
</code></pre>
<h3 id="变量-c_cxxflags_gc"><a class="header" href="#变量-c_cxxflags_gc">变量 C_CXXFLAGS_GC</a></h3>
<p>　　C/C++ 编译器生成二进制节 GC 选项。</p>
<p>　　默认值为 <code>-fdata-sections -ffunction-sections</code> 。</p>
<p>　　设置后会被检查是否支持，参见下文。</p>
<h3 id="变量-ldflags_gc"><a class="header" href="#变量-ldflags_gc">变量 LDFLAGS_GC</a></h3>
<p>　　链接器生成二进制节 GC 选项。</p>
<p>　　默认值为 <code>-Wl,--gc-sections</code> 。</p>
<p>　　设置后会和 <code>C_CXXFLAGS_GC</code> 通过 <code>$CXX</code> 作为编译器编译链接简单程序测试是否支持。若不支持，此变量和 <code>C_CXXFLAGS_GC</code> 都会被置空。</p>
<p><strong>已知限制</strong> <a href="http://sourceforge.net/p/msys2/discussion/general/thread/2d6adff2/?limit=25">Windows 上的工具链可能缺乏 <code>/dev/null</code> 的必要支持</a>，因此此项检查使用的输出路径指定为 <code>/tmp/null</code> 。</p>
<h3 id="变量-c_cxxflags_pic"><a class="header" href="#变量-c_cxxflags_pic">变量 C_CXXFLAGS_PIC</a></h3>
<p>　　C 和 C++ 编译器共用的 PIC （ Position Independent Code ，位置无关代码）生成选项。</p>
<p>　　默认值在 Win32 上为空，其它平台上为 <code>-fPIC -fno-semantic-interposition</code> 。</p>
<p>　　用于保证生成的对象文件可被用于生成动态库。</p>
<h3 id="变量-ldflags_strip"><a class="header" href="#变量-ldflags_strip">变量 LDFLAGS_STRIP</a></h3>
<p>　　链接器剥离符号选项。</p>
<p>　　默认值为 <code>-s</code> 。</p>
<h3 id="变量-c_cxxflags_ext"><a class="header" href="#变量-c_cxxflags_ext">变量 C_CXXFLAGS_EXT</a></h3>
<p>　　指定 C/C++ 语言扩展的选项。</p>
<p>　　默认值和平台相关：若为 Win32 环境则为空，否则为 <code>-D_POSIX_C_SOURCE=200809L</code> 。</p>
<p><strong>注释</strong> 若实现环境没有提供适当的宏定义，YFramework 中使用 POSIX 平台文件系统 API 的实现要求不被满足而可能构建失败。</p>
<h3 id="变量-c_cxxflags_arch"><a class="header" href="#变量-c_cxxflags_arch">变量 C_CXXFLAGS_ARCH</a></h3>
<p>　　C 和 C++ 编译器共用的体系结构相关选项。</p>
<p>　　默认值为空。</p>
<p>　　不限制具体形式，使用 G++ 时可以是 <code>-march=native</code> 。</p>
<h3 id="变量-c_cxxflags_common"><a class="header" href="#变量-c_cxxflags_common">变量 C_CXXFLAGS_COMMON</a></h3>
<p>　　C 和 C++ 编译器共用的公共选项。</p>
<p>　　默认值为 <code>-pipe $C_CXXFLAGS_GC $C_CXXFLAGS_ARCH -pedantic-errors $C_CXXFLAGS_EXT</code> 。</p>
<h3 id="变量-c_cxxflags_opt_lv"><a class="header" href="#变量-c_cxxflags_opt_lv">变量 C_CXXFLAGS_OPT_LV</a></h3>
<p>　　C 和 C++ 编译器优化等级选项。</p>
<p>　　默认值为 <code>-O3</code> 。</p>
<h3 id="函数-shbuild_get_c_cxxflags_warning"><a class="header" href="#函数-shbuild_get_c_cxxflags_warning">函数 SHBuild_Get_C_CXXFLAGS_WARNING</a></h3>
<p>　　取 C 和 C++ 编译器共用的警告命令行选项的默认值。</p>
<p>　　结果包括以下列表中的内容：</p>
<ul>
<li><code>-Wall</code></li>
<li><code>-Wcast-align</code></li>
<li><code>-Wdeprecated</code></li>
<li><code>-Wdeprecated-declarations</code></li>
<li><code>-Wdouble-promotion</code></li>
<li><code>-Wextra</code></li>
<li><code>-Wfloat-equal</code></li>
<li><code>-Wformat=2</code></li>
<li><code>-Winvalid-pch</code></li>
<li><code>-Wlogical-op</code></li>
<li><code>-Wmissing-declarations</code></li>
<li><code>-Wmissing-include-dirs</code></li>
<li><code>-Wmultichar</code></li>
<li><code>-Wno-format-nonliteral</code></li>
<li><code>-Wredundant-decls</code></li>
<li><code>-Wshadow</code></li>
<li><code>-Wsign-conversion</code></li>
<li><code>-Wstringop-overflow=0</code></li>
<li><code>-Wsuggest-attribute=const</code></li>
<li><code>-Wsuggest-attribute=noreturn</code></li>
<li><code>-Wsuggest-attribute=pure</code></li>
<li><code>-Wtrampolines</code></li>
</ul>
<p>　　通过检查 C++ 编译器和版本已知不支持的选项会被替换为其它功能近似的选项或被排除。</p>
<p><strong>注释</strong> 当前仅检查 C++ 编译器，假定 C 编译器和 C++ 编译器版本对应一致（即 G++ 蕴含 GCC ，Clang++ 蕴含 Clang ）。</p>
<h3 id="变量-c_cxxflags_warning"><a class="header" href="#变量-c_cxxflags_warning">变量 C_CXXFLAGS_WARNING</a></h3>
<p>　　C 和 C++ 编译器共用的警告命令行选项。</p>
<p>　　默认值是调用<a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_get_c_cxxflags_warning">函数 <code>SHBuild_Get_C_CXXFLAGS_WARNING</code></a> 得到的值。</p>
<h3 id="变量-c_cxxflags_impl_warning"><a class="header" href="#变量-c_cxxflags_impl_warning">变量 C_CXXFLAGS_IMPL_WARNING</a></h3>
<p>　　和特定实现相关的 C 和 C++ 编译器共用的警告命令行选项。</p>
<p>　　默认值为空值。</p>
<h3 id="变量-cxxflags_impl_warning"><a class="header" href="#变量-cxxflags_impl_warning">变量 CXXFLAGS_IMPL_WARNING</a></h3>
<p>　　和特定实现相关的 C++ 编译器警告命令行选项。</p>
<p>　　默认值为空值。</p>
<h3 id="变量-cxxflags_impl_common"><a class="header" href="#变量-cxxflags_impl_common">变量 CXXFLAGS_IMPL_COMMON</a></h3>
<p>　　和特定实现相关的 C++ 编译器一般命令行选项。</p>
<p>　　默认值包括若干特定实现的选项。</p>
<h3 id="线程命令行选项"><a class="header" href="#线程命令行选项">线程命令行选项</a></h3>
<p>　　线程命令行选项是一组未指定名称的内部命令行选项，包含编译器选项和链接器选项的默认值。其中，编译器选项被<a href="Tools/Scripts.zh-CN.html#%E5%8F%98%E9%87%8F-cflags">变量 <code>CFLAGS</code></a> 和<a href="Tools/Scripts.zh-CN.html#%E5%8F%98%E9%87%8F-cxxflags">变量 <code>CXXFLAGS</code></a> 的默认值使用，链接器选项被<a href="Tools/Scripts.zh-CN.html#%E5%8F%98%E9%87%8F-ldflags">变量 <code>LDFLAGS</code></a> 的默认值使用。</p>
<p>　　默认值按以下方式检查和指定线程参数：</p>
<ul>
<li>通过 <code>-dumpspecs</code> 的内容检查是否匹配 <code>mthreads:</code> 。若成功，编译器和链接器选项添加 <code>-mthreads</code> 。</li>
<li>否则，测试带有 <code>-mthread</code> 选项的构建。若（直接调用编译器驱动）构建通过，则链接器选项添加 <code>-mthreads</code> ，并检查编译。
<ul>
<li>若编译不通过，则编译器选项添加 <code>-D_MT</code> ，否则添加 <code>-mthreads</code> 。</li>
</ul>
</li>
<li>否则，若通过 <code>-dumpspecs</code> 的内容检查匹配 <code>no-pthread:</code> 且带有 <code>-pthread</code> 时无法构建，则保持编译器和链接器选项不变。</li>
<li>否则，编译器和链接器选项添加 <code>-pthread</code> 。</li>
</ul>
<p><strong>注意</strong> 不论 C 或 C++ ，当前实现在调用编译器测试构建时总是使用<a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_cxx_testsimple">函数 SHBuild_CXX_TestSimple</a> 。</p>
<h3 id="变量-cxxflags_impl_opt"><a class="header" href="#变量-cxxflags_impl_opt">变量 CXXFLAGS_IMPL_OPT</a></h3>
<p>　　和特定工具相关的 C++ 编译器优化命令行选项。</p>
<p>　　默认值包括若干特定实现的选项。</p>
<h3 id="变量-cflags_std"><a class="header" href="#变量-cflags_std">变量 CFLAGS_STD</a></h3>
<p>　　指定 C 标准的编译器命令行选项。</p>
<p>　　默认值为 <code>-std=c11</code> 。</p>
<h3 id="变量-cflags_warning"><a class="header" href="#变量-cflags_warning">变量 CFLAGS_WARNING</a></h3>
<p>　　C 编译器警告命令行选项。</p>
<p>　　默认值包含以下列表中的内容：</p>
<ul>
<li>变量 <code>C_CXXFLAGS_WARNING</code> 的内容</li>
<li>变量 <code>C_CXXFLAGS_IMPL_WARNING</code> 的内容</li>
</ul>
<h3 id="变量-cxxflags_std"><a class="header" href="#变量-cxxflags_std">变量 CXXFLAGS_STD</a></h3>
<p>　　指定 C++ 标准的编译器命令行选项。</p>
<p>　　默认值为 <code>-std=c++11</code> 。</p>
<h3 id="函数-shbuild_get_cxxflags_warning"><a class="header" href="#函数-shbuild_get_cxxflags_warning">函数 SHBuild_Get_CXXFLAGS_WARNING</a></h3>
<p>　　取 C++ 编译器的警告命令行选项的默认值。</p>
<p>　　结果包括以下列表中的内容：</p>
<ul>
<li>变量 <code>C_CXXFLAGS_WARNING</code> 的内容</li>
<li>变量 <code>C_CXXFLAGS_IMPL_WARNING</code> 的内容</li>
<li><code>-Wconditionally-supported</code></li>
<li><code>-Wctor-dtor-privacy</code></li>
<li><code>-Wdeprecated</code>（仅当旧版本 GCC 中这个选项支持 C++ 但不支持 C 时）</li>
<li><code>-Wno-deprecated-register</code></li>
<li><code>-Wno-mismatched-tags</code></li>
<li><code>-Wno-missing-braces</code>（仅当 Clang++ &lt; 6.0 ，作为<a href="https://bugs.llvm.org/show_bug.cgi?id=21629">这个问题</a>的变通）</li>
<li><code>-Wnon-virtual-dtor</code></li>
<li><code>-Woverloaded-virtual</code></li>
<li><code>-Wsign-promo</code></li>
<li><code>-Wshorten-64-to-32</code></li>
<li><code>-Wstrict_null_sentinal</code></li>
<li><code>-Wsuggest-final-methods</code></li>
<li><code>-Wsuggest-final-types</code></li>
<li><code>-Wweak-vtables</code></li>
<li><code>-Wzero-as-null-pointer-constant</code></li>
<li>变量 <code>CXXFLAGS_IMPL_WARNING</code> 的内容</li>
</ul>
<p>　　除以上变量中的内容外，通过检查 C++ 编译器和版本已知不支持的选项会被替换为其它功能近似的选项或被排除。</p>
<h3 id="变量-cxxflags_warning"><a class="header" href="#变量-cxxflags_warning">变量 CXXFLAGS_WARNING</a></h3>
<p>　　C++ 编译器警告命令行选项。</p>
<p>　　默认值是调用<a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_get_cxxflags_warning">函数 <code>SHBuild_Get_CXXFLAGS_WARNING</code></a> 得到的值。</p>
<h3 id="变量-cxxflags_opt_dbg"><a class="header" href="#变量-cxxflags_opt_dbg">变量 CXXFLAGS_OPT_DBG</a></h3>
<p>　　C++ 编译器优化和调试相关的命令行选项。在未设置非空的 <code>SHbuild_Debug</code> 时。</p>
<p>　　默认值包含以下列表中的内容：</p>
<ul>
<li>变量 <code>C_CXXFLAGS_OPT_LV</code> 的内容</li>
<li>变量 <code>CXXFLAGS_OPT_UseAssert</code> 没有被设置非空值时包含 <code>-NDEBUG</code></li>
<li>变量 <code>CXXFLAGS_IMPL_OPT</code> 的内容</li>
<li><code>-fomit-frame-pointer</code></li>
</ul>
<h3 id="变量-cflags"><a class="header" href="#变量-cflags">变量 CFLAGS</a></h3>
<p>　　C 编译器使用的命令行选项。</p>
<p>　　默认值为 <code>$CFLAGS_STD $C_CXXFLAGS_PIC $C_CXXFLAGS_COMMON $CFLAGS_WARNING $C_CXXFLAGS_IMPL_THRD_ $C_CXXFLAGS_COMMON_IMPL_ $CXXFLAGS_OPT_DBG</code> 。其中，<code>C_CXXFLAGS_COMMON_IMPL_</code> 是<a href="Tools/Scripts.zh-CN.html#%E7%BA%BF%E7%A8%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9">编译器线程命令行选项</a>，而 <code>C_CXXFLAGS_COMMON_IMPL_</code> 是根据支持的编译器在内部定义的非公开变量。</p>
<p><strong>注意</strong> 当前和 C++ 编译器选项共用 <code>CXXFLAGS_OPT_DBG</code> 。</p>
<h3 id="变量-cxxflags"><a class="header" href="#变量-cxxflags">变量 CXXFLAGS</a></h3>
<p>　　C++ 编译器使用的命令行选项。</p>
<p>　　默认值为 <code>$CXXFLAGS_STD $C_CXXFLAGS_PIC $C_CXXFLAGS_COMMON $CXXFLAGS_WARNING $C_CXXFLAGS_IMPL_THRD_ $CXXFLAGS_IMPL_COMMON $CXXFLAGS_OPT_DBG</code> 。其中，<code>C_CXXFLAGS_COMMON_IMPL_</code> 是<a href="Tools/Scripts.zh-CN.html#%E7%BA%BF%E7%A8%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9">编译器线程命令行选项</a>，而 <code>CXXFLAGS_IMPL_COMMON</code> 的默认值包含<a href="Tools/Scripts.zh-CN.html#%E5%8F%98%E9%87%8F-cflags">变量 <code>C_CXXFLAGS_COMMON_IMPL_</code></a> 的内容。</p>
<h3 id="变量-ldflags_opt_dbg"><a class="header" href="#变量-ldflags_opt_dbg">变量 LDFLAGS_OPT_DBG</a></h3>
<p>　　链接器优化和调试相关的命令行选项。在未设置非空的 <code>SHbuild_Debug</code> 时。</p>
<p>　　默认值为 <code>$LDFLAGS_STRIP $LDFLAGS_IMPL_OPT $LDFLAGS_GC</code> 。</p>
<h3 id="变量-ldflags"><a class="header" href="#变量-ldflags">变量 LDFLAGS</a></h3>
<p>　　链接器使用的命令行选项。</p>
<p>　　默认值依次包含以下内容：</p>
<ul>
<li>变量 <code>C_CXXFLAGS_PIC</code> 的内容。</li>
<li>变量 <code>CXXFLAGS_WARNING</code> 的内容。</li>
<li>默认的<a href="Tools/Scripts.zh-CN.html#%E7%BA%BF%E7%A8%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9">线程命令行选项</a>。</li>
<li>变量 <code>LDFLAGS_OPT_DBG</code> 的内容。</li>
<li>可选的其它选项（参见以下 <a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-yslib-commontxt"><code>Tools/Scripts/SHBuild-YSLib-common.txt</code></a> ）。</li>
</ul>
<p>　　默认使用 <code>-Wl,</code> 传递链接器特定的命令行。</p>
<h2 id="toolsscriptsshbuild-common-toolchainsh"><a class="header" href="#toolsscriptsshbuild-common-toolchainsh">Tools/Scripts/SHBuild-common-toolchain.sh</a></h2>
<p>　　被应用程序构建脚本包含的基础功能，提供默认的编译器和链接器等工具的名称。</p>
<p>　　支持 GCC/G++ 和 Clang/Clang++ 。</p>
<p>　　支持 <code>ar</code> 及与其兼容的工具 <code>gcc-ar</code>/<code>llvm-ar</code> 的自动检测。对 Clang++ 和 G++ ，分别使用 <code>llvm-ar</code> 和 <code>gcc-ar</code> 。</p>
<p>　　以下可在环境外部配置，在值确定后被导出：</p>
<ul>
<li><code>CC</code>
<ul>
<li>若操作系统为 <code>Win32</code> 且 <code>MSYSTEM</code> 指定为默认使用 llvm 工具链（即 Clang ）的环境，默认值为 <code>clang</code> ，否则为 <code>gcc</code> 。</li>
</ul>
</li>
<li><code>CXX</code>
<ul>
<li>若操作系统为 <code>Win32</code> 且 <code>MSYSTEM</code> 指定为默认使用 llvm 工具链（即 Clang++ ）的环境，默认值为 <code>clang++</code> ，否则为 <code>g++</code> 。</li>
</ul>
</li>
<li><code>AR</code>
<ul>
<li>默认值为变量 <code>CXX</code> 指定的 C++ 编译器确定的自动检测结果；若非 Clang++ 和 G++ ，则使用 <code>ar</code> 。</li>
</ul>
</li>
<li><code>ARFLAGS</code>
<ul>
<li>默认值为 <code>rcs</code> 。</li>
</ul>
</li>
<li><code>LD</code>
<ul>
<li>默认值为变量 <code>CXX</code> 的值。</li>
</ul>
</li>
</ul>
<p>　　关于 <code>MSYSTEM</code> 指定的环境和使用的工具链的对应关系，参见 <a href="https://www.msys2.org/docs/environments/">MSYS2 支持的环境</a>；关于支持的 <code>MSYSTEM</code> 的值和 MSYS2 环境，另见<a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_platform_detect">函数 <code>SHBuild_Platform_Detect</code></a> 。</p>
<p>　　以下只读变量在初始化配置时被按需初始化并断言非空：</p>
<ul>
<li><code>SHBuild_CC_Name</code> ：C 编译器名称。
<ul>
<li>在调用函数 <code>SHBuild_CC_GetVersion</code> 时被首先初始化。</li>
<li>初值是 <code>$CC</code> 作为参数调用函数 <code>SHBuild_CheckCC</code> 的结果。</li>
</ul>
</li>
<li><code>SHBuild_CC_Version</code> ：C 编译器版本号。
<ul>
<li>当前未使用。</li>
<li>初值是调用函数 <code>SHBuild_CC_GetVersion</code> 的结果。</li>
</ul>
</li>
<li><code>SHBuild_CXX_Name</code> ：C++ 编译器名称。
<ul>
<li>在调用<a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_cxx_getversion">函数 <code>SHBuild_CXX_GetVersion</code></a> 时被首先初始化。</li>
<li>在脚本 <a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-common-toolchainsh"><code>Tools/Scripts/SHBuild-common-toolchain.sh</code></a> 确定 <code>AR</code> 的默认值值前初始化。</li>
<li>在脚本 <a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-common-optionssh"><code>Tools/Scripts/SHBuild-common-options.sh</code></a> 确定 <code>CXXFLAGS</code> 等其它配置变量的默认值值前初始化。</li>
<li>初值是 <code>$CXX</code> 作为参数调用函数 <code>SHBuild_CheckCXX</code> 的结果。</li>
</ul>
</li>
<li><code>SHBuild_CXX_Version</code> ：C++ 编译器版本号。
<ul>
<li>在脚本 <code>Tools/Scripts/SHBuild-common-toolchain.sh</code> 确定 C++ 版本号前初始化。</li>
<li>初值是调用函数 <code>SHBuild_CXX_GetVersion</code> 的结果。</li>
</ul>
</li>
</ul>
<p>　　上述按需初始化使用<a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_initreadonly">函数 <code>SHBuild_InitReadonly</code></a>。</p>
<p><strong>注释</strong> 可通过外部执行环境指定这些变量具有非空值而跳过初始化。</p>
<p>　　<strong>这个脚本是公开的工具</strong>，被安装脚本部署。</p>
<h3 id="函数-shbuild_checkcompiler"><a class="header" href="#函数-shbuild_checkcompiler">函数 SHBuild_CheckCompiler</a></h3>
<p>　　尝试以参数指定的编译参数和输入调用参数指定的编译器，并按检查结果选择和输出参数的值。</p>
<p>　　检查编译器时，首先排除参数指定的编译器不可执行的情形，然后通过尝试编译以参数指定的源程序进行。</p>
<p>　　前四参数分别指定编译器的路径、尝试编译的源程序、检查成功时输出的结果和检查失败时输出的结果，之后的参数指定编译选项和源文件。选项和源文件参数中，应在语言选项（如 <code>-xc++</code> ）后出现一次表示输入源程序的 <code>-</code> 。</p>
<p><strong>注释</strong> 这允许自由安排参数中 <code>-</code> 的顺序。一般地，<code>-</code> 应出现在 <code>-xc++</code> 等参数之后，而出现在链接的库选项之前（如有）。若指定链接的其它库选项在 <code>-</code> 之前，其中的符号在使用 GNU ld 等对出现顺序敏感的链接器时，无法在源程序中引用而链接失败。</p>
<p>　　检查前断言前两个参数非空。指定编译选项的参数为空时，第三和第四参数可能不提供或为空。</p>
<p>　　源程序和换行符通过管道输入编译器。</p>
<p><strong>注释</strong> 对 ISO C 以及 ISO C++11 前的版本，翻译单元不以空行结尾引起未定义行为。此处指定源程序的参数可以不以换行结尾也可安全处理。</p>
<p>　　结果是以下之一：</p>
<ul>
<li>空值（第一参数指定不可执行的路径）。</li>
<li>第三参数（检查成功时的结果）。</li>
<li>第四参数（检查失败时的结果）。</li>
</ul>
<p><strong>注意</strong> 当前不检查失败原因。编译命令调用依赖可写的临时目录。参见函数 <code>SHBuild_GetTempDir</code> 的已知限制。</p>
<h3 id="函数-shbuild_checkcc"><a class="header" href="#函数-shbuild_checkcc">函数 SHBuild_CheckCC</a></h3>
<p>　　尝试调用参数指定的编译器以检查 C 编译器风格。</p>
<p>　　第一参数指定编译器可执行文件路径。</p>
<p>　　结果是以下之一：</p>
<ul>
<li>空值（不支持的编译器）。</li>
<li><code>Clang</code> 。</li>
<li><code>GCC</code> 。</li>
</ul>
<h3 id="函数-shbuild_checkcxx"><a class="header" href="#函数-shbuild_checkcxx">函数 SHBuild_CheckCXX</a></h3>
<p>　　尝试调用参数指定的编译器以检查 C++ 编译器名称。</p>
<p>　　第一参数指定编译器可执行文件路径。</p>
<p>　　结果是以下之一：</p>
<ul>
<li>空值（不支持的编译器）。</li>
<li><code>Clang++</code> 。</li>
<li><code>G++</code> 。</li>
</ul>
<h3 id="函数-shbuild_cc_test"><a class="header" href="#函数-shbuild_cc_test">函数 SHBuild_CC_Test</a></h3>
<p>　　测试 <code>"$CC"</code> 指定的编译器 C 编译器命令行是否可成功调用。</p>
<p>　　第一参数指定源程序，之后的参数指定编译选项。编译选项前隐含 <code>-pipe -xc</code> 。</p>
<p>　　以 <code>SHBuild_CheckCompiler</code> 实现编译器调用。</p>
<h3 id="函数-shbuild_cc_testsimple"><a class="header" href="#函数-shbuild_cc_testsimple">函数 SHBuild_CC_TestSimple</a></h3>
<p>　　测试 <code>"$CC"</code> 指定的编译器 C 编译器命令行编译最小程序是否可成功调用。</p>
<p>　　参数指定编译选项。</p>
<p>　　以 <code>SHBuild_CC_Test</code> 实现编译器调用。</p>
<p>　　使用的最小程序是 <code>int main(void){return 0;}</code> 。</p>
<h3 id="函数-shbuild_cxx_test"><a class="header" href="#函数-shbuild_cxx_test">函数 SHBuild_CXX_Test</a></h3>
<p>　　测试 <code>"$CXX"</code> 指定的编译器 C++ 编译器命令行是否可成功调用。</p>
<p>　　第一参数指定源程序，之后的参数指定编译选项。编译选项前隐含 <code>-pipe -xc++</code> 。</p>
<p>　　以 <code>SHBuild_CheckCompiler</code> 实现编译器调用。</p>
<h3 id="函数-shbuild_cxx_testsimple"><a class="header" href="#函数-shbuild_cxx_testsimple">函数 SHBuild_CXX_TestSimple</a></h3>
<p>　　测试 <code>"$CXX"</code> 指定的编译器 C++ 编译器命令行编译最小程序是否可成功调用。</p>
<p>　　参数指定编译选项。</p>
<p>　　以 <code>SHBuild_CXX_Test</code> 实现编译器调用。</p>
<p>　　使用的最小程序是 <code>int main(){}</code> 。</p>
<h3 id="函数-shbuild_cc_getversion"><a class="header" href="#函数-shbuild_cc_getversion">函数 SHBuild_CC_GetVersion</a></h3>
<p>　　尝试调用 <code>"$CC"</code> 指定的编译器以管道输入的程序取 C 编译器版本号。</p>
<p>　　结果是以下之一：</p>
<ul>
<li>成功时：GCC 或 Clang 版本号的 <code>X.Y.Z</code> 转换为 <code>X * 10000 + Y * 100 + Z</code> 的数值的字符串。</li>
<li>失败时：空。</li>
</ul>
<p><strong>已知缺陷</strong> 不支持无法取得 <code>__GNUC_PATCHLEVEL__</code> 的旧版本 GCC 。
<strong>已知缺陷</strong> 不支持 Apple Clang 。</p>
<h3 id="函数-shbuild_cxx_getversion"><a class="header" href="#函数-shbuild_cxx_getversion">函数 SHBuild_CXX_GetVersion</a></h3>
<p>　　尝试调用 <code>"$CXX"</code> 指定的编译器以管道输入的程序取 C++ 编译器版本号。</p>
<p>　　结果是以下之一：</p>
<ul>
<li>成功时：G++ 或 Clang++ 版本号的 <code>X.Y.Z</code> 转换为 <code>X * 10000 + Y * 100 + Z</code> 的数值的字符串。</li>
<li>失败时：空。</li>
</ul>
<p><strong>已知缺陷</strong> 不支持无法取得 <code>__GNUC_PATCHLEVEL__</code> 的旧版本 GCC 。
<strong>已知缺陷</strong> 不支持 Apple Clang 。</p>
<h2 id="toolsscriptsshbuild-self-hostsh"><a class="header" href="#toolsscriptsshbuild-self-hostsh">Tools/Scripts/SHBuild-self-host.sh</a></h2>
<p>　　<a href="Tools/SHBuild.zh-CN.html">SHBuild</a> 自举测试用脚本。</p>
<p>　　使用 SHBuild 编译并静态链接构建 SHBuild 。和 <a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 1 SHBuild</a> 类似，直接使用 YSLib 源文件。</p>
<h2 id="toolsscriptsshbuild-self-host-dllsh"><a class="header" href="#toolsscriptsshbuild-self-host-dllsh">Tools/Scripts/SHBuild-self-host-DLL.sh</a></h2>
<p>　　<a href="Tools/SHBuild.zh-CN.html">SHBuild</a> 自举测试用脚本。</p>
<p>　　使用 SHBuild 编译并动态链接构建 SHBuild 。依赖 <code>/usr/lib</code> 中存在的 YFramework 和 YBase 动态库文件。</p>
<h2 id="toolsscriptsshbuild-yslibsh"><a class="header" href="#toolsscriptsshbuild-yslibsh">Tools/Scripts/SHBuild-YSLib.sh</a></h2>
<p>　　作为 <a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 1 SHBuild</a> 公共配置脚本被不同的 stage 1 构建脚本包含。</p>
<p>　　包含脚本依次执行：</p>
<ul>
<li>按需初始化<a href="Tools/../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">变量 <code>SHBuild_ToolDir</code></a> 。</li>
<li>包含脚本 <a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-commonsh"><code>Tools/Scripts/SHBuild-common.sh</code></a> 以按需初始化确定默认构建位置依赖的环境变量。</li>
<li>调用<a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_s1_initconf">函数 <code>SHBuild_S1_InitConf</code></a> 初始化 stage 1 SHBuild 配置。</li>
<li>初始化缓存：
<ul>
<li>按需初始化<a href="Tools/Scripts.zh-CN.html#stage-1-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">变量 <code>S1_CacheFile</code></a> ，默认值为 <code>"$S1_BuildDir/config.cache"</code> 。</li>
<li>初始化缓存相关的内部状态，并调用<a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_loadcache">函数 <code>SHBuild_LoadCache</code></a> 加载缓存。</li>
<li>内部状态决定传递给函数 <code>SHBuild_LoadCache</code> 被缓存的变量的名称模式：<code>(CC CXX LD AR '(C|CXX|LD|AR)FLAGS.*' 'SHBuild_(C|CXX)_.*' 'S1_Cached_.*'</code>)。</li>
</ul>
</li>
<li>初始化 stage 1 公共构建资源和配置：
<ul>
<li>按需初始化<a href="Tools/Scripts.zh-CN.html#%E5%8F%98%E9%87%8F-shbuild_pch_stdinc_h">变量 <code>SHBuild_PCH_stdinc_h</code></a> 。</li>
<li>包含脚本 <a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-common-optionssh"><code>Tools/Scripts/SHBuild-common-options.sh</code></a> 以按需初始化构建工具使用的选项。</li>
<li>初始化变量 <code>INCLUDE_PCH</code> 为指定版本库下 <code>YBase/include/stdinc.h</code> 的路径字符串。</li>
<li>初始化变量 <code>INCLUDES</code> 为版本库目录下的适合作为编译器选项使用的头文件目录列表。</li>
</ul>
</li>
<li>定义函数（参见以下各节）。</li>
</ul>
<p><strong>注意</strong> 这个脚本包含 <code>INC_SHBuild_YSLib</code> 守卫变量检查，默认重复包含只被执行一次。</p>
<h3 id="变量-shbuild_pch_stdinc_h"><a class="header" href="#变量-shbuild_pch_stdinc_h">变量 SHBuild_PCH_stdinc_h</a></h3>
<p>　　预编译头文件名称，默认值为 <code>"$S1_BuildDir/stdinc.h"</code> 。</p>
<h3 id="函数-shbuild_s1_initializepch"><a class="header" href="#函数-shbuild_s1_initializepch">函数 SHBuild_S1_InitializePCH</a></h3>
<p>　　初始化 stage 1 使用的预编译头文件：即调用：</p>
<pre><code class="language-shell">SHBuild_CheckPCH "$INCLUDE_PCH" "$SHBuild_PCH_stdinc_h"
</code></pre>
<h2 id="toolsscriptsshbuild-yslibtxt"><a class="header" href="#toolsscriptsshbuild-yslibtxt">Tools/Scripts/SHBuild-YSLib*.txt</a></h2>
<p>　　构建 YSLib 用的 <a href="Tools/../Development.zh-CN.html#npla1-%E8%84%9A%E6%9C%AC">NPLA1 脚本</a>，包含以下文件：</p>
<ul>
<li><a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-yslib-commontxt"><code>Tools/Scripts/SHBuild-YSLib-common.txt</code></a> ：被 <code>Tools/Scripts/SHBuild-YSLib-build.txt</code> 加载的 NPLA1 脚本。</li>
<li><a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-yslib-buildtxt"><code>Tools/Scripts/SHBuild-YSLib-build.txt</code></a> ：使用 SHBuild 构建 debug 或 release 配置的 YBase 和 YFramework 库的 NPLA1 脚本，被 <code>Tools/install-sysroot.sh</code> 调用，其中 <a href="Tools/SHBuild.zh-CN.html">SHBuild</a> 默认为 <a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 1 SHBuild</a> 。</li>
</ul>
<p>　　调用方式详见<a href="Tools/SHBuild.zh-CN.html#npl-%E6%94%AF%E6%8C%81">关于 NPL 支持的说明</a>。</p>
<p>　　可通过<a href="Tools/Scripts.zh-CN.html#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">外部环境变量</a>配置脚本行为。</p>
<p>　　构建过程中可能检查版本控制系统以计算版本号等元信息，这可被环境变量控制，参见<a href="Tools/Scripts.zh-CN.html#%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E6%94%AF%E6%8C%81">版本控制系统支持</a>。</p>
<p>　　被支持的具体脚本参见以下各节：</p>
<ul>
<li><a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-yslib-commontxt"><code>Tools/Scripts/SHBuild-YSLib-common.txt</code></a></li>
<li><a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-yslib-buildtxt"><code>Tools/Scripts/SHBuild-YSLib-build.txt</code></a></li>
</ul>
<h2 id="toolsscriptsshbuild-yslib-commontxt"><a class="header" href="#toolsscriptsshbuild-yslib-commontxt">Tools/Scripts/SHBuild-YSLib-common.txt</a></h2>
<p>　　这个脚本提供一些公共的库，包括支持类似 <a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-common-optionssh"><code>Tools/Scripts/SHBuild-common-options.sh</code></a> 和 <a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-common-toolchainsh"><code>Tools/Scripts/SHBuild-common-toolchain.sh</code></a> 的选项以环境变量的方式配置，但 C 编译器相关的选项除外（不使用而被忽略）。</p>
<p>　　除关于 <a href="Tools/../Development.zh-CN.html#shell-%E8%84%9A%E6%9C%AC">shell 脚本</a>和 <a href="Tools/../Development.zh-CN.html#npla1-%E8%84%9A%E6%9C%AC">NPLA1 脚本</a>之间的一般差异外，与 <code>Tools/Scripts/SHBuild-common-options.sh</code> 和 <code>Tools/Scripts/SHBuild-common-toolchain.sh</code> 的不同为：</p>
<ul>
<li>通过调用函数进入<strong>构建环境变量检测</strong>并在之后进入回调函数中构建。
<ul>
<li>按需初始化变量。构建环境变量检测可能延迟访问以避免不必要初始化的值。配置时为确定变量的默认值的检查的调用顺序可能不同。</li>
<li>使用 debug 模式时，<code>CXXFLAGS_OPT_DBG</code> 设置为 <code>-O0 -g -D_GLIBCXX_DEBUG_PEDANTIC</code> ，不再被环境变量覆盖。</li>
<li>生成变量默认值的选项之间的空白符可能不同（通常可确保为一个空格）。</li>
<li>附加支持构建应用的配置，在导出的变量的默认值中添加扩展的选项（参见以下相关说明）替换 shell 脚本中指定的默认值（可影响其它默认值）。</li>
<li>附加检查 <a href="https://github.com/google/sanitizers/wiki">sanitizer</a> 。参见以下相关章节的说明。</li>
</ul>
</li>
<li>部分函数具有不同的参数：
<ul>
<li><a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_get_c_cxxflags_warning">函数 <code>SHBuild_Get_C_CXXFLAGS_WARNING</code></a> 具有参数列表 <code>(cxx-name cxx-version)</code> ，接受参数代替<a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-common-toolchainsh">变量 <code>SHBuild_CXX_Name</code></a> 和<a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-common-toolchainsh">变量 <code>SHBuild_CXX_Version</code></a> 的值。</li>
<li><a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_get_cxxflags_warning">函数 <code>SHBuild_Get_CXXFLAGS_WARNING</code></a> 具有参数列表 <code>(cxx-name cxx-version C_CXXFLAGS_WARNING C_CXXFLAGS_IMPL_WARNING CXXFLAGS_IMPL_WARNING)</code> ，接受参数代替<a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-common-toolchainsh">变量 <code>SHBuild_CXX_Name</code></a> 、<a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-common-toolchainsh">变量 <code>SHBuild_CXX_Version</code></a> 、 <a href="Tools/Scripts.zh-CN.html#%E5%8F%98%E9%87%8F-c_cxxflags_warning">变量 <code>C_CXXFLAGS_WARNING</code></a>、<a href="Tools/Scripts.zh-CN.html#%E5%8F%98%E9%87%8F-c_cxxflags_impl_warning">变量 <code>C_CXXFLAGS_IMPL_WARNING</code></a>和<a href="Tools/Scripts.zh-CN.html#%E5%8F%98%E9%87%8F-cxxflags_impl_warning">变量 <code>CXXFLAGS_IMPL_WARNING</code></a>的值。</li>
</ul>
</li>
<li>支持更多变量和默认值。
<ul>
<li>除非另行指定，这些变量在构建环境变量检测中使用。参见以下各节。</li>
<li>在构建动态库或应用程序时，使用空 <code>C_CXXFLAGS_GC</code> 值。
<ul>
<li><strong>原理</strong> 这些选项<a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html">影响编译时代码生成，不总是优化的</a>。对静态库，因为始终无法预测可能需要排除的定义，启用这些选项是合理的。否则，通常从源代码直接确保排除冗余定义更有效。</li>
<li><strong>注释</strong> <code>LDFLAGS_GC</code> 的值仍被保持。对使用空的 <code>C_CXXFLAGS_GC</code> 值构建的目标文件这没有预期的作用，但对其它情形（典型地，静态库）仍然有效。</li>
</ul>
</li>
</ul>
</li>
<li>提供部分和 shell 脚本不同的函数，详见版本库中的 <code>doc/NPL.txt</code> 。</li>
<li>提供单独的缓存机制。
<ul>
<li>配置缓存的变量的名称具有 <code>SHBuild_</code> ，可能具有名称前缀为 <code>S1_</code> 的对应的 <a href="Tools/Scripts.zh-CN.html#stage-1-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">stage 1 共享变量</a>。
<ul>
<li>两者功能相同，但指定 <a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 2 和之后阶段而非 stage 1</a> 的缓存行为。</li>
</ul>
</li>
<li>支持以下被缓存的变量：
<ul>
<li><a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-yslibsh">Stage 1 被缓存的变量</a>的一个子集，名称以 NPLA1 字符串列表定义为：<code>list "CXX" "LD" "AR" "CFLAGS" "CXXFLAGS" "LDFLAGS" "ARFLAGS" "SHBuild_CXX_Name" "SHBuild_CXX_Version"</code> 。</li>
<li>缓存的配置变量，作为配置项取值同 <a href="Tools/Scripts.zh-CN.html#stage-1-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">stage 1 共享变量</a>，且支持 <code>#f</code> 同 <code>"false"</code> ，<code>#t</code> 同 <code>"true"</code> 。
<ul>
<li>变量 <code>SHBuild_Cached_quadmath</code> ：类似变量 <a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-bootstrapsh"><code>S1_Cached_quadmath</code></a> 。</li>
</ul>
</li>
</ul>
</li>
<li><code>SHBuild_CacheFile</code> ：类似变量 <code>S1_CacheFile</code> 。默认值为构建目录下的 <code>config.cache</code> 。</li>
<li><code>SHBuild_CacheMode</code> ：类似变量 <code>S1_CacheMode</code> 。</li>
</ul>
</li>
</ul>
<p>　　这个脚本被 <a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-yslib-buildtxt"><code>Tools/Scripts/SHBuild-YSLib-build.txt</code></a> 加载，并被 <a href="Tools/Scripts.zh-CN.html#toolsinstall-sysrootsh"><code>Tools/install-sysroot.sh</code></a> 间接调用。</p>
<p>　　以下<a href="Tools/Scripts.zh-CN.html#%E5%85%AC%E5%85%B1%E6%9E%84%E5%BB%BA%E9%85%8D%E7%BD%AE%E5%8F%98%E9%87%8F">公共构建配置变量</a>影响脚本的特定行为：</p>
<ul>
<li><code>SS_DebugEnv</code> 的作用当前包括：
<ul>
<li>对环境变量修改时输出修改的变量名和对应的值。</li>
</ul>
</li>
<li><code>SS_Verbose</code> 的作用当前包括：
<ul>
<li>在 <code>LDFLAGS</code> 变量中附加 <code>-mwindows</code> 时提示。</li>
<li>在安装文件时输出安装类型、目标和源。</li>
</ul>
</li>
</ul>
<p>　　脚本支持外部调用这个脚本的命令行设置变量的默认值，以覆盖直接指定构建环境变量检测确定的选项，如：</p>
<pre><code class="language-bash">CXX=clang++ CXXFLAGS='-std=c++11 -O2' Tools/install-sysroot.sh
</code></pre>
<p><strong>警告</strong> 使用预编译头选项和缺陷同 <a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-buildsh"><code>Tools/Scripts/SHBuild-build.sh</code></a> 。其中的特性未指定使用 shell 实现，和后者可能存在 shell 环境中可见的差异。</p>
<p>　　<strong>这个脚本是公开的工具</strong>，被安装脚本部署。</p>
<h3 id="变量-ldflags_dyn_base"><a class="header" href="#变量-ldflags_dyn_base">变量 LDFLAGS_DYN_BASE</a></h3>
<p>　　指定动态库基础链接选项。</p>
<p>　　默认值和平台相关：若为 Win32 环境则使用 <code>-shared -Wl,--dll</code> ，否则为 <code>-shared</code> 。</p>
<h3 id="变量-ldflags_dyn_extra"><a class="header" href="#变量-ldflags_dyn_extra">变量 LDFLAGS_DYN_EXTRA</a></h3>
<p>　　指定动态库附加链接选项。</p>
<p>　　默认值等价于 <code>-Wl,--no-undefined,--dynamic-list-data,--dynamic-list-cpp-new,--dynamic-list-cpp-typeinfo</code> 。</p>
<h3 id="变量-ldflags_dyn"><a class="header" href="#变量-ldflags_dyn">变量 LDFLAGS_DYN</a></h3>
<p>　　指定动态库链接选项。</p>
<p>　　默认值为 <code>$LDFLAGS_DYN_BASE $LDFLAGS_DYN_EXTRA</code> 。</p>
<h3 id="变量-libs_rpath"><a class="header" href="#变量-libs_rpath">变量 LIBS_RPATH</a></h3>
<p>　　用于指定在运行时 ELF 映像需要的动态库的路径的链接器选项。</p>
<p>　　在 Win32 默认不设置，其它平台默认值为 <code>-Wl,-rpath,'\$ORIGIN:\$ORIGIN/../lib'</code> 。</p>
<h3 id="变量-libpfx"><a class="header" href="#变量-libpfx">变量 LIBPFX</a></h3>
<p>　　库前缀。</p>
<p>　　在 Win32 默认不设置，其它平台默认值为 <code>lib</code> 。</p>
<h3 id="变量-dsosfx"><a class="header" href="#变量-dsosfx">变量 DSOSFX</a></h3>
<p>　　动态库文件名后缀。</p>
<p>　　在 Win32 默认值为 <code>.dll</code> ，其它平台默认值为 <code>.so</code> 。</p>
<h3 id="变量-exesfx"><a class="header" href="#变量-exesfx">变量 EXESFX</a></h3>
<p>　　可执行文件名后缀。</p>
<p>　　在 Win32 默认值为 <code>.exe</code> ，其它平台默认不设置。</p>
<h3 id="sanitizer-检查支持"><a class="header" href="#sanitizer-检查支持">Sanitizer 检查支持</a></h3>
<p>　　构建环境变量检测支持 sanitizer ：若在变量 <code>CFLAGS</code>、<code>CXXFLAGS</code>、<code>LDFLAGS</code> 或 <code>SHBuild_CXXFLAGS</code> 中包含启用被支持的 sanitizer 的选项 （以 <code>-fsanitizer=address</code> 起始），配置最终在 <code>CFLAGS</code>、<code>CXXFLAGS</code> 和 <code>LDFLAGS</code> 最后添加自动调整的选项。</p>
<p>　　构建配置支持 ASan、TSan、MSan、UBSan 和 LSan 。Sanitizer 自身支持的系统和编译器详见 sanitizer 的文档。</p>
<p>　　ASan 使用的选项要求和建议参见 <a href="https://github.com/google/sanitizers/wiki/AddressSanitizer#faq">FAQ</a> 。</p>
<p><strong>注意</strong> <a href="https://gcc.gnu.org/legacy-ml/gcc/2014-10/msg00006.html">GCC 不支持 MSan</a> 。MSan 要求标准库<a href="https://github.com/google/sanitizers/wiki/MemorySanitizerLibcxxHowTo">使用带 MSan 的选项构建</a>，否则<a href="https://github.com/google/sanitizers/issues/542">会有假阳性结果</a>。</p>
<p><strong>注意</strong> 具体调整的选项参见脚本具体实现，不保持构建版本之间稳定。* <strong>注意</strong> 构建脚本不保证构建的二进制程序的具体可用性。构建的程序可能因为程序及 sanitizer 实现的缺陷运行时出错，可能另需具体排查原因修复。</p>
<h3 id="扩展选项的默认值"><a class="header" href="#扩展选项的默认值">扩展选项的默认值</a></h3>
<p>　　变量 <code>LDFLAGS</code> 的默认值依次包含：</p>
<ul>
<li>和 shell 脚本中相同的默认值。</li>
<li>生成可执行程序时且要求按需调整链接器参数时，附加的值：
<ul>
<li>当需要生成 Win32 子系统程序时，附加 <code>-mwindows</code> 。</li>
</ul>
</li>
<li>构建动态可执行程序时，变量 <code>LIBS_RPATH</code> 的内容。</li>
<li>构建动态库或应用时，变量 <code>LDFLAGS_DYN</code> 的内容。</li>
</ul>
<h3 id="shbuild-附加构建选项环境变量"><a class="header" href="#shbuild-附加构建选项环境变量">SHBuild 附加构建选项环境变量</a></h3>
<p>　　若回调函数中调用 SHBuild 构建，可在此之前设置<strong>扩展环境变量</strong>并调用函数 <code>SHBuild_Extend_CallVariables</code> 以更新被 SHBuild 使用的环境变量 <code>LDFLAGS</code> 和 <code>LIBS</code> 的值。这些影响 SHBuild 工具调用构建工具的命令行的 <strong>SHBuild 附加构建选项环境变量</strong>，包括：</p>
<ul>
<li><code>SHBuild_CFLAGS</code></li>
<li><code>SHBuild_CXXFLAGS</code></li>
<li><code>SHBuild_LDFLAGS</code></li>
<li><code>SHBuild_LIBS</code></li>
</ul>
<p>　　除非另行指定，SHBuild 附加构建选项环境变量的默认值为空，不被脚本设置。</p>
<h3 id="其它函数和可在外部设置的其它变量"><a class="header" href="#其它函数和可在外部设置的其它变量">其它函数和可在外部设置的其它变量</a></h3>
<p>　　详见版本库中的 <code>doc/NPL.txt</code> 。</p>
<p>　　其它变量不被构建环境变量检测访问，而通过函数调用生效，如 <code>SHBuild_Extend_CallVariables</code> 。</p>
<h2 id="toolsscriptsshbuild-yslib-buildtxt"><a class="header" href="#toolsscriptsshbuild-yslib-buildtxt">Tools/Scripts/SHBuild-YSLib-build.txt</a></h2>
<p>　　这个脚本当前包括和安装相关的流程，实现 <code>Tools/install-sysroot.sh</code> 在 <a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 1 SHBuild 构建后的主要逻辑</a>。</p>
<p>　　脚本支持在构建前自动从网络安装<a href="Tools/../Archives.zh-CN.html#external">外部依赖项二进制归档文件</a>以准备从源代码构建安装 YFramework 库。这仅在环境变量 <code>YSLib_DistDir</code> 被设置非空值时启用。这需要一些外部工具命令的支持：</p>
<ul>
<li>下载归档依次检查以下工具命令：
<ul>
<li><code>wget</code></li>
<li><code>curl</code></li>
<li><strong>注释</strong> 因为 <a href="Tools/../Run.zh-CN.html#%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%8E%AF%E5%A2%83">PowerShell 不被支持</a>，实现不检查<a href="https://daniel.haxx.se/blog/2016/08/19/removing-the-powershell-curl-alias/">对 <code>wget</code> 和 <code>curl</code> 的不兼容别名</a>。</li>
<li><strong>注释</strong> 另见以下环境变量 <code>SS_Offline</code> 的说明。</li>
</ul>
</li>
<li>解压缩归档依次检查以下工具命令：
<ul>
<li><code>bsdtar</code></li>
<li><code>7za</code></li>
</ul>
</li>
<li><strong>注释</strong> 当前不提供这些工具的自动安装。
<ul>
<li><strong>原理</strong> 这些工具广泛可用，在不同环境中具有不同情形。
<ul>
<li><a href="https://techcommunity.microsoft.com/t5/containers/tar-and-curl-come-to-windows/bc-p/3272679">自 Microsoft Windows 10 Insider Build 17063/1809</a> 起，<a href="https://curl.se/windows/microsoft.html">随系统提供 <code>curl</code> 的可执行文件</a> 。</li>
<li>MSYS2 和一些 Linux 发行版等环境通过包管理器提供这些命令行工具。</li>
</ul>
</li>
<li><strong>原理</strong> 这些工具通常被全局安装，可能需要系统管理员权限才能执行安装命令。考虑潜在的<a href="Tools/../Run.zh-CN.html#%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%8E%AF%E5%A2%83">安全性</a>和复杂性问题，本脚本不支持确保提供这个前提。</li>
</ul>
</li>
</ul>
<p>　　脚本使用 <a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-yslib-commontxt"><code>Tools/Scripts/SHBuild-YSLib-common.txt</code></a> 中提供的一些函数。</p>
<p>　　脚本支持以下<a href="Tools/Scripts.zh-CN.html#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">外部扩展环境变量</a>指定构建和部署目标：</p>
<ul>
<li><code>SHBuild_UseDebug</code> 非空时启用构建和安装 debug 配置的库。</li>
<li><code>SHBuild_UseRelease</code> 非空时启用构建和安装 release 配置的库。</li>
<li><code>SHBuild_NoStatic</code> 非空时跳过静态库构建。</li>
<li><code>SHBuild_NoDynamic</code> 非空时跳过动态库构建。</li>
<li><code>SHBuild_No3rd</code> 非空时跳过第三方库安装。
<ul>
<li>对<a href="Tools/../Development.zh-CN.html#%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96%E9%A1%B9">外部依赖项</a>中的库，只安装启用的配置决定的必要的外部依赖。启用的配置由 <code>SHBuild_UseDebug</code> 和 <code>SHBuild_UseRelease</code> 指定。</li>
</ul>
</li>
<li><code>SHBuild_NoDev</code> 非空时跳过可选的开发工具构建和安装。</li>
<li><code>SHBuild_Rebuild_S1</code> 非空时跳过文件存在性检查，总是重新构建 stage 1 SHBuild 。</li>
<li><code>SHBuild_NoDev</code> 非空时跳过 stage 2 SHBuild 后的开发工具构建和安装。</li>
<li><code>YSLib_DistDir</code> 非空时应指定包含一个绝对路径作为储存 YSLib 归档的目录。</li>
</ul>
<p>　　以下<a href="Tools/Scripts.zh-CN.html#%E5%85%AC%E5%85%B1%E6%9E%84%E5%BB%BA%E9%85%8D%E7%BD%AE%E5%8F%98%E9%87%8F">公共构建配置变量</a>影响脚本的特定行为：</p>
<ul>
<li>所有调用 <code>Tools/Scripts/SHBuild-YSLib-common.txt</code> 而生效的公共构建配置变量在此作用相同。</li>
<li><code>SS_DirectExtract</code> 的作用包括：
<ul>
<li>安装下载的归档时，直接用工具命令行覆盖对应位置的文件，而不先解压缩释放到临时目录后再更新。</li>
</ul>
</li>
<li><code>SS_Offline</code> 的作用包括：
<ul>
<li>不检查下载工具命令的可用性。</li>
<li>不使用网络下载资源。</li>
</ul>
</li>
</ul>
<p>　　以下构建时的中间变量可被外部配置，当外部没有配置或为空值时使用默认值：</p>
<ul>
<li><code>SHBuild_SystemPrefix</code> ：系统前缀，在 Sysroot 根路径下决定安装路径。
<ul>
<li>默认值由脚本 <code>Tools/Scripts/SHBuild-YSLib-common.txt</code> 中的函数的调用确定：同 <code>SHBuild_GetSystemPrefix (SHBuild_Platform_Detect SHBuild_Host_OS SHBuild_Host_Arch)</code> 的结果。</li>
<li>脚本 <code>Tools/Scripts/SHBuild-common.sh</code> 中提供 shell 脚本的等价调用：<code>$(SHBuild_GetSystemPrefix (SHBuild_Platform_Detect "$SHBuild_Host_OS" "$SHBuild_Host_Arch"))</code> 。</li>
</ul>
</li>
<li><code>SHBuild_YF_Libs_freetype</code> ：freetype 库链接参数。
<ul>
<li>默认值为 <code>-lfreetype</code> 或 <code>pkg-config --libs freetype2</code> 的输出结果。
<ul>
<li>其中存在 Sysroot <code>libfreetype.a</code> 时默认值为前者。</li>
</ul>
</li>
</ul>
</li>
<li><code>SHBuild_YF_Libs_FreeImage</code> ：FreeImage 库链接参数。
<ul>
<li>默认值为 <code>-lFreeImaged</code> 或 <code>-lFreeImage</code> ，对应 debug 和非 debug 配置。</li>
</ul>
</li>
</ul>
<p>　　这个脚本也可能使用其它变量用于传递参数给被调用的命令，包括一些 <code>SHBuild</code> 预期的变量；后者作为公开接口，但<strong>其具体含义和使用不保证在不同版本间稳定</strong>。</p>
<p>　　在<a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">自举构建 stage 2 SHBuild</a> 前构建安装 YFramework 库时，接受以下环境变量：</p>
<ul>
<li><code>INCLUDES_freetype</code> 指定覆盖包含路径的编译器命令行选项。
<ul>
<li>默认值以 <code>-I</code> 起始，使用版本库目录下的 <code>3rdparty/freetype/include</code> 目录带有适当引号的完整路径。</li>
</ul>
</li>
<li><a href="Tools/../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量 <code>SHBuild_VCS_hg</code> 或 <code>SHBuild_VCS_git</code></a> 指定构建时的版本控制系统，作用参见以下说明。</li>
</ul>
<p>　　在 stage 2 环境中构建其它目标时接受以下<a href="Tools/Scripts.zh-CN.html#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">外部环境变量</a>（部分被 SHBuild 直接以环境变量的方式接受）：</p>
<ul>
<li><code>INCLUDES</code> ：包含路径，和非 SHBuild 中的 <code>Makefile</code> 惯用法含义类似。</li>
<li><code>LDFLAGS</code> ：链接命令行选项。</li>
<li><code>LIBS</code> ：作为命令行选项的链接时使用的库路径。</li>
<li><code>LIBS_RPATH</code> ：非 Windows 平台使用的 <code>rpath</code> 路径。</li>
<li>SHBuild 附加构建选项环境变量：参见 <code>Tools/Scripts/SHBuild-YSLib-common.txt</code> 。其中变量 <code>SHBuild_CXXFLAGS</code> 同时作用在预编译头构建。</li>
</ul>
<h3 id="版本字符串"><a class="header" href="#版本字符串">版本字符串</a></h3>
<p>　　在 stage 1 构建 YFramework 前，通过选择的版本控制系统指定确定版本字符串，可在被构建的 YFramework 库中引用。</p>
<p>　　确定版本字符串时，检查对应的命令，具体方式详见关于<a href="Tools/Scripts.zh-CN.html#%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E6%94%AF%E6%8C%81">版本控制系统支持</a>的描述。若检查都失败，则版本字符串为空串。否则，使用第一个检查成功的命令生成对应的版本字符串。</p>
<p><strong>已知限制</strong> 若使用 <code>git</code> 生成版本字符串，当前同时依赖 <code>sed</code> 命令。</p>
<p>　　若版本字符串非空，则通过宏定义的方式参与之后的构建。当前影响以下源文件所在的翻译单元：</p>
<ul>
<li><code>YFramework/source/YSLib/Core/YCoreUtilities.cpp</code></li>
</ul>
<p>　　在构建前，若被影响的上述翻译单元已被构建，在生成目录中对应的（以 <code>.d</code> 为扩展名的）依赖文件被修改，以添加对版本控制系统中的特定文件的依赖。这能使最新的版本控制系统的修改影响生成的目标代码，而无需手动修改这些翻译单元的源文件。</p>
<p><strong>已知限制</strong> 当前自动更新依赖的实现同时依赖 <code>sed -i</code> 命令。</p>
<h2 id="toolsscriptsshbuild-buildapptxt"><a class="header" href="#toolsscriptsshbuild-buildapptxt">Tools/Scripts/SHBuild-BuildApp.txt</a></h2>
<p>　　NPLA1 应用程序构建脚本。可利用此工具脚本调用 SHBuild 构建特定<em>配置(configuration)</em> 下使用 YSLib 库和基础环境开发的应用程序。</p>
<p>　　<strong>这个脚本是公开的工具</strong>，被安装脚本部署。</p>
<h3 id="基本原理"><a class="header" href="#基本原理">基本原理</a></h3>
<p>　　<strong>配置</strong>是特定用途的一组程序输出的集合。常见软件配置可以区分目标平台，是否为调试配置等。</p>
<p>　　脚本通过设置特定的环境变量并调用 SHBuild 递归扫描指定目录完成构建。其中调用命令由环境变量 <code>SHBuild</code> 指定。若变量 <code>SHBuild</code> 为空，则假定使用脚本程序在 Sysroot 中，由 Sysroot 的布局确定的 SHBuild 的位置作为变量 <code>SHBuild</code> 的默认值。</p>
<p>　　脚本支持区分 debug 和非 debug 配置以及静态和 DLL 配置。详见以下说明。</p>
<p>　　使用 debug 配置总称 debug 模式。使用其它配置总称 release 模式。</p>
<h3 id="调用方式"><a class="header" href="#调用方式">调用方式</a></h3>
<p>　　无参数调用时，显示帮助文本。以第一参数指定<strong>配置名称</strong>，执行脚本直接一次性配置后构建。之后可选的其它参数被脚本传递给 SHBuild ，详见以下的操作说明。</p>
<h3 id="使用须知"><a class="header" href="#使用须知">使用须知</a></h3>
<p>　　脚本依赖 Sysroot 。</p>
<p>　　这个脚本被 <a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-buildpkgsh"><code>Tools/Scripts/SHBuild-BuildPkg.sh</code></a> 调用。</p>
<p>　　当前只支持构建，不支持部署。</p>
<p>　　构建时调用的工具链命令行及配置详见 <a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-yslib-commontxt"><code>Tools/Scripts/SHBuild-YSLib-common.txt</code></a> 的说明。</p>
<p>　　需要先确保源代码可访问。<strong>注意</strong>源代码目录会被递归扫描，建议在目录中只包含所有需要构建的源文件或被包含的文件。</p>
<h3 id="操作说明"><a class="header" href="#操作说明">操作说明</a></h3>
<p>　　一般步骤：</p>
<ul>
<li>新建一个 GNU bash 脚本（以下称为<em>用户构建脚本</em> ），调用此脚本（若无法在 <code>PATH</code> 找到，需要使用完整路径）。</li>
<li>以源代码所在目录的路径作为参数，执行通过此脚本包含的 <code>SHBuild_BuildApp</code> 函数，等待构建完成。</li>
<li>直接包含后的脚本仍可使用无参数调用用户构建脚本查看选项和说明。</li>
</ul>
<p>　　简化操作：也可以不创建用户构建脚本，直接在命令行中执行，例子见<a href="Tools/../GettingStarted.zh-CN.html">入门</a>。</p>
<p>　　若有必要，在调用本脚本之前设置 <code>SHBuild_BuildDir</code> 变量为指定输出文件所在的目录的完整路径，如：</p>
<pre><code class="language-shell">export SHBuild_BuildDir=$(dirname "$0"`/../build)
</code></pre>
<p>　　上述命令行指定相对于用户构建脚本上一层目录的 <code>build</code> 子目录下作为基准输出路径。若不显式设置此变量，工具脚本会指定其默认值为用户构建脚本所在的目录。</p>
<p>　　调用本脚本。脚本会自动加入必要的参数调用 SHBuild ，传递的参数依次具体如下：</p>
<ul>
<li>中间变量 <code>SHBOPT</code> 的值，包括根据配置决定的目录设置选项、<code>-xid,include -xmode,2</code> 以及用户在脚本命令行指定的剩余选项 <code>SHBOPT_BASE</code> 。</li>
<li>传递给本脚本的配置名称以外的可选参数。</li>
<li><code>SHBuild_BuildApp</code> 的值，用于编译器的库配置（包含路径以及使用 DLL 需要的宏定义 <code>-DYF_DLL -DYB_DLL</code> ），由脚本根据静态或动态库配置自动确定，无需重复输入类似选项。</li>
</ul>
<p><strong>特别注意</strong> 脚本执行<strong>以输出基准路径作为当前工作目录</strong>，需要以此为基准指定源文件路径（ <code>SHBuild</code> 使用的 <code>SRCPATH</code> 参数）。</p>
<p>　　通过脚本命令行间接传递给 <code>SHBuild</code> 的参数 <code>SHBOPT_BASE</code> 以及函数 <code>SHBuild_BuildApp</code> 的参数都可以进一步对构建过程进行调整，如 <code>-xj,2</code> 指定 2 个并行线程构建。</p>
<p><strong>注意</strong> 以 SHBuild 作为 <a href="Tools/../Development.zh-CN.html#npla1-%E8%84%9A%E6%9C%AC">NPLA1 脚本</a>解释器时，传递的参数可能会被 SHBuild 截获，而不被继续传递给脚本中调用的 SHBuild 。为避免这种情形，在 <code>-xcmd,RunNPLFile</code> 和本的脚本文件名选项后，可加上 <code>--</code> 分隔其余命令行参数。</p>
<h3 id="配置设置"><a class="header" href="#配置设置">配置设置</a></h3>
<p>　　传递给 SHBuild 指定使用 <code>.配置名称</code> 相对路径（无需另外指定 <code>-xd,</code> 参数）。如 <code>-cdebug</code> 指定输出路径为 <code>.debug</code> 。省略此项默认配置名为 <code>shbuild</code> 。</p>
<p>　　脚本根据以下规则自动检测配置：</p>
<ul>
<li>若配置名称以 <code>debug</code> 起始，或环境变量的 <code>SHBuild_Debug</code> 值非空，则视为使用 debug 配置。</li>
<li>若配置名称以 <code>static</code> 结束，活环境变量 <code>SHBuild_Static</code> 的值非空，则视为使用 static 配置。</li>
</ul>
<h3 id="环境变量-2"><a class="header" href="#环境变量-2">环境变量</a></h3>
<p>　　环境变量 <code>SHBuild_Debug</code> 和 <code>SHBuild_Static</code> 可按上述自动检测配置过程指定配置类型。</p>
<p>　　默认情况下，release 配置会在链接器命令行加入 <code>-mwindows</code> ，<a href="Tools/../Prerequisitions.zh-CN.html">和 debug 配置编译的程序行为不保证相同</a>。设置非空变量 <code>SHBuild_NoAdjustSubsystem</code> 禁用此行为。</p>
<p>　　脚本使用包含 YSLib 库的编译器命令行。脚本已经导出了用于链接器的包含使用 YSLib 库命令行参数的变量 <code>LDFLAGS</code> 和 <code>LIBS</code> 。若有必要，可设置 SHBuild 附加构建选项环境变量（参见 Tools/Scripts/SHBuild-YSLib-common.txt ）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="准备-6"><a class="header" href="#准备-6">准备</a></h1>
<p>　　在开始教程前，掌握以下知识：</p>
<ul>
<li><a href="GettingStarted.zh-CN.html">入门</a></li>
</ul>
<p>　　并对以下内容有基本了解：</p>
<ul>
<li><a href="Development.zh-CN.html">开发说明</a></li>
</ul>
<h1 id="内容目录"><a class="header" href="#内容目录">内容目录</a></h1>
<ul>
<li><a href="Tutorial/Overview.zh-CN.html">综述</a></li>
<li><a href="Tutorial/GUI.zh-CN.html">GUI 应用开发</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基础约定"><a class="header" href="#基础约定">基础约定</a></h1>
<h2 id="关于头文件的补充说明"><a class="header" href="#关于头文件的补充说明">关于头文件的补充说明</a></h2>
<p>　　在<a href="Tutorial/../GettingStarted.zh-CN.html">入门</a>中已经解释了头文件宏的使用。</p>
<p>　　公开的头文件宏的命名是模块路径的直接应用：替换 <code>::</code> 为 <code>_</code> ，加上前缀 <code>YFM_</code> 或 <code>YFM_平台名</code> 。</p>
<p>　　这些宏名直接定义在各个 <code>include</code> 目录的 <code>YModules.h</code> 中。而头文件 <code>&lt;YSBuild.h&gt;</code> 则包含了一系列的 <code>YModules.h</code> 和其它模块的头文件，因此可以直接包含它来简化使用。</p>
<h2 id="命名空间-1"><a class="header" href="#命名空间-1">命名空间</a></h2>
<p>　　YSLib 中不同的次级子项目引入不同的命名空间。</p>
<p>　　关于每个顶级子项目下不同的命名空间参见 <code>doc/YBase.txt</code> 和 <code>doc/YFramework.txt</code> 以及 Doxygen 生成的文档。</p>
<p><strong>注意</strong> 在以下讨论中，若没有特别说明，所有非宏名的标识符都在 <code>namespace YSLib</code> 中。</p>
<p>　　注意避免命名空间使用冲突。除非是在一个很有限的块作用域内，一般而言，<code>using namespace std;</code> 总是不被推荐的，但 <code>using namespace YSLib;</code> 在<strong>非头文件</strong>中则是被允许的。</p>
<p>　　在 YSLib 的头文件中，无论是 <code>using</code> 声明还是 <code>using</code> 指令或是命名空间别名，都是经过<strong>慎重考虑</strong>的，特别是为了实现平台中立的兼容。</p>
<ul>
<li>如 YCLib::Mutex 模块支持标准库的对应接口，即使语言的实现如 libstdc++ 在单线程平台上不提供支持，也通过回退到 YBase::PseudoMutex 而允许不改动用户代码并直接保证空行为。允许不改动用户代码的性质可通过 <code>using namespace platform::Concurrency</code> 实现。</li>
</ul>
<p>　　所有其它不经意的在头文件中使用都应被避免。</p>
<h2 id="标识符命名"><a class="header" href="#标识符命名">标识符命名</a></h2>
<p>　　因为无法完全避免使用不同风格命名的外部依赖，YSLib 强调区分命名的来源而不是使用单一命名风格。</p>
<p>　　YBase 使用和 ISO C++ 标准库相容的风格。YFramework 则约定使用框架名称，其中可能包含一些前缀，如 <code>I</code> 表示只有抽象方法的类（接口类），<code>G</code> 表示用于泛型（与元编程目的相区别）的类模板的名称等。</p>
<p>　　详细的命名规约参见 <code>doc/CommonRules.txt</code> 和 <code>doc/YFramework.txt</code> 。</p>
<h1 id="yslib-应用程序基本模型"><a class="header" href="#yslib-应用程序基本模型">YSLib 应用程序基本模型</a></h1>
<h2 id="程序的启动运行和终止"><a class="header" href="#程序的启动运行和终止">程序的启动、运行和终止</a></h2>
<p>　　启动一个应用一般可以分为两个部分：创建内容；让内容被显示。YSLib 对此提供了整体性的便利解决方案。以下说明以典型的 GUI 程序为例（非 GUI 程序实际上不必要使用特别的支持）。</p>
<p>　　Helper::GUIApplication 模块提供的 <code>GUIApplication</code> 类的单例对象初始化中集成了 GUI 程序必要的初始化。之后，可以部署必要的操作，例如决定哪些内容被初始地呈现。程序通过 Helper::GUIApplication 提供的函数 <code>Execute</code> 调用被封装的<strong>消息循环(message loop)</strong> ，接受用户输入并按需响应。最后，当特定条件被满足时，退出 <code>Execute</code> 函数，程序结束。</p>
<h2 id="消息循环消息和消息队列"><a class="header" href="#消息循环消息和消息队列">消息循环、消息和消息队列</a></h2>
<p>　　消息循环，或称<strong>事件循环(event loop)</strong> ，是交互式应用的典型实现方式。程序通过处理(handling) 不同的<strong>消息(message)</strong> 完成期望的行为。除了少数特殊消息（例如表示“退出”以结束程序的消息），消息循环自身通常不能决定如何处理一个消息，因此需要<strong>分发(dispatching)</strong> 到用户提供程序中。</p>
<p>　　基本的消息循环的是一个<strong>轮询(polling)</strong> 操作，一次循环尝试确定一个需要被处理的消息。所有被处理的消息储存于<strong>消息队列(message queue)</strong> 内。当消息循环从消息队列取得消息时，通常即在队列中删除此消息。适当的操作产生消息发送至消息队列内以待处理。这种机制能让消息之间具有一定的顺序保证。但要注意，为了满足调度的需要，此处的队列并不一定需要是严格先进先出的。YSLib 使用模块 YSLib::Core::YMessage 提供的 <code>Messaging::Message</code> 类表示消息，<code>Messaging::MessageQueue</code> 类表示支持优先级的消息队列。</p>
<p>　　当没有消息需要被处理时即进入<strong>空闲(idle)</strong> 状态，库需要保证消息循环不被立刻终止，可以采取如下操作：</p>
<ul>
<li>发送特定的空闲消息并立即处理。</li>
<li>当可能有其它机制发送消息至消息队列时，放弃处理器资源以便节约能源或（在多任务环境中）使其它程序被调度，预定等待一定时间后再次轮询。</li>
<li>结合以上操作。</li>
</ul>
<p>　　交互式程序中，用户动作和其它外部输入可以被抽象为一个消息。输入消息包含必要的状态数据。用户程序指定此处的响应逻辑，更新特定应用的状态，绘制屏幕图形等。由于一个 GUI 程序在此需要完成的任务具有典型性，可以在更高层次上加以抽象，不一定需要直接控制消息循环。但了解消息循环仍然是必要的。</p>
<h2 id="shell"><a class="header" href="#shell">Shell</a></h2>
<p>　　YSLib 提供称为 Shell 的抽象使交互式程序易于被分隔为不同的实现。每个 Shell 类可以通过覆盖的虚函数 OnGotMessage 提供响应不同的消息一整套逻辑。</p>
<h1 id="进一步阅读-2"><a class="header" href="#进一步阅读-2">进一步阅读</a></h1>
<ul>
<li><a href="Tutorial/GUI.zh-CN.html">GUI 应用开发</a></li>
<li><a href="Tutorial/Configuration.zh-CN.html">程序配置</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="图形支持"><a class="header" href="#图形支持">图形支持</a></h1>
<p>　　YSLib 现阶段不强调图形学功能。作为 GUI 的基础，YSLib 主要在命名空间 <code>Drawing</code> 内提供以下两类图形接口：</p>
<ul>
<li>在 YSLib::Core::YGDIBase 描述图形的位置、大小等几何属性的对象 <code>Point</code> 、<code>Size</code> 和 <code>Rect</code> 。</li>
<li>在 YSLib::Service 中提供简单图形和字形的光栅化、像素操作和块传输等绘制功能。</li>
</ul>
<p>　　在了解 YSLib 开发时会少量涉及上述的第一类接口，需要了解其意义和简单的用法。进一步描述详见接口文档。</p>
<h2 id="标量类型"><a class="header" href="#标量类型">标量类型</a></h2>
<p>　　YSLib 默认使用整数坐标。表示屏幕坐标位置的有符号数类型 <code>SPos</code> 和大小的无符号数类型 <code>SDst</code> 的范围和平台相关，由 YCLib 提供，一般保证至少 16 位，但应避免依赖其具体范围。</p>
<h2 id="类模板和类类型"><a class="header" href="#类模板和类类型">类模板和类类型</a></h2>
<p>　　类模板 <code>GBinaryGroup</code> 表示两个标量的有序对，被用于表示屏幕坐标。以 <code>SPos</code> 作为模板参数的实例 <code>Point</code> 和 <code>Vec</code> 表示点的位置和二维向量，当前是一致的。</p>
<p>　　类 <code>Size</code> 包括两个 <code>SDst</code> 分量，用于表示大小。</p>
<p>　　类 <code>Rect</code> 约定了一个边和屏幕坐标系总是共线的矩形：保存一个左上角位置的 <code>Point</code> 和表示宽度和高度的 <code>Size</code> 对象。</p>
<p>　　一个 Rect 对象可以直接通过位置和大小构造：</p>
<pre><code class="language-cpp">Rect r1(Point(10, 20), Size(40, 50));
Rect r2({10, 20}, {40, 50}); // 同上。
Rect r3(10, 20, 40, 50); // 同上。
Rect r4{10, 20, 40, 50}; // 同上。
</code></pre>
<p>　　类模板 <code>GGraphics</code> 表示<em>二维图形接口上下文</em> ，是一个表示缓冲区的指针（不保证具有所有权）和大小组成的数据结构。一般使用的是其实例 <code>Graphics</code> 和 <code>ConstGraphics</code> 。</p>
<p>　　类 <code>PaintContext</code> 包含了 GUI 绘制中的一些必要信息，其中由 <code>Graphics</code> 对象表示目标，<code>Point</code> 对象表示参考位置，<code>Rect</code> 对象表示需要保证绘制的边界范围。</p>
<h1 id="gui-应用接口概述"><a class="header" href="#gui-应用接口概述">GUI 应用接口概述</a></h1>
<h2 id="shell-和-guistate"><a class="header" href="#shell-和-guistate">Shell 和 GUIState</a></h2>
<p>　　Helper::GUIShell 模块提供的类 <code>Shells::GUIShell</code> 是专用于不同平台 GUI 程序处理的 shell ，它隐藏了控制和响应 GUI 需要处理的具体消息，使用户输入被分发到更高级的 <code>UI::GUIState</code> 类的对象中。</p>
<p>　　GUIState 是模块 YSLib::UI::YGUI 提供的平台中立的 GUI 公共逻辑处理的实现。默认 GUIState 对象预先构造的<strong>单态(monostate)</strong> 对象，即被全局共享，可以储存和 GUI 相关的公共状态。</p>
<p>　　通过 YSLib::UI::YGUI 提供的函数 <code>UI::FetchGUIState</code> 取得取默认图形用户界面公共状态：</p>
<pre><code class="language-cpp">using namespace UI;
auto&amp; state(FetchGUIState());
</code></pre>
<h2 id="事件event"><a class="header" href="#事件event">事件(event)</a></h2>
<p>　　<code>UI::GUIState</code> 的成员函数被 <code>Shells::GUIShell</code> 直接或间接调用以按需构造不同的<strong>事件</strong> 。</p>
<p>　　一般意义的事件本质上是可以容纳回调(callback) 的对象，是发布-订阅模式的实现。用户通过事件提供的接口注册回调，在事件被触发调用时订阅者可以调用这些被预先发布的回调。</p>
<p>　　YSLib 事件由模块 YSLib::Core::YEvent 提供的 <code>GEvent</code> 类模板提供，包含多播支持，即 <code>GEvent</code> 中可以有多个回调函数，在触发事件时依优先级和插入顺序调用这些回调函数。<code>GEvent</code> 支持的回调通过<strong>事件处理器(event handler)</strong> <code>GHEvent</code> 类模板提供，除限定返回类型 <code>void</code> 外，使用方式基本兼容于 <code>std::function</code> （提供 ISO C++ 定义的<strong>可调用对象(callable object)</strong> 作为回调），此外提供两个方面的增强：</p>
<ul>
<li>可比较相等。这意味着 <code>GEvent</code> 不需要保存特定的引用即可支持查询或移除特定回调（若可调用对象自身支持 <code>==</code> 则通过 <code>==</code> 操作定义结果，否则总是认为同类型可调用对象都相等）。</li>
<li>通过 YBase 库模块 YStandardEx::Functional 的 <code>ystdex::make_expanded</code> 模板提供允许比事件处理器提供模板更少参数的可调用对象的支持，允许省略在右边的若干参数。缺乏此支持时，一个可调用对象的函数形参即使未被使用，仍然需要出现在声明的参数列表中，带来一些不便。</li>
</ul>
<p>　　另外，GEvent 的 <code>operator()</code> 会忽略回调抛出的 <code>std::bad_function_call</code> 异常。</p>
<p>　　和消息不同，YSLib 的事件默认总是被同步处理的。不同的事件使用不同的枚举标识，携带特定类型的<strong>事件参数(event argument)</strong> 对象。</p>
<p>　　用户通过给事件提供不同的可调用对象作为回调，在其中可以实现应用程序特定的逻辑。</p>
<h2 id="部件widget"><a class="header" href="#部件widget">部件(widget)</a></h2>
<p>　　部件是 GUI 的可见元素抽象。体现 GUI 逻辑的事件最终被分发到具体的<strong>部件</strong>上，在部件持有的事件上进行响应。</p>
<p>　　部件具有一系列基本的可视化属性，例如位置和大小。其它一些状态决定它如何被绘制以及和其它部件的关系或者具有用户程序关心的数据。YSLib 中的部件实现模块 YSLib::UI::YWidget 提供的 <code>UI::IWidget</code> 接口以及作为基类的 <code>UI::Widget</code> ，通过处理 <code>UI::Paint</code> 事件使其被绘制。</p>
<p>　　基本的部件只能处理 <code>UI::Paint</code> 标识的绘制事件，可以处理其它事件（例如直接响应表示用户输入的事件）的部件称为<strong>控件(control)</strong> 。模块 YSLib::UI::YControl 提供了控件的基类 <code>UI::Control</code> 。其它大部分部件派生于这个类以提供不同的功能。</p>
<p>　　调整部件的特定属性即可以基本完成一个 GUI 应用。</p>
<p>　　模块 YSLib::UI::YWidgetEvent 提供了 UI::VisualEvent 枚举标识默认支持的 GUI 事件，其中不同的枚举项表示不同的 GUI 事件，可能对应不同的事件参数类型。默认支持的事件参数类型都是类类型的右值引用类型，但和标准库的右值引用参数类型不同，约定被转移后状态可预测。</p>
<p>　　从一个控件取得一个指定事件标识的的事件左值，可以使用 YSLib::UI::YControl 提供的函数模板 <code>UI::FetchEvent</code> 。可以直接在取得的事件上进行操作，所以不必要直接声明一个变量。</p>
<pre><code class="language-cpp">using namespace Drawing; // 使用 Drawing::Size 等。模块 YSLib::UI::YControl 已在命名空间 YSLib 中有此声明，若包含了对应的头文件，可以省略。
using namespace UI;
Control ctl(Size(80, 20)); // 创建一个 Control 类型的控件 ctl ，初始大小为 (80, 20) 。
auto&amp; paint_event(FetchEvent&lt;Paint&gt;(ctl)); // 取 ctl 的 UI::Paint 事件，通常是不必要的。

// 使用 lambda 表达式添加回调是简便的做法：
FetchEvent&lt;Click&gt;(ctl) += [](CursorEventArgs&amp;&amp;){
	std::cout &lt;&lt; "Control clicked!" &lt;&lt; std::endl;
};
FetchEvent&lt;Click&gt;(ctl) += []{ // 得力于 GHEvent 允许省略参数的特性，这里可以省略没有用到的形式参数。
	std::cout &lt;&lt; "Control clicked again!" &lt;&lt; std::endl;
};
</code></pre>
<p>　　当 ctl 被点击时，上面 <code>UI::Click</code> 事件上添加的两个回调会被依次执行，在标准输出上输出两行字符串。</p>
<h2 id="指定部件的视图属性"><a class="header" href="#指定部件的视图属性">指定部件的视图属性</a></h2>
<p>　　部件的视图属性包括<strong>位置</strong>和<strong>大小</strong>等。</p>
<p>　　上例中通过指定 <code>Size</code> 对象表示部件初始化时的大小。这个类型和下面涉及的位置以及边界类型都由模块 YSLib::Core::YGDIBase 提供，头文件默认已经被包含在 GUI 中所以不需要显式包含。</p>
<p>　　位置由二维的点 <code>Point</code> 类型表示。此处并没有明确位置是相对于哪个坐标系的。创建部件以后，并没有直接指定部件应在哪被显示，所以这里的位置本身只具有相对意义。</p>
<p>　　也可以通过直接指定 <code>Rect</code> 类型的矩形的<strong>边界</strong>：</p>
<pre><code class="language-cpp">Control ctl2(Rect(10, 20, 40, 20)); // 位置为 (10, 20) ，大小为 (40, 20) 。
Control ctl3({10, 20, 40, 20}); // 同上。
</code></pre>
<p>　　出于动态加载部件的需要，YSLib 提供的部件总是可以通过一个 Rect 值构造以及默认构造（相当于 Rect 为空），因此不限于 <code>UI::Control</code> 使用。</p>
<p>　　在创建部件之后，使用函数 <code>GetLocationOf</code> 、<code>GetSizeOf</code> 和 <code>GetBoundsOf</code> 等查询这些属性；相对地，使用函数 <code>SetLocationOf</code> 、<code>SetSizeOf</code> 和 <code>SetBoundsOf</code> 等设置这些属性。通过这些函数设置位置和大小会分别触发 <code>Move</code> 和 <code>Resize</code> 事件。</p>
<h2 id="视图树和容器"><a class="header" href="#视图树和容器">视图树和容器</a></h2>
<p>　　YSLib 提供了单一的<strong>视图树</strong>结构作为显示视图的抽象。通过指定部件所在的<strong>容器</strong>限定显示的范围。容器自身是一个部件，可以嵌套在另外的部件中。容器中的部件（<strong>子部件</strong>）的位置使用容器部件的边界的左上角作为原点，即位置表示子部件的边界的左上角相对于容器的边界的左上角。这样的结构典型地构成一颗树，只有作为树根的<strong>顶层部件</strong>没有容器。</p>
<p>　　容器通过 <code>UI::IWdiget</code> 提供一般的迭代遍历支持。不是所有容器都支持动态添加子部件。模块 YSLib::UI::YPanel 提供一般的面板容器 <code>UI::Panel</code> 支持这个特性：</p>
<pre><code class="language-cpp">using namespace Drawing;
using namespace UI;
Panel pnl(Size(200, 100));
Control ctl({10, 20, 100, 40});

pnl += ctl; // ctl 作为 pnl 的子部件，在 pnl 左上角的位置 (10, 20) 显示。
yassume(&amp;pnl == FetchContainerPtrOf(ctl)); // 宏 yassume 由 YBase 提供，默认和标准库的宏 assert 行为一致，表示断言；函数 FetchContainerPtr 取得指向容器的指针。
</code></pre>
<h3 id="顶层窗口top-level-window"><a class="header" href="#顶层窗口top-level-window">顶层窗口(top level window)</a></h3>
<p>　　部件最终需要通过顶层部件的 <code>UI::Paint</code> 事件被显示。在独立实现中，顶层部件一般是模块 YSLib::UI::YDesktop 提供的 <code>UI::Desktop</code> 。在<a href="Tutorial/../Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">宿主实现</a>中，由于需要和<a href="Tutorial/../Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">宿主环境</a>的 GUI 集成，使用不同的接口。在一个有桌面环境的宿主平台中，这样的顶层部件一般称为<strong>顶层窗口</strong>。</p>
<p>　　Helper 模块对顶层窗口提供了和平台相关的实现。通过模块 Helper::HostedUI 提供的函数 Host::ShowTopLevel 使一个部件成为一个顶层窗口。</p>
<pre><code class="language-cpp">using namespace UI;
Control ctl(Size(200, 100));

Host::ShowTopLevel(ctl);
</code></pre>
<p>　　对 Windows ，<code>Host::ShowTopLevel</code> 支持更多的样式和扩展样式参数调整宿主窗口。具体使用详见 <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms632680(v=vs.85).aspx">MSDN</a> 。当调用 <code>Host::ShowTopLevel</code> 时，会自动创建具有独立线程和（ Win32 意义上的）消息循环 Windows 窗口，这个过程可能发生阻塞。</p>
<h2 id="常用部件"><a class="header" href="#常用部件">常用部件</a></h2>
<p>　　<code>UI</code> 命名空间下除了 <code>Widget</code> 、<code>Control</code> 、<code>Panel</code> 和 <code>YDesktop</code> 几类直接作为框架必要类型的部件外，还有更多提供不同实用功能的部件。</p>
<p>　　注意，非控件的部件不能取 <code>UI::Paint</code> 外的事件，否则会抛出异常。</p>
<h3 id="uilabel"><a class="header" href="#uilabel">UI::Label</a></h3>
<p>　　这是显示文本标签的部件。</p>
<p>　　简单的用法是创建部件后，修改 <code>Text</code> 属性。它接受的是模块 YSLib::Core::YString 提供的 <code>String</code> 类型的 UCS-2 字符串，可以直接通过 <code>std::u16string</code> 或 <code>const char16_t*</code> 等构造。因此内建的 <code>u</code> 前缀的字面量可以直接用于赋值 <code>Text</code> 。YSLib 中 GUI 的其它部分也使用这样的字符串。</p>
<h3 id="uibutton"><a class="header" href="#uibutton">UI::Button</a></h3>
<p>　　按钮控件。</p>
<p>　　类似 <code>UI::Label</code> 可以显示文本，但它是一个控件，可以点击并添加 <code>UI::Click</code> 事件回调。</p>
<h2 id="动态加载"><a class="header" href="#动态加载">动态加载</a></h2>
<p>　　模块 YSLib::UI::Loader 提供了在运行时读取 <a href="Tutorial/../Features/NPL.zh-CN.html">NPLA1</a> 配置加载部件视图树的 API 。</p>
<p>　　这些 API 当前相对不稳定，可能较容易改变，因此不作详细介绍。具体用法可参照<a href="Tutorial/../Features.zh-CN.html">示例程序 YReader</a> 的源代码。</p>
<h1 id="小结"><a class="header" href="#小结">小结</a></h1>
<p>　　通过以上讨论，读者可以回顾<a href="Tutorial/../GettingStarted.zh-CN.html">入门</a>中的示例，分析其中的各个部分的具体意义。</p>
<p>　　在这个基础上，参阅 Doxygen 文档查找 <code>UI</code> 命名空间下的其它 API 以开发自己的 GUI 应用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="程序配置概述"><a class="header" href="#程序配置概述">程序配置概述</a></h1>
<p>　　因为可移植性需求，YSLib 不直接使用特定平台提供的机制（如 <a href="https://en.wikipedia.org/wiki/Windows_Registry">Windows 注册表</a>）。考虑表达能力和实现冗余，YSLib 不使用 <a href="https://en.wikipedia.org/wiki/INI_file">INI</a> 等简单的配置格式。考虑实现复杂性和用户输入配置的简便性，YSLib 避免使用 <a href="https://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language">SGML</a> 及其派生的标记语言，特别地，<a href="https://en.wikipedia.org/wiki/XML">XML</a> 及其派生语言实现作为配置格式。</p>
<p>　　YSLib 提供相关解决方案为基于 <a href="Tutorial/../Features/NPL.zh-CN.html">NPL 派生实现 NPLA1</a> 的配置，在 YFramework 模块 NPL::Configuration 中提供相关 API 。</p>
<h1 id="规则和意义"><a class="header" href="#规则和意义">规则和意义</a></h1>
<p>　　除了整个文件构成的 NPL 表达式外，每一个 NPL 表达式的第一个项应为标识符，表示配置项的名称。其后的项可以是字符串或列表，表示配置项的内容。</p>
<h1 id="用例"><a class="header" href="#用例">用例</a></h1>
<p>　　YFramework 的一部分使用配置决定程序运行时需要的信息，如字体文件的位置。参照<a href="Tutorial/../Run.zh-CN.html">程序运行</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="术语概要"><a class="header" href="#术语概要">术语概要</a></h1>
<p>　　本文档概述及约定 YSLib 基本的概念含义，主要用于<a href="Development.zh-CN.html">开发</a>。</p>
<p>　　一些术语概念适用各种不同的上下文，主要用于开发过程中的设计和规则说明。</p>
<p>　　术语以列表形式的条目列出。通过使用元语言语法 <em>&lt;相关范畴/上下文&gt;</em> 标记指示被修饰或被限定的概念的适用范围。不需要消歧义时，省略标记。</p>
<h1 id="通用领域"><a class="header" href="#通用领域">通用领域</a></h1>
<p>　　除非另行指定，适用于任意<a href="Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">上下文</a>；但存在更具体的上下文的特定概念定义时，优先适用后者。</p>
<h2 id="经验语义"><a class="header" href="#经验语义">经验语义</a></h2>
<p>　　经验语义解释的术语的含义总是假定可被实证，不需要进一步解释。</p>
<p>　　元语言中的标记使用经验语义。标记可被本文档中已归类的章节提供。</p>
<p>　　本文档中非形式地使用在特定理论中严格定义的、和<a href="Terminology.zh-CN.html#%E9%80%9A%E7%94%A8%E9%A2%86%E5%9F%9F">本章</a>的条目具有逻辑上相容的含义的概念时，不进一步解释。</p>
<h2 id="自指"><a class="header" href="#自指">自指</a></h2>
<p>　　<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E6%8C%87"><strong>自指</strong></a>是概念定义形式上的自我指涉。</p>
<p><strong>示例</strong> “<a href="Terminology.zh-CN.html#%E9%80%9A%E7%94%A8%E9%A2%86%E5%9F%9F">本章</a>”是关于位置的自指。</p>
<p>　　有必要通过自指定义的概念，隐含引入定义内容的过程的<a href="https://zh.wikipedia.org/zh-cn/%E5%BE%AA%E7%92%B0%E8%AB%96%E8%AD%89">循环论证</a>。这些概念的精确内涵和外延依赖<a href="Terminology.zh-CN.html#%E7%BB%8F%E9%AA%8C%E8%AF%AD%E4%B9%89">经验语义</a>的实证，否则在自然语言语言中可能需要循环论证而失去定义的意义。此处的条目内容（包括链接的外部定义）仅仅供参考，而不是精确的内涵和外延。为简化复杂度，限制自指定义的概念都是名词。</p>
<p><strong>示例</strong> 上述注释中，<strong>内涵</strong>和<strong>外延</strong>约定为以下<a href="Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">非自指</a>的概念，因此可依据本文档给出明确的定义来源。</p>
<p><strong>示例</strong> 在程序语言理论中，上下文(context) 指形式上可继续补充内容的构造；文档可能非形式地使用和这个含义相容的概念。</p>
<ul>
<li>实体(entity) ：任意被自然语言表达的目标；不需要通过自然语言先验定义；参见经验语义。</li>
<li>语义(semantics) ：参见经验语义。</li>
<li>经验(experience) ：参见哲学或一般等价的经验语义。</li>
<li>范畴(category) ：参见<a href="https://zh.wikipedia.org/zh-cn/%E8%8C%83%E7%95%B4%E8%AE%BA">范畴论</a>。</li>
<li>态射(morphism) ：参见范畴论。</li>
<li>归纳(induction) ：一种态射，可操作性参见经验语义。</li>
<li>方法学(methodology) ：一个归纳经验得到的范畴；参见哲学或一般等价的经验语义。</li>
<li>方法(method) ：方法学的一个子范畴；可操作性参见经验语义。</li>
<li>概念(concept) ：参见逻辑学。</li>
<li>上下文(context) ：一种概念范畴适用的态射；参见经验语义。</li>
</ul>
<h2 id="非自指"><a class="header" href="#非自指">非自指</a></h2>
<p>　　包含多个一般领域的概念。</p>
<ul>
<li><em>&lt;名词&gt;</em> 形式(form) ：参见经验语义和数学。</li>
<li><em>&lt;概念&gt;</em> 内涵：参见逻辑学。</li>
<li><em>&lt;概念&gt;</em> 外延：参见逻辑学。</li>
<li><em>&lt;概念&gt;</em> 定义(definition) ：确定概念内涵和外延的方法；参见任意一种形式逻辑学。</li>
<li><em>&lt;动词&gt;</em> 抽象(abstracting) ：通过经验语义定义概念范畴或集合的方法。</li>
<li><em>&lt;名词&gt;</em> 抽象(abstraction) ：<em>&lt;动词&gt;</em> 抽象的结果。</li>
<li><em>&lt;动词&gt;</em> 封装(encapsulating) ：从某一个范畴中抽象一个子范畴的方法。</li>
<li><em>&lt;名词&gt;</em> 封装(encapsulation) ：<em>&lt;动词&gt;</em> 封装的结果。</li>
<li>规范(specialization) ：一种提供在特定上下文中可定义的描述的封装，参见工程学（特别是软件工程学，下同）。</li>
<li>接口(interface) ：一种封装，参见工程学。</li>
<li>实现(implementation) ：一种封装，参见工程学。</li>
<li>重用(reusing) ：参见经验语义和工程学。</li>
<li>不变性(invariance) ：满足某种<a href="https://zh.wikipedia.org/zh-cn/%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB">等价关系</a>（自反、传递、对称的<a href="https://zh.wikipedia.org/zh-cn/%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB">二元关系</a>）。</li>
<li>不变量(invariant) ：具有不变性的实体。参见数学和契约式程序设计。</li>
<li>状态(state) ：可以和其它实体关联的、可在某个上下文中保持变化或不变的实体。同一状态总是保持变化或保持不变。状态变化的含义参见经验语义、数学或另行指定。
<ul>
<li>可变状态(mutable state) ：在某个上下文中满足以下条件的状态：
<ul>
<li>可能映射到超过一个其它状态。</li>
<li>存在对应的重新配置可变状态映射到不同的其它状态的<em>改变(mutate)</em> 操作。</li>
</ul>
</li>
<li>不可变状态(immutable state) ：不是可变状态的状态。</li>
</ul>
</li>
<li><em>&lt;动词&gt;</em> 派生(deriving) ：基于重用的操作。</li>
<li><em>&lt;名词&gt;</em> 派生(derivation) ：<em>&lt;动词&gt;</em> 派生的结果。</li>
</ul>
<h1 id="计算机科学"><a class="header" href="#计算机科学">计算机科学</a></h1>
<p>　　包含多个关于数学、逻辑学和计算机领域的概念。</p>
<ul>
<li><em>&lt;动词&gt;</em> 形式化(formalize) ：建立数学意义上的严格<a href="Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">形式</a>。</li>
<li><em>&lt;名词&gt;</em> 形式化(formalization) ：建立形式的过程。</li>
<li>形式方法(formal method) ：包含形式化的<a href="Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">方法</a>。</li>
<li><em>&lt;动词&gt;</em> 建模(model) ：建立形式化输出的形式。</li>
<li><em>&lt;名词&gt;</em> 模型(model) ：建模的结果。</li>
<li>集合(set) ：一种数学模型，参见 <a href="https://zh.wikipedia.org/zh-cn/%E5%86%AF%E8%AF%BA%E4%BC%8A%E6%9B%BC-%E5%8D%9A%E5%86%85%E6%96%AF-%E5%93%A5%E5%BE%B7%E5%B0%94%E9%9B%86%E5%90%88%E8%AE%BA">NBG 集合论</a>。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E7%B1%BB_%28%E6%95%B0%E5%AD%A6%29">类</a>(class) ：参见 NBG 集合论和范畴论。</li>
<li>真类(proper class) ：参见 NBG 集合论和范畴论。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB">二元关系</a>(binary relationship) ：一种基于集合上定义的数学实体。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB">等价关系</a>(equivalence relationship) ：<a href="https://zh.wikipedia.org/zh-cn/%E8%87%AA%E5%8F%8D%E5%85%B3%E7%B3%BB">自反的(reflexive)</a> 、<a href="https://zh.wikipedia.org/zh-cn/%E5%AF%B9%E7%A7%B0%E5%85%B3%E7%B3%BB">对称的(symentric)</a> 且<a href="https://zh.wikipedia.org/zh-cn/%E4%BC%A0%E9%80%92%E5%85%B3%E7%B3%BB">传递的(transitive)</a> 二元关系。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB">偏序关系</a>(paritial order relationship) ：自反的、<a href="https://zh.wikipedia.org/zh-cn/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%85%B3%E7%B3%BB">反对称的(asymentric)</a> 且传递的的二元关系。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB">严格偏序关系</a>(paritial order relationship) ：<a href="https://zh.wikipedia.org/zh-cn/%E8%87%AA%E5%8F%8D%E5%85%B3%E7%B3%BB#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">反自反的(irreflexive)</a>、反对称的且传递的的二元关系。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E7%AD%89%E4%BB%B7%E7%B1%BB">等价类</a>(equivalence class) ：等价关系划分集合得到的类。</li>
<li>可计算性(computability) ：参见数学。
<ul>
<li>通常由 <a href="https://zh.wikipedia.org/zh-cn/%E9%82%B1%E5%A5%87%EF%BC%8D%E5%9B%BE%E7%81%B5%E8%AE%BA%E9%A2%98">Church-Turing 论题</a>定义。</li>
</ul>
</li>
<li>计算(computation) ：由可计算性定义的操作的等价类，可表现为特定的外在的行为(behavior) 。</li>
<li>计算模型(computation model) ：描述计算的模型，是对计算建模的结果。</li>
<li>序列(sequence) ：有序集合。</li>
<li>形式语义(formal semantics) ：使用形式化的方式表达的语义。</li>
<li>形式语言(formal language) : 特定形式化的方式确定的元素的全集。
<ul>
<li><strong>注释</strong> 这也可能作为<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>对应的某种形式语义。这同时是语言对应的<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">语法</a>的外延。</li>
</ul>
</li>
<li>计算复杂度(computational complexity) ：某个形式化计算模型中以有限的正整数作为模型决定的规模(metric) 作为参数的渐进(asymptotic) 性质确定的度量。
<ul>
<li>时间复杂度(time complexity) ：描述步骤规模的计算复杂度。</li>
<li>空间复杂度(space comlexity) ：描述存储规模的计算复杂度。</li>
</ul>
</li>
<li>并发(concurrency) ：计算的非确定性的(non-deterministic) 组合(composition) 的性质。
<ul>
<li>并发的(concurrent) ：已被并发方式组合的。</li>
</ul>
</li>
<li>并行(parallelism) ：确定性的(deterministic) 计算行为蕴含的可提升渐进效率(asymptotic efficiency) 而不改变计算预期的其它行为的性质。
<ul>
<li>并行的(parallel) ：已蕴含并行的。</li>
<li>可并行化的(parallelizable) ：允许改变而蕴含并行的。</li>
<li><strong>注释</strong> 渐进效率可使用渐进形式的复杂度描述。</li>
<li><strong>注释</strong> 一个表达渐进效率的具体例子是<a href="https://en.wikipedia.org/wiki/Big_O_notation">大 O 记号(en-US)</a> 。</li>
</ul>
</li>
<li>二进制(binary) ：实数的二进位制表示格式。</li>
</ul>
<h1 id="规范"><a class="header" href="#规范">规范</a></h1>
<p>　　包含提供<a href="Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">规范</a>的<a href="Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">实体</a>定义。</p>
<ul>
<li>符合性(conformance) ：满足规范的实现性质。</li>
<li>要求(requirement) ：规范对实现的作为判断符合性的条件。</li>
<li>约束(constraint) ：可被<a href="Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">形式</a>表达，用于限制和明确行为的规则。不一定使用形式表达。</li>
<li>违反(violation) ：对约束指定的条件的不满足。</li>
<li>过时的(obsolesent) ：已确认因为存在更合适的选项而建议不继续使用的（接口/特性）。</li>
<li>废弃的(deprecated) ：过时的但因为兼容性等原因，暂时保留的、一般可提供替代的接口或特性。</li>
<li>语言：<a href="Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">模型</a>或者非形式地其它方式定义的一种<a href="Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">接口</a>。</li>
<li><em>&lt;语言&gt;</em> 接口(<em>&lt;language&gt;</em> interface) ：和表达<a href="Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">语义</a>有关的语言的可见的特征。</li>
</ul>
<p>　　包含关于语言的规范的定义。</p>
<ul>
<li><em>&lt;语言&gt;</em> 实现(<em>&lt;language&gt;</em> implementation)：对语言规则中的要求的<a href="Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87"><em>&lt;非自指&gt;</em> 实现</a>。</li>
<li><em>&lt;语言&gt;</em> 人类接口(human interface) ：语义仅对人类有意义（内容改变时可以导致语义的差异性），不提供为涉及作为计算模型实现的语言接口。</li>
<li><em>&lt;语言&gt;</em> 机器接口(machine interface) ：对机器（或特定语言实现的特定部分）有意义的语言接口。注意不同语言实现组成部分可以不同。
<ul>
<li><strong>示例</strong> 对 <a href="https://zh.wikipedia.org/zh-cn/C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8">C 语言的预处理器</a>，C 源代码中的空白符是机器接口，而对<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">翻译器</a>来说则不是。就源代码而言，机器接口总是人类接口的子集。</li>
</ul>
</li>
<li><em>&lt;语言&gt;</em> 特性(*&lt;language&gt; feature) ：作为功能提供的人类接口。</li>
<li>语言规则(language rule) ：约定可实现及应被实现的语言接口的描述，可包含语言特性的表达。</li>
<li>语言规范(language specialization) ：包含正式的(normative) 的语言规则的集合的<a href="Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">规范</a>；或称语言规格说明。</li>
<li>语言实现(language implementation) ：语言提供的接口的实现，是语言的表现形式，可以是具体语言实现或抽象语言实现之一。
<ul>
<li>具体语言实现(concreate language implementation) ：能最终完全表达为可预测的物理现象一一对应的表达<a href="Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">可计算性</a>的实现，一般应为程序。</li>
<li>抽象语言实现(abstract language implementation) ：非具体语言实现的语言实现。形式意义的标准定义的语言属于此类。</li>
</ul>
</li>
<li>派生语言实现(derived language implementation) ：派生已有实现的部分或全部得到的语言实现。以下简作“派生实现”。</li>
<li><em>&lt;语言&gt;</em> 实现环境(environment of implementation) ：对应特定语言实现的特定不变状态（对机器来说可以是配置项，对人来说不确定，所以一般忽略）的集合。</li>
<li><em>&lt;语言&gt;</em> 互操作(interoperation) ：不同的语言实现环境中发生的交互。</li>
<li><em>&lt;语言&gt;</em> 嵌入实现(embedded implemenation) ：在现有的其它语言实现上建立的可共享部分实现环境支持互操作的语言实现。</li>
<li>宿主语言(host language) ：提供嵌入实现的现有实现中使用的语言。</li>
<li>客户语言(guest language) ：嵌入实现中被宿主语言支持实现的语言。</li>
<li>未定义的(undefined) ：可能导致违反<a href="Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">规范</a>的约束但语言规范同时没有要求提供任何可能影响<a href="Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">符合性</a>的保证（如具有诊断消息）的。
<ul>
<li><strong>注释</strong> 表示置于语言规则下的行为等不可预测。</li>
</ul>
</li>
<li>良定义的(well-defined) ：明确地非未定义的。</li>
<li>未指定的(unspecified) ：<a href="Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">规范</a>隐式或显式地允许但不要求唯一确定的至少一个实现选项。
<ul>
<li><strong>注释</strong> 通常允许多种不同的选项；但在特定实现配置下，规则中未指定的选项也可被限制为只有一种可行的选项。</li>
<li><strong>注释</strong> 同一个实现或者不同实现可能确定地或非确定地选取不同的选项而不保证表现一致。</li>
</ul>
</li>
<li>由实现定义的(implementation-defined) ：取决于各个具体语言实现的，要求有文档说明。</li>
<li>由派生实现定义的(derived-implementation-defined) ：取决于各个派生语言实现的，要求除存在默认定义或被派生实现的部分有明确的文档说明。</li>
</ul>
<h1 id="程序设计语言"><a class="header" href="#程序设计语言">程序设计语言</a></h1>
<p>　　提供上下文 <em>&lt;程序设计语言&gt;</em> ，特别是语言规范的定义。</p>
<p>　　主要用例参见 <a href="Features/NPL.zh-CN.html">NPL</a> 。</p>
<ul>
<li>广义实体：<em>&lt;通用领域&gt;</em> 实体。语言抽象的目标，不另行定义（意义最终取决于自然语言）。</li>
<li>名称(name) ：一种特殊的可比较相等的广义实体，专用于和另一个的广义实体关联。</li>
<li><em>&lt;动词&gt;</em> 指称(denote) ：名称对广义实体的关联动作。</li>
<li><em>&lt;名词&gt;</em> 指称(denotation) ：被名称指称而关联的实体。</li>
<li>实体(entity) ：非名称的广义实体。</li>
<li>表示(representation) ：以一个符合某种形式的约束的实体指称另一个实体。</li>
<li>符号(symbol) ：<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>允许的不使用其它对象表示的对象。符号可实现名称。</li>
<li>字母表(alphabet) ：符号在语言中的全集。</li>
<li>串(string) ：可能重复出现的符号的有限序列。</li>
<li>文法(grammar) ：描述任意的可形式化的语言规则。</li>
<li>语法(syntax) ：以语言中的串作为基本元素，描述语言的字面(literal) 结构模式(pattern) 的语言规则，通常是文法的一部分。</li>
<li>语义(semantics) ：非语法的考虑逻辑上的释义(interpretation) 或含义(meaning) 的规则、原理和过程，通常可被语法以外的文法描述并可约束含义的表达。</li>
<li>实例(instance) ：具有代表性含义的集合的元素。</li>
<li>代码(code) ：任意有限的语言的实例片段组成的语法范畴。</li>
<li>伪代码(pseudo code)：抽象语言实现的语言的代码。
<ul>
<li><strong>注释</strong> 习惯上和具体语言实现代码完全一致的代码可以不作为伪代码考虑。</li>
</ul>
</li>
<li>程序(program) ：具体语言实现接受的以代码表示的输入，或被变换后对应的输出。</li>
<li>数据(data) ：程序处理的一般信息。
<ul>
<li><strong>注释</strong> 除以下的编码外，通常不直接作为代码处理。</li>
</ul>
</li>
<li>编码(encode) ：变换数据为确切格式的代码。
<ul>
<li><strong>注释</strong> 格式通常使用语言定义。</li>
</ul>
</li>
<li><em>&lt;名词&gt;</em> 编码(encoding) ：经编码得到的结果。
<ul>
<li><strong>原理</strong> 相对被编码的数据，因可预测格式，这可能更容易处理。因此，同时可能被视为数据。</li>
</ul>
</li>
<li>解码(decode) ：变换确切格式的代码为数据。
<ul>
<li><strong>注释</strong> 编码和解码可以是对应可逆的。</li>
</ul>
</li>
<li>行为(behavior) ：语言实现或在满足符合性的具体语言实现中的程序的外部表现。
<ul>
<li>基于可操作性考虑，一般仅约束实现的机器<a href="Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">接口</a>。</li>
<li><strong>注释</strong> 程序的行为是具体的<a href="Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算行为</a>的实例。</li>
</ul>
</li>
<li>可观察行为(observable behavior) ：影响语言实现环境中外部的行为。
<ul>
<li><strong>注释</strong> 语言可通过在一般的行为上添加特定附加限制规定其具体外延。</li>
</ul>
</li>
<li>计算作用(computational effect) ：可被某个形式化计算模型描述的行为。</li>
<li>翻译(translation) ：不同语言的程序之间的变换，可作为语言实现的形式。
<ul>
<li><strong>注释</strong> 输入和输出具有相同表示的恒等变换不被视为翻译。</li>
</ul>
</li>
<li>IR（intermediate representation ，中间表示）：翻译过程中使用的和输入及输出都不同的表示。</li>
<li>翻译器(translator) ：实现翻译的程序。</li>
<li>运行(run) ：实现程序或组成程序的实体的行为的动作。</li>
<li>加载(load) ：运行程序或组成程序的实体时从实现环境取得相关实体的动作，可蕴含创建这些实体的副本或翻译其中的代码到特定形式。</li>
<li>执行(execute) ：处理程序或组成程序的实体，使这些实体或实体的副本作为资源被消费而蕴含这些实体被运行，同时可能蕴含消费实现环境的其它资源。
<ul>
<li><strong>注释</strong> 执行强调资源的消费，是运行的子集。资源被消费后不再可用。因此，除非同时蕴含资源的<em>再生(reclaim)</em> ，被执行的同一实体不预期被再次执行。再生资源包括实体加载时翻译或取得副本，及实现环境中补充的替代资源。</li>
</ul>
</li>
<li>解释(interpretation) ：通过不依赖显式指定的附加的程序翻译而直接运行表现行为的具体语言实现的形式。</li>
<li>解释器(interpreter) ：实现解释的程序。
<ul>
<li><strong>注释</strong> 解释器是翻译器的真子集。</li>
</ul>
</li>
<li>编译(compilation) ：通过依赖显式指定的附加的程序翻译而运行翻译的输出表现行为的具体语言实现的形式。
<ul>
<li><strong>注释</strong> 典型的编译以生成 IR 作为附加的程序翻译过程。</li>
</ul>
</li>
<li>编译器(compiler) ：实现编译的程序。
<ul>
<li><strong>注释</strong> 编译器是翻译器的真子集。</li>
</ul>
</li>
<li>源语言(source language) ：翻译的输入的语言。</li>
<li>目标语言(target language) ：编译的输出的语言。</li>
<li>转译器(transpiler) ：源语言和目标语言都能作为典型的源语言的翻译器。
<ul>
<li><strong>注释</strong> 或称为<strong>源到源翻译器(source-to-source translator)</strong> 。</li>
</ul>
</li>
<li>转译编译器(transcompiler) ：源语言和目标语言都能作为典型的源语言的编译器。
<ul>
<li><strong>注释</strong> 或称为<strong>源到源编译器(source-to-source compiler)</strong> 。</li>
<li><strong>注释</strong> 通常转译器需要明确的 IR ，所以都是转译编译器。</li>
</ul>
</li>
<li>源代码(source code) ：源语言编码的代码。</li>
<li><em>&lt;翻译&gt;</em> 目标代码(target code) ：目标语言编码的代码。</li>
<li>目标代码(code code) ：编译器输出的代码。
<ul>
<li><strong>注释</strong> 编译器输出的目标代码是翻译的目标代码的特例，一般具有<a href="Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">二进制</a>编码。</li>
</ul>
</li>
<li>源程序(source program) ：形式为作为翻译的输入的源代码程序。</li>
<li>复杂度(complexity) ：以程序的规模作为参数的关于程序的直接执行的<a href="Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算复杂度</a>。</li>
<li>元语言(metalanguage) ：描述其它语言的语言。</li>
<li>对象语言(object language)：被元语言操作或实现的语言。</li>
<li>元编程(metaprograming) ：使用元语言编程。</li>
<li>反射(reflection) ：元语言和对象语言相同的元编程。</li>
<li>具现(reification) ：在对象语言中以数据模型作为关联实体以表示程序的语义。</li>
<li>诊断(diagnostics) ：明确的对特定预期或非预期执行的行为的响应的总和。</li>
<li>诊断消息(diagnostic message) ：用于和用户交互的表现诊断的告知及提示。</li>
<li>未定义行为(undefined behavior) ：<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">未定义的</a>行为。</li>
<li>良定义行为(well-defined behavior) ：<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">良定义的</a>行为。</li>
<li>未指定行为(unspecified behavior) ：<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">未指定的</a>行为。
<ul>
<li><strong>注释</strong> 由实现选取<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规范</a>中可能允许的指定行为的不确定选项，这些选项可能由显式或隐式的语言规则确定。</li>
<li><strong>注释</strong> 推论：由实现定义的行为是未指定行为。在本文档中，为最小化依赖，不在正式规则中明确这些关系。</li>
</ul>
</li>
<li>语言特性(language feature) ：语言提供的功能接口，可以是具体语言特性或抽象语言特性之一。</li>
<li>具体语言特性(concrete language feature) ：完全没有派生语言实现定义的语言特性。</li>
<li>抽象语言特性(abstract language feature) ：非具体语言特性的语言特性。</li>
<li>外部环境(external environment) ：和程序及被翻译的程序没有交集的和实现环境无关的状态。</li>
<li>外部表示(external representation) ：具有特定形式的用于和外部环境交互的表示。</li>
<li>内部表示(internal representation) ：非外部表示的表示。</li>
<li>外部编码(external encoding) ：程序和外部环境交互使用的编码。</li>
<li>内部编码(internal encoding) ：非外部的编码。</li>
<li>可编程性(programmability) ：允许使用程序提供实现的性质。</li>
<li>API（application programming interface ，应用程序编程接口）：提供可编程性以实现程序之间交互的接口。</li>
<li>ABI（application binary interface ，<a href="https://zh.wikipedia.org/zh-cn/%E5%BA%94%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8E%A5%E5%8F%A3">应用程序二进制接口</a>）：提供可编程性以实现二进制编码的程序之间交互的接口。
<ul>
<li><strong>注释</strong> ABI 可以是明确指定了二进制形式的程序之间的 API ，也可以是不依赖二进制编码实现的程序的 API 的实现细节。</li>
</ul>
</li>
</ul>
<h1 id="计算机体系结构"><a class="header" href="#计算机体系结构">计算机体系结构</a></h1>
<p>　　提供上下文 <em>&lt;计算机体系结构&gt;</em> ，特别是作为<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言实现</a>补充的定义。</p>
<ul>
<li>指令(instruction) ：构成代码的具有有限的表示的基本单元，其表示一般具有<a href="Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">二进制</a>编码。
<ul>
<li><strong>注释</strong> 指令序列可作为一种<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">目标代码</a>的形式，可实现<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">程序</a>。</li>
<li><strong>注释</strong> 典型地，指令是通过特定的机器的实现支持，即<em>机器指令(machine instruction)</em> 。这些机器可以是物理的(physical) 或虚拟的(virtual) 。一般物理的机器由特定的机器硬件直接提供指令功能实现的支持，而虚拟的机器指通过软件方式在其它硬件的基础上提供适配支持。</li>
</ul>
</li>
<li>指令集(instruction set) ：通过指令的集合提供<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">可编程</a>功能的<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">接口</a>。
<ul>
<li><strong>注释</strong> 指令集是提供接口为目的设计的具有相近格式的指令构成的统一<a href="Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">规范</a>，而非任意指令的集合。</li>
</ul>
</li>
<li>ISA（instruction-set architecture ，<a href="https://zh.wikipedia.org/zh-cn/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%A7%8B">指令集架构</a>）：依赖和蕴含特定指令集设计的程序之间交互的接口，包括指令集和<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">实现环境</a>的相关假设。
<ul>
<li><strong>注释</strong> 实现环境假设可蕴含明确的 ABI 和指令集以外的配置。</li>
<li><strong>注释</strong> ISA 可作为<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">具体语言实现</a>的一部分。</li>
<li><strong>注释</strong> ISA 可为特定的物理的或虚拟的机器设计，而不需要具有适应不同机器的<em>可移植性(potability)</em> 。</li>
<li><strong>注释</strong> 典型地，ISA 是软件实现<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">可编程性</a>的最底层次的<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">机器接口</a>；更低层次的接口通常依赖不能被纯软件方式访问的机器实现细节。但这并非绝对。</li>
</ul>
</li>
<li>本机语言(native language) ：通过 ISA 直接支持的<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">目标代码</a>实现的语言。</li>
<li>地址(address) ：在实现中指定实体位置的<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">编码</a>。</li>
<li>地址空间(address space) ：映射到地址的操作中，地址的陪域(codomain) 。</li>
<li>寻址(addressing) ：在地址空间中确定实体关联的地址。</li>
<li>CPU（central processing unit，<a href="https://zh.wikipedia.org/zh-cn/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8">中央处理单元</a>) ：带有运算部件和控制部件，允许对物理计算资源寻址的物理 ISA 的通用实现。
<ul>
<li><strong>注释</strong> CPU 是 ISA 的主要实现。</li>
<li>物理的实现又称为中央处理器。强调具有<em>缓存(cache)</em> 时，又称为中央处理机。</li>
<li>除非另行指定，讨论特定的（物理）机器的体系结构时，默认指 CPU 支持的 ISA 。</li>
</ul>
</li>
<li>GPU（graphics processing unit，<a href="https://zh.wikipedia.org/zh-cn/%E5%9C%96%E5%BD%A2%E8%99%95%E7%90%86%E5%99%A8">图形处理单元</a>）：带有图形处理功能的物理 ISA 的专用实现。
<ul>
<li><strong>注释</strong> GPU 是非通用 ISA 的常见主要实现。</li>
<li>物理的实现又称为图形处理器或显示核心，因其主要以处理 2D/3D 图形计算而得名。</li>
<li>但 GPU 也能适用于比 CPU 更（计算时间和能效意义上）高效的特定计算任务，不一定和图形处理相关，即 <a href="https://zh.wikipedia.org/zh-cn/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%99%A8%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97">GPGPU</a> 。</li>
<li>为通用的计算加速的类似设备仍可能被称为 CPU ，即便其中没有<em>光栅化单元(rasterization unit)</em> 或最后用于输出的 ROP（<a href="https://zh.wikipedia.org/zh-cn/%E6%B8%B2%E6%9F%93%E8%BE%93%E5%87%BA%E5%8D%95%E5%85%83">渲染输出单元</a>，render output unit ），但保留了和<a href="https://zh.wikipedia.org/zh-cn/%E7%B9%AA%E5%9C%96%E7%AE%A1%E7%B7%9A">图形处理流水线</a>共用的物理部件，如支持<a href="https://zh.wikipedia.org/zh-cn/%E7%9D%80%E8%89%B2%E5%99%A8"><em>着色器(shader)</em></a> 的硬件实现。</li>
</ul>
</li>
</ul>
<h1 id="项目管理"><a class="header" href="#项目管理">项目管理</a></h1>
<p>　　提供上下文 <em>&lt;项目&gt;</em> 。</p>
<p>　　主要用例参见版本库中的项目文档 <code>doc/ProjectRules.txt</code> 。</p>
<ul>
<li>构建(build) ：通过确定的规则生成预设项目产出的动作。
<ul>
<li><strong>注释</strong> 典型地，包括从源代码翻译得到程序的过程。</li>
</ul>
</li>
<li>涉众(skateholder) ：项目关联的各方的主体。</li>
<li>角色(role) ：依据项目过程中起到的作用，对项目涉众实行一些附加归类。
<ul>
<li><strong>注释</strong> 项目的角色同时可用于项目阶段的描述中。</li>
</ul>
</li>
<li>用户(user) ：使用项目输出的项目涉众。</li>
<li>维护者(maintainer) ：决定项目中各个部分的内容的用户。
<ul>
<li><strong>注释</strong> 维护者可参与和维护部分相关的项目决策。</li>
</ul>
</li>
<li>开发者(developer) ：参与程序库和开发工具的功能修改的用户。
<ul>
<li><strong>注释</strong> 开发者可参与公开的构建过程以完成这些修改。</li>
</ul>
</li>
<li>最终用户(end user) ：独立为项目过程的用户。
<ul>
<li><strong>注释</strong> 最终用户可以不参与提前(ahead-of-time) 构建的项目过程。基于认知需求的差异可能需要从一般用户中单独区分。</li>
</ul>
</li>
</ul>
<h2 id="依赖管理"><a class="header" href="#依赖管理">依赖管理</a></h2>
<p>　　项目管理的客体被分解为特定关联的依赖项。任意两个依赖项之间存在<a href="https://zh.wikipedia.org/zh-cn/%E5%8F%8D%E5%AF%B9%E7%A7%B0%E5%85%B3%E7%B3%BB">反对称</a>和<a href="https://zh.wikipedia.org/zh-cn/%E4%BC%A0%E9%80%92%E5%85%B3%E7%B3%BB">传递</a>的<a href="https://zh.wikipedia.org/zh-cn/%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB">二元关系</a>称为<strong>依赖关系</strong>。<strong>严格依赖关系</strong>是反自反的依赖关系。</p>
<p>　　依赖项和依赖项之间的严格依赖关系统称为<em>依赖(dependency)</em> 。</p>
<h3 id="依赖引用"><a class="header" href="#依赖引用">依赖引用</a></h3>
<p>　　因为依赖关系的传递性，多个依赖关系可能存在无法满足严格依赖关系的情形，即<em>循环依赖(cyclic dependency)</em> 。这导致以确定的顺序解析依赖不可行，增加维护成本。</p>
<p>　　为了避免一定层次上的循环依赖，以该层次内组件为顶点的依赖关系的关系图应明确组织为有向无环图。
在最简单情况下依赖关系可退化为线性顺序依赖。</p>
<h3 id="内部依赖和外部依赖"><a class="header" href="#内部依赖和外部依赖">内部依赖和外部依赖</a></h3>
<p>　　项目中的组成部分之间的依赖称为<strong>内部依赖</strong>，其它依赖为<strong>外部依赖</strong>。</p>
<h2 id="源代码"><a class="header" href="#源代码">源代码</a></h2>
<p>　　<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源代码</a>用于生成指定目标代码。</p>
<p>　　通常源代码以文件形式保存，即<em>源代码文件(source code file)</em> ，简称<em>源文件(source file)</em> 。</p>
<h2 id="版本库"><a class="header" href="#版本库">版本库</a></h2>
<p>　　项目使用的<em>版本控制系统(version controlling system)</em> 具有<em>存储库(repository)</em> 作为持久存储实体，即版本库。</p>
<p>　　当前使用的主要版本控制系统为 <a href="https://www.mercurial-scm.org/">Mercurial</a> 。因为是分布式版本控制，也用于直接分发源代码。</p>
<p>　　每个文件系统上存储的版本库实例中，<code>.hg</code> 目录存储版本库元数据。</p>
<h1 id="设计和模型"><a class="header" href="#设计和模型">设计和模型</a></h1>
<h2 id="环境"><a class="header" href="#环境">环境</a></h2>
<p>　　程序中的某一部分的外界称为<strong>环境(environment)</strong>。根据限定程序的范围，可以有更确切的定义，如<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">实现环境</a>（对一类语言实现而言）、运行时环境（对共享实现环境的一类程序而言）。</p>
<p>　　一般地，实现环境可以分为<em>独立环境(freestanding environment)</em> 和<em>宿主环境(hosted environment)</em> ，区分依据为是否依赖宿主（对部署在单一计算机上的实现，一般指操作系统）的支持。因此，环境有时指操作系统及其提供的外部服务的集合。</p>
<p>　　一些语言，如 ISO C 和 ISO C++ ，可以同时支持宿主环境和独立环境的实现，对应<em>独立实现(freestanding impementation)</em> 和<em>宿主实现(hosted impementation)</em> 。</p>
<p>　　<em>构建系统(build system)</em> 是环境中包含语言实现的自动执行<a href="Terminology.zh-CN.html#%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86">构建</a>任务的系统，包含一个或多个完成构建任务的工具<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">程序</a>即<em>构建程序(build program)</em> 。一般地，构建系统被<a href="Terminology.zh-CN.html#%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86">开发者</a>使用，<em>开发环境(development environment)</em> 包含构建系统。</p>
<p>　　程序构建使用的环境是<em>构建环境(build environment)</em> 。程序运行使用的环境是<em>运行时环境(runtime environment)</em>，简称<em>运行环境</em>。</p>
<p><strong>注释</strong> 最终用户也可能是开发者，或有构建需求的非开发者，因此也可能使用部署到运行环境中的构建系统。</p>
<h2 id="平台-1"><a class="header" href="#平台-1">平台</a></h2>
<p>　　环境中决定程序适用环境的被依赖的特定资源集合称为<strong>平台环境(platform environment)</strong>，简称<strong>平台(platform)</strong>。平台的典型例子有：</p>
<ul>
<li>运行时支持的 <a href="Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">ISA</a> 。</li>
<li>操作系统和 <a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">ABI</a> 。</li>
</ul>
<p>　　平台的内涵是资源的集合，其构成并非任意。构成平台的特定准则应使之保持相对的稳定和可预期，即可配置；即平台是名义的(nominal) 可配置的资源集合。</p>
<p>　　若平台包含的资源是已知的，则不需要平台的观念，分析其资源子集（即便不构成平台）即可解决几乎平台抽象涉及的所有技术问题（同时这也是定义一个具体平台的基础）。但在简化资源集合的全局性质分析（如比较资源配置方案）和名义抽象以隐藏实现（如为开发者提供预设环境集合）的应用角度上，平台仍有被单独讨论的意义。</p>
<h3 id="兼容性和可移植性"><a class="header" href="#兼容性和可移植性">兼容性和可移植性</a></h3>
<p>　　若一个依赖项对应的平台可以替换，则此依赖项和此平台<em>兼容(compatible)</em> 。<strong>兼容性(compatibility)</strong> 是平台兼容的二元关系。兼容性不是一种<a href="https://zh.wikipedia.org/zh-cn/%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB">等价关系</a>，因为不保证传递。</p>
<p>　　替换平台的过程称为<em>移植(porting)</em> 。移植的可行性称为<strong>可移植性(portability)</strong> 。</p>
<p>　　兼容任意平台的依赖项被称为是<em>平台中立(platform-neutral)</em> 的。</p>
<p>　　当平台中立的依赖项的依赖能被自动满足而不需要考虑时，是<em>平台无关(platform-independent)</em> 的。平台中立<a href="https://zh.wikipedia.org/zh-cn/%E5%AE%9E%E8%B4%A8%E6%9D%A1%E4%BB%B6">实质蕴含</a>平台无关。</p>
<h3 id="运行平台"><a class="header" href="#运行平台">运行平台</a></h3>
<p>　　一般的程序可涉及以下类型的平台：</p>
<ul>
<li>宿主平台(host platform) ：程序被<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">运行</a>的平台是程序的宿主平台。</li>
<li>目标平台(target platform) ：程序运行目标支持的平台。
<ul>
<li>除非另行指定，目标平台同程序的宿主平台。</li>
<li><strong>注释</strong> 例如，对一个<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">翻译器</a>，可以指定目标平台是其输出的程序支持运行目标的平台。</li>
</ul>
</li>
</ul>
<p>　　<em>本机平台(native platform)</em> 是通过<a href="Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">本机语言</a>实现而不需附加翻译的运行平台。</p>
<p><strong>原理</strong></p>
<p>　　目标平台通常和宿主平台一致。指定目标平台的理由是，存在最终不一定在宿主平台上运行的程序，其运行的环境可能需要宿主平台不保证支持的特性，这典型地包括：</p>
<ul>
<li>构建的程序自身是生成其它程序的程序，如编译器和链接器。这些程序生成的平台是目标平台，不需要和它们的宿主平台相同。</li>
<li>构建的程序可以在宿主平台上运行，但在其它平台上具有更完全的特性集。后者被作为目标平台。</li>
</ul>
<p><strong>注意</strong> 此处的宿主平台具有相对意义，不一定脱离被运行的目标平台。一个宿主平台通常自身是宿主实现平台，但这点不被保证。</p>
<p>　　总是指定存在目标平台可简化<a href="Terminology.zh-CN.html#%E6%A8%A1%E6%8B%9F%E5%92%8C%E4%BB%BF%E7%9C%9F">适配不同平台的描述</a>。</p>
<h3 id="依赖和外延"><a class="header" href="#依赖和外延">依赖和外延</a></h3>
<p>　　若平台之间不出现平台的实现（如开发语言的实现）和环境自身的相互依赖，则这些平台相互<em>独立(independent)</em> 。总是保持相互独立的一组平台称为<em>独立平台(independent platforms)</em> 。每一组独立平台保证可以相对于其它独立平台分离开发和测试。</p>
<p>　　注意以上术语和 ISO C 和 ISO C++ 定义的<em>宿主实现(hosted implementation)</em> 和<em>独立实现(freestanding implementation)</em> 的关联和区别。</p>
<p>　　对<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">编译器</a>，若<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">编译</a>输出的程序代码被宿主平台支持运行，其目标平台即被视为和宿主平台一致，称为<em>本机编译(native build)</em> ；否则，称为<em>交叉编译(corss build)</em> 。</p>
<p>　　对<a href="Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">构建系统</a>的典型的应用场景，多个<a href="Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">构建程序</a>可能具有不同的<a href="Terminology.zh-CN.html#%E8%BF%90%E8%A1%8C%E5%B9%B3%E5%8F%B0">运行平台</a>集合。为简化统一的描述，约定以下类型的平台：</p>
<ul>
<li>构建平台(build platform) ：运行初始的构建程序的<a href="Terminology.zh-CN.html#%E8%BF%90%E8%A1%8C%E5%B9%B3%E5%8F%B0">宿主平台</a>。
<ul>
<li><strong>原理</strong> 无论是否可构建成功，对一个构建系统，构建平台应当总是存在。以进入构建系统作为基准，可有效避免对其它平台的依赖。</li>
</ul>
</li>
<li>宿主平台：运行构建平台输出代码的平台。</li>
<li>目标平台：运行最终目标代码的平台。</li>
<li><strong>注释</strong> 若构建系统的输出是一个编译器，则构建系统的宿主平台和目标平台同这个编译器的宿主平台和目标平台。</li>
</ul>
<p>　　若宿主平台和构建平台一致，称为<em>本机构建(native build)</em> ；否则，称为<em>交叉构建(corss build)</em> 。</p>
<p><strong>注释</strong></p>
<p>　　本机构建和交叉构建通过初始的构建程序的<a href="Terminology.zh-CN.html#%E8%BF%90%E8%A1%8C%E5%B9%B3%E5%8F%B0">宿主平台</a>是否和<a href="Terminology.zh-CN.html#%E8%BF%90%E8%A1%8C%E5%B9%B3%E5%8F%B0">目标平台</a>相同确定，而和输出无关。这和交叉编译比较宿主平台和目标平台不同。</p>
<p>　　通常构建系统在本机构建时提供对构建平台的检查以确定自身是否能够运行；交叉构建环境需要显式指定。</p>
<p>　　编译器可能隐含地支持交叉编译（如 GCC ），也可能需要显示指定目标平台（如 LLVM ）。</p>
<h3 id="模拟和仿真"><a class="header" href="#模拟和仿真">模拟和仿真</a></h3>
<p>　　<strong>模拟(emulation)</strong> 指适配和运行为不同平台设计的程序，广义上包括以下两类：</p>
<ul>
<li>环境模拟(environment emulation) ：使用<em>模拟器(emulator)</em> 或<em>虚拟机(virtual machine)</em> 等作为宿主平台的程序，模拟<a href="Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">运行环境</a>的通用解决方案。</li>
<li>程序模拟(program emulation) ：直接以运行时环境适配层嵌入宿主平台运行时，在具体程序中提供类似被模拟的目标平台的具体特性和接口。</li>
</ul>
<p>　　运行模拟程序的环境和被模拟环境分别是宿主平台和目标平台。</p>
<p>　　虚拟机在这个意义下是广义的模拟器中对<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">机器接口</a>提供支持的子集，一般和其余的模拟器分别对待。</p>
<p>　　环境模拟和程序模拟的主要差异为是否独立的、专用的宿主平台程序作为中介以维护目标平台和宿主平台的隔离。</p>
<p>　　在一般意义上，<strong>仿真(simulation)</strong> 指对需要分析的问题建立的<a href="Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">模型</a>的过程、方法和机制，在软件工程以外也被称为模拟，如计算机模拟(computer simulation) 。对于以计算机系统为目标的仿真，建立的模型可以是具体的实物（包括硬件和软件），称为<em>仿真器(simulator)</em> 。以软件接口为主要操作方式实现的仿真器同时实现了环境模拟，但侧重不同：精确重现需要分析行为，而非实用的功能等价性和体系中的可替换性。</p>
<h3 id="平台配置"><a class="header" href="#平台配置">平台配置</a></h3>
<p>　　实际的平台实现可能复用部分实现，配置之间可存在某种构成依赖关系的<a href="Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">偏序关系</a>（如继承关系）。这些在项目中所有被配置的平台称为<em>公共平台(common platform)</em> ，其中能对应生成输出的称为<em>具体平台(concrete platform)</em> ，否则为<em>抽象平台(abstract platform)</em> 。</p>
<p>　　对一个平台配置，程序可提供更多的子配置共用现有的相同的配置。子配置可继续对平台特性具体特化，而对原始配置的用户程序隐藏细节。</p>
<p>　　普遍适用于一般功能配置也可被作为平台配置的一部分而作为子配置。</p>
<p><strong>注释</strong> 例如，多线程和非多线程版本、调试和非调试版本可作为平台配置的功能子配置。</p>
<p><strong>原理</strong> 尽管功能配置提供的特性可能是普遍的，但它的实现依赖的特性不都在每个平台中存在，而可能需要一定程度的模拟和仿真，或可选地提供部分特性。提供功能子配置可把这些特性作为次要的实现细节，和原始的平台上的更显著特性隔离。</p>
<p>　　若存在这样的子配置，应当满足：</p>
<ul>
<li>这些子配置应当在每个部署的用户程序的依赖中保持唯一，即一个环境中不能同时依赖不同的子配置的程序映像。
<ul>
<li><strong>原理</strong> 这样不但不需要保持子配置之间的 <a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">ABI</a> 兼容性，同时 <a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 也可以存在不兼容（而不仅仅是调试符号等附加元数据的差异）。</li>
</ul>
</li>
<li>相应地，依赖不同子配置的用户程序也具有对应的子配置。用户程序可以仅提供其中的部分子配置的程序映像。
<ul>
<li><strong>原理</strong> 对每个子配置需要提供单独的依赖路径以避免冲突，因此一般不能在同一个部署中直接复用不同子配置的程序映像。为了避免不必要的资源占用，支持用户程序仅提供部分子配置（而非所有子配置的映像）是必要的。</li>
</ul>
</li>
<li>除非另行指定，被复用的公开库的程序名称在不同子配置中应当存在差异。
<ul>
<li><strong>原理</strong> 尽管不会同时被一个用户程序依赖，每个部署中，不同的子配置的程序映像通常仍需共存。在名称上要求差异允许文件系统直接支持这种策略。</li>
</ul>
</li>
</ul>
<h3 id="平台标识"><a class="header" href="#平台标识">平台标识</a></h3>
<p>　　不同平台可以标识符加以区分。由于平台受到不同环境因素决定的正交性，通常此类标识符可以分解为表示这些正交环境的标识符的元组形式，用 <code>-</code> 等字符分隔。</p>
<p>　　一种常用的方式是 GNU <a href="Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">构建系统</a>的<a href="https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.69/html_node/System-Type.html#System-Type">系统类型</a>，经典表示方式为三元组(triplet) ，或其省略形式：</p>
<ul>
<li>一般包括体系结构(architecture) 、系统厂商(system vendor) 和系统软件环境。</li>
<li>第一项不可省略，之后的项可省略。</li>
</ul>
<p>　　其中：</p>
<ul>
<li>体系结构一般指定 <a href="Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">CPU</a> 要求的最小 <a href="Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">ISA</a> 。</li>
<li>系统厂商指集成平台的环境厂商。</li>
<li>系统软件环境保证满足 <a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">ABI</a> 要求，可以包含操作系统及<a href="Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">本机语言</a>运行时实现的名称。</li>
<li>通过<em>工具链(toolchain)</em> 等<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">具体语言实现</a>构建时环境确定的程序依赖项是系统库(system library) ，是系统软件环境的一部分。
<ul>
<li>系统库可能被作为<a href="https://www.gnu.org/licenses/gcc-exception-3.1-faq.html">特定许可证例外</a>涵盖的范围。
<ul>
<li>详见 <a href="http://www.gnu.org/licenses/gpl.html">GNU GPLv3</a> 的 <a href="http://www.gnu.org/licenses/gpl-faq.html#SystemLibraryException">system library exception</a> 中的 system library 定义。</li>
</ul>
</li>
<li><strong>注释</strong> 系统库一般是特定平台或操作系统提供运行时支持的、由特定第三方环境提供开发支持的<a href="Terminology.zh-CN.html#%E5%86%85%E9%83%A8%E4%BE%9D%E8%B5%96%E5%92%8C%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96">外部依赖</a>，例如提供特定平台的 ISO C++ 标准库部分实现的 libstdc++ 和提供 Windows API 实现的 GDI32 等。</li>
<li>被分发的程序源代码可能仅依赖不受到许可证影响的、公开的接口规范（如<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规范</a>），而不直接依赖实现，而不构成版权法意义的衍生作品，但同时构建的二进制程序可以依赖二进制的系统库。</li>
</ul>
</li>
</ul>
<p>　　确定为<a href="Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">宿主环境</a>时，系统软件同时指定操作系统和运行时环境而拆分为两项，三元组扩充为四元组，如 <a href="https://wiki.gentoo.org/wiki/CHOST">Gentoo 使用的 CHOST</a> 。</p>
<p>　　在不够充分体现平台的必要差异（尤其是体系结构相关的配置）时也可通过自行定义标识符并指定与三元组的对应关系，如 <a href="https://wiki.debian.org/Multiarch/Tuples">Debian multiarch</a> 。</p>
<p>　　系统类型用来提供一定程度的兼容（替换和<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>）：</p>
<ul>
<li>系统类型代表了系统厂商的预设的配置集合，因此可提供符合相对上的（事实）标准的构建和运行环境。</li>
<li>这种兼容性有时会被过度依赖，乃至被误认为完全的 ABI 兼容：
<ul>
<li>系统类型不保证涵盖所有 ABI 细节，满足相同的系统类型的程序实例之间不一定符合完全相同的 ABI 而可相互替换或互操作，即原则上即不保证完全的 ABI 兼容。
<ul>
<li><strong>原理</strong> 实现的差异原则上不适合或无法通过系统类型区分。否则，系统类型事实上需要任意地长以涵盖不同细节，而会导致程序部署环境的碎片化，使维护兼容性的原始目的失去主要意义。</li>
</ul>
</li>
<li>一个主要实例：不同构建工具链生成的二进制程序之间不总是保证完全的 ABI 兼容：即便程序代码不改变，工具链生成的二进制代码之间也不保证可互操作即确保<em>二进制兼容性(binary compatibility)</em> 。
<ul>
<li>同一个版本的同一工具链通过某些构建选项即可能构建出不能保证 ABI 兼容的二进制程序映像。
<ul>
<li>例如，GCC 使用 <code>-m</code> 前缀选项可能影响 ABI 。</li>
</ul>
</li>
<li>即便使用工具链发行版固定的默认预设选项，不同版本工具链在设计上不能完全保证二进制兼容性。
<ul>
<li>例如，为兼容 ISO C++11 中关于 <code>std::basic_string</code> 和 <code>std::list</code> 等 <a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 改动，GCC 5 显式提供<a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_dual_abi.html">不同的 ABI 配置</a> 而在支持这些改动的配置上[放弃对原有 libstdc++ 的 ABI 兼容保证。</li>
</ul>
</li>
</ul>
</li>
<li>相同的系统类型可以对应不同的依赖集合，已被作为实用的维护兼容性的方法。
<ul>
<li>这种差异通常隐藏在系统库之下，此时提供不同的二进制兼容映像可以在部署时对依赖系统库的程序隐藏这些差异。</li>
</ul>
</li>
<li><strong>注释</strong> 现代 Microsoft Windows（基于 Windows NT 执行体）是应用包括这类兼容性在内的多种策略的一个典型实例：
<ul>
<li>隐藏二进制差异的主要实例是 Microsoft Windows NT 的 Win32 和 <a href="https://zh.wikipedia.org/zh-cn/%E5%BE%AE%E8%BD%AFPOSIX%E5%AD%90%E7%B3%BB%E7%BB%9F">POSIX 子系统</a>，用户程序通过链接到不同的子系统 DLL ，可共享上层 ABI 。</li>
<li><a href="https://www.cygwin.com/">Cygwin</a> 是一个类似的 POSIX 子系统替代实现，其用户程序当前默认依赖系统库 <code>cygwin1.dll</code> 。</li>
<li>Windows Subsystem for Linux (WSL) 则不是这种兼容性的实例。
<ul>
<li>因为映像格式的差异，它的用户空间程序使用的系统类型更接近 x86_64-pc-linux（具体系统类型取决于安装的发行版；典型地是 x86_64-pc-linux-gnu ）。</li>
<li>部署 WSL 环境需要涉及一整套不同系统类型的二进制映像，仅在子系统的内部实现存在（对 Windows NT 执行体而言的）隐藏实现差异的情形。</li>
</ul>
</li>
<li>不涉及子系统但同样通过 DLL 隐藏二进制的实例是隐藏系统库的版本差异：不同版本的 C 运行时(CRT) 和 Microsoft VC++ 运行时库可以在一个 Windows 系统实例中共存。
<ul>
<li>特别地，MSVCRT 和 UCRT 作为不同的 CRT ，可在同一个系统映像中安装，并作为同一个系统类型的不同实现提供。</li>
<li>同时，不同的 CRT 可具有不同的工具链支持。</li>
<li>不同版本的运行时中每个子配置（多线程和非多线程版本、调试和非调试版本）共用相同的配置，在此不视为存在差异。</li>
<li>CRT 的多版本部署和其它一些系统中 libc 显式影响系统类型不同。
<ul>
<li><strong>原理</strong> 尽管同样是作为语言实现的一部分部署的系统库（至少在通常以此<a href="https://www.gnu.org/licenses/gcc-exception-3.1-faq.html">为由</a>取得<a href="https://www.gnu.org/licenses/gcc-exception-3.1.html">许可证豁免</a>的意义上），仅有后者通常是影响整个系统部署的库，而不适合通过相同的系统类型提供二进制不兼容的版本。否则，这会使整个系统中的几乎所有二进制程序映像之间都不具有二进制兼容性，而无法通过<a href="https://en.wikipedia.org/wiki/Dynamic_linker#Implementations">通常的机制</a>共享二进制代码。</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://www.msys2.org/docs/environments/MSYS">MSYS2 提供的不同环境</a> 是体现上述所有各种不同兼容性方式的一个复杂实例。
<ul>
<li>其中，MSYS2 环境基于 Cygwin ，是通过类似子系统 DLL 部署的兼容层，其用户程序当前默认依赖系统库 <code>msys-2.0.dll</code> 。</li>
<li>其余环境被视为原生的 Win32 应用，使用 Win32 子系统。按体系结构归类分组，每一组内可存在原生的共用相同系统类型的不同实现。
<ul>
<li>例如，<code>/mingw64</code> 、<code>/clang64</code> 和 <code>/ucrt64</code> 中部署的二进制程序共享系统类型 <code>x86_64-w64-mingw32</code> 。</li>
<li>其中 <code>/mingw64</code> 中的程序依赖的 CRT 和另两种共享 <code>x86_64-w64-mingw32</code> 的环境不同，而 <code>/clang64</code> 中的程序依赖的 C++ 运行时库也和另两种环境不同。</li>
</ul>
</li>
</ul>
</li>
<li>上述的这些配置仍然没有穷尽系统库的 ABI 的差异。
<ul>
<li>例如，GCC 工具链中预设了<a href="https://github.com/FrankHB/pl-docs/blob/master/zh-CN/mingw-vs-mingw-v64.md">无法保证 ABI 相互兼容的不同异常处理和线程模型</a>（每个不同的模型同时可需要部署不同的 DLL 作为系统库依赖）。</li>
</ul>
</li>
<li>包括上述 MSYS2 中的每个环境的使用 GCC 的不同发行版都预设了具体的内部依赖，如：
<ul>
<li>MSYS2 中，<code>x86_64-w64-mingw32</code> 环境使用 SEH 异常处理模型，其用户程序当前默认依赖系统库 <code>libgcc_s_seh-1.dll</code> 。</li>
<li>MSYS2 中，<code>i686-w64-mingw32</code> 环境使用 Dwarf2 线程处理模型，其用户程序当前默认依赖系统库 <code>libgcc_s_dw2-1.dll</code> 。</li>
<li>一些发行版如 <a href="https://github.com/niXman/mingw-builds">MinGW-builds</a> 默认使用 SjLj 异常处理模型，其用户程序当前默认依赖系统库 <code>libgcc_s_sjlj-1.dll</code> 。</li>
<li>MSYS2 和大多数其它 <a href="https://www.mingw-w64.org/">MinGW-w64</a> 发行版中长期使用 POSIX 线程模型提供较完善的 C++ 标准库线程特性实现，当前使用 <a href="https://www.mingw-w64.org/#headers-libraries-and-runtime">winpthreads</a> ，其用户程序当前默认依赖系统库 <code>libwinpthread-1.dll</code> 。</li>
<li>预期可在现代环境中替代 <a href="https://www.mingw-w64.org/contribute/#mcfgthread">winpthreads</a> 的 <a href="https://github.com/lhmouse/mcfgthread">mcfgthread</a> 对<a href="https://gcc.gnu.org/pipermail/gcc-patches/2022-October/602704.html">上游的修改已被讨论</a>，使用新的线程模型 <code>mcf</code> ，其用户程序会依赖不同的系统库。</li>
</ul>
</li>
<li>实现系统库时，可依赖非系统库 API 。通常，系统库可直接在运行时依赖 Windows NT 执行体。系统库之间也可存在其它单向的内部依赖。这些情形下，系统库自身不是符合环境要求的程序。
<ul>
<li>例如，mcfgthread 依赖非 Win32 API ，自身不是严格意义的 Win32 程序（尽管构建时仍在运行于 Win32 子系统的假定下链接）。</li>
<li>POSIX 子系统依赖 Win32 系统。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>为了避免兼容性保证过程的复杂性，除非另行指定，关于系统类型：
<ul>
<li>可标识通过源代码部署的单一配置。构建支持和其它外部环境应当被文档明确。</li>
<li>避免认为其它形式部署的唯一依据。特别地，支持可共享相同二进制部署的<a href="Terminology.zh-CN.html#%E5%B9%B3%E5%8F%B0%E9%85%8D%E7%BD%AE">平台子配置</a>。</li>
</ul>
</li>
</ul>
<p>　　除非另行指定：</p>
<ul>
<li>本项目的平台定义不依赖具体的标识，但文档描述使用和三元组兼容的方式指定平台标识的基本形式。
<strong>原理</strong> 这在设计上避免对具体的平台标识的表示方式的接口依赖。因为系统厂商不一定具有相同的约定，且并非总是存在一种最优的选择，使用具体方式唯一地描述平台既无法保证描述清楚所有必要的细节（而足以确保兼容性），也不利于可移植性；更重要地，实际上和平台中立的目的矛盾。但是，默认的实现仍然遵循通行的规则和约定，可以减少实现和用户使用上的复杂性。
<strong>注释</strong> 一个例子是 GNU 和 LLVM 工具链使用不同的方式提供三元组；此外，有的实现提供四元组。详见以下的说明。</li>
<li>若同一个平台配置存在多个不同的标识符，默认使用以下规则确定：
<ul>
<li>对使用 MinGW-w64 实现的工具链，使用<a href="https://sourceforge.net/p/mingw-w64/wiki2/TypeTriplets/">工具链定义的三元组</a></li>
<li>否则，使用 <a href="https://savannah.gnu.org/projects/config">GNU config</a> 的最新版本中指定的标识符。
<ul>
<li>即 <a href="https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD"><code>config.guess</code></a> 和 <a href="https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD"><code>config.sub</code></a> 脚本。</li>
</ul>
</li>
<li><strong>注意</strong> <a href="https://sourceforge.net/p/mingw-w64/mingw-w64/ci/master/tree/mingw-w64-doc/howto-build/mingw-w64-howto-build-adv.txt">MinGW.org 和 MinGW-w64 都使用 <code>mingw32</code> 而非 <code>mingw64</code></a> ，这和 GNU guess 不同。
<ul>
<li>MinGW-w64 的源代码中仅有<a href="https://www.msys2.org/docs/environments/">环境路径前缀</a> 和 GNU config 的代码使用 <code>mingw64</code> 。</li>
<li>GCC 可接受 <code>mingw*</code> 而忽略其中的差异，但通常并不使用 GNU config 的 <code>mingw64</code> 配置 GCC。
<ul>
<li>因此这里的标识符能和 <code>gcc -v</code> 的结果中的 <code>Target:</code> 结果兼容。</li>
</ul>
</li>
<li>应当避免<a href="https://github.com/msys2/MINGW-packages/issues/8020">可能存在的混淆</a>。</li>
</ul>
</li>
<li><strong>注释</strong> <code>config.guess</code> 支持更一般的输入，包含 1 到 4 个部分，规格化为三元组 <code>CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM</code> 或四元组 <code>CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM</code> 。
<ul>
<li>前两个部分是机器类型，其中的厂商仅指制造商。如 <code>i686-w64-mingw32</code> 中的 <code>w64</code> 实际上不符合其含义。</li>
<li>最后或后两个部分是操作系统，实际包含操作系统和 C 运行时实现的 ABI（可选），即 <code>&lt;kernel&gt;-&lt;libc&gt;</code> 或 <code>&lt;kernel&gt;-&lt;abi&gt;</code> 。
<ul>
<li><a href="Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">独立实现</a>的 ABI 配置也被视为操作系统，如 <code>eabi</code> 和 <code>gnueabi</code> 。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>注释</strong> 通常不使用 <a href="https://clang.llvm.org/docs/CrossCompilation.html#target-triple">Clang 的三元组</a>。
<ul>
<li><strong>原理</strong> 尽管形式上更清晰，<code>&lt;sys&gt;-&lt;abi&gt;</code> 的划分实际使之成为四元组而非三元组，这种明确划分不总是符合现实的复杂需求。
<ul>
<li>这在关于 ABI 兼容的不明确性和歧义更加显著。这类不一致对适配更多不在现有清单上的平台更加困难，特别是未指定 <code>&lt;vendor&gt;</code> 时。
<ul>
<li><strong>注释</strong> 一个歧义的例子：<code>gnu</code> 在 Linux 上特指 glibc ，而在 Windows 上却指 libstdc++ 代表的 Itanium C++ ABI 实现。后者的 C 运行时库（通称 CRT ）却和 <code>msvc</code> 兼容。</li>
</ul>
</li>
<li>和 GNU guess 不同，Clang 三元组使用的情形相当有限，甚至<a href="https://stackoverflow.com/questions/15036909/">长期以来并不具有用户文档中明确的列表或检查规则</a>。
<ul>
<li>虽然 <code>clang</code> 接受 <code>-triple</code> 指定三元组，<code>clang --print-targets</code> 却输出平台标识符而非三元组。</li>
<li>三元组实际来自 <a href="https://llvm.org/doxygen/Triple_8h_source.html">LLVM 而非 Clang 的支持</a>。</li>
<li>更接近此处需求的是同时使用 LLVM 的 <a href="https://docs.rust-embedded.org/embedonomicon/compiler-support.html#built-in-target"><code>rustc --print target-list</code></a> 的输出。</li>
</ul>
</li>
<li>默认 <code>&lt;unknown&gt;</code> 但不一定在清单中被排除。这种随意性引起一些解析和理解上的困难。
<ul>
<li><strong>注释</strong> 在清单中滥用 <code>&lt;unknown&gt;</code> 的大量（却不是每个）例子可在 <code>rustc --print target-list</code> 的输出中找到。例如，通常读者（和系统维护者）难以理解：为何存在 <code>wasm32-unknown-emscripten</code> 和 <code>wasm32-wasi</code> 的同时还有 <code>wasm32-unknown-unknown</code> 而非 <code>wasm32-unknown</code> ？</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>具体构建过程可按需不同形式的标识符。
<ul>
<li><strong>原理</strong> 平台配置不一定通过系统类型描述。
<ul>
<li><strong>注释</strong> 例如，<code>cmake -G</code> 支持的标识依赖生成系统的配置，而非运行程序的系统类型。</li>
</ul>
</li>
<li><strong>原理</strong> 在不需要关心系统类型中各个组成部分的情形，其它的平台标识符可提供更简单明确的替代。
<ul>
<li><strong>注释</strong> <code>cmake -G clang --print-targets</code> 的结果是一个实例。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多平台构建"><a class="header" href="#多平台构建">多平台构建</a></h3>
<p>　　构建系统中可能涉及多个平台。</p>
<p>　　运行构建系统的环境和被构建的程序的环境不需要相同，对应的平台分别是<a href="Terminology.zh-CN.html#%E4%BE%9D%E8%B5%96%E5%92%8C%E5%A4%96%E5%BB%B6">宿主平台</a>和<a href="Terminology.zh-CN.html#%E4%BE%9D%E8%B5%96%E5%92%8C%E5%A4%96%E5%BB%B6">目标平台</a> 。宿主平台和目标平台相同时称为<em>本机(native)</em> 构建；不同时称为<em>交叉(cross)</em> 构建。</p>
<p>　　多个构建过程可能串联组成更大的构建过程。不同构建过程存在输出和输入之间的依赖。此时，前一过程输出的目标平台需要兼容于后一过程作为输入的宿主平台，否则无法直接运行。典型情况下这些平台是相同的，但也可以存在平台之间自身保证二进制<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>兼容性（如支持 x86_64 的体系结构上混用 i686 和 x86_64 ）的情况。</p>
<p>　　一些构建系统如 <a href="https://gcc.gnu.org/onlinedocs/gccint/Configure-Terms.html">GNU 工具链使用更复杂的术语</a>，单独引入<a href="Terminology.zh-CN.html#%E4%BE%9D%E8%B5%96%E5%92%8C%E5%A4%96%E5%BB%B6">构建平台</a>。</p>
<p>　　除非另行指定，本文档不要求单独使用这个概念，而默认构建平台是第一级构建过程（即 GNU autoconf 的“配置”）的宿主平台。</p>
<p><strong>原理</strong></p>
<p>　　不要求显式的构建平台确保一般性并简化模型。</p>
<p>　　特别地，能单独指定构建平台，是因为已知第一级配置可以单独通过<a href="Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">宿主环境</a>运行本机程序（典型地，如 C 语言等<a href="Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">本机语言</a>实现的<a href="Terminology.zh-CN.html#%E4%BE%9D%E8%B5%96%E5%92%8C%E5%A4%96%E5%BB%B6">宿主实现</a>程序）。典型地，GNU autoconf 等使用宿主环境脚本调用配置阶段构建的程序实现构建的第一级阶段。</p>
<p><strong>注释</strong></p>
<p>　　一些支持交叉构建的系统，即便被设计为配合已知的第一级构建的本机语言实现，也使用简化的模型。</p>
<p>　　例如，Go 语言的交叉编译实现中，可<a href="https://dh1tw.de/2019/12/cross-compiling-golang-cgo-projects/">使用简化的模型</a>，也可能<a href="https://go.dev/wiki/GccgoCrossCompilation">使用区分构建平台的模型</a>。</p>
<p>　　构建系统实现可能通过不同的环境变量区分针对<a href="Terminology.zh-CN.html#%E4%BE%9D%E8%B5%96%E5%92%8C%E5%A4%96%E5%BB%B6">不同的平台</a>的对应的<a href="Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">构建程序</a>。例如，一些主要的 GNU 项目有以下支持：</p>
<ul>
<li>多个环境变量指定构建系统中不同阶段使用的生成不同平台代码的编译器。以 C 编译器为例：
<ul>
<li>环境变量 <code>CC</code> 指定宿主平台使用的编译器，其宿主平台以及目标平台和构建系统的对应平台相同。</li>
<li>环境变量 <code>CC_FOR_BUILD</code> 或 <code>BUILD_CC</code> 指定构建平台的 C <a href="Terminology.zh-CN.html#%E4%BE%9D%E8%B5%96%E5%92%8C%E5%A4%96%E5%BB%B6">本机编译器</a>。
<ul>
<li>它输出的目标程序可作为构建脚本调用的一部分，即它的目标平台是构建平台。</li>
<li>指定 <code>CC_FOR_BUILD</code> 和 <code>CC</code> 不同的值可允许它不是宿主平台的本机编译器；其输出的目标程序能在构建平台运行，而不一定能在宿主平台运行。</li>
<li>构建平台和宿主平台相同时，一般同 <code>CC</code> 。</li>
</ul>
</li>
<li>环境变量 <code>CC_FOR_HOST</code> 或 <code>HOST_CC</code> 指定宿主平台的 C 编译器。
<ul>
<li><code>HOST_CC</code> 名义上指定宿主平台编译器，实际因为被用于构建过程而更应视为构建平台的编译器，因此可能同 <code>CC_FOR_BUILD</code> 且当前一般建议使用 <code>CC_FOR_BUILD</code> 替代，尽管因为兼容性可能仍被支持。</li>
<li><code>CC_FOR_HOST</code> 很少使用，一般同 <code>CC</code>（尽管<a href="https://github.com/mesonbuild/meson/issues/3969">有时后者总是被视为本机编译器</a>）。</li>
</ul>
</li>
<li>环境变量 <code>CC_FOR_TARGET</code> 指定目标平台的 C 编译器。
<ul>
<li>不使用 <code>TARGET_CC</code> 。</li>
</ul>
</li>
</ul>
</li>
<li>在 GNU binutils 的历史中：
<ul>
<li><code>HOST_CC</code> 在<a href="https://sourceware.org/git/?p=binutils-gdb.git;a=commitdiff;h=fecd2382e77b89f12c9d630ed4e42e9a54ba6953">初始提交</a>中即已出现。</li>
<li><code>CC_FOR_TARGET</code> 在<a href="https://sourceware.org/git/?p=binutils-gdb.git;a=commit;h=5148923360989fb54088f499e4b4cefd14088f9a">这个提交</a>中被引入。</li>
<li><code>CC_FOR_BUILD</code> 在<a href="https://sourceware.org/git/?p=binutils-gdb.git;a=commit;h=440868a029f0e200c019dce82ec783163fa59eed">这个提交</a>中被引入。</li>
<li><code>CC_FOR_HOST</code>（以及 <code>CFLAGS_FOR_HOST</code> ）最早在<a href="https://sourceware.org/git/?p=binutils-gdb.git;a=commitdiff;h=3c2476067c4b9c7db494af355e575b607fededee">这个提交</a>中出现。
<ul>
<li>仅在测试中使用。</li>
</ul>
</li>
<li><code>BUILD_CC</code> 最早在<a href="https://sourceware.org/git/?p=binutils-gdb.git;a=commitdiff;h=3866be5d4e427b4d114ad3b145496b8125c0fb0c">这个提交</a>中出现，代替 <code>HOST_CC</code> 。</li>
<li><code>BUILD_CC</code> 的支持在<a href="https://sourceware.org/git/?p=binutils-gdb.git;a=commit;h=4ec9a3b2495d5b49da1d83ac4ca0e3f90f8d2f75">这个提交</a>被移除。
<ul>
<li>参见以下 GCC 的更改。</li>
<li>剩余的更改被之后的提交（<a href="https://sourceware.org/git/?p=binutils-gdb.git;a=commitdiff;h=4fa63067931306bf5a9f9894bf4d2f5e14a1228f">[1]</a><a href="https://sourceware.org/git/?p=binutils-gdb.git;a=commitdiff;h=37ad95141b084645ed5729a0f36e1c945b0ac693">[2]</a><a href="https://sourceware.org/git/?p=binutils-gdb.git;a=commitdiff;h=3866be5d4e427b4d114ad3b145496b8125c0fb0c">[3]</a>）移除。</li>
</ul>
</li>
</ul>
</li>
<li>在 GCC 的历史中：
<ul>
<li><code>HOST_CC</code> 在<a href="https://sourceware.org/git/?p=binutils-gdb.git;a=commitdiff;h=79d8453e1c6f6e7e304d6f44da0dd018c459a121">初始提交</a>中即已出现。</li>
<li><a href="https://gcc.gnu.org/git/?p=gcc.git;a=commit;h=c192da272be503d6d70ee09165cbac6de7b0b88a">这个提交</a>支持 <code>HOST_CC</code> 。</li>
<li><a href="https://gcc.gnu.org/git/?p=gcc.git;a=commit;h=b7cb92adc97bd0cde5263493567cff7d23ed65d7">这个提交</a>在配置脚本中支持 <code>BUILD_CC</code> 。</li>
<li><a href="https://gcc.gnu.org/git/?p=gcc.git;a=commit;h=fe81dd695d4f49444de0114ee69b219c8d6aa45c">这个提交</a>使用 <code>BUILD_FOR_CC</code> 代替 <code>BUILD_CC</code> 。</li>
<li><code>BUILD_CC</code> 支持在<a href="https://gcc.gnu.org/git/?p=gcc.git;a=commit;h=eaf9f3b2e936e437092978ee61606cb53f87e5bc">之后</a>被移除。</li>
<li>没有出现 <code>CC_FOR_HOST</code> 。</li>
</ul>
</li>
<li>GNU Autoconf <a href="https://git.savannah.gnu.org/cgit/autoconf.git/commit/?id=723cfb231e56f59931a0553b46754c1189a44f04">引入环境变量 <code>BUILD_CC</code> 和 <code>HOST_CC</code></a> 代替 <code>CC</code> 指定构建平台和宿主平台运行的 C 编译器。</li>
<li>GNU config <a href="https://git.savannah.gnu.org/cgit/config.git/commit/?id=b0f77efb54be49c9f3b73a970e0224dd8ff28bea">引入 GNU Autoconf 的上述更改</a>。</li>
<li>GNU config <a href="https://git.savannah.gnu.org/cgit/config.git/commit/?id=045c3cc31298d4270d4b3a2e36531819206dd4d1">之后引入的更改</a>补充的注释指出 <code>CC_FOR_BUILD</code> 代替 <code>HOST_CC</code> 。
<ul>
<li>这在更早的提交中也有出现，如<a href="https://sourceware.org/git/?p=binutils-gdb.git;a=commitdiff;h=2412a768378f4c97e28f82824cbccc0c52b83938">这个 GNU binutils 提交</a>。</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h1>
<p>This page specifies the language features from the standard shall be used in this project, by introducing several rules and then clearifying which features are <em>applied</em> to the project from specific project build revision and time.</p>
<p>This page also includes some related information of external projects about various language implementations.</p>
<p>The interface documentation for this project may be specified in the <code>doc</code> directory of the repository,  in the pages of wiki, or in the Doxygen comments around the declarations in the header files in the source code. All of them are in zh-CN by default.</p>
<p>Unless otherwise specified, notations of date and time are in UTC+8.</p>
<h1 id="notation"><a class="header" href="#notation">Notation</a></h1>
<p>"<strong>NOTE</strong>" indicates note for maintainers and it is not directly from the source of the concerned contents.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>Some external materials are referenced here by links in several categories. Entries in same category are listed ordinally specified by document numbers (if any).</p>
<p>Since only adopted revisions are applied, most superseded reversions are placed together. A paper of a collection of issues can have multiple revisions and it can be adopted more than once (e.g. <a href="https://wg21.link/p0165">P0165</a>); these revisions does not superseds each other.</p>
<h2 id="revision-and-timestamp"><a class="header" href="#revision-and-timestamp">Revision and timestamp</a></h2>
<p>Revisions are designated in forms of b<em>revision-number</em>[<em>time</em>], where <em>revision-number</em> is the number of revision and <em>time</em> is the timestamp issued for that revision in any of ISO 8601:2004 calendar time formats. The timestamp is usually a date conventionally with <em>YYYY</em>-<em>MM</em>-<em>DD</em>.</p>
<h2 id="list-of-items"><a class="header" href="#list-of-items">List of items</a></h2>
<p>Items of features are categorized in different lists with various status. The indentation of a list indicates the context: items with less indentation level cover the topic covering items with more indentation level.</p>
<h2 id="items-and-tags"><a class="header" href="#items-and-tags">Items and tags</a></h2>
<p>Each item in a list is normally specified by (committee) document or CWG/LWG/EWG/LEWG issue/DR(defect report) number with a link and a title. Paper as editor's report or issue/DR list  (but <em>not</em> list about contents out of these contents, e.g. specifically drafted resolution paper of one ore more DRs) should be collectively listed in a few list (so issues can be top-level items otherwise). Each item may be noted with following tags:</p>
<ul>
<li>"adopted" indicating the feature has been incorperated into <strong>the working paper</strong> (but <strong>not</strong> in this document) since the followed time which is usually the content of "Disposition" column from the <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers">official document list</a></li>
<li>"based on" indicating one of the base specifications</li>
<li>"dropped" indicating abandoned in development</li>
<li>"overriden by" indicating new item taking effect instead of the current one</li>
<li>"part of" or "parts of" indicating not all contents of the specification</li>
<li>"revised" indicating one of the revised specifications
<ul>
<li>is often unique</li>
<li>should be significant, e.g. adopted previously; otherwise it can already be indexed by other lists of items, and if there are no other list is appropriate, it shall be in the "outdated" list</li>
</ul>
</li>
<li>"see" pointing to revised revisions</li>
<li>"see also" for related materials</li>
<li>"see other derivation" pointing to siblings</li>
<li>"see subsequent" pointing to subsequent new series</li>
<li>"since" with initial project build revision and time of applying (which is only applicable for features adopted or tentatively adopted in this document)</li>
<li>"split from" for the original item containing the material</li>
<li>"subsumed by" for the target of migration (e.g. for duplicated issues)</li>
<li>"with" indicating additional specifications not covered by specified one in the context</li>
</ul>
<h1 id="basic-rules"><a class="header" href="#basic-rules">Basic rules</a></h1>
<p><strong>The Forwarding Compatibility Rule:</strong> All language features incompatible with published/normative future versions of the language specification shall not be mandated or depend on.</p>
<p><strong>The Baseline Implementation Rule:</strong> Each feature being used shall have been implemented in general available version of at least 2 <a href="https://en.wikipedia.org/wiki/Free_and_open-source_software">FOSS</a> implementations.</p>
<h1 id="general-status"><a class="header" href="#general-status">General status</a></h1>
<p>The default configuration, <em>baseline</em>, is specified here. The features explicitly introduced to clearify dependences on the language implementations are also listed in this and following sections.</p>
<h2 id="conformance"><a class="header" href="#conformance">Conformance</a></h2>
<p>The conformance of languages and environments used in this project is specified using published versions of standards and technicle specifications, as well as drafts and proposals. For purpose of specification in this project, all of them are designated as specifications.</p>
<p>Several C++0x features are used since b206[2011-05-03]. These features are also in ISO C++11(ISO/IEC 14882:2011). Previously C++03 with TR1(ISO/IEC TR 19768:2007) was used. New versions of ISO C++ and technicle specifications are also considered:</p>
<ul>
<li>ISO C++14(ISO/IEC 14882:2014)</li>
<li>ISO C++17(ISO/IEC 14882:2017)</li>
<li>ISO C++20(ISO/IEC 14882:2020)</li>
</ul>
<h3 id="baseline"><a class="header" href="#baseline">Baseline</a></h3>
<p>C++11 is now default to conform.</p>
<p>As per the forwarding compatibility rules, all C++03 features conflicted with future versions of C++ (e.g. <code>export</code>) and all features already removed from C++17 (e.g. <code>std::auto_ptr</code>) are disallowed to rely on.</p>
<p>TR1 features are avoided and have been substituted by their C++11 counterparts.</p>
<p><a href="https://eel.is/c++draft">Draft standard</a> is considered in sake of avoiding conflicts with future versions of the standard.</p>
<h3 id="additional-specifications"><a class="header" href="#additional-specifications">Additional specifications</a></h3>
<p>The considered and (possibly incompletely) reviewed technical specifications beyond C++11 are:</p>
<ul>
<li>ISO/IEC TS 19568:2015 Programming Languages — C++ Extensions for Library Fundamentals
<ul>
<li><a href="https://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=64031">Published</a> 2015-09-30 (ISO Store)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html">Final draft (N4480)</a> (2015-04-07)</li>
</ul>
</li>
</ul>
<p>(See <a href="https://wongmichael.com/2016/02/28/c17-content-predictionpre-jacksonville-and-post-kona-report/">here</a> for information about adoption in C++17.)</p>
<h2 id="replacements"><a class="header" href="#replacements">Replacements</a></h2>
<p>Several features in specifications beyond C++11 is not directly relied on, but this project provides some replacements (possibly with some custom extensions) as features to ease the work about compatibility.</p>
<p>Replacements are provided in a "(mostly) drop-in" manner, i.e. the base name of API are same, but with allowence of difference on qualified prefix and/or prefixes(of namespaces, mostly, to <code>std</code>; or of headers to be included. This allows user code replacing interface with a few alias declarations without changing of the program well-formedness and behavior. It is easy to change the underlying set of API as well as to pick a subset of them on purpose.</p>
<p>The replacements provided are bidirectionally drop-in replaceable, which can be used interchangably with the features they replace, except the compatibility exceptions specified below. However, such replacements are not guaranteed to be mixed arbitrary with the feature being replacements. The granularity of mixture with guaranteed usablity is a type or a template with any related operations relying on the type signature derived from that entity, unless otherwise specificed in documentation.</p>
<p>Some of other replacements are ony-way drop-in replacements, i.e., guaranteed being able to replace the correspoinding features in specifications without changing of meaning but not the other way.</p>
<h3 id="compatibility-exceptions"><a class="header" href="#compatibility-exceptions">Compatibility exceptions</a></h3>
<p>Several features cannot be implemented portably due to ISO C++ core language features are not available in virous target environments (e.g. in the baseline).</p>
<p>Emulation of (esp. core language) features involved such cases is limited, and it would be implemented in replacements with <em>best effort</em> when it is practibly implementatble.</p>
<p><strong>NOTE</strong> If the core language in the baseline does not limit the feasibility, the replacements shall still be the drop-in replaceable.</p>
<p><strong>Corollary</strong> Features limited by the core language are available <strong>conditionally</strong> depending on which language dialect is being used.</p>
<p><strong>NOTE</strong> Extensions of specific language implementations may loose the limitations, but there are still no guarantees.</p>
<p>For cases where the replaced features cannot be implemented portably in the baseline, the limitations shall be documented on related interface either with <code>\warning</code> command on each instances or with descriptions in the header including them, to inform users the existence of portability risks and the condition of availablity (i.e. which dialects it is guaranteed to work). To avoid frequent needs, features totally unusable (e.g. features relying on <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3651.pdf">variable templates</a>) are not provided at all, thus only a few cases should be concerned.</p>
<p>Currently, compatibility limitations include:</p>
<ul>
<li>Availablilty of <code>constexpr</code> on functions and function templates may be limited, when the dialect of an earlier standard (before the edition of the standard requires them) is used.
<ul>
<li>As a result, operations relies on such replacements may not work in contexts requiring constant expressions.</li>
<li>Additional implementation support may improve the availability of <code>constexpr</code>.
<ul>
<li><strong>NOTE</strong> Sometimes, compiler builtins may provide <code>constexpr</code> being implementable without the limitation even an earlier standard is used; sometimes there are just no such extensions.</li>
</ul>
</li>
<li>Replacements of features beyond ISO C++20 shall have <code>constexpr</code> required by the interface, whenever they are implementable portably.
<ul>
<li><strong>Rationale</strong> With <code>std::is_constant_evaluated</code> since C++20, different paths of implementations of portable C++ code are allowed, so reducing the quality specifically for contexts not requring constant expressions is not a problem.</li>
</ul>
</li>
<li>If there are problems of implementation complexity of the replacments targeting before C++20 to meet the requirements of <code>constexpr</code> reducing the quality of the features used in the contexts not requiring constant expressions (e.g. expectable performance degration), <code>constexpr</code> may not be provided by design.
<ul>
<li><strong>Rationale</strong> Before C++14, <code>constexpr</code> has extra limitations on the function body. To work with the baseline without additional implementation complexity, <code>inline</code> may be used instead of <code>constexpr</code>.</li>
<li>Whether the specialized implementation with <code>constexpr</code> provided for C++14 and higher edition of the language standard is unspecified.</li>
<li><strong>NOTE</strong> Providing specialized implementations is a QoI (quality of implementation) issue. Typically, <code>constexpr</code> would be directly enabled when C++14 or some higher edition of the language standard is used.</li>
</ul>
</li>
<li>Concrete instances missing <code>constexpr</code> are listed below.
<ul>
<li><code>ystdex::addressof</code> may not have <code>constexpr</code> for specific types.
<ul>
<li><strong>NOTE</strong> Even the type is complete, there is no guarantee to rule out user-defined overloaded <code>operator&amp;</code> on the object.</li>
<li>In cases where <code>operator&amp;</code> is used, C++11 provides <code>std::addressof</code> to get the correct result. However, it is not designated with <code>constexpr</code>, which is available portably only since C++17.</li>
</ul>
</li>
<li>Replacements of features in <code>&lt;bits&gt;</code> (since C++20) may not have <code>constexpr</code>.</li>
</ul>
</li>
</ul>
</li>
<li>To determine whether a class is declared with <code>final</code> may be impossible.
<ul>
<li>It is not implementable without some implementation support before C++14 introduces <code>std::is_final</code>.</li>
<li><strong>NOTE</strong> <code>std::is_empty</code> is not implementable in portable C++ without such support. However, <code>std::is_empty</code> is provided by C++11 (in the baseline), so there shall be <em>no</em> limitation on determine whether a class is empty.</li>
</ul>
</li>
</ul>
<p>For better compatibility to evolution, additional exceptions are granted here:</p>
<ul>
<li>Type equivalence between provided and replaced types is not guaranteed even if they coexist in a same configuration of C++ implementation.
<ul>
<li>This allows mixture of different components served as different parts of the replaced interface at same time, as well as complement of interface already (insufficiently) implemented by the current C++ implementation.</li>
<li>Types may provided based on old revision of specification (e.g. by inheritance of classes).</li>
</ul>
</li>
<li>The <code>constexpr</code> specifier may be effectively omitteed in interface or implementation of the library when the environment is limited in a configuration with insufficient core language support.
<ul>
<li>The <code>constexpr</code> guaranteed by C++14 is not guaranteed available in a  configuartion ealier than C++14, since it may be missing of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3652.html">relaxing constraints</a> support in the core langauge implementation.</li>
<li>Any <code>constexpr</code> on <code>lambda-expression</code>s is not guaranteed available in a configuration eariler than C++17 even after adoption of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0170r1.pdf"><code>constexpr</code> lambda</a>, since it may be missing in the core langauge implementation.</li>
</ul>
</li>
<li>Operators may be introduced in declarations different to current version of specifications.
<ul>
<li>This is like <a href="https://eel.is/c++draft/objects.within.classes">[objects.within.classes]</a> for private class members.</li>
<li>Comparison operators are no longer guaranteed accessible as independent entities (e.g. as operand of <code>&amp;</code> or accessing using <code>qualified-id</code>).
<ul>
<li>This is same to the direction of future standardization proposed in <a href="https://www.open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0790r0.html">P0790R0</a>.</li>
<li>This dependes on C++20 <code>&lt;=&gt;</code> operator, but it is not the only way.</li>
</ul>
</li>
<li>Other operators can be similar to get potentional great simplication of implementation.
<ul>
<li>Notably, with <a href="https://en.wikipedia.org/wiki/Barton%E2%80%93Nackman_trick">Barton–Nackman trick</a>, simplification can be achived partially as <code>&lt;=&gt;</code> on most overloadable operators (not only comparison).</li>
<li>Currently, most operators in this project is simplified by using of <code>YBase.YStandard.Operatos</code> API.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="subproject-structure"><a class="header" href="#subproject-structure">Subproject structure</a></h3>
<p>All of the replacements live in the top-level subproject YBase. The overall structure concerned here is:</p>
<ul>
<li>YBase
<ul>
<li>YDefinition (header file <code>ydef.h</code>)</li>
<li>LibDefect</li>
<li>YStandardEx</li>
<li><em>others</em></li>
</ul>
</li>
<li>YCLib</li>
<li><em>other YSLib or YSLib-like top-level subprojects</em></li>
</ul>
<p>For YBase, all interface of C++ code is in the namespaces specified here. This includes replacements.</p>
<p>There is no well-defined behavior guaranteed if library-wise rules are violated. The rules are:</p>
<ul>
<li>No namespaces name can be introduced as top-level (directly enclosed in <a href="https://eel.is/c++draft/basic.scope.namespace#3">the global namespace</a>) namespace names except the namespaces specified here:
<ul>
<li>Namespaces <a href="https://eel.is/c++draft/namespace.constraints">specified by the standard</a> are used according to these rules.</li>
<li>The namespace <code>ystdex</code> provides most code not from YBase.LibDefect.</li>
<li>Namespace name (glob) pattern 'ystdex_*' are reserved.
<ul>
<li>Some of them may be used as top-level namespaces providing code additional to namespace <code>ystdex</code> without clash in <code>ystdex</code>, e.g. when ADL(argument dependent lookup) is unavoidable.</li>
</ul>
</li>
<li>Reserved namespace with public interface as well as namespace <code>ystdex</code> are collectively specified as <em>public top-level namespaces</em>.
<ul>
<li>Currently public top-level namespaces are:
<ul>
<li>namespace <code>ystdex</code></li>
<li>namespace <code>ystdex_swap</code></li>
</ul>
</li>
</ul>
</li>
<li>To simplify the code, any top-level names without explicit qualified preifx <code>::</code> shall be used as-if they are prefixed with with <code>::</code>.</li>
</ul>
</li>
<li>Only YBase.LibDefect can inject names into namespace <code>std</code> and other namespaces specified by the standard (as parts of implementation) when necessary in provide being <a href="https://eel.is/c++draft/conforming">conforming</a>. Otherwise, they shall be conform to <a href="https://eel.is/c++draft/constraints">the rules of the library user code</a>.</li>
<li>Documented reserved marco names besides <a href="https://eel.is/c++draft/reserved.names">the standard rules</a> shall be also avoided by the library user code.</li>
<li>All other cases are conform to <a href="https://eel.is/c++draft/requirements">the standard rules</a> except that the namespaces provided by the standard are replaced by the top-level namespaces specified above.</li>
</ul>
<p>Except for the file specified as "drop-in replacement", a header specified by a rule in a published standard or specification may or may not be directly aligned to the actual one in YBase, but there are clear many-interface-to-one-header relationship across the interface and headers by splitting each standard header to plural correspoinding header files.</p>
<p><strong>Rationale</strong> The purpose is to break down dependencies and to reduce the overhead of inclusion performed in preprocessing phase.</p>
<p>For other top-level subprojects, no replacements need to be considered. Unless otherwise specified, the baseline applies directly. If there need replacements, use interface proveded by YBase for preference (but usually <em>not</em> YBase.LibDefect).</p>
<h3 id="components"><a class="header" href="#components">Components</a></h3>
<p>Replacements in YBase consist of following components with caveats:</p>
<ul>
<li><strong>YDefinition</strong>, i.e. <code>ydef.h</code>, provides various vendor-neutral compatible interface of language implementation by conditioanlly-defined preprocessing macros.
<ul>
<li>A few replacements are same to YStandardEx direct replacements below, except provided in the top-level namespace directly.</li>
</ul>
</li>
<li><strong>LibDefect</strong> implementation provides some interface directly conforming to the standard, as complements of the language implementations provided by system and toolchain vendors.
<ul>
<li>The public headers shall be capable for direct use with any implementation meeting the requirements specified by the YSLib documentation (including following sections) as in-drop replacements for corresponding standard library headers.</li>
</ul>
</li>
<li><strong>YStandardEx replacements</strong> provide remain interface meet the functionality needs.
<ul>
<li><strong>YStandardEx direct replacements</strong> provide adaptive interface compatible and (almost) conforming to multile version of specifications.
<ul>
<li>To support adaptive use, the direct part of replacements may conditionally include different source, whose interface is specified as "<strong>conditionally</strong>" in this document.</li>
<li>The comformance requirements shall be clear to each interface.</li>
<li>Nonconforming interface may only occur with exactly same or one-to-one mapping of interface between namespace <code>std</code> and <code>ystdex</code> in the user code.</li>
<li>Nonconforming interface shall not introduce differences on requirements on the program using that interface.</li>
<li>Nonconforming interface shall be still compatible to other rules. That is, use of the interface shall not alter well-formness and the well-defined behavior of the program, except cases restricted by compatibility limitations.</li>
</ul>
</li>
<li><strong>YStandardEx dedicated replacements</strong> provide interface compatible to specifications as well as their drafts by less conformance requirements compared to direct replacements.
<ul>
<li>Nonconformance may occur in a form same to that in the case of YStandardEx direct replacements.</li>
<li>Nonconformance shall occur in a form that loosing the requirements of rules in the published standard or specification, or in a form with explicitly supported extensions which are not compatible to these rules; otherwise, the interface should be designed as direct replacements or non replacements.</li>
</ul>
</li>
</ul>
</li>
<li><strong>YCLib replacements</strong>
<ul>
<li>As YStandardEx direct and dedicated replacements, respectively, with platform-dependent implementation details relied on. Some features may be conditonally supported depending on the standard library implementatinos.</li>
<li>The names are provided in namespace <code>platform</code>.</li>
</ul>
</li>
</ul>
<p>See following paragraphs for precise definition of components and more detailed descriptions on policies of their use.</p>
<h2 id="evolution"><a class="header" href="#evolution">Evolution</a></h2>
<p>For compatibility, the project may use different sets of rules in each parts. YBase is more stable and conservative to utilize new C++ features.</p>
<h3 id="longterm-policy"><a class="header" href="#longterm-policy">Longterm policy</a></h3>
<p>The longterm policy holds as:</p>
<ul>
<li><code>ydef.h</code>: For compatibility reasons, only a subset of C++11 would be mandated. The precise subset is unspecified and can vary between revisions.</li>
<li>YBase except LibDefect discussed above: Library features beyond C++11 would be used only available.</li>
<li>Other parts of the project: C++ features would be used aggressively (but still restrictd by the rules here, esp. the basic rules). Currently it is still in the baseline.</li>
</ul>
<h3 id="core-language-compatibility-features"><a class="header" href="#core-language-compatibility-features">Core language compatibility features</a></h3>
<p>Some core language feature have fallback in C++03 (e.g. <code>constexpr</code>) or library (e.g. <code>alignof</code>), mostly workaround in <code>ydef.h</code>, as well as some optional extensions (e.g. <code>__has_feature</code> and <code>__builtin_expect</code>) wrapped as implementation details. They are provided by YDefnition.</p>
<p>Some core language features not in the standard but provided by various adapted language implementations have been wrapped in a platform-neutral interface provided by YDefinition.</p>
<h3 id="library-implementation-integreations"><a class="header" href="#library-implementation-integreations">Library implementation integreations</a></h3>
<p>Due to limitations of specific environments, some standard library features might be not usable without alternative implementations. They may be enabled by using additional headers in the module YBase.LibDefect instead of the corresponding standard headers.</p>
<p>As patches, namely parts of language implementations, the code in YBase.LibDefect can be highly implementation-specific. It has significant differences (which may cause undefined behavior without further guarantees) to the usual library and user code:</p>
<ul>
<li>It can be directly intrusive to the global namespace, <code>namespace std</code> and other implementation-specific namespaces, which may be reserved by the standard.</li>
<li>As part of the standard library implementation, it may use names reserved by the standard.</li>
<li>It may have implementation-specific contents intended only for internal use and guarded by conditional inclusion, because they are direct replacements for the standard library.</li>
</ul>
<p>The code has been carefully tuned to be compatible to supported environments, to keep out undefined behavior merely caused by this implementation.</p>
<h3 id="library-compatibility-features"><a class="header" href="#library-compatibility-features">Library compatibility features</a></h3>
<p>To reduce impact on user code to adopt new versions of specifications, several post-C++03 library features are provided in the top-level namespace <code>ystdex</code> (with inlined namespace if the features have been in published standards) in module YBase.YStandardEx, either by <code>using</code> declarations from namespace <code>std</code> iff. provided by the standard library, or being implemented from scratch when the features are not available from the standard library (not the library implementation, i.e. implementation-specific interface are still forbidden).</p>
<p>They are designed to be (bidirectionally) drop-in replacements (with necessary filename change in <code>#include</code> directives) of corresponding specific version of <code>std</code> or <code>std::experimental</code> interface, with a few exceptions:</p>
<ul>
<li>Except for some specialization of standard library templates, the enclosing namespace is not <code>std</code> so name lookup may behave differently to the standard library interface.
<ul>
<li>Use additional 'using ystdex::<em>NAME</em>;' to enable ADL(argument dependent lookup) for <em>NAME</em>.</li>
<li>Note <a href="https://eel.is/c++draft/global.functions#4">[global.functions]/4</a> is still conforming similarly. Any ADL beyond <code>namespace ystdex</code> shall be specified by the interface documentation.</li>
</ul>
</li>
<li>The overloaded operators may be implemented by ADL-only manner, i.e. declared as friend functions, rather than namespace scope entities.
<ul>
<li>Currently no entities are declared in this manner except for interface are ready for post-C++14 standard library features.</li>
</ul>
</li>
<li>It is unspecified that whether the concerned types of replacement API is identical to the types in the standard.
<ul>
<li>It is important to know this to avoid type introspection based on wrong type identical assumptions, including:
<ul>
<li>Using <code>static_assert</code> or some other meta operations based on static type equivalence.</li>
<li>RTTI or exception handling based on dynamic type identity.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>They are collectively called as <strong>YStandardEx direct replacements</strong> for the corresponding features being replaced.</p>
<p>YBase user code may use interface in public top-level namespaces instead of the counterparts in the namespaces mentioned above to simplify the migration. For components of direct replacements interface specified in the standard (but not technical specifications) beyond ISO C++11, they are in correspoinding enclosed <strong>standard replacement namespaces</strong> which are inline namespaces enclosed unambiguously in public namespaces with a common namespace prefix pattern with same nested namespaces to the standard interface. For example:</p>
<ul>
<li>Interface first occurred or last updated in ISO C++14 in namespace <code>std</code> is in inline namespace <code>ystdex::cpp2014</code>.</li>
<li><code>std::pmr</code> interface introduced since ISO C++17 is in inline namespace <code>ystdex::pmr::cpp2017</code>.</li>
</ul>
<p>Note that a similar approach is also proposed for <code>std</code> separatedly as <em>shadow namespace</em> in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1473r0.pdf">P1473R0</a> for some slightly different purposes.</p>
<p>If there are multiple published versions of standard having modification on some entities denoted by a same name, there shall be one candidate or at least one extra alias declaration to reference it in the public top-level namespaces unambiguously, allowing omission of the inline namespace name normally but distinguishing on need. Deprecated features is not guaranteed provided unless explicitly specified to reduce confusion and restriction as per the future direction of feature using implied in this document. To avoid misconceptions, other replacements shall neither be provided in standard replacement namespaces or their enclosing namespaces thereof.</p>
<p>Ambiguity across different namespaces with mixture use of them shall also be avoided.</p>
<p>Components for the upcoming standard (in the working draft or Technicle Specifications, but not the published Internaltional Standard) are deliberately experimental as library compatibility features, so they are directly declared in public top-level namespaces.</p>
<p>As per the compatibility limitations of replacements, exceptional rules of compatibility to <code>std</code> interface are granted hereby:</p>
<ul>
<li>For entities used specifically in tag dispatching, only such use is required to be compatible as drop-in replacement. The differences shall be defined in documents about the replacement.</li>
</ul>
<p>Revised components of library compatibility features shall not be deprecated in the current (newest formal) standard.</p>
<h3 id="extended-library-compatibility-features"><a class="header" href="#extended-library-compatibility-features">Extended library compatibility features</a></h3>
<p>Some other interfaces in YBase.YStandardEx are designed as replacements for corresponding specific versions of <code>std</code> or <code>std::experimental</code> interface, as the compatibility features above, but with extra extensions, and with no restriction about the solution of <a href="https://wg21.cmeerw.net/lwg/issue2013%5D">LWG 2013</a> (that is, they may be with extra <code>constexpr</code>). They can be used as ony-way drop-in replacements.</p>
<p>Entities with extended library compatibility features to the replaced entites are collectively called as <strong>YStandardEx dedicated replacements</strong> of the corresponding features being replaced, where each of them meets following requirements:</p>
<ul>
<li>Except extensions, it shall be able to one-to-one mapped to the entity being replaced with exact functionality (albeit the name can be different in several cases, see below).</li>
<li>If it is neither a type nor a template of type (class template or alias template), or it is provided as some part of other compatibility features, its base name (<em>unqualified-id</em>) shall be same to the name of entity being replaced.</li>
<li>Its name shall be declared in public top-level namespaces or enclosed namespaces thereof, except the namespaces excluded by the rules specified previously.</li>
</ul>
<p>Components of extended library compatibility features not being dedicated replacements shall be declared in public top-level namespaces and may be declared in the same header of the compatibility features above.</p>
<h3 id="potential-library-compatibility-features"><a class="header" href="#potential-library-compatibility-features">Potential library compatibility features</a></h3>
<p>Some other interfaces in YBase.YStandardEx are designed close to correspongding specific versions of <code>std</code> or <code>std::experimental</code> interface, to be an implemantation base of above compatibility library features or extended library compatibility features. They are <strong>not</strong> replacements as they are not designed to be conforming to any version of the standard or technical specifications, nor always provided in a drop-in manner. Nevertheless, they may have features which can be directly mapped to the said specifications, with or without some resolutions of LWG issues applied.</p>
<p>Although as implementation of above features, they are totally in details, they can also be used as public interfaces as other parts of YSLib.</p>
<h2 id="reviewed"><a class="header" href="#reviewed">Reviewed</a></h2>
<p>The following editor's report has been fully reviewed (b593[2015-04-23]), which means all the resolutions in the paper are categorized in the following clauses:</p>
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2370.html">N2370</a></li>
</ul>
<p><strong>NOTE</strong> There might exist minor differences between editor's report and the paper in the list, e.g. <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3059.pdf">N3059</a> (rev 5.2) in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3091.html">N3091</a> is (rev 5.1). For these cases, only the later revisions at the point of time are reviewed and probably would not be updated unless necessary.</p>
<h2 id="to-be-done"><a class="header" href="#to-be-done">To be done</a></h2>
<p>Reviewing of following defect reports and resolutions are work in progress.</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue215">CWG 215</a>: Template parameters are not allowed in <code>nested-name-specifier</code>s</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue218">CWG 218</a>: Specification of Koenig lookup (see also <a href="https://wg21.cmeerw.net/cwg/issue113">CWG 113</a> and <a href="https://wg21.cmeerw.net/cwg/issue143">CWG 143</a>)</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue397">CWG 397</a>: Same address for string literals from default arguments in inline functions?</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue667">CWG 667</a>: Trivial special member functions that cannot be implicitly defined</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1135">CWG 1135</a>: Explicitly-defaulted non-public special member functions
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue1136">CWG 1136</a>: Explicitly-defaulted explicit constructors</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1140">CWG 1140</a>: Incorrect redefinition of POD class</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1145">CWG 1145</a>: Defaulting and triviality</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1149">CWG 1149</a>: Trivial non-public copy operators in subobjects</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1208">CWG 1208</a>: Explicit <code>noexcept</code> in defaulted definition</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4320.html">N4320</a>: Make exception specifications be part of the type system
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue92">CWG 92</a>: Should exception-specifications be part of the type system?</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1946">CWG 1946</a>: <code>exception-specification</code>s vs pointer dereference (see also <a href="https://wg21.cmeerw.net/cwg/issue92">CWG 92</a> and <a href="https://wg21.cmeerw.net/ewg/issue169">EWG 169</a>)</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue2010">CWG 2010</a>: exception-specifications and conversion operators (see also <a href="https://wg21.cmeerw.net/cwg/issue92">CWG 92</a>, <a href="https://wg21.cmeerw.net/cwg/issue1798">CWG 1798</a>, <a href="https://wg21.cmeerw.net/cwg/issue1946">CWG 1946</a>, <a href="https://wg21.cmeerw.net/cwg/issue1975">CWG 1975</a>, <a href="https://wg21.cmeerw.net/cwg/issue1995">CWG 1995</a> and <a href="https://wg21.cmeerw.net/ewg/issue169">EWG 169</a>)</li>
<li><a href="https://wg21.cmeerw.net/ewg/issue169">EWG 169</a>: Make exception specifications be part of the type system</li>
</ul>
</li>
</ul>
<p>Reviewing of following editor's reports is work in progress.</p>
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2008.html">N2008</a></li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2283.html">N2283</a></li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2589.html">N2589</a></li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2799.html">N2799</a></li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3001.html">N3001</a></li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3091.html">N3091</a></li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3938.html">N3938</a>
<ul>
<li>LWG motion 3: <a href="https://wg21.cmeerw.net/lwg/issue2188">LWG 2188</a> "Reverse iterator does not fully support targets that overload <code>operator&amp;</code>" with editorial fix</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4583.html">N4583</a>
<ul>
<li>LWG motion 6: <a href="https://wg21.link/p0220r1">P0220R1</a> "Adopt library fundamentals v1 TS components for C++17") (incompletely applied)</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4603.html">N4603</a>
<ul>
<li>LWG motion 34: <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0180r2.html">P0188R2</a>: Reserve a New Library Namespace Future Standardization</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4619.html">N4619</a></li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4661.html">N4661</a></li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4714.html">N4714</a></li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4740.html">N4740</a></li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4764.html">N4764</a>
<ul>
<li>CWG motion 15: <a href="https://wg21.link/p0941r2">P0941R2 "Feature-test macros"</a></li>
<li>LWG motion 21: <a href="https://wg21.link/p0879r0">P0879R0 "<code>constexpr</code> for <code>swap</code> and <code>swap</code>-related functions"</a> applied, resolving 1 issue:
<ul>
<li><a href="https://wg21.link/lwg2800">LWG 2800</a>: <code>constexpr</code> <code>swap</code>
The following issues are being waiting to be resolved (and then be reviewed here) formally in public standards.</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4792.html">N4792</a>
<ul>
<li>LWG motion 13: <a href="https://wg21.link/p0318r1">P0318R1 "<code>unwrap_ref_decay</code> and <code>unwrap_reference</code>"</a></li>
<li>LWG motion 21: <a href="https://wg21.link/p0591r4">P0591R4 "Utility functions to implement uses-allocator construction"</a></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue943">CWG 943</a>: Is <code>T()</code> a temporary?
<ul>
<li><strong>NOTE</strong> see also <a href="https://www.open-std.org/JTC1/SC22/WG21/docs/papers/2015/p0135r0.html">P0135R0</a></li>
</ul>
</li>
<li><a href="https://www.open-std.org/JTC1/SC22/WG21/docs/papers/2014/n3918.html">N3918</a> Core Issue 1299: Temporary objects vs temporary expressions
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue1299">CWG 1299</a>: “Temporary objects” vs “temporary expressions”
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue1651">CWG 1651</a>: Lifetime extension of temporary via reference to subobject</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1893">CWG 1893</a>: Function-style cast with braced-init-lists and empty pack expansions</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1300">CWG 1300</a>
<ul>
<li>see also <a href="https://wg21.cmeerw.net/cwg/issue914">CWG 914</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1661">CWG 1661</a>: Preservation of infinite loops</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1722">CWG 1722</a>: Should lambda to function pointer conversion function be <code>noexcept</code>?</li>
</ul>
<h1 id="no-actions"><a class="header" href="#no-actions">No actions</a></h1>
<p>There are nothing to do of coding and further documentations for some resolutions.</p>
<p>In WG21 terms:</p>
<ul>
<li>NAD means "not a defect".</li>
<li>TC1 means "Technical Corrigendum 1".</li>
</ul>
<h2 id="in-the-baseline"><a class="header" href="#in-the-baseline">In the baseline</a></h2>
<p>These issues are resolved as NAD and thus have been rejected by WG21 in the baseline, and there are no further changes to reopen:</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue37">CWG 37</a>: When is <code>uncaught_exception()</code> <code>true</code>?</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue61">CWG 61</a>: Address of static member function "<code>&amp;p-&gt;f</code>"</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue109">CWG 109</a>: Allowing <code>::template</code> in <em>using-declaration</em>​s</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue130">CWG 130</a>: Sequence points and <em>new-expression</em>​s</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue182">CWG 182</a>: Access checking on explicit specializations
<ul>
<li>see also <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0692r1.html">P0692R1</a></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue84">LWG 84</a>: Ambiguity with <code>string::insert()</code></li>
<li><a href="https://wg21.cmeerw.net/ewg/issue91">EWG 91</a>: [tiny] <a href="https://wg21.cmeerw.net/cwg/issue622">Core issue 622</a>, Relational comparisons of arbitrary pointers
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue622">CWG 622</a>: Relational comparisons of arbitrary pointers (see <a href="https://wg21.cmeerw.net/ewg/issue91">EWG 91</a>)</li>
</ul>
</li>
<li>parts of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2173.html">N2173</a>: Core Extensions for Evolution
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue13">CWG 13</a>: <code>extern "C"</code> for Parameters of Function Templates</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue107">CWG 107</a>: linkage of operator functions</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue168">CWG 168</a>: C linkage of static members</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue229">CWG 229</a>: Partial specialization of function templates</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue294">CWG 294</a>: can <code>static_cast</code> drop exception specs (see also <a href="https://wg21.cmeerw.net/cwg/issue87">CWG 87</a>)</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue359">CWG 359</a>: Type definition inside anonymous union</li>
</ul>
</li>
</ul>
<p>These issues were once confirmed but are in NAD status now due to newer feature changes which have been adopted by the standard and by this project, so there are nothing further to do:</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue395">CWG 395</a>: Conversion operator template syntax</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue178">LWG 178</a>: Should <code>clog</code> and <code>cerr</code> initially be tied to <code>cout</code>?
<ul>
<li>see also bullet 6 in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1569.htm">N1569</a></li>
<li>see also <a href="https://wg21.cmeerw.net/lwg/issue455">LWG 455</a>: <code>cerr::tie()</code> and <code>wcerr::tie()</code> are overspecified</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2386">LWG 2386</a>: <code>function::operator=</code> handles allocators incorrectly
<ul>
<li>see also <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0302r1.html">P0302R1</a></li>
</ul>
</li>
</ul>
<p>These resolutions are already adopted as TC1, i.e. in C++03, and still effective (probably revised) in later versions of the standard:</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue25">CWG 25</a>: Exception specifications and pointers to members</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue30">CWG 30</a>: Valid uses of "<code>::template</code>"</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue84">CWG 84</a>: Overloading and conversion loophole used by <code>auto_ptr</code></li>
<li><a href="https://wg21.cmeerw.net/cwg/issue137">CWG 137</a>: <code>static_cast</code> of <em>cv</em> <code>void*</code></li>
<li><a href="https://wg21.cmeerw.net/cwg/issue178">CWG 178</a>: More on value-initialization (see also <a href="https://wg21.cmeerw.net/cwg/issue543">CWG 543</a>)</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue304">CWG 304</a>: Value-initialization of a reference</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue29">LWG 29</a>: <code>Ios_base::init</code> doesn't exist</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue35">LWG 35</a>: No manipulator <code>unitbuf</code> in synopsis</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue61">LWG 61</a>: Exception-handling policy for unformatted output</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue129">LWG 129</a>: Need error indication from <code>seekp()</code> and <code>seekg()</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue136">LWG 136</a>: <code>seekp</code>, <code>seekg</code> setting wrong streams?</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue209">LWG 209</a>: <code>basic_string</code> declarations inconsistent</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue227">LWG 227</a>: <code>std::swap()</code> should require <code>CopyConstructible</code> or <code>DefaultConstructible</code> arguments</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue250">LWG 250</a>: splicing invalidates iterators</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2000/n1219.htm">N1219</a>: PROPOSED RESOLUTION TO LIBRARY ISSUE 60
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue60">LWG 60</a>: What is a formatted input function?</li>
</ul>
</li>
</ul>
<h2 id="not-related-to-user-code"><a class="header" href="#not-related-to-user-code">Not related to user code</a></h2>
<p>These issues are resolved as NAD or NAD editorial and thus nothing to do for user code:</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue1384">CWG 1384</a>: <code>reinterpret_cast</code> in constant expressions</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue435">CWG 1415</a>: Change "declararation or definition" to "declaration"</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1520">CWG 1520</a>: Alias template specialization vs pack expansion (see also <a href="https://wg21.cmeerw.net/cwg/issue1558">CWG 1558</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue299">LWG 299</a>: Incorrect return types for iterator dereference
<ul>
<li>resolved by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue392">LWG 392</a>: 'equivalence' for input iterators</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue408">LWG 408</a>: Is <code>vector&lt;reverse_iterator&lt;char*&gt; &gt;</code> forbidden?
<ul>
<li>resolved by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue526">LWG 526</a>: Is it undefined if a function in the standard changes in parameters?
<ul>
<li><strong>NOTE</strong> However, not all implementations are conforming, albeit they have been fixed at current.
<ul>
<li>See <a href="https://reviews.llvm.org/rL358534">LLVM r358534</a> and <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=91620">GCC PR 91620</a> for examples.</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue529">LWG 529</a>: The standard encourages redundant and confusing preconditions</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue580">LWG 580</a>: unused allocator members</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue867">LWG 867</a>: Valarray and value-initialization</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue1079">LWG 1079</a>: <code>RandomAccessIterator</code>'s <code>operator-</code> has nonsensical effects clause
<ul>
<li>resolved by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue1211">LWG 1211</a>: move iterators should be restricted as input iterators
<ul>
<li>resolved by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2006">LWG 2006</a>: <code>emplace</code> broken for associative containers
<ul>
<li>proposed by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3178.htm">N3178</a>: <code>emplace</code> broken for associative containers</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2204">LWG 2204</a>: <code>reverse_iterator</code> should not require a second copy of the base iterator</li>
</ul>
<p>These post-C++03 issues are still open, but it is technically not implying requirements of changes of any conforming implementations or programs:</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue2054">CWG 2054</a>: Missing description of class SFINAE
<ul>
<li><strong>NOTE</strong> Althoug no official actions are made, this is considered not related to user code for several reasons:
<ul>
<li>The standard rules have already support the use.
<ul>
<li>Rules in <a href="https://eel.is/c++draft/temp#spec.partial.order">[temp.spec.partial.order]</a> have already cover the cases, albeit quite implicit, by assuming there are no exceptional case (hard errors) on the deduction process described in the rules.</li>
<li>The example of <a href="https://eel.is/c++draft/temp#spec.partial.match-2">[temp.spec.partial.match/2]</a> shows the use of rules.</li>
<li>Then the rules in <a href="https://eel.is/c++draft/temp.deduct">[temp.deduct]</a> apply and no rules can definitely render a program merely having such deduction error as ill-formed.</li>
<li>The problem is that the reference to [temp.deduct] rules is not clear, so it can be an issue to improve.</li>
</ul>
</li>
<li>The idiomatic way of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4436.pdf">N4436</a> requires exactly such use.
<ul>
<li><code>void_t</code> has been in the standard by adoption of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3911.pdf">N3911</a>.</li>
<li>Typical implemenations of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4600.html#meta.detect">the correspoinding library components in N4600</a> also rely on the idiom itself.</li>
</ul>
</li>
<li>Major implementations have been support the feature for years.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>These post-C++03 draft resolutions are non-normative, purely editorial or conceptional, so no actions could be taken (revised b941[2022-03-15]):</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue113">CWG 113</a>: Visibility of called function</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue119">CWG 119</a>: Object lifetime and aggregate initialization</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue357">CWG 357</a>: Definition of signature should include name</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue404">CWG 404</a>: Unclear reference to construction with non-trivial constructor (<strong>NOTE</strong> partially superseded by new wording in <a href="https://eel.is/c++draft/basic.life">[basic.life]</a> proposed by <a href="https://wg21.cmeerw.net/cwg/issue1751">CWG 1751</a> and <a href="https://wg21.cmeerw.net/cwg/issue2256">CWG 2256</a>)</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue413">CWG 413</a>: Definition of "empty class"</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue452">CWG 452</a>: Wording nit on description of <code>this</code>, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2370.html">partially adopted</a></li>
<li><a href="https://wg21.cmeerw.net/cwg/issue525">CWG 525</a>: Missing <code>*</code> in example</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue538">CWG 538</a>: Definition and usage of structure, POD-struct, POD-union, and POD class
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue327">CWG 327</a>: Use of "structure" without definition</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue582">CWG 582</a>: Template conversion functions</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue594">CWG 594</a>: Coordinating issues 119 and 404 with delegating constructors (see <a href="https://wg21.cmeerw.net/cwg/issue119">CWG 119</a> and <a href="https://wg21.cmeerw.net/cwg/issue404">CWG 404</a>)</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue618">CWG 618</a>: Casts in preprocessor conditional expressions</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue627">CWG 627</a>: Values behaving as types</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue999">CWG 999</a>: “Implicit” or “implied” object argument/parameter?</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue542">LWG 542</a>: <code>shared_ptr</code> observers</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue610">LWG 610</a>: Suggested non-normative note for C++0x (i.e. small function object optimization)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue616">LWG 616</a>: missing '<code>typename</code>' in <code>ctype_byname</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue628">LWG 628</a>: Inconsistent definition of <code>basic_regex</code> constructor</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue640">LWG 640</a>: 27.6.2.5.2 does not handle (<code>unsigned</code>) <code>long long</code> (i.e. for <code>ostream::operator&lt;&lt;</code>), <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2370.html">outdated</a></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue724">LWG 724</a>: <code>DefaultConstructible</code> is not defined</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue868">LWG 868</a>: Default construction and value-initialization
<ul>
<li>see also <a href="https://wg21.cmeerw.net/lwg/issue724">LWG 724</a> and <a href="https://wg21.cmeerw.net/lwg/issue867">LWG 867</a></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue972">LWG 972</a>: The term "Assignable" undefined but still in use</li>
<li>part of <a href="https://wg21.cmeerw.net/lwg/issue2135">LWG 2135</a>: Unclear requirement for exceptions thrown in <code>condition_variable::wait()</code>
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2240">LWG 2240</a>: Probable misuse of term "function scope" in <a href="https://eel.is/c++draft/thread.condition">[thread.condition]</a></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2310">LWG 2310</a>: Public exposition only member in <code>std::array</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2434">LWG 2434</a>: <code>shared_ptr::use_count()</code> is efficient</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2755">LWG 2755</a>: §<a href="https://eel.is/c++draft/string.view.io">[string.view.io]</a> uses non-existent <code>basic_string_view::to_string</code> function</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue3310">LWG 3310</a>: Replace <code>SIZE_MAX</code> with <code>numeric_limits&lt;size_t&gt;::max()</code></li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2775.htm">N2775</a>: Small library thread-safety revisions</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a>: Iterators in C++0x</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3966.html">N3966</a>: Fixes for <code>optional</code> objects (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4078.html">N4078</a>)</li>
<li>editorial change in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4714.html">N4714</a></li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0134r0.html">P0134R0</a>: Introducing a name for <em>brace-or-equal-initializer</em>​s for non-static data members</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0583r0.pdf">P0583R0</a>: <code>std::byte</code> is the correct name</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1076r1.html">P1076R1</a>: Editorial clause reorganization <a href="https://github.com/cplusplus/draft/blob/master/papers/n4764.md">with modification</a></li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0509r1">P0509R1</a>: Updating "Restrictions on exception handling" (adopted: accepted by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4664.pdf">N4664</a>)
<ul>
<li>see national body comments GB 41 and GB 42 in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4664.pdf">N4664</a>: ISO/IEC CD 14882, C++ 2017, National Body Comments</li>
</ul>
</li>
</ul>
<p>These post-C++03 draft resolutions would <strong>never</strong> be depended on because they are only intended useful for language implementations and there shall be no compatibility problems for conforming code (revised b593[2015-04-23]):</p>
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2194.pdf">N2194</a>: <code>decltype</code> for the C++0x Standard Library</li>
</ul>
<p>These post-C++03 papers are used for changes spcifically on technical specifications and not relied on:</p>
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4041.html">N4041</a>: Concerns with changing existing types in Technical Specifications</li>
</ul>
<h2 id="outdated"><a class="header" href="#outdated">Outdated</a></h2>
<p>These resolutions are only about TR1 or features have been formally deprecated/removed from current ISO C++, so shall never be depended on:</p>
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue527">LWG 527</a>: <code>tr1::bind</code> has lost its Throws clause</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue588">LWG 588</a>: requirements on zero sized <code>tr1::array</code>s and other details (for <code>std::array</code>, resolved by <a href="https://wg21.cmeerw.net/lwg/issue776">LWG 776</a>)</li>
</ul>
<p>These issues are duplicate (in "dup" status):</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue133">CWG 133</a>: Exception specifications and checking (subsumed by <a href="https://wg21.cmeerw.net/cwg/issue87">CWG 87</a> and <a href="https://wg21.cmeerw.net/cwg/issue92">CWG 92</a>)</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue595">CWG 595</a>: Exception specifications in templates instantiated from class bodies (subsumed by <a href="https://wg21.cmeerw.net/cwg/issue1330">CWG 1330</a>)</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1300">CWG 1300</a>: <code>T()</code> for array types (duplicate of <a href="https://wg21.cmeerw.net/cwg/issue914">CWG 914</a>)</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1568">CWG 1568</a>: Temporary lifetime extension with intervening cast (duplicate of <a href="https://wg21.cmeerw.net/cwg/issue1376">CWG 1376</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue105">LWG 105</a>: <code>fstream</code> ctors argument types desired (duplicate of <a href="https://wg21.cmeerw.net/lwg/issue454">LWG 454</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue479">LWG 479</a>: Container requirements and placement new (duplicate of <a href="https://wg21.cmeerw.net/lwg/issue580">LWG 580</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue486">LWG 486</a>: <code>min</code>/<code>max</code> CopyConstructible requirement is too strict (duplicate of <a href="https://wg21.cmeerw.net/lwg/issue281">LWG 281</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2775">LWG 2775</a>: <code>reverse_iterator</code> is does not compile for fancy pointers (duplicate of <a href="https://wg21.cmeerw.net/lwg/issue1052">LWG 1052</a>)</li>
</ul>
<p>These resolutions are superseded by later modification on the working paper before the later publication of the standard:</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue35">CWG 35</a>: Definition of default-initialization (see <a href="https://wg21.cmeerw.net/cwg/issue178">CWG 178</a>)</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue2022">CWG 2022</a>: Copy elision in constant expressions (see by <a href="https://wg21.cmeerw.net/cwg/issue2278">CWG 2278</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue235">LWG 235</a>: No specification of default ctor for <code>reverse_iterator</code> (see by <a href="https://wg21.cmeerw.net/lwg/issue1012">LWG 1012</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue759">LWG 759</a>: A reference is not an object (see <a href="https://wg21.cmeerw.net/lwg/issue1204">LWG 1204</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2753">LWG 2753</a>: Optional's constructors and assignments need constraints (see <a href="https://wg21.cmeerw.net/lwg/issue2756">LWG 2756</a>)</li>
<li><a href="https://issues.isocpp.org/show_bug.cgi?id=72">LEWG 72</a>: <code>bad_optional_access</code> should derive from <code>std::exception</code>, not <code>std::logic_error</code> (see <a href="https://wg21.cmeerw.net/lwg/issue2842">LWG 2806</a>)</li>
</ul>
<p>These resoultions are issues for TSes and later superseded in the working paper and the TSes are not used:</p>
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2451">LWG 2451</a>: [fund.ts.v2] <code>optional&lt;T&gt;</code> should 'forward' <code>T</code>'s implicit conversions (see <a href="https://wg21.cmeerw.net/lwg/issue2756">LWG 2756</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2745">LWG 2745</a>: [fund.ts.v2] Implementability of <a href="https://wg21.cmeerw.net/lwg/issue2451">LWG 2451</a> (see <a href="https://wg21.cmeerw.net/lwg/issue2756">LWG 2756</a>)</li>
</ul>
<p>These papers are superseded and newer revisions have been reviewed, so no further actions would be taken:</p>
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1489.pdf">N1489</a>: Templates aliases for C++ (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2112.pdf">N2112</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1599.html">N1599</a>: <a href="https://wg21.cmeerw.net/lwg/issue431">Issue 431</a>: Swapping containers with unequal allocators (see subsequent <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2525.pdf">N2525</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1890.pdf">N1890</a>: Initialization and initializers (see subsequent <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1919.pdf">N1919</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1919.pdf">N1919</a>: Initializer lists (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2100.pdf">N2100</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1932.pdf">N1932</a>: Random Number Generation in C++0X: A Comprehensive Proposal (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2032.pdf">N2032</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1961.html">N1961</a>: Wording for range-based for-loop (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2196.html">N2196</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1968.pdf">N1968</a>: Lambda expressions and closures for C++ (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2329.pdf">N2329</a>: Lambda expressions and closures for C++ (Revision 1))</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2032.pdf">N2032</a>: Random Number Generation in C++0X: A Comprehensive Proposal, version 2 (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2079.pdf">N2079</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2062.html">N2062</a>: POD's Revisited (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2102.html">N2102</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2079.pdf">N2079</a>: Random Number Generation in C++0X: A Comprehensive Proposal, version 3 (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2111.pdf">N2111</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2095.html">N2095</a>: <code>long long</code> Goes to the Library (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2114.html">N2114</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2100.pdf">N2100</a>: Initializer lists (Rev 2.) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2215.pdf">N2215</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2102.html">N2102</a>: POD's Revisited; Resolving Core Issue 568 (Revision 1) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2172.html">N2172</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2112.pdf">N2112</a>: Templates Aliases (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2258.pdf">N2258</a>)
<ul>
<li><strong>NOTE</strong> The <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/">page</a> missed the link to Previous Version.</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2151.pdf">N2151</a>: Variadic Templates for the C++0x Standard Library (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2192.pdf">N2192</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2172.html">N2172</a>: POD's Revisited; Resolving Core Issue 568 (Revision 2) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2230.html">N2230</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2192.pdf">N2192</a>: Variadic Templates for the C++0x Standard Library (Revision 1) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2242.pdf">N2242</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2196.html">N2196</a>: Wording for range-based <code>for</code>-loop (revision 1) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2243.html">N2243</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2210.html">N2210</a>: Defaulted and Deleted Functions (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2326.html">N2326</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2202.html">N2202</a>: C99 Compatibility : <code>__func__</code> and predeclared identifiers (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2251.html">N2251</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2215.pdf">N2215</a>: Initializer lists (Rev. 3) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2385.pdf">N2385</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2217.pdf">N2217</a>: Placement Insert for Containers (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2268.pdf">N2268</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2230.html">N2230</a>: POD's Revisited; Resolving Core Issue 568 (Revision 3) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2294.html">N2294</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2236.pdf">N2236</a>: Towards support for attributes in C++ (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2379.pdf">N2379</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2243.html">N2243</a>: Wording for range-based <code>for</code>-loop (revision 2) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2394.html">N2394</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2251.html">N2251</a>: C99 Compatibility : <code>__func__</code> and predeclared identifiers (revision 1) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2340.htm">N2340</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2268.pdf">N2268</a>: Placement Insert for Containers (Revision 1) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2345.pdf">N2345</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2294.html">N2294</a>: POD's Revisited; Resolving Core Issue 568 (Revision 4) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2342.htm">N2342</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2326.html">N2326</a>: Defaulted and Deleted Functions (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2346.htm">N2346</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2329.pdf">N2329</a>: Lambda expressions and closures for C++ (Revision 1) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2413.pdf">N2413</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2345.pdf">N2345</a>: Placement Insert for Containers (Revision 2) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2642.pdf">N2642</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2379.pdf">N2379</a>: Towards support for attributes in C++ (Revision 2) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2418.pdf">N2418</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2385.pdf">N2385</a>: Initializer lists WP wording (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2531.pdf">N2531</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2394.html">N2394</a>: Wording for range-based <code>for</code>-loop (revision 3) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2778.htm">N2778</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2413.pdf">N2413</a>: Lambda Expressions and Closures: Wording for Monomorphic Lambdas (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2487.pdf">N2487</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2418.pdf">N2418</a>: Towards support for attributes in C++ (Revision 3) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2553.pdf">N2553</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2477.pdf">N2477</a>: Uniform initialization design choices (Revision 2) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2532.pdf">N2532</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2487.pdf">N2487</a>: Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 2) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2529.pdf">N2529</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2529.pdf">N2529</a>: Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 3) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2550.pdf">N2550</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2531.pdf">N2531</a>: Initializer lists WP wording (Revision 2) (see subsequent <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2575.pdf">N2575</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2532.pdf">N2532</a>: Uniform initialization design choices (Revision 2) (see subsequent <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2575.pdf">N2575</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2550.pdf">N2550</a>: Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 4) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf">N2927</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2553.pdf">N2553</a>: Towards support for attributes in C++ (Revision 4) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2751.pdf">N2751</a>; the unavailable revised revision N2663 is wrong on <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/">document list</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2575.pdf">N2575</a>: Initializer Lists — Alternative Mechanism and Rationale (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2640.pdf">N2640</a>)</li>
<li><a href="https://www.open-std.org/JTC1/SC22/WG21/docs/papers/2008/n2635.html">N2635</a>: Local and Unnamed Types as Template Arguments (revised by <a href="https://www.open-std.org/JTC1/SC22/WG21/docs/papers/2008/n2657.htm">N2657</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2640.pdf">N2640</a>: Initializer Lists — Alternative Mechanism and Rationale (v. 2) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2672.htm">N2672</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2642.pdf">N2642</a>: Proposed Wording for Placement Insert (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2680.pdf">N2680</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2751.pdf">N2751</a>: Towards support for attributes in C++ (Revision 5) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2761.pdf">N2761</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2778.htm">N2778</a>: Wording for range-based <code>for</code>-loop (revision 4) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2930.html">N2930</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2820.pdf">N2820</a>: Adding heterogeneous comparison lookup to associative containers (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2882.pdf">N2882</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2882.pdf">N2882</a>: Adding heterogeneous comparison lookup to associative containers for TR2 (Rev 1) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3465.pdf">N3465</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2904.pdf">N2904</a>: Defining default copy and move (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2953.html">N2953</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2953.html">N2953</a>: Defining Move Special Member Functions (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2987.html">N2987</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2987.html">N2987</a>: Defining Move Special Member Functions (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3044.html">N3044</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3044.html">N3044</a>: Defining Move Special Member Functions (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3053.html">N3053</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3149.html">N3149</a>: From <em>Throws: Nothing</em> to <code>noexcept</code> (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3195.htm">N3195</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3248.pdf">N3248</a>: <code>noexcept</code> Prevents Library Validation (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3279.pdf">N3279</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3433.html">N3433</a>: Clarifying Memory Allocation (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3537.html">N3537</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3465.pdf">N3465</a>: Adding heterogeneous comparison lookup to associative containers for TR2 (Rev 2) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3657.htm">N3657</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3537.html">N3537</a>: Clarifying Memory Allocation (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3664.html">N3664</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3597.html">N3597</a>: Relaxing constraints on <code>constexpr</code> functions (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3652.html">N3652</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3598.html">N3598</a>: <code>constexpr</code> member functions and implicit <code>const</code> (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3652.html">N3652</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3727.html">N3727</a>: A proposal to add <code>invoke</code> function template (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4169.html">N4169</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3873.html">N3873</a>: Improved insertion interface for unique-key maps (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4006.html">N4006</a> and <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4240.html">N4240</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4002.pdf">N4002</a>: Cleaning‐up <code>noexcept</code> in the Library (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4227.pdf">N4227</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4006.html">N4006</a>: An improved <code>emplace()</code> for unique-key maps (dropped; see other derivation of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3873.html">N3873</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4017.htm">N4017</a>: Non-member <code>size()</code> and more (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4155.htm">N4155</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4056.html">N4056</a>: Minimal incomplete type support for standard containers (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4371.html">N4371</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4151.html">N4151</a>: TriviallyCopyable <code>reference_wrapper</code> (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4277.html">N4277</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4155.htm">N4155</a>: Non-member <code>size()</code> and more (Revision 1) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4280.pdf">N4280</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4227.pdf">N4227</a>: Cleaning-up noexcept in the Library (Rev 2) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4258.pdf">N4258</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4228.pdf">N4228</a>: Refining Expression Evaluation Order for Idiomatic C++ (see subsequent <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0145r0.pdf">P0145R0</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4240.html">N4240</a>: Improved insertion interface for unique-key maps (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4279.html">N4279</a>)</li>
<li><a href="https://www.open-std.org/JTC1/SC22/WG21/docs/papers/2014/n4334.html">N4334</a>: Wording for <code>bool_constant</code> (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4389.html">N4389</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4371.html">N4371</a>: Minimal incomplete type support for standard containers, revision 2 (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4390.html">N4390</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4390.html">N4390</a>: Minimal incomplete type support for standard containers, revision 3 (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4371.html">N4510</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4429.html">N4429</a>: Rewording inheriting constructors ((<a href="https://wg21.cmeerw.net/cwg/issue1941">core issue 1941</a> et al) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0136r0.html">P0136R0</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4446.html">N4446</a>: The missing <em><code>INVOKE</code></em> related trait (i.e. <code>is_callable</code>) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0077r0.html">P0077R2</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0136r0.html">P0136R0</a>: Rewording inheriting constructors ((<a href="https://wg21.cmeerw.net/cwg/issue1941">core issue 1941</a> et al) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0136r1.html">P0136R1</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0145r0.pdf">P0145R0</a>: Refining Expression Evaluation Order for Idiomatic C++ (Revision 1) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r1.pdf">P0145R1</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0068r0.pdf">P0068R0</a>: Proposal of <code>[[unused]]</code>, <code>[[nodiscard]]</code> and <code>[[fallthrough]]</code> attributes. (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0188r0.pdf">P0188R0</a> and <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0189r0.pdf">P0189R0</a> in parts, see subsequent <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0212r0.pdf">P0212R0</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0077r0.html">P0077R0</a>: <code>is_callable</code>, the missing <em><code>INVOKE</code></em> related trait (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0077r1.html">P0077R1</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0077r1.html">P0077R1</a>: <code>is_callable</code>, the missing <em><code>INVOKE</code></em> related trait (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0077r2.html">P0077R2</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r1.pdf">P0145R1</a>: Refining Expression Evaluation Order for Idiomatic C++ (Revision 2) (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r2.pdf">P0145R2</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r2.pdf">P0145R2</a>: Refining Expression Evaluation Order for Idiomatic C++ (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r3.pdf">P0145R3</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0188r0.pdf">P0188R0</a>: Wording for <code>[[fallthrough]]</code> attribute. (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0188r1.pdf">P0188R1</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0189r0.pdf">P0189R0</a>: Wording for <code>[[nodiscard]]</code> attribute. (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0189r1.pdf">P0189R1</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0212r0.pdf">P0212R0</a>: Wording for <code>[[maybe_unused]]</code> attribute. (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0212r1.pdf">P0212R1</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0302r0.html">P0302R0</a>: Deprecating Allocator Support in <code>std::function</code> (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0302r1.html">P0302R1</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1089r2.pdf">P1089R2</a>: Sizes Should Only span Unsigned (see subseqent <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1227r1.html">P1227R1</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1227r0.html">P1227R0</a>: Signed <code>ssize()</code> functions, unsigned <code>size()</code> functions (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1227r1.html">P01227R1</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1227r1.html">P1227R1</a>: Signed <code>ssize()</code> functions, unsigned <code>size()</code> functions (revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1227r2.html">P01227R2</a>)</li>
</ul>
<p>These papers have been previously adopted but superseded by newer adopted papers, so no further actions would be taken:</p>
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2525.pdf">N2525</a>: Allocator-specific Swap and Move Behavior (adopted 2008-03, in editor's report <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2589.html">N2589</a>; revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3672.html">N3672</a>: A proposal to add a utility class to represent optional objects (Revision 4) (adopted 2013-04; revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3793.html">N3793</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0077r2.html">P0077R2</a>: <code>is_callable</code>, the missing <em><code>INVOKE</code></em> related trait (adopted 2016-02; revised by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0604r0.html">P0604R0</a>)</li>
</ul>
<p>These features were still under development but the approved versions were superseded (note that the superseded versions may still newer than currently adopted version), and not adopted in this document:</p>
<ul>
<li><a href="https://wg21.cmeerw.net/ewg/issue22">EWG 22</a>: N4030, 3745, N3694 Feature-testing recommendations for C++, N3435 Standardized feature-test macros (for adopted version, see <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4200.htm">N4200</a>)
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3435.htm">N3435</a>: Standardized feature-test macros</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3694.htm">N3694</a>: Feature-testing recommendations for C++</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3745.htm">N3745</a>: Feature-testing recommendations for C++</li>
<li><a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2014/n4030.htm">N4030</a>: Feature-testing recommendations for C++</li>
<li><a href="https://www.open-std.org/JTC1/SC22/WG21/docs/papers/2015/p0096r0.html">P0096R0</a>: Feature-testing recommendations for C++</li>
<li><a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0096r4.html">P0096R4</a>: Feature-testing recommendations for C++ (see subsequent <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0941r0.html">P0941R0</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0941r0.html">P0941R0</a>: Integrating feature-test macros into the C++ WD</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0941r1.html">P0941R1</a>: Integrating feature-test macros into the C++ WD</li>
</ul>
</li>
<li><a href="https://www.open-std.org/JTC1/SC22/WG21/docs/papers/2014/n3890.html">N3890</a>: <code>Container&lt;Incomplete Type&gt;</code> (partially superseded by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4056.html">N4056</a>)</li>
</ul>
<h2 id="revoked"><a class="header" href="#revoked">Revoked</a></h2>
<p>These resolutions are overriden by later issues after publications of the standard:</p>
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue22">LWG 22</a>: Member <code>open</code> vs. flags (see <a href="https://wg21.cmeerw.net/lwg/issue409">LWG 409</a>)
<ul>
<li><strong>NOTE</strong> This is non-editorial but finally changes only informal texts.</li>
</ul>
</li>
</ul>
<p>These features were once adopted by the working paper but later removed away, so no actions would be taken until introduced to the draft again:</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue1308">CWG 1308</a>: Completeness of class type within an exception-specification (see <a href="https://wg21.cmeerw.net/cwg/issue1330">CWG 1330</a>)</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue86">LWG 1029</a>: Specialized algorithms for memory management need to be concept-constrained templates</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue1001">LWG 1001</a>: Pointers, concepts and headers (see <a href="https://wg21.cmeerw.net/lwg/issue1178">LWG 1178</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2525.pdf">N2525</a>: Allocator-specific Swap and Move Behavior (i.e. <code>allocator_propagate_*</code>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2620.pdf">N2620</a>: Concepts for the C++0x Standard Library: Diagnostics library</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2736.pdf">N2736</a>: Concepts for the C++0x Standard Library: Numerics (Revision 3)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2755.htm">N2755</a>: Concepts for the C++0x Standard Library: Chapter 17 -Introduction (Revision 2)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2758.pdf">N2758</a>: Iterator Concepts for the C++0x Standard Library (Revision 5)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2759.pdf">N2759</a>: Concepts for the C++0x Standard Library: Algorithms (Revision 5)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2768.pdf">N2768</a>: Allocator Concepts, part 1 (revision 2)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2770.pdf">N2770</a>: Concepts for the C++0x Standard Library: Utilities (Revision 5)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2773.pdf">N2773</a>: Proposed Wording for Concepts (Revision 9)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2774.pdf">N2774</a>: Foundational Concepts for the C++0x Standard Library (Revision 5)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2776.pdf">N2776</a>: Concepts for the C++0x Standard Library: Containers (Revision 4)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2777.pdf">N2777</a>: Concepts for the C++0x Standard Library: Iterators (Revision 4)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2779.pdf">N2779</a>: Concepts for Clause 18: Part 2</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2780.pdf">N2780</a>: Named Requirements for C++0X Concepts, version 2</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2786.pdf">N2786</a>: Simplifying <code>unique_copy</code> (Revision 1)</li>
</ul>
<p>There are actions taken by the committee to remove away some former working draft features which are never used in this project:</p>
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2549.htm">N2549</a>: Excision of Clause 31 (i.e. <code>&lt;date_time&gt;</code>)</li>
</ul>
<h2 id="non-defects"><a class="header" href="#non-defects">Non defects</a></h2>
<p>These out-of-baseline issues are resolved as NAD:</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue1005">CWG 1005</a>: Qualified name resolution in member functions of class templates (see also <a href="https://wg21.cmeerw.net/cwg/issue1017">CWG 1017</a>; note <a href="https://wg21.cmeerw.net/cwg/issue515">CWG 515</a> is still effective)</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1334">CWG 1334</a>: Layout compatibility and cv-qualification</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue466">LWG 466</a>: <code>basic_string</code> ctor should prevent null pointer error</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue760">LWG 760</a>: The <code>emplace</code> issue (see <a href="https://wg21.cmeerw.net/lwg/issue2164">LWG 2164</a> which is still open)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue763">LWG 763</a>: Renaming <code>emplace()</code> overloads (<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2680.pdf">N2680</a> renamed one of the overloads to <code>emplace_hint</code>; for related discussion see <a href="https://wg21.cmeerw.net/lwg/issue1302">LWG 1302</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue851">LWG 851</a>: simplified array construction
<ul>
<li>see <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html">N4480</a>: Programming Languages — C++ Extensions for Library Fundamentals
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4391">N4391</a>: <code>make_array</code>, revision 4</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue1202">LWG 1202</a>: <code>integral_constant</code> needs a spring clean</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue1302">LWG 1302</a>: different emplace semantics for sequence and associated containers</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue1651">LWG 1651</a>: Lifetime extension of temporary via reference to subobject</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2311">LWG 2311</a>: Allocator requirements should be further minimized</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2319">LWG 2319</a>: <code>basic_string</code>'s move constructor should not be <code>noexcept</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2446">LWG 2446</a>: Unspecialized <code>std::tuple_size</code> should be defined</li>
</ul>
<h2 id="not-applicable"><a class="header" href="#not-applicable">Not applicable</a></h2>
<p>Some proposals are not approved.</p>
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3400.html">N3400</a>: A proposal for eliminating the underscore madness that library writers have to suffer</li>
</ul>
<p>Some proposals are not applicable yet and to be resolved in future. There also may be workaround provided by C++ implementation extensions or user code.</p>
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2683.html">N2683</a>: issue 454: problems and solutions
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue454">LWG 454</a>: <code>basic_filebuf::open</code> should accept <code>wchar_t</code> names</li>
</ul>
</li>
</ul>
<h2 id="in-development"><a class="header" href="#in-development">In development</a></h2>
<p>These issues are in "extension" state and not ready to be adopted:</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue476">CWG 476</a>: Determining the buffer size for placement new (see also <a href="https://wg21.cmeerw.net/cwg/issue256">CWG 256</a>)</li>
</ul>
<h1 id="adoption"><a class="header" href="#adoption">Adoption</a></h1>
<p>C++11 core language features and headers below now are being used.</p>
<p>Note: the "adopted" time notes listed in following entries are relative to the working paper.</p>
<h2 id="imported-tr1-headers"><a class="header" href="#imported-tr1-headers">Imported TR1 Headers</a></h2>
<p>TR1(see <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf">N1836</a>) headers imported to C++11 are used:</p>
<ul>
<li><code>&lt;array&gt;</code> (since b218[2011-06-14])</li>
<li><code>&lt;type_traits&gt;</code> (since b206[2011-05-03])</li>
<li><code>&lt;tuple&gt;</code> (since b206[2011-05-03])
<ul>
<li>not relying on <a href="https://wg21.cmeerw.net/lwg/issue1118">LWG 1118</a>: <code>tuple</code> query APIs do not support cv-qualification
<ul>
<li>replaced by <code>ystdex::tuple_size</code> (see below)</li>
</ul>
</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue1191">LWG 1191</a>: <code>tuple</code> <code>get</code> API should respect rvalues</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue1382">LWG 1382</a>: <code>pair</code> and <code>tuple</code> constructors should forward arguments</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue1384">LWG 1384</a>: Function <code>pack_arguments</code> is poorly named (i.e. <code>forward_as_tuple</code>; since b206[2011-05-03])</li>
<li>with <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2244.html">N2244</a>: Wording for <code>decay</code>, <code>make_pair</code> and <code>make_tuple</code></li>
<li>with <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2299.html">N2299</a>: Concatenating <code>tuple</code>s, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2370.html">with modification</a> (since b303[2012-04-23])</li>
</ul>
</li>
<li><code>&lt;unordered_map&gt;</code> (since b206[2011-05-03])</li>
<li><code>&lt;unordered_set&gt;</code> (since b206[2011-05-03])</li>
</ul>
<h2 id="new-headers"><a class="header" href="#new-headers">New headers</a></h2>
<p>New headers after C++03 may be used.</p>
<h3 id="c11-baseline"><a class="header" href="#c11-baseline">C++11 baseline</a></h3>
<p>New non-TR1 headers from C++11 are used:</p>
<ul>
<li><code>&lt;atomic&gt;</code> (for all platforms from b590[2015-04-03]; for platforms supporting multithreading since b328[2011-07-25]; for platform MinGW32 since b299[2013-04-08])</li>
<li><code>&lt;chrono&gt;</code> (since b291[2012-03-07])</li>
<li><code>&lt;forward_list&gt;</code> (since b218[2011-06-14]; see <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2543.htm">N2543</a>)
<ul>
<li>without <a href="https://wg21.cmeerw.net/lwg/issue1340">LWG 1340</a>: Why does <code>forward_list::resize</code> take the object to be copied by value?</li>
</ul>
</li>
<li><code>&lt;initializer_list&gt;</code> (since b297[2012-03-27]; see <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2672.htm">N2672</a>)</li>
<li><code>&lt;typeindex&gt;</code> (since b468[2014-01-20])</li>
<li><code>&lt;regex&gt;</code> (since b795[2017-06-11])</li>
<li><code>&lt;system_error&gt;</code> (since b476[2014-02-16]; see <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2241.html">N2241</a>)</li>
</ul>
<h3 id="multithreading"><a class="header" href="#multithreading">Multithreading</a></h3>
<p>For all implementations supporting multithreading, these headers are also used:</p>
<ul>
<li><code>&lt;condition_variable&gt;</code> (since b328[2011-07-25]; for platform MinGW32 since b299[2013-04-08])</li>
<li><code>&lt;future&gt;</code> (since b520[2014-07-23])</li>
<li><code>&lt;mutex&gt;</code> (since b328[2011-07-25]; for platform MinGW32 since b299[2013-04-08])</li>
<li><code>&lt;thread&gt;</code> (since b328[2011-07-25]; for platform MinGW32 since b299[2013-04-08])</li>
</ul>
<p>Note: <a href="https://wg21.cmeerw.net/lwg/issue1360">LWG 1360</a> specified single-threaded program should be able to use <code>&lt;atomic&gt;</code>, and resolved by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3256.html">N3256</a>. However, the current YSLib doesn't require it for single-threaded programs.</p>
<h3 id="beyond-c11"><a class="header" href="#beyond-c11">Beyond C++11</a></h3>
<p>For rules of baseline, new headers are only used conditionally, mostly for avoiding need of replacements in non-C++11 modes where the specified headers are available.</p>
<ul>
<li>`&lt;memory_resource&gt; (since b842[2018-10-27]
<ul>
<li>replacement provided by <code>&lt;ystdex/memory_resource.h&gt;</code> if not available</li>
</ul>
</li>
<li>`&lt;string_view&gt; (since b833[2018-07-31]
<ul>
<li>replacement provided by <code>&lt;ystdex/string_view.hpp&gt;</code> if not available</li>
</ul>
</li>
<li><code>&lt;optional&gt;</code> (since b831[2018-07-13])
<ul>
<li>replacement provided by <code>&lt;ystdex/optional.h&gt;</code> if not available
<ul>
<li>with parts of <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0032r3.pdf">P0032R3</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="technical-specifications"><a class="header" href="#technical-specifications">Technical Specifications</a></h2>
<p>Technical Specifications are retargetted to standards finally. Not all features are used until they are adopted to the standard draft.</p>
<h3 id="tr1"><a class="header" href="#tr1">TR1</a></h3>
<p>TR1 features was once used, but now retired and corresponding ISO C++ features shall be used, since they are imported from TR1 (see editor's report <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2008.html">N2008</a> and the correspoinding working draft <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2009.pdf">N2009</a>) (since b206[2011-05-03]):</p>
<ul>
<li>TR1 <code>&lt;type_traits&gt;</code> including metafunctions and <code>std::tr1::aligned_storage</code> (since b175[2010-12-23])
<ul>
<li>replaced by C++11 <code>std::aligned_storage</code>, see <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2341.pdf">N2341</a> (since b206[2011-05-03])</li>
</ul>
</li>
<li>TR1 <code>&lt;memory&gt;</code> <code>std::tr1::shared_ptr</code> (since b203[2011-04-22])
<ul>
<li>replaced by C++11 <code>std::shared_ptr</code> (since b206[2011-05-03])</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue545">LWG 545</a>: When is a deleter deleted?, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2283.html">reworded slightly</a></li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue575">LWG 575</a>: the specification of <code>~shared_ptr</code> is MT-unfriendly, makes implementation assumptions, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2283.html">reworded slightly</a></li>
<li>see also <a href="https://wg21.cmeerw.net/lwg/issue611">LWG 611</a></li>
</ul>
</li>
</ul>
<p>Some TR1 features are not used, as C++11 features are directly used instead:</p>
<ul>
<li>TR1 <code>&lt;memory&gt;</code> <code>std::tr1::function</code> is superseded by <code>std::function</code> (since b207[2011-05-09])
<ul>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2132">LWG 2132</a>: <code>std::function</code> ambiguity</li>
</ul>
</li>
<li>TR1 <code>&lt;cstdint&gt;</code> types in <code>std::tr1</code> are superseded <code>std</code> types in ISO C++11 (since b209[2011-05-14])
<ul>
<li><strong>NOTE</strong> Previously, <code>&lt;stdint.h&gt;</code> from GCC or ISO C99 was used optionally (since b133[2010-07-16]).</li>
</ul>
</li>
<li>TR1 <code>&lt;cmath&gt;</code> <code>std::tr1::llround</code> is superseded by <code>std::llround</code> (since b260[2011-11-15])
<ul>
<li><strong>NOTE</strong> The feature was not actually relied on, instead ISO C99 <code>llround</code> in the global namespace was used as a workaround for implementations, until YBase.LibDefect.CMath was settled (since b556[2014-11-27]).</li>
</ul>
</li>
</ul>
<p>Some features are not used, but being compatible (see also <a href="StandardUsing.en-US.html#neutral-of-existence">Neutral of existence</a> features below).</p>
<ul>
<li>TR1 additions to header <code>&lt;cfloat&gt;</code></li>
</ul>
<p>Other superseded TR1 features in the listed headers above may be also relied on since then.</p>
<h3 id="other-tses"><a class="header" href="#other-tses">Other TSes</a></h3>
<p>Although not used directly for evolution rules, some adopted modifications have already in the final draft of technical specifications:</p>
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html">N4480</a>: Programming Languages — C++ Extensions for Library Fundamentals
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2409">LWG 2409</a>: [fund.ts] SFINAE-friendly <code>common_type</code>/<code>iterator_traits</code> should be removed from the fundamental-ts (adopted 2014-06)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4288.html">N4288</a>: Strike <code>string_view::clear</code> from Library Fundamentals (adopted 2014-11)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3843.pdf">N3843</a>: A SFINAE-Friendly <code>std::common_type</code> (adopted 2014-03, removed for LWG 2409 2014-11)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4391">N4391</a>: <code>make_array</code>, revision 4 (adopted 2015-04)
<ul>
<li>see also direct replacement <code>ystdex::make_array</code></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4562.html">N4562</a>: Working Draft, C++ Extensions for Library Fundamentals, Version 2
<ul>
<li>parts on <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3793.html">N3793</a>: A proposal to add a utility class to represent optional objects (Revision 5)
<ul>
<li>revised previously-adopted <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3672.html">N3672</a>: A proposal to add a utility class to represent optional objects (Revision 4) (adopted 2013-04)
<ul>
<li>moved to Library TS by LWG motion 6 in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3769.pdf">N3769</a></li>
</ul>
</li>
</ul>
</li>
<li>with <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3765.pdf">N3765</a>: On Optional</li>
<li>based on <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4282.pdf">N4282</a>: A Proposal for the World's Dumbest Smart Pointer, v4</li>
</ul>
</li>
</ul>
<p>They are listed here for exposition-only use. The actual adoption depends on items depending them on.</p>
<h2 id="adopted-changes"><a class="header" href="#adopted-changes">Adopted changes</a></h2>
<p>Features adopted shall be compatible with rules for general status.</p>
<h3 id="to-be-reviewd"><a class="header" href="#to-be-reviewd">To be reviewd</a></h3>
<p>These pre-C++11 resolutions are believed have been relied on. It is yet to determine the "since" clause (reviewed b865[2019-08-30]).</p>
<ul>
<li>some issues resolved by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2757.htm">N2757</a>: Expedited core issues handling (revision 2)
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue614">CWG 614</a>: Results of integer <code>/</code> and <code>%</code></li>
<li><a href="https://wg21.cmeerw.net/cwg/issue624">CWG 624</a>: Overflow in calculating size of allocation (see also <a href="https://wg21.cmeerw.net/cwg/issue476">CWG 476</a>)
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue256">CWG 256</a>: overflow calculating size of new array</li>
<li>see also <code>std::bad_array_new_length</code> from <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2932.pdf">N2932</a> (since b941[2022-03-15])</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="restrictive-improvement"><a class="header" href="#restrictive-improvement">Restrictive improvement</a></h3>
<p>The conformance of following lists of clearer specification with probable stronger restrictions (to the implementation and program-provided code including this project) or fixed specifications aligned with all existed implementations are concerned and took into account (revised b971[2023-04-04]).</p>
<p>For specifications before C++11:</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue96">CWG 96</a>: Syntactic disambiguation using the <code>template</code> keyword</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue201">LWG 201</a>: Numeric limits terminology wrong</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue220">CWG 220</a>: require de-allocation not throw</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue274">LWG 274</a>: a missing/impossible allocator requirement (partially overriden by <a href="https://wg21.cmeerw.net/lwg/issue2447">LWG 2447</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue294">LWG 294</a>: User defined macros and standard headers</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue300">LWG 300</a>: <code>list::merge()</code> specification incomplete</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue386">LWG 386</a>: Reverse iterator's <code>operator[]</code> has impossible return type</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue416">LWG 416</a>: definitions of <code>XXX_MIN</code> and <code>XXX_MAX</code> macros in <code>climits</code>, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2283.html">reworded slightly</a></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue422">LWG 422</a>: explicit specializations of member functions of class templates, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2283.html">reworded slightly</a></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue456">LWG 456</a>: Traditional C header files are overspecified</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue420">LWG 420</a>: is <code>std::FILE</code> a complete type?</li>
</ul>
<p>For specifications between C++11 and C++14:</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue1376">CWG 1376</a>: <code>static_cast</code> of temporary to rvalue reference (see also <a href="https://wg21.cmeerw.net/cwg/1568">CWG 1568</a>)</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1430">CWG 1430</a>: Pack expansion into fixed alias template parameter list</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1493">CWG 1493</a>: Criteria for move-construction</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1570">CWG 1570</a>: Address of subobject as non-type template argument</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1596">CWG 1596</a>: Non-array objects as <code>array[1]</code></li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1629">CWG 1629</a>: Can a closure class be a literal type?</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1672">CWG 1672</a>: Layout compatibility with multiple empty bases</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1751">CWG 1751</a>: Non-trivial operations vs non-trivial initialization</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1885">CWG 1885</a>: Return value of a function is underspecified</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2013">LWG 2013</a>: Do library implementers have the freedom to add <code>constexpr</code>? (see also <a href="https://stackoverflow.com/questions/22182432/is-gcc-considering-builtins-of-non-constant-expression-functions-to-be-constant">here</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2014">LWG 2014</a>: More restrictions on macro names</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2447">LWG 2447</a>: Allocators and <code>volatile</code>-qualified value types</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3436.html">N3436</a>: <code>std::result_of</code> and SFINAE</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3644.pdf">N3644</a>: Null Forward Iterators (adopted 2013-04)</li>
</ul>
<p>For specifications between C++14 and C++17:</p>
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2129">LWG 2129</a>: User specializations of <code>std::initializer_list</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2139">LWG 2139</a>: What is a <em>user-defined</em> type?</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2150">LWG 2150</a>: Unclear specification of <code>find_end</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2419">LWG 2419</a>: Clang's libc++ extension to <code>std::tuple</code>
<ul>
<li>resolved by <a href="https://wg21.cmeerw.net/lwg/issue2312">LWG 2312</a> and <a href="https://wg21.cmeerw.net/lwg/issue2549">LWG 2549</a></li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0180r2.html">P0180R2</a>: Reserve a New Library Namespace Future Standardization
<ul>
<li>adopted by LWG motion 34 in editor's report <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4603.html">N4603</a></li>
<li><strong>NOTE</strong> The title in LWG motion 34 in N4603 is "Reserve a New Library Namespace Future <em>for</em> Standardization". This seems more correct.</li>
</ul>
</li>
</ul>
<p>For specification beyond C++17 (including drafting and WP state):</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue2256">CWG 2256</a>: Lifetime of trivially-destructible objects</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue3031">LWG 3031</a>: Algorithms and predicates with non-<code>const</code> reference arguments</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue3140">LWG 3140</a>: <code>COMMON_REF</code> is unimplementable as specified (adopted 2018-11, in editor's report <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4792.html">N4792</a>)</li>
</ul>
<h3 id="deprecation"><a class="header" href="#deprecation">Deprecation</a></h3>
<p>Features in the following adopted deprecation are <strong>not</strong> depended on (revised b863[2019-08-01]):</p>
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0174r2.html">P0174R2</a>: Deprecating Vestigial Library Parts in C++17 (adopted 2016-06; since b835[2018-08-13])
<ul>
<li>see the replacment of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0174r2.html#4.4"><code>std::get_temporary_buffer</code></a></li>
</ul>
</li>
<li>deprecation of <code>shared_ptr</code> <code>unique</code> in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0521r0.html">P0521R0</a>: Proposed Resolution for CA 14 (<code>shared_ptr</code> <code>use_count</code>/<code>unique</code>) (adopted 2016-11; since b835[2018-08-14])
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2776">LWG 2776</a>: <code>shared_ptr</code> <code>unique()</code> and <code>use_count()</code></li>
<li>see national body comment <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0488r0.pdf#CA14">CA 14</a> in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0488r0.pdf">P0488R0</a>: WG21 Working Paper, NB Comments, ISO/IEC CD 14882</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0767r1.html">P0767R1</a>: Deprecate POD
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue2323">CWG 2323</a>: Expunge POD</li>
<li>see national body comment <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0488r0.pdf#US101">US 101</a> in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0488r0.pdf">P0488R0</a>: WG21 Working Paper, NB Comments, ISO/IEC CD 14882 (adopted 2017-11; since b853[2018-02-15])</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0806r2.html">P0806R2</a>: Deprecate implicit capture of <code>this</code> via <code>[=]</code> (adopted 2018-06)</li>
</ul>
<h3 id="removal"><a class="header" href="#removal">Removal</a></h3>
<p>Several features removed in C++17 are <strong>not</strong> depended on (revised b935[2021-12-26]):</p>
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2385">LWG 2385</a>: <code>function::assign</code> allocator argument doesn't make sense</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2487">LWG 2487</a>: <code>bind()</code> should be <code>const</code>-overloaded, not <em>cv</em>-overloaded
<ul>
<li>in libstdc++ this is an extension (although declared deprecated by <code>_GLIBCXX_DEPR_BIND</code>) but the implementation (<code>std::__volget</code>) is essentially not type-safe (with <code>const_cast</code> to remove <code>volatile</code> in the calls)</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0001r1.html">P0001R1</a>: Remove Deprecated Use of the <code>register</code> Keyword</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0002r1.html">P0002R1</a>: Remove Deprecated <code>operator++(bool)</code></li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0004r1.html">P0004R1</a>: Remove Deprecated iostreams aliases</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0302r1.html">P0302R1</a>: Removing Allocator Support in <code>std::function</code> (rev 1) (adopted 2016-06)
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2308.html">N2308</a>: Adding allocator support to <code>std::function</code> for C++0x, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2370.html">with modification</a></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2370">LWG 2370</a>: Operations involving type-erased allocators should not be <code>noexcept</code> in <code>std::function</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2501">LWG 2501</a>: <code>std::function</code> requires POCMA/POCCA</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2502">LWG 2502</a>: <code>std::function</code> does not use allocator::construct</li>
<li>see also the replacement <code>ystdex::function</code></li>
</ul>
</li>
<li>all parts but mentioned below of removal in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0003r5.html">P0619R4</a>: Reviewing Deprecated Facilities of C++17 for C++20
<ul>
<li>D.4 C++ standard library headers [depr.cpp.headers]</li>
<li>D.7 uncaught_exception [depr.uncaught]</li>
<li>D.8 Old adaptable function bindings [depr.func.adaptor.binding]</li>
<li>D.9 The default allocator [depr.default.allocator]</li>
<li>D.10 Raw storage iterator [depr.storage.iterator]</li>
<li>D.12 Deprecated type traits [depr.meta.types]</li>
<li>D.14 Deprecated <code>shared_ptr</code> observers [depr.util.smartptr.shared.obs]</li>
</ul>
</li>
</ul>
<p>A few features already removed are conditionally enabled only when available (for old versions of the language dialects):</p>
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0003r5.html">P0003R1</a>: Removing Deprecated Exception Specifications from C++17</li>
<li>D.3 Deprecated exception specifications [depr.except.spec] in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0003r5.html">P0619R4</a>: Reviewing Deprecated Facilities of C++17 for C++20</li>
</ul>
<p>A few features already removed are replaced directly:</p>
<ul>
<li><code>std::get_temporary_buffer</code> in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0619r4.html#3.11">P0619R4</a> are replaced by <code>ystdex::get_temporary_buffer</code></li>
</ul>
<h3 id="c11-features"><a class="header" href="#c11-features">C++11 features</a></h3>
<p>C++11 library features used indirectly (not mandated, but with design in mind that could make more interface usable, e.g. macro substitution or template instantiations):</p>
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2761.pdf">N2761</a>: Towards support for attributes in C++ (Revision 6)</li>
</ul>
<p>Other C++11 core and library features used directly (without the features the program will either be ill-formed or has unexpected behavior for some input allowed by the API):</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue45">CWG 45</a>: Access to nested classes (since b273[2012-01-01])
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue8">CWG 8</a>: Access to template arguments used in a function return type and in the nested name specifier</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue10">CWG 10</a>: Can a nested class access its own class name as a qualified name if it is a private member of the enclosing class?</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue87">CWG 87</a>: Exception specifications on function parameters (see also <a href="https://wg21.cmeerw.net/cwg/issue25">CWG 25</a>, <a href="https://wg21.cmeerw.net/cwg/issue92">CWG 92</a> and <a href="https://wg21.cmeerw.net/cwg/issue133">CWG 133</a>; since b249[2011-10-15])</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue208">CWG 208</a>: Rethrowing exceptions in nested handlers (since b461[2013-12-23])</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue222">CWG 222</a>: Sequence points and lvalue-returning operators (since b297[2012-03-27])
<ul>
<li>with <a href="https://wg21.cmeerw.net/cwg/issue637">CWG 637</a>: Sequencing rules and example disagree</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue226">CWG 226</a>: Default template arguments for function templates (since b387[2013-03-11])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue254">CWG 254</a>: Exception types in clause 19 are constructed from <code>std::string</code> (since b643[2015-10-08]; i.e. <code>const char*</code> parameter in constructor of standard exception classes)</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue302">CWG 302</a>: Value-initialization and generation of default constructor (since b206[2011-05-03])</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue339">CWG 339</a>: Overload resolution in operand of <code>sizeof</code> in constant expression (since b591[2015-04-10])</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue382">CWG 382</a>: Allow <code>typename</code> outside of templates (since b421[2013-07-03])</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue519">CWG 519</a>: Null pointer preservation in void* conversions (since b204[2011-04-26])</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue542">CWG 542</a>: Value initialization of arrays of POD-structs (since b206[2011-05-03])</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue765">CWG 765</a>: Local types in inline functions with external linkage (since b282[2012-02-04])
<ul>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue1157">LWG 1157</a>: Local types can now instantiate templates</li>
<li>with extra assumption of the identity of types in function templates or in functions of class templates across translation units <a href="https://stackoverflow.com/questions/34717823/can-using-a-lambda-in-header-files-violate-the-odr/34721371#34721371">which is potentially a core language defect</a>
<ul>
<li>see also <a href="Development.zh-CN.html">here(zh-CN)</a> for detailed explanation and requiremnts on implementation</li>
</ul>
</li>
<li>applied to <a href="https://www.open-std.org/JTC1/SC22/WG21/docs/papers/2008/n2657.htm">N2657</a></li>
<li>applied to <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf">N2927</a></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1104">CWG 1104</a>: Global-scope template arguments vs the <code>&lt;:</code> digraph (since b493[2014-04-16])</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1330">CWG 1330</a>: Delayed instantiation of <code>noexcept</code> specifiers (since b792[2017-06-05])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue49">LWG 49</a>: Underspecification of <code>ios_base::sync_with_stdio</code> (since b565[2015-01-16])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue91">LWG 91</a>: Description of <code>operator&gt;&gt;</code> and <code>getline()</code> for <code>string&lt;&gt;</code> might cause endless loop (since b663[2015-12-18])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue130">LWG 130</a>: Return type of <code>container::erase(iterator)</code> differs for associative containers (since b216[2011-06-08])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue254">LWG 254</a>: Exception types in clause 19 are constructed from <code>std::string</code> (since b643[2015-10-08])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue265">LWG 265</a>: <code>std::pair::pair()</code> effects overly restrictive (since b206[2011-05-03])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue280">LWG 280</a>: Comparison of <code>reverse_iterator</code> to <code>const reverse_iterator</code> (since b408[2013-05-30])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue371">LWG 371</a>: Stability of <code>multiset</code> and <code>multimap</code> member functions (since b216[2011-06-08])
<ul>
<li>see also <a href="https://wg21.cmeerw.net/lwg/issue130">LWG 130</a></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue376">LWG 376</a>: <code>basic_streambuf</code> semantics (since b616[2015-07-21])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue419">LWG 419</a>: istream extractors not setting failbit if eofbit is already set (since b437[2015-01-16])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue438">LWG 438</a>: Ambiguity in the "do the right thing" clause (since b274[2012-01-04])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue453">LWG 453</a>: <code>basic_stringbuf::seekoff</code> need not always fail for an empty stream (since b617[2015-07-25])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue534">LWG 534</a>: Missing <code>basic_string</code> members (i.e. <code>basic_string</code> <code>pop_back</code>, <code>back</code> and <code>front</code>; since b315[2012-06-08])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue559">LWG 559</a>: <code>numeric_limits&lt;const T&gt;</code>, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2283.html">reworded slightly</a> (since b440[2013-08-29])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue564">LWG 564</a>: <code>stringbuf</code> <code>seekpos</code> underspecified (since b743[2016-11-21])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue589">LWG 589</a>: Requirements on iterators of member template functions of containers (since b216[2011-06-08])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue596">LWG 596</a>: 27.8.1.3 Table 112 omits <code>"a+"</code> and <code>"a+b"</code> modes (since b326[2012-07-19])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue611">LWG 611</a>: Standard library templates and incomplete types (since b206[2011-05-03])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue694">LWG 694</a>: <code>std::bitset</code> and <code>long long</code> (since b932[2021-12-04])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue704">LWG 704</a>: MoveAssignable requirement for container value type overly strict (since b206[2011-05-03])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue711">LWG 711</a>: Contradiction in empty <code>shared_ptr</code> (since b784[2017-04-29])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue762">LWG 762</a>: <code>std::unique_ptr</code> requires complete type? (since b238[2011-09-07])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue811">LWG 811</a>: <code>pair</code> of pointers no longer works with literal <code>0</code> (since b206[2011-05-03])
<ul>
<li>partially superseded when <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4387.html">N4387</a> is conditonally used</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue868">LWG 868</a>: Default construction and value-initialization (since b206[2011-05-03])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue771">LWG 771</a>: Impossible throws clause in <a href="https://eel.is/c++draft/string.conversions">[string.conversions]</a> (since b375[2013-01-22])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue772">LWG 772</a>: Impossible return clause in <a href="https://eel.is/c++draft/string.conversions">[string.conversions]</a> (since b375[2013-01-22])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue806">LWG 806</a>: <code>unique_ptr::reset</code> effects incorrect, too permissive (since b206[2011-05-03])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue809">LWG 809</a>: <code>std::swap</code> should be overloaded for array types (since b620[2015-08-02])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue817">LWG 817</a>: <code>bind</code> needs to be moved (since b401[2013-05-02])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue900">LWG 900</a>: Stream move-assignment (tentatively since b620[2015-08-01]; since b727[2016-09-17])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue911">LWG 911</a>: I/O streams and move/swap semantic (tentatively since b620[2015-08-01]; since b727[2016-09-17])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue922">LWG 922</a>: <a href="https://eel.is/c++/draft/func.bind.place">[func.bind.place]</a> Number of placeholders (since b437[2013-08-22])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue929">LWG 929</a>: Thread constructor (since b384[2013-03-01])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue993">LWG 993</a>: <code>_Exit</code> needs better specification (since b565[2015-01-16])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue1019">LWG 1019</a>: Make <code>integral_constant</code> objects useable in <em>integral-constant-expression</em>​s (since b590[2015-04-10])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue1040">LWG 1040</a>: Clarify possible sameness of associative container's <code>iterator</code> and <code>const_iterator</code> (since b496[2014-05-01])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue1178">LWG 1178</a>: Header dependencies (since b338[2012-09-13])
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue343">LWG 343</a>: Unspecified library header dependencies (see also <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2259.html">N2259</a>)</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue1192">LWG 1192</a>: <code>basic_string</code> missing definitions for <code>cbegin</code> / <code>cend</code> / <code>crbegin</code> / <code>crend</code> (since b546[2014-10-17])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue1382">LWG 1382</a>: <code>pair</code> and <code>tuple</code> constructors should forward arguments (since b206[2011-05-03])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1626.pdf">N1626</a>: Proposed Resolution for Core Issue 39 (Rev. 1) (since b447[2013-09-25])
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue39">CWG 39</a>: Conflicting ambiguity rules</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1653.htm">N1653</a>: Working draft changes for C99 preprocessor synchronization (since b257[2011-11-04])
<ul>
<li><strong>NOTE</strong> Previously only the support of variadic macros and empty macro arguments as a GCC extension is used.</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1720.html">N1720</a>: Proposal to Add Static Assertions to the Core Language (Revision 3) (since b206[2011-05-03])
<ul>
<li>with <a href="https://wg21.cmeerw.net/cwg/issue676">CWG 676</a>: <em>static_assert-declaration</em>​s and general requirements for declarations</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1757.html">N1757</a>: Right Angle Brackets (Revision 1) (since b206[2011-05-03])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1780.html">N1780</a>: Comments on LWG issue 233: Insertion hints in associative containers (since b216[2011-06-08])
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue233">LWG 233</a>: Insertion hints in associative containers</li>
<li>see also <a href="https://wg21.cmeerw.net/lwg/issue371">LWG 371</a></li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1811.pdf">N1811</a>: Adding the <code>long long</code> type to C++ (Revision 3) (since b206[2011-05-03])
<ul>
<li>with specializations of <code>numerical_limits</code> in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2114.html">N2114</a>: <code>long long</code> Goes to the Library, Revision 1 (since b932[2021-12-04])</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1822.pdf">N1822</a>: A Proposal to add a max significant decimal digits value to the C++ Standard Library Numeric limits (since b260[2011-11-12]; i.e. <code>numeric_limits::max_digits10</code>)
<ul>
<li>without <a href="https://wg21.cmeerw.net/lwg/issue613">LWG 613</a>: <code>max_digits10</code> missing from <code>numeric_limits</code></li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf">N1836</a>: Draft Technical Report on C++ Library Extensions (Built-in type traits) (since b206[2011-05-03])
<ul>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue1182">LWG 1182</a>: Unfortunate <code>hash</code> dependencies</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue1255">LWG 1255</a>: <code>declval</code> should be added to the library (since b260[2011-11-14])</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue1270">LWG 1270</a>: <code>result_of</code> should be moved to <code>&lt;type_traits&gt;</code> (since b245[2011-09-23])</li>
</ul>
</li>
<li><code>cbegin</code>/<code>cend</code>/<code>crbegin</code>/<code>crend</code> from <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1913.pdf">N1913</a>: A Proposal to Improve <code>const_iterator</code> Use (version 2) (since b206[2011-05-03])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a>: Rvalue Reference Recommendations for Chapter 23, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2283.html">reworded</a> (since b216[2011-06-08])
<ul>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue759">LWG 759</a> superseded by <a href="https://wg21.cmeerw.net/lwg/issue1204">LWG 1204</a></li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1984.pdf">N1984</a>: Deducing the type of variable from its initializer expression (revision 4) (since b206[2011-05-03]; i.e. <code>auto</code>-typed variables)
<ul>
<li>with <a href="https://wg21.cmeerw.net/cwg/issue615">CWG 615</a>: Incorrect description of variables that can be initialized</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1986.pdf">N1986</a>: Delegating Constructors (revision 3) (since b311[2011-05-25])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1987.htm">N1987</a>: Adding "<code>extern template</code>" (version 2) (since b206[2011-05-03])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2005.pdf">N2005</a>: A maximum significant decimal digits value for the C++0x Standard Library Numeric limits (since b301[2012-04-13])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2179.html">N2179</a>: Language Support for Transporting Exceptions between Threads (since b538[2014-09-28]; i.e. <code>exception_ptr</code> and <code>current_exception</code>, etc)
<ul>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue829">LWG 829</a>: <code>current_exception</code> wording unclear about exception type</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue1130">LWG 1130</a>: <code>copy_exception</code> name misleading (i.e. <code>make_exception_ptr</code>; since b550[2014-11-04])</li>
<li>with <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3195.htm">N3195</a>: From <em>Throws: Nothing</em> to <code>noexcept</code> (version 2)</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf">N2235</a>: Generalized Constant Expressions—Revision 5 (since b246[2011-09-23]; i.e. <code>constexpr</code>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2238.html">N2238</a>: Minimal Unicode support for the standard library (revision 3) (since b253[2011-10-18])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2239.html">N2239</a>: A finer-grained alternative to sequence points (revised) (since b297[2012-03-27]; notably order of aggregate initialization, see also <a href="https://wg21.cmeerw.net/cwg/issue1030">CWG 1030</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2240.html">N2240</a>: Two missing traits: <code>enable_if</code> and <code>conditional</code>, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2283.html">added specification when <code>B</code> is <code>false</code></a> (since b206[2011-05-03])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2241.html">N2241</a>: Diagnostics Enhancements for C++0x (Rev. 1), <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2283.html">reworded</a> (since b476[2014-02-16]; i.e. <code>&lt;system_error&gt;</code>)
<ul>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue805">LWG 805</a>: <code>posix_error::posix_errno</code> concerns (since b550[2014-11-04]; i.e. <code>errc</code>)</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2242.pdf">N2242</a>: Proposed Wording for Variadic Templates (Revision 2) (since b251[2011-10-08])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2244.html">N2244</a>: Wording for <code>decay</code>, <code>make_pair</code> and <code>make_tuple</code> (since b206[2011-05-03])</li>
<li>features from <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2246.html">N2246</a>: 2 of the least crazy ideas for the standard library in C++0x (i.e. <code>next</code>/<code>prev</code>/<code>is_sorted_until</code>/<code>is_heap_until</code>)
<ul>
<li><code>next</code>/<code>prev</code> (since b375[2013-01-22])</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2249.html">N2249</a>: New Character Types in C++, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2283.html">library part reworded</a> (since b253[2011-10-18])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2255.html">N2255</a>: Minor Modifications to the type traits Wording Revision 2, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2283.html">reworded</a> (since b206[2011-05-03])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2258.pdf">N2258</a>: Templates Aliases (since b433[2013-08-01])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2259.html">N2259</a>: Specify header dependency for <code>&lt;iostream&gt;</code> (since b338[2012-09-13]; see also <a href="https://wg21.cmeerw.net/lwg/issue343">LWG 343</a>)</li>
<li>features(e.g. <code>alignof</code>) from <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2341.pdf">N2341</a>: Adding Alignment Support to the C++ Programming Language / Wording
<ul>
<li><code>std::aligned_storage</code> used instead of <code>std::tr1::aligned_storage</code> since b206[2011-05-03]</li>
<li>other features except <code>std::aligned_union</code> used since b315[2012-06-08]</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2342.htm">N2342</a>: POD's Revisited; Resolving Core Issue 568 (Revision 5) (since b206[2011-05-03])
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue543">CWG 543</a>: Value initialization and default constructors</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue568">CWG 568</a>: Definition of POD is too strict</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2343.pdf">N2343</a>: Decltype (revision 7) (since b206[2011-05-03])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2346.htm">N2346</a>: Defaulted and Deleted Functions (since b207[2011-05-05])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf">N2347</a>: Strongly Typed Enums (revision 3), <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2370.html">with modification</a> (since b261[2011-11-19])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2348.pdf">N2348</a>: Wording for <code>std::numeric_limits&lt;T&gt;::lowest()</code> (since b242[2011-09-16])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2349.pdf">N2349</a>: Constant Expressions in the Standard Library — Revision 2, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2370.html">with modification</a> (since b260[2011-11-12])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf">N2350</a>: Container <code>insert</code>/<code>erase</code> and iterator constness (Revision 1) (since b531[2014-08-31])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2351.htm">N2351</a>: Improving <code>shared_ptr</code> for C++0x, Revision 2 (i.e. <code>make_shared</code> etc; since b529[2014-08-24])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2431.pdf">N2431</a>: A name for the null pointer: <code>nullptr</code> (revision 4) (since b206[2011-05-03]; the replacement as compatible layer introduced since b204[2011-04-26])
<strong>NOTE</strong> The replacement is direct in YDefinition.</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2437.pdf">N2437</a>: Explicit Conversion Operator Draft Working Paper (revision 3) (since b260[2011-11-15])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2439.htm">N2439</a>: Extending move semantics to <code>*this</code> (revised wording) (since b591[2015-04-11])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2442.htm">N2442</a>: Raw and Unicode String Literals; Unified Proposal (Rev. 2)
<ul>
<li>unicode string literals used since b253[2011-10-18]</li>
<li>raw string literals used since b431[2013-07-23]</li>
<li>other features used since b434[2013-08-04]</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2530.html">N2530</a>: Making It Easier to Use <code>std::type_info</code> as an Index in an Associative Container (since b468[2014-01-20]; i.e. <code>type_info::hash_code</code>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2535.htm">N2535</a>: Namespace Association ("<code>inline namespace</code>") (since b427[2013-07-11])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2540.htm">N2540</a>: Inheriting Constructors (revision 5) (since b538[2014-09-24])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2541.htm">N2541</a>: New Function Declarator Syntax Wording (since b207[2011-05-05])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2543.htm">N2543</a>: STL singly linked lists (revision 3) (since b218[2011-06-04]; i.e. <code>&lt;forward_list&gt;</code>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2544.pdf">N2544</a>: Unrestricted Unions (Revision 2) (since b569[2015-01-29])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2546.pdf">N2546</a>: Removal of <code>auto</code> as a storage-class specifier (since b206[2011-05-03])
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue629">CWG 629</a>: <code>auto</code> parsing ambiguity</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2559.htm">N2559</a>: Nesting Exception Objects (Revision 1) (since b477[2014-02-19])
<ul>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue819">LWG 819</a>: <code>rethrow_if_nested</code></li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue1136">LWG 1136</a>: Incomplete specification of <code>nested_exception::rethrow_nested()</code></li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2634.html">N2634</a>: Solving the SFINAE problem for expressions (since b591[2015-04-10])
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue339">CWG 339</a>: Overload resolution in operand of <code>sizeof</code> in constant expression</li>
</ul>
</li>
<li><a href="https://www.open-std.org/JTC1/SC22/WG21/docs/papers/2008/n2657.htm">N2657</a>: Local and Unnamed Types as Template Arguments (since b206[2011-05-03])
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue488">CWG 488</a>: Local types, overload resolution, and template argument deduction</li>
<li>with <a href="https://wg21.cmeerw.net/cwg/issue765">CWG 765</a> above</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2659.htm">N2659</a>: Thread-Local Storage (since b425[2013-07-08])
<ul>
<li>with <a href="https://wg21.cmeerw.net/cwg/issue810">CWG 810</a>: Block-scope <code>thread_local</code> variables should be implicitly <code>static</code> (since b425[2013-07-08])</li>
</ul>
</li>
<li>parts of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2666.pdf">N2666</a>: More STL algorithms (revision 2)
<ul>
<li><code>all_of</code> (since b494[2014-04-24])</li>
<li><code>any_of</code> (since b360[2012-12-08])</li>
<li><code>none_of</code> (since b547[2014-10-25])</li>
<li><code>find_if_not</code> (since b408[2013-05-30])</li>
<li><code>copy_n</code> (since b292[2012-03-12])</li>
<li><code>partition_point</code> (since b968[2023-02-17])</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2672.htm">N2672</a>: Initializer List proposed wording (since b297[2012-03-27])
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue1030">CWG 1030</a>: Evaluation order in initializer-lists used in aggregate initialization (since b297[2012-03-27]; see also <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2239.html">N2239</a>)</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2680.pdf">N2680</a>: Proposed Wording for Placement Insert (Revision 1) (since b286[2012-02-19])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2709.html">N2709</a>: Packaging Tasks for Asynchronous Execution (since b520[2014-07-23]; i.e. <code>packaged_task</code>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2756.htm">N2756</a>: Non-static data member initializers (since b360[2013-04-29])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2764.pdf">N2764</a>: Forward declaration of enumerations (rev. 3) (since b658[2015-12-08])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>: Fixing a Safety Problem with Rvalue References: Proposed Wording (Revision 1) (since b206[2011-05-03])
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue1138">CWG 1138</a>: Rvalue-ness check for rvalue reference binding is wrong (since b206[2011-05-03])</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf">N2927</a>: New wording for C++0x Lambdas (rev. 2) (since b212[2011-05-27])
<ul>
<li>with <a href="https://wg21.cmeerw.net/cwg/issue765">CWG 765</a> above</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2930.html">N2930</a>: Range-Based For Loop Wording (Without Concepts) (since b316[2011-06-11])</li>
<li><code>std::bad_array_new_length</code> from <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2932.pdf">N2932</a>: Fixing freestanding: iteration 2.2 (since b941[2022-03-15])</li>
<li>features from <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a>: Allocators post Removal of C++ Concepts (Rev 1)
<ul>
<li><code>std::addressof</code> used since b288[2012-02-26]
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue970">LWG 970</a>: <code>addressof</code> overload unneeded</li>
</ul>
</li>
<li><code>std::allocator_traits</code> except propagation traits used since b592[2015-04-19]</li>
<li>propagation traits in <code>std::allocator_traits</code> used since b830[2018-07-08]
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue431">LWG 431</a>: Swapping containers with unequal allocators</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3050.html">N3050</a>: Allowing Move Constructors to Throw (Rev. 1) (since b319[2012-06-24]; i.e. <code>noexcept</code> and <code>std::move_if_noexcept</code>)
<ul>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue1349">LWG 1349</a>: <code>swap</code> should not throw</li>
<li>with <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3180.htm">N3180</a>: More on <code>noexcept</code> for the Strings Library (since b329[2012-08-05])</li>
<li>with <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3279.pdf">N3279</a>: Conservative use of <code>noexcept</code> in the Library (since b461[2013-12-23])</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3052.html">N3052</a>: Converting Lambdas to Function Pointers (since b360[2012-12-07])</li>
<li>features except in <code>&lt;type_traits&gt;</code> from <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3053.html">N3053</a>: Defining Move Special Member Functions (since b230[2011-08-07])
<ul>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue1309">LWG 1309</a>: Missing expressions for Move/CopyConstructible
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue1283">LWG 1283</a>: MoveConstructible and MoveAssignable need clarification of moved-from state</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3143.html">N3143</a>: Proposed wording for US 90 (since b206[2011-05-03]; i.e. <code>std::forward</code>)</li>
<li><a href="https://www.open-std.org/JTC1/SC22/WG21/docs/papers/2010/n3168.htm">N3168</a>: Problems with Iostreams Member Functions (Amended from US 137) (since b805[2017-09-26])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3189.htm">N3189</a>: Observers for the three <em>handler functions</em> (since b550[2014-11-04])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3272.htm">N3272</a>: Follow-up on <code>override</code> control (since b311[2011-05-25])</li>
</ul>
<h2 id="tentatively-applied"><a class="header" href="#tentatively-applied">Tentatively applied</a></h2>
<p>All adopted changes are confirmed being included in the newest working paper and would not be removed in future unless they are not in the working paper or published standard any longer.</p>
<h3 id="platform-dependent-features"><a class="header" href="#platform-dependent-features">Platform-dependent features</a></h3>
<p>Some features only are relied in platform-dependent implementation details where all of supported platforms of the project has been confirmed to support. Currently (revised b971[2023-04-05]) there are none, but see the YCLib replacements below.</p>
<h3 id="conditionally-used-features"><a class="header" href="#conditionally-used-features">Conditionally used features</a></h3>
<p>Some C++11 features are not requried to reduce compatibility impact on implementations, but can be utilized when available, i.e. used <strong>conditionally</strong> (by conditional inclusion or being transparent):</p>
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2340.htm">N2340</a>: C99 Compatibility : <code>__func__</code> and predeclared identifiers (revision 2) (since b638[2015-09-24])</li>
</ul>
<p>Some post-C++11 features are used <strong>conditionally</strong>:</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue616">CWG 616</a>: Definition of “indeterminate value” (since b663[2016-01-11]) (see also <a href="https://wg21.cmeerw.net/cwg/issue1213">CWG 1213</a>)
<ul>
<li>without <a href="https://wg21.cmeerw.net/cwg/issue129">CWG 129</a>: Stability of uninitialized auto variables</li>
<li>without <a href="https://wg21.cmeerw.net/cwg/issue240">CWG 240</a>: Uninitialized values and undefined behavior (see also <a href="https://wg21.cmeerw.net/cwg/issue129">CWG 129</a>)
<ul>
<li>without <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_338.htm">WG14/DR338</a></li>
</ul>
</li>
<li>without <a href="https://wg21.cmeerw.net/cwg/issue312">CWG 312</a>: “use” of invalid pointer value not defined (see also <a href="https://wg21.cmeerw.net/cwg/issue623">CWG 623</a>)</li>
<li>without <a href="https://wg21.cmeerw.net/cwg/issue623">CWG 623</a>: Use of pointers to deallocated storage (see also <a href="https://wg21.cmeerw.net/cwg/issue623">CWG 312</a>)</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1581">CWG 1581</a>: When are <code>constexpr</code> member functions defined? (since b834[2016-08-03])</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1558">CWG 1558</a>: Unused arguments in alias template specializations (since b653[2015-11-25]; see also <a href="https://wg21.cmeerw.net/cwg/issue1430">CWG 1430</a>, <a href="https://wg21.cmeerw.net/cwg/issue1520">CWG 1520</a> and <a href="https://wg21.cmeerw.net/cwg/issue1554">CWG 1554</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2285">LWG 2285</a>: <code>make_reverse_iterator</code> (since b595[2015-05-01])
<ul>
<li>replaced by <code>ystdex::make_reverse_iterator</code> conditionally since b833[2018-07-29]</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3421.htm">N3421</a>: Making Operator Functors <code>greater&lt;&gt;</code> (since b679[2016-03-19]; see also <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3657.htm">N3657</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3478.html">N3478</a>: Core Issue 1512: Pointer comparison vs qualification conversions (since b562[2014-12-22])
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue73">CWG 73</a>: Pointer equality</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1512">CWG 1512</a>: Pointer comparison vs qualification conversions</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3493.html">N3493</a>: Compile-time integer sequences (since b589[2015-04-03])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3652.html">N3652</a>: Relaxing constraints on <code>constexpr</code> functions/<code>constexpr</code> member functions and implicit <code>const</code> (adopted 2013-04; since b591[2015-04-15])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3655.pdf">N3655</a>: TransformationTraits Redux, v2 (since b595[2015-05-01])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3656.htm">N3656</a>: <code>make_unique</code> (Revision 1) (since b617[2015-07-23])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3657.htm">N3657</a>: Adding heterogeneous comparison lookup to associative containers (rev 4) (adopted 2013-04; rev 3 not in the list)
<ul>
<li>without <code>is_transparent</code> since b678[2016-03-17]</li>
<li>with <code>is_transparent</code> since b679[2016-03-19]</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3671.html">N3671</a>: Making non-modifying sequence operations more robust: Revision 2 (since b627[2015-08-30])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3778.html">N3778</a>: C++ Sized Deallocation (since b842[2018-10-29])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4169.html">N4169</a>: A proposal to add <code>invoke</code> function template (Revision 1) (since b617[2015-07-23])
<ul>
<li><strong>without</strong> <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1065r2.html">P1065R2</a>: <code>constexpr</code> <em>INVOKE</em></li>
</ul>
</li>
<li><code>pair</code> constructors improvement in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4387.html">N4387</a>: Improving <code>pair</code> and <code>tuple</code>, revision 3 (adopted 2015-05; since b850[2019-01-14])
<ul>
<li>missed in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4528.html">N4528</a>, see <a href="https://github.com/cplusplus/draft/commit/c8347e3f3caa2ecef1b1dd869ce15b9095134a1a">this commit</a>.</li>
<li><strong>without</strong> <a href="https://wg21.cmeerw.net/lwg/issue2051">LWG 2051</a>: Explicit <code>tuple</code> constructors for more than one parameter</li>
<li><strong>without</strong> partially addressed <a href="https://wg21.cmeerw.net/lwg/issue2312">LWG 2312</a>: <code>tuple</code>'s constructor constraints need to be phrased more precisely</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2397">LWG 2397</a>: <code>map::emplace</code> and explicit <code>V</code> constructors
<ul>
<li>see also <a href="https://wg21.cmeerw.net/ewg/issue114">EWG 114</a>: N4074 Let <code>return {expr}</code> Be Explicit, Revision 2, N4131 explicit should never be implicit, N4094 Response To: Let <code>return {expr}</code> Be Explicit, N4029 Let return Be Direct and <code>explicit</code>, N3452 (unpublished) Let <code>{x,y,z}</code> =&gt; <code>explicit</code> (resolved as NAD)</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4389.html">N4389</a>: Wording for <code>bool_constant</code>, revision 1 (since b617[2015-07-23])</li>
<li>some C11 features in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0063r3.html">P0063R3</a>: C++17 should refer to C11 instead of C99 (adopted 2016-06)
<ul>
<li><code>DBL_HAS_SUBNORM</code>, <code>FLT_HAS_SUBNORM</code> and <code>LDBL_HAS_SUBNORM</code> (since b932[2021-12-04])</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0035r4.html">P0035R4</a>: Dynamic memory allocation for over-aligned data (since b835[2018-08-14])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0188r1.pdf">P0188R1</a>: Wording for <code>[[fallthrough]]</code> attribute. (adopted 2016-02; since b793[2017-06-06])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0189r1.pdf">P0189R1</a>: Wording for <code>[[nodiscard]]</code> attribute. (adopted 2016-02; since b823[2018-07-26])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0212r1.pdf">P0212R1</a>: Wording for <code>[[maybe_unused]]</code> attribute. (adopted 2016-02; since b823[2018-07-26])</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0386r2.pdf">P0386R2</a>: Inline Variables (adopted 2016-06; since b831[2018-07-13])</li>
<li>part (with only the signature available in C++11) of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0674r1.html">P0674R1</a>: Extending <code>make_shared</code> to Support Arrays (adopted 2017-07; since b849[2018-12-30])
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2070">LWG 2070</a>: <code>allocate_shared</code> should use <code>allocator_traits::construct</code></li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0593r6.html">P0593R6</a>: Implicit creation of objects for low-level object manipulation (adopted 2020-02; since b966[2023-02-01])
<ul>
<li><strong>NOTE</strong> This was incorrectly relied on since b865[2019-08-25].</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1774r8.pdf">P1774R8</a>: Portable assumptions (adopted 2022-08; since b971[2018-04-02])</li>
</ul>
<h3 id="feature-testing"><a class="header" href="#feature-testing">Feature testing</a></h3>
<p>Following Feature Testing study group (SD-6 recommendations approved by SG 10) documents after <a href="https://wg21.cmeerw.net/ewg/issue22">EWG 22</a> have been reviewed, with some of them applied or updated:</p>
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4200.htm">N4200</a>: Feature-testing recommendations for C++ (since b591[2015-04-15]; i.e. <code>__has_cpp_attribute</code>, etc; see subsequent <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4440.html">N4440</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4440.html">N4440</a>: Feature-testing recommendations for C++ (superseded)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4535.html">N4535</a>: Feature-testing preprocessor predicates for C++17 (i.e. <code>__has_include</code> and <code>__has_cpp_attribute</code>, see below)
<ul>
<li>for <code>__has_include</code>, see <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0061r1.html">P0061R1</a> below</li>
<li><code>__has_cpp_attribute</code> adopted, as <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4200.htm">N4200</a> above
<ul>
<li>this is now in the <a href="https://eel.is/c++draft/cpp.cond#nt:has-attribute-expression">working draft</a>, though not in the list of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/">official page</a> as of b831[2018-07-13]</li>
<li>adopted by CWG motion 15 in editor's report <a href="https://github.com/cplusplus/draft/blob/master/papers/n4764.md">N4764</a></li>
<li>see <a href="https://www.open-std.org/pipermail/features/2014-March/000163.html">discussion here</a> for motivation</li>
</ul>
</li>
<li>see also <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0941r1.html">P0941R1</a></li>
</ul>
</li>
<li><a href="https://www.open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0096r1.html">P0096R1</a>: Feature-testing recommendations for C++ (since b679[2016-03-20]; see subsequent <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0941r0.html">P0941R0</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0941r2.html">P0941R2</a>: Integrating feature-test macros into the C++ WD (rev. 2) (since b831[2018-07-12])</li>
</ul>
<p>Following documents override feature testing paper which is incorporated into the standard draft as normative features:</p>
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0061r1.html">P0061R1</a>: <code>__has_include</code> for C++17 (adopted 2015-10; since b831[2018-07-12])</li>
</ul>
<p>Some additional feature testing support are also <strong>conditionally</strong> reviewd. Some are already extensions of Clang++ and other implementations for several revisions. The identifiers with <code>__has_</code> in following list are being used and considered for conditional inclusion:</p>
<ul>
<li><code>__has_attribute</code> since b628[2015-09-01], after in macro detection candidate list since b492[2014-04-10]</li>
<li><code>__has_builtin</code> since b535[2014-09-14]</li>
<li><code>__has_extension</code> and <code>__has_feature</code> since b484[2013-03-09]</li>
</ul>
<h2 id="tentatively-not-applied"><a class="header" href="#tentatively-not-applied">Tentatively not applied</a></h2>
<h3 id="used-deprecations"><a class="header" href="#used-deprecations">Used deprecations</a></h3>
<p>There are no features eventually removed in future versions of ISO C++ are yet to be resolved currently.</p>
<h3 id="workarounds"><a class="header" href="#workarounds">Workarounds</a></h3>
<p>Several acknowledged but not adopted (by the draft) issues (revised b834[2018-07-31]) are assumed not effect user code with workarounds provided by implementations, including:</p>
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2472">LWG 2472</a>: Heterogeneous comparisons in the standard library can result in ambiguities
<ul>
<li>no effect on YStandardEx replacement as there is no <code>std::rel_ops</code>-like operators in namespace <code>ystdex</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2858">LWG 2858</a>: LWG 2472: actually an incompatibility with C++03 (see <a href="https://wg21.cmeerw.net/lwg/issue280">LWG 280</a>)
<ul>
<li>no effect on <code>ystdex::reversed_iterator</code></li>
</ul>
</li>
</ul>
<h3 id="primarily-replaceable"><a class="header" href="#primarily-replaceable">Primarily replaceable</a></h3>
<p>The following features are not relied on, but confirmed still being compatible, with further rules to incooperate:</p>
<ul>
<li>part of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0551r3.pdf">P0551R3</a>: Thou Shalt Not Specialize <code>std</code> Function Templates! (adopted 2018-03)
<ul>
<li>though not relied on, any of the entities overloadable with standard components as the subset of the <em>direct replacements</em> specified in following clauses conform to the definition of the term <em>customization point</em> specified here</li>
<li><em>designated customization point</em> is extended to any direct replacments implicitly (i.e. a direct replacement is also implied to be customized by user code if it comforms to a designated customization point specified here), or explicitly following the designation otherwise specified by the interface documentation and with further rules to be intercooperated</li>
</ul>
</li>
</ul>
<p>The following changes about standard library are not depended on, but were considered some replacements have been used as forcing the requirements for implementations other than using of YStandardEx replacements:</p>
<ul>
<li>part of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4258.pdf">N4258</a>: Cleaning up noexcept in the Library (Rev 3) (adopted 2014-11)
<ul>
<li>only for part of <code>noexcept</code> which is <strong>not</strong> exclusively covered by the applying specified below, as <code>noexcept</code> can be added in user-code by introducing new classes meets the changes here like direct replacements (e.g. inheriting the base containers) when direct replacements is <strong>not</strong> yet provided by YStandardEx</li>
</ul>
</li>
</ul>
<h3 id="replaced-directly"><a class="header" href="#replaced-directly">Replaced directly</a></h3>
<p>These C++ features are directly provided by YDefinition as historical interests, as all supported configuartions have conform to the standard versions already including them:</p>
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2431.pdf">N2431</a>: A name for the null pointer: <code>nullptr</code> (revision 4) (since b206[2011-05-03])
<ul>
<li>replaced by <code>ystdex::nullptr_t</code> and <code>ystdex::nullptr</code></li>
<li>The type <code>ystdex::nullptr_t</code> is also provided <a href="https://learn.microsoft.com/zh-cn/cpp/extensions/nullptr-cpp-component-extensions">for C++/CLI</a> without depending on <code>std</code>.</li>
</ul>
</li>
</ul>
<p>These C++ features are <strong>not</strong> required, but the replacements are used instead.</p>
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue1118">LWG 1118</a>: <code>tuple</code> query APIs do not support cv-qualification
<ul>
<li>replaced by <code>ystdex::tuple_size</code> (since b958[2022-10-15])</li>
</ul>
</li>
</ul>
<p>These post-C++11 library features are <strong>not</strong> required <strong>currently</strong> (revised b969[2023-02-21]) but direct replacements (to be used <strong>conditionally</strong> once the draft standard is approved) are provided in YBase:</p>
<ul>
<li>parts of <a href="https://wg21.cmeerw.net/lwg/issue1234">LWG 1234</a>: "Do the right thing" and <code>NULL</code>
<ul>
<li>replaced by <code>ystdex::basic_string</code> (since b832[2018-07-25])</li>
<li>see also dedicated replacement <code>ystdex::list</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2108">LWG 2108</a>: No way to identify allocator types that always compare equal
<ul>
<li>with part of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4258.pdf">N4258</a>: Cleaning-up <code>noexcept</code> in the Library (Rev 3)</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2467">LWG 2467</a>: <code>is_always_equal</code> has slightly inconsistent default</li>
<li><code>std::allocator_tratits::is_always_equal</code> is provided as member of <code>ystdex::allocator_traits</code>; see also dedicated replacement <code>ystdex::map</code> for one of the drop-in replacements</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2112">LWG 2112</a>: User-defined classes that cannot be derived from
<ul>
<li>i.e. <code>is_final</code></li>
<li>replaced by <code>ystdex::is_final</code> <strong>with compatibility excptions</strong> (since b938[2022-02-09])
<ul>
<li>implemented in a best effort way: either <code>std::is_final</code> or <code>__is_final</code> builtin is used</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2141">LWG 2141</a>: <code>common_type</code> trait produces reference types
<ul>
<li>replaced by <code>ystdex::common_type</code> and <code>ystdex::common_type_t</code> (since b937[2022-02-06])</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2148">LWG 2148</a>: Hashing enums should be supported directly by <code>std::hash</code>
<ul>
<li>replaced by <code>ystdex::hash</code> (since b967[2023-02-07])</li>
<li>without <a href="https://wg21.cmeerw.net/lwg/issue2141">LWG 2543</a>: <a href="https://wg21.cmeerw.net/lwg/issue2148">LWG 2148</a> (hash support for enum types) seems under-specified
<ul>
<li><strong>NOTE</strong> This is conditonally available if the implementation of the primary template of <code>std::hash</code> is conforming.</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2188">LWG 2188</a>: Reverse iterator does not fully support targets that overload <code>operator&amp;</code>
<ul>
<li>replaced by <code>ystdex::reverse_iterator</code></li>
<li>adopted by LWG motion 3 in editor's report <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3938.html">N3938</a> with editorial fix</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2268">LWG 2268</a>: Setting a default argument in the declaration of a member function assign of <code>std::basic_string</code>
<ul>
<li>replaced by <code>ystdex::basic_string</code> (since b833[2018-07-31])</li>
</ul>
</li>
<li>parts of <a href="https://wg21.cmeerw.net/lwg/issue2193">LWG 2193</a>: Default constructors for standard library containers are explicit
<ul>
<li>replaced by <code>ystdex::basic_string</code> (since b832[2018-07-25])</li>
<li>see also dedicated replacements <code>ystdex::list</code>, <code>ystdex::map</code> and <code>ystdex::unordered_map</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2247">LWG 2247</a>: Type traits and <code>std::nullptr_t</code>
<ul>
<li>replaced by <code>ystdex::is_null_pointer</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2296">LWG 2296</a>: <code>std::addressof</code> should be <code>constexpr</code>
<ul>
<li>replaced by <code>ystdex::addressof</code> <strong>with compatibility excptions</strong>
<ul>
<li>implemented in a best effort way: <code>constepxr</code> works with most usual but not all cases like C++17 due to compatibility limitations where no <code>__builtin_addressof</code> is supported by the implementation</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2598">LWG 2598</a>: <code>addressof</code> works on temporaries</li>
</ul>
</li>
<li>adopted by part of LWG motion 16 in editor's report <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4583.html">N4583</a></li>
</ul>
</li>
<li>part of <code>common_type</code> changes in <a href="https://wg21.cmeerw.net/lwg/issue2408">LWG 2408</a>: SFINAE-friendly <code>common_type</code>/<code>iterator_traits</code> is missing in C++14
<ul>
<li>adopted from <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3843.pdf">N3843</a>: A SFINAE-Friendly <code>std::common_type</code></li>
<li>replaced by <code>ystdex::common_type</code> and <code>ystdex::common_type_t</code></li>
</ul>
</li>
<li>part of <a href="https://wg21.cmeerw.net/lwg/issue2455">LWG 2455</a>: Allocator default construction should be allowed to throw
<ul>
<li>replaced by <code>ystdex::basic_string</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2465">LWG 2465</a>: SFINAE-friendly <code>common_type</code> is nearly impossible to specialize correctly and regresses key functionality
<ul>
<li>first part of <a href="https://wg21.cmeerw.net/lwg/issue2460">LWG 2460</a>: <a href="https://wg21.cmeerw.net/lwg/issue2408">LWG issue 2408</a> and value categories</li>
<li>replaced by <code>ystdex::common_type</code> and <code>ystdex::common_type_t</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2579">LWG 2579</a>: Inconsistency wrt Allocators in <code>basic_string</code> assignment vs. <code>basic_string::assign</code>
<ul>
<li>replaced by <code>ystdex::basic_string</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2583">LWG 2583</a>: There is no way to supply an allocator for <code>basic_string(str, pos)</code>
<ul>
<li>replaced by <code>ystdex::basic_string</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2763">LWG 2763</a>: <code>common_type_t&lt;void, void&gt;</code> is undefined
<ul>
<li>replaced by <code>ystdex::common_type</code> and <code>ystdex::common_type_t</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2770">LWG 2770</a>: <code>tuple_size&lt;const T&gt;</code> specialization is not SFINAE compatible and breaks decomposition declarations
<ul>
<li>replaced by <code>ystdex::tuple_size</code> (since b958[2022-10-15])</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2778">LWG 2778</a>: <code>basic_string_view</code> is missing constexpr
<ul>
<li>replaced by <code>ystdex::basic_string_view</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2788">LWG 2788</a>: <code>basic_string</code> range mutators unintentionally require a default constructible allocator
<ul>
<li>replaced by <code>ystdex::basic_string</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2812">LWG 2812</a>: Range access is available with <code>&lt;string_view&gt;</code>
<ul>
<li>replaced by <code>"string_view.hpp"</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2817">LWG 2817</a>: <code>std::hash</code> for <code>nullptr_t</code>
<ul>
<li>replaced by <code>ystdex::hash</code> (since b967[2023-02-07])</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3911.pdf">N3911</a>: TransformationTrait Alias <code>void_t</code>
<ul>
<li>replaced by <code>void_t</code> in namespace <code>ystdex::cpp2017</code>, with workaround for <a href="https://wg21.cmeerw.net/cwg/issue1558">CWG 1558</a></li>
<li>see <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3843.pdf">N3843</a> for motivation</li>
</ul>
</li>
<li>parts of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4258.pdf">N4258</a> (adopted 2014-11)
<ul>
<li>replaced by <code>ystdex::allocator_traits::is_always_equal</code>; see <a href="https://wg21.cmeerw.net/lwg/issue2108">LWG 2108</a></li>
<li>replaced by <code>ystdex::basic_string</code>, except the part revised by <a href="https://wg21.cmeerw.net/lwg/issue2455">LWG 2455</a></li>
<li>see also dedicated replacement <code>ystdex::map</code></li>
<li>see also <a href="https://wg21.cmeerw.net/lwg/issue2455">LWG 2455</a> of change on <code>std::vector</code> (<strong>not replaced</strong>)</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4277.html">N4277</a>: TriviallyCopyable <code>reference_wrapper</code> (Revision 1)
<ul>
<li>with <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0357r2.html">P0357R2</a>: <code>reference_wrapper</code> for incomplete types</li>
<li>replaced by <code>ystdex::lref</code></li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4280.pdf">N4280</a>: Non-member <code>size()</code> and more (Revision 2) (adopted 2014-11)
<ul>
<li>replaced by <code>size</code>, <code>empty</code> and <code>data</code> in namespace <code>ystdex::cpp2017</code> conforming to designated customization point specified by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0551r3.pdf">P0551R3</a>, also <code>ystdex::range_size</code> with addtional interface for <code>std::initializer_list</code></li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4436.pdf">N4436</a>: Proposing Standard Library Support for the C++ Detection Idiom
<ul>
<li>partially replaced by <code>is_detected</code>, <code>detected_t</code>, <code>detected_or</code>, <code>detected_or_t</code>, <code>is_detected_exact</code> and <code>is_detected_convertile</code> in namespace <code>ystdex</code></li>
</ul>
</li>
<li><code>std::experimental::fundamentals_v2::observer_ptr</code> in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4562.html#memory.observer.ptr">N4562</a>
<ul>
<li>replaced feature based on <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4282.pdf">N4282</a>: A Proposal for the World's Dumbest Smart Pointer, v4</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0007r1.html">P0007R1</a>: Constant View: A proposal for a <code>std::as_const</code> helper function template (adopted 2015-11)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0013r1.html">P0013R1</a>: Logical Operator Type Traits (revision 1) (adopted 2015-10)
<ul>
<li>replaced by <code>conjunction</code>, <code>disjunction</code> and <code>negation</code> in namespace <code>ystdex</code>, based on <code>and_</code>, <code>or_</code> and <code>not_</code> (see dedicated replacements below)</li>
</ul>
</li>
<li>parts of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0031r0.html">P0031R0</a>: A Proposal to Add Constexpr Modifiers to <code>reverse_iterator</code>, <code>move_iterator</code>, <code>array</code> and Range Access
<ul>
<li>partially replaced by <code>reverse_iterator</code>, <code>begin</code>, <code>cbegin</code>, <code>end</code>, <code>cend</code>, <code>rbegin</code>, <code>crbegin</code>, <code>rend</code> and <code>crend</code> in namespace <code>ystdex</code></li>
<li>adopted by part of LWG motion 16 in edtitor report <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4583.html">N4583</a></li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r3.html">P0091R3</a>: Template argument deduction for class templates (Rev. 6) (adopted 2016-06)</li>
<li>interface in headers <code>&lt;optional&gt;</code>, <code>&lt;string_view&gt;</code> and <code>&lt;memory_resource&gt;</code> in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0220r1.html">P0220R1</a>: Adopt Library Fundamentals V1 TS Components for C++17 (R1)
<ul>
<li><code>&lt;optional&gt;</code> replaced by <code>&lt;ystdex/optional.hpp&gt;</code>
<ul>
<li><code>std::bad_optional_access</code> replaced by <code>ystdex::bad_optional_access</code></li>
<li><code>std::optional</code> replaced by <code>ystdex::cpp2017::optional</code></li>
</ul>
</li>
<li><code>&lt;string_view&gt;</code> replaced by <code>&lt;ystdex/string_view.hpp&gt;</code>
<ul>
<li><code>std::basic_string_view</code> replaced by <code>ystdex::cpp2017::basic_string_view</code></li>
<li><code>std::string_view</code> replaced by <code>ystdex::cpp2017::string_view</code></li>
<li><code>std::wstring_view</code> replaced by <code>ystdex::cpp2017::wstring_view</code></li>
<li><code>std::u16string_view</code> replaced by <code>ystdex::cpp2017::u16string_view</code></li>
<li><code>std::u32string_view</code> replaced by <code>ystdex::cpp2017::u32string_view</code></li>
</ul>
</li>
<li><code>&lt;memory_resource&gt;</code> replaced by <code>&lt;ystdex/memory_resource.h&gt;</code>
<ul>
<li><code>std::pmr::memory_resource</code> replaced by <code>ystdex::pmr::cpp2017::memory_resource</code></li>
<li><code>std::pmr::polymorphic_allocator</code> replaced by <code>ystdex::pmr::cpp2017::polymorphic_allocator</code></li>
<li><code>std::pmr::new_delete_resource</code> replaced by <code>ystdex::pmr::cpp2017::new_delete_resource</code></li>
<li><code>std::pmr::null_memory_resource</code> replaced by <code>ystdex::pmr::cpp2017::null_memory_resource</code></li>
<li><code>std::pmr::set_default_resource</code> replaced by <code>ystdex::pmr::cpp2017::set_default_resource</code></li>
<li><code>std::pmr::get_defualt_resource</code> replaced by <code>ystdex::pmr::cpp2017::get_defualt_resource</code></li>
<li><code>std::pmr::pool_options</code> replaced by <code>ystdex::pmr::pool_options</code></li>
<li><code>std::pmr::cpp2017::synchronized_pool_resource</code> replaced by <code>ystdex::pmr::cpp2017::synchronized_pool_resource</code></li>
<li><code>std::pmr::unsynchronized_pool_resource</code> replaced by <code>ystdex::pmr::cpp2017::unsynchronized_pool_resource</code></li>
<li><code>std::pmr::monotonic_buffer_resource</code> replaced by <code>ystdex::pmr::cpp2017::monotonic_buffer_resource</code></li>
</ul>
</li>
<li><code>std::apply</code> in <code>&lt;tuple&gt;</code> replaced by <code>ystdex::apply</code>
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3915.pdf">N3915</a>: <code>apply()</code> call a function with arguments from a tuple (V3) (adopted 2014-02)</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2418">LWG 2418</a>: [fund.ts] <code>apply</code> does not work with member pointers</li>
</ul>
</li>
<li>partially adopted by LWG motion 6 in editor's report <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4583.html">N4583</a>
<ul>
<li><code>&lt;optional&gt;</code>, <code>&lt;string_view&gt;</code>, <code>&lt;memory_resource&gt;</code> and <code>&lt;tuple&gt;</code> in parts of LWG motion 6: <a href="https://wg21.link/p0220r1">P0220R1</a> "Adopt library fundamentals v1 TS components for C++17") (incompletely applied from <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4562.html">N4562</a>)</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2283">LWG 2283</a>: [fund.ts] <code>optional</code> declares and then does not define an <code>operator&lt;()</code> (this is actually targetting <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3691.pdf">the standard draft</a>, not <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4023.html#optional.comp_with_t">the library fundmental draft</a>)</li>
<li>with <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4078.html">N4078</a>: Fixes for <code>optional</code> objects (adopted 2014-06)</li>
</ul>
</li>
<li>with <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0254r2.pdf">P0254R2</a>: Integrating <code>std::string_view</code> and <code>std::string</code> (adopted 2016-06, by LWG motion 14 in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4603.html">N4603</a>)
<ul>
<li>replaced by <code>ystdex::basic_string</code> and <code>ystdex::basic_string_view</code></li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2742">LWG 2742</a>: Inconsistent string interface taking <code>string_view</code></li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2758">LWG 2758</a>: <code>std::string{}.assign("ABCDE", 0, 1)</code> is ambiguous
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2757">LWG 2757</a>: <code>std::string{}.insert(3, "ABCDE", 0, 1)</code> is ambiguous</li>
</ul>
</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2771">LWG 2771</a>: Broken Effects of some <code>basic_string::compare</code> functions in terms of <code>basic_string_view</code> (see <a href="https://wg21.cmeerw.net/lwg/issue2758">LWG 2758</a>)</li>
</ul>
</li>
<li>with <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0337r0.html">P0337R0</a>: Delete <code>operator=</code> for <code>polymorphic_allocator</code> (adopted by LWG motion 26 in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4603.html">N4603</a>)</li>
<li>with <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0339r6.pdf">P0339R6</a>: <code>polymorphic_allocator&lt;&gt;</code> as a vocabulary type (adopted 2019-03)
<ul>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue3237">LWG 3237</a> (see below)</li>
</ul>
</li>
<li>with changes on <code>pmr::memory_resource</code> in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0619r4.html">P0619R4</a></li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2724">LWG 2724</a>: The <code>protected virtual</code> member functions of <code>memory_resource</code> should be <code>private</code></li>
<li>conditionally with <a href="https://wg21.cmeerw.net/lwg/issue2740">LWG 2740</a>: <code>constexpr optional&lt;T&gt;::operator-&gt;</code>
<ul>
<li>only with <code>constexpr addressof</code> (i.e. since C++17 or with some extensions)</li>
</ul>
</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2756">LWG 2756</a>: C++ WP <code>optional&lt;T&gt;</code> should '<code>forward</code>' <code>T</code>'s implicit conversions</li>
<li><strong>without</strong> <a href="https://wg21.cmeerw.net/lwg/issue2825">LWG 2825</a>: <a href="https://wg21.cmeerw.net/lwg/issue2756">LWG 2756</a> breaks class template argument deduction for optional, as the resolution need <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0091r4.html">deduction guides</a> unsupported here yet</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2842">LWG 2806</a>: Base class of <code>bad_optional_access</code></li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2842">LWG 2842</a>: <code>in_place_t</code> check for <code>optional::optional(U&amp;&amp;)</code> should decay <code>U</code></li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2843">LWG 2843</a>: Unclear behavior of <code>std::pmr::memory_resource::do_allocate()</code></li>
<li>with part (for <code>optional</code>) of <a href="https://wg21.cmeerw.net/lwg/issue2857">LWG 2857</a>: <code>{variant,optional,any}::emplace</code> should return the constructed value
<ul>
<li>partially replaced by <code>ystdex::any</code></li>
</ul>
</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2900">LWG 2900</a>: The copy and move constructors of <code>optional</code> are not <code>constexpr</code></li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2961">LWG 2961</a>: Bad postcondition for <code>set_default_resource</code> (similart to <a href="https://wg21.cmeerw.net/lwg/issue2522">LWG 2522</a> targetting Library Fundamentals V2)</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2969">LWG 2969</a>: <code>polymorphic_allocator::construct()</code> shouldn't pass <code>resource()</code></li>
<li>with parts (concerned with <code>polymorphic_allocator</code>) of <a href="https://wg21.cmeerw.net/lwg/issue2975">LWG 2975</a>: Missing case for pair construction in scoped and polymorphic allocators</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue3000">LWG 3000</a>: <code>monotonic_memory_resource::do_is_equal</code> uses <code>dynamic_cast</code> unnecessarily</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue3036">LWG 3036</a>: <code>polymorphic_allocator::destroy</code> is extraneous</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue3037">LWG 3037</a>: <code>polymorphic_allocator</code> and incomplete types</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue3038">LWG 3038</a>: <code>polymorphic_allocator::allocate</code> should not allow integer overflow to create vulnerabilities
<ul>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue3237">LWG 3237</a>: <a href="https://wg21.cmeerw.net/lwg/issue3038">LWG 3038</a> and <a href="https://wg21.cmeerw.net/lwg/issue3190">3190</a> have inconsistent PRs</li>
</ul>
</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue3113">LWG 3113</a>: <code>polymorphic_allocator::construct()</code> should more closely match <code>scoped_allocator_adaptor::construct()</code></li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0185r1.html">P0185R1</a> Adding [<code>nothrow</code>-]<code>swappable</code> traits, revision 3 (adopted 2016-02)
<ul>
<li>replaced by <code>is_swappable_with</code>, <code>is_swappable</code>, <code>is_nothrow_swappable_with</code> and <code>is_nothrow_swappable</code> in namespace <code>ystdex</code>, and <code>swap</code> in namespace <code>ystdex_swap</code> (see also <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0879r0.html">P0879R0</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2456">LWG 2456</a>: Incorrect exception specifications for '<code>swap</code>' throughout library</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2554">LWG 2554</a>: Swapping multidimensional arrays is never <code>noexcept</code></li>
<li>see also <a href="https://wg21.cmeerw.net/lwg/issue2766">LWG 2766</a></li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0209r2.pdf">P0209R2</a> <code>make_from_tuple</code>: <code>apply</code> for construction (adopted 2016-06, by LWG motion 23 in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4603.html">N4603</a>)
<ul>
<li>replaced by <code>ystdex::make_from_tuple</code></li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0298r3.pdf">P0298R3</a>: A byte type definition
<ul>
<li>replaced by <code>ystdex::byte</code>, except when the core language support unavailable before C++17, where the name is provided as an alias of <code>unsigned char</code></li>
<li>see also <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0583r0.pdf">P0583R0</a>.</li>
</ul>
</li>
<li><code>&lt;flat_map&gt;</code> from <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0429r9.pdf">P0429R9</a>
<ul>
<li>with part (except deduction guides) of <a href="https://wg21.cmeerw.net/lwg/issue3803">LWG 3803</a>: <code>flat_foo</code> constructors taking <code>KeyContainer</code> lack <code>KeyCompare</code> parameter</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue3816">LWG 3816</a>: <code>flat_map</code> and <code>flat_multimap</code> should impose sequence container requirements</li>
<li>without but waiting <a href="https://wg21.cmeerw.net/lwg/issue3802">LWG 3802</a>: <code>flat_foo</code> allocator-extended constructors lack move semantics</li>
<li>without part of deduction guides of LWG 3803</li>
<li>without <a href="https://wg21.cmeerw.net/lwg/issue3786">LWG 3786</a>: Flat maps' deduction guide needs to default <code>Allocator</code> to be useful</li>
<li>without <a href="https://wg21.cmeerw.net/lwg/issue3804">LWG 3804</a>: <code>flat_foo</code> missing some allocator-extended deduction guides</li>
<li>replaced by <code>&lt;ystdex/flat_map.hpp&gt;</code>
<ul>
<li>with exception of exception specification of <code>swap</code> by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0429r8.pdf">P0429R8</a> which seems like a defect</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0435r1.pdf">P0435R1</a>: Resolving LWG Issues re <code>common_type</code>
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2465">LWG 2465</a>: SFINAE-friendly <code>common_type</code> is nearly impossible to specialize correctly and regresses key functionality</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2763">LWG 2763</a>: <code>common_type_t&lt;void, void&gt;</code> is undefined</li>
<li>replaced by <code>ystdex::common_type</code> and <code>ystdex::common_type_t</code></li>
</ul>
</li>
<li>part of <code>common_type</code> in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0548r1.pdf">P0548R1</a>: <code>common_type</code> and <code>duration</code>
<ul>
<li>replaced by <code>ystdex::common_type</code> and <code>ystdex::common_type_t</code></li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0550r2.pdf">P0550R2</a>: Transformation Trait <code>remove_cvref</code>
<ul>
<li>replaced by <code>ystdex::remove_cvref</code></li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0604r0.html">P0604R0</a>: Resolving GB 55, US 84, US 85, US 86 (adopted 2017-03)
<ul>
<li>partially replaced by <code>invoke_result</code>, <code>invoke_result_t</code>, <code>is_invocable</code>, <code>is_invocable_r</code>, <code>is_nothrow_invocable</code> and <code>is_nothrow_invocable_r</code> in namespace <code>ystdex::cpp2017</code></li>
<li>revised previously-adopted <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0077r2.html">P0077R2</a>: <code>is_callable</code>, the missing <em><code>INVOKE</code></em> related trait (adopted 2016-02)</li>
<li>national body comments GB 55, US 84, US 85, US 86 accepted with modifications in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4664.pdf">N4664</a></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2017">LWG 2017</a>: <code>std::reference_wrapper</code> makes incorrect usage of <code>std::result_of</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2021">LWG 2021</a>: Further incorrect usages of <code>result_of</code></li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2219">LWG 2219</a>: <em><code>INVOKE</code></em>-ing a pointer to member with a reference_wrapper as the object expression</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2767">LWG 2767</a>: <code>not_fn</code> call_wrapper can form invalid types</li>
</ul>
</li>
<li>all new function templates in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0591r4.pdf">P0591R4</a>: Utility functions to implement uses-allocator construction (adopted 2018-11)
<ul>
<li><code>std::uses_allocator_construction_args</code> replaced by <code>ystdex::uses_allocator_construction_args</code></li>
<li><code>std::make_obj_using_allocator</code> replaced by <code>ystdex::make_obj_using_allocator</code></li>
<li><code>std::uninitialized_construct_using_allocator</code> replaced by <code>ystdex::uninitialized_construct_using_allocator</code></li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0607r0.html">P0607R0</a>: Inline Variables for the Standard Library
<ul>
<li>depends on <a href="https://wg21.cmeerw.net/cwg/issue1713">CWG 1713</a>, the "minimalistic suggestion" and "additional suggestion" in paper are fully (both) taken in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf">N4659</a>, which is not explicitly indicated by the editor's report <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4661.html">N4661</a></li>
<li>partially replaced by <code>ystdex::nullopt</code></li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0619r4.html">P0619R4</a>: Reviewing Deprecated Facilities of C++17 for C++20
<ul>
<li><code>std::reference_wrapper</code> partially replaced by <code>ystdex::lref</code></li>
<li><code>std::iterator</code> is not used (see also <a href="https://wg21.cmeerw.net/lwg/issue2438">LWG 2438</a>)</li>
<li>changes on <code>std::pmr::memory_resource</code> is implemented for <code>ystdex::pmr::memory_resource</code></li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0653r2.html">P0653R2</a>: Utility to convert a pointer to a raw pointer (adopted 2017-11)
<ul>
<li><code>std::to_address</code> is replaced by <code>ystdex::to_address</code></li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0879r0.html">P0879R0</a>: Constexpr for <code>swap</code> and <code>swap</code> related functions
<ul>
<li>partially replaced by <code>swap</code> in namespace <code>ystdex_swap</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2800">LWG 2800</a>: <code>constexpr</code> <code>swap</code></li>
<li>this is now in the <a href="https://raw.githubusercontent.com/cplusplus/draft/master/papers/n4762.pdf">working draft</a>, though not in the list of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/">official page</a> as of b834[2018-08-03]</li>
<li>adopted by LWG motion 21 in editor's report <a href="https://github.com/cplusplus/draft/blob/master/papers/n4764.md">N4764</a></li>
</ul>
</li>
<li>part of <code>common_type</code> in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0898r3.pdf">P0898R3</a>: Standard Library Concepts
<ul>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue3205">LWG 3205</a>: <code>decay_t</code> in the new <code>common_type</code> fallback should be <code>remove_cvref_t</code></li>
<li>replaced by <code>ystdex::common_type</code> and <code>ystdex::common_type_t</code></li>
</ul>
</li>
<li><code>&lt;flat_set&gt;</code> from <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1222r4.pdf">P1222R4</a>
<ul>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue3751">LWG 3751</a>: Missing feature macro for <code>flat_set</code></li>
<li>with part (except deduction guides) of <a href="https://wg21.cmeerw.net/lwg/issue3803">LWG 3803</a>: <code>flat_foo</code> constructors taking <code>KeyContainer</code> lack <code>KeyCompare</code> parameter</li>
<li>without but waiting <a href="https://wg21.cmeerw.net/lwg/issue3802">LWG 3802</a>: <code>flat_foo</code> allocator-extended constructors lack move semantics</li>
<li>without part of deduction guides of LWG 3803</li>
<li>without <a href="https://wg21.cmeerw.net/lwg/issue3774">LWG 3774</a>: <code>&lt;flat_set&gt;</code> should include <code>&lt;compare&gt;</code></li>
<li>without <a href="https://wg21.cmeerw.net/lwg/issue3804">LWG 3804</a>: <code>flat_foo</code> missing some allocator-extended deduction guides</li>
<li>without <a href="https://wg21.cmeerw.net/lwg/issue3879">LWG 3879</a>: <code>erase_if</code> for <code>flat_{,multi}set</code> is incorrectly specified</li>
<li>replaced by <code>&lt;ystdex/flat_set.hpp&gt;</code>
<ul>
<li>with exception of exception specification of <code>swap</code> by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1222r3.pdf">P1222R3</a> which seems like a defect</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Some replaced features do not have exact the same features (but a subset) of the corresponding <code>std</code> features, due to limitation of implementations or by design. Except listed above, the limitations are:</p>
<ul>
<li>The following templates do not support program-defined specializations by design:
<ul>
<li><code>ystdex::common_type</code></li>
<li><code>ystdex::hash</code></li>
<li>Use explicit specializations of <code>std</code> templates instead.</li>
</ul>
</li>
<li><code>ystdex::hash</code>
<ul>
<li><strong>not</strong> with <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0513r0.pdf">P0513R0</a>: Poisoning the Hash
<ul>
<li><strong>NOTE</strong> This is conditonally available if the implementation of the primary template and the corresponding explicit specializations of <code>std::hash</code> is conforming. The following parts are only supported when the implementation of <code>std::hash</code> is conforming.</li>
<li>The national body comment FI 15 in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0488r0.pdf">P0488R0</a> is supported (with both <code>std::hash</code> and <code>ystdex::hash</code>) for <code>ystdex::optional</code> is conditionally supported.</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2791">LWG 2791</a> is supported with <code>ystdex::hash</code> (but not <code>std::hash</code>) on the basis between corresponding <code>ystdex::basic_string</code> and <code>ystdx::basic_string_view</code> instances, but not for <code>std</code> ones (even when <code>std::basic_string</code> is used as <code>std::basic_string</code>).</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Some previously applied pre-C++11 resolutions also work on replacements, listed here for exposition-only use:</p>
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue280">LWG 280</a>: Comparison of <code>reverse_iterator</code> to <code>const reverse_iterator</code>
<ul>
<li>partially replaced by <code>ystdex::reverse_iterator</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue386">LWG 386</a>: Reverse iterator's <code>operator[]</code> has impossible return type
<ul>
<li>replaced by <code>ystdex::reverse_iterator::operator[]</code></li>
</ul>
</li>
</ul>
<h3 id="replaced-alternatively"><a class="header" href="#replaced-alternatively">Replaced alternatively</a></h3>
<p>These features were once adopted by the working paper but later removed away, and further actions different to the committee are considered by this project for practical reasons (e.g. compatibility and availability in lack of other features):</p>
<ul>
<li>parts of <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0032r3.pdf">P0032R3</a>: Homogeneous interface for <code>variant</code>, <code>any</code> and <code>optional</code> (Revision 3) (adopted 2016-06)
<ul>
<li>see national body comment CH 3 relavent to parts of <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0032r3.pdf">P0032R3</a> in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0488r0.pdf">P0488R0</a>: WG21 Working Paper, NB Comments, ISO/IEC CD 14882</li>
<li>see <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0504r0.html">P0504R0</a>: Revisiting in-place tag types for <code>any</code>/<code>optional</code>/<code>variant</code></li>
<li>removed by <a href="https://github.com/cplusplus/draft/commit/d2d23690a253b91fb7ccb1631581bd9c8f2937d2">this commit</a></li>
<li>this is not always taken in the direct replacements in <code>namespace ystdex::cpp2017</code> to avoid impaction from lack of varaible template support</li>
</ul>
</li>
</ul>
<h3 id="replaced-dedicately"><a class="header" href="#replaced-dedicately">Replaced dedicately</a></h3>
<p>There are several core language issues are resolved by YDefinition core language compatiblitiy features <strong>conditioanlly</strong>, even though they may be still not adopted or even without a concrete proposed resolution currently (revised b835[2018-08-14]):</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue2097">CWG 2097</a>: Lambdas and <code>noreturn</code> attribute</li>
</ul>
<p>There are several YBase features which can <strong>currently</strong> (revised b967[2023-02-07]) be used as replacement for similar post-C++11 library features. See also <a href="Features.zh-CN.html">Features(zh-CN)</a>.</p>
<ul>
<li><code>ystdex::and_</code>, <code>ystdex::or_</code> and <code>ystdex::not_</code> are provided to replace logical operation traits introduced in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0013r1.html">P0013R1</a>
<ul>
<li>currently aliases of them are also direct replacements in namespace <code>cpp2017</code></li>
</ul>
</li>
<li><code>ystdex::lref</code> is provided as a replacement for <code>std::reference_wrapper</code> with less verbosity
<ul>
<li>supports <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4277.html">N4277</a>: TriviallyCopyable <code>reference_wrapper</code> (Revision 1)</li>
<li>otherwise mostly same to <code>boost::reference_wrapper</code> besides its name and <code>constexpr</code> requirements (needing core language support)
<ul>
<li>no deprecated members of <code>std::reference_wrapper</code>, see <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0619r4.html">P0619R4</a>: Reviewing Deprecated Facilities of C++17 for C++20</li>
<li>supports incomplete value type, see <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0357r2.html">P0357R2</a></li>
<li>not same type to any instance of <code>std::reference_wrapper</code> so not treated specially by <code>std::bind</code> and other <code>std</code> API</li>
</ul>
</li>
<li>with part of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0604r0.html">P0604R0</a></li>
<li>with part of <a href="https://wg21.cmeerw.net/lwg/issue2993">LWG 2993</a></li>
</ul>
</li>
<li><code>ystdex::unwrap_reference</code>, <code>ystdex::unwrap_reference_t</code>, <code>ystdex::unwrap_ref_decay</code> and <code>ystdex::unwrap_ref_decay_t</code> are provided with extensions for <code>ystdex::lref</code>, as replacement for the following C++20 features
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0318r1.pdf">P0318R1</a>: <code>unwrap_ref_decay</code> and <code>unwrap_reference</code> (adopted 2018-11)
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue3202">LWG 3202</a>: P0318R1 was supposed to be revised</li>
</ul>
</li>
</ul>
</li>
<li><code>ystdex::get_temporary_buffer</code> is provided to replace <code>std::get_temporary _buffer</code> deprecated by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0174r2.html#4.4">P0174R2</a> and removed by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0619r4.html#3.11">P0619R4</a></li>
<li><code>ystdex::any</code> is provided as a replacement for <code>std::any</code> with richer features and greater availability
<ul>
<li>already with following C++17 <code>std::any</code> features
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2744">LWG 2744</a></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2769">LWG 2769</a>
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2768">LWG 2768</a></li>
</ul>
</li>
<li>parts of <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0032r3.pdf">P0032R3</a>
<ul>
<li>with part of <a href="https://wg21.cmeerw.net/lwg/issue2857">LWG 2857</a></li>
</ul>
</li>
<li>NOTE: <a href="https://wg21.cmeerw.net/lwg/issue2509">LWG 2509</a> is superseded by the resolution and mostly not applicable because of the support of non <code>CopyConstructible</code> types (see below)</li>
<li>NOTE: <a href="https://wg21.cmeerw.net/lwg/issue2754">LWG 2754</a> is not applicable because the exact same reason above</li>
</ul>
</li>
<li>supports non <code>CopyConstructible</code> types (if a <code>ystdex::any</code> object holding an object of such type is eventually copied, exception would be thrown</li>
<li>with underlying interface for custom holders and handlers (for <code>ystdex::any_iterator</code>, etc)</li>
<li>supports constructor overload with minimal construction overhead for the empty object with <code>ystdex::default_init_t</code> parameter (at the cost of not supporting <code>constepxr</code> as the default constructor)</li>
<li>supports unsafe cast operations and more extensions to bypass checks with narrow contracts</li>
<li>early available before several standard proposals, including the <code>any</code> class itself and members like <code>emplace</code> (see <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0032r0.pdf">P0032R0</a>)
<ul>
<li>actually being first to replace <code>boost::any</code> before <code>std::any</code> was proposed as a post-C++11 feature by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3390.html">N3390</a>: <em>Any</em> Library Proposal (Revision 1)</li>
<li>see also the original proposal <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1939.html">N1939</a>: <em>Any</em> Library Proposal for TR2</li>
</ul>
</li>
</ul>
</li>
<li><code>ystdex::function</code> is provided as a replacement for <code>std::function</code> with richer features
<ul>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2062">LWG 2062</a></li>
<li>with allocator support in construction like the feature removed by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0302r1.html">P0302R1</a></li>
<li>(since C++20) with <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0771r1.pdf">P0771R1</a>: <code>std::function</code> move constructor should be <code>noexcept</code>(adopted 2016-11)</li>
</ul>
</li>
<li><code>ystdex::list</code> is proveded as a replacement for <code>std::list</code> with enhanced features
<ul>
<li>(since C++11) with the part of <a href="https://wg21.cmeerw.net/lwg/issue1234">LWG 1234</a>: "Do the right thing" and <code>NULL</code></li>
<li>(since C++17) with the part of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4510.html">N4510</a>: Minimal incomplete type support for standard containers, revision 4</li>
<li>(since C++20) with the part of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0084r2.pdf">P0084R2</a>: Emplace Return Type (Revision 2) (adopted 2016-06)</li>
<li>with the part of <a href="https://wg21.cmeerw.net/lwg/issue2839">LWG 2839</a>: Self-move-assignment of library types, again</li>
</ul>
</li>
<li><code>ystdex::map</code> and <code>ystdex::unordered_map</code> are provided as replacements of <code>std::map</code> and <code>std::unordered_map</code> (other associative containers TBD) including follwing enhancement (full ISO C++17 features support):
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3657.htm">N3657</a></li>
<li>part of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4258.pdf">N4258</a> (adopted 2014-11)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4279.html">N4279</a> (adopted 2014-11)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0083r3.pdf">P0083R3</a> (adopted 2016-06)</li>
<li>parts of <a href="https://wg21.cmeerw.net/lwg/issue2005">LWG 2005</a>
<ul>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2571">LWG 2571</a></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2059">LWG 2059</a></li>
<li>part of <a href="https://wg21.cmeerw.net/lwg/issue2354">LWG 2354</a></li>
<li>incomplete key and mapped types support which is not supported by C++17 (like <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4510.html">N4510</a>) yet (so it is not in <code>namespace ystdex::cpp2017</code>; although lisbstdc++ can support it)</li>
<li>part of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0458r2.html">P0458R2</a> (adopted 2018-06)</li>
</ul>
</li>
</ul>
<p>Some YCLib replacements depend on the implementation details of the standard libaray:</p>
<ul>
<li>There are severl replacements provided by module YCLib::FileIO:
<ul>
<li><code>platform::basic_filebuf</code></li>
<li><code>platform::basic_ifstream</code></li>
<li><code>platform::basic_ofstream</code></li>
<li><code>platform::basic_fstream</code></li>
<li>alias of these templates</li>
<li>These types having extensions on supported parameter types of <code>open</code>, as well as standard features:
<ul>
<li>with <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1981.html">N1981</a>: Uniform Use of <code>std::string</code> Revision 1</li>
<li>with parameter type support similar (a bit like the resolution of <a href="https://wg21.cmeerw.net/lwg/issue3430">LWG 3430</a>) but different to <a href="https://wg21.cmeerw.net/lwg/issue105">LWG 105</a> and <a href="https://wg21.cmeerw.net/lwg/issue454">LWG 454</a></li>
<li>without <a href="https://wg21.cmeerw.net/lwg/issue2676">LWG 2676</a>: Provide <code>filesystem::path</code> overloads for File-based streams</li>
<li>without <a href="https://wg21.cmeerw.net/lwg/issue3430">LWG 3430</a>: <code>std::fstream</code> &amp; co. should be constructible from <code>string_view</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="neutral-of-existence"><a class="header" href="#neutral-of-existence">Neutral of existence</a></h3>
<p>These post-C++03 (adopted, any proposed or any not proposed but theorotically allowed having well-defined behavior) resolutions or features (with diagnostic suggestions) are <strong>not</strong> depended on <strong>currently</strong> (revised b972[2023-04-13]) but confirmed still being compatible:</p>
<p><strong>NOTE</strong> However, user code can still be affected; some resolutions may have been applied to similar other interface of YBase, see sections above.</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue446">CWG 446</a>: Does an lvalue-to-rvalue conversion on the "<code>?</code>" operator produce a temporary?
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue86">CWG 86</a>: Lifetime of temporaries in query expressions</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue462">CWG 462</a>: Lifetime of temporaries bound to comma expressions</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue468">CWG 468</a>: Allow <code>::template</code> outside of templates</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue475">CWG 475</a>: When is <code>std::uncaught_exception()</code> <code>true</code>? (take 2)</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue515">CWG 515</a>: Non-dependent references to base class members (see also <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=21008">GCC PR 21008</a>)</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue569">CWG 569</a>: Spurious semicolons at namespace scope should be allowed</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue573">CWG 573</a>: Conversions between function pointers and <code>void*</code> (see also <a href="https://wg21.cmeerw.net/cwg/issue195">CWG 195</a>/<a href="https://wg21.cmeerw.net/cwg/issue1120">CWG 1120</a>)</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue760">CWG 760</a>: <code>this</code> inside a nested class of a non-static member function</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue790">CWG 790</a>: Concatenation of raw and non-raw string literals</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue903">CWG 903</a>: Value-dependent integral null pointer constants
<ul>
<li>NOTE: This is actually adopted after C++11 despite the compatibility clause is agianst to C++03.</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1120">CWG 1120</a>: <code>reinterpret_cast</code> and <code>void*</code> (depends on <a href="https://wg21.cmeerw.net/cwg/issue573">CWG 573</a>)</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1164">CWG 1164</a>: Partial ordering of <code>f(T&amp;)</code> and <code>f(T&amp;&amp;)</code></li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1213">CWG 1213</a>: Array subscripting and xvalues (see also <a href="https://wg21.cmeerw.net/cwg/issue616">CWG 616</a>)</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1227">CWG 1227</a>: Mixing immediate and non-immediate contexts in deduction failure</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1255">CWG 1255</a>: Definition problems with <code>constexpr</code> functions</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1301">CWG 1301</a>: Value initialization of union
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue1324">CWG 1324</a>: Value initialization and defaulted constructors</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1368">CWG 1368</a>: Value initialization and defaulted constructors (part 2)</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1310">CWG 1310</a>: What is an “acceptable lookup result?”</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1399">CWG 1399</a>: Missing non-deduced context following a function parameter pack
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue1388">CWG 1388</a>: Deduction with multiple function parameter packs</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1402">CWG 1402</a>: Move functions too often deleted
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue1491">CWG 1491</a>: Move construction and rvalue reference members</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1412">CWG 1412</a>: Problems in specifying pointer conversions</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1579">CWG 1579</a>: Return by converting move constructor</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1591">CWG 1591</a>: Deducing array bound and element type from initializer list</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1626">CWG 1626</a>: <code>constexpr</code> member functions in <code>brace-or-equal-initializer</code>s</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1665">CWG 1665</a>: Declaration matching in explicit instantiations</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1693">CWG 1693</a>: Superfluous semicolons in class definitions (depends on <a href="https://wg21.cmeerw.net/cwg/issue569">CWG 569</a>)</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1778">CWG 1778</a>: exception-specification in explicitly-defaulted functions
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2165">LWG 2165</a>: <code>std::atomic&lt;X&gt;</code> requires <code>X</code> to be nothrow default constructible</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1875">CWG 1875</a>: Reordering declarations in class scope</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1854">CWG 1854</a>: Disallowing use of implicitly-deleted functions
<ul>
<li>see <a href="https://wg21.cmeerw.net/cwg/issue1778">CWG 1778</a></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1895">CWG 1895</a>: Deleted conversions in conditional operator operands
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue1932">CWG 1932</a>: Bit-field results of conditional operators</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1952">CWG 1952</a>: Constant expressions and library undefined behavior</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1980">CWG 1980</a>: Equivalent but not functionally-equivalent redeclarations</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue2137">CWG 2137</a>: List-initialization from object of same type</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue2248">CWG 2248</a>: Problems with sized <code>delete</code></li>
<li><a href="https://wg21.cmeerw.net/cwg/issue2267">CWG 2267</a>: Copy-initialization of temporary in reference direct-initialization</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue2022">CWG 2278</a>: Copy elision in constant expressions reconsidered</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue2313">CWG 2313</a>: Redeclaration of structured binding reference variables</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue2430">CWG 2430</a>: Completeness of return and parameter types of member functions</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue2446">CWG 2446</a>: Questionable type-dependency of <code>concept-id</code>s</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue2523">CWG 2523</a>: Undefined behavior via omitted destructor call in constant expressions</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue208">LWG 208</a>: Unnecessary restriction on past-the-end iterators</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue251">LWG 251</a>: <code>basic_stringbuf</code> missing <code>allocator_type</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue281">LWG 281</a>: <code>std::min()</code> and <code>max()</code> requirements overly restrictive</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue283">LWG 283</a>: <code>std::replace()</code> requirement incorrect/insufficient</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue365">LWG 365</a>: Lack of <code>const</code>-qualification in clause 27
<ul>
<li>replaced by <a href="StandardUsing.en-US.html#replaced-dedicately"><code>platform::basic_ifstream::is_open</code> and <code>platform::basic_ofstream::is_open</code>, as well as their aliases</a></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue387">LWG 387</a>: <code>std::complex</code> over-encapsulated</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue402">LWG 402</a>: wrong new expression in <code>[some_]allocator::construct</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue409">LWG 409</a>: Closing an <code>fstream</code> should clear error state
<ul>
<li>replaced by <a href="StandardUsing.en-US.html#replaced-dedicately"><code>platform::basic_fstream::is_open</code> and <code>platform::basic_ofstream::is_open</code>, as well as their aliases</a></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue455">LWG 455</a>: <code>cerr::tie()</code> and <code>wcerr::tie()</code> are overspecified</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue497">LWG 497</a>: meaning of <code>numeric_limits::traps</code> for floating point types</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue531">LWG 531</a>: array forms of unformatted input functions (i.e. for <code>istream::get</code>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue543">LWG 543</a>: <code>valarray</code> slice default constructor</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue551">LWG 551</a>: <code>&lt;ccomplex&gt;</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue562">LWG 562</a>: <code>stringbuf</code> ctor inefficient</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue565">LWG 565</a>: <code>xsputn</code> inefficient</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue566">LWG 566</a>: array forms of unformatted input function undefined for zero-element arrays (i.e. for <code>istream::get</code>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue576">LWG 576</a>: <code>find_first_of</code> is overconstrained</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue578">LWG 578</a>: purpose of hint to <code>allocator::allocate()</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue586">LWG 586</a>: string inserter not a formatted function</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue593">LWG 593</a>: <code>__STDC_CONSTANT_MACROS</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue619">LWG 619</a>: Longjmp wording problem</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue643">LWG 643</a>: Impossible "as if" clauses</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue646">LWG 646</a>: <code>const</code> incorrect <code>match_result</code> members</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue659">LWG 659</a>: <code>istreambuf_iterator</code> should have an <code>operator-&gt;()</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue679">LWG 679</a>: <code>resize</code> parameter by value
<ul>
<li>replaced by <code>ystdex::list::resize</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue776">LWG 776</a>: Undescribed assign function of <code>std::array</code> (i.e. <code>array::fill</code>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue779">LWG 779</a>: Resolution of <a href="https://wg21.cmeerw.net/lwg/issue283">#283</a> incomplete</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue787">LWG 787</a>: complexity of <code>binary_search</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue807">LWG 807</a>: <code>tuple</code> construction should not fail unless its element's construction fails</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue844">LWG 844</a>: <code>complex</code> <code>pow</code> return type is ambiguous</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue848">LWG 848</a>: Missing <code>std::hash</code> specializations for <code>std::bitset</code>/<code>std::vector&lt;bool&gt;</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue850">LWG 850</a>: Should <code>shrink_to_fit</code> apply to <code>std::deque</code>? (i.e. <code>deque::shrink_to_fit</code>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue852">LWG 852</a>: unordered containers <code>begin(n)</code> mistakenly <code>const</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue900">LWG 900</a>: Stream move-assignment</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue1004">LWG 1004</a>: Clarify "throws an exception"
<ul>
<li>see national body comment UK 179 in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2837.pdf">N2837</a>: C++0X, CD 1, National Body Comments</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue1012">LWG 1012</a>: <code>reverse_iterator</code> default ctor should value initialize (adopted by LWG motion 1 in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3001.html">N3001</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue1071">LWG 1071</a>: <code>is_bind_expression</code> should derive from <code>integral_constant&lt;bool&gt;</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue1215">LWG 1215</a>: <code>list::merge</code> with unequal allocators
<ul>
<li>replaced by <code>ystdex::list::merge</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue1334">LWG 1334</a>: Insert iterators are broken for some proxy containers compared to C++03</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue1340">LWG 1340</a>: Why does <code>forward_list::resize</code> take the object to be copied by value?
<ul>
<li>see also <a href="https://wg21.cmeerw.net/lwg/issue679">LWG 679</a></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue1399">LWG 1399</a>: <code>function</code> does not need an explicit default constructor</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue1402">LWG 1402</a>: <code>nullptr</code> constructors for smart pointers should be <code>constexpr</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2005">LWG 2005</a>: <code>unordered_map::insert(T&amp;&amp;)</code> protection should apply to <code>map</code> too
<ul>
<li>partially replaced by <code>ystdex::map</code></li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2571">LWG 2571</a>: §<a href="https://eel.is/c++draft/map.modifiers#2">[map.modifiers]/2</a> imposes nonsensical requirement on <code>insert(InputIterator, InputIterator)</code>
<ul>
<li>replaced by <code>ystdex::map</code></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2045">LWG 2045</a>: <code>forward_list::merge</code> and <code>forward_list::splice_after</code> with unequal allocators
<ul>
<li>see also <a href="https://wg21.cmeerw.net/lwg/issue1215">LWG 1215</a></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2059">LWG 2059</a>: C++0x ambiguity problem with <code>map::erase</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2103">LWG 2103</a>: <code>std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::propagate_on_container_move_assignment</code> (see also <a href="https://wg21.cmeerw.net/lwg/issue2108">LWG 2108</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2104">LWG 2104</a>: <code>unique_lock</code> move-assignment should not be <code>noexcept</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2135">LWG 2135</a>: Unclear requirement for exceptions thrown in <code>condition_variable::wait()</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2233">LWG 2233</a>: <code>bad_function_call::what()</code> unhelpful</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2247">LWG 2247</a>: Type traits and <code>std::nullptr_t</code> (i.e. <code>is_null_pointer</code>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2261">LWG 2261</a>: Are containers required to use their 'pointer' type internally?</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2291">LWG 2291</a>: <code>std::hash</code> is vulnerable to collision DoS attack</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2313">LWG 2313</a>: <code>tuple_size</code> should always derive from <code>integral_constant&lt;size_t, N&gt;</code>
<ul>
<li>replaced by <code>ystdex::tuple_size</code> (since b958[2022-10-15])</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2321">LWG 2321</a>: Moving containers should (usually) be required to preserve iterators
<ul>
<li>replaced by <code>ystdex::map</code> and some other containers in YBase.YStandardEx which support the resolution</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2354">LWG 2354</a>: Unnecessary copying when inserting into maps with braced-init syntax</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2360">LWG 2360</a>: <code>reverse_iterator::operator*()</code> is unimplementable (see also <a href="https://wg21.cmeerw.net/lwg/issue2204">LWG 2204</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2362">LWG 2362</a>: unique, associative <code>emplace()</code> should not move/copy the mapped_type constructor arguments when no insertion happens (see also <a href="https://wg21.cmeerw.net/lwg/issue2006">LWG 2006</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2376">LWG 2376</a>: <code>bad_weak_ptr::what()</code> overspecified</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2393">LWG 2393</a>: <code>std::function</code>'s <code>Callable</code> definition is broken</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2437">LWG 2437</a>: <code>iterator_traits::reference</code> can and can't be <code>void</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2438">LWG 2438</a>: <code>std::iterator</code> inheritance shouldn't be mandated</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2442">LWG 2442</a>: <code>call_once()</code> shouldn't <code>DECAY_COPY()</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2455">LWG 2455</a>: Allocator default construction should be allowed to throw</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2466">LWG 2466</a>: <code>allocator_traits::max_size()</code> default behavior is incorrect</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2470">LWG 2470</a>: Allocator's <code>destroy</code> function should be allowed to fail to instantiate (split from <a href="https://wg21.cmeerw.net/lwg/issue2447">LWG 2447</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2483">LWG 2483</a>: <code>throw_with_nested()</code> should use <code>is_final</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2485">LWG 2485</a>: <code>get()</code> should be overloaded for <code>const tuple&amp;&amp;</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2503">LWG 2503</a>: multiline option should be added to <code>syntax_option_type</code>
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2343">LWG 2343</a>: Is the value of the ECMA-262 <code>RegExp</code> object's multiline property really false?</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2509">LWG 2509</a>: [fund.ts.v2] <code>any_cast</code> doesn't work with rvalue reference targets and cannot move with a value target
<ul>
<li><strong>NOTE</strong> The proposed resolution is targeting the working paper of the TS. It is not applied to <code>std::any</code> in ISO C++17 and it is still not in post-C++17 working draft <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4778.pdf">N4778</a>, and it is overriden by the resolution of <a href="https://wg21.cmeerw.net/lwg/issue2769">LWG 2769</a> partially.</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2141">LWG 2543</a>: <a href="https://wg21.cmeerw.net/lwg/issue2148">LWG 2148</a> (hash support for enum types) seems under-specified</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2547">LWG 2547</a>: Container requirements (and other library text) should say "strict total order", not just "total order"</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2549">LWG 2549</a>: Tuple EXPLICIT constructor templates that take tuple parameters end up taking references to temporaries and will create dangling references
<ul>
<li>see also <a href="https://wg21.cmeerw.net/lwg/issue2312">LWG 2312</a></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2567">LWG 2567</a>: Specification of logical operator traits uses <code>BaseCharacteristic</code>, which is defined only for <code>UnaryTypeTrait</code>s and <code>BinaryTypeTraits</code>
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2568">LWG 2568</a>: [fund.ts.v2] Specification of logical operator traits uses <code>BaseCharacteristic</code>, which is defined only for <code>UnaryTypeTraits</code> and <code>BinaryTypeTraits</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2577">LWG 2577</a>: <code>{shared,unique}_lock</code> should use <code>std::addressof</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2591">LWG 2591</a>: <code>std::function</code>'s member template <code>target()</code> should not lead to undefined behaviour</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2729">LWG 2729</a>: Missing SFINAE on <code>std::pair::operator=</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2744">LWG 2744</a>: <code>any</code>'s in_place constructors</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2754">LWG 2754</a>: The <code>in_place</code> constructors and emplace functions added by <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0032r3.pdf">P0032R3</a> don't require <code>CopyConstructible</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2766">LWG 2766</a>: Swapping non-swappable types</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2769">LWG 2769</a>: Redundant <code>const</code> in the return type of <code>any_cast(const any&amp;)</code>
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2768">LWG 2768</a>: <code>any_cast</code> and move semantics</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2781">LWG 2781</a>: Contradictory requirements for <code>std::function</code> and <code>std::reference_wrapper</code>
<ul>
<li>replaced by <code>ystdex::function</code> with the resolution</li>
<li>see also <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66284">GCC PR66284</a></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2794">LWG 2794</a>: Missing requirements for allocator pointers</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2857">LWG 2857</a>: {<code>variant</code>,<code>optional</code>,<code>any</code>}<code>::emplace</code> should return the constructed value
<ul>
<li>partially replaced by <code>ystdex::any</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2993">LWG 2993</a>: <code>reference_wrapper&lt;T&gt;</code> conversion from <code>T&amp;&amp;</code>
<ul>
<li>partially replaced by <code>ystdex::lref</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2993">LWG 3006</a>: Constructing a <code>basic_stringbuf</code> from a <code>string</code> — where does the allocator come from?</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue3017">LWG 3017</a>: <code>list</code> <code>splice</code> functions should use <code>addressof</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue3087">LWG 3087</a>: One final <code>&amp;x</code> in §<a href="https://eel.is/c++draft/list.ops">[list.ops]</a></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue3130">LWG 3130</a>: <a href="https://eel.is/c++draft/input.output">§[input.output]</a> needs many <code>addressof</code>
<ul>
<li>replaced by <a href="StandardUsing.en-US.html#replaced-dedicately"><code>platform::basic_ifstream</code>, <code>platform::basic_ofstream</code> and <code>platform::basic_fstream</code>, as well as their aliases</a></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue3190">LWG 3190</a>: <code>std::allocator::allocate</code> sometimes returns too little storage
<ul>
<li><strong>NOTE</strong> However, <a href="https://wg21.cmeerw.net/lwg/issue3237">LWG 3237</a> is adopted for the direct replacement <code>ystdex::polymorphic_allocator</code>.</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue3430">LWG 3430</a>: <code>std::fstream</code> &amp; co. should be constructible from <code>string_view</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue3679">LWG 3679</a>: Is <code>&lt;ranges&gt;</code> sufficient for <code>istream_view</code>?</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue3681">LWG 3681</a>: Further considerations on <a href="https://wg21.cmeerw.net/lwg/issue3679">LWG 3679</a></li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1981.html">N1981</a>: Uniform Use of <code>std::string</code> Revision 1</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1990.htm">N1990</a>: Proposed Text for <code>minmax</code> (N1840) (i.e. <code>minmax</code> and <code>minmax_element</code> in <code>&lt;algorithm&gt;</code>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1991.htm">N1991</a>: Proposed Text for <code>defaultfloat</code> (N1842) (i.e. <code>defaultfloat</code> in <code>&lt;ios&gt;</code>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2007.html">N2007</a>: Proposed Library Additions for Code Conversion</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2111.pdf">N2111</a>: Random Number Generation in C++0X: A Comprehensive Proposal, version 4
<ul>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue609">LWG 609</a>: missing <code>static const</code></li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2253.html">N2253</a>: Extending <code>sizeof</code> to apply to non-static data members without an object (revision 1)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2292.html">N2292</a>: Standard Library Applications for Deleted Functions</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2321.html">N2321</a>: Enhancing the <code>time_get</code> facet for POSIX® compatibility, Revision 2</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2353.html">N2353</a>: A Specification for <code>vector&lt;bool&gt;</code></li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2547.htm">N2547</a>: Allow atomics use in signal handlers</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2554.pdf">N2554</a>: The Scoped Allocator Model (Rev 2)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2760.htm">N2760</a>: Input/Output Library Thread Safety</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2765.pdf">N2765</a>: User-defined Literals (aka. Extensible Literals (revision 5))</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2782.htm">N2782</a>: C++ Data-Dependency Ordering: Function Annotation (i.e. <code>[[carries_dependency]]</code>)</li>
<li>N3026
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue408">CWG 408</a>: <code>sizeof</code> applied to unknown-bound array <code>static</code> data member of template</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue490">CWG 490</a>: Name lookup in <code>friend</code> declarations</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue722">CWG 722</a>: Can <code>nullptr</code> be passed to an ellipsis?</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue734">CWG 734</a>: Are unique addresses required for namespace-scope variables?</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue935">CWG 935</a>: Missing overloads for character types for user-defined literals</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1000">CWG 1000</a>: Mistaking member <code>typedef</code>s for constructors</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3059.pdf">N3059</a>: Proposal to simplify <code>pair</code> (rev 5.2) (i.e. <code>piecewise_construct_t</code>, etc.)
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue1321">LWG 1321</a>: <code>scoped_allocator_adaptor</code> <code>construct</code> and <code>destroy</code> don't use <code>allocator_traits</code></li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3282.pdf">N3282</a>: Resolution for core issues <a href="https://wg21.cmeerw.net/cwg/issue1207">1207</a> and <a href="https://wg21.cmeerw.net/cwg/issue1017">1017</a>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue945">CWG 945</a>: Use of <code>this</code> in a late-specified return type</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1017">CWG 1017</a>: Member access transformation in unevaluated operands (see also <a href="https://wg21.cmeerw.net/cwg/issue1005">CWG 1005</a>; note <a href="https://wg21.cmeerw.net/cwg/issue1005">CWG 515</a> is still effective)</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1207">CWG 1207</a>: Type of class member in <code>trailing-return-type</code> (see also <a href="https://wg21.cmeerw.net/cwg/issue945">CWG 945</a>)
<ul>
<li>GCC may not work. This is <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=52869">GCC PR 52869</a>, fixed in GCC 9, but it has regression in GCC 11.1 (see <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100752">GCC PR 100752</a>). Clang++ works.</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3651.pdf">N3651</a>: Variable Templates (Revision 1) (adopted 2013-04)
<ul>
<li>with <a href="https://wg21.cmeerw.net/cwg/issue1713">CWG 1713</a>: Linkage of variable template specializations</li>
<li>with <a href="https://wg21.cmeerw.net/cwg/issue2032">CWG 2032</a>: Default template-arguments of variable templates</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3664.html">N3664</a>: Clarifying Memory Allocation (adopted 2013-04)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3843.pdf">N3843</a>: A SFINAE-Friendly <code>std::common_type</code> (adopted 2014-11)
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2408">LWG 2408</a> SFINAE-friendly <code>common_type</code>/<code>iterator_traits</code> is missing in C++14</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4081.html">N4081</a>: Working Draft, C++ Extensions for Library Fundamentals (see <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html">N4480</a>)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4279.html">N4279</a>: Improved insertion interface for unique-key maps (Revision 2.3) (adopted 2014-11)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4510.html">N4510</a>: Minimal incomplete type support for standard containers, revision 4 (adopted 2015-05; however, <strong>similar requirements for associative containers (not proposed yet) were required when replacments were not used</strong>, see <a href="Development.zh-CN.html">here (zh-CN)</a>)
<ul>
<li>replaced by extension of <code>ystdex::map</code> and <code>ystdex::unordered_map</code></li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0022r2.html">P0022R2</a>: Proxy Iterators for the Ranges Extensions</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0083r3.pdf">P0083R3</a>: Splicing Maps and Sets (Revision 5) (adopted 2016-06)
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue839">LWG 839</a>: Maps and sets missing splice operation</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue1041">LWG 1041</a>: Add associative/unordered container functions that allow to extract elements</li>
<li>partially replaced by <code>ystdex::map</code> and <code>ystdex::unordered_map</code></li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0136r1.html">P0136R1</a>: Rewording inheriting constructors (<a href="https://wg21.cmeerw.net/cwg/issue1941">core issue 1941</a> et al) (adopted 2015-10)
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue1573">CWG 1573</a>: Inherited constructor characteristics</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1645">CWG 1645</a>: Identical inheriting constructors via default arguments</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1715">CWG 1715</a>: Access and inherited constructor templates</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1736">CWG 1736</a>: Inheriting constructor templates in a local class</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1903">CWG 1903</a>: What declarations are introduced by a non-member <code>using-declaration</code>?</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1941">CWG 1941</a>: SFINAE and inherited constructor default arguments</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1959">CWG 1959</a>: Inadvertently inherited copy constructor</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1991">CWG 1991</a>: Inheriting constructors vs default arguments</li>
</ul>
</li>
<li>following resolution of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0165r3.html">P0165R3</a>: C++ Standard Library Issues to be moved in Issaquah (adopted 2016-10)
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2062">LWG 2062</a>: Effect contradictions w/o no-throw guarantee of <code>std::function</code> swaps
<ul>
<li>replaced by <code>ystdex::function</code> since (revised b848[2018-12-24])</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0409r2.html">P0409R2</a>: Allow lambda capture <code>[=, this]</code> (adopted 2017-07)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0458r2.html">P0458R2</a>: Checking for Existence of an Element in Associative Containers (adopted 2018-06)
<ul>
<li>partially replaced by <code>ystdex::map</code> and <code>ystdex::unordered_map</code></li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0513r0.pdf">P0513R0</a>: Poisoning the Hash (adopted 2016-11)
<ul>
<li>national body comment FI 15 in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0488r0.pdf">P0488R0</a>: WG21 Working Paper, NB Comments, ISO/IEC CD 14882</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2791">LWG 2791</a>: <code>string_view</code> objects and strings should yield the same hash values</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0588r1.html">P0588R1</a>: Simplifying implicit lambda capture (adopted 2017-11)
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue1913">CWG 1913</a>: <code>decltype((x))</code> in <code>lambda-expression</code>s</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1632">CWG 1632</a>: Lambda capture in member initializers</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0600r1.pdf">P0600R1</a>: <code>[[nodiscard]]</code> in the Library, Rev1 (adopted 2017-11)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0616r0.pdf">P0616R0</a>: de-pessimize legacy <code>&lt;numeric&gt;</code> algorithms with <code>std::move</code> (adopted 2017-11)
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2055">LWG 2055</a>: <code>std::move</code> in <code>std::accumulate</code> and other algorithms</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0641r2.html">P0641R2</a>: Resolving Core Issue #1331 (<code>const</code> mismatch with defaulted copy constructor) (adopted 2017-11)
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue1331">CWG 1331</a>: <code>const</code> mismatch with defaulted copy constructor
<ul>
<li>see also <a href="https://wg21.cmeerw.net/cwg/issue1426">CWG 1426</a>: Allowing additional parameter types in defaulted functions</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0692r1.html">P0692R1</a>: Access Checking on Specializations (adopted 2017-11)
<ul>
<li>see also <a href="https://wg21.cmeerw.net/cwg/issue182">CWG 182</a></li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0840r2.html">P0840R2</a>: Language support for empty objects (adopted 2018-03)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0935r0.html">P0935R0</a>: Eradicating unnecessarily explicit default constructors from the standard library (adopted 2018-06)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1227r2.html">P1227R2</a>: Signed <code>ssize()</code> functions, unsigned <code>size()</code> functions (Revision 2) (adopted 2019-03)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1668r1.html">P1668R1</a>: Enabling <code>constexpr</code> Intrinsics By Permitting Unevaluated inline-assembly in <code>constexpr</code> Functions (adopted 2019-07)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2242r3.html">P2242R3</a>: Non-literal variables (and labels and gotos) in <code>constexpr</code> functions (adopted 2021-10)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2314r4.html">P2314R4</a>: Character sets and encodings (adopted 2021-10)
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue2455">CWG 2455</a>: Concatenation of string literals vs translation phases 5 and 6</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2647r1.html">P2647R1</a>: Permitting <code>static constexpr</code> variables in <code>constexpr</code> functions (adopted 2022-11)</li>
</ul>
<h3 id="avoided"><a class="header" href="#avoided">Avoided</a></h3>
<p>These already adopted (by the standard or the working paper) post-C++11 resolutions (which may need no modification on a previous conforming C++ implementation) are <strong>not</strong> depended on <strong>currently</strong> (revised b971[2023-04-05]) but confirmed still being compatible, and also <strong>would not be relied on in future</strong> based on the fact of reducing expresiveness in the language and lacking of portable extensions to prevent underming of code quality based on current status:</p>
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r3.pdf">P0145R3</a>: Refining Expression Evaluation Order for Idiomatic C++ (adopted 2016-06)</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0218r0.html">P0218R0</a>: Adopt the <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4100.pdf">File System TS</a> for C++17
<ul>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2676">LWG 2676</a>: Provide <code>filesystem::path</code> overloads for File-based streams</li>
<li><strong>Rationale</strong> There are dedicated APIs from YSLib providing potentionally more powerful and portable platform-dependent features with a different design based on <code>ystdex::path</code> (a container template being filesystem-agnostic) and YCLib platform APIs instead of specific string-based path types. To simplify the design, the features are not used, and interoperations are not supported yet.</li>
</ul>
</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1847r4.pdf">P1847R4</a>: Make declaration order layout mandated (adopted 2021-06)</li>
</ul>
<h1 id="list-of-reported-issues"><a class="header" href="#list-of-reported-issues">List of reported issues</a></h1>
<p>There are some issues related reported, or originally found and forwarded by author of this project. Some issues are related to the to language or enviornment specifications. See <a href="ReportedIssues.en-US.html">reported issues</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h1>
<p>There are some issues related reported, or originally found and forwarded by author of this project. Some issues might block the project in some sense. To review them conveniently, reported issues are collect in this document.</p>
<p>Unless otherwise specified, notations are same to those in <a href="StandardUsing.en-US.html">StandardUsing</a>.</p>
<h1 id="list-of-reported-issues-1"><a class="header" href="#list-of-reported-issues-1">List of reported issues</a></h1>
<p>Issues not rejected or withdrawn are collected and listed here (revised b840[2018-10-07]).</p>
<h2 id="specifications"><a class="header" href="#specifications">Specifications</a></h2>
<p>Some issues are related to the to language or enviornment specifications.</p>
<p>The entries may duplicate with above.</p>
<h3 id="isoiec-14882-isoiec-jtc1-sc22wg21-issue-list"><a class="header" href="#isoiec-14882-isoiec-jtc1-sc22wg21-issue-list">ISO/IEC 14882 (ISO/IEC JTC1 SC22/WG21 issue list)</a></h3>
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue1949">CWG 1949</a>: “sequenced after” instead of “sequenced before” (resolved at <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4567.pdf">N4567</a>, see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4566.html">N4566</a>)
<ul>
<li>Issue delegated in <a href="https://github.com/cplusplus/draft/issues/61">GitHub issue 61</a>.</li>
</ul>
</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue2240">LWG 2240</a>: Probable misuse of term "function scope" in <a href="https://eel.is/c++draft/thread.condition">[thread.condition]</a> (resolved)
<ul>
<li>Original thread posted in <a href="https://groups.google.com/a/isocpp.org/forum/#!topic/std-discussion/JpQVT-pwP9E">std-discussion</a>.</li>
<li>Issue delegated in <a href="https://github.com/cplusplus/draft/issues/57">GitHub issue 57</a>.</li>
</ul>
</li>
</ul>
<h2 id="implementations-of-standards-or-specifications"><a class="header" href="#implementations-of-standards-or-specifications">Implementations of standards or specifications</a></h2>
<p>Some issues are related to the to implementations of language or enviornment specifications.</p>
<h3 id="gnu-c-bugzilla"><a class="header" href="#gnu-c-bugzilla">GNU C++ (<a href="https://gcc.gnu.org/bugzilla/">Bugzilla</a>)</a></h3>
<ul>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53872">PR 53872</a>: [C++11] ADL bug in <code>std::thread</code> (RESOLVED FIXED 4.7.2)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53873">PR 53873</a>: [C++11] strange error message for template overloading (RESOLVED DUPLICATE of <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53862">bug 53862</a>)
<ul>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53862">PR 53862</a>: [4.6/4.7 regression] [C++11] sorry, unimplemented: use of 'type_pack_expansion' in template (RESOLVED FIXED 4.7.1)</li>
</ul>
</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=54216">PR 54216</a>: Missing diagnostic for ill-formed anonymous enum declarations (RESOLVED FIXED 4.9.0)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=55053">PR 55053</a>: <code>std::is_explicitly_convertible</code> should be removed (RESOLVED WORKSFORME 4.8.0)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=56699">PR 56699</a>: [4.8/4.9 regression] Failed for sizeof (non-static member) in lambda expression (RESOLVED FIXED mainline/4.8.1)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57183">PR 57183</a>: [C++11] <code>auto</code> and -Wunused-variable (RESOLVED FIXED 4.8.1)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57444">PR 57444</a>: [4.8/4.9 Regression] ICE in instantiate_type for invalid use of member with <em>using-declaration</em> (RESOLVED DUPLICATE of <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58457">bug 58457</a>)
<ul>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58457">PR 58457</a>: [4.8/4.9 Regression] ICE when placement <code>new</code> operator is used with using keyword and custom constructor (RESOLVED FIXED 4.8.2/4.9.0)</li>
</ul>
</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58395">PR 58395</a>: Undefined behavior vs. exception (RESOLVED WONTFIX)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=59682">PR 59682</a>: Invalid syntax accepted: new-placement without <em>expression-list</em> (RESOLVED FIXED 6.0)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=59931">PR 59931</a>: Wrong wording of diagnostic about imaginary "member function type"</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=60709">PR 60709</a>: [C++11]ICE when using a <em>braced-init-list</em> as function argument to initialize a reference to array (RESOLVED FIXED 4.8.3)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61019">PR 61019</a>: ICE: incomplete type of class template as <em>pseudo-destructor-name</em> (RESOLVED FIXED 6.0)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63400">PR 63400</a>: [C++11]precision of <code>std::chrono::high_resolution_clock</code> (UNCONFIRMED)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65343">PR 65343</a>: unexpected exception thrown during destruction of static object in debug mode
<ul>
<li>Since some version of Windows 10, the crash dialog would not show, made it less annoying.</li>
</ul>
</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65748">PR 65748</a>: [C++11][C++14]Invalid copy elision on operand of <em>throw-exception</em> (RESOLVED DUPLICATE of <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57533">bug 57533</a>)
<ul>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57533">PR 57533</a>: When throwing local variable, it's being move-constructed even if not going out of scope. (NEW)</li>
<li>This misfeature is carefully avoided in YSLib source.</li>
</ul>
</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65890">PR 65890</a>: [C++03]<code>sizeof(qualified-id)</code> accepted when the operand denotes a non-static member (RESOLVED INVALID)
<ul>
<li>This does not effect YSLib since C++11 is the baseline.</li>
</ul>
</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67238">PR 67238</a>: [C++11][C++14]cc1plus crash for nested <code>decltype</code> expression in parameter pack in trailing return type when '-g' enabled (RESOLVED FIXED 6.0)
<ul>
<li>This was worked arounded in YSLib source, before 6.0 is actually depended on.</li>
</ul>
</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67795">PR 67795</a>: Wrong code generated for conditional expression with cast (WAITING)
<ul>
<li>Given that it is not confirmed fixed, this may still block some code.</li>
</ul>
</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=70480">PR 70480</a>: Reduce RTTI code bloat for specified types (NEW)
<ul>
<li>For the DS platform, YSLib uses <code>ystdex::type_id</code> instead <code>typeid</code> to work around.</li>
</ul>
</li>
<li><a href="https://bitbucket.org/FrankHB/yslib/issues/30/b699-mingw32-some-error-constants">YSLib issue 30</a>
<ul>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=71444">PR 71444</a>: Error constants for MinGW-w64 (RESOLVED FIXED 5.5 6.4 7.1)</li>
<li>This was worked around in YSLib source and fixed since G++ 7.1.</li>
</ul>
</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86734">PR 86734</a>: [<a href="https://wg21.cmeerw.net/lwg/issue2188">DR 2188</a>] <code>reverse_iterator::operator-&gt;</code> does not support overloaded <code>operator&amp;</code> (RESOLVED FIXED 7.4 8.3)
<ul>
<li>See upstream <a href="https://wg21.cmeerw.net/lwg/issue2188">LWG 2188</a>.</li>
<li>This is conditionally avoided by <a href="StandardUsing.en-US.html">the YBase replacement</a> <code>ystdex::reverse_iterator</code>.</li>
</ul>
</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=90966">PR 90966</a>: [9/10 Regression] ICE in <code>tsubst_copy</code>, at <code>cp/pt.c</code>:16155 (RESOLVED FIXED 9.3 and 10)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=91127">PR 91127</a>: Incorrect checking of nonnull attribute with argument to a constructor of class with a virtual base (NEW)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=91480">PR 91480</a>: Nonconforming definitions of standard library feature-test macros (NEW)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=91531">PR 91531</a>: <code>_Rb_tree</code>'s copy assignment should respect to POCCA regardless of <code>is_always_equal</code> (NEW)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=91541">PR 91541</a>: [C++17] Exception specification of <code>operator=</code> of node-based containers may be broken (RESOLVED WONTFIX)
<ul>
<li>Actually it is then fixed.</li>
</ul>
</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=91620">PR 91620</a>: <code>std::[forward_]list::remove_if/unique</code> should respect to <a href="https://wg21.cmeerw.net/lwg/issue526">DR 526</a> (RESOLVED FIXED 11.0)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=93470">PR 93470</a>: [C++2a] [9 Regression] [C++2a] <code>std::reference_wrapper</code> to function type is broken with Clang (RESOLVED FIXED 9.3)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=94602">PR 94602</a>: wrong semantic check to prvalue as <code>decltype</code> operand (UNCONFIRMED)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=97362">PR 97362</a>: <code>__deref</code> in <code>&lt;functional&gt;</code> in debug mode clashes with internal macro in Windows system header (RESOLVED FIXED 8.5 9.4 10.3 11.0)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100472">PR 100472</a>: [C++17] Wrong template non-type argument handling on function reference to <code>noexcept</code> functions (RESOLVED DUPLICATE of <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=97420">bug 97420</a>)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100682">PR 100682</a>: Outdated manual about the debug mode using (RESOLVED FIXED 11.3 12.0)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=104191">PR 104191</a>: Incorrect <code>max_size()</code> for node-based containers (NEW)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=107189">PR 107189</a>: Inconsistent range insertion implementations in <code>std::_Rb_tree</code> in <code>&lt;bits/stl_tree.h&gt;</code> (RESOLVED FIXED 13.0)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=108771">PR 108771</a>: Incorrect <code>noexcept</code> for merging in <code>&lt;bits/stl_tree.h&gt;</code> (UNCONFIRMED)</li>
</ul>
<h3 id="llvmclang-bugzilla-and-github-issues"><a class="header" href="#llvmclang-bugzilla-and-github-issues">LLVM/Clang (<a href="https://llvm.org/bugs/">Bugzilla</a> and <a href="https://github.com/llvm/llvm-project/issues">GitHub issues</a>)</a></h3>
<ul>
<li><a href="https://llvm.org/bugs/show_bug.cgi?id=25306">PR 25306</a>: <code>__attribute__((returns_nonnull))</code> does not work for <code>std::add_pointer_t&lt;T&gt;</code> (NEW)</li>
<li><a href="https://llvm.org/bugs/show_bug.cgi?id=27504">PR 27504</a>: Inherited constructor with dependent base class introduced by a <em>typedef-name</em> may not work (NEW)</li>
<li><a href="https://llvm.org/bugs/show_bug.cgi?id=27443">PR 27443</a>: [CWG 734] Nonconforming aliasing of block scope objects (RESOLVED DUPLICATE of <a href="https://llvm.org/bugs/show_bug.cgi?id=18538">bug 18538</a>)
<ul>
<li><a href="https://llvm.org/bugs/show_bug.cgi?id=18538">PR 18538</a>: non-conforming optimization <code>-fmerge-all-constants</code> is enabled by default</li>
<li>Note they are not identical. PR 27443 is for ISO C++ and PR 18538 is for ISO C.</li>
</ul>
</li>
<li><a href="https://bugs.llvm.org/show_bug.cgi?id=43275">PR 43275</a>: Pure attribute and C++ exceptions (NEW)</li>
<li><a href="https://bugs.llvm.org/show_bug.cgi?id=45542">PR 45542</a>: wrong semantic check to prvalue as <code>decltype</code> operand (NEW)</li>
<li><a href="https://github.com/llvm/llvm-project/issues/60622">issue 60622</a> (NEW)</li>
</ul>
<h3 id="microsoft-visual-c"><a class="header" href="#microsoft-visual-c">Microsoft Visual C++</a></h3>
<p>New issues are now reported to <a href="https://developercommunity.visualstudio.com/">Microsoft Visual Studio Developer Community</a>.</p>
<p>As <a href="https://connect.microsoft.com/">Microsoft Connect</a> is down now, any status would not be updated. Note some posts have been inaccessible even before the service stopped.</p>
<ul>
<li><a href="https://connect.microsoft.com/VisualStudio/feedback/details/1641428">Microsoft Connect issue 1641428</a>: Wrong Win32 error to <code>errno</code> mapping (ACTIVE)
<ul>
<li>YSLib code does not rely on Universal source, instead implements the functionality spearatedly, so it has no effect.</li>
<li>This seems to be fixed before Microsoft Connect closed.</li>
</ul>
</li>
<li><a href="https://bitbucket.org/FrankHB/yslib/issues/33">YSLib issue 33</a>
<ul>
<li><a href="https://connect.microsoft.com/VisualStudio/feedback/details/2913382">Microsoft Connect issue 2913382</a>: Parameter parsing bug (ACTIVE)</li>
<li><a href="https://developercommunity.visualstudio.com/content/problem/431539/vc-cannot-parse-function-pointer-parameter-with-de.html">problem 431539</a>: VC++ cannot parse function pointer parameter with default argument '{}' (Under Consideration)</li>
</ul>
</li>
<li><a href="https://bitbucket.org/FrankHB/yslib/issues/34">YSLib issue 34</a>: [Win32] std::unique_ptr::operator-&gt; not conforming in Microsoft VC++ 2015
<ul>
<li><a href="https://connect.microsoft.com/VisualStudio/feedback/details/2918170">Microsoft Connect issue 2918170</a>: <code>std::unique_ptr::operator-&gt;</code> not conforming (FIXED accroding to <a href="https://blogs.msdn.microsoft.com/vcblog/2016/10/11/c1417-features-and-stl-fixes-in-vs-15-preview-5/">here</a>)</li>
</ul>
</li>
<li><a href="https://developercommunity.visualstudio.com/content/problem/417142/lwg-2070p0674r1-stdallocate-shared-is-not-conformi.html">problem 417142</a>: [LWG 2070][P0674R1] <code>std::allocate_shared</code> is not conforming (Under Investigation)</li>
<li><a href="https://bitbucket.org/FrankHB/yslib/issues/35">YSLib issue 35</a>: [Win32] Microsoft VC++ 2017 failed to evaluate the dependent noexcept expression inside noexcept-specifier
<ul>
<li><a href="https://developercommunity.visualstudio.com/content/problem/431598/vc-fails-to-compile-the-noexcept-expression-inside.html">problem 431598</a>: VC++ fails to compile the noexcept expression inside noexcept-specifier with a template-parameter instantiated from an explicit destruct call (Closed - Fixed)(Fixed In: Visual Studio 2019 version 16.1)(Fixed In: Visual Studio 2019 version 16.1 Preview 1)</li>
</ul>
</li>
<li><a href="https://bitbucket.org/FrankHB/yslib/issues/36">YSLib issue 36</a>: [Win32] Microsoft VC++ 2017 failed to initialize with string arrays with a constexpr u8 string literal
<ul>
<li><a href="https://developercommunity.visualstudio.com/content/problem/431628/vc-fails-to-initialize-with-string-arrays-with-a-c.html">problem 431628</a>: VC++ fails to initialize with string arrays with a constexpr u8 string literal (Closed - Fixed)(Fixed In: Visual Studio 2019 version 16.0)(Fixed In: Visual Studio 2019 version 16.0 Preview 5)</li>
</ul>
</li>
<li><a href="https://bitbucket.org/FrankHB/yslib/issues/37">YSLib issue 37</a>: [Win32] Microsoft VC++ 2017 internal compiler error when building SHBuild
<ul>
<li><a href="https://developercommunity.visualstudio.com/content/problem/431665/vc-2017-internal-error-for-overloaded-qualified-fu.html">problem 431665</a>: VC++ 2017 internal error for overloaded qualified function template function call in the function default argument (Closed - Fixed)(Fixed In: Visual Studio 2019 version 16.1)(Fixed In: Visual Studio 2019 version 16.0)</li>
</ul>
</li>
<li><a href="https://bitbucket.org/FrankHB/yslib/issues/38">YSLib issue 38</a>: [Win32] Microsoft VC++ 2017 failed to select expected std::swap specialization
<ul>
<li><a href="https://developercommunity.visualstudio.com/content/problem/431904/vc-2017-stdswap-is-not-conforming.html">problem 431904</a> (Closed - Fixed)(Fixed In: Visual Studio 2019 version 16.1)(Fixed In: Visual Studio 2019 version 16.1 Preview 2)(Fixed In: Visual Studio 2019 version 16.1 Preview 1)</li>
</ul>
</li>
<li><a href="https://bitbucket.org/FrankHB/yslib/issues/39">YSLib issue 39</a>: [Win32] Microsoft VC++ 2017 rejects dependent noexcept-specifier in template partial specializations
<ul>
<li><a href="https://developercommunity.visualstudio.com/t/vc-2017-rejects-dependent-noexcept-specifier-in-te/441268">problem 441268</a> (Closed - Not a bug)
<ul>
<li>According to <a href="https://developercommunity.visualstudio.com/t/vc-2017-rejects-dependent-noexcept-specifier-in-te/441268#T-N873330">this reply</a>, it is a defect of ISO C++, see <a href="https://wg21.cmeerw.net/cwg/issue2355">CWG 2355</a>. However, the wrong compilation error C2057 has been fixed.</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://github.com/microsoft/STL/issues/2093">microsoft/STL issue 2093</a>: <code>fiopen</code> handling of non-standard flags (Open)</li>
<li><a href="https://github.com/microsoft/STL/issues/2093">microsoft/STL issue 2609</a>: <code>&lt;memory_resource&gt;</code>: Conformance issues on <code>monotonic_buffer_resource::do_allocate</code> (Open)</li>
</ul>
<h2 id="other-projects"><a class="header" href="#other-projects">Other projects</a></h2>
<p>As complement, some issues are related to other tools used by the project or referenced in documentation of this project, which may loosely concern with issues listed above.</p>
<h3 id="drmemory"><a class="header" href="#drmemory">DrMemory</a></h3>
<ul>
<li><a href="https://github.com/DynamoRIO/drmemory/issues/1826">issue 1826</a>: Crash in Win10 TH2 (Closed <a href="https://github.com/DynamoRIO/drmemory/commit/446007ec2c76fbab9220850b38aac48c538eee18">FIXED</a>)</li>
</ul>
<h3 id="devkitpro"><a class="header" href="#devkitpro">devkitPro</a></h3>
<h4 id="libfat"><a class="header" href="#libfat">libfat</a></h4>
<ul>
<li><a href="https://github.com/devkitPro/libfat/pull/1">pull request 1</a>: Removed redundant check (<a href="https://github.com/devkitPro/libfat/commit/1e1e9a23ddc4fce1cf5f956fc94cffc9d3569c20">Merged</a>)</li>
<li><a href="https://github.com/devkitPro/libfat/issues/2">issue 2</a>: Wrong root sectors count determined for FAT12 and FAT16? (Open)</li>
<li><a href="https://github.com/devkitPro/libfat/issues/3">issue 3</a>: Redundant function calls (Open)</li>
<li><a href="https://github.com/devkitPro/libfat/issues/4">issue 4</a>: <code>_FAT_directory_entryFromPosition</code> issues (Open)</li>
<li><a href="https://github.com/devkitPro/libfat/issues/5">issue 5</a>: Redundant call of <code>_FAT_directory_getRootEntry</code> for "<code>/</code>" (Open)</li>
<li><a href="https://github.com/devkitPro/libfat/issues/6">issue 6</a>: <code>ENOTDIR</code> vs <code>ENOENT</code> for invalid path prefix (Open)</li>
<li><a href="https://github.com/devkitPro/libfat/issues/7">issue 7</a>: Pathname with or without trailing slashes for directories (Open)</li>
<li><a href="https://github.com/devkitPro/libfat/issues/10">issue 10</a>: Setting <code>errno</code> when removing a non-empty directory (Open)</li>
<li><a href="https://github.com/devkitPro/libfat/issues/19">issue 19</a>: Uninitialized <code>timespec</code> fields in <code>stat</code> (Open)</li>
</ul>
<h4 id="libnds"><a class="header" href="#libnds">libnds</a></h4>
<ul>
<li><a href="https://github.com/devkitPro/libnds/issues/3">issue 3</a>: Compiler warnings (Closed)</li>
<li><a href="https://github.com/devkitPro/libnds/issues/4">issue 4</a>: About <code>std::chrono</code> clocks (Closed)</li>
<li><a href="https://github.com/devkitPro/libnds/pull/30">pull request 30</a>: Removed redundant code. (<a href="https://github.com/devkitPro/libnds/commit/aaf79c49fa8a8dfb18b8fb53da72dd0fc7f622a5">Merged</a>)</li>
<li><a href="https://github.com/devkitPro/libnds/pull/33">pull request 33</a>: Fixed redundant qualifier (<a href="https://github.com/devkitPro/libnds/commit/a76bff0e943ee2f516bda5f1c7bc6d81d2af44a7">Merged</a>)</li>
</ul>
<h4 id="newlib"><a class="header" href="#newlib">newlib</a></h4>
<ul>
<li><a href="https://github.com/devkitPro/newlib/issues/5">issue 5</a>: Nonconforming return type of <code>ftell</code> (Closed FIXED)</li>
</ul>
<h3 id="other-language-implementations"><a class="header" href="#other-language-implementations">Other language implementations</a></h3>
<p>As <a href="https://bitbucket.org/blog/sunsetting-mercurial-support-in-bitbucket">Mercurial support of BitBucket has ended</a> now, any status of issues of Mercurial repositories would not be updated, and the links are not accessible.</p>
<ul>
<li><a href="https://bitbucket.org/AndresNavarro/klisp/issues/12">klisp issue 12</a>: A problem of proper tail call (NEW)</li>
<li><a href="https://github.com/shirok/Gauche/issues/805">Gauche issue 805</a>: <code>=</code> can be not transitive (Closed <a href="https://github.com/shirok/Gauche/commit/1701481673cba786d30e0b322411c0034fdcbec5">FIXED</a>)</li>
<li><a href="https://github.com/cisco/ChezScheme/issues/606">Chez Scheme issue 606</a>: <code>=</code> can be not transitive (Closed <a href="https://github.com/ashinn/chibi-scheme/commit/82d61b3d8e50bacc266b450e21127663f3c39de5">FIXED</a>)</li>
<li><a href="https://github.com/ashinn/chibi-scheme/issues/812">Chibi Scheme issue 812</a>: <code>=</code> can be not transitive (Closed)</li>
<li><a href="https://github.com/makotom/glibc-wsl/issues/2">makotom/glibc-wsl issue 2</a>:  Please update (Closed <a href="https://github.com/makotom/glibc-wsl/releases/tag/2.35-2%4028-14f31b0">FIXED</a>)</li>
<li><a href="https://github.com/archlinuxcn/repo/issues/2678">archlinuxcn/repo issue 2678</a>: glibc-linux4 is outdated (Closed <a href="https://github.com/archlinuxcn/repo/commit/abc940cde81372a433040da704c2ede5e3b90da8">FIXED</a>)</li>
</ul>
<h1 id="resolved-implementation-issues"><a class="header" href="#resolved-implementation-issues">Resolved implementation issues</a></h1>
<p>Some issues were tagged BLOCKED status previously. Issues known resolved and confirmed to work would be put in this chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general"><a class="header" href="#general">General</a></h1>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>This document describes a set of rules for creating and maintaining documentations or some other kinds of materials, which is not project-specific. This document is also self-conforming to these rules.</p>
<h2 id="notation-1"><a class="header" href="#notation-1">Notation</a></h2>
<p>Specific formats may be used. The visual output may depend on the method of rendering.</p>
<p>Texts intended to be handled differently (for example, portions of program source code) may be in <code>some specific format</code>. Other texts are considered normal.</p>
<p><a href="https://en.wikipedia.org/wiki/Hyperlink">Hyperlinks</a> may be used in normal texts pointing to external references, local pages, or anchors in specific documents.</p>
<p>Normal text empasized in general are in <strong>the specific format</strong>, usually (visually) bold.</p>
<p>Local terms in the normal text are emphasized at first appearence in <em>the specific format</em>, usually (visually) italic.</p>
<p>For terms used globally in this document and any other derivations, see below.</p>
<h2 id="terms-and-definitions"><a class="header" href="#terms-and-definitions">Terms and definitions</a></h2>
<h3 id="resources-1"><a class="header" href="#resources-1">Resources</a></h3>
<p>Contents of materials are split as <em>resources</em> (e.g. <a href="http://en.wikipedia.org/wiki/Computer_file"><em>files</em></a>) in possibly nested <em>namespaces</em> (e.g. <a href="http://en.wikipedia.org/wiki/Directory_%28computing%29"><em>directories</em></a>). A namespace is also considered as a resource for convenience.</p>
<h3 id="paths-and-identifiers"><a class="header" href="#paths-and-identifiers">Paths and identifiers</a></h3>
<p>A <em>path</em> is used to identifying or locating a resource, which can be in various forms (e.g. filesystem <a href="http://en.wikipedia.org/wiki/Path_%28computing%29"><em>path</em></a> or <a href="http://en.wikipedia.org/wiki/Uniform_resource_locator"><em>URL</em></a>).</p>
<p>A path may have several <em>components</em> denoting different <em>levels</em> of namespace or the last level non-namespace resource.</p>
<p>An <em>empty path</em> is a path without any components.</p>
<p>A path with more than one components shall have syntactic <em>separators</em> (e.g. a slash(<code>/</code>) or whitespace) to split different components.</p>
<p>An <em>identifier</em> is a path with exactly one components without any separators, which can be used to differentiate resources in the same namespace or to collectively name some sets of resources in various namespaces.</p>
<p>A resource may be denoted with not necessarily the unique identifier or path. However, all resources this document discussed below are named.</p>
<h2 id="languages"><a class="header" href="#languages">Languages</a></h2>
<p>Rules of natural languages are specified in this subclause. They have effects on normal texts.</p>
<p>Normal text of noun phrases may have embedded translations for different natural languages or more detailed descriptions following its first occurence, in parentheses (<code>(</code> and <code>)</code>).</p>
<p>Different <a href="https://en.wikipedia.org/wiki/Letter_case">letter cases</a> (if appropriate) may be used for sentences, acronyms and words in the titles of clauses.</p>
<h3 id="editions-in-languages"><a class="header" href="#editions-in-languages">Editions in languages</a></h3>
<p>A set of documentation may be in one (natural) language. The <a href="http://en.wikipedia.org/wiki/IETF_language_tag">IETF language tag</a> with at least one subtag and an additional prefix dot(<code>.</code>) shall be placed in the end of identifier of the resource before the dot and the extension name (if any). Otherwise the documentation shall be in multiple languages or without text contents (e.g. containing only ideographic images), and no language code shall be in the identifier of the resource.</p>
<p>When the additional dot and tag is removed, all different resource with same names shall refer to the same set of contents only in different languages, or at least one of them shall be <em>incomplete</em> which means to be <em>completed</em> as in former case. The resource is one <em>edition</em> in the specific language of the documentation.</p>
<p>Unless explicitly specified, when the meaning is in conflict for multiple editions in different languages, the complete one shall be valid over others. If there is not only one complete edition, the validity is specified in following order:</p>
<ul>
<li><code>en-US</code></li>
<li><code>en</code></li>
<li><code>zh-CN</code></li>
<li><code>zh</code></li>
</ul>
<p><strong>NOTE</strong> The form of these literals conforms to the recommendation of <a href="https://en.wikipedia.org/wiki/IETF_language_tag">IETF language tag</a>, specifically, the "language" and "region" syntax elements in <a href="https://www.rfc-editor.org/rfc/rfc5646.html">RFC 5646</a>.</p>
<p>If no one edition in above languages is complete, the documentation is defective.</p>
<p>A language tag may be used to annotate one or more words in text. An annotation of such use is a <em>language tag annotation</em>, which consists of a tag combined with one pair of enclosing parentheses (namely, <code>(</code> and <code>)</code>).</p>
<p>Hyperlinks in pages should preferrably link to localized contents corresponding to the language or one of the major languages used in the page (if any) when suitable. If contents of the linked target is in other languages (esp. when there are more than one semantically identical editions in multiple languages), at least one language tag for majority of the contents should be noted subsequent to the hyperlink; otherwise, the tag should be omitted.</p>
<p>For compatibility of client programs, each link of <a href="https://en.wikipedia.org/wiki/URI">URI</a> should be encoded in form of normalized <a href="https://tools.ietf.org/html/rfc3986#section-2.1">Percent-Encoding in RFC 3986</a>.</p>
<p>Additionally, several hyperlinks are normalized with the same form for a specific language. Currently the rule consists of following cases:</p>
<ul>
<li>For <a href="https://zh.wikipedia.org/zh-cn">Chinese Wikipedia(zh-CN)</a>, the link shall following the rule in <a href="https://zh.wikipedia.org/zh-cn/Help:%E4%B8%AD%E6%96%87%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%E7%9A%84%E7%B9%81%E7%AE%80%E3%80%81%E5%9C%B0%E5%8C%BA%E8%AF%8D%E5%A4%84%E7%90%86">the section in the language conversion help page(zh-CN)</a>, with small letter "cn" in the link.</li>
</ul>
<h3 id="in-english"><a class="header" href="#in-english">In English</a></h3>
<p>Stylistic usage of letter cases shall be respected in the following precedence:</p>
<ol>
<li>All uppercase should not be used normally.</li>
<li>Acronyms and other proper noun (pharses) shall be in the appropriate styles.</li>
<li>The title case style shall be used for page or document titles.</li>
<li>Either the title case or the sentence case shall be used in the titles in a page. This shall be consistent within a document.</li>
<li>Either the title case or the sentence case shall be used in the detailed descriptions for acronyms in parentheses. This may vary in the same page.</li>
<li>Detailed descriptions for acronyms in parentheses may use title case or sentence case.</li>
<li>All lowercase style shall be used for words in the embedded translations or detailed descriptions in parentheses in other cases.</li>
<li>Sentence case should be used otherwise.</li>
</ol>
<p>English wording documentation is intended to be conforming to <a href="http://std.dkuug.dk/jtc1/sc22/wg9/isodir3.pdf">the ISO/IEC directive, part 3</a>.</p>
<p><strong>NOTE</strong> The use of modal verbs is distinct with <a href="http://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a>.</p>
<p>For wording referenced from RFC documents, RFC 2119 is preferred, but not necessary with the case clarification (i.e. <a href="https://tools.ietf.org/html/rfc8174">RFC 8174</a>) for documents published earlier than RFC 8174 due to compatibility issues.</p>
<p>The following grammartical forms of English (with <code>en</code> or <code>en-US</code> tags) are considered idiomatic and application of such forms may be preferred:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Answer_ellipsis">answer ellipsis</a> to elide the subject in the summary of commit messages where a question for the topic of the log message is assumed</li>
<li><a href="http://en.wikipedia.org/wiki/English_passive_voice#Additional_passive_constructions">bare passive clause</a> omitting the auxiliary verb for short descriptive notes (e.g. commit messages in repositories and assertions messages in programs)</li>
<li><a href="https://en.wikipedia.org/wiki/Null-subject_language#The_imperative_form">null subject</a> and <a href="https://en.wikipedia.org/wiki/Pro-drop_language#English">pronoun dropping</a> in imperative forms</li>
<li><a href="https://en.wikipedia.org/wiki/Zero-marking_in_English#Zero_article">zero article</a> for singular form of a countable noun denoting a specialized term being referenced, usually used in a terse-style title or in a list term (like this line)</li>
</ul>
<p><strong>Informative notes:</strong> The tense and mood used in the logs in version control systems are <a href="https://stackoverflow.com/questions/3580013/should-i-use-past-or-present-tense-in-git-commit-messages">opinion-based</a>. However, the implied rules are choosed here to avoid imperative forms by default, because:</p>
<ul>
<li>First, it should be respected same in all information processing system: to make sure who are the messages in the logs serve to.
<ul>
<li>Version control systems are capable for reading and writing operations on the version history, with asymmetric operational frequency in general.
<ul>
<li>For most stakeholders to a repository in most cases, read-only accesses of the version history are more frequent compared to changing opertions.</li>
<li>This is also consistent with the idiom pattern used in programming: do not abuse imperative updates with side effects.</li>
</ul>
</li>
<li>For most users, commit logs are <a href="https://stackoverflow.com/a/8059167/2307646">entries of journal</a> of the version history.
<ul>
<li>They do not and should not care about imperative changes in the logical perspective.</li>
</ul>
</li>
</ul>
</li>
<li>Unconstrained changes in the version history as effectful operations can make messes easily.
<ul>
<li>They are usually only well-behaved enough within some local context (e.g. in a single branch of a reliable instance of the version history).</li>
<li>They often make troubles in other cases (e.g. when stripped as patches possibly reordered).</li>
</ul>
</li>
<li>Messages in the logs may be cooperated with other instances of version history.
<ul>
<li>No imperative mood can essentially assume the changes described will always be applied in the exactly same way.</li>
<li>As mentioned above, out-of-order changes make messes. If the messages are precise, they also make messes like other changed contents.</li>
</ul>
</li>
<li>In general, messages in the logs work for distributed repositories.
<ul>
<li>There is simply no standpoint for the global view of the universe of the version history by default.</li>
<li>Messages should be ready to be audited by random accesses, besides being applied subsequently in some replays.</li>
<li>These facts further undermines the necessity of imperative changes.</li>
</ul>
</li>
</ul>
<h1 id="format-specific-rules"><a class="header" href="#format-specific-rules">Format-specific rules</a></h1>
<h2 id="text-files"><a class="header" href="#text-files">Text files</a></h2>
<p>Unless otherwise specified, all text files should be encoded as UTF-8 with <a href="http://en.wikipedia.org/wiki/Byte_order_mark">BOM</a> enabled.</p>
<p>Any use of encoding which may not be converted verbatim and losslessly in binary form to UTF-8 shall be explicit specified in documantation.</p>
<p>Any UTF BOMs shall not exist in a derived text format with normative specification which excludes the BOM explicitly.</p>
<ul>
<li><strong>Rationale</strong> The specification such text format may assume the contents are all the payload in a known UTF encoding.</li>
</ul>
<p>BOM should be omitted for text files dedicated to tools without capability of properly handling it. Otherwise, BOM shall be used as possible when it can clarify the encoding being used.</p>
<p>Unless definitely intended and explictly specified in documentation, newlines shall be consistent. Default use of newline is <a href="http://en.wikipedia.org/wiki/CRLF">CR+LF</a>.</p>
<p>Two subsequent newlines indicate an <a href="http://en.wikipedia.org/wiki/End-of-file">EOF</a> logically. Subsequent newlines out of verbatim quoted text (including source code) should only be used at EOF.</p>
<p>There are also some default rules on typography implemented by ordinary characters in plain texts:</p>
<ul>
<li>No <a href="http://en.wikipedia.org/wiki/Space_characters#Spaces_in_Unicode">space characters</a> should be at <a href="http://en.wikipedia.org/wiki/End-of-line">EOL</a>.</li>
<li>For text other than verbatim quoted, no more than one <a href="https://en.wikipedia.org/wiki/Whitespace_character">whitespace characters</a> should be used to represent a single indent, except there are preferred combination in the language.
<ul>
<li><strong>Rationale</strong> By default, no more than one whitespaces should be used to represent an indent, because there should be no chance to insert a character in the middle of an indent.</li>
<li><strong>NOTE</strong> An example of preferred exceptional case is that the hanging indent (in the first line of a paragraph) in east Asian languages where dedicated combination of <a href="https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms">fullwidth</a> whitespaces are preferred. Typically, the sequence consists of 2 <a href="https://en.wikipedia.org/wiki/Whitespace_character#Unicode">ideographic space (U+3000)</a>.</li>
<li><strong>NOTE</strong> To keep the semantics rules clear, when possible (in horizontal texts and out of the context of making tables) and no other forms are more preferred by the rules of the language, use <a href="http://en.wikipedia.org/wiki/Tab_key#Tab_characters">horizontal tab character(U+0009)</a> instead of <a href="http://en.wikipedia.org/wiki/Space_%28punctuation%29">other spaces (i.e. U+0020)</a> to indent.</li>
</ul>
</li>
<li>For Western languages, except at the first of line, each word which consists of <a href="http://en.wikipedia.org/wiki/Alphanumeric">alphanumeric</a> characters should be seperated by a single space character (U+0020) with other words.</li>
<li>Space characters (U+0020) should be used for alignment when portability is required.
<ul>
<li><strong>Rationale</strong> This makes the visal effect easy to predicate in the usual settings with monospaced fonts in contexts like source code of programs.</li>
<li><strong>NOTE</strong> Other spaces like <a href="https://en.wikipedia.org/wiki/Non-breaking_space">non-breaking space (U+00A0)</a> may be better in specific uses, but not portable as U+0020.</li>
</ul>
</li>
</ul>
<h2 id="markdown"><a class="header" href="#markdown"><a href="http://en.wikipedia.org/wiki/Markdown">Markdown</a></a></h2>
<p>Names of markdown files should be with <code>.md</code> extension.</p>
<p><strong>NOTE</strong> Several rules here can be enforced by <a href="https://github.com/DavidAnson/markdownlint">markdownlint</a> tools like <a href="https://github.com/DavidAnson/markdownlint-cli2">markdownlint-cli2</a>. A compatible configuration file is included in this project.</p>
<p><strong>NOTE</strong> Markdown files derive text files. The rule of <a href="WikiRules.en-US.html#text-files">subsequent newlines</a> is covered by a modified setting of <a href="https://github.com/DavidAnson/markdownlint/blob/v0.32.1/doc/md009.md">markdownlint rule MD009</a> with "strict" mode.</p>
<h3 id="dialects"><a class="header" href="#dialects">Dialects</a></h3>
<p>Unless explicitly specified elsewhere, only common dialects are to be used. Currently this should be <a href="https://help.github.com/articles/github-flavored-markdown">GFM (GitHub Flavored Markdown)</a>.</p>
<p><strong>NOTE</strong> This is not <a href="https://docs.gitlab.com/ee/user/markdown.html">GLFM (GitLab Flavored Markdown)</a>, which also abbreviated as GFM formerly.</p>
<p>And if the content may be presented on <a href="https://bitbucket.org">Bitbucket</a> wiki, stricter rules applies, notably:</p>
<ul>
<li>There is currently <a href="https://jira.atlassian.com/browse/BCLOUD-6930">no inline HTML support</a>.</li>
<li>There is currently <a href="https://jira.atlassian.com/browse/BCLOUD-8276">no anchor support</a>.</li>
</ul>
<p><strong>NOTE</strong> This repository is not intended deployed in Bitbucket wiki now. The stricter rules on Bitbucket wiki above are not applicable here.</p>
<h3 id="syntactic-restrictions"><a class="header" href="#syntactic-restrictions">Syntactic restrictions</a></h3>
<p>As text files, markdown files shall obey the same rules above. The indentation rule is necessary to avoid some compatibility issues, e.g. <a href="https://bitbucket.org/site/master/issue/7748/markdown-nested-lists-not-working-bb-8925">this</a>.</p>
<p>As specified, reserved characters defined by RFC 3986 should be percentage-encoded. Notably, the parentheses(<code>()</code>) in hyperlinks shall be encoded to make it more fault-tolerent for some editors.</p>
<p>Headers should be prefixed by <code>#</code>s.</p>
<p>There should be no redundant characters allowed between the annotated words and annotation (esp. whitespace characters), even there are whitespaces in the words. The annotation in this rule includes any language tag annotation defined in previous subclause.</p>
<p><strong>Rational</strong> This is for the sake of compact annotation representations, as well as to ease the transition from plain texts to structured ones (e.g., to get align with the Markdown links without redundant whitespaces between <code>[]</code> and <code>()</code>).</p>
<p><strong>NOTE</strong> The whitespace rules in the language annotation is also applicable. Instead, it is also allowed to use word combination (instead of the annotation) when gramatically correct, so this rule does not apply.</p>
<h3 id="code-block-names"><a class="header" href="#code-block-names">Code block names</a></h3>
<p>Laugnage names are required on the code blocks.</p>
<p><strong>NOTE</strong> This is covered by <a href="https://github.com/DavidAnson/markdownlint/blob/v0.32.1/doc/md040.md">markdownlint rule MD040</a>.</p>
<p>The following requirements are hold on the names:</p>
<ul>
<li>Use the langauge names in a well-known style, unless explicitly noted here.
<ul>
<li>Currently, this is specified in the <a href="https://github.com/highlightjs/highlight.js/blob/main/SUPPORTED_LANGUAGES.md">list of supported languages of hightlight.js</a>.</li>
<li>For all other cases (including program output), use <code>text</code>.</li>
<li><strong>Rationale</strong> Proper language identifiers make syntactic highlight and other cosumers of Markdown work appropriately.</li>
<li>As an exception, custom names can be used only when it is either explicitly defined or mentioned unambiguously in the document contents.
<ul>
<li><strong>Rationale</strong> This is only for human readers of the Markdown source. Otherwise it should be like <code>text</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Use the most proper language names actually reflect the contents of the code with maximum portability in the intended use cases, even they are equivalent in some implementaions of the consumer of the Markdown code.
<ul>
<li>Use <code>shell</code> when the code is conforming to <a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html">POSIX shell language</a>.
<ul>
<li><strong>NOTE</strong> For instance, <code>shell</code> is preferred than <code>bash</code> even if the command is to call a script only compatible to <a href="https://www.gnu.org/software/bash/manual/">GNU Bash</a>.</li>
<li><strong>Rationale</strong> The source language shall be respected. It is irrelavant to how the contents are handled in the actually execution (e.g. specifying a different language by <a href="https://en.wikipedia.org/wiki/Shebang">Shebang</a>).</li>
</ul>
</li>
<li>Use <code>console</code> when the code is conforming to both of shell and DOS/Windows batch scripts.</li>
<li>Use <code>dos</code>/<code>bat</code>/<code>cmd</code> contextually. The differences of batch commands in interactive script environment and in files shall be respected.</li>
<li><strong>Rationale</strong> These rules make it clear to the human readers of the Markdown source by clear intent.</li>
</ul>
</li>
</ul>
<h1 id="cross-references"><a class="header" href="#cross-references">Cross references</a></h1>
<p>This document is used by the YSLib project. It may be also referenced by other repositories.</p>
<p><strong>Except for the following list, do not edit unless ultimately necessary.</strong></p>
<p>Known referenced by:</p>
<ul>
<li><a href="https://github.com/FrankHB/pl-docs">Programming Language Documentations</a> by <a href="https://github.com/FrankHB">FrankHB</a></li>
</ul>
<h1 id="annex-informative"><a class="header" href="#annex-informative">Annex (Informative)</a></h1>
<h2 id="alternaive-imcompatible-rules"><a class="header" href="#alternaive-imcompatible-rules">Alternaive imcompatible rules</a></h2>
<p>Usually there the rules of documentation here are compatible to other rules in various specifications. However, some of the well-known rules are considered overspecified (albeit not rigouous) and with insufficient quality in specification. Thus, these rules are <em>deliberately</em> kept incompatible, and never accepted here:</p>
<ul>
<li>The specification may be too vague by missing separating the comformance rules and the suggestions, so it is difficult to manually verify the conformance just by the specification text.
<ul>
<li>Some confusions may be from the lack of rules on the modal verbs.</li>
<li>Some rules may be underspecified for external resources. For example, the claim of "be a valid Markdown file" is unclear without further notes, because there is no unique standard to determine the definition of "valid", since there are multiple dialects of the Markdown language and no flavor is definitely more representative than others.</li>
</ul>
</li>
<li>The rules of mandated letter cases (in particular, capitalization) may be too restrictive.
<ul>
<li>This may be generally too subjective. It can be good to sticking to a well-name for to ease for use cases for technical merits (like for machine verication), but the fixed spelling on cases may be overspecified.
<ul>
<li>The exception is when the name is standardized and machine-oriented by default.</li>
<li>As a notable instance, <a href="https://www.rfc-editor.org/rfc/rfc5646.html">RFC 5646</a> recommends but does not mandate the capitalization for the codes from <a href="https://en.wikipedia.org/wiki/ISO_639-1">ISO 639-1</a> and <a href="https://en.wikipedia.org/wiki/ISO_3166-1">ISO 3166-1</a>, while the preferred capitalization diverges in the 2 standards.</li>
</ul>
</li>
<li>On the other hand, mandotory like "README" instead of "Readme" is too restrictve. It will be problatic to be transferred between case-insensitive enviornments and case-sensitive environments (e.g. names in filesystems), where one environment may allow entries of <code>README</code> and <code>Readme</code> coexisting but another may not.
<ul>
<li>When techically feasible to having different cases coexisting, "README" and "Readme" are symmentric, i.e. no one is definitely more preferred than the other for machines. It is then not intuitive to reason why "README" must be preferred to "Readme" instead of the exact opposite in the specification, in particular with the fact that such entry is mainly created for human readers but not machines.</li>
<li>Instead, keeping one overridable as well as a recommended default form (which does not necessarily to be all capitalized) of spelling is better for both portability and other needs.</li>
<li>Further, names like "README.md" are less consistent to "README.MD". The latter is at least required in some ancient systems not support the small case, hence even more preferred for portability (in extreme cases).</li>
</ul>
</li>
</ul>
</li>
<li>Prioritizing non-regional subtags for languages should not be recommended normally, because this is less accurate, and the confusion may even be offensive to specific culture, since there can be lack of consensus that one subtag can override another without changing the meaning of the text (which is not the case of the relationship between tags and subtags).</li>
<li>Validation of hyperlinks should be acknowledged not always possible when the linked resource is out of the control (i.e. external) in a document.
<ul>
<li>Anyway, there is no persistency guarantee for most hyperlinks in the Web.</li>
<li>Mandating the state of the referenced resource of hyperlinks unconditionally will make any verification result one-time, because the exteranl links may be broken immediately after the verification. Then the conformance is non-deterministic.</li>
<li>Such mandatory is applicable only for hyperlinks provable to be persistent. But this is infeasible with automatic methods at least for external links on the Web, because the test of persistency may be unreliable until the link is broken.</li>
<li>So, unless external links are not allowed (which seems an overkill), rules having impractical assumptions of the validation process should be in the specification.</li>
</ul>
</li>
</ul>
<p>An example of most bullets above can be found in the <a href="https://github.com/RichardLitt/standard-readme/blob/master/spec.md">specification</a> of <a href="https://github.com/RichardLitt/standard-readme">standard-readme</a>.</p>
<h2 id="notes-on-the-overall-writing-style"><a class="header" href="#notes-on-the-overall-writing-style">Notes on the overall writing style</a></h2>
<p>This subclause is used for informative supplement (guidelines and rationales) on the writing style used across the materials in the repository. The "adoptions" in the text below shall be interpreted as suggestions, but not mandotory rules.</p>
<p>There can be some stylish emphasize on the use of the language for personality, say, <a href="http://xahlee.org/wordy/musing/xah_style.html">this</a>. However, a line of the boundary to prevent overly stylish should be drawn. That is, it should be generally grammatical <em>without drafting a new dialect not well-known enough</em>. Dialects not well-known enough have troubles being adoption, and they carry (and increase) confusions. Even without the adoption problems, consider dialects as specifications, or standards, the divergence would not be eliminated without extraordinary efforts, see also <a href="https://xkcd.com/927/">xkcd 927</a>. Hence, for a context out of <a href="https://en.wikipedia.org/wiki/Constructed_language">conlang</a>, avoid it.</p>
<p>There are actually many rules shared with the link above in the writing here, tailored by the rule. Analyze them one by one and then categorize, with the reasons attached:</p>
<ul>
<li>Rejected:
<ul>
<li>Article “an” vs “a”
<ul>
<li>This is rejected because it has ungrammatical, and it has significant damange on the experience for readers on smoothness about phonetics.</li>
</ul>
</li>
<li>Pronoun “I” vs “i”
<ul>
<li>Rejected for ungrammatical issue. There are no enough benefits to take ad-hoc rules over and over.</li>
</ul>
</li>
<li>Saxon Genitive: “James's car” vs “James' car”
<ul>
<li>Ditto.</li>
</ul>
</li>
<li>Symbol Used for the Quotation Mark
<ul>
<li>Straight quotes should be used for English, or there are no place to use.</li>
<li>Curly double quotes are in the orthography in some languages, but not in English.</li>
</ul>
</li>
<li>Quoting Computer Code
<ul>
<li>Non-idomatic to use <code>「</code> and <code>」</code> in English. Even more non-idomatic to use them for quotation of the code.</li>
<li>Non-idomatic to use <code>〔</code> and <code>〕</code> in English. Even more non-idomatic to use them for paths.</li>
<li>There are more conventional semantic styles for those quotation, e.g. Markdown ``` quotes. The styles can be also customized by the style sheets.</li>
</ul>
</li>
<li>Period in Person's Names
<ul>
<li>Non-idomatic <a href="https://en.wikipedia.org/wiki/Full_stop#Initials">in majority</a>.</li>
<li>Though uncommon, there is an ambiguity to the shortened form with a name having only one letter without the period.</li>
<li>There are no rationals. If the ambighity between the last punctuation of a sentence with this use is a matter, why limit it to "person's names"? E.g., "e.g. " with "." (and a space character after the 2nd ".") is actually used by the text. This is not logical at all.</li>
</ul>
</li>
<li>Citation Format
<ul>
<li>The requirements on the precise format is intentionally omit here globally, to allow better interoperbility to the contexts.</li>
<li>Adaption to the target context is important than stiking on a concrete known format. However, being internally consistency is also important. These two points should stay together in peace.</li>
<li>For multiple targets, more than one format for the same content can coexist. Notice that a machine readable format can be more efficient for specific uses, but not that readable for humans. So there often can be a mixture.</li>
<li>Afterall, too many aspects can be customized here.</li>
</ul>
</li>
</ul>
</li>
<li>Weakly rejected:
<ul>
<li>Use Logical Spelling Variant
<ul>
<li>It is somewhat subjective to identify what is "logical" enough.</li>
<li>Alghough some are occasionally the same (e.g. "color" instead of "colour"), this is nothing to do with "logical". Just apply the rule of "en-US is preferrend to other English dialects" by default.</li>
</ul>
</li>
<li>No “and” for Last Item in Sequence
<ul>
<li>Althoug abuse of conjunctions can be a problem, it usually should not happen without some delibarte effots.</li>
<li>By not eliminating the "too odd" exceptional cases, this rule is less beneficial.</li>
<li>Simply keeping "and" is still the simplest.</li>
<li>“My favorite fruits are: {peach, banana, cherry}” is not that logical. Reduce it with some substituion, it has the form "My favorite fruits are: <em>a set of fruits</em>", which looks not grammatical due to the non-canonical use of verb "are". A more grammatical form should have "are <em>in</em>" instead of a plain "are" here.</li>
</ul>
</li>
<li>No “respectively” in Parallel Sequences
<ul>
<li>Good to prevent redundancy, but when used, the emphasize is not redundant.</li>
<li>“{peach, banana, cherry}, colored {pink, yellow, red}” is confusing due to the possibly ambiguity in the composition of multiple set notations (curly brace pairs), given that it is not an idiomatic way of expression in natural languages.
<ul>
<li>Why does this mean a parallel sequence instead of a Cartesian product?</li>
<li>It is perfectly "grammatical" to the nature of the extended syntax of "{}".</li>
<li>The phrase "colored {pink, yellow, red}" can be reviewed as a result from the predictor "colored" being applied by the set {pink, yellow, red}.</li>
<li>Before the semantic analysis on the precise meaning of this sentence (to render {peach, banana, cherry} × colored {pink, yellow, red}) nonsense, no notational sensitivity can be induced.</li>
<li>Instead, a "respectively" clearly rules the ambiguity out by syntax.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Weakly adopted (contextually):
<ul>
<li>Short Sentence Length
<ul>
<li>This is mildly adopted, but not always good in reality, because it is often more difficult to split the words correctly and precisely without redundancy using short sentences.</li>
<li>Basically it should be forgotten, and when there are sentences looking unconfortably lengthy, revive and champion this as a rule.</li>
</ul>
</li>
<li>Avoid Idioms in Tech Writing
<ul>
<li>Good in general.</li>
<li>But it incurs a mental cost to identify the idioms to pick up some alternatives intentioanlly. This is actually acknoledged as "it's very time consuming".</li>
<li>Also it can lead to words not in the basic English without very careful treatment of the validity of the alternatives (so clashing with "Diction" section). To distinguish whether a particular word in the vocabulary of basic English is difficult for non-specialists of English education.</li>
</ul>
</li>
<li>No Right Justification
<ul>
<li>There should be the exceptional cases for typographic uses, esp. per sentence alignment like <a href="http://www.opimedia.be/DS/languages/tabs-vs-spaces/">this</a>.</li>
<li>Otherwise, what on earth is that?</li>
</ul>
</li>
<li>Use Metric System
<ul>
<li>Sometimes idiomatic. However, Instead of "USD$1M", use "USD 1M" instead, to avoid the "dollar" redundancy between "D" in "USD" and the dollar sign ("$"). Then the reason is not strong enough there: it is not idiomatic to use the idiomatic <em>prefix</em> "M" actually as a suffix. The common use of abbreviations like "MB" to "M" is informal, and the omission of other basic units is non-idiomatic.</li>
<li>Distinguishing of "k" and "ki" is good. Likewise "M" and "Mi".</li>
</ul>
</li>
<li>Person's Name, Title
<ul>
<li>Order of First Name, Last Name
<ul>
<li>Alphabaticlal order can be the default convention, but not the only.</li>
</ul>
</li>
<li>No Honorary Title
<ul>
<li>It is plausible to prefer name to title for accuracy.</li>
<li>Degrees from different majors and different places. There may be confusions. "PhD" is lilely certainly not about "philosophy", but what if "philosophy" is exactly needed?</li>
<li>An exception is to make confusion intionally. That is, <a href="https://en.wikipedia.org/wiki/Pun">word punning</a>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Adopted (without exceptional cases):
<ul>
<li>Omitting Articles: {a, the}
<ul>
<li>This is adopted for non-mandotory.</li>
</ul>
</li>
<li>Diction
<ul>
<li>Good for clarity.</li>
</ul>
</li>
<li>Hyphen, Dash
<ul>
<li>Ditto.</li>
</ul>
</li>
<li>Apostrophe
<ul>
<li>Grammatical. Orthographic.</li>
</ul>
</li>
<li>Punctuation in List Items
<ul>
<li>Conventional.</li>
<li>The only exception is the phrase itself: "<a href="https://en.wikipedia.org/wiki/Full_stop">full stop</a>" may have a preferred form "period" in en-US, although <a href="https://en.wikipedia.org/wiki/Full_stop#Medieval_Latin_and_modern_English_period">there is not a big difference nowadays (also see below)</a>. This does not change the status of adoption, though.</li>
</ul>
</li>
<li>Sentences Should Always End in a Period
<ul>
<li>Idiomatic.</li>
<li>The titile is problematic to include exclamation mark or question mark as "period", as period is just the period symbol in normal uses. The detailed text is correct, though.</li>
<li>The exceptional cases like "e.g." and "i.e." are explained as "haven't fully though out" here, but actually, they should not be the problem, becuase a period is not necessarily the end of a sentence. The ancient use which differentiate "full stop" and "period" use the former for the case, but nowadays it is conventional <a href="https://en.wikipedia.org/wiki/Full_stop#Medieval_Latin_and_modern_English_period">to treat them the same</a>.</li>
</ul>
</li>
</ul>
</li>
<li>Strongly adopted (with even more and stricter rules):
<ul>
<li>Active vs Passive Voice
<ul>
<li>Passive voice is almost always preferred (for technical writings).</li>
<li>Almost no subjects denoting readers are even used.</li>
<li>Cold, inhuman and <em>precise</em> statements are preferred, except when the opposite are the objects being discussed (e.g. <em>metophors</em>, for GUI).</li>
<li>The first-person subject pronouns ("I" and "we") are also rarely used. (This also largely prevents the concern of “I” vs “i” mentioned above.)</li>
<li>Moreover, this also covers the instance of commit messages.</li>
</ul>
</li>
<li>Do Not Spell Out Numbers
<ul>
<li>This is also adopted. Moreover, numbers are treated the same if it is at the beginning at the sentence. More and moreover, ordinal numbers are also enforced besides cardinal numbers, for cases just need number (e.g. "1st" is preferred over "first" with exceptional cases when used as an adverb or in phrases like "at first").</li>
</ul>
</li>
<li>Date format
<ul>
<li>Idomatic.</li>
<li>This prevents the ambiguity between "dd-mm-yyyy" and "mm-dd-yyyy" in particular.</li>
<li>Moreover, in some contexts, more detailed ISO 8601 forms are required (e.g. with time zone information).</li>
</ul>
</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
