<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The YSLib Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="Book tranplanted from YSLib BitBucket wiki.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Home.html"><strong aria-hidden="true">1.</strong> 索引/Index</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Home.en-US.html"><strong aria-hidden="true">1.1.</strong> English Version</a></li><li class="chapter-item expanded "><a href="Home.zh-CN.html"><strong aria-hidden="true">1.2.</strong> 简体中文版</a></li><li class="chapter-item expanded "><a href="Contents.zh-CN.html"><strong aria-hidden="true">1.3.</strong> Contents(zh-CN)/主题目录</a></li></ol></li><li class="chapter-item expanded "><a href="GettingStarted.zh-CN.html"><strong aria-hidden="true">2.</strong> 入门</a></li><li class="chapter-item expanded "><a href="Development.zh-CN.html"><strong aria-hidden="true">3.</strong> 开发说明</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Prerequisitions.zh-CN.html"><strong aria-hidden="true">3.1.</strong> 先决条件</a></li><li class="chapter-item expanded "><a href="GettingSources.zh-CN.html"><strong aria-hidden="true">3.2.</strong> 获取源代码</a></li><li class="chapter-item expanded "><a href="Build.zh-CN.html"><strong aria-hidden="true">3.3.</strong> 构建</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="BuildDocumentation.zh-CN.html"><strong aria-hidden="true">3.3.1.</strong> 构建文档</a></li></ol></li><li class="chapter-item expanded "><a href="Test.zh-CN.html"><strong aria-hidden="true">3.4.</strong> 测试</a></li><li class="chapter-item expanded "><a href="Run.zh-CN.html"><strong aria-hidden="true">3.5.</strong> 运行</a></li></ol></li><li class="chapter-item expanded "><a href="Features.zh-CN.html"><strong aria-hidden="true">4.</strong> 结构和特性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ProjectDependencies.zh-CN.html"><strong aria-hidden="true">4.1.</strong> （内部）项目依赖性说明</a></li><li class="chapter-item expanded "><a href="Features/NPL.zh-CN.html"><strong aria-hidden="true">4.2.</strong> NPL</a></li></ol></li><li class="chapter-item expanded "><a href="EMPTY.html"><strong aria-hidden="true">5.</strong> 应用开发环境</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Sysroot.zh-CN.html"><strong aria-hidden="true">5.1.</strong> Sysroot</a></li><li class="chapter-item expanded "><a href="YDE.zh-CN.html"><strong aria-hidden="true">5.2.</strong> YDE</a></li></ol></li><li class="chapter-item expanded "><a href="EMPTY.html"><strong aria-hidden="true">6.</strong> 项目维护资源</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Releases.zh-CN.html"><strong aria-hidden="true">6.1.</strong> 发布工程</a></li><li class="chapter-item expanded "><a href="Archives.zh-CN.html"><strong aria-hidden="true">6.2.</strong> 归档</a></li></ol></li><li class="chapter-item expanded "><a href="EMPTY.html"><strong aria-hidden="true">7.</strong> 工具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Tools/SHBuild.zh-CN.html"><strong aria-hidden="true">7.1.</strong> SHBuild</a></li><li class="chapter-item expanded "><a href="Tools/RevisionPatcher.zh-CN.html"><strong aria-hidden="true">7.2.</strong> RevisionPatcher</a></li><li class="chapter-item expanded "><a href="Tools/SXML2XML.zh-CN.html"><strong aria-hidden="true">7.3.</strong> SXML2XML</a></li><li class="chapter-item expanded "><a href="Tools/ProjectGenerator.zh-CN.html"><strong aria-hidden="true">7.4.</strong> ProjectGenerator</a></li><li class="chapter-item expanded "><a href="Tools/Scripts.zh-CN.html"><strong aria-hidden="true">7.5.</strong> 脚本</a></li></ol></li><li class="chapter-item expanded "><a href="Tutorial.zh-CN.html"><strong aria-hidden="true">8.</strong> 教程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Tutorial/Overview.zh-CN.html"><strong aria-hidden="true">8.1.</strong> 综述</a></li><li class="chapter-item expanded "><a href="Tutorial/GUI.zh-CN.html"><strong aria-hidden="true">8.2.</strong> GUI</a></li><li class="chapter-item expanded "><a href="Tutorial/Configuration.zh-CN.html"><strong aria-hidden="true">8.3.</strong> 程序配置</a></li></ol></li><li class="chapter-item expanded "><a href="EMPTY.html"><strong aria-hidden="true">9.</strong> 附录/Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Terminology.zh-CN.html"><strong aria-hidden="true">9.1.</strong> 术语概要</a></li><li class="chapter-item expanded "><a href="StandardUsing.en-US.html"><strong aria-hidden="true">9.2.</strong> Standard Using</a></li><li class="chapter-item expanded "><a href="ReportedIssues.en-US.html"><strong aria-hidden="true">9.3.</strong> Reported Issues</a></li><li class="chapter-item expanded "><a href="WikiRules.en-US.html"><strong aria-hidden="true">9.4.</strong> Wiki Rules</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The YSLib Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="english-version"><a class="header" href="#english-version"><a href="Home.en-US.html">English Version</a></a></h1>
<h1 id="简体中文版"><a class="header" href="#简体中文版"><a href="Home.zh-CN.html">简体中文版</a></a></h1>
<h1 id="contentszh-cn主题目录"><a class="header" href="#contentszh-cn主题目录"><a href="Contents.zh-CN.html">Contents(zh-CN)/主题目录</a></a></h1>
<h1 id="copyright-of-this-wiki"><a class="header" href="#copyright-of-this-wiki">Copyright of this wiki</a></h1>
<p>© 2013-2020 <a href="mailto:frankhb1989@gmail.com">FrankHB</a> and wiki editors.</p>
<p>Except where otherwise specified explicitly, materials in this repository are licensed under following terms:</p>
<p><a href="http://creativecommons.org/licenses/by-sa/4.0/"><img src="http://i.creativecommons.org/l/by-sa/4.0/88x31.png" alt="http://creativecommons.org/licenses/by-sa/4.0/" title="license" /></a></p>
<p>This work is licensed under a <a href="http://creativecommons.org/licenses/by-sa/4.0/" title="CC-BY-SA 4.0">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="about"><a class="header" href="#about">About</a></h1>
<p>The YSLib Project is a project of platform-neutral framework consists of several multi-licensed open source libraries. It is aiming to develop native applications in a naturally cross-platform manner.</p>
<p>See LICENSE.TXT in the source directory for licensing affairs.</p>
<p>The main part (except libraries not being maintained in this project) of the libraries is coded in C++, which is strictly conforming to ISO/IEC 14882. (For features being used, see <a href="StandardUsing.en-US.html">here</a>. For some issues concerned with this project, see <a href="ReportedIssues.en-US.html">here</a>.)</p>
<p>The project is currently in <a href="Releases.zh-CN.html">Alpha state(zh-CN)</a> with following interface compatibility strategies:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a> compatibility for any revision depending on specific platform, toolchain or build configuration is never guaranteed.</li>
<li>ABI compatibility may not be retained between releases with same platform, toolchain and build configuration.</li>
<li><a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> of libraries may be modified locally and there is no guarantee for compatibility between releases.</li>
<li><a href="https://en.wikipedia.org/wiki/User_interface">UI</a> of tools (see <a href="Contents.zh-CN.html">contents(zh-CN)</a> for the list) may be modified progressively across builds; unless specified elsewhere, added features are kept being <a href="https://en.wikipedia.org/wiki/Backward_compatibility">backward compatible</a> within at least one next releases.</li>
</ul>
<p>See <a href="GettingStarted.zh-CN.html">here(zh-CN)</a> for basic steps to use YSLib in development.</p>
<p>See <a href="Releases.zh-CN.html">here(zh-CN)</a> for releases and plans.</p>
<h2 id="currently-supported-platforms"><a class="header" href="#currently-supported-platforms">Currently supported platforms</a></h2>
<ul>
<li>(<a href="https://en.wikipedia.org/wiki/Nintendo">Nintendo</a>/<a href="https://en.wikipedia.org/wiki/IQue">iQue</a>) <a href="https://en.wikipedia.org/wiki/Nintendo_DS_line#Nintendo_DS_family">DS</a> (arm-none-eabi)
<ul>
<li>using <a href="DeSmuME.en-US.html">DeSmuME</a> to run on PC</li>
</ul>
</li>
<li>MinGW32 (i686-w64-mingw32, compatible with i686-pc-mingw32)</li>
</ul>
<h2 id="pending-supported-platform"><a class="header" href="#pending-supported-platform">Pending supported platform</a></h2>
<ul>
<li>Android (arm-linux-androideabi)</li>
<li>MinGW64 (x86_64-w64-mingw32)</li>
<li>Linux32 (i686-linux-gnu)</li>
<li>Linux64 (x86_64-linux-gnu)</li>
</ul>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<h3 id="documentation-in-the-yslib-project"><a class="header" href="#documentation-in-the-yslib-project">Documentation in the YSLib project</a></h3>
<p>Documentation in the YSLib project consist of several parts:</p>
<ul>
<li>The development documentation which is intended for the project maintainers, see <a href="Development.zh-CN.html">development(zh-CN)</a>.
<ul>
<li>The document in <code>doc/vsd</code> can be viewed by Microsoft Office Visio or Microsoft Visual Studio 2013.</li>
</ul>
</li>
<li>Souce code documentation, which can be generated using Doxygen, see <a href="BuildDocumentation.zh-CN.html">building documentation(zh-CN)</a>.
<ul>
<li>Currently the Doxygen commands in the source code are mainly coded in simplified Chinese. It is planned to utilize Doxygen's <code>~[LanguageId]</code> command to generate multilingual documents in future. All other comments, however, should be in English by default.</li>
</ul>
</li>
<li>Other non-generated documents are text files in the repository, like <code>Readme.zh-CN.txt</code>.</li>
</ul>
<h3 id="about-this-wiki"><a class="header" href="#about-this-wiki">About this wiki</a></h3>
<p>This wiki is a project related to the YSLib project. They are currently the only two members in the same project group, each has separated repository. Common documentation for the project group, general user documentation and list of significant features for the YSLib project are dominated by this wiki. Documentation in the YSLib project is mainly for maintainers of the project. They are bidirectionally referenced, namely the content of this wiki may be refenenced in the YSLib project and vice versa.</p>
<p>Unless otherwise specified, the content of this wiki is fit for the current last master branch revision (i.e. the revision <code>tip</code> of <code>master</code> branch in the repository).</p>
<p>See <a href="WikiRules.en-US.html">here</a> for rules to edit this wiki.</p>
<p>It is intended to reference every pages of this wiki in this page.</p>
<h1 id="contributions"><a class="header" href="#contributions">Contributions</a></h1>
<p>Contributions to the projects are welcomed. Provided materials thereby shall be adjusted by contributors (and the project maintainer) to conform the license of the corresponding projects if necessary.</p>
<p><strong>Rules in this wiki are treated as consensus.</strong> Rules in project documentation have effect on maintainers but not other contributors. However, the contents in the projects shall always be conforming to the project rules.</p>
<p>To feedback or report issues, use <a href="https://bitbucket.org/FrankHB/yslib/issues/">Bitbucket issue tracker</a>, or contact the project maintainer as noted below.</p>
<h2 id="rules-for-project-contents"><a class="header" href="#rules-for-project-contents">Rules for project contents</a></h2>
<p>The following philosophy are generally accommodated throughout the projects.</p>
<ul>
<li>
<p><strong>Do not <a href="https://en.wikipedia.org/wiki/Reinventing_the_wheel">reinvent the wheel</a>.</strong> Projects here only accepts modular components which would be better elsewhere. Here &quot;better&quot; is defined as &quot;superior than current solution in at least one aspect for consensually known need&quot;.</p>
<ul>
<li>See the notes in <a href="Features.zh-CN.html">features(zh-CN)</a> for the list of invented wheels and the rationale.</li>
</ul>
</li>
<li>
<p><strong>Decline premature optimization.</strong> However, what is &quot;premature&quot; is determined by the need, which would be probably variable.</p>
</li>
</ul>
<h1 id="contacts"><a class="header" href="#contacts">Contacts</a></h1>
<ul>
<li>Mail to: <a href="mailto:frankhb1989@gmail.com">frankhb1989@gmail.com</a></li>
<li>Post <a href="http://tieba.baidu.com/f?kw=%BB%C3%A4%CE%C9%CF%B5%DB">here</a> (mainly zh-CN)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概要"><a class="header" href="#概要">概要</a></h1>
<p>　　YSLib 项目是一个提供多个开源库组成的平台中立框架的项目，主要致力于以自然的方式开发跨平台本机应用。</p>
<p>　　使用的许可证见源代码目录中的 LICENSE.TXT 。</p>
<p>　　主要部分（非此项目维护的库除外）使用 C++ 编码，严格符合 ISO/IEC 14882 。（使用的 ISO 特性参见<a href="StandardUsing.en-US.html">这里(en-US)</a> 。和本项目相关的被报告的问题见<a href="ReportedIssues.en-US.html">这里(en-US)</a> 。）</p>
<p>　　项目当前为 <a href="Releases.zh-CN.html">Alpha 状态</a>，具有以下接口兼容性策略：</p>
<ul>
<li>任意版本不保证依赖特定平台、工具链或构建配置的 <a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a> 兼容性。</li>
<li>同一平台、工具链和构建配置的发布版本之间的 ABI 可能不兼容。</li>
<li>库的 <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> 设计在局部调整而不保证在发布版本之间兼容。</li>
<li>工具（列表参见<a href="Contents.zh-CN.html">目录</a>）的 <a href="https://en.wikipedia.org/wiki/User_interface">UI</a> 可能会在构建中渐进修改；除非另行指定，添加的特性在之后的至少一个发布版本中保持<a href="https://en.wikipedia.org/wiki/Backward_compatibility">向后兼容</a>。</li>
</ul>
<p>　　关于使用 YSLib 开发的基本步骤，参见<a href="GettingStarted.zh-CN.html">入门</a>。</p>
<p>　　目前已发布版本、进展和计划看<a href="Releases.zh-CN.html">这里</a>。</p>
<h2 id="当前支持平台"><a class="header" href="#当前支持平台">当前支持平台</a></h2>
<ul>
<li>(<a href="https://zh.wikipedia.org/zh-cn/%E4%BB%BB%E5%A4%A9%E5%A0%82">Nintendo</a>/<a href="https://zh.wikipedia.org/zh-cn/%E7%A5%9E%E6%B8%B8%E7%A7%91%E6%8A%80">iQue</a>) <a href="https://zh.wikipedia.org/zh-cn/%E4%BB%BB%E5%A4%A9%E5%A0%82DS%E5%AE%B6%E6%97%8F#.E4.BB.BB.E5.A4.A9.E5.A0.82DS.E5.AE.B6.E6.97.8F">DS</a> (arm-none-eabi)
<ul>
<li>在 PC 上使用<a href="DeSmuME.en-US.html">DeSmuME(en-US)</a> 运行</li>
</ul>
</li>
<li>MinGW32 (i686-w64-mingw32, compatible with i686-pc-mingw32)</li>
</ul>
<h2 id="待定支持平台"><a class="header" href="#待定支持平台">待定支持平台</a></h2>
<ul>
<li>Android (arm-linux-androideabi)</li>
<li>MinGW64 (x86_64-w64-mingw32)</li>
<li>Linux32 (i686-linux-gnu)</li>
<li>Linux64 (x86_64-linux-gnu)</li>
</ul>
<h2 id="文档"><a class="header" href="#文档">文档</a></h2>
<h3 id="yslib-项目中的文档"><a class="header" href="#yslib-项目中的文档">YSLib 项目中的文档</a></h3>
<p>　　YSLib 项目中的文档主要包括以下几个部分：</p>
<ul>
<li>主要供项目维护者参考的开发文档，详见<a href="Development.zh-CN.html">开发说明</a>。
<ul>
<li>目录 <code>doc/vsd</code> 下的文档可使用 Microsoft Office Visio 或 Microsoft Visual Studio 2013 查看。</li>
</ul>
</li>
<li>源代码文档，可使用 Doxygen 生成，参见<a href="BuildDocumentation.zh-CN.html">构建文档</a>。
<ul>
<li>当前源代码中的 Doxygen 命令主要编码为简体中文。未来计划使用 Doxygen 的 <code>~[LanguageId]</code> 命令生成多种语言的文档。其它注释主要使用英文。</li>
</ul>
</li>
<li>其它非生成的文本文件，如 <code>Readme.zh-CN.txt</code> 。</li>
</ul>
<h3 id="关于本-wiki"><a class="header" href="#关于本-wiki">关于本 wiki</a></h3>
<p>　　本 wiki 是和 YSLib 项目关联的项目。本 wiki 和 YSLib 项目组成了同一个项目组当前仅有的两个成员，每个项目都有单独的版本库。项目组的公共文档、YSLib 的一般用户文档和重要特性列表主要由本 wiki 提供。YSLib 项目中的文档主要面向项目的维护者。两者的文档构成双向引用，即 YSLib 项目可能引用本 wiki 的内容，反之亦然。</p>
<p>　　除非另行指定，本 wiki 的内容适合当前最新的主分支版本（即版本库 <code>master</code> 分支标识为 <code>tip</code> 的版本）。</p>
<p>　　编辑本 wiki 的规则参见<a href="WikiRules.en-US.html">这里(en-US)</a> 。</p>
<p>　　本页面有意引用所有本 wiki 的所有页面。</p>
<h1 id="贡献"><a class="header" href="#贡献">贡献</a></h1>
<p>　　对项目的贡献受到欢迎。由此提供的材料应在必要时由贡献者（及项目维护者）调整，以符合相应项目的许可证。</p>
<p>　　<strong>这个 wiki 规则被视为共识。</strong> 在项目文档内部的规则对维护者而不是其他贡献者有效。但是，项目中的内容应符合项目规则。</p>
<p>　　要反馈或报告问题，使用 <a href="https://bitbucket.org/FrankHB/yslib/issues/">Bitbucket 问题跟踪系统</a>，或按如下方式联系项目维护者。</p>
<h2 id="项目内容规则"><a class="header" href="#项目内容规则">项目内容规则</a></h2>
<p>　　下列指导原则一般地适用于所有项目。</p>
<ul>
<li><strong>不<a href="https://zh.wikipedia.org/zh-cn/%E9%87%8D%E9%80%A0%E8%BD%AE%E5%AD%90">重复发明轮子</a>。</strong> 这里的项目只接受比别处更好的模块化组件。此处“更好”定义为“在至少一个方面比现有解决方案更有效地满足一致同意的已知需求”。
<ul>
<li>参见<a href="Features.zh-CN.html">特性</a>注记的轮子列表和原理。</li>
</ul>
</li>
<li><strong>拒绝不成熟的优化。</strong> 然而，何谓“不成熟”由需求决定，这很可能变化。</li>
</ul>
<h1 id="联系方式"><a class="header" href="#联系方式">联系方式</a></h1>
<ul>
<li>发邮件到<a href="mailto:frankhb1989@gmail.com">frankhb1989@gmail.com</a></li>
<li>在<a href="http://tieba.baidu.com/f?kw=%BB%C3%A4%CE%C9%CF%B5%DB">贴吧</a>发贴/Post <a href="http://tieba.baidu.com/f?kw=%BB%C3%A4%CE%C9%CF%B5%DB">here</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="主题目录"><a class="header" href="#主题目录">主题目录</a></h1>
<ul>
<li><a href="GettingStarted.zh-CN.html">入门</a></li>
<li><a href="Development.zh-CN.html">开发说明</a>
<ul>
<li><a href="Prerequisitions.zh-CN.html">先决条件</a></li>
<li><a href="GettingSources.zh-CN.html">获取源代码</a>（另见项目维护资源）</li>
<li><a href="Build.zh-CN.html">构建</a>
<ul>
<li><a href="BuildDocumentation.zh-CN.html">构建文档</a></li>
</ul>
</li>
<li><a href="Test.zh-CN.html">测试</a></li>
<li><a href="Run.zh-CN.html">运行</a></li>
</ul>
</li>
<li><a href="Features.zh-CN.html">结构和特性</a>
<ul>
<li><a href="ProjectDependencies.zh-CN.html">（内部）项目依赖性</a>说明</li>
<li><a href="Features/NPL.zh-CN.html">NPL</a></li>
</ul>
</li>
<li>应用开发环境
<ul>
<li><a href="Sysroot.zh-CN.html">Sysroot</a></li>
<li><a href="YDE.zh-CN.html">YDE</a></li>
</ul>
</li>
<li>项目维护资源
<ul>
<li><a href="Releases.zh-CN.html">发布工程</a>：规则、版本清单和路线图等</li>
<li><a href="Archives.zh-CN.html">归档</a>：发布的历史资源</li>
<li>以下工具中部分用于项目维护</li>
</ul>
</li>
<li>工具
<ul>
<li><a href="Tools/SHBuild.zh-CN.html">SHBuild</a></li>
<li><a href="Tools/RevisionPatcher.zh-CN.html">RevisionPatcher</a></li>
<li><a href="Tools/SXML2XML.zh-CN.html">SXML2XML</a></li>
<li><a href="Tools/ProjectGenerator.zh-CN.html">ProjectGenerator</a></li>
<li><a href="Tools/Scripts.zh-CN.html">脚本</a></li>
</ul>
</li>
<li><a href="Tutorial.zh-CN.html">教程</a></li>
<li><a href="Terminology.zh-CN.html">术语概要</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="导航"><a class="header" href="#导航">导航</a></h1>
<p>　　<a href="Home.zh-CN.html">YSLib 是什么？</a></p>
<p>　　返回<a href="Contents.zh-CN.html">目录</a>查看其它内容。</p>
<h1 id="目标读者"><a class="header" href="#目标读者">目标读者</a></h1>
<p>　　本文预期的读者是对了解如何使用 YSLib 创建项目感兴趣的<strong>开发者</strong>。</p>
<h2 id="基础知识"><a class="header" href="#基础知识">基础知识</a></h2>
<p>　　本文假定读者已经掌握或了解以下知识，不详细展开讨论：</p>
<ul>
<li>计算机体系结构常识</li>
<li>了解规范 C++ 语言的标准（ISO/IEC 14882）</li>
<li>了解什么是语言的实现（如编译器和链接器等）并掌握常见实现的使用方法（如 G++ 命令行）</li>
<li>有必要时，能避免依赖只在特定实现支持的方言特性</li>
</ul>
<h1 id="概要-1"><a class="header" href="#概要-1">概要</a></h1>
<p>　　本文档说明开发 YSLib 程序的简易操作。以下仅提供操作步骤和主要意义的解释。</p>
<p><strong>注意</strong> 若需自行定制构建，参照以下引用的文档的全文，而非某个特定章节；再按照<a href="Build.zh-CN.html">构建</a>中的步骤执行。</p>
<p>　　当前只有关于 Windows 下使用 MinGW32 的内容，基于 MSYS2 环境。</p>
<h1 id="环境配置"><a class="header" href="#环境配置">环境配置</a></h1>
<p>　　使用 YSLib 开发需要配置 YSLib 环境，以确保 YSLib 的库和相关环境可用。</p>
<p>　　当前建议直接在本机环境中从源代码构建安装 YSLib ，参照以下步骤和要点：</p>
<ul>
<li>参照<a href="Prerequisitions.zh-CN.html">先决条件</a>的 <strong>PC(MinGW32)</strong> 一节给出的链接下载 MSYS2 并配置环境，执行脚本安装所需的工具。
<ul>
<li><strong>注释</strong> 若不需要构建 GUI 应用程序，也可以参照先决条件的 <strong>PC/Linux</strong> 一节，在 Linux 环境下本机构建。</li>
</ul>
</li>
<li><a href="GettingSources.zh-CN.html">获取源代码</a>。
<ul>
<li>若直接从版本库获取，直接构建可能找不到库而在链接时失败。可以自行参照文档构建缺少的外部依赖项，或<a href="Archives.zh-CN.html">从归档仓库下载</a>二进制文件放置到指定的库文件路径中，详见<a href="Development.zh-CN.html">开发说明</a>。</li>
<li>文件不包含 POSIX 权限。若需在依赖文件权限的环境（包括典型的 Linux 环境）中直接运行 shell 脚本，需确保（可能被间接调用的）脚本文件可执行，如运行 <code>find Tools -type f -name &quot;*.sh&quot; -exec chmod +x {} \;</code> 。</li>
</ul>
</li>
<li>参照 <a href="Sysroot.zh-CN.html">Sysroot</a> ，运行 <code>Tools/install-sysroot.sh</code> 脚本以构建 YSLib 并安装头所需的文件，得到 Sysroot 环境。然后，把 <code>sysroot/usr/bin</code> 目录的完整路径加入 <code>PATH</code> 环境变量（一般应添加在最前端）。
<ul>
<li><strong>注意</strong> 除非了解确切的作用，不要添加 YSLib 中的其它目录到 <code>PATH</code> ；添加不合适的目录可能会导致脚本运行失败。</li>
</ul>
</li>
</ul>
<p><strong>注释</strong> 以上是对新手的建议步骤。为了避免在之后的步骤中出现需要回溯解决的问题，这些步骤务求详尽。若已了解构建环境配置或为自动化部署，通常总是可以使用一行脚本在受支持的环境中直接构建 Sysroot 。</p>
<h1 id="开发基础"><a class="header" href="#开发基础">开发基础</a></h1>
<p>　　以下介绍使用 YSLib 开发须知的基础要点，并说明如何开发示例程序。</p>
<h2 id="控制台程序和图形用户界面gui-程序"><a class="header" href="#控制台程序和图形用户界面gui-程序">控制台程序和图形用户界面(GUI) 程序</a></h2>
<p>　　需要注意，在 Windows 中控制台程序仍然可以包含 GUI 。</p>
<p>　　YSLib 支持各种用户应用程序。为了简便起见，以下只介绍 GUI 程序的使用。更具体的说明参见 <a href="Prerequisitions.zh-CN.html">Windows 子系统</a>。</p>
<h2 id="编写-hello-world-程序"><a class="header" href="#编写-hello-world-程序">编写 Hello World 程序</a></h2>
<p>　　新建 C++ 源文件（名称任意，但需要<a href="Tools/SHBuild.zh-CN.html#markdown-header-_1">以 <code>.cpp</code> 等作为扩展名以保证 SHBuild 作为 C++ 源文件处理</a>），内容如下：</p>
<pre><code>#include &lt;YSBuild.h&gt;
#include YFM_Helper_GUIApplication
#include YFM_YSLib_UI_Label
#include YFM_Helper_HostedUI

int
main()
{
	using namespace YSLib;
	GUIApplication app;
	UI::Label wgt({480, 360, 160, 24});

	wgt.Text = u&quot;Hello world!&quot;;
	Host::ShowTopLevel(wgt, WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX, 0);
	Execute(app);
}
</code></pre>
<h3 id="关于头文件"><a class="header" href="#关于头文件">关于头文件</a></h3>
<p>　　可以安全地重复包含头文件。</p>
<p>　　注意到 <code>#include</code> 后可以是一个宏。这里表示路径的宏 <code>YFM_*</code> 由 <code>&lt;YSBuild.h&gt;</code> 保证定义，因此这个头文件需要在使用这些宏之前被包含。</p>
<p>　　使用宏表示 YFramework 的大多数头文件名是兼容性的需要。用户程序不需要使用这种策略，尤其是集成开发环境可能会对这样引入的头文件的修改不敏感而导致的构建遗漏。</p>
<p>　　MinGW32 平台的 Helper::HostedUI 的头文件已经保证包含了 <code>&lt;Windows.h&gt;</code> 中宿主窗口的声明，不需要显式包含。</p>
<h2 id="使用-shbuild-buildapp-脚本构建程序"><a class="header" href="#使用-shbuild-buildapp-脚本构建程序">使用 SHBuild-BuildApp 脚本构建程序</a></h2>
<p>　　把上面的文件保存到<strong>一个空的目录</strong>下，以下以 <code>$SRC</code> 指定这个目录名。</p>
<p>　　执行以下命令：</p>
<pre><code>bash -c &quot;cd $SRC; SHBuild-BuildPkg.sh release .&quot;
</code></pre>
<p>　　在目录 <code>$SRC/.release</code> 下找到构建好的可执行文件（具体文件名取决于源文件名），执行观察结果。</p>
<h3 id="说明"><a class="header" href="#说明">说明</a></h3>
<p>　　<code>bash -c</code> 启动新的 shell 执行命令。</p>
<p>　　<code>cd $SRC</code> 切换 shell 的当前工作目录到源代码目录。</p>
<p>　　<code>SHBuild-BuildPkg.sh</code> 调用构建脚本。脚本的参数分别是：</p>
<ul>
<li><code>release</code> 是一个配置名称。配置名称决定保存生成的文件的输出目录相对当前工作目录的位置，这里输出目录是当前工作目录下的 <code>.release</code> 子目录。可以更换配置名称以指定不同的输出目录。
　　* 若配置名称以 <code>debug</code> 起始，启用调试配置，自动使用调试库和构建选项。</li>
<li><code>.</code> 表示构建的目录源代码的根目录为当前工作目录。</li>
<li>之后的可选参数在此省略。</li>
</ul>
<p>　　构建脚本以特定的选项调用 <a href="Tools/SHBuild.zh-CN.html">SHBuild</a> 工具作为脚本解释器执行 NPLA1 脚本 <code>SHBuild-BuildApp.txt</code> ，详见 <a href="Sysroot.zh-CN.html">Sysroot</a> 。</p>
<p>　　<code>SHBuild-BuildApp.txt</code> 内部再次调用 SHBuild 工具进行构建。默认会递归扫描整个目录（除了名称以 <code>.</code> 起始的子目录外）。若存在多个源文件，这些文件都会被一起编译并链接。为了避免预期以外的结果，之前要求源文件在空目录中。</p>
<h3 id="其它方法"><a class="header" href="#其它方法">其它方法</a></h3>
<p>　　也可以直接调用 <code>SHBuild</code> 或者编译器命令行，但需要手动指定调用编译器的参数以及链接的库等，较为复杂，在此从略。</p>
<h3 id="清理"><a class="header" href="#清理">清理</a></h3>
<p>　　无论是 <code>SHBuild</code> 还是 <code>SHBuild-BuildPkg.sh</code> 当前都不提供清理功能。因为包括中间文件的输出文件都在同一个输出目录中，直接删除输出的目录即可。</p>
<h1 id="进一步阅读"><a class="header" href="#进一步阅读">进一步阅读</a></h1>
<p>　　参见<a href="Development.zh-CN.html">开发说明</a>的相应章节和进阶的<a href="Tutorial.zh-CN.html">教程</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开发说明"><a class="header" href="#开发说明">开发说明</a></h1>
<p>　　关于环境配置，详见<a href="Run.zh-CN.html">运行</a>。当前没有其它的面向最终用户的说明。</p>
<p>　　以下为面向开发者的说明。</p>
<h1 id="准备"><a class="header" href="#准备">准备</a></h1>
<ul>
<li>了解<a href="Prerequisitions.zh-CN.html">先决条件</a></li>
<li><a href="GettingSources.zh-CN.html">获取源代码</a></li>
<li>了解<a href="ProjectDependencies.zh-CN.html">项目依赖性</a></li>
<li>了解<a href="Terminology.zh-CN.html">术语概要</a>的体例以备参考</li>
</ul>
<p>　　YSLib 项目文档位于 YSLib 项目而不是本 wiki 项目中。</p>
<p>　　维护者参考的细节和一般规则详见 YSLib 项目文档 <code>doc/ProjectRules.txt</code> ；术语的完整定义详见 YSLib 项目文档 <code>doc/CommonRules.txt</code> 。</p>
<h1 id="项目过程"><a class="header" href="#项目过程">项目过程</a></h1>
<p>　　基本规则参见 YSLib 项目文档 <code>doc/ProjectRules.txt</code> 。</p>
<p>　　本 wiki 项目作为用户手册和开发者补充文档的形式作为实现及之后阶段输出。</p>
<p>　　实现的附加输出为库和工具。</p>
<p>　　之前阶段（如设计）为前期过程，其文档和适用于维护过程的项目规则位于 YSLib 项目文档（位于 <code>doc/</code> ）。</p>
<p>　　其中整体过程由 <code>doc/Designation.txt</code> 指定。当前内联设计以外的过程，因此不存在设计外前期过程的单独文档。</p>
<h1 id="开发"><a class="header" href="#开发">开发</a></h1>
<ul>
<li><a href="Build.zh-CN.html">构建</a>
<ul>
<li><a href="BuildDocumentation.zh-CN.html">构建文档</a></li>
</ul>
</li>
<li><a href="Run.zh-CN.html">运行</a></li>
<li>使用 <a href="Sysroot.zh-CN.html">Sysroot</a> 开发和部署程序</li>
</ul>
<h1 id="平台"><a class="header" href="#平台">平台</a></h1>
<p>　　关于<strong>外部依赖</strong>、<strong>平台</strong>、<strong>目标平台</strong>和<strong>宿主平台</strong>等概念的一般定义参见<a href="Terminology.zh-CN.html">术语概要</a>。</p>
<p>　　YSLib 项目约定一个体系结构和使用的外部依赖是一个平台。</p>
<p>　　YSLib 支持不同的目标平台。类似 ISO C/C++ 的独立实现(freestanding implementation) 和宿主实现(hosted implementation) ，平台分为两类：<strong>独立实现平台</strong>和<strong>宿主实现平台</strong>。后者存在操作系统的支持而前者没有。</p>
<h2 id="语言使用和实现要求"><a class="header" href="#语言使用和实现要求">语言使用和实现要求</a></h2>
<p>　　本节适用于本项目，不直接限制依赖项和用户程序。项目中特定部分的规则及适用性详见 YSLib 项目文档 <code>doc/ProjectRules.txt</code> 。</p>
<p>　　除脚本（见以下相关章节）外，使用 ISO C++ 作为主要开发语言。</p>
<p>　　不使用和 ISO C++03 以后被接受的特性不兼容的特性，包括但不限于：</p>
<ul>
<li>被取消的特性，如 ISO C++03 后导出模板的 <code>export</code> 关键字。
<ul>
<li>不限制有条件使用的之后的其它特性，如 <code>export</code> 被作为模块。（当前不使用模块。）</li>
</ul>
</li>
<li>在 ISO C++03 中标记为 deprecated 而在之后版本去除的特性，如 <code>const char</code> 数组类型左值到 <code>char*</code> 右值的转换。</li>
<li>在 ISO C++03 中标记为 deprecated 但在之后版本重新取消 deprecated 的特性，如修饰命名空间作用域声明的 <code>static</code> 。</li>
<li>实现的 Defect Report ，如 <a href="http://wg21.cmeerw.net/cwg/issue615">CWG 615</a> 。</li>
<li>显式排除的特定的语言特性：
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r3.pdf">P0145R3</a> ：ISO C++17 指定的特定表达式的求值顺序。
<ul>
<li><strong>注释</strong> 使用 <a href="https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Dialect-Options.html">G++ 的 <code>-fno-strong-eval-order</code> 选项</a>可显式指定假定避免依赖这项特性。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　注意即使使用特定模式，一些实现也可能引入之后的 Defect Report 而不保证兼容，如 <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65890">GCC PR 65890</a> 。</p>
<p>　　关于精确的特性使用规则、具体使用及备选的特性的清单等，详见<a href="StandardUsing.en-US.html">标准使用（英文）</a> 。</p>
<p>　　以下对语言实现的要求和支持情况适用整个项目。具体内容可能会在未来变动。</p>
<h3 id="基准实现要求"><a class="header" href="#基准实现要求">基准实现要求</a></h3>
<p>　　YSLib 依赖 ISO C++ 独立实现或宿主实现，附加以下要求：</p>
<ul>
<li>满足<a href="StandardUsing.en-US.html">标准使用(en-US)</a> 中具体特性的要求。
<ul>
<li><strong>注释</strong> 默认基于 ISO C++11 环境，但并不要求实现完整支持所有特性。</li>
<li><strong>注释</strong> 一些特性具有替代实现或者是可选的，而不被依赖。</li>
</ul>
</li>
<li>满足 ISO C++11 [implimits] 建议的最小实现要求。</li>
<li>标准库基于 ISO C++11 定义的宿主实现，并满足以下要求：
<ul>
<li><strong>注释</strong> 语言实现不需要是完整的宿主实现。</li>
<li>提供以下符合标准的整数类型：
<ul>
<li>定宽整数 <code>std::intN_t</code> 和 <code>std::uintN_t</code>（其中 N 为 8 、16 、32 或 64 ）。</li>
<li>类型 <code>std::uintptr_t</code> 。</li>
<li><strong>注释</strong> 定宽整数在 ISO C++11 中为可选支持。</li>
</ul>
</li>
<li>满足以下实现定义行为的要求：
<ul>
<li>至少支持 <code>std::placeholders::_7</code>。</li>
<li><strong>注释</strong> 按 ISO C++11 Annex B [implimits] ，符合标准的下限为 10 ，因此已被上述规则涵盖。</li>
</ul>
</li>
<li>假定用于迭代器的 <code>difference_type</code> 或坐标计算的有符号整数作为显式转换的目标类型且结果不能在范围内表示时，不引起副作用且结果的值不是能在此范围内表示的任意值（即为小于 <code>0</code> 的值）。
<ul>
<li><strong>注释</strong> 一个典型的例子是 <code>std::ptrdiff_t</code> 。</li>
<li>当前标准中，转换到有符号数的结果由实现定义。</li>
<li><a href="http://wg21.link/p0907">WG21 P0907</a> 已提议修改使用补码表示，并在 ISO C++20 采纳，按，符合此要求。</li>
<li><strong>注释</strong> 一般的到有符号数转换的由实现定义的行为仍不被依赖。</li>
</ul>
</li>
<li>假定特定类型的特定操作无异常抛出（但不依赖异常规范的行为），当前包括：
<ul>
<li><code>std::string</code> 的默认构造函数（ <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4002.pdf">WG21 N4002</a> 引入了显式指定 <code>noexcept</code> ，仅从标准草案 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf">WG21 N4296</a> 起有效）。</li>
</ul>
</li>
</ul>
</li>
<li>假定被包含在具有外部链接实体的函数体或声明命名空间作用域中外部链接名称的被 ODR 使用(<a href="http://eel.is/c++draft/basic.def.odr#3">odr-used</a>) 的 lambda 表达式相同。
<ul>
<li>否则会引起被包含的代码中的 lambda 在多个翻译单元 ODR 使用时<a href="http://eel.is/c++draft/basic.def.odr#6">违反 ODR 引发未定义行为</a> 。此类未定义行为包括以下情形：
<ul>
<li>所在函数体在 <code>extern inline</code> 函数。这被 <a href="http://wg21.cmeerw.net/cwg/issue765">CWG 765</a> 解决并存在于 ISO C++11 和<a href="http://eel.is/c++draft/dcl.fct.spec#4">之后的标准文本</a>中。
<ul>
<li>对符合 ISO C++11 及之后版本标准的实现，<a href="https://www.reddit.com/r/cpp/comments/40saz8/a_workaround_for_dangerous_lambda_odr_violations/">这个变通</a> 对其中的示例代码因此是不必要的；其它情况也有代码膨胀的缺陷，不应使用。</li>
<li>已知当前所有版本的 Microsoft VC++ 编译器都<a href="https://www.reddit.com/r/cpp/comments/40lm8o/lambdas_are_dangerous/">没有实现这个特性且会在内联代码后引起未预期的行为，计划在下一版本修复</a>。</li>
</ul>
</li>
<li>命名空间作用域中的 lambda 表达式，或所在函数体在其它实体，包括函数模板、类模板的成员函数以及类模板的成员函数模板。这是<a href="http://stackoverflow.com/questions/34717823/can-using-a-lambda-in-header-files-violate-the-odr/34721371#34721371">未被提交和解决的 ISO C++ 缺陷</a>。此处的假定作为用于避免这个问题。</li>
</ul>
</li>
<li>基于 <a href="https://mentorembedded.github.io/cxx-abi/abi.html#closure-types">Itanium ABI</a> 的实现符合这个条件。</li>
</ul>
</li>
<li>对宿主环境中程序外部的状态的并发修改不引起未定义行为。
<ul>
<li>现有操作系统和文件系统提供的接口和实现普遍不能保证避免 <a href="https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use">TOCTTOU 访问(en-US)</a> 导致的问题。具体修改的结果未指定，但应不直接引起无法预测的程序行为。</li>
<li>除非另行指定，本项目的实现不保证检查外部程序的修改。</li>
</ul>
</li>
</ul>
<p>　　假定 YSLib 实现和用户程序的代码满足以下要求：</p>
<ul>
<li>假定异常和标准库 RTTI 对象满足 ODR ，即使是在使用动态库的宿主实现中。
<ul>
<li>但影响用户代码生成的实现的二进制约定（如 <a href="https://reviews.llvm.org/rL205139">ARM64</a> ）且不使用以下错误实现变通的情形除外。</li>
<li>这要求用户代码不依赖影响相关符号可见性而导致 ODR 失效的特性。
<ul>
<li>例如，这不允许如 <code>dlopen</code> 使用 <code>RTLD_LOCAL</code> 加载具有相关符号的库。</li>
</ul>
</li>
<li>这允许 <code>std::type_info</code> 的比较操作和散列操作的高效实现，并避免一些实现错误。
<ul>
<li>使用 libstdc++ (libsupc++) 时，需要重定义宏 <code>__GXX_TYPEINFO_EQUALITY_INLINE</code> 和宏 <code>__GXX_MERGED_TYPEINFO_NAMES</code> 为 <code>1</code> 。
<ul>
<li>这是对 <code>std::type_info</code> 比较操作的错误实现的变通。
<ul>
<li>参见 <a href="https://gcc.gnu.org/viewcvs/gcc?view=revision&amp;revision=179236">GCC r179236</a> 的修改。</li>
<li>参见 <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=103240">GCC PR 103240</a> 。</li>
</ul>
</li>
<li>一般在编译器命令行中使用 <code>-U</code> 选项取消可能存在的预定义再使用 <code>-D</code> 选项重新显式定义，以避免预定义宏被重定义。</li>
<li>调整 <code>__GXX_TYPEINFO_EQUALITY_INLINE</code> 对启用 <code>__GXX_MERGED_TYPEINFO_NAMES</code> 是必要的。</li>
<li><strong>注释</strong> <code>__GXX_MERGED_TYPEINFO_NAMES</code> 默认值被<a href="https://gcc.gnu.org/viewcvs/gcc?view=revision&amp;revision=149964">修改</a> 以支持上述影响符号可见性的特性。</li>
</ul>
</li>
<li>其它实现暂不使用选项支持，以避免和上述二进制约定冲突。
<ul>
<li>libc++ 不支持另行调整，由实现根据平台环境指定 <code>_LIBCPP_HAS_NONUNIQUE_TYPEINFO</code> 。</li>
<li>另见以下关于 <code>std::type_info</code> 比较的限制。</li>
</ul>
</li>
</ul>
</li>
<li>链接时除上述二进制约定，假定 <code>std::type_info</code> 相关的符号被共享。
<ul>
<li>这不允许在实现生成以外显式地<a href="https://stackoverflow.com/questions/19496643/using-clang-fvisibility-hidden-and-typeinfo-and-type-erasure">隐藏相关的符号</a>（如通过 <code>#pragma</code> 预处理指令或 <code>-fvisibility=hidden</code> 编译器命令行选项）。</li>
<li>这一般要求在兼容 GNU ld 的链接器在<a href="https://sourceware.org/binutils/docs/ld/Options.html#Options">命令行选项</a>中使用 <code>--dynamic-list-cpp-typeinfo</code> 等方式导出相关符号（也允许但不要求使用 <code>-rdynamic</code> 或 <code>-export-dynamic</code> ）。</li>
</ul>
</li>
</ul>
</li>
<li>不依赖 RTTI 的 <code>std::type_info</code> 对象在未命名命名空间中同名不同实体的比较结果：
<ul>
<li>libc++ 没有正确支持这些比较，参见 <a href="https://bugs.llvm.org/show_bug.cgi?id=34907">LLVM PR 34907</a>(<a href="https://github.com/llvm/llvm-project/issues/34255">LLVM GitHub issue 34255</a>)。</li>
<li>Clang++ <a href="https://github.com/llvm/llvm-project/issues/59790">当前没有正确支持生成相关名称</a>。</li>
<li><strong>注释</strong> 在未命名命名空间的实体和命名命名空间的实体之间的比较不被涵盖。</li>
</ul>
</li>
<li>假定在标准库宏 <code>NDEBUG</code> 被定义的翻译单元中的代码不违反异常规范。
<ul>
<li>这允许改进代码生成，如使用 <a href="https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Dialect-Options.html">G++ 的 <code>-fno-enforce-eh-specs</code> 选项</a>。</li>
<li>程序应不依赖违反异常规范时调用标准库的函数的行为。否则，程序行为未定义。</li>
</ul>
</li>
</ul>
<p>　　YSLib 中具体子项目可要求更严格的实现假定，违反这些假定要求诊断，并可能在不保证支持的构建配置环境下终止构建。需要显式提供诊断时，若可行，应使用符合上述要求的可移植特性。此外，YSLib 实现可依赖可选的语言实现扩展。具体的更严格的假定和可选特性使用参见项目版本库中 <code>doc</code> 目录下的相关项目文档。</p>
<p><strong>注释</strong> 一些诊断通过语言规则保证而无需显式提供。提供诊断使用的可移植特性的一个例子是 <code>#error</code> 预处理命令。</p>
<p><strong>原理</strong> YBase 对标准库的修正实现要求更严格的关于实现细节的假定。YBase 对标准库的不分替代（如 <code>std::addressof</code> ）需依赖更严格的实现特性才能完整实现和标准库相同的保证（尽管不分保证作为 YBase 替代是可选提供的）。依赖更严格的实现假定也允许依赖和向用户代码提供特定平台配置的功能特性，以及提供质量更好的高性能实现。</p>
<h3 id="历史实现要求"><a class="header" href="#历史实现要求">历史实现要求</a></h3>
<p>　　以下要求已被修改或取消。</p>
<ul>
<li>假定提供撤销标准库未定义行为的保证：
<ul>
<li>撤销 <a href="http://eel.is/c++draft/res.on.functions#2.5">[res.on.functions]/2.5</a> 对特定不完整类型作为模板实际参数引起未定义行为的限制，包括：
<ul>
<li>使用默认分配器（ <code>std::allocator</code> 的实例）的 <code>std::vector</code> 的 <code>value_type</code> 类型。
<ul>
<li>这被包含在 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4510.html">WG21 N4510</a> 。</li>
<li><code>ystdex::pmr::pool_resource</code> 的实现从 b843[2018-11-10] 起依赖这项特性。</li>
<li>从 b863[2019-07-26] 起不使用不完整类型的元素而不再依赖这项特性。</li>
</ul>
</li>
<li>使用默认分配器（ <code>std::allocator</code> 的实例）的关联容器（即 <code>std::map</code> 和 <code>std::set</code> ）的 <code>value_type</code> 类型。
<ul>
<li>对 <code>std::vector</code> 、<code>std::list</code> 和 <code>std::forward_list</code> ，<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4510.html">WG21 N4510</a> 引入了不完整类型的支持。这<strong>不在</strong>此处要求。关联容器的要求预期在未来被添加。</li>
<li>已知 libstdc++ 的实现符合这个条件。</li>
<li>在 YSLib 中仅被 <code>YSLib::ValueNode</code> 通过在 <code>std::map</code> 使用递归的键类型的实现从 b338[2012-09-13] 起依赖。</li>
<li>因为使用 <code>ystdex::map</code> 替代 <code>std::map</code> ，从 b830[2017-08-11] 起取消这个要求，不再依赖标准库实现提供的扩展特性。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>假定特定类型的特定操作无异常抛出（但不依赖异常规范的行为），包括：
<ul>
<li><code>std::function::swap</code>（ <a href="https://wg21.cmeerw.net/lwg/issue2062">LWG 2062</a> 起有效）。
<ul>
<li>因为使用 <code>ystdex::function</code> 替代 <code>std::function</code> ，从 b848[2018-12-24] 起取消这个要求。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="可选实现支持"><a class="header" href="#可选实现支持">可选实现支持</a></h3>
<p>　　允许使用 ISO C++11 以后兼容最新标准草案的正式标准中的特性（可通过 <code>__cplusplus</code> 宏和 <a href="https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations">SG10 建议的特性检查</a>判断）。</p>
<h3 id="扩展特性"><a class="header" href="#扩展特性">扩展特性</a></h3>
<p>　　不依赖实现的方言扩展，但在确保实现能支持时，在特定的代码中可通过条件包含等方式选用。</p>
<p>　　若实现默认具有不符合标准的特性，在本项目的代码中不依赖这些特性，即便外部依赖项可能对此进行配置（如 MinGW G++ 为了和 Microsoft VC++ 兼容启用的 <code>-mms-bitfields</code> ，而 MSYS2 安装的 freetype2 的 <code>pkg-config</code> 的 CFLAGS 隐含此参数）。</p>
<h2 id="保留名称"><a class="header" href="#保留名称">保留名称</a></h2>
<p>　　YSLib 项目中，除了 YBase.LibDefect 是对标准库实现的修正外，并不是语言的实现，因此公开接口遵循 ISO C++ 对保留名称的使用，如不引入以 <code>__</code> 起始的标识符。</p>
<p>　　对实现环境已经以保留标识符提供的接口，适用以下规则：</p>
<ul>
<li><code>&lt;ydef.h&gt;</code> 提供宏包装特定实现的标识符。</li>
<li>除标准预定义的（如 <code>__cplusplus</code> ）和用于特性检查的标识符（以 <code>__cpp</code> 或 <code>__has</code> 起始），以及上述被包装时的宏定义，不在注解（作为宏 <code>YB_ATTR</code> 和 <code>YB_ATTR_STD</code> 的参数）外直接使用保留标识符。</li>
</ul>
<p>　　<code>&lt;ydef.h&gt;</code> 和其它一些 YSLib 项目头文件保留特定的不被标准保留的标识符，详见 YSLib 项目文档 <code>doc/Definitions.txt</code> 。</p>
<h1 id="库概述"><a class="header" href="#库概述">库概述</a></h1>
<p>　　YSLib 项目由多个子项目组成。其中主要的有顶级子项目：YBase 和 YFramework 。它们是开发 YSLib 应用的必备的库。每个库被构建为单独的映像（静态库或动态库）。</p>
<p>　　YSLib 的组件有些是依赖于特定平台的，但更多是<strong>平台中立</strong>的。关于库的组件在此的不同，详见下文的解释。</p>
<p>　　静态库、动态库或其它可能被库构建时依赖的输入以及构建使用的工具是库构建的<strong>依赖项</strong>。关于依赖项的一般说明，详见<a href="Terminology.zh-CN.html">术语</a>中关于依赖管理的说明。</p>
<h2 id="平台模拟"><a class="header" href="#平台模拟">平台模拟</a></h2>
<p>　　除非另行指定，文档中的狭义的“模拟”概念指程序模拟。</p>
<p>　　YSLib 项目中，<strong>平台模拟(platform emulation)</strong> 主要指直接以运行时环境适配层嵌入宿主平台运行时，在具体程序中提供类似被模拟的目标平台的具体特性和接口。</p>
<p>　　完整的定义详见 YSLib 项目文档 <code>doc/CommonRules.txt</code> 。</p>
<h2 id="外部依赖项"><a class="header" href="#外部依赖项">外部依赖项</a></h2>
<p>　　<strong>外部依赖项</strong>在构建项目的上下文中，指构建时可能使用的外部依赖，是不由本项目维护和单独发布的依赖项。</p>
<p>　　YSLib 项目严格使用 ISO C++ 的子集和特定实现的可选的扩展。关于依赖的语言特性，参见以上<a href="Development.zh-CN.html#%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E8%A6%81%E6%B1%82">语言使用和实现要求</a>的说明。</p>
<p>　　在所有目标平台上，除了<strong>系统库</strong>外，外部依赖项是相同的，但可能使用不同的版本，也不一定按相同的配置构建。系统库的概念和 <a href="http://www.gnu.org/licenses/gpl.html">GNU GPLv3</a> 的 <a href="http://www.gnu.org/licenses/gpl-faq.html#SystemLibraryException">system library exception</a> 中的 system library 定义类似，在此指特定平台或操作系统提供运行时支持的、由特定第三方环境提供开发支持的外部依赖，例如提供特定平台的 ISO C++ 标准库部分实现的 libstdc++ 和提供 Windows API 实现的 GDI32 等。</p>
<p>　　除了系统库外，一部分外部依赖项可选或必须使用自行构建的（可能被修改的）版本。这些外部依赖项的修改和构建脚本位于版本库的 <code>3rdparty</code> 目录，默认按原始许可证发行。</p>
<p>　　YBase 只直接依赖 ISO C++ 标准库。</p>
<p>　　YFramework 默认依赖经过修改的 FreeType2 和 FreeImage 。其中前者当前仅修改头文件，经过特别处理和官方发布的直接构建的版本二进制兼容，可以被系统库替换。</p>
<p>　　当前版本中，存储库中不同宿主平台对应的静态库文件（后缀名为 <code>.a</code> ）的目录如下：</p>
<ul>
<li>YFramework/DS/lib</li>
<li>YFramework/MinGW32/lib</li>
<li>YFramework/MinGW64/lib</li>
<li>YFramework/Android/lib</li>
<li>YFramework/Linux/lib</li>
</ul>
<p>　　其中，使用的 FreeImage 静态库对应 YFramework 的 <code>debug</code> 和非 <code>debug</code> 配置，文件名分别为 <code>libFreeImaged.a</code> 和 <code>libFreeImage.a</code> 。这可在同一个目录树中共存。</p>
<p>　　（当前 Android 和 Linux 仅支持单一本机体系结构，实际仅测试 Android ARMv7 和 Linux x86_64 。）</p>
<p>　　构建 YFramework 时需包含 <code>3rdparty/include</code> 目录的头文件。<a href="Sysroot.zh-CN.html">Sysroot</a> 安装脚本 <a href="Tools/Scripts.zh-CN.html">Tools/install-sysroot.sh</a> 会复制包括上面的头文件在内的文件。</p>
<p>　　当前已经使用的详细外部依赖项详见 YSLib 项目文档 <code>doc/Dependencies.txt</code> 。</p>
<p><strong>注意</strong> 版本库历史中包括静态库(<code>.a</code>) 文件，但为减少版本库大小，不再更新且可能移除，使用外部源或自行构建的方式替代。参见<a href="Archives.zh-CN.html">归档</a>获取单独配置或和源代码目录集成的已编译的外部依赖项。</p>
<p>　　在 build 885 之前，版本库历史的对应的宿主平台中的静态库位于以下位置：</p>
<ul>
<li>YFramework/DS/lib</li>
<li>YFramework/MinGW32/lib-i686</li>
<li>YFramework/Android/lib</li>
<li>YFramework/Linux/lib-x86_64</li>
</ul>
<p>　　其中 Android 平台只包括 FreeType2 ，Linux 平台只包括 FreeImage 。其它平台包括 FreeType2 和 FreeImage 库文件。</p>
<p>　　其它平台中，只有随其它文件的发布版本包含完整更新，否则压缩包中可能只有其中一个库文件。</p>
<p>　　关于自行构建外部依赖项的方法，参见<a href="Build.zh-CN.html">构建说明</a>。</p>
<h2 id="模块"><a class="header" href="#模块">模块</a></h2>
<p>　　YSLib 项目组织为一个逻辑上的树形结构，其叶节点称为<strong>模块</strong>。类似文件系统，非叶节点称为<strong>模块目录</strong>。在源代码中使用<strong>模块路径</strong>来标识不同的模块，其分隔符为 <code>::</code> 。在 YSLib 项目下直接划分的<strong>顶级子项目</strong>的名称仅在必要时出现在模块路径中，完整模块路径一般从<strong>次级子项目</strong>的名称起始。</p>
<p>　　C 和 C++ 源代码的一个模块由以下三种形式之一构成：</p>
<ul>
<li>一个头文件</li>
<li>一个非头文件的源文件</li>
<li>一个头文件和对应的源文件</li>
</ul>
<p>　　作为公开接口的模块是公开模块。公开模块的头文件在单独的目录中以便部署。</p>
<p>　　按 ISO C 和 ISO C++ 规定，C 或 C++ 模块中存在的非头文件的源文件和包含的头文件构成一个 C 或 C++（预处理）翻译单元，简称<strong>单元</strong>。注意这里包含的头文件不仅限于模块中的头文件。</p>
<p>　　关于模块的进一步说明以及模块路径的形式文法和头文件依赖的基本规则，参见 YSLib 项目文档 <code>doc/ProjectRules.txt</code> 。</p>
<h2 id="文件系统布局"><a class="header" href="#文件系统布局">文件系统布局</a></h2>
<p>　　作为 C++ 项目，YSLib 把每个顶级子项目的源文件和公开模块头文件分别保存在不同的目录中，即 <code>include</code> 和 <code>source</code> 。非公开模块若有头文件，也位于 <code>source</code> 。</p>
<p>　　特定于目标平台配置的代码会直接位于 <code>平台名</code> 目录下，称为<strong>平台扩展</strong>。对应的两个目录为 <code>平台名/include</code> 和 <code>平台名/source</code> 。</p>
<p>　　除了平台扩展的内容，文件系统目录和模块目录的每一级对应。平台扩展的模块目录名是对应平台中立部分加上后缀 <code>_(平台名)</code> 。</p>
<p>　　举例：顶级子项目 YFramework 下的次级子项目 Helper 的非平台扩展的源代码在目录 <code>YFramework/include/Helper</code> 和 <code>YFramework/source/Helper</code> 中，它的 DS 平台扩展的源代码位于 <code>YFramework/DS/include/Helper</code> 和 <code>YFramework/DS/source/Helper</code> 中。</p>
<p>　　提供平台扩展的次级子项目只有 YCLib 和 Helper 。</p>
<p>　　编译项目时包含的头文件是合并的，如编译器命令行 <code>-IYFramework/DS/include -IYFramework/include</code> 在一次编译中同时使用平台中立和特定于平台 DS 的模块的 YFramework 头文件。</p>
<h2 id="yslib-及其本体"><a class="header" href="#yslib-及其本体">YSLib 及其本体</a></h2>
<p>　　在 YBase 和 YFramework 分离之前，YSLib 是一整个库。原 YSLib 大部分仍然在 YFramework 中，仍然可称为 YSLib ，是一个 YFramework 下的次级子项目。注意和整个项目名的不同，以下称为 <strong>YSLib 库</strong>，以示区分。</p>
<p>　　YSLib 库中，Adaptor 用于适配特定于具体外部依赖的接口。可以通过修改其中的代码替换外部依赖，包括部分标准库兼容接口。</p>
<p>　　其它部分的接口和实现都是严格平台中立且不依赖外部特定接口而变化的，称为<strong>本体</strong>。本体中提供了 YSLib 的主要功能。</p>
<h2 id="helper"><a class="header" href="#helper">Helper</a></h2>
<p>　　若需要开发依赖平台特定的应用，本体接口可能不足，而需要使用平台扩展。此外，可能需要一些便利功能。</p>
<p>　　在 YSLib 库之上，Helper 对此类需求提供了一致而灵活的接口。</p>
<p>　　若需要更接近特定平台实现的接口，可以使用 YCLib 及其平台扩展。</p>
<p>　　YCLib 和 Helper 在宿主实现上都提供了更加丰富的功能。</p>
<h1 id="代码规范"><a class="header" href="#代码规范">代码规范</a></h1>
<p>　　YSLib 项目维护的代码规范符合 YSLib 项目中的文档约定的规则，包括：</p>
<ul>
<li><code>doc/CommonRules.txt</code> ：一般规则。</li>
<li><code>doc/ProjectRules.txt</code> ：项目规则。</li>
<li><code>doc/LanguageConvention.txt</code> ：语言使用约定。</li>
</ul>
<p>　　YSLib 中的脚本代码应符合以下相关章节的约定。</p>
<h2 id="代码格式化"><a class="header" href="#代码格式化">代码格式化</a></h2>
<p>　　<code>doc/CommonRules.txt</code> 中规定了命名风格和参考的代码格式。由于格式化代码涉及语义分析，并不保证可以完全自动化进行，需要在编码时注意调整。</p>
<p>　　以下工具配置可以把其中的主要工作自动化进行：</p>
<ul>
<li><code>clang-format</code>
<ul>
<li>可通过 MSYS2 包 <code>mingw-w64-i686-clang</code> 或 <code>mingw-w64-x86_64-clang</code> 安装，以下配置以这里的 3.7 版本为基准测试</li>
<li>配置选项的文档参见<a href="http://clang.llvm.org/docs/ClangFormatStyleOptions.html">这里</a></li>
<li>通过命令行 <code>-style=</code> 指定使用选项文件 <code>Tools/YSLib.clang-format</code></li>
<li><strong>注意</strong> 至少以下格式需要手动调整
<ul>
<li>在 <a href="http://lists.llvm.org/pipermail/cfe-commits/Week-of-Mon-20160808/167367.html">LLVM r278121</a> 添加 <a href="https://reviews.llvm.org/D23317">SpaceAfterTemplateKeyword 支持</a> 前 <a href="http://stackoverflow.com/questions/34423615/cpp-template-spacing-using-clang-format-3-6-not-working-as-expected">只支持 <code>template &lt;</code> 而不支持 <code>template&lt;</code></a></li>
<li>行末的 <code>\</code> 前可能附加多个空格</li>
<li><code>{}</code> 会被拆分</li>
<li>部分宏会被作为块的起始叠加缩进</li>
<li>选项 <code>AlwaysBreakAfterReturnType</code> 未被支持，部分函数和函数模板声明的返回类型后缺少换行</li>
</ul>
</li>
<li>通过命令行 <code>-i</code> 直接编辑文件而不是打印结果到标准输出</li>
<li>命令行示例： <code>find YBase YFramework YSTest -name &quot;*.h&quot; -o -name &quot;*.hpp&quot; -o -name &quot;*. cpp&quot; | xargs clang-format -i -style=file</code></li>
<li>命令行示例： <code>find YBase YFramework YSTest -name &quot;*.h&quot; -o -name &quot;*.hpp&quot; -o -name &quot;*. cpp&quot; | xargs -i sh -c &quot;clang-format -i -style=file {}&quot;</code></li>
<li>命令行示例（同时替换 <code>template &lt;</code> ）： <code>find YBase YFramework YSTest -name &quot;*.h&quot; -o -name &quot;*.hpp&quot; -o -name &quot;*. cpp&quot; | xargs -i sh -c &quot;clang-format -i -style=file {} &amp;&amp; sed -bi 's/template &lt;/template&lt;/g' {}&quot;</code></li>
</ul>
</li>
<li><code>astyle</code>
<ul>
<li>可通过 MSYS2 包 <code>mingw-w64-i686-astyle</code> 或 <code>mingw-w64-x86_64-astyle</code> 安装，以下命令行以这里的 2.05.1 版本为基准测试
*（版本 2.05 ）命令行选项的文档参见<a href="http://astyle.sourceforge.net/astyle.html">这里</a>
<ul>
<li><code>--help</code> 取得的文档可能<a href="https://github.com/Alexpux/MINGW-packages/issues/1011">有问题</a>，<code>--delete-empty-lines</code> 对应的短选项应为 <code>-xe</code> 而不是 <code>-xd</code></li>
</ul>
</li>
<li>使用命令行选项 <code>-A1 -T -p -U -k1 -xj -xy -xC80</code>
<ul>
<li>短选项可以缩写</li>
<li>和上述 <code>clang-format</code> 比较，少了部分功能，主要有
<ul>
<li><code>AlignAfterOpenBracket: DontAlign</code></li>
<li><code>AlignTrailingComments: true</code></li>
<li><code>AlwaysBreakAfterReturnType: All</code></li>
<li><code>MaxEmptyLinesToKeep: 2</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>注意</strong> 至少以下格式需要手动调整
<ul>
<li>无法正确识别 <code>constexpr</code> 导致错误的缩进</li>
<li>虽然<a href="http://sourceforge.net/p/astyle/bugs/265/">右值引用识别问题</a>已解决，但实测对模板参数无效</li>
<li>对 <code>extern &quot;C&quot;</code> 块冗余缩进</li>
<li>断行后的缩进</li>
<li>lambda 表达式的捕获列表中的 <code>=</code> 周围的冗余空格以及对应的 <code>{</code> 断行</li>
<li><code>static_cast</code> 等关键字后的 <code>&lt;&gt;</code> 周围的冗余空格</li>
<li>宏实际参数列表头部的 <code>(</code> 和作为第一个参数的标点可能有冗余空格</li>
<li>宏实际参数列表尾部的 <code>,)</code> 没有以空格隔离</li>
<li>初始化数组的列表 <code>{</code> 和之前的 <code>]</code> 存在冗余空格</li>
</ul>
</li>
<li>不使用 <code>-xp</code> ，尽管一些注释需要（移除行首 <code>*</code> 后保持一级缩进）的此类格式，但它会不必要地影响大部分 Doxygen 注释块</li>
<li>默认备份文件后缀 <code>.orig</code> ；可选使用 <code>-n</code> 取消备份文件，或 <code>--suffix=</code> 修改备份文件后缀</li>
<li>使用 <code>-r</code> 递归处理子目录</li>
<li>可选使用 <code>-v</code> 显示详细过程</li>
<li>可选使用 <code>-Q</code> 只显示被处理的文件</li>
<li>可选使用 <code>--dry-run</code> 不实际处理文件</li>
<li>命令行示例：<code>astyle -vQnrA1TpUk1xjxyxC80 YBase/*.h* YBase/*.cpp YFramework/*.h* YFramework/*.cpp YSTest/*.h* YSTest/*.cpp</code></li>
</ul>
</li>
</ul>
<h2 id="构建选项"><a class="header" href="#构建选项">构建选项</a></h2>
<p>　　一般地，在脚本中默认指定的工具链的警告选项应能支持代码规范。</p>
<h1 id="脚本"><a class="header" href="#脚本">脚本</a></h1>
<p>　　YSLib 版本库中包含若干脚本。这些脚本和 YSLib 安装部署的脚本使用本章中的约定。</p>
<p>　　脚本一般通过调用解释器运行。脚本的运行要求宿主环境（符合 YSLib 源码 <code>YF_Hosted</code> 定义支持的平台，指具有操作系统的环境）。</p>
<p>　　除非另行指定，脚本以文件的形式部署。</p>
<h2 id="外部环境"><a class="header" href="#外部环境">外部环境</a></h2>
<ul>
<li>除非另行指定，脚本不假定自身的存储位置。
<ul>
<li>一般地，这允许脚本的内容不总是可通过文件系统访问。这包括执行时脚本的来源被移除和不公开以文件的形式部署等情形。</li>
</ul>
</li>
<li>对文件系统中的脚本：
<ul>
<li>脚本文件总是普通文件或可解析到普通文件的有效的符号链接。</li>
<li>除非另行指定，不假定脚本文件所在的位置或其父路径可写。</li>
</ul>
</li>
</ul>
<p>　　项目中提供的脚本在版本库中具有固定的相对路径。除解释环境适用的公共的约定（如提供一般类 UNIX 系统使用的文件系统布局的 <a href="https://zh.wikipedia.org/zh-cn/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86">FHS（文件系统层次结构标准）</a>），脚本不预设绝对路径的假定。</p>
<p><strong>警告</strong> 小心处理路径。当前脚本直接或间接使用的所有涉及文件系统递归操作均不假设检查遍历的目标之间是否重复，若使用不恰当的目录链接，可能造成未预期的行为（如复制指向父目录的目录链接时可引起无限递归）。部署时应提前确保不存在这样的链接。</p>
<p>　　脚本实现假定没有可能冲突的并发文件访问。</p>
<h2 id="脚本文件"><a class="header" href="#脚本文件">脚本文件</a></h2>
<p>　　<strong>脚本文件总是使用以下约定的扩展名。</strong></p>
<p>　　除了 Windows 命令解释器使用的 <code>.cmd</code> 文件以及 <a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0">NPLA1</a> 脚本使用的 <code>.txt</code> 文件，所有脚本使用 <a href="http://zh.wikipedia.org/zh-cn/Shebang">Shebang</a> 明确需要使用的解释环境（详见 <a href="Development.zh-CN.html#shell-%E8%84%9A%E6%9C%AC">shell 脚本的说明</a>）。</p>
<p>　　Windows 命令解释器脚本因为实现限制使用本机 ANSI 代码页的编码，约定为兼容 ASCII 。</p>
<p>　　NPLA1 脚本约定使用带有 BOM 的 UTF-8 编码（去除 BOM 的脚本可能兼容 ASCII ）。详见 <a href="Tools/SHBuild.zh-CN.html#npl-%E6%94%AF%E6%8C%81">stage 1 SHBuild 中关于 NPL 支持的说明</a>。</p>
<h2 id="接口约定"><a class="header" href="#接口约定">接口约定</a></h2>
<p>　　脚本变量可能被读取和加载。除非另行指定，非导出的变量和名称以 <code>_</code> 结尾的变量，都不是公开接口。</p>
<h3 id="路径"><a class="header" href="#路径">路径</a></h3>
<p>　　<em>路径(path)</em> 是由有限的路径组件构成的序列。在不引起歧义时，路径即指文件系统路径。文件系统的路径组件能以字符串形式表示。</p>
<p>　　在支持相对路径的环境中，是否支持相对路径取决于具体脚本。</p>
<p>　　内部的路径的分隔符使用 <code>/</code> 。通过<a href="Tools/Scripts.zh-CN.html">工具脚本</a>提供的 <a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-SHBuild_2w"><code>SHBuild_2w</code></a> 等函数，可转换为带有不同路径分隔符的路径字符串。这种转换通常仅在必要时（如明确作为外部工具的输入）使用。</p>
<p>　　字符串形式的路径（即路径字符串）可能是保证不以分隔符结尾的文件名和确保以分隔符结尾的目录路径字符串。目录路径指目录路径字符串或其对应的非字符串形式的路径。</p>
<p>　　两个路径字符串的拼接可构成新的路径字符串。这两个路径字符串分别是路径前缀和路径后缀。除非另行指定，作为路径前缀使用的路径字符串是文件名。这要求通过串接路径后缀构成访问前缀指定的目录的新的路径时，路径后缀需要以分隔符起始。</p>
<p><strong>注意</strong> YBase 的 <code>ystdex::path</code> 和 YFramework 的 <code>YSLib::IO::Path</code> 等数据结构表示根路径外无视结尾分隔符的非字符串形式的路径，因为有效的分隔符仅在根路径中出现。这些实现一般不检查分隔符的合法性，如其中具有包含分隔符的路径组件，也可能正常转换为字符串形式的合法路径。当前脚本只使用字符串形式的路径。</p>
<h2 id="shell-脚本"><a class="header" href="#shell-脚本">Shell 脚本</a></h2>
<p>　　扩展名 <code>.sh</code> 的脚本文件是 shell 脚本文件。大多数脚本需要使用 <a href="https://www.gnu.org/software/bash/">GNU bash</a> 运行，如：</p>
<pre><code>#!/usr/bin/bash
</code></pre>
<p>　　需要考虑兼容性时，一般使用以下替代：</p>
<pre><code>#!/usr/bin/env bash
</code></pre>
<p>　　其它可以直接兼容 POSIX shell 的 <code>.sh</code> 脚本使用 Shebang 如：</p>
<pre><code>#!/usr/bin/sh
</code></pre>
<p>　　需要考虑兼容性时，一般使用以下替代：</p>
<pre><code>#!/usr/bin/env sh
</code></pre>
<p>　　为简化脚本代码，用户需要保证调用 shell 脚本时，环境应满足以下条件，否则行为未指定：</p>
<ul>
<li>使用满足要求的 Shell 语言实现：
<ul>
<li>对 bash 脚本：
<ul>
<li>满足版本要求：<strong>当前 Bash 最低版本为 4.0 。</strong></li>
<li>不使用 POSIX 兼容模式。</li>
<li>保证能使用 <code>mapfile</code> 等 <code>bash</code> 内建命令。</li>
</ul>
</li>
<li>对其它 POSIX shell 脚本：
<ul>
<li>使用符合 POSIX 的 shell ，或使用以上要求相同的 <code>bash</code> 运行 shell 脚本。</li>
</ul>
</li>
</ul>
</li>
<li>不论是否设置了变量 <code>POSIXLY_CORRECT</code> ，命令解释环境的变量满足：
<ul>
<li><a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_14">特殊内建工具</a>没有被用户定义的同名变量或别名覆盖。</li>
<li>被脚本调用的 POSIX 定义的工具命令没有被用户定义的同名变量或别名覆盖为调用时可观察行为不等价的实体。</li>
<li>变量 <code>IFS</code> 未设置或设置为默认值 <code>:</code> 。</li>
</ul>
</li>
<li>命令解释器同 <code>bash</code> 的 <code>-p</code> 选项启用时效果相同。
<ul>
<li>用户应保证不设置 <code>CDPATH</code> 等 <code>-p</code> 忽略的<a href="Run.zh-CN.html">环境变量</a>及 <code>$BASH_ENV</code> 等启动文件，以避免未预期的不同行为。</li>
</ul>
</li>
<li>脚本文件不是目标在不同目录中的符号链接。
<ul>
<li>对 bash 脚本，允许使用变量 <code>BASH_SOURCE</code> 的值（如 <code>${BASH_SOURCE[0]}</code> 或 <code>${BASH_SOURCE%/*}</code> 等形式） 较可靠地判断脚本文件的路径。此时，隐含需要附加假定通过脚本文件路径确定其它资源的位置。</li>
<li>部分脚本可能有更进一步的使用限制或不依赖 <code>.</code> 命令及命令解释器调用的差异。此时，可直接使用 <code>&quot;$0&quot;</code> 判断路径。</li>
</ul>
</li>
</ul>
<p>　　脚本实现中的调用不受以上限制。</p>
<p>　　若脚本可以确保兼容 POSIX shell ，使用后者而不是前者。</p>
<p>　　如果对应解释器位于其它目录，可以符号链接到上面指定的路径。</p>
<p>　　除非另行指定，本文档约定使用的路径字符串的分隔符为 <code>/</code> ，不连续出现在路径中，且不在结尾出现。例外：</p>
<ul>
<li>平台相关的绝对路径转义可出现 <code>//</code> 。</li>
<li>构成路径的路径前缀可能以分隔符结尾，直接表示上层目录。</li>
</ul>
<p><strong>注意</strong> 当前版本库中的文件不保证跟踪权限。在一些环境中可能因为可执行权限问题导致无法立即执行脚本，参见<a href="GettingSources.zh-CN.html">这里的说明</a> 。</p>
<p>　　<a href="../Releases.zh-CN.html">正式支持的发布版本</a>中的公开 Shell 脚本应保证用 <a href="https://www.shellcheck.net/">ShellCheck</a> 0.7 或以上版本（任选）检查没有诊断消息。检查的命令行为 <code>shellcheck -x -P SCRIPTDIR</code> 跟随文件名。除非另行指定，使用明确的方式避免引起检查的问题而不是使用指令消除检查的结果，如使用 <code>${BASH_SOURCE[0]}</code> 代替 <code>$BASH_SOURCE</code> 以避免 ShellCheck 警告 SC2128 。</p>
<h3 id="shell-语言使用规约"><a class="header" href="#shell-语言使用规约">Shell 语言使用规约</a></h3>
<p>　　脚本程序不调整影响别名扩展的 shell 选项（如 bash 的 <code>shopt -u expand_aliases</code> ）。</p>
<p>　　除非另行指定，已定义的 shell 函数假定不被其它变量覆盖。这允许实现省略 <code>readonly -f</code> 或 <code>declare -g -r -f</code> 声明，且允许使用相同的定义覆盖以简化调试。</p>
<p>　　依照<a href="Run.zh-CN.html">运行时环境的约定</a>，除非另行指定，脚本不区分未设置的环境变量和已设置但具有空值的环境变量，以允许在外部环境配置脚本的执行。这两种情形下，被用于脚本中的变量的环境变量都可能指定一个非空的初始值，称为变量的<em>默认值(default value)</em> 。变量是否使用默认值总在先于第一次使用变量的值的初始化时确定。变量的初始化和默认值满足以下约定：</p>
<ul>
<li>初始化的变量是否只读未指定。</li>
<li>初始化变量时若需使用默认值，可能发生附加的求值（如命令调用）以其结果确定具体默认值。</li>
<li>除非变量的初始化被指定为由特定的函数确定，变量在未指定的脚本被执行时无条件初始化，而不需要使用变量的值前调用特定的函数。</li>
<li>除非另行指定，在特定函数中初始化的变量由此函数指定其默认值。</li>
<li>除非另行指定，初始化时使用的外部环境变量的值可假定和脚本运行环境直接或间接调用脚本前相同。</li>
</ul>
<p>　　除非另行指定，返回非数值的 shell 函数使用 <code>echo</code> 或功能蕴含 <code>echo</code> 的命令调用输出返回的值。</p>
<p>　　非生成的脚本源代码中不使用包含 <code>__</code> 的名称。</p>
<p>　　公开函数的函数名及公开的变量名不以 <code>_</code> 结尾，否则以一个 <code>_</code> 结尾。</p>
<p>　　对 <a href="Tools/SHBuild.zh-CN.html">SHBuild</a> 相关工具使用的函数，使用前缀 <code>SHBuild</code> 。</p>
<p>　　函数出错且无法恢复时退出脚本。</p>
<p>　　版本库中的提供的脚本一般应能通过 ShellCheck 检查。对需要使用 <a href="https://github.com/koalaman/shellcheck/wiki/Directive">ShellCheck 指令</a>指定脚本起始构造的检查时，在之前添加一行空命令（对 bash 脚本使用 <code>:</code> ，非 bash 脚本命令使用 <code>true</code> ）以避免非预期地使指令作用于整个脚本。</p>
<h3 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h3>
<p>　　Shell 脚本可使用以下能通过外部环境指定值的环境变量：</p>
<ul>
<li>用于指定入口位置：
<ul>
<li><code>SHBuild</code> ：外部 SHBuild 可执行文件路径。
<ul>
<li>默认值和特定脚本被设计适应的部署环境相关（例如，视不同情形，脚本可使用 <code>${BASH_SOURCE[0]}</code> 或 <code>&quot;$0&quot;</code> ）。</li>
</ul>
</li>
<li><code>SHBuild_ToolDir</code> ：工具目录中的脚本目录（参见<a href="Tools/Scripts.zh-CN.html">脚本</a>）。
<ul>
<li>默认值由脚本根据存储库所在目录确定。</li>
</ul>
</li>
</ul>
</li>
<li>用于指定存储库中的资源：
<ul>
<li><code>SHBuild_BaseDir</code> : SHBuild 目录，是工具目录中提供 SHBuild 的源代码的目录。
<ul>
<li>默认值按 <code>SHBuild_ToolDir</code> 初始化后的相对位置确定，为 <code>&quot;$SHBuild_ToolDir/../SHBuild&quot;</code>。</li>
</ul>
</li>
<li><code>YSLib_BaseDir</code> ：YSLib 目录，即版本库检出后的工作目录。
<ul>
<li>默认值按 <code>SHBuild_ToolDir</code> 初始化后的相对位置确定，为 <code>&quot;$SHBuild_ToolDir/../..&quot;</code>。</li>
</ul>
</li>
</ul>
</li>
<li>用于指定输出目录：
<ul>
<li><code>SHBuild_BuildDir</code> ：构建使用的中间输出文件路径。
<ul>
<li>默认值定义如下：
<ul>
<li>对不依赖 Sysroot 的以及 <code>YSLib/YSTest</code> 目录下的项目构建脚本，默认值指定在完整的版本库中和 <code>&quot;$YSLib_BaseDir/build/$(SHBuild_GetBuildName)&quot;</code> 相同的目录，且构建 <a href="Sysroot.zh-CN.html">stage 1</a> YSLib 时确保为绝对路径。</li>
<li>对 <code>YSLib/YDE</code> 目录下的项目构建脚本，默认值是 <code>&quot;.$(SHBuild_GetBuildName)&quot;</code> 。</li>
<li>否则，默认值是当前工作目录 <code>.</code> 。</li>
<li>以上调用的函数 <code>SHBuild_GetBuildName</code> 在脚本 Tools/Scripts/SHBuild-common.sh 中，依赖具有非空值的变量 <code>SHBuild_Host_OS</code> 和 <code>SHBuild_Host_Arch</code> 。</li>
</ul>
</li>
</ul>
</li>
<li><code>SHBuild_SysRoot</code> ：输出的 Sysroot 根路径。
<ul>
<li>在 stage 1 中，默认值是 <code>&quot;$YSLib_BaseDir/sysroot&quot;</code> 。</li>
</ul>
</li>
</ul>
</li>
<li>用于配置构建环境：
<ul>
<li>其它情形不用于指定输出目录，不保证具有默认值。</li>
<li><code>SHBuild_Env_TempDir</code> ：构建时使用的临时目录路径。
<ul>
<li>由脚本 Tools/Scripts/SHBuild-common.sh 的函数 <code>SHBuild_PrepareBuild</code> 初始化。</li>
<li>默认值由脚本 <code>Tools/Scripts/SHBuild-common.sh</code> 中的函数 <code>SHBuild_GetTempDir</code> 的调用确定。</li>
</ul>
</li>
<li><code>SHBuild_Env_Arch</code> ：构建系统架构。
<ul>
<li>由脚本 Tools/Scripts/SHBuild-common.sh 的函数 <code>SHBuild_CheckUName</code> 初始化。</li>
</ul>
</li>
<li><code>SHBuild_Env_OS</code> ：构建系统操作系统。
<ul>
<li>初始化和确定值的方式同 <code>SHBuild_Env_Arch</code> 。</li>
</ul>
</li>
<li><code>SHBuild_Host_Arch</code> ：宿主架构。
<ul>
<li>由脚本 Tools/Scripts/SHBuild-common.sh 的函数 <code>SHBuild_PrepareBuild</code> 初始化。</li>
<li>默认值使用以下方式指定：
<ul>
<li>当 <code>SHBuild_Env_OS</code> 的值是 <code>Win32</code> 且外部变量 <code>MSYSTEM</code> 的值是 <code>MSYSTEM64</code> 时，默认值为 <code>x86_64</code> 。</li>
<li>当 <code>SHBuild_Env_OS</code> 的值是 <code>Win32</code> 且外部变量 <code>MSYSTEM</code> 的值是 <code>MSYSTEM32</code> 时，默认值为 <code>i686</code> 。</li>
<li>其它情形默认值同 <code>SHBuild_Env_Arch</code> 初始化后的值。</li>
</ul>
</li>
</ul>
</li>
<li><code>SHBuild_Host_OS</code> ：宿主操作系统。
<ul>
<li>初始化的方式同 <code>SHBuild_Host_Arch</code> 。</li>
<li>默认值同 <code>SHBuild_Env_OS</code> 初始化后的值。</li>
</ul>
</li>
<li><code>SHBuild_VCS_</code> 起始的变量：指定使用的版本控制系统。
<ul>
<li><code>SHBuild_VCS_hg</code> ：若非空，指定使用 <a href="https://www.mercurial-scm.org/">Mercurial</a> 。</li>
<li><code>SHBuild_VCS_git</code> ：若非空，指定使用 <a href="http://git-scm.com/">Git</a> 。</li>
<li>除非另行指定，若同时指定使用 Mercurial 和 Git 两者，则使用 Mercurial 。</li>
<li>指定使用版本控制系统是提示，不保证是实际的选择。具体使用前，脚本可能自动对可用性（命令行 <code>hg</code> 和 <code>git</code> 及当前工作目录是否位于对应的版本库）进行检查，当不满足要求时可能忽略提示。</li>
<li><strong>原理</strong> 若当前工作目录同时位于多个版本控制系统的版本库，使用提示可以明确选择其中之一。</li>
<li><strong>注释</strong> 本项目的<a href="GettingSources.zh-CN.html">源代码可从 Mercurial 或 Git 中取得</a>。</li>
</ul>
</li>
<li><code>SHBuild</code> 构建使用的变量：详见 SHBuild 的帮助信息。</li>
<li>其它构建脚本使用的变量：详见以下具体脚本的说明。</li>
</ul>
</li>
</ul>
<p>　　若以上变量在上述任一情形存在作为路径的默认值且外部环境指定变量的值，则指定的值应表示合法的路径。</p>
<p>　　一般地，部署的 shell 脚本需引用其它脚本时，以如下方式使用指定入口的环境变量：</p>
<ul>
<li>若脚本只支持 Sysroot ，以 <code>SHBuild</code> 在 Sysroot 的安装位置推断其它脚本的路径。</li>
<li>若脚本只支持工具目录中的脚本目录布局，以 <code>SHBuild_ToolDir</code> 指定。
<ul>
<li>这隐含目录在版本库中的布局，可以此初始化 <code>YSLib_BaseDir</code> 等变量的默认值。</li>
</ul>
</li>
<li>若脚本同时支持 Sysroot 中部署的位置和工具目录中的脚本目录布局：则不使用以上的变量。
<ul>
<li>引用其它脚本文件时可直接指定包含，如：<code>. &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)/SHBuild-common.sh&quot;</code> 。</li>
</ul>
</li>
</ul>
<p>　　除指定入口的环境变量，是否支持外部可覆盖默认值的上述环境变量是可选的，取决于各个脚本的具体支持。</p>
<h2 id="npla1-脚本"><a class="header" href="#npla1-脚本">NPLA1 脚本</a></h2>
<p>　　NPLA1 脚本可被 SHBuild 调用。SHBuild 支持特定的选项作为 NPLA1 的脚本解释器。脚本解释器支持 NPLA1 脚本文件。此外，在 shell 脚本中，NPLA1 脚本代码可能以字符串的形式存储和被 SHBuild 调用。</p>
<h3 id="npla1-环境变量"><a class="header" href="#npla1-环境变量">NPLA1 环境变量</a></h3>
<p>　　NPLA1 脚本可使用和 shell 脚本通用的环境变量，如 <code>SHBuild</code> 。</p>
<p>　　除 stage 1 外，shell 脚本使用环境变量 <code>NPLA1_ROOT</code> 指定的根目录作为 SHBuild 加载 NPLA1 脚本使用的起始目录。</p>
<p>　　脚本（包括直接或间接调用 NPLA1 脚本的其它脚本）除默认值外不需要依赖 Sysroot 的安装路径下的目录和文件布局，环境变量 <code>SHBuild</code> 和 <code>NPLA1_ROOT</code> 可分别指定相互无依赖的路径。当仅指定 <code>SHBuild</code> 时，通过指定的 SHBuild 路径推断 <code>NPLA1_ROOT</code> 默认值，此时使用假定符合 Sysroot 约定的相对路径。</p>
<p>　　NPLA1 脚本可使用以上约定含义和默认值的 shell 环境变量并初始化 NPLA1 脚本内的同名变量，但部分变量的作用域和初始化方式可能不同：</p>
<ul>
<li>在 Tools/Scripts/SHBuild-YSLib-common.txt 中直接初始化变量 <code>SHBuild_Env_Arch</code> 和 <code>SHBuild_Env_OS</code> 。</li>
<li>在 Tools/Scripts/SHBuild-YSLib-common.txt 的函数 <code>SHBuild_GetPlatformStrings</code>（详见版本库中的 <code>doc/NPL.txt</code>）的调用中初始化变量 <code>SHBuild_Host_Arch</code> 和 <code>SHBuild_Host_OS</code> 。</li>
</ul>
<p>　　注意在 NPLA1 脚本中创建的变量不是环境变量；但和 shell 脚本类似，若需作为其它外部命令的环境变量，可先导出再调用对应的程序。</p>
<h3 id="npla1-函数"><a class="header" href="#npla1-函数">NPLA1 函数</a></h3>
<p>　　NPLA1 脚本可提供部分 shell 脚本中的同名函数。除非另行指定，这些函数的调用接口以及功能和 shell 脚本中的同名函数一致，但实现和以下行为不保证相同：</p>
<ul>
<li>出错时的诊断方式。</li>
<li>缓存的变量及相关的输出提示信息。</li>
<li>性能。</li>
<li>影响的非公开环境变量等其它外部环境状态。</li>
</ul>
<p>　　作为公开接口的 NPLA1 函数另见 <code>doc/NPL.txt</code> 中的描述。</p>
<h2 id="构建脚本"><a class="header" href="#构建脚本">构建脚本</a></h2>
<p>　　一些开发脚本被用于构建。构建脚本的一般形式提供配置和生成阶段的自动化功能。</p>
<p>　　配置阶段设置交互环境。典型地，通过执行命令前设置的环境变量指定可配置项。</p>
<p>　　生成阶段调用合适的工具完成构建。</p>
<p>　　配置阶段的接口可能对外隐藏，此时使用默认配置进行构建。</p>
<p>　　一些公用的构建脚本可适用于整个项目。其它的构建脚本可构建具体子项目中的目标。</p>
<p>　　构建脚本可以是 makefile 或其它可执行的脚本。其中，makefile 可能使用以上约定含义的 shell 环境变量，但不保证可被外部指定覆盖脚本中指定的默认值。</p>
<h1 id="参考"><a class="header" href="#参考">参考</a></h1>
<ul>
<li>YSLib 项目文档 <code>doc/Dependencies.txt</code> 了解组织结构、开发规则、默认使用的外部依赖项（包括语言实现）和相关约定。</li>
<li><a href="Features.zh-CN.html">结构和特性</a> 中的树形结构了解项目依赖性。</li>
<li>YSLib 项目文档 <code>doc/ProjectRules.txt</code> 了解组织结构、开发规则和相关约定。</li>
<li>YSLib 项目文档 <code>doc/YBase.txt</code> 了解顶级子项目 YBase 。</li>
<li>YSLib 项目文档 <code>doc/YFramework.txt</code> 了解顶级子项目 YFramework 。</li>
<li>YSLib 项目文档 <code>doc/YSLib.txt</code> 了解 YFramework 的次级子项目 YSLib 。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="先决条件"><a class="header" href="#先决条件">先决条件</a></h1>
<p>　　本文档列出受支持的构建配置的关联的先决条件，以及这些环境下的已知问题和相关应对。</p>
<p><strong>注释</strong> 构建配置和平台的相关定义详见<a href="Terminology.zh-CN.html">术语</a>。对问题的描述可能仅适用于个别的配置和源代码版本。仅需要配置构建环境的用户可以跳过关于非目标平台和不相关的问题的内容。</p>
<p>　　特定历史版本依赖的详细环境和平台库版本参见开发文档 <code>doc/Dependencies.txt</code> 。以下仅为当前最新主分支版本中用于构建 YSLib 自身及基于 YSLib 开发应用的环境配置说明。</p>
<p>　　关于本项目对平台的定义和项目保持的环境约束，包括开发需要的以下基础环境外的其它第三方依赖，在了解下文内容后，参见<a href="Development.zh-CN.html">开发说明</a>。</p>
<p><strong>注意</strong> <a href="GettingSources.zh-CN.html">获取到源代码</a>并不保证能够直接构建 YSLib（特别是对于直接从版本库获取的途径）。如需自行构建，应注意<a href="Development.zh-CN.html">开发说明</a>中有关外部依赖项的部分获取必要的其它文件。</p>
<p>　　关于运行环境，另见<a href="Run.zh-CN.html">运行时平台环境的说明</a>。</p>
<p>　　详细提交测试的环境参见开发文档 <code>doc/Test.txt</code> 。</p>
<p>　　若不使用特定的特性或构建平台，构建环境的部分要求是可选的。</p>
<p>　　以下各节的环境配置以“宿主平台/目标平台(目标平台名)”为标题指定，其中目标平台名是正式的配置名称（也在其它项目文档中作为配置名称使用），若和平台一致则被省略；其它平台的标识当前仅为明确开发流程，在用户文档中使用。对宿主平台和目标平台两者一致的情形，只标识一个平台。关于“平台”的一般含义，参见<a href="Terminology.zh-CN.html">术语</a>。</p>
<h2 id="公共构建环境"><a class="header" href="#公共构建环境">公共构建环境</a></h2>
<p>　　构建环境提供工具链（语言实现）和构建需要的工具。某些工具被不同的构建环境共享（但可能仍需针对不同构建平台使用不同二进制程序）。</p>
<p>　　Windows 平台上的 MSYS2 基础环境符合以下公共构建环境的所有要求。当前发布和一般提交（包括本机平台和交叉构建）时仅测试 MSYS2 。</p>
<h3 id="命令行环境"><a class="header" href="#命令行环境">命令行环境</a></h3>
<p>　　除非另行指定，构建环境的命令兼容 POSIX shell 。当前非 POSIX shell 的命令行构建环境仅在 <a href="Sysroot.zh-CN.html">Sysroot stage 2 环境</a> 被支持。</p>
<h3 id="工具链"><a class="header" href="#工具链">工具链</a></h3>
<p>　　使用 <code>make</code> 的平台需要 POSIX shell 支持。</p>
<p>　　除非另行指定，<code>make</code> 使用 GNU make ，版本 3.78 以上（建议使用 4.0 以上版本，虽然 YSLib makefile 不使用不兼容的特性）；不使用 <code>mingw32-make</code> 。</p>
<p>　　注意 <code>make</code> 可能被构建工具使用，详见以下链接时优化的说明。</p>
<p>　　POSIX shell 实现可使用<a href="Tools/Scripts.zh-CN.html">和工具脚本兼容的脚本解释环境</a> ，一般即 <code>bash</code> （建议版本 4.0 或以上）。</p>
<p>　　除非另行指定，直接支持的 C++ 实现为 GNU C++ 4.9 或以上版本。</p>
<h3 id="自动环境检测"><a class="header" href="#自动环境检测">自动环境检测</a></h3>
<p>　　在命令行环境中使用<a href="Tools/Scripts.zh-CN.html">脚本</a>构建时，脚本可能自动检测构建环境而需要附加的工具。这些工具可能在具体的构建环境（如以下各节）中可能已被提供或可选安装，参阅各个构建环境附带的文档。</p>
<ul>
<li><code>grep</code> ：用于判断线程支持的命令行选项。</li>
<li><code>uname</code> ：用于查询平台配置。</li>
</ul>
<p>　　使用特定的选项跳过自动检测构建时，可不依赖某些工具。详见具体脚本的说明。</p>
<h3 id="控制台和终端"><a class="header" href="#控制台和终端">控制台和终端</a></h3>
<p>　　除了自动检测环境（ Win32 或非 Win32 下使用 ANSI 转义序列）开启的彩色（前景色）文本，构建环境没有使用依赖特定终端的字符界面。因此可以使用不同的控制台或终端模拟器。</p>
<p><strong>注意</strong> 在 Windows 平台上若使用 ConEmu 出现 0xC0000005 错误，尝试<a href="https://code.google.com/p/conemu-maximus5/wiki/MicrosoftBugs">升级到最新版本后勾选 Inject ConEmuHk 选项</a> ，或直接使用 <code>cmd</code> 代替。</p>
<h3 id="线程执行环境"><a class="header" href="#线程执行环境">线程执行环境</a></h3>
<p>　　除非另行指定，线程执行环境使用 ISO C++ 的定义，参见 <a href="http://www.eel.is/c++draft/intro.multithread">ISO C++ [intro.multithread]</a> 。</p>
<p>　　库或接口的集合对多线程环境的依赖性满足以下要求：</p>
<ul>
<li>明确<strong>不依赖多线程执行环境</strong>时，保证在指定<a href="Terminology.zh-CN.html">平台</a>上可用的的公开 API 可构建并满足接口约定的语义，可在单线程执行环境中运行。</li>
<li>明确<strong>严格不依赖多线程执行环境</strong>时，在不依赖多线程执行环境的要求上，还应保证语义一致。</li>
<li>否则，不保证接口提供的功能可用。</li>
</ul>
<p>　　YSLib 整体不依赖多线程执行环境。特定的依赖多线程执行的情形包括以下话题：</p>
<ul>
<li>使用 ISO C++ 线程环境（首先要求实现满足<a href="Development.zh-CN.html">整体要求</a>）：
<ul>
<li>运行时环境需要部署的线程支持库，参见以下章节对各个平台的说明。</li>
<li>特定的依赖线程环境语义的接口，参见具体组件的开发文档（如 <code>doc/YSLib.txt</code> ）及源代码中的 API 注释或以此<a href="BuildDocumentation.zh-CN.html">构建 API 文档</a>。</li>
</ul>
</li>
<li>特定的平台实现使用非 ISO C++ 线程模型或实现（不保证<a href="Terminology.zh-CN.html">平台中立</a>）：
<ul>
<li>不会作为对所有平台必要的公开接口。</li>
<li>YCLib 提供 POSIX API 封装。</li>
<li>其它实现细节参见开发文档 <code>doc/YCLib.txt</code> 等。</li>
</ul>
</li>
</ul>
<h3 id="链接时优化lto"><a class="header" href="#链接时优化lto">链接时优化(LTO)</a></h3>
<p>　　YSLib 默认在 release 构建配置下通过向编译器和链接器传递命令行参数 <code>-flto</code> 等启用 LTO 。若工具链不支持 LTO ，可能需要自行修改脚本去除相关选项——这不被正式支持。</p>
<p>　　MSYS2 的 MinGW 目标的 binutils-git 包的 <code>gnu-ar</code> 较早启用了 LTO 插件，可以直接使用。现在 MSYS2 的 MinGW 目标的 binutils 包也应支持。其它工具链需自行验证。</p>
<p><strong>注意</strong> <a href="http://gcc.gnu.org/gcc-4.9/changes.html">GCC 4.9 起使用 LTO 默认不启用 -ffat-lto-objects 选项</a>，因此需要链接器具有 LTO 插件支持，否则在启用 <code>-flto</code> 选项时会出现无法解析符号的链接错误。因为本项目当前只支持 GCC 5.0 以上的版本，使用 GCC 时这总是应当被注意。</p>
<p><strong>注意</strong> <a href="https://github.com/gcc-mirror/gcc/blob/master/gcc/lto-wrapper.c#L1309">GCC 的 LTO wrapper 默认使用 <code>make</code></a> ，若没有 <code>make</code> 也没有通过指定 <code>MAKE</code> <a href="Run.zh-CN.html">环境变量</a>替代，构建时使用 <code>-flto</code> 会失败。</p>
<h2 id="pcdsds"><a class="header" href="#pcdsds">PC/DS(DS)</a></h2>
<p>　　支持的构建环境：</p>
<ul>
<li>DS 交叉编译环境，包括
<ul>
<li>使用 <code>make</code> 的公共构建环境</li>
<li>ARM 目标平台 C/C++ 交叉编译环境</li>
<li>生成 .nds 文件的 <code>ndstool</code> 工具</li>
<li>环境变量 <code>DEVKITARM</code> 指定工具路径（见以下说明）</li>
</ul>
</li>
</ul>
<p>　　支持的运行环境：</p>
<ul>
<li>Nintendo/iQue DS[Lite/i/LL]
<ul>
<li>仅测试了 iQue DS Lite</li>
</ul>
</li>
<li>DeSmuME 0.9.9 <strong>（注意新版本因为<a href="http://wiki.desmume.org/index.php?title=Faq#How_can_I_run_homebrew_games_that_require_DLDI_patching_.3F">自动 DLDI</a> 存在缺陷，暂时不支持运行自制程序。）</strong></li>
</ul>
<p>　　环境变量 <code>DEVKITARM</code> 指定一个 POSIX 路径，其中的 <code>bin</code> 子目录下包括工具。示例（ POSIX shell 使用 Windows 路径）：</p>
<pre><code>export DEVKITARM=/C/devkitPro/devkitARM
</code></pre>
<p>　　建议使用发布时最新版本的 <a href="http://devkitpro.org/">devkitPro</a> 。</p>
<p>　　devkitPro 在 Windows 下提供 MSYS ，在 devkitPro 安装目录下 <code>msys/bin</code> 包含 <code>bash</code> 等程序。可把此路径添加到环境变量 <code>PATH</code> 。也可使用 MSYS2 替代。</p>
<p>　　发布和一般提交时仅测试 devkitPro 最新版本，目标平台三元组 arm-none-eabi。</p>
<h2 id="pcwin32"><a class="header" href="#pcwin32">PC(Win32)</a></h2>
<p>　　Windows 平台使用 Microsoft VC++ 构建。因为一些已知的问题，暂不正式支持。参见以下 MinGW32 平台的构建条件以获取 Windows 可执行文件。</p>
<p>　　但以下的部分信息和 MinGW 通用。</p>
<h3 id="windows-子系统subsystem"><a class="header" href="#windows-子系统subsystem">Windows 子系统(subsystem)</a></h3>
<p>　　<a href="http://zh.wikipedia.org/zh-cn/Windows_NT%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">Windows NT 内核以上支持不同的称为<em>子系统</em> 的用户模式运行时环境</a> ，主要包括 Win32 子系统、OS/2 子系统和 POSIX 子系统。</p>
<p>　　因为标准库实现以及 YFramework 的部分组件依赖 Win32 API ，YSLib 在 Windows 上的实现依赖 Win32 子系统。</p>
<p>　　Microsoft Visual C++ 提供 <a href="http://msdn.microsoft.com/zh-cn/library/fcc1zstk.aspx"><code>/SUBSYSTEM</code> 链接器选项</a>来指定不同的子系统。在此 <code>CONSOLE</code> 指定控制台程序，而 <code>WINDOWS</code> 指定非控制台的通常使用 GUI 的程序，它们都使用 Win32 子系统实现。</p>
<p>　　控制台程序和 GUI 程序的入口不同，也有一些行为上的不同。例如，启动控制台程序默认会显示命令行窗口；GUI 程序忽略命令行的交互式输入。</p>
<h3 id="操作系统版本"><a class="header" href="#操作系统版本">操作系统版本</a></h3>
<p>　　Windows 操作系统版本一般对（非交叉编译的）构建没有直接影响，但有以下例外：</p>
<p>　　GCC 的<strong>预编译头文件不保证对系统兼容</strong>：升级系统后可能出现错误，例如升级 Windows 10 1803 以后的系统，使用旧的预编译头文件（而不更改编译器二进制文件），可能出现以下内部错误：</p>
<pre><code>internal error in mingw32_gt_pch_use_address, at config/i386/host-mingw32.c:184: MapViewOfFileEx: 试图访问无效的地址。
</code></pre>
<p>　　此时删除所有预编译头文件，或不使用预编译头文件重新构建即可。类似的问题在其它的项目中<a href="https://jira.reactos.org/browse/CORE-8053">也是已知的问题</a>，使用类似的方式解决。</p>
<p>　　另外，<a href="https://github.com/msys2/MINGW-packages/issues/5067">部分 Windows 版本可能存在不明原因的内核缺陷导致类似的问题</a>。不仅限于构建，这些问题可能对运行也有影响。</p>
<p>　　硬件故障（如有缺陷的物理内存）也可能导致类似的故障，但这和使用的操作系统版本无关。</p>
<h3 id="预编译头文件"><a class="header" href="#预编译头文件">预编译头文件</a></h3>
<p>　　部分构建使用可选的预编译头文件。</p>
<h2 id="pcmingw32"><a class="header" href="#pcmingw32">PC(MinGW32)</a></h2>
<p>　　MinGW32 包含 32 位和 64 位宿主和目标平台。关于 MinGW 或 MinGW32 的称谓，参见<a href="https://github.com/FrankHB/pl-docs/blob/master/zh-CN/mingw-vs-mingw-v64.md">这里</a>的说明。</p>
<p>　　支持的构建环境：</p>
<ul>
<li>目标 32 位(i686) MinGW GCC 工具链。
<ul>
<li>支持不同的 MinGW 运行时
<ul>
<li><a href="https://sourceforge.net/projects/mingw-w64/">MinGW-W64</a> （目标三元组 i686-w64-mingw32 ）。</li>
<li><a href="http://mingw.org/">MinGW.org</a> （目标平台三元组 i686-pc-mingw32 ）</li>
</ul>
</li>
<li>要求标准库多线程支持，否则只支持构建 YBase ，不支持构建 YFramework 。
<ul>
<li>当前 <a href="https://gcc.gnu.org">GCC 官方</a>的 libstdc++ 只提供 POSIX 线程模型的支持，不支持 Win32 线程模型。</li>
<li>可考虑使用 <a href="https://github.com/lhmouse/mcfgthread">mcfgthread</a></li>
</ul>
</li>
<li>仅测试 Windows 上的本机构建（构建平台三元组同目标平台三元组）。
<ul>
<li>一般提交时仅测试 MinGW-W64 的发行版。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　非正式支持的构建环境：</p>
<ul>
<li>目标 64 位(x86_64) MinGW GCC 本机工具链（宿主和目标平台三元组 x86_64-w64-mingw32 或 x86_64-pc-mingw32 ）。</li>
<li>以上工具链中使用 LLVM 和 Clang++ 代替 GCC 。
<ul>
<li>仅测试 MSYS2 的 <code>MSYSTEM</code> 为 <code>MINGW32</code> 和 <code>MINGW64</code> 替换 GCC 。</li>
<li>虽然可支持，没有测试 <code>MSYSTEM</code> 为 <code>CLANG32</code> 和 <code>CLANG64</code> 的工具链。</li>
<li>当前 32 位平台暂不支持 LLD（ MSYS2 包 <code>mingw32/mingw-w64-i686-lld</code> ）。</li>
</ul>
</li>
<li>虽然可支持，没有测试 <code>MSYSTEM</code> 为 <code>UCRT64</code> 的工具链。</li>
<li>暂不在配置<a href="Tools/Scripts.zh-CN.html">脚本</a>以外支持和测试 <code>MSYSTEM</code> 为 <code>CLANGARM64</code> 的工具链（宿主平台三元组 aarch64-w64-mingw32 ）。</li>
</ul>
<p>　　对 i686 平台，存储库中 <code>YFramework/MinGW32/lib-i686</code> 目录用于保存外部依赖项 FreeType2 和修改版 FreeImage 的二进制文件。</p>
<p>　　对 x86_64 平台，需要自行编译依赖项。若构建环境存在可二进制兼容的 FreeType2 ，只需要编译修改版本的 FreeImage 。</p>
<p>　　支持的运行环境：</p>
<ul>
<li>Microsoft Windows XP 或以上版本的操作系统。
<ul>
<li>对于 64 位目标工具链构建的程序，需要 64 位操作系统。</li>
<li>当前默认发行的二进制文件使用 MSYS2 环境（详见以下小节）构建，要求 Microsoft Windows 7 64 位或以上版本的操作系统。</li>
</ul>
</li>
<li>构建环境匹配的附加运行库，默认支持的工具链要求包括以下动态库文件：
<ul>
<li><code>libwinpthread-1.dll</code></li>
<li><code>libgcc_s_dw2-1.dll</code></li>
<li><code>libstdc++-6.dll</code></li>
<li><code>libquadmath-0.dll</code>（自 build 932 起）</li>
</ul>
</li>
</ul>
<p>　　注意以上运行库未在发布版本中打包。此处依赖的详细说明参见开发文档 <code>doc/Dependencies.txt</code> @1.5.2 。</p>
<p>　　若缺少 DLL ，也可在 MinGW32 GCC 发行版中的 <code>bin</code> 目录下找到。</p>
<p><strong>特别注意</strong> 应使用对应的正确的线程模型（使用 POSIX 或 MCF 而不是 Win32 ，后者没有实现标准库的线程支持）以及异常模型（ i686 为 Dwarf2 和 SjLj 之一，特定构建版本相关）。运行时 DLL 不匹配会导致错误。</p>
<h3 id="msys2"><a class="header" href="#msys2">MSYS2</a></h3>
<p>　　建议使用 <a href="http://msys2.org/">MSYS2</a> 环境。</p>
<p>　　MSYS2 以从 <a href="https://wiki.archlinux.org/index.php/Main_page_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">Arch Linux</a> 移植的 <a href="https://wiki.archlinux.org/index.php/Pacman_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">pacman</a> 作为包管理器，可以直接通过命令行安装和移除不同的包，包括开发工具。</p>
<p>　　以下环境也可用于开发其它 MSYS2 或 MinGW32 应用（忽略标注为 YSLib 的步骤即可）。</p>
<h4 id="体系结构和命令行调用"><a class="header" href="#体系结构和命令行调用">体系结构和命令行调用</a></h4>
<p>　　一个 MSYS2 环境同时支持 MSYS2 和 i686(x86) 和 x86_64(x64) 的 MinGW32 三个目标平台。其中 MSYS2 目标类似 <a href="https://www.cygwin.com/">Cygwin</a> ，运行时依赖特定的 POSIX 兼容层 DLL （这里一般是 msys-2.0.dll ），性能往往较依赖 <a href="https://msdn.microsoft.com/library/abx4dbyh.aspx">MSVCRT</a> （默认版本现在 Windows 系统中应都已存在部署）的 MinGW32 目标低。所以不需要严格的 POSIX 兼容的应用尽量使用 MinGW 而不是 MSYS2 目标。</p>
<p>　　MSYS2 自身也存在不同的体系结构而成为目标平台。和 MinGW32 不同，每个基础环境是 i686 和 x86_64 之一。在 x64 Windows 上，可以通过部署多个基础环境，合理设置环境变量 <code>PATH</code> 来切换使用 i686 或 x86_64 （而 32 位 Windows 只支持 i686 ）路径；但一般情形下只需要使用其中之一。这个决定一般会作用到所有 MSYS2 程序，如 <code>bash</code> 。</p>
<p>　　不论是 i686 还是 x86_64 的 MSYS2 基础环境，都可以选择安装 i686 或 x86_64 的 MinGW32 目标的包，但因为使用不同的 MSYS2 程序，两者并非可完全替换。</p>
<p><strong>注意</strong> 因为基础环境中 <code>uname</code> 是位于 <code>/usr/bin</code> 的 MSYS2 程序，基础环境的体系结构会影响 <code>uname</code> 的结果而导致目标体系结构的自动判断结果不同，当前可能会影响后续需要的命令，详见 <a href="Sysroot.zh-CN.html">MinGW Sysroot 开发指令</a>。</p>
<p><strong>注意</strong> MSYS2 程序和不同体系结构的（本机或其它 MSYS2 ）程序混用可能出现问题。参见下文关于 MSYS2 程序运行问题的说明。</p>
<p>　　一个 MSYS2 环境中可能同时存在不同目标的程序，通过合理控制环境变量 <code>PATH</code> 的顺序或在调用时加前缀(prefix) 控制。例如 <code>/usr/bin/gcc.exe</code> 和 <code>/mingw32/bin/gcc.exe</code> 可能同时存在，分别是 MSYS2 和 i686 MinGW32 的 GCC ，可通过以下方式确定调用 MinGW32 GCC ：</p>
<ul>
<li>在 <code>PATH</code> 中使 <code>/mingw32/bin</code> 尽量靠前来指定 <code>gcc</code> 调用 MinGW32 而不是 MSYS2 GCC</li>
<li>若存在 <code>i686-w64-mingw32-gcc</code> 等明确目标平台的版本，一般可以直接在命令行中代替 <code>gcc</code></li>
<li>明确路径前缀，即使用 <code>/mingw32/bin/gcc</code> 代替 <code>gcc</code></li>
</ul>
<p>　　某些工具可能在附加路径前缀 <code>/mingw32</code> 指定此类程序的安装位置。但当前 YSLib 不提供工具控制这些部署方式，默认只使用第一种方式：手动配置 <code>PATH</code> 。</p>
<p>　　MSYS2 MinGW 工具链使用 POSIX 线程模型。</p>
<p>　　MSYS2 MinGW i686 工具链使用 Dwarf2 异常模型。</p>
<p>　　当前 YSLib 不支持 MSYS 目标。</p>
<h4 id="主要配置步骤"><a class="header" href="#主要配置步骤">主要配置步骤</a></h4>
<p>　　（某些步骤和原理也可参考<a href="https://sourceforge.net/p/msys2/wiki/MSYS2%20installation/">官方 Wiki</a> 。）</p>
<ul>
<li>进入<a href="https://sourceforge.net/projects/msys2/files/Base/">官方发布站点</a>/<a href="http://mirror.bit.edu.cn/msys2/Base/">北京理工大学镜像</a>/<a href="https://mirrors.tuna.tsinghua.edu.cn/msys2/distrib/">清华大学 TUNA 镜像</a>/<a href="http://mirrors.ustc.edu.cn/msys2/distrib/">中国科学技术大学开源软件镜像</a>的其中一个子目录下载 MSYS2 基础环境：
<ul>
<li>目录 <code>i686</code> 和 <code>x86_64</code> 针对 MSYS2 而非 MinGW32 目标。</li>
<li>一般尽量选择较新的 <code>x86_64</code> 版本。</li>
<li>如果有能解压缩 <code>.xz</code> 的软件，可以直接下载压缩包，否则选择 <code>.exe</code> 文件；对应版本内容一致。</li>
</ul>
</li>
<li>安装 MSYS2 基础环境到自定义的目录如 <code>C:\msys2</code> （以下称为<strong>MSYS2 根目录</strong>）。
<ul>
<li>注意 Win32 下 <code>PATH_MAX</code> 为 <code>260</code> ，此处最好避免过长的路径以使一些软件具有更好的兼容性。</li>
<li>对压缩包直接利用现有工具解压；对可执行文件直接执行安装。</li>
<li>之后，<strong>必须</strong>执行 MSYS2 根目录下的 <code>msys2_shell.bat</code> 确保完成安装。</li>
</ul>
</li>
<li>设置环境变量：
<ul>
<li>可总是使用 MSYS2 根目录下自带的批处理文件打开 终端（默认是 <code>mintty</code> ），会自动在终端环境的 <code>PATH</code> 变量前加入对应所需的路径，不需要另行设置。
<ul>
<li>对较新的版本（安装了 <code>filesystem-2016.05-2</code> 或更新版本的包）的 MSYS2 基础环境安装，分别运行启动脚本 <code>msys2_shell.cmd -msys</code> 、<code>msys2_shell.cmd -mingw32</code> 和 <code>mingw64_shell.cmd -mingw64</code> 进入对应的 MSYS2 、MinGW32 和 MinGW64 的 shell 。</li>
<li>对未更新 <code>filesystem-2016.05-2</code> 或更新版本的包的 MSYS2 旧版本基础环境安装，分别运行启动脚本 <code>msys2_shell.cmd</code> 、<code>mingw32_shell.bat</code> 和 <code>mingw64_shell.bat</code> 进入对应的 MSYS2 、MinGW32 和 MinGW64 的 shell 。</li>
</ul>
</li>
<li>也可直接一次性设置 Windows 系统环境变量，这样可以对其它命令行环境（如 <code>cmd</code> ）生效。
<ul>
<li><strong>注意</strong> 环境变量的值需要符合 Windows 的路径格式，每个路径之间以分号分隔。</li>
<li>需要设置 <code>bash</code> 所在的 MSYS 工具的目录（即 MSYS2 根目录下的 <code>/usr/bin</code> ）以及 MinGW 目标编译器和其它工具所在的目录（对 32 位的目标为 MSYS2 根目录下的 <code>/mingw32/bin</code> ）。</li>
<li><strong>注意</strong> 因为 MSYS 和 MinGW 是不同的目标，使用不同的 GCC （可能被同时安装），需要保证 MinGW 编译器被优先搜索，所以 MinGW 目录一般应在 MSYS 目录之前。</li>
</ul>
</li>
<li><a href="http://sourceforge.net/p/msys2/tickets/4/">一些构建环境可能会依赖环境变量 <code>MSYSTEM</code> 的值，MSYS2 根目录批处理文件进入的不同环境对此有不同的设置</a>。YSLib 中的构建脚本可使用此变量判断平台。MSYS2 中对应的启动脚本会自动完成这些设置。</li>
</ul>
</li>
<li>确保能搜索到正确的 MinGW 编译器。
<ul>
<li>可以进入 Shell 执行命令 <code>/usr/bin/which gcc</code> ，确定输出的结果为 MinGW 编译器（默认为 <code>/mingw32/bin/gcc.exe</code> 和 <code>/mingw64/bin/gcc.exe</code> 之一）而不是 MSYS 编译器（默认为 <code>/usr/bin/gcc.exe</code> ）</li>
<li>若已确保 MSYS 根目录下 <code>/usr/bin</code> 目录在环境变量 <code>PATH</code> 中，直接进入 <code>cmd</code> 或 Shell 直接执行 <code>which gcc</code> ，方法和效果与上述方法相同</li>
<li>可以直接在命令行执行 <code>gcc -v</code> 查看输出，确认 <code>Target: </code> 带有后缀 <code>-w64-mingw32</code></li>
</ul>
</li>
<li>建议手动执行 <code>pacman -Syu</code> 自行升级，或 <code>pacman -S</code> 安装所需的包的最新版本</li>
<li>若用于构建 YSLib ，建议<a href="GettingSources.zh-CN.html">获取源代码</a>后，进入 <code>bash</code> （此处也可以使用其它 Shell ）后运行 POSIX Shell 脚本 <code>Tools/msys2-pacman-update.sh</code> 以确保 YSLib 构建需要的依赖项被安装
<ul>
<li>脚本不会重复安装已经安装的包</li>
</ul>
</li>
</ul>
<p>　　上述脚本调用 MSYS2 的包管理器 <code>pacman</code> 分批下载安装或更新所需工具：首先安装必要的工具，其次安装可选（但推荐）的工具。具体内容详见脚本代码。若安装工具时需要确认，按 <code>Y</code> 并回车。</p>
<h4 id="配置安装源"><a class="header" href="#配置安装源">配置安装源</a></h4>
<p>　　官方镜像配置参见 <a href="https://github.com/Alexpux/MSYS2-packages/tree/master/pacman-mirrors">pacman-mirrors</a> 。</p>
<p>　　若 <code>pacman</code> 下载过慢，可用文本编辑器打开 MSYS 根目录下的 <code>/etc/pacman.d</code> 中的配置文件，编辑对应的镜像地址。如对于 32 位的 MinGW 包，在 <code>mirrorlist.mingw32</code> 的其它非注释行之前插入：</p>
<pre><code>## 清华大学 TUNA 镜像（ 2016-09-23 已变更，注意大小写）
Server = http://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/i686
## 中国科学技术大学开源软件镜像（之前曾停止更新，最后更新 2015-06-18 ；2015-11-01 已恢复）
Server = http://mirrors.ustc.edu.cn/msys2/mingw/i686
## 北京理工大学镜像（最后更新早于 2017-02-09）
Server = http://mirror.bit.edu.cn/msys2/REPOS/MINGW/i686
</code></pre>
<p>　　因为包 mingw-w64-x86_64-freetype 的 FreeType2 可二进制兼容，x86_64 平台只需要编译修改版本的 FreeImage 。</p>
<h4 id="msys2-程序运行问题"><a class="header" href="#msys2-程序运行问题">MSYS2 程序运行问题</a></h4>
<p>　　MSYS2 类似 Cygwin ，依赖 <code>fork</code> 调用创建新进程。这可能会出错。</p>
<p>　　在执行以下步骤（参考<a href="http://sourceforge.net/p/msys2/tickets/74/">这里</a>）后，重新运行程序：</p>
<ul>
<li>关闭窗口或用任务管理器终止 <code>sh.exe</code> 和 <code>bash.exe</code> 等进程并尽量确保没有基于 MSYS2 环境的其它程序正在被运行</li>
<li>执行 MSYS 根目录下的 <code>autorebase.bat</code></li>
</ul>
<p>　　也可以参考 <a href="https://www.cygwin.com/faq.html#faq.using.fixing-fork-failures">Cygwin 的解决方法</a>。</p>
<p>　　混用 x86/x64 程序（不管是 Win32 还是 MSYS 程序）导致的类似问题可能经以上步骤仍然无法修复，这可由 MSYS2 <a href="http://sourceforge.net/p/msys2/tickets/208/">在特定操作系统上的一个缺陷</a>引起。变通做法是只使用固定目标的程序，例如只使用 i686 MSYS 基础系统执行 i686 MinGW32 GCC 。注意 i686 MinGW32 GCC 是 x86 的 Win32 程序。尽管它不是 MSYS2 程序，但可在 LTO 时调用 MSYS2 程序 <code>make</code> ，这时候可能出错。</p>
<p>　　如果确定只使用少数程序，在命令行指定替换。例如 x86_64 的 MSYS2 bash 环境中使用 i686 MinGW32 GCC ，指定 LTO 调用的 <code>make</code> ：</p>
<pre><code>export MAKE=/path-to-another-msys2-root/mingw32/make
</code></pre>
<p>　　或直接替换所有 <code>make</code> ：</p>
<pre><code>export make=/path-to-another-msys2-root/mingw32/make
</code></pre>
<p><strong>注意</strong> <code>%SystemRoot%\System32\cmd.exe</code> 在 x64 Windows 下是 x64 程序，对应的 x86 版本是 <code>%SystemRoot%\SysWOW64\cmd.exe</code> 。</p>
<h3 id="gcc-with-the-mcf-thread-model"><a class="header" href="#gcc-with-the-mcf-thread-model">GCC with the MCF thread model</a></h3>
<p>　　也可使用 <a href="https://gcc-mcf.lhmouse.com/">MCF 线程模型构建的 GCC</a> ，基于 MinGW-W64 和 mcfgthread ，使用 MCF 线程模型。</p>
<p>　　这个发行版没有 <code>make</code> 。</p>
<p>　　需自行编译依赖项。</p>
<p>　　未在提交中测试。</p>
<h3 id="mingw-builds"><a class="header" href="#mingw-builds">MinGW-Builds</a></h3>
<p>　　也可使用 <a href="http://mingw-w64.sourceforge.net/">MinGW-W64</a> 发行版，如 <a href="http://sourceforge.net/projects/mingw-w64/files/latest/download">mingw-builds</a> ，并自行获得和配置脚本 <code>Tools/msys2-pacman-update.sh</code> 中被安装的工具。</p>
<p>　　需使用基于 POSIX 线程模型的版本，否则只可用 YBase 。</p>
<p>　　需自行编译依赖项。</p>
<p>　　当前未测试。</p>
<h3 id="nuwennet"><a class="header" href="#nuwennet">Nuwen.net</a></h3>
<p>　　对 x86_64 平台可使用 <a href="http://nuwen.net/mingw.html">newen.net</a> 提供的 MinGW 发行版，包含比较多的第三方库。</p>
<p>　　仍需自行编译依赖项以支持 YFramework （当前不支持）。</p>
<p>　　因为 15.2 之前的版本仅支持 Win32 线程模型，不支持 <code>std::thread</code> 等标准库线程 API ，不支持生成 YFramework ，只支持生成 YBase 。</p>
<p>　　当前未测试。</p>
<h3 id="windows-子系统subsystem-1"><a class="header" href="#windows-子系统subsystem-1">Windows 子系统(subsystem)</a></h3>
<p>　　基本内容参见以上 PC(Win32) 平台关于 Windows 子系统(subsystem) 的介绍。</p>
<p>　　在 MinGW 工具链的命令行中，选项 <code>-mconsole</code> 和 <code>-mwindows</code> 对应 Microsoft VC++ 工具链的子系统选项。若没有指定，一般默认为前者。通常 <code>-mwindows</code> 隐式使用一些附加的库，如 <code>-lgdi32 -lcomdlg32</code> 。和 VC++ 不同，当前使用的 MinGW 实现一般可以支持统一使用 <code>main</code> 作为入口，不需要特别修改。</p>
<p>　　对 <code>gcc</code> 或 <code>g++</code> ，使用 <code>-dumpspecs</code> 查看内建支持的 specs 。Clang/Clang++ 不适用 specs ，需要查看文档和源代码。</p>
<h2 id="pcandroid"><a class="header" href="#pcandroid">PC/Android</a></h2>
<p>　　支持的构建环境：</p>
<ul>
<li>Android 开发环境（仅测试 Windows x64 宿主环境），包括：
<ul>
<li>使用 <code>make</code> 的公共构建环境。</li>
<li>JDK（仅测试 Oracle JDK 1.8 ；注意 Android 仅支持部分 Java 8 特性）。</li>
<li>Android SDK 。</li>
<li>Android SDK Build-tools 。</li>
<li>Android NDK （仅使用独立工具链）。</li>
<li>用于打包 APK 的私钥（用 Tools/create-android-debug-keystore.sh 可生成默认私钥）。</li>
</ul>
</li>
</ul>
<p>　　支持的运行环境：</p>
<ul>
<li>Android 模拟器，运行操作系统 Android 5 （对应 API level 21 ），或更高版本（未测试，可能有兼容性问题）。</li>
<li>物理设备，操作系统要求同上（未正式测试，可能有兼容性问题）。</li>
</ul>
<h1 id="pclinux"><a class="header" href="#pclinux">PC/Linux</a></h1>
<p>　　当前仅用于可移植性测试。要点：</p>
<ul>
<li>当前仅测试 x86-64 （提供 FreeImage 二进制文件）</li>
<li>可用被支持版本的 G++ 或 Clang++</li>
<li>因为不提供 freetype2 的二进制库，需要保证 freetype2 库文件可用，可以通过 <code>pkg-source</code> 找到或位于 <code>/usr/lib</code> 路径中</li>
<li>使用 XCB 作为系统库，但功能不全</li>
</ul>
<p>　　Windows 10 可使用 <a href="https://zh.wikipedia.org/zh-cn/Windows_Subsystem_for_Linux">WSL(Windows Subsystem for Linux)</a> 。</p>
<p>　　注意 Windows 10 秋季创意者更新（版本 1709 ）的 WSL 存在<a href="https://github.com/Microsoft/WSL/issues/2606">已知可导致并行构建失败的缺陷</a> ，以及可能有的<a href="https://github.com/Microsoft/BashOnWindows/issues/2534">其它问题</a> ，本项目不针对这些问题单独提供变通。</p>
<h1 id="其它构建环境"><a class="header" href="#其它构建环境">其它构建环境</a></h1>
<p>　　集成开发环境是可选的，参见<a href="Build.zh-CN.html">构建</a>。</p>
<p>　　关于文档构建需要的依赖，参见<a href="BuildDocumentation.zh-CN.html">构建文档</a>。</p>
<p>　　关于执行工具脚本需要的环境，参见<a href="Tools/Scripts.zh-CN.html">脚本</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="获取源代码"><a class="header" href="#获取源代码">获取源代码</a></h1>
<p>　　建议通过 <a href="https://www.mercurial-scm.org/">Mercurial</a> 或 <a href="http://git-scm.com/">Git</a> 获取仓库中的最新代码。</p>
<p><strong>注意</strong> 构建过程可依赖源代码中不直接提供的二进制文件。详见<a href="Build.zh-CN.html">构建</a>中的说明。</p>
<h2 id="通过-mercurial"><a class="header" href="#通过-mercurial">通过 Mercurial</a></h2>
<p>　　安装 Mercurial ，使用命令行</p>
<pre><code>hg clone https://hg.osdn.net/view/yslib/YSLib YSLib
</code></pre>
<p>　　得到源代码的本地副本。</p>
<p>　　若已有本地副本，可使用</p>
<pre><code>hg pull -u
</code></pre>
<p>　　同步更新到最新版本。</p>
<p>　　或者安装 GUI 客户端（如 <a href="http://tortoisehg.bitbucket.org/">TortoiseHg</a> ）进行以上操作。具体使用参考软件附带的手册。</p>
<h2 id="通过-git"><a class="header" href="#通过-git">通过 Git</a></h2>
<p>　　安装 Git ，使用以下命令行之一得到源代码的本地副本：</p>
<pre><code>git clone https://github.com/FrankHB/YSLib.git YSLib
</code></pre>
<pre><code>git clone https://gitee.com/FrankHB/YSLib.git YSLib
</code></pre>
<p>　　若已有本地副本，可使用</p>
<pre><code>git pull
</code></pre>
<p>　　同步更新到最新版本。</p>
<p>　　或者安装 GUI 客户端（如 <a href="http://tortoisegit.net/">TortoiseGit</a> ）进行以上操作。具体使用参考软件附带的手册。</p>
<p><strong>注意</strong> Git 版本库是 Mercurial 版本库的镜像。不同版本库可具有不同的传输性能；使用合适的镜像可能大幅改善同步的体验。上述版本库都是官方维护的，大多数时候不需要担心同步时效性，但镜像版本库的更新仍可能比主版本库稍晚数分钟到数小时。</p>
<h2 id="下载已发布版本"><a class="header" href="#下载已发布版本">下载已发布版本</a></h2>
<p>　　<a href="Releases.zh-CN.html">已经发布的版本</a>列出了可以直接下载的测试发布版本。</p>
<p>　　可以在以下<a href="Archives.zh-CN.html">归档</a>中获得特定发布版本的源代码和部分二进制文件。</p>
<p>　　注意这些代码通常比版本库中的旧。在 <a href="Releases.zh-CN.html">Beta 阶段</a>前也不表示更稳定。</p>
<h2 id="文件权限"><a class="header" href="#文件权限">文件权限</a></h2>
<p><strong>已知缺陷</strong> Windows 上的 Mercurial 不跟踪可执行位。</p>
<p>　　若在其它环境中因此无法执行脚本，在版本库根目录下执行以下 shell 命令变通：</p>
<pre><code>find . -type f -name &quot;*.sh&quot; -exec chmod +x {} \;
</code></pre>
<p>　　因为约定<a href="Tools/Scripts.zh-CN.html">总是使用 <code>*.sh</code> 作为可执行的脚本的扩展名</a>，不需要考虑其它文件。</p>
<h2 id="历史资源"><a class="header" href="#历史资源">历史资源</a></h2>
<p>　　因为代码托管站点不再提供服务，以下资源已过时：</p>
<ul>
<li>曾经可用，当前服务已经停止：
<ul>
<li><a href="https://code.google.com/">Google Code</a>: <code>hg clone https://yslib.googlecode.com/hg/ YSLib</code></li>
<li><a href="http://gitcafe.com">GitCafe</a>: <code>git clone https://gitcafe.com/FrankHB/YSLib.git YSLib</code></li>
</ul>
</li>
<li>已经无法同步：
<ul>
<li><a href="https://bitbucket.org">Bitbucket</a>: <code>hg clone https://bitbucket.org/FrankHB/yslib YSLib</code></li>
</ul>
</li>
<li>被取代：
<ul>
<li><a href="http://git.oschina.net">OSChina</a>: <code>git clone http://git.oschina.net/FrankHB/yslib.git YSLib</code>（使用 Gitee 代替）</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="准备-1"><a class="header" href="#准备-1">准备</a></h1>
<ul>
<li>参见<a href="Development.zh-CN.html">开发说明</a></li>
<li>参见<a href="ProjectDependencies.zh-CN.html">项目依赖性</a>了解 YSLib 子项目之间的联系</li>
</ul>
<h1 id="外部依赖项构建"><a class="header" href="#外部依赖项构建">外部依赖项构建</a></h1>
<p>　　这个步骤是可选的。若已获取二进制的库文件，可以跳过。</p>
<p>　　YSLib 发布的文件和对应使用的外部依赖项（包括二进制的库文件）可以<a href="Archives.zh-CN.html">从归档仓库下载</a>。</p>
<p>　　进入 <code>3rdparty</code> 对应库的目录查看 <code>Readme</code> 文件说明。按此说明进行构建，一般方法为：</p>
<ul>
<li>自行获取指定的公开发行的源代码</li>
<li>复制 <code>3rdparty</code> 库的目录中的文件到源代码，替换源代码中的原始文件</li>
<li>运行指定的构建脚本命令行</li>
</ul>
<h1 id="库和示例程序构建"><a class="header" href="#库和示例程序构建">库和示例程序构建</a></h1>
<p>　　以下主要描述构建项目的默认目标：库和示例程序 <code>YSTest</code> 。对特定的构建方式，支持附加的其它目标。</p>
<p><strong>注意</strong> 除了 <a href="Tools/SHBuild.zh-CN.html">SHBuild</a> 外，当前没有实现子项目间的依赖管理。由于<a href="Releases.zh-CN.html">非正式版不保证二进制兼容性</a>，直接增量构建可能在更新代码后失败。此时可手动清理构建生成的中间目录即 <code>build</code>。</p>
<p>　　另见<a href="BuildDocumentation.zh-CN.html">构建文档</a>。</p>
<h2 id="使用构建工具和脚本"><a class="header" href="#使用构建工具和脚本">使用构建工具和脚本</a></h2>
<p>　　这是宿主平台的建议构建方式，支持所有的构建目标。</p>
<p>　　基本使用详见 <a href="Tools/SHBuild.zh-CN.html">SHBuild</a> 和 <a href="Sysroot.zh-CN.html">Sysroot</a> 。</p>
<p>　　b600 起用于发布和测试的二进制文件使用 SHBuild 构建。</p>
<p>　　当前版本的构建使用以下方式：</p>
<ul>
<li>调用 <code>Tools/install-sysroot.sh</code> 构建 Sysroot 。
<ul>
<li>确保环境变量 <code>SHBuild_UseDebug</code> 和 <code>SHBuild_UseRelease</code> 的值非空。</li>
<li>确保环境变量 <code>SHBuild_NoStatic</code> 、<code>SHBuild_No3rd</code> 和 <code>SHBuild_NoDev</code> 的值为空。</li>
</ul>
</li>
<li>在 Sysroot 部署完成后，设置环境变量 <code>PATH</code> 包含 Sysroot 布局下的<a href="Sysroot.zh-CN.html">二进制目录</a>。
<ul>
<li>对配置名 <code>debug-static</code>、<code>debug</code>、<code>release-static</code> 和 <code>release</code> ，以配置名作为第一参数分别调用 <code>YSTest/SHBuild-YSTest.sh</code> 构建示例项目 <code>YSTest</code> 的各个配置。</li>
<li>类似地，调用 <code>YDE/install-all.sh</code> 构建 <a href="YDE.zh-CN.html">YDE</a> 中所有包的各个配置。</li>
</ul>
</li>
</ul>
<h2 id="microsoft-visual-studio"><a class="header" href="#microsoft-visual-studio">Microsoft Visual Studio</a></h2>
<p>　　源代码包含 Microsoft Visual Studio 2012/2013 解决方案 .sln 文件。可以直接生成解决方案。注意若修改被依赖项目代码后直接生成，依赖项目也不会重新编译，需要手动清除或重新编译。</p>
<p>　　当前包含了平台中立项目（便于源代码管理，不实际生成）、DS 项目 、MinGW32 项目和 Android 项目，但仅支持生成使用 make 的平台（ DS 和 Android ，需要对应的工具链支持）。因为正确支持的语言特性不足，Visual Studio 使用的编译器不能正常生成 Win32 项目。</p>
<p>　　使用 Microsoft Visual Studio 打开文件，需特定的环境变量以保证使用 makefile 的项目可构建。以下（使用 兼容 <code>bash</code> 的）路径仅为示例：</p>
<p>　　DS 项目：</p>
<pre><code>DEVKITPRO=/opt/devkitpro
</code></pre>
<p>　　Android 项目：</p>
<pre><code>ANDROID_SDK = /d/Android/sdk
PATH = /d/clang-android/bin:/c/Program\ Files/Java/jdk1.8.0_211/bin:$PATH
</code></pre>
<p><strong>注意</strong> Visual Studio 项目使用的 makefile 命令行依赖 <code>bash</code> 以及时检测到错误停止生成，可参见<a href="Prerequisitions.zh-CN.html">先决条件</a>配置宿主环境。</p>
<p>　　支持生成的 Visual Studio 项目包含依赖性，不需要另行设置；也支持清理命令。</p>
<h2 id="codeblocks"><a class="header" href="#codeblocks">Code::Blocks</a></h2>
<p>　　从 b217 (2011-06-13) 起支持。</p>
<p>　　源代码包含 Code::Blocks 工作空间 .workspace 文件，建议使用 Code::Blocks 12.11 或以上版本打开。</p>
<p><strong>注意</strong> 打开工作空间后直接生成，其中的项目不都能成功构建，因为并非所有项目都保证能生成。项目名没有平台后缀的不用于构建，仅作为项目原型便于开发。</p>
<p>　　当前包含了平台中立项目（项目名不含下划线，便于源代码管理，不实际生成）、DS 项目和 MinGW32 项目，支持构建 DS 项目和 MinGW32 项目，每个分别包含 debug 和 release 配置。除此之外，MinGW32 项目还支持 debug_DLL 配置和 release_DLL 配置，用于生成动态链接库或使用动态链接库生成可执行文件。</p>
<p>　　对于 DS 可以分别编译其它各个项目，但不能运行。可以在工具菜单添加 DeSmuME 命令行运行。</p>
<p>　　b599 (2015-05-21) 起支持通过<a href="Tools/Scripts.zh-CN.html">脚本 GenerateProjects.sh</a> 生成 .cbp 文件。和 Visual Studio 不同，项目文件的内容不保证最新。这些文件以后仅保证在<a href="Releases.zh-CN.html">发布版本</a>更新。</p>
<p>　　b600 前用于发布和测试的二进制文件使用此方式构建。因为编译时使用的文件路径不同等原因，构建的二进制文件和 SHBuild 不完全等价。</p>
<h2 id="make-命令行"><a class="header" href="#make-命令行">make 命令行</a></h2>
<p>　　和 Visual Studio 类似，Code::Blocks 项目文件仅用于查看项目文件，当前不作为首要的构建途径被支持。</p>
<p>　　虽然 Code::Blocks 具有模块化设计，但仍有一些欠缺可配置性及文档的逻辑被集成在核心（使用 C++ 实现，且不容易改动）而造成问题，如：</p>
<ul>
<li>头文件搜索使用字符串匹配。
<ul>
<li>这直接导致在编辑器中无法定位宏名形式的 <code>#include</code> 的路径。</li>
<li>这种形式实际被 YFramework 及 FreeType 使用。</li>
</ul>
</li>
<li>在运行时环境插入 <code>PATH</code> 环境变量的前缀，不保证和构建时相同也不可由用户指定去除。
<ul>
<li>前缀包括 <code>.</code> 、链接器和调试器的可执行文件所在的路径。</li>
<li>因为是前缀，当前路径及链接器和调试器可执行文件的路径直接污染环境变量，无法通过其它设置去除。</li>
<li>当这些路径具有和构建时不同版本的动态库时，使用 Code::Blocks 运行程序会使用错误的动态库。</li>
<li>因此，使用 Code::Blocks 运行程序时，为了使用正确的动态库，不同的版本的动态库不能和工具链共存。</li>
</ul>
</li>
</ul>
<p>　　由于这些自身的局限性，Code::Blocks 不适合作为现代的集成开发环境，没有在现状以外其它的改进支持的计划。</p>
<p>　　使用 <code>make</code> 构建适用于使用 Makefile 的平台，当前包括 DS 和 Android 。</p>
<p>　　设 $Configuration 是生成配置名称，则</p>
<p>　　在各个项目目录下运行</p>
<pre><code>make -r BUILD=$Configuration
</code></pre>
<p>　　即可生成。</p>
<p>　　在各个项目目录下运行</p>
<pre><code>make -r BUILD=$Configuration rebuild
</code></pre>
<p>　　即可重新生成。</p>
<p>　　在各个项目目录下运行</p>
<pre><code>make -r BUILD=$Configuration clean
</code></pre>
<p>　　即可清除生成。</p>
<p><strong>注意</strong> 因为不同子项目的 makefile 之间不追溯依赖关系，直接运行 makefie 需明确依赖顺序，参见<a href="ProjectDependencies.zh-CN.html">项目依赖性</a>。</p>
<p>　　和其它构建方式类似，YFramework 依赖于 YBase 。对 DS 项目，注意附加的项目依赖性以确定生成顺序：</p>
<ul>
<li>YSTest/DS_ARM9 依赖 YFramework 。</li>
<li>YSTest 依赖 YSTest/DS_ARM7 和 YSTest/DS_ARM9 。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="准备-2"><a class="header" href="#准备-2">准备</a></h1>
<ul>
<li><a href="GettingSources.zh-CN.html">获取源代码</a></li>
<li>安装带有图形界面前端的 Doxygen</li>
<li>安装 Graphviz/Dot 工具（见注意事项）</li>
</ul>
<h1 id="构建"><a class="header" href="#构建">构建</a></h1>
<p>　　使用 Doxywizard(Doxygen GUI) 打开目录下的 Doxygen 文件，选择 Run 选项卡，点击 Run doxygen 按钮等待完成即可。</p>
<p>　　构建文档的内容主要来自源文件中的注释。</p>
<p>　　默认的输出路径在 <code>doc/html</code> 。打开其中的 <code>index.html</code> 进入主页。</p>
<h1 id="注意事项"><a class="header" href="#注意事项">注意事项</a></h1>
<ul>
<li>Dot 工具的路径是被硬编码的。
<ul>
<li>如果不确定安装的位置，使用前清空 <code>DOT_PATH</code> ，并设置 <a href="Run.zh-CN.html"><code>PATH</code> 环境变量</a>使二进制文件能被找到。可以直接编辑 Doxyfile 或者在 Expert 选项卡的 Dot 项中设置 <code>DOT_PATH</code> 。</li>
</ul>
</li>
<li>当前配置使用 <code>DOT_IMAGE_FORMAT</code> 为 <code>svg</code> 而不是默认的 <code>png</code> ，生成的文件不支持 Intenet Explorer 9 以前版本的浏览器。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述"><a class="header" href="#概述">概述</a></h1>
<p>　　这是单列的测试顶级子项目。</p>
<p>　　预期覆盖整个项目中的各个<a href="Features.zh-CN.html">库</a>，但目前仅测试 YBase 。框架部分的主要测试由示例程序 YReader 完成。</p>
<h1 id="准备-3"><a class="header" href="#准备-3">准备</a></h1>
<ul>
<li>参见<a href="Build.zh-CN.html">构建</a></li>
<li>参见<a href="Development.zh-CN.html">开发说明</a></li>
<li>配置满足<a href="Prerequisitions.zh-CN.html">先决条件</a>的对应平台运行环境</li>
</ul>
<h1 id="依赖"><a class="header" href="#依赖">依赖</a></h1>
<p>　　当前测试脚本 <code>test.sh</code> 依赖<a href="Tools/Scripts.zh-CN.html">工具脚本</a> ，并使用相同的解释环境。</p>
<h1 id="运行"><a class="header" href="#运行">运行</a></h1>
<p>　　测试脚本 <code>test.sh</code> 构建测试程序并运行。</p>
<p>　　当前测试程序只包括 YBase::YStandardEx 的相关内容。</p>
<p>　　以标准输出显示测试项的数量和每个测试项的结果。通过为 <code>PASS.</code> ，失败为 <code>FAIL.</code> 。</p>
<h2 id="配置"><a class="header" href="#配置">配置</a></h2>
<p>　　变量 <code>TestDir</code> 表示当前测试使用的目录，默认值即为 <code>test</code> 目录。</p>
<p>　　和工具脚本类似，变量 <code>SHBuild_ToolDir</code> 指定工具脚本目录。测试脚本据此包含构建配置所需的工具脚本。因为默认定位到此路径，不需要依赖 <a href="Sysroot.zh-CN.html">Sysroot</a> 安装脚本。</p>
<p>　　在包含工具脚本前，测试脚本使用（当前被直接硬编码在脚本中）以下配置：</p>
<pre><code>CXXFLAGS_OPT_UseAssert=true
SHBuild_Debug=debug
SHBuild_NoAdjustSubsystem=true
</code></pre>
<p>　　脚本不会调用 <code>SHBuild</code> 。脚本直接接受的参数附加为使用 <code>$CXX</code> 构建时命令行选项。</p>
<p>　　和构建 YBase 和 YFramework 库的工具脚本类似，测试脚本支持预编译头文件。但因为默认直接使用 <code>TestDir</code> 作为输出路径，修改配置后可能需要手动清理 <code>gch</code> 文件以免预编译头文件失效。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="准备-4"><a class="header" href="#准备-4">准备</a></h1>
<ul>
<li>参见<a href="Build.zh-CN.html">构建</a></li>
<li>参见<a href="Development.zh-CN.html">开发说明</a></li>
<li>配置满足<a href="Prerequisitions.zh-CN.html">先决条件</a>的对应平台运行环境</li>
</ul>
<h1 id="平台环境"><a class="header" href="#平台环境">平台环境</a></h1>
<p>　　以下适用包含 YSLib 程序和其它程序的构建和运行环境。并非每一个程序都需要区分特定平台，一些程序的行为是平台中立的。关于 YSLib 版本库内的及安装 YSLib 部署的脚本的运行环境，另见<a href="Development.zh-CN.html">脚本运行</a>的相关说明。</p>
<h2 id="yslib-程序"><a class="header" href="#yslib-程序">YSLib 程序</a></h2>
<p><strong>注意</strong> 示例程序最大化地使用了 YSLib 的平台模拟特性，支持特定的<a href="Development.zh-CN.html">目标平台</a>在运行时作为<a href="Development.zh-CN.html">宿主平台</a>对另一平台的<a href="Development.zh-CN.html">平台模拟</a>，即运行的原生示例程序和被模拟平台的原生程序保持基本相同的功能效果；但并不保证所有其它 YSLib 程序同样支持。</p>
<p>　　被正式支持的平台模拟列表如下：</p>
<ul>
<li>PC 模拟 DS</li>
</ul>
<p>　　被非正式支持的平台模拟列表如下：</p>
<ul>
<li>Android 模拟 DS</li>
</ul>
<h1 id="硬件资源要求"><a class="header" href="#硬件资源要求">硬件资源要求</a></h1>
<p>　　占用的硬件资源不确定，取决于平台配置以及具体应用程序。</p>
<p><strong>注意</strong> 特定平台可能有额外限制，详见各个平台运行时环境的说明。</p>
<h1 id="环境变量-1"><a class="header" href="#环境变量-1">环境变量</a></h1>
<p>　　<a href="https://zh.wikipedia.org/zh-cn/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量</a>是程序的实现环境（典型地，如操作系统）的运行环境提供的一种机制。程序在运行时可能访问这些环境变量，以提供不同的行为，或在程序之间、程序与外部环境之间传递信息。</p>
<p><strong>注释</strong> 非宿主实现的平台可能不支持环境变量。本项目的程序在这些平台上不使用环境变量。</p>
<p>　　没有依赖这些具体应用或其提供的实现环境时，如有可能，应当避免使用依赖这些具体的使用方式。</p>
<p>　　一些情形程序通过判断特定的环境变量配置功能。特别地，设置特定的环境变量为非空值可能启用功能。</p>
<p>　　一般地，只要环境变量被支持，一个环境变量总是能被设置为非空的字符串（至少本项目支持的平台能假定如此）。但是，访问环境变量的行为仍可能依赖具体平台的不同细节，而影响可移植性：</p>
<ul>
<li>环境变量的名称可能是大小写敏感或不敏感的：名称仅有大小写不同的环境变量可能被视为不同或同一个。
<ul>
<li>例如，Windows（指 Win32 环境，下同）的环境变量名对大小写不敏感。其它大部分实现环境对环境变量的大小写敏感。</li>
<li>因此，作为公开接口提供的环境变量应当总是具有固定的、大小写敏感的拼写，且避免出现仅有不同大小写的可能因同名冲突的不同环境变量名。</li>
</ul>
</li>
<li>环境变量可被设置为空值。具有空值的环境变量可能会或不会被视为没有被设置（或被取消设置）的环境变量。
<ul>
<li>例如，设置 Windows 的某个环境变量为空值，效果即删除环境变量。其它大部分实现环境中，设置环境变量为空值，环境变量不被删除。</li>
<li>一些环境可能指定不同的行为，如<a href="https://www.msys2.org/news/#2022-09-24-changed-behavior-for-empty-env-vars">较新版本的 MSYS2 支持配置 <code>MSYS=noemptyenvvalues</code> </a> 。</li>
<li>因此，不直接判断环境变量被设置，而判断环境变量是否为空值。</li>
</ul>
</li>
<li>环境变量名可能具有不同的限制。
<ul>
<li>仅假定 ISO C 基本字符集的标识符（大小写拉丁字母、数字和下划线 <code>_</code> ）可被用于环境变量名。</li>
</ul>
</li>
<li>具体环境变量的访问方式可能和具体宿主平台中访问环境变量的具体程序相关，如：
<ul>
<li><a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_05_03">POSIX shell 变量</a>引用 <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html#tag_08">XBD 环境变量</a>，可使用 <code>$VAR</code> 访问变量 <code>VAR</code> 的值。</li>
<li><a href="https://learn.microsoft.com/windows-server/administration/windows-commands/set_1">Windows <code>set</code> 命令</a> 显示或设置环境变量，可使用 <code>%VAR%</code> 访问变量 <code>VAR</code> 的值。</li>
<li><a href="https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_environment_variables">Powershell 支持环境变量</a>，可通过 <code>$Env:VAR</code> 访问变量 <code>VAR</code> 的值。</li>
</ul>
</li>
<li>以下<em>周知的(well-known)</em> 环境变量因在各个被本项目支持的宿主实现平台普遍可用，而可被直接使用，但使用方式并非完全相同：
<ul>
<li><a href="https://zh.wikipedia.org/zh-cn/PATH_%28%E5%8F%98%E9%87%8F%29"><code>PATH</code></a> 表示程序中执行（外部程序提供的）命令使用的搜索路径。
<ul>
<li>对 Windows ，另见 <a href="https://learn.microsoft.com/windows-server/administration/windows-commands/path"><code>path</code> 命令</a>（其中使用 <code>%PATH%</code> 引用环境变量 <code>PATH</code> ）。</li>
<li>另见 <a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_09_01_01">POSIX</a> 的规定。</li>
<li><code>PATH</code> 的值可支持多个路径名称，其中分隔符不一定相同，如 Windows 使用 <code>;</code> ，而 POSIX 使用 <code>:</code> 。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　除非需要依赖具体实现环境或另行指定，本项目中提供的环境变量应当避免上述依赖差异。</p>
<h1 id="文件系统"><a class="header" href="#文件系统">文件系统</a></h1>
<p>　　为最大化可移植性，原则上 YSLib 的程序逻辑<strong>不依赖自身组件具有显式编码的具体文件路径</strong>，因此默认不要求在具体系统约定的周知(well-known) 的文件系统位置（如 <a href="https://docs.microsoft.com/zh-cn/windows/win32/dlls/dynamic-link-library-search-order">Windows DLL 搜索路径</a>中的目录和 <a href="https://zh.wikipedia.org/zh-cn/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86">FHS</a> 定义的目录）部署。但具体平台配置可以自行限定目录布局作为默认运行时环境，如 <a href="Sysroot.zh-CN.html">Sysroot</a> 。其中外部文件可有默认路径，参见以下相关章节。</p>
<p>　　YSLib 中的库使用的文件系统路径具有以下约束：</p>
<ul>
<li>不依赖兼容 POSIX 的文件系统和路径表示。
<ul>
<li>特别地，不依赖文件系统是否具有文件名的大小写敏感性。</li>
<li><strong>推论</strong> 为保证可移植性，文件系统路径大小写敏感，需要显式区分而加以明确。</li>
<li>这样仍可兼容 FAT 等大小写不敏感的文件系统。</li>
</ul>
</li>
<li>要求支持符合 YSLib 项目规范的开发（参见项目的 <code>doc/ProjectRules.txt</code> ）。</li>
</ul>
<p>　　一般地，YBase 不要求文件系统访问；使用 YFramework 框架的程序，由 YFramework 中的框架初始化等逻辑引入文件系统访问。</p>
<h1 id="二进制依赖项"><a class="header" href="#二进制依赖项">二进制依赖项</a></h1>
<p>　　按以上文件路径约定，构建得到的目标程序没有预设特定的位置限制，可按需转移。</p>
<p>　　运行程序前，应确保程序能找到二进制依赖项：</p>
<ul>
<li>确保<a href="Prerequisitions.zh-CN.html">先决条件</a>中的依赖项可以在 <code>PATH</code> 环境变量的目录被找到，或者复制到程序所在的目录。</li>
<li>对于静态链接 YFramework 和 YBase 程序，不需要其它二进制程序文件的部署。</li>
<li>使用 DLL 的程序可能依赖 YFramework.dll 和 YBase.dll ，或者 debug 配置的 YFrameworkd.dll 和 YBased.dll 。这些库已经在 sysroot 的 <code>bin</code> 目录下安装，因此可以直接把 <code>bin</code> 目录加入 <code>PATH</code> 环境变量，而不必复制或移动库文件。</li>
</ul>
<p><strong>说明</strong> 在任意被支持的平台上，YSLib 避免使用导致在特定平台上被特殊处理且无法可靠避免这种行为而确保兼容性一致的外部依赖项名称（若因为外部环境更新导致此类问题，则需在 YSLib 的新版本适当修改后支持）。例如，支持 <a href="http://www.geoffchappell.com/studies/windows/win32/apisetschema/index.htm">API Set Schema</a> 的 Windows 版本加载 DLL 时，<a href="https://stackoverflow.com/a/47530043/2307646"><code>LdrLoadDll</code> 解析以 <code>api-</code> 或 <code>EXT-</code> 起始的文件名进行重定位</a> ，因此设计时确保外部依赖项对应的文件名不以这些前缀起始。</p>
<h1 id="外部文件"><a class="header" href="#外部文件">外部文件</a></h1>
<p>　　外部文件包括：</p>
<ul>
<li>在文件系统中部署的外部二进制依赖项。</li>
<li>配置文件：可被修改以改变程序的运行时行为。</li>
<li>其它数据文件。</li>
</ul>
<p>　　数据文件提供程序运行时所需的必要或可选的信息。配置文件可能作为数据文件使用。</p>
<p>　　外部文件的路径应符合前述关于文件路径的约定。</p>
<h2 id="文件格式"><a class="header" href="#文件格式">文件格式</a></h2>
<p>　　除非另行指定，使用以下文件格式：</p>
<ul>
<li>配置文件是内容为 <a href="Features/NPL.zh-CN.html">NPL</a> 配置的 UTF-8 文本文件，具有 UTF-8 BOM</li>
<li>其它数据文件为二进制文件</li>
</ul>
<h2 id="文件系统布局-1"><a class="header" href="#文件系统布局-1">文件系统布局</a></h2>
<p>　　除配置文件可能指定默认的具体位置（详见下文）外，YFramework 程序的不需依赖特别的文件系统布局。</p>
<p>　　除非另行指定（暂无），YFramework 不创建文件系统目录。</p>
<p>　　<a href="Sysroot.zh-CN.html">Sysroot</a> 提供类 UNIX 系统使用的布局作为可选项。</p>
<h2 id="文件访问约定"><a class="header" href="#文件访问约定">文件访问约定</a></h2>
<p>　　除非另行指定，YFramework 对外部文件的访问适用本节约定。</p>
<p><strong>注意</strong> 除非另行指定，程序访问配置文件的时机是未指定的。</p>
<h3 id="基本要求"><a class="header" href="#基本要求">基本要求</a></h3>
<p>　　应确保外部文件满足以下条件，否则运行时出错，或在另行指定（暂无）的特定情形下不保证行为符合预期：</p>
<ul>
<li>具有适当的（可读和可写）权限以允许程序访问其内容及元数据，或在必要时进行创建。</li>
<li>需要写入的文件所在的位置应该具有足够的空间。</li>
</ul>
<h3 id="文件映射和内存映像"><a class="header" href="#文件映射和内存映像">文件映射和内存映像</a></h3>
<p>　　文件读写使用 YCLib::MemoryMapping ，优先使用内存文件映射。在文件无法访问时，部分文件可能使用内存映像代替。</p>
<p><strong>注意</strong> 除非使用内存映像，应确保外部文件的内容可读；否则，可在之后引发无法恢复的错误；参见当前实现使用的 <a href="Features.zh-CN.html">YCLib::MemoryMapping 的注意事项</a>。</p>
<h3 id="共享文件"><a class="header" href="#共享文件">共享文件</a></h3>
<p>　　宿主平台使用协同锁(advisory lock) 对并发文件内容访问提供有限的共享保护，避免基于 YFramework 程序并发访问外部文件时的竞争。不使用强制锁(mandatory lock) 以利于提升性能。</p>
<p><strong>注意</strong> 除检查文件创建外，不提供相关文件系统元数据并发访问保护。</p>
<p><strong>注意</strong> 因为锁定非强制，宿主不保证其它机制访问文件的程序（如非 YFramework 程序）在这里产生冲突，有可能破坏文件内容。用户应避免对相关文件造成此类访问的破坏性编辑。</p>
<p><strong>注意</strong> 因为访问顺序未指定，不同 YFramework 实例可能修改相同的文件（如配置文件）而导致外部可见的影响。</p>
<p>　　未来可能添加完整的对共享文件内容修改的传递和检查的机制。</p>
<h2 id="配置生成和输入输出"><a class="header" href="#配置生成和输入输出">配置生成和输入输出</a></h2>
<p>　　配置文件可能提供默认内容，在外部文件不存在或读取失败时尝试创建。默认内容一般由框架直接提供。</p>
<ul>
<li>自动生成并保存外部文件时需确保程序可在指定目录下创建文件。
<ul>
<li>具体目录视具体文件而定。</li>
<li>可在运行前部署正确的配置文件以避免自动生成。</li>
</ul>
</li>
<li>若无法满足，生成保存在内存中的临时配置映像之后的修改不会保存到外部文件。
<ul>
<li><strong>注意</strong> 某些版本的 Windows （如 Windows Vista 以后的版本）在特定的目录（如 <code>%PROGRAMFILES%</code> ）中创建文件默认需要管理员权限。</li>
</ul>
</li>
</ul>
<h2 id="公共配置文件"><a class="header" href="#公共配置文件">公共配置文件</a></h2>
<p>　　文件 <code>yconf.txt</code> 为 YFramework 程序的公共<a href="Tutorial/Configuration.zh-CN.html">配置</a>文件，在框架初始化时，先于其它配置文件之前处理。若不存在，提供默认内容。其位置是预先指定的，和平台相关。详见下一章对框架初始化的说明。</p>
<p>　　为避免 YFramework 程序在运行时出错或行为不符合预期，注意确保满足前述访问约定的要求。若无法在程序映像文件所在目录（详见以下关于框架初始化的说明）创建文件，配置不能保存到外部文件。</p>
<p>　　在 Win32 上一个正确的公共配置文件的内容可能是这样的：</p>
<pre><code>YFramework
(
	DataDirectory &quot;C:\Data\\&quot;
)
(
	FontDirectory &quot;C:\Windows\Font\\&quot;
)
(
	FontFile &quot;C:\Windows\Font\FZYTK.TTF&quot;
)
</code></pre>
<p>　　这里指定的路径分别为数据目录路径、字体文件目录路径和字体文件路径。</p>
<h2 id="数据目录"><a class="header" href="#数据目录">数据目录</a></h2>
<p>　　用于存放 YFramework 程序必要的数据以及运行时的配置。</p>
<p>　　通过 <code>yconf.txt</code> 中项 <code>DataDirectory</code> 的值指定数据目录的路径。</p>
<p>　　自动生成的配置中数据目录的默认路径如下：</p>
<ul>
<li>DS ： <code>/Data</code> 目录</li>
<li>Win32 ：同默认生成配置文件所在的目录</li>
<li>Android ： SD 卡目录（自动检测同上）下的 <code>Data</code> 目录</li>
<li>其它平台：当前工作目录</li>
</ul>
<p>　　当前可用数据文件位于 YSLib 存储库的 <code>Data</code> 目录下，可自行复制到数据目录。</p>
<h3 id="chrlib-的-gbk-转换例程初始化"><a class="header" href="#chrlib-的-gbk-转换例程初始化">CHRLib 的 GBK 转换例程初始化</a></h3>
<p>　　对使用 CHRLib 提供的 GBK 编码转换的程序，需保证数据目录下存在数据文件 <code>cp113.bin</code> 。</p>
<p>　　对 Win32 平台，CHRLib 初始化 GBK 转换例程读取数据文件失败时，首先尝试使用 NLS 替代：</p>
<ul>
<li>通过读取注册表取得 NLS 文件路径，默认为系统目录下的 <code>C_936.NLS</code>（文件名大小写可能不同，这不影响加载）。</li>
<li><strong>注意</strong> 并非所有 Windows 安装带有指定的 NLS 文件。
<ul>
<li>具体支持的 NLS 文件名由注册表读取。这些文件在系统目录（<code>%WINDIR%\System32</code> 或 <code>%WINDIR%\SysWOW64</code>）存在。这些目录中是否存在注册表中指定文件的 NLS 文件首先和系统支持的语言相关。</li>
<li>新近版本的 64 位 Windows 10 可能在 <code>%WINDIR%\System32\C_936.NLS</code> 但不存在 <code>%WINDIR%\SysWOW64\C_936.NLS</code> 。由于 64 位 Windows 默认<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa384187.aspx">对系统目录重定向</a>，导致 32 位系统中直接读取系统目录找不到 NLS 文件。在 build 937 前，YFramework 初始化加载 NLS 文件时不特别处理这种情况，因此 NLS 不可用。</li>
</ul>
</li>
<li>若 Win32 NLS 初始化仍然失败，则 CHRLib 初始化 GBK 转换例程失败。</li>
</ul>
<p>　　对其它平台，数据文件读取失败则 CHRLib 初始化 GBK 转换例程失败。</p>
<p>　　初始化失败后，使用 CHRLib 转换 GBK 编码的程序在调用转换例程时抛出异常，可能导致程序非正常退出。</p>
<h3 id="mime-数据"><a class="header" href="#mime-数据">MIME 数据</a></h3>
<p>　　数据目录下的配置文件 <code>MIMEExtMap.txt</code> 存储 MIME 数据。若不存在，提供默认内容。</p>
<h2 id="字体目录和文件路径"><a class="header" href="#字体目录和文件路径">字体目录和文件路径</a></h2>
<p>　　只要其中之一有效即可（若没有成功指定字体文件路径，则默认字体文件路径不确定）。</p>
<p>　　自动生成的配置中字体文件的默认路径如下：</p>
<ul>
<li>DS ： <code>/Font/FZYTK.ttf</code></li>
<li>Win32 ：系统字体目录下的 <code>SimSun.ttc</code></li>
<li>Android ： <code>/system/fonts/DroidSansFallback.ttf</code></li>
<li>Linux ： <code>./SimSun.ttc</code></li>
</ul>
<p>　　自动生成的配置中字体目录的默认路径如下：</p>
<ul>
<li>DS ： <code>/Font</code> 目录</li>
<li>Android ： <code>/system/fonts</code> 目录</li>
<li>其它平台：同数据目录</li>
</ul>
<h1 id="特定平台运行环境"><a class="header" href="#特定平台运行环境">特定平台运行环境</a></h1>
<h2 id="ds"><a class="header" href="#ds">DS</a></h2>
<p>　　以下说明中，<code>$NDSEmulator</code> 为模拟器 <a href="DeSmuME.en-US.html">DeSmuME</a> 可执行文件的绝对路径，<code>$TargetPath</code> 为 ROM 映像文件（ <code>.nds</code> 文件）的路径，$FAT_Path为 FAT 目录路径（见以下说明）。</p>
<p>　　之前经测试的最小版本为 0.9.6 。建议使用最新版本。</p>
<p>　　运行时，需在运行模拟器的宿主机中准备一个目录作为映射到设备中的虚拟 FAT 目录。宿主的目录在运行中不会被 DeSmuME 修改；宿主目录的文件系统不要求为 FAT 。运行时会加载虚拟目录的内容。</p>
<p><strong>注意</strong> 官方版的 DeSmuME 不支持包含非 ASCII 字符的宿主路径而忽略这些文件。部分修改版可能没有这个限制。</p>
<p><strong>注意</strong> 因为 DS 模拟器和烧录卡需要加载 ROM 映像到 RAM 后才能运行，映像大小会影响可用运行内存，使用 debug 配置构建的 YSTest 示例版本不一定在 DS 上支持所有功能。相关支持限制及变更详见 YSLib 项目文档 <code>doc/Test.txt</code> 。</p>
<p>　　可通过以下方式之一指定 FAT 目录。</p>
<h3 id="slot-1-映射"><a class="header" href="#slot-1-映射">Slot 1 映射</a></h3>
<p>　　Slot 1 （即 NDS ROM 卡槽，硬件介质可以是 NDS 卡带，或烧录卡和存储卡的组合）的模拟从 DeSmuME 0.9.8 版本起支持。</p>
<p>　　运行命令行示例：</p>
<pre><code>&quot;$NDSEmulator&quot; &quot;$TargetPath&quot; --preload-rom --slot1-fat-dir=&quot;$FAT_Path&quot;
</code></pre>
<p>　　其中 <code>--preload-rom</code> 对 0.9.10 和 0.9.11 版本是必须的（以支持自动 <a href="https://wiki.gbatemp.net/wiki/DLDI">DLDI(en-US)</a> 补丁），否则加载失败。这个选项可以在模拟器（Windows 版本）的 GUI 菜单中 <code>Config</code> → <code>ROM Loading</code> 中选择。最新版本的源码会对自制 ROM 自动启用 ROM 预先加载的选项而不用另行配置，可以省略这个选项。</p>
<h3 id="slot-2-映射"><a class="header" href="#slot-2-映射">Slot 2 映射</a></h3>
<p>　　Slot 1 （即 GBA ROM 卡槽，硬件介质可以是 GBA 卡带或其它扩展）的模拟需要配置为使用 <code>GBA Movie Player (Compact Flash)</code> 。</p>
<p>　　运行命令行示例：</p>
<pre><code>&quot;$NDSEmulator&quot; &quot;$TargetPath&quot; --cflash-path=&quot;$FAT_Path&quot;
</code></pre>
<p>　　对 0.9.10 和 0.9.11 版本，需同 Slot 1 映射添加 <code>--preload-rom</code> 或使用菜单设置加载选项，否则同样无法加载（尽管源码中表示 <code>--preload-rom</code> 是适用 Slot 1 而不是 Slot 2 的选项）。</p>
<p>　　这个选项也可以通过 GUI 配置。在 0.9.9 版本前，使用菜单 <code>Emulation</code> → <code>GBA Slot</code> 。自 0.9.9 版本起，使用菜单 <code>Config</code> → <code>Slot 2 (GBA Slot)</code> 。</p>
<p><strong>注意</strong> DeSmuME svn4030 及之后的一些版本（至少包括 0.9.8 ）会在载入 MPCF 映像时错误地忽略 <code>--cflash-path</code> 选项，以 仿真(Emulation) → GBA 插槽(GBA Slot) 菜单中的设置或对应配置文件 <code>desmume.ini</code> 中指定正确的路径。</p>
<p>　　在 <code>desmume.ini</code> 中有效的最小配置：</p>
<pre><code>[GBAslot]
type=1
[GBAslot.CFlash]
fileMode=0
path=H:\NDS\efsroot\
</code></pre>
<p>　　这里 <code>H:\NDS\efsroot</code> 是 <code>$FAT_Path</code> 的一个示例。</p>
<p><strong>注意</strong> 自 Slot1 0.9.10 起，当 Slot 1 设置为 R4 时会覆盖 Slot 2 设置加载 R4 路径（ Dev+ 版本显示自动 DLDI 补丁在 Slot 1 设置为 R4 从 <code>GBA Movie Player (Compact Flash)</code> 改为 <code>R4(DS) - Revolution for DS</code> ），因此需确保<strong>Slot 1 设置不为 R4 ，或正确设置了 Slot 1 R4 的路径</strong>（而改用 Slot 1 映射）。</p>
<h2 id="mingw32"><a class="header" href="#mingw32">MinGW32</a></h2>
<p>　　自 build 431 起，YFramework 使用的 <a href="https://freeimage.sourceforge.io/">FreeImage</a> 修改版集成 <a href="https://zh.wikipedia.org/zh-cn/Libjpeg#libjpeg-turbo">libjepg-turbo</a> ，需要 CPU 支持 <a href="https://zh.wikipedia.org/zh-cn/SSE2">SSE2</a> 指令集扩展。</p>
<p>　　除 2005 年前生产的硬件外绝大多数环境已经满足这个条件。当前几乎所有兼容 IA-32 的市售 CPU 都包含 SSE2 支持。特别地，支持 x86_64 指令集的 CPU 要求支持 SSE2 ，在使用 x86_64 的 64 位 Windows 上运行 32 位 Win32 程序（通过 <a href="https://zh.wikipedia.org/zh-cn/WoW64">WoW64</a> ）也支持 SSE2 。</p>
<h2 id="android"><a class="header" href="#android">Android</a></h2>
<p>　　可使用 <code>adb</code> 命令安装 APK 包，如：</p>
<pre><code>&quot;$ANDROID_SDK/platform-tools/adb&quot; -e install -r &quot;$1&quot;
</code></pre>
<p>　　此处 <code>-e</code> 指定 TCP/IP 设备（通常是模拟器），若使用 USB 设备（通常是物理机器）应移除或使用较新的 <code>adb</code> 的 <code>-d</code> 选项代替；<code>&quot;$1&quot;</code> 指定 APK 文件路径。</p>
<p>　　之后，在 Android 的 GUI 环境下直接运行安装的程序。</p>
<p>　　若因签名变更等原因无法覆盖安装或更新，需要先卸载后再安装。</p>
<p><strong>注意</strong> Android 安装 <code>.apk</code> 包时需要占用额外存储资源。为避免内置存储空间不足导致不直接表现安装失败（需要 <code>logcat</code> 查看）但直至运行时找不到二进制库而导致启动失败，应保留足够的空间，特别是对占用较大的 debug 配置构建的映像。保留空间的大小一般大于 <code>.apk</code> 作为 <code>.zip</code> 解压缩占用的空间。另见<a href="https://code.google.com/p/android/issues/detail?id=21670">此处报告的未确认的类似问题</a>。</p>
<h1 id="框架初始化"><a class="header" href="#框架初始化">框架初始化</a></h1>
<p>　　框架初始化服务于整个框架。</p>
<p>　　初始化的重要策略之一是在程序启动时减少不必要的初始化，以允许实现以下目的：</p>
<ul>
<li>减少可能的外部依赖（如不需要使用文字的程序就不初始化字体缓存，也不需要依赖外部字体文件和字体配置等）。</li>
<li>减少可能的运行时程序资源占用。</li>
<li>保留静态链接时优化去除没有调用的代码以减少二进制可执行文件大小的可能性。</li>
</ul>
<p>　　按当前框架的设计，框架初始化在 DS 平台在程序运行初始阶段完成。其它平台可延迟初始化，按需调用。</p>
<p>　　并非所有 YFramework 中的 API 都要求框架初始化。以下功能隐含自动进行的框架初始化：</p>
<ul>
<li>使用默认字体缓存。</li>
<li>使用 MIME 数据时。</li>
</ul>
<p>　　框架初始化加载配置文件，其中配置文件路径的确定方式参见以下节的说明。成功公共加载配置文件后，框架初始化检查配置文件的内容，并访问框架公共配置。若检查失败，抛出异常。</p>
<p>　　修改 YFramework 模块 Helper::Initialization 重新编译后，可修改默认设置改变初始化行为。以下行为<strong>可能会在未来改变</strong>。</p>
<h2 id="根路径"><a class="header" href="#根路径">根路径</a></h2>
<p>　　<strong>根路径(root path)</strong> 是框架初始化时参考的基本路径，由如下方式确定：</p>
<ul>
<li>Win32 和 Linux（除 Android ）：程序映像所在的目录。</li>
<li>Android ：SD 卡目录（自动按顺序检测 <code>/sdcard</code> 、<code>/mnt/sdcard</code> 或 <code>/storage/sdcard0</code> 之一）。</li>
<li>其它平台：第一次初始化时的当前工作目录。</li>
</ul>
<p>　　确定根路径在框架初始化或要求确定根路径时进行。若定位程序映像，同时会解析符号链接。若定位根路径失败，抛出异常。</p>
<p>　　抛出的异常默认不被框架处理，可使程序退出。用户代码捕获特定异常可改变默认退出行为。</p>
<h2 id="配置路径"><a class="header" href="#配置路径">配置路径</a></h2>
<p>　　公共配置文件 <code>yconf.txt</code> 所在目录的路径前缀（结尾带有路径分隔符）称为框架的<strong>配置路径(configuration path)</strong> ，决定和平台相关的配置加载起始位置。配置路径和配置文件相对路径（对 <code>yconf.txt</code> ，即配置文件名）组合得到配置文件路径。</p>
<p>　　配置路径的确定方式和平台相关。</p>
<p>　　任意平台总能确定一个首选的配置路径。</p>
<p>　　除首选的配置路径外，一些平台还支持一个或多个不同的<strong>后备(fallback) 配置路径</strong>。在读写特定的配置文件时，若根路径访问失败，但存在后备配置路径，依序使用这些路径重试直至成功或全部访问失败。这样的配置文件当前包括 <code>yconf.txt</code> 。具体应用可使用初始化 API 以类似的方式加载其它配置文件。</p>
<p>　　以下是具有后备配置路径的平台中确定配置路径的顺序：</p>
<ul>
<li>Linux（除 Android ）：
<ul>
<li>首先使用首选的配置路径。</li>
<li>若环境变量 <code>HOME</code> 非空，则路径 <code>$HOME/.YSLib/</code> 是后备配置路径。</li>
</ul>
</li>
<li>Win32 ：在 Linux 的基础上：若 <code>$HOME</code> 非空，则路径 <code>$HOME/.YSLib/</code> 是后备配置路径。
<ul>
<li>同 Linux 平台的使用顺序（对应使用 Win32 的环境变量和路径语法，即备份路径 <code>%HOME%\.YSLib\</code> ）。</li>
<li>若环境变量 <code>USERPROFILE</code> 非空，则路径 <code>%USERPROFILE%\.YSLib\</code> 是后备配置路径。</li>
</ul>
</li>
</ul>
<p>　　后备配置路径中若子目录 <code>.YSLib</code> 不存在则被创建。若创建失败，配置路径访问失败。</p>
<p>　　对不具有后备路径的平台，首选的配置路径总是根路径。否则，首选的配置路径由以下方式确定：</p>
<ul>
<li>程序映像所在的位置可推断出符合类似 FHS 的文件系统布局（称为局部 FHS 目录布局），则首选的配置路径为程序映像所在的目录的上一级目录的 <code>var</code> 子目录下的 <code>YSLib</code> 子目录。
<ul>
<li>推断文件系统布局为以 POSIX 环境变量语法表示为 <code>$PREFIX/</code>、<code>$PREFIX/$BIN/</code>、<code>$PREFIX/lib/</code> 和 <code>$PREFIX/share/</code> 这些路径前缀都存在且可作为目录访问，其中 <code>$PREFIX</code> 是程序映像所在的目录的上级目录，而 <code>$BIN</code> 是程序映像所在的目录的名称（按 FHS 通常为 <code>bin</code> ，此处不检查）。</li>
<li>这保证创建映像的可执行程序映像的目录中内容不被修改，以符合 FHS 。</li>
</ul>
</li>
<li>否则，首选的配置路径为根路径。
<ul>
<li>确定配置路径要求确定根路径。</li>
</ul>
</li>
</ul>
<p>　　对不具有后备路径的平台不检查文件系统布局，也不要求实现确保程序映像路径的操作，以简化实现。</p>
<p><strong>注意</strong> 若后备配置路径的配置文件可访问，直接使用此配置文件保存配置，不再创建配置文件。若需要恢复在首选配置路径创建配置文件的行为，需确保后备配置路径的配置文件不可访问（例如，移除所有后备配置路径的这些配置文件）。</p>
<h2 id="配置文件加载"><a class="header" href="#配置文件加载">配置文件加载</a></h2>
<p>　　加载配置文件 <code>yconf.txt</code> 时，首先按上述的顺序确定各个配置路径，每确定一个路径时访问其中的配置文件。若全部失败（如找不到可读的文件），则尝试自动生成配置并创建配置文件。创建配置文件的位置和顺序同上述确定配置路径的顺序。若创建配置文件全部失败，则放弃创建配置文件，直接使用生成的配置。</p>
<p>　　不存在配置文件时，配置不能通过 Helper::Initialization 的 API 持久化保存，尝试保存配置会失败。</p>
<h2 id="其它初始化"><a class="header" href="#其它初始化">其它初始化</a></h2>
<p>　　成功后，框架进一步处理公共配置文件以外的其它初始化；详见以上具体配置文件的相关章节。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="版本库结构和文件说明"><a class="header" href="#版本库结构和文件说明">版本库结构和文件说明</a></h1>
<p>　　版本库依赖支持子目录的层次文件系统。以下只包括版本库根目录下的顶级子目录和少数特定的二级子目录及其中的部分文件的说明。</p>
<ul>
<li><code>.git</code> Git 目录（可通过 hg-git 同步）</li>
<li><code>.hg</code> Mercurial 目录</li>
<li><code>3rdparty</code> 第三方依赖项</li>
<li><code>Data</code> 最终用户环境中部署的数据目录</li>
<li><code>Tools</code> 开发使用的（辅助）工具
<ul>
<li><code>Tools/SHBuild</code> SHBuild 构建工具</li>
<li><code>Tools/Scripts</code> 用于构建和建立 SHBuild 环境的工具脚本</li>
</ul>
</li>
<li><code>YBase</code> 顶级子项目 YBase</li>
<li><code>YFramework</code> 顶级子项目 YFramework</li>
<li><code>YSTest</code> 测试用示例项目目录（项目名为 YSTest ，以实际内容命名的项目名为 YReader ）
<ul>
<li><code>YSTest/Android</code> 示例项目 YReader 的 Android 平台项目（未完成正式支持）</li>
<li><code>YSTest/DS_ARM7</code> 示例项目 YReader 的 ARM7 项目（仅用于 DS 平台，用于生成 ARM7 ELF 二进制映像）</li>
<li><code>YSTest/DS_ARM9</code> 示例项目 YReader 的 ARM9 项目（包括 DS 平台 ARM9 部分，于生成 ARM9 ELF 二进制映像；源代码和其它平台共享）</li>
<li><code>YSTest/DS</code> 示例项目 YReader 的 DS 平台可执行文件项目（仅用于 DS 平台，用于生成 NDS 文件）</li>
<li><code>YSTest/MinGW32</code> 示例项目 YReader 的 MinGW32 平台可执行文件项目（仅用于 MinGW32 平台，用于生成 EXE 文件）</li>
</ul>
</li>
<li><code>build</code> 默认构建目录（可选构建时生成）</li>
<li><code>doc</code> 开发文档</li>
<li><code>doc/vsd</code> 架构示意 Visio 文档</li>
<li><code>test</code> 测试代码目录</li>
<li><code>.gitignore</code> Git 忽略文件</li>
<li><code>.hgeol</code> Mercurial EOL 插件配置文件</li>
<li><code>.hgignore</code> Mercurial 忽略文件</li>
<li><code>.hgtags</code> Mercurial 标签文件</li>
<li><code>CC BY-SA 3.0 legalcode.txt</code> 文档许可证： Creative Commons Legal Code Attribution-ShareAlike 3.0 Unported</li>
<li><code>Doxyfile</code> Doxygen 配置文件</li>
<li><code>FTL.TXT</code> 许可证： The FreeType Project LICENSE</li>
<li><code>gpl-2.0.txt</code> 许可证： GNU GENERAL PUBLIC LICENSE Version 2</li>
<li><code>gpl-3.0.txt</code> 许可证： GNU GENERAL PUBLIC LICENSE Version 3</li>
<li><code>LICENSE.txt</code> 整体许可证</li>
<li><code>LICENSE_HISTORY.txt</code> 整体许可证：历史版本</li>
<li><code>license-fi.txt</code> 许可证： FreeImage Public License - Version 1.0</li>
<li><code>Readme.zh-CN.txt</code> 自述文件</li>
<li><code>YSTest.sln</code> Visual Studio 解决方案文件</li>
<li><code>YSTest.workspace</code> Code::Blocks 工作空间文件</li>
</ul>
<p><strong>注释</strong> 以上布局中的顶级子目录可作为顶级子项目或作为项目模块在开文档中引用，其名称起始使用大写字母，以目录的名称原文作为模块名称。其它构建时生成以外的目录也可被引用，但不使用目录名称作为模块名称。</p>
<p>　　顶级子项目或其中的平台子目录中，可包含以下目录：</p>
<ul>
<li><code>include</code> 可被安装部署的公开头文件</li>
<li><code>source</code> 被构建的源文件</li>
</ul>
<p>　　以下目录会被默认支持的构建配置生成：</p>
<ul>
<li><code>YDE/</code> 下以 <code>.</code> 起始的特定宿主平台为子目录名的构建目录是 <a href="Sysroot.zh-CN.html">stage 2 环境</a>下的 <a href="YDE.zh-CN.html">YDE 项目</a>的生成文件目录</li>
<li><code>build/</code> 下以特定的宿主平台为子目录名的默认构建目录，默认配置构建时会创建不同的平台目录，其中的子目录可包括：
<ul>
<li><code>.stage1</code> <a href="Tools/SHBuild.zh-CN.html">stage 1 环境</a> 构建和生成目录</li>
<li><code>.test</code> <a href="Test.zh-CN.html">测试项目</a>构建和生成文件目录</li>
<li>以 <code>.</code> 起始的其它 <a href="Sysroot.zh-CN.html">Sysroot</a> 构建目录，用于创建 <a href="Sysroot.zh-CN.html">stage 2 环境</a>的 YSLib 库以及基于 stage 2 环境的 Sysroot 方式的 YSTest 的构建</li>
<li>其它非 Sysroot 的 YSLib 和 YSTest 项目生成文件目录</li>
</ul>
</li>
<li><code>sysroot</code> 使用<a href="Tools/Scripts.zh-CN.html">脚本</a>构建的默认 <a href="Sysroot.zh-CN.html">Sysroot （含 stage 2 环境）</a> 生成目录</li>
</ul>
<h2 id="文件系统布局约定"><a class="header" href="#文件系统布局约定">文件系统布局约定</a></h2>
<p>　　版本库遵循一定的文件系统布局规则。这些规则在这里和一些开发文档中被描述。没有通过这些描述被明确的布局应被视为实现细节，其改变可不被文档描述。</p>
<p>　　不论是否是实现细节，特定的路径都可被版本库的忽略文件路径涵盖。</p>
<p><strong>注意</strong> 版本库中的文件系统布局和 Sysroot 约定的部署实例的布局相互独立，不适用此处的规则，且布局可能存在差异。</p>
<p>　　虽然没有在项目初始指定，版本库中部分目录和文件结构及使用方式与现有的一些约定类似或兼容：</p>
<ul>
<li>部分文件系统布局和使用符合 <a href="https://api.csswg.org/bikeshed/?force=1&amp;url=https://raw.githubusercontent.com/vector-of-bool/pitchfork/develop/data/spec.bs">cxx-pflR1</a> 。
<ul>
<li>顶级子目录 <code>build</code> 符合 <a href="https://api.csswg.org/bikeshed/?force=1&amp;url=https://raw.githubusercontent.com/vector-of-bool/pitchfork/develop/data/spec.bs#tld.build"><code>build/</code></a> 指定的目的和作用。</li>
<li>顶级子项目或其中的平台子目录中的子目录 <code>include</code> 和 <code>source</code> 对应符合 <a href="https://api.csswg.org/bikeshed/?force=1&amp;url=https://raw.githubusercontent.com/vector-of-bool/pitchfork/develop/data/spec.bs#tld.include"><code>include/</code></a> 和 <a href="https://api.csswg.org/bikeshed/?force=1&amp;url=https://raw.githubusercontent.com/vector-of-bool/pitchfork/develop/data/spec.bs#tld.src"><code>src/</code></a> 指定的目的和作用，其使用符合<a href="https://api.csswg.org/bikeshed/?force=1&amp;url=https://raw.githubusercontent.com/vector-of-bool/pitchfork/develop/data/spec.bs#src.header-placement">分离放置布局</a>。</li>
<li>顶级子目录 <code>test</code> 符合 <a href="https://api.csswg.org/bikeshed/?force=1&amp;url=https://raw.githubusercontent.com/vector-of-bool/pitchfork/develop/data/spec.bs#tld.tests"><code>tests/</code></a> 指定的主要目的和作用，但不限于非单元测试。</li>
<li>顶级子目录 <code>Data</code> 符合 <a href="https://api.csswg.org/bikeshed/?force=1&amp;url=https://raw.githubusercontent.com/vector-of-bool/pitchfork/develop/data/spec.bs#tld.data"><code>data/</code></a> 指定的主要目的和作用，但强调最终用户环境，且不适用生成文档的源代码。</li>
<li>顶级子目录 <code>doc</code> 符合 <a href="https://api.csswg.org/bikeshed/?force=1&amp;url=https://raw.githubusercontent.com/vector-of-bool/pitchfork/develop/data/spec.bs#tld.docs"><code>docs/</code></a> 指定的目的和作用。</li>
<li>因为不使用版本管理的子模块机制，不使用 <a href="https://api.csswg.org/bikeshed/?force=1&amp;url=https://raw.githubusercontent.com/vector-of-bool/pitchfork/develop/data/spec.bs#tld.libs"><code>libs/</code></a> 和 <a href="https://api.csswg.org/bikeshed/?force=1&amp;url=https://raw.githubusercontent.com/vector-of-bool/pitchfork/develop/data/spec.bs#submod.extras"><code>extras/</code></a> ，符合指定的规则。</li>
</ul>
</li>
<li>部分文件系统布局和使用符合 <a href="http://jdebp.uk/FGA/slashpackage.html">Jonathan de Boyne Pollard 约定的 slashpackage 内部结构</a>。
<ul>
<li>顶级子项目或其中的平台子目录中的子目录 <code>source</code> 符合指定的目的和作用。</li>
<li>默认构建目录是名为 <code>build</code> 的一级子目录，可能不存在，符合指定的目的和作用。</li>
<li>除构建目录外的文件预期不应被构建过程修改，默认与之兼容。</li>
<li>不要求 <code>source</code> 链接到 <code>build</code> ，与之不兼容。</li>
<li>构建 Sysroot 可能直接链接文件到输出目录，与之不兼容。</li>
<li>仅要求部署过程正常时的部署目标目录的完整性，不要求更新是原子的或可事务性回滚，与之不兼容。</li>
</ul>
</li>
</ul>
<h1 id="项目结构和特性"><a class="header" href="#项目结构和特性">项目结构和特性</a></h1>
<p>　　项目内容以模块为单位组织。关于模块的概念及其表示形式，详见 YSLib 项目文档 <code>doc/ProjectRules.txt</code> 。因为特性众多，在此只列出较上层的基本结构，不总是精确到具体模块。</p>
<h2 id="ybase-yframework-基础库"><a class="header" href="#ybase-yframework-基础库">YBase ：YFramework 基础库</a></h2>
<p>　　详见 <code>doc/YBase.txt</code> 。</p>
<p>　　替代标准库的特性另见 <a href="StandardUsing.en-US.html">StandardUsing(en-US)</a> 。</p>
<ul>
<li>YStandardEx ： YFramework 标准扩展库</li>
<li>LibDefect ：标准库修正</li>
<li>YTest ：YFramework 基础测试库</li>
</ul>
<h2 id="yframework--yframework-框架库"><a class="header" href="#yframework--yframework-框架库">YFramework ： YFramework 框架库</a></h2>
<p>　　详见 <code>doc/YFramework.txt</code> 。</p>
<ul>
<li>CHRLib ：字符编码处理库
<ul>
<li>编码标识</li>
<li>目前支持 UTF-8/UCS-2/UCS-4/GBK ，可扩充</li>
<li>默认编码 UTF-8</li>
</ul>
</li>
<li>YCLib ： YSLib 基础库
<ul>
<li>Platform ：平台定义</li>
<li>平台相关 API 封装</li>
<li>平台相关硬件抽象</li>
<li>Win32 专用接口（略）</li>
</ul>
</li>
<li>YSLib ：YShell 库（主体，暂定）
<ul>
<li>Adaptor ：适配器层
<ul>
<li>Configuration ： 库配置</li>
<li>YReference ：智能指针封装（基于 Loki 实现【已移除】/使用 ISO C++11 标准库）</li>
<li>简单的内存调试设施</li>
<li>附加容器（可选 Loki 的 yasli 容器，默认不启用）</li>
<li>Anti-Grain Geometry 2.4 移植（修复了一处在 2.5 仍然存在的 bug ），因在 DS 上效率太低所以默认不启用【已移除】</li>
<li>Font ：字体管理（基于 FreeType 2 实现）</li>
<li>Image ：平台中立的图像输入和输出（基于 FreeImage 实现）</li>
</ul>
</li>
<li>Core ： YSLib 核心</li>
<li>Service ：YSLib 服务</li>
<li>UI ： YSLib 用户界面</li>
<li><a href="Features/NPL.zh-CN.html">NPL</a></li>
<li>Helper ：助手库：初始化、宿主支持等</li>
</ul>
</li>
</ul>
<h2 id="yreader-示例"><a class="header" href="#yreader-示例">YReader ：示例</a></h2>
<ul>
<li>ShlExplorer ：文件列表浏览</li>
<li>控件测试：按钮点击、窗口拖曳、FPS （伪）显示等</li>
<li>Shell 切换</li>
<li>ShlReader ：文本浏览
<ul>
<li>读取并显示文本文件的内容</li>
<li>随机跳转</li>
<li>书签设置、读取和保存</li>
</ul>
</li>
<li>HexBrowser：十六进制浏览</li>
</ul>
<h1 id="构建-1"><a class="header" href="#构建-1">构建</a></h1>
<p>　　支持使用多种途径进行<a href="Build.zh-CN.html">构建</a>。支持<a href="Terminology.zh-CN.html">多平台构建</a>。另见 <a href="Sysroot.zh-CN.html">Sysroot</a> 和以下的“轮子列表”章节。</p>
<p>　　<a href="Terminology.zh-CN.html">依赖</a>以模块为单位组织。接口（如公开 API 头文件）不出现循环依赖。</p>
<p>　　可通过修改代码以裁剪、定制库实现内部的模块构建（如为了减小编译后的二进制映像体积），但应注意在 YSLib 项目文档中列出的显式依赖规则。未来可能会支持构建时的定制配置工具。</p>
<h1 id="abi"><a class="header" href="#abi">ABI</a></h1>
<p>　　目前除 YBase::LibDefect 和具体实现兼容外，不保证 ABI 稳定。</p>
<p>　　具体策略详见 YSLib 项目文档 <code>doc/</code> 下各个库的文档。</p>
<h1 id="api"><a class="header" href="#api">API</a></h1>
<p>　　对各 API 的说明和注意事项详见 YSLib 项目中的源代码，可<a href="BuildDocumentation.zh-CN.html">构建文档</a>。</p>
<h2 id="平台相关-api-注意事项"><a class="header" href="#平台相关-api-注意事项">平台相关 API 注意事项</a></h2>
<ul>
<li>YCLib::MemoryMapping 中 <code>platform::MappedFile</code> 的实现需确保文件内容可访问，否则取指针后，可在之后的操作中引发不可恢复的错误。
<ul>
<li>在硬件支持 MMU 的平台上，使用内存映射实现。
<ul>
<li>读取错误产生不可恢复的错误。
<ul>
<li>因为无法确保确定的调用位置，框架不做任何处理。
<ul>
<li>除非用户程序进行处理，这将导致程序崩溃。</li>
</ul>
</li>
<li>Win32 平台：失败时<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa366801(v=vs.85).aspx">引发 <code>EXCEPTION_IN_PAGE_ERROR</code> 结构化异常</a>。</li>
<li>POSIX 宿主平台：失败时<a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html">引发 <code>SIGSEGV</code> 信号</a>。</li>
</ul>
</li>
<li>因此不支持不可靠的远程文件。</li>
</ul>
</li>
<li>其它平台（当前包括 DS ），使用文件流模拟。
<ul>
<li>若 <code>platform::MappedFile</code> 初始化失败会直接抛出异常。除非用户代码忽略，可避免引发后续失败（引起未定义行为）。</li>
</ul>
</li>
<li>当前仅支持只读映射。若修改取得的映射指针指向的存储，在使用内存映射实现的平台上也可引发上述行为类似的不可恢复的错误。</li>
</ul>
</li>
</ul>
<h2 id="标准库使用"><a class="header" href="#标准库使用">标准库使用</a></h2>
<p>　　YSLib 对 C++ 标准库<a href="Prerequisitions.zh-CN.html">具有明确的要求</a>，且仅使用<a href="StandardUsing.en-US.html">明确的标准库特性</a>。</p>
<p>　　和 <a href="http://llvm.org/docs/CodingStandards.html#c-standard-library">LLVM 编码标准对 C++ 标准库的使用(en-US)</a>类似，YSLib 强调尽可能依赖标准库的公开接口。仅在具有充足理由时不依赖标准库而提供和使用自定义 API （基本上总是因为设计和实现的质量不足够满足需求和以上要求的原因）。</p>
<p>　　对标准库特性使用的具体限制见<a href="Development.zh-CN.html">开发说明</a>及 YSLib 项目文档 <code>doc/LanguageConvention.txt</code> 等规则。</p>
<p>　　相关的其它原理另见下节。</p>
<h2 id="轮子列表"><a class="header" href="#轮子列表">轮子列表</a></h2>
<p>　　本项目发明了一些轮子。为了符合<a href="Home.zh-CN.html">不重复发明轮子的项目内容规则</a>，在发现更好的替代时，其中一些会被逐渐移除。</p>
<p>　　但是，其余一些轮子，因为特定的原因，不视为对此规则的违反而得以保留，包括一些在当前实现中使用的和较新版本语言规范中提供的兼容的特性。</p>
<p>　　主要包括以下内容：</p>
<ul>
<li>YBase.YStandardEx
<ul>
<li>为了兼容性需要，一些标准库接口的实现会被保留。但当合适的版本可用时，通过条件包含选择别名声明，优先使用标准库提供的版本。</li>
<li>Meta 、TypeTraits 以及其它元编程设施
<ul>
<li>其它元编程设施因为没有被标准化、风格和可用性问题，提供了 C++14 兼容的元函数和类似 <a href="https://github.com/ericniebler/range-v3">Range-v3</a> 及 <a href="http://boostorg.github.io/hana/">Boost.Hana</a> 的实现使用的接口。</li>
</ul>
</li>
<li>IntegerSequence
<ul>
<li>主要接口兼容 C++14 的 <code>std::integer_sequence</code> ，但早于提案 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3493.html">N3493</a> 。</li>
<li>提供了更丰富的底层接口如 <code>make_peano_sequence</code> 。</li>
</ul>
</li>
<li>Operators
<ul>
<li>接口类似 <a href="http://www.boost.org/doc/libs/1_60_0/libs/utility/operators.htm">Boost.Operators</a> ，但有以下不同：
<ul>
<li>要求 C++11 支持。</li>
<li>使用代码量较少的紧凑的实现，不支持对不符合标准的编译器的多数实现细节上的变通。</li>
<li>不支持链式模板参数（这是为了兼容不支持偏特化的编译器的变通）。</li>
<li>提供对 <code>noexcept</code> 的支持。</li>
</ul>
</li>
<li>接口类似 <a href="https://github.com/taocpp/operators">The Art of C++ / Operators</a>（原 df.operators ）。</li>
<li>除以上列出外，还有以下差异和特性：
<ul>
<li>操作符模板使用别名而不保证是类。</li>
<li>支持可选的操作符参数，默认推断 <code>constexpr</code> 。</li>
<li>重载操作符实现为模板友元以支持推断 <code>constexpr</code> 同时允许在派生类中提供显式覆盖实现。</li>
</ul>
</li>
<li>此外，提供部分不在上述类似接口中提供的成员操作符重载。</li>
</ul>
</li>
<li>Any
<ul>
<li>接口类似 <a href="http://www.boost.org/doc/libs/1_60_0/doc/html/any.html">Boost.Any</a> ，包括内部非公开的 <code>unsafe_any_cast</code> 作为扩展；此外 <code>any</code> 成员也有一些扩展。</li>
<li>除了 <code>any</code> 外还提供底层实现相关的扩展，用于实现 AnyIterator ，<strong>这无法被简单取代</strong>。</li>
<li>Any 的<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1939.html">提案</a>最早于 2006 年基于 Boost.Any 提出，未考虑 C++11 特性。此实现早于标准库提案的<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3390.html">后续修订版本</a>实现。</li>
<li>现在和 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4081.html">WG21 N4081</a> 的 <code>std::experimental::any</code> 同步，但仍然保持扩展。</li>
<li>使用了小对象优化实现，这也符合后来<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3804.html">更新的提案</a>中的建议。
<ul>
<li>空间性能<strong>明显比 Boost.Any 高效</strong>。</li>
<li><strong>libstdc++ 的 <code>std::experimental::any</code> 也使用了类似的实现，但<a href="https://gcc.gnu.org/ml/libstdc++/2014-06/msg00093.html">比此处的实现晚 1 年以上</a></strong>。早期 libstdc++ 实现还存在<a href="https://gcc.gnu.org/ml/libstdc++/2015-05/msg00052.html">遗漏考虑对齐</a>和<a href="https://gcc.gnu.org/ml/libstdc++/2015-07/msg00091.html">自赋值</a>的缺陷，这些问题在此处从不存在。</li>
</ul>
</li>
<li>提供 <code>emplace</code> 相关扩展，可避免构造 <code>any</code> 对象或赋值时冗余初始化目标类型的值。</li>
<li>提供 <code>unchecked_*</code> 成员和 <code>unchecked_any_cast</code> 模板扩展，要求参数非空，因为省略检查比对应的检查空值的接口（ <code>unchecked_any_cast</code> 对应 <code>unsafe_any_cast</code> ）更高效。</li>
</ul>
</li>
<li>Optional
<ul>
<li>ISO C++17 的 <code>&lt;optional&gt;</code> 在 ISO C++11 下的移植和扩展。</li>
<li>支持几乎所有特性，除 <code>operator-&gt;</code> 因为核心语言特性限制不总是支持结果是常量表达式。</li>
<li>支持少量扩展接口： <code>make_optional_inplace</code> 和 <code>ref_opt</code> 。</li>
</ul>
</li>
<li>Map
<ul>
<li>ISO C++17 的 <code>&lt;map&gt;</code> 在 ISO C++11 下的移植和扩展。</li>
<li>支持不完整键类型，不依赖特定扩展（如 libstdc++ 的 <code>std::map</code>）。</li>
</ul>
</li>
<li>Invoke
<ul>
<li>提供 <code>std::invoke</code> 的替代。</li>
</ul>
</li>
<li>Apply
<ul>
<li>提供 <code>std::apply</code> 的替代。</li>
</ul>
</li>
<li>Function
<ul>
<li>提供 <code>std::function</code> 的替代。</li>
</ul>
</li>
<li>Rational
<ul>
<li>类模板 <code>fixed_point</code> 和提案 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0037r1.html">P0037R1</a> 中的有相似之处，但模板参数类型更明确，且提出较早。</li>
</ul>
</li>
<li>一些非直接的（以同名接口一一替代的）标准库替代接口
<ul>
<li>减少了标准库对应的限制，提升了易用性。</li>
<li>不一定和标准库的对应功能的 API 同名。</li>
<li><code>lref</code> 部分取代 <a href="http://www.eel.is/c++draft/refwrap"><code>std::reference_wrapper</code></a> （涉及 <code>std::bind</code> 的使用无法取代）。
<ul>
<li>和 <code>std::reference_wrapper</code> 不同而和 <a href="http://www.boost.org/doc/libs/1_60_0/libs/core/doc/html/boost/reference_wrapper.html"><code>boost::reference_wrapper</code></a> 类似，
不<a href="http://www.eel.is/c++draft/refwrap#3">提供 weak result type</a> ，不<a href="http://www.eel.is/c++draft/requirements#res.on.functions-2">要求模板参数为完整类型</a>。</li>
<li>保证满足 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4277.html">WG21 N4277</a> 提出的 TrivialCopyable 要求。</li>
<li>提供配套的 <code>ref</code> 和 <code>cref</code> 外还有和 <a href="http://www.boost.org/doc/libs/1_60_0/libs/core/doc/html/core/ref.html">Boost 接口</a>一致但支持 <code>lref</code> 的 <code>is_reference_wrapper</code> 和 <code>unwrap_reference</code> 元函数。</li>
</ul>
</li>
<li><code>mapped_set</code> 用 <code>ystdex::map</code> 模拟 <code>std::set</code> 。
<ul>
<li>不要求键类型保持 <code>const</code> 。这意味着（和 C++98/03 类似）只要不影响比较操作的等价关系，元素可以使用无 <code>mutable</code> 修饰的成员而保持 <code>const</code> 类型检查。</li>
<li>使用 ADL <code>set_value_move</code> 优化插入等操作，允许转移值。</li>
<li>在 C++11 下即支持<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3657.htm">泛型查询</a>接口。</li>
<li>因为使用 <code>ystdex::map</code>  ，支持不完整键类型。</li>
</ul>
</li>
</ul>
</li>
<li>一些通常典型地用于标准库内部实现的接口
<ul>
<li>实际上也适于被用户代码使用。</li>
<li><code>has_mem_value</code> 、<code>has_nested_allocator</code> 和 <code>enable_if_transparent_t</code> 等检查类型要求的元编程设施。</li>
<li><code>search_map</code> 提供关联容器查找，适合实现 <code>map</code> 等的 <code>operator[]</code> 和 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4279.html"><code>try_emplace</code></a> 等设施。
<ul>
<li>支持迭代器提示参数。使用比当前(2016-03) 最新开发版本的 libstdc++ 更紧凑的实现（而 <a href="http://stackoverflow.com/questions/34382073/re-implementing-stdmaptry-emplace-from-c17-in-c11">libc++ 对 <code>map::try_emplace</code>，用 <code>lower_bound</code> 近似</a>，也包括对用户代码提供提示参数的情况（直接忽略提示），后者尽管满足复杂度要求但特定情况下容易更低效。</li>
</ul>
</li>
</ul>
</li>
<li>其它可在 C++11 下使用的标准库扩展
<ul>
<li>ISO/IEC TS 19568:2015 C++ Extensions for Library Fundamentals （最终草案 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html">N4480</a>） 以及 ISO/IEC DTS 19568 C++ Extensions for Library Fundamentals, Version 2 （草案 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4564.pdf">N4564</a>）的一些接口在 C++11 下的实现和 YStandardEx 扩展。
<ul>
<li>提供元函数 <code>and_</code> 、<code>or_</code> 和 <code>not_</code> 。
<ul>
<li>是早于提案 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0013r0.html">P0013R0</a> 的实现。</li>
<li>比原始提案及 libstdc++ 中使用的实现更简单。</li>
<li>以别名模板的形式支持 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0013r1.html">P0013R1</a> 。</li>
</ul>
</li>
<li>函数模板 <code>apply</code> 利用更加强大（投影到不同参数位置进行调用）的 <code>call_projection</code> 实现，而非直接基于 <code>integer_sequence</code> 。</li>
<li>类模板 <code>optional</code> 。</li>
<li>类 <code>any</code> 大体兼容这里的接口规范。</li>
<li>类模板 <code>string_view</code> 。</li>
<li>类模板 <code>observer_ptr</code> 。</li>
<li>部分比较操作使用 Operators 实现，保证一般预期的可用性同时简化实现及改善编译性能，但不完全和规范一致。</li>
</ul>
</li>
<li>函数模板 <code>destroy</code> 是早于提案 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0040r0.html">P0040R0</a> 的实现。
<ul>
<li>使用不同的参数形式被重命名为 <code>destruct</code> 等模板。</li>
<li>实现和 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0040r0.html">P0040R2</a> 兼容的相关接口。</li>
</ul>
</li>
<li>类型特征 <code>unwrap_reference</code> 早于提案 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0318r0.pdf">P0318R0</a> 提供，功能近似。</li>
</ul>
</li>
</ul>
</li>
<li>YFramework
<ul>
<li>一些接口存在第三方的高效实现，但不足以同时在性能和功能上取代现有接口和实现。（以下性能测试因为实际环境基准问题当前仅用于内部测试，未正式支持。）</li>
<li>CHRLib
<ul>
<li>提供的 UTF-8 解码实现之一在主要支持平台（即 MinGW32 ）上实测为当前已知最快的实现。
<ul>
<li>第二快的是 <a href="https://github.com/miloyip/rapidjson">RapidJSON</a> 。虽然同样使用状态转移查找表，它使用刻意避免分支判断的实现机制，使用的表较大而对缓存可能不友好，导致在典型的实现中反而不一定更快。此外实测表明，使用 GCC 的 <code>__attribute__((flatten))</code> 即能明显影响这里的性能，程度和算法优化相比无法忽视。</li>
<li>其它朴素实现都明显落后于<a href="http://bjoern.hoehrmann.de/utf-8/decoder/dfa/">使用状态查找表</a>算法的性能。</li>
</ul>
</li>
</ul>
</li>
<li>YSLib.Core.YEvent
<ul>
<li>在不进行体系结构和 ABI 相关优化的限制前提下，<code>YSLib::GEvent</code> 的性能超过<a href="https://github.com/FrankHB/nano-signal-slot">这里</a>的除了 <code>jl_signal</code> 所有实现。而后者基于特定实现的 ABI 进行了较为复杂的优化。（待定：整合<a href="https://github.com/NoAvailableAlias/signal-slot-benchmarks">新的测试</a>。）</li>
<li>除了没有 Boost.Signal2 的线程安全和定制返回类型策略的接口外，所有功能都不弱于上述测试中的例子。</li>
<li>此外，基于 <code>ystdex::make_expanded</code> 提供允许省略未使用的参数这个实用特性，是以上测试用例都不具备的。事实上，尚没有已知的 C++ 库中提供类似的特性。其它语言可能提供类似的特性简化 GUI 开发，如 <a href="https://msdn.microsoft.com/en-us/library/windows/apps/mt204783.aspx">{x:Bind}</a> ，但实现原理上，其运行时性能不可能超过此处的方式（静态语言在翻译时确定参数列表）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="项目依赖性"><a class="header" href="#项目依赖性">项目依赖性</a></h1>
<p>　　示例项目 YSTest 在 DS 上依赖 YSTest/DS_ARM7 和 YSTest/DS_ARM9 两个项目。
YSTest/DS_ARM9 依赖于 YFramework ；在其它平台直接依赖 YFramework 。</p>
<p>　　YFramework 依赖 YBase 。</p>
<p>　　除了 MinGW 外使用 Make 构建。需要添加静态库时，把相应的 .a 文件加入相应的 lib 目录下，否则需要手动修改对应的 <code>Makefile</code> 。</p>
<p>　　MinGW 使用 Code::Block 或 <a href="Sysroot.zh-CN.html">Sysroot</a> 构建。</p>
<h2 id="生成路径"><a class="header" href="#生成路径">生成路径</a></h2>
<p>　　默认构建的根目录位于版本库下的 <code>build</code> 目录。</p>
<p><strong>注意</strong> 本节以下内容不适用于 <a href="Sysroot.zh-CN.html">Sysroot</a> 。</p>
<p>　　设 <code>$(Platform)</code> 是平台名称，<code>$(Configuration)</code> 是生成配置名称，则各个项目生成的文件和中间文件都在项目的 <code>build/$(Platform)/$(Configuration)</code> 子目录下。修改 <code>Makefile</code> 的配置可以分离生成文件和中间文件的输出路径。</p>
<p>　　默认生成配置名称可以是 <code>debug</code> 或 <code>release</code>（注意此项的大小写会在 <code>Makefile</code> 中表现出区别）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述-1"><a class="header" href="#概述-1">概述</a></h1>
<p>　　NPL 是 YSLib 提供的语言集合，它在语言规范层次上被设计为可扩展的。</p>
<p>　　通过<em>派生(derive)</em> 现有的语言（ NPL 的<em>方言(dialect)</em> ），避免完全重新设计新的语言，来满足需要一些新语言的场合下的需求。被派生的语言是 NPL 的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">抽象语言实现</a>。翻译或执行 NPL 或 NPL 抽象语言实现的程序是 NPL （方言）的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">具体语言实现</a>。具有具体语言实现的方言仍可以派生新的语言作为<a href="https://en.wikipedia.org/wiki/Domain-specific_language">领域特定语言</a>。</p>
<p>　　派生领域特定语言的一个其它的例子是 <a href="https://en.wikipedia.org/wiki/XML">XML</a> 。</p>
<h2 id="语法和语义"><a class="header" href="#语法和语义">语法和语义</a></h2>
<p>　　NPL 的<a href="Features/NPL.zh-CN.html#%E8%AF%AD%E6%B3%95">语法</a>基于形式文法上可递归构造的<strong>表达式</strong>。</p>
<p>　　在操作语义（基于<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E9%87%8D%E5%86%99%E7%B3%BB%E7%BB%9F">项重写系统</a>）的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E8%A7%84%E5%88%99%E5%92%8C%E6%B1%82%E5%80%BC">意义</a>上，其中的子表达式又称为<strong>项</strong>。</p>
<p>　　非正式地，NPL 使用类似 <a href="https://zh.wikipedia.org/wiki/S-%E8%A1%A8%E8%BE%BE%E5%BC%8F">S-表达式</a>的基本语法，但不使用二元有序对（和终止符号）而直接支持列表；即表达式直接以是否为括号作为边界，分为<a href="Features/NPL.zh-CN.html#%E5%88%97%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">列表表达式</a>和非列表表达式。</p>
<p>　　正式语法中，作为子表达式的项可以是列表或非列表项的<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F">复合表达式</a>规约列表项中的一部分代替有序对的地位，以要求任意项可被无歧义地进行从左到右的语法分析。</p>
<p>　　NPL 只要求小括号作为列表表达式的边界。其它替代的括号由<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">派生实现</a>约定。对于适用于多个 NPL 实现的可移植代码，避免使用其它语言中习惯作为代替括号边界的字符表示替代的括号以外的含义，特别地，[ISO C++] 文法 <code>balanced-token</code> 中的边界字符 <code>()[]{}</code> 。</p>
<p>　　NPL 对标识符的限制较为宽松。[ISO C] 和 [ISO C++] 的所有标识符都是 NPL 标识符。但派生实现可加以限制。</p>
<p>　　NPL 不提供专用的注释语法。以特定形式的项（如表示字符串的字面量）替代注释是预期的惯用法(idiom) 。这不妨碍派生语言可能添加预处理器扩展特性。</p>
<p>　　NPL 提供了一些通用的概念和<a href="Features/NPL.zh-CN.html#npl-%E5%85%AC%E5%85%B1%E8%AF%AD%E4%B9%89">公共规则</a>，但不构成<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">具体语言实现</a>的完整语义规则。语义规则由派生实现补充完整。</p>
<p><strong>注释</strong></p>
<p>　　排除注释及中缀标点 <code>;</code> 和 <code>,</code> ，NPL 的语法和 <a href="https://en.wikipedia.org/wiki/Scheme_%28programming_language%29">Scheme 语言</a>或<a href="https://web.cs.wpi.edu/~jshutt/kernel.html">Kernel 语言</a>的语法近似。不过，NPL 不支持构造循环引用，也不提供相关语法。</p>
<h2 id="需求概述"><a class="header" href="#需求概述">需求概述</a></h2>
<p>　　设计满足的需求描述参见<a href="https://github.com/FrankHB/pl-docs/blob/master/en-US/calling-for-language-features.md">这里(en-US)</a> 。</p>
<p>　　需求来源：</p>
<ul>
<li>出发点：构建一个可用计算机实现的语言。</li>
<li>基本目的：在以标准 C++ 环境（ [ISO C++] 定义的<em>宿主实现(hosted implementation)</em> ）的程序框架中嵌入配置和脚本操作。</li>
<li>扩展目的：渐进地向独立的计算机系统演进，探究能适用于各个领域并以计算机实现的<em>通用目的语言(general-purpose language)</em> 。</li>
</ul>
<p>　　本文档描述基于此出发点的 <strong>NPL(Name Protocoling Language)</strong> （一个替代的递归缩写是“NPL's not a Programming Language”，因其不仅适合作为 PL 的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>特性及其参照实现。</p>
<p>　　和大部分其它设计不同，为了确保一定程度的适应通用目的的性质，它们被设计整体首要考虑。这样的设计的语言是（自设计(by desing) 用于）满足通用目的的语言(general-purposed language) 。</p>
<h2 id="其它设计和实现参考"><a class="header" href="#其它设计和实现参考">其它设计和实现参考</a></h2>
<p>　　NPL 是独立设计的语言，但它和 [R<sup>n</sup>RK] 定义的 <a href="https://web.cs.wpi.edu/~jshutt/kernel.html">Kernel 语言</a>有许多核心设计的相似之处，尽管设计的一些基本特征（如<a href="Features/NPL.zh-CN.html#%E8%B5%84%E6%BA%90%E5%8F%AF%E7%94%A8%E6%80%A7%E5%9F%BA%E6%9C%AC%E7%BA%A6%E5%AE%9A">资源可用性基本约定</a>）以及<a href="Features/NPL.zh-CN.html#%E9%A2%86%E5%9F%9F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">基本哲学</a>相当不同。</p>
<p>　　NPL 的<a href="Features/NPL.zh-CN.html#npla1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80">主要实现</a>的核心部分实质上支持了 Kernel 的<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9E%8B">形式模型</a>—— vau 演算(vau calculi) 。</p>
<p><strong>注释</strong> 另见<a href="Features/NPL.zh-CN.html#%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E6%96%B9%E6%B3%95">操作语义</a>。</p>
<p>　　具体的 NPL 语言在这些模型的基础上提供。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0">NPL 的命名</a>即体现了 vau 演算和传统 <a href="Features/NPL.zh-CN.html#%CE%BB-%E5%AE%8C%E5%A4%87%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AF%B9%E5%BA%94%E8%AF%AD%E6%B3%95">λ 演算</a>为模型的语言的核心差异：</p>
<p>　　强调允许在<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>中指定求值上下文的<em>显式求值(explicit evaluation)</em>（而非 Lisp 方言中以 <code>quote</code> 为代表的显式干预默认的隐式求值）的风格以及<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>前后的不同，特别地，关注在语言中直接表达的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">名称</a>和<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>后指称的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">实体</a>的不同。</p>
<p>　　更进一步地，NPL 普遍地支持区分<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">一等引用</a>和被引用的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等实体</a>并具有更精确的资源控制机制，这是与 Kernel 的主要设计上的差异。</p>
<p>　　关于 vau 演算的形式模型和其它相关内容，详见 [Shu10] 。特别地，vau 演算提供了 <a href="https://en.wikipedia.org/wiki/Fexpr">fexpr</a> 类似的抽象。</p>
<p><strong>注释</strong> 另见<a href="Features/NPL.zh-CN.html#npla1-%E8%A7%84%E8%8C%83%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值算法设计的实例</a>。</p>
<p>　　关于一些其它支持 fexpr 特性的语言设计，参见：</p>
<ul>
<li><a href="https://software-lab.de/doc/faq.html#lambda">PicoLisp</a></li>
<li><a href="http://www.newlisp.org/downloads/newlisp_manual.html#define-macro">newLISP</a></li>
</ul>
<p>　　和 Kernel 以及本设计不同，这两个例子的设计使用<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">动态作用域</a>；在主要的特性中存在一些关键的不同而在形式模型的适用性上有显著的区别。</p>
<p><strong>注释</strong></p>
<p>　　NPL 和历史上同名的 <a href="https://en.wikipedia.org/wiki/John_Darlington">John Darlington</a> 的 <a href="https://en.wikipedia.org/wiki/NPL_(programming_language)">NPL (New Programming Language)</a> 没有直接渊源；特别地，后者的多个等式的函数定义语法和高阶类型没有被内建支持，而<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态类型</a>和纯函数式限制被避免。</p>
<p>　　Kernel 语言的原始参照实现是 SINK 依赖 MzScheme version 103 的解释器实现，和 [R<sup>n</sup>RK] 有一定差异。例如，字面量 <code>#ignore</code> 和 <code>#inert</code> 用 <code>%ignore</code> 和 <code>%inert</code> 代替。</p>
<p>　　<em><a href="https://web.archive.org/web/20210301121505/http://klisp.org/">klisp</a></em> 是 Kernel 语言的一个更完善的实现。</p>
<p>　　有些特性（如复数支持）都没有在这两个中实现提供，而仅在 [R<sup>n</sup>RK] 中指定。</p>
<h2 id="实现"><a class="header" href="#实现">实现</a></h2>
<p>　　在 YFramework/NPL 提供一些参考<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">具体语言实现</a>。当前 YFramework 主要使用<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">抽象语言实现</a> <a href="Features/NPL.zh-CN.html#npla">NPLA</a> 的具体<em>派生(derived)</em> 的实现 <a href="Features/NPL.zh-CN.html#npla1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80">NPLA1</a> ，在这个基础上用于不同的目的，如<a href="Features/../Tutorial/Configuration.zh-CN.html">程序配置</a>、<a href="Features/../Tutorial/GUI.zh-CN.html">动态加载的 GUI</a> 等。</p>
<p>　　NPLA 提供了比大多数现有的程序设计语言更强大的一般抽象。这集中体现在：</p>
<ul>
<li>和 NPL 的原始设计一致，不提供也不要求区分实现的阶段(phase) 。</li>
<li>支持<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">一等环境</a>不修改现有语言的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>即可实现共享类似语法的新语言。</li>
<li>允许以一般手段表达求值和未求值表达式的差异。</li>
</ul>
<p>　　这意味着 NPLA 是本质上动态的语言，但和一般语言不同，用户可以很大程度上动态地替换现有语言实现，包括在运行时替换一个解释实现为一个或多个优化编译器。这也意味着语言设计上既不需要区分解释实现和编译实现（本质上不对立），也不需要区分动态和静态（因为随时能从基础语言上构造出静态子集）。</p>
<p>　　这样的特性设计在绝大多数语言中不存在并且几乎无法支持。已知唯一的例外是 <a href="http://web.cs.wpi.edu/~jshutt/kernel.html">Kernel</a> ，在这些特性上有极大的相似，尽管实际上基本特性是<strong>独立设计的</strong>，并且在基本<a href="Features/NPL.zh-CN.html#%E9%A2%86%E5%9F%9F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">设计哲学</a>上有极大不同（ NPL 和 [R<sup>n</sup>RK] 中明确的 guidelines有很大不同且基本不兼容）。不过，考察设计的完整性，NPL 的派生语言也从中借鉴了一些重要的设计：</p>
<ul>
<li><a href="http://lambda-the-ultimate.org/node/4093"><code>$vau</code></a> 、<em>合并子(combiner)</em> /<em>应用子(applicative)</em> /<em>操作子(operative)</em> 等术语。</li>
<li>在<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>中支持模式匹配的<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">形式参数树</a>。</li>
<li>一些以合并子形式提供的操作。
<ul>
<li>一般的作为接口提供的合并子在 NPL 中仍称为函数；合并子是作为表达式的函数的特定的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>。
<ul>
<li><strong>注释</strong> 在 Scheme 中，合并子中的应用子对应<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">过程</a>。</li>
</ul>
</li>
<li>相似的操作主要体现在<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">名称</a>和<a href="Features/../Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">语义</a>上。因为一些基本设计的差异，不保证完全兼容。</li>
<li>相似操作的实现不尽相同，但其中不通过<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>的直接的实现（称为<em>派生(derivation)</em> ）有一部分几乎完全相同。</li>
<li>使用 <code>$</code> 作为一些<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">标识符</a>（如 <code>$lambda</code> ）的前缀是独立设计的巧合；现在含义已和 Kernel 一致，表示 <em>special form</em> 。</li>
</ul>
</li>
</ul>
<p>　　一些值得注意的和类似语言的主要设计差异（原理详见开发文档）：</p>
<ul>
<li>NPL 和 Kernel 类似，强调<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>，但含义有所不同。此处的“对象”和 [ISO C] 及 [ISO C++] 中的定义类似，具有比 Kernel 更严格的含义。
<ul>
<li>和 Kernel 合并子及 Scheme 过程类似，NPLA 默认使用<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值传递</a>参数和结果；但与之不同，不隐式对实际参数<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%88%AB%E5%90%8D">别名</a>，不<a href="Features/NPL.zh-CN.html#%E5%85%B1%E4%BA%AB%E5%BC%95%E7%94%A8">共享</a>对象。</li>
</ul>
</li>
<li>NPLA 和<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">派生实现</a>的语法和整体的求值类似 Scheme 和 Kernel 大多数基于 S-表达式的 <a href="https://en.wikipedia.org/wiki/Lisp_%28programming_language%29">Lisp</a> 方言，但有一些显著的区别。
<ul>
<li>和 Scheme 不同，而和 Kernel 一致，NPLA 避免顶层(top-level) 和局部的上下文的差异。</li>
<li>NPLA1 明确区分约定包括列表项的求值规则。和传统习惯不同，NPLA1 中括号明确不需要表示应用的含义，这可以减少一些场合（如命令行）需要输入的过多的连续括号。</li>
<li>和 [R<sup>n</sup>RS] 定义的 Scheme 以及 [R<sup>n</sup>RK] 定义的 Kernel 一致，不支持某些 Lisp 方言的方括号 <code>[]</code> 替代圆括号 <code>()</code> 的语法。</li>
<li>不提供注释语法。</li>
<li>语言实现中内置预处理处理中缀 <code>;</code> 和 <code>,</code> ，作为前缀合并子 <code>$sequence</code> 和 <code>list</code> 的语法糖。两者的含义和 Kernel 中的相同（类似 Scheme 的 <code>begin</code> 和 <code>list</code> ）。</li>
</ul>
</li>
<li>和 Kernel 相似而和 Scheme 不同，使用操作子及一等环境和 <code>eval</code> 代替 Scheme 的<a href="https://en.wikipedia.org/wiki/Hygienic_macro">卫生宏(hygienic macro)(en-US)</a> 及宏展开的作用。
<ul>
<li>和 Kernel 类似，鼓励使用直接求值风格而不是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%A3%8E%E6%A0%BC">引用(quote)</a> 。</li>
<li>不过 NPLA 也提供了 <code>$quote</code> 的派生而非如 Kernel 一样完全避免。</li>
</ul>
</li>
<li>和 Kernel 不同，NPL 明确支持资源抽象，<strong>不保证支持</strong><a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>，而 NPLA 明确<strong>不支持</strong>循环引用。</li>
<li>NPLA 明确支持基于 [ISO C++] 实现的对象模型和<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>，且明确<strong>不要求</strong>支持全局 <a href="https://zh.wikipedia.org/zh-cn/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_%28%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8%29">GC</a> 。
<ul>
<li>从在互操作的目的出发，和 C++ 具有相似性和相容性。
<ul>
<li>支持基于 <a href="https://eel.is/c++draft/intro.abstract">C++ 抽象机语义</a>的更一般的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>（除原生 <code>volatile</code> 外）和一等状态(first-class states)  。</li>
<li>和 [ISO C++] 类似，在<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>中保留特定的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未定义行为</a>，而不要求实现避免。</li>
<li>暂时不直接支持多线程环境，但可以在不同线程上同时使用不同的实现的实例。</li>
<li>函数默认使用不隐式别名的按值调用和返回传递复制或转移值，和 C++ 对应上下文的复制初始化(copy initialization) 语义一致。（不过求值为操作子的 NPL 函数在 C++ 没有直接的对应。）</li>
</ul>
</li>
<li>在 vau 演算的论文 ([Shu10]) 中，提及不支持全局 GC 有较大的管理开销(admistrative cost) 但没有详细讨论和<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言特性</a>的联系。</li>
</ul>
</li>
<li>即便不支持全局 GC ，当前实现仍然<strong>明确支持</strong> <a href="Features/NPL.zh-CN.html#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C-ptc">PTC(proper tail call)</a> 。
<ul>
<li>PTC 基于语言规则而不是<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">实现行为</a>定义，详见 <a href="https://www.researchgate.net/profile/William_Clinger/publication/2728133_Proper_Tail_Recursion_and_Space_Efficiency/links/02e7e53624927461c8000000/Proper-Tail-Recursion-and-Space-Efficiency.pdf">proper tail recursion</a> ，这里和 Kernel 提供的保证含义一致。</li>
<li>没有在其它语言发现这种不支持全局 GC 和支持类似 C++ 副作用的情形下的 PTC 支持的先例。</li>
</ul>
</li>
<li>和 Kernel 不同，NPLA 不完全强制对象类型的<a href="Features/NPL.zh-CN.html#%E5%B0%81%E8%A3%85">封装</a>；且基于支持互操作的考虑，支持<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%85%A8%E9%9B%86">开放</a>的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">类型系统</a>，而不要求覆盖所有值（即要求对象类型分区(partition) ）。</li>
<li>对机器数（不论是整数还是浮点数）的操作被剥离了，当前不被支持，需要用户代码添加个别操作。</li>
<li>NPLA 的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">规约</a>框架和 vau 演算的<a href="Features/NPL.zh-CN.html#%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E6%96%B9%E6%B3%95">操作语义</a>几乎完全一致，不过实际上（因为先前语言设计上的不确定）显著地保留了更多的可扩展和可修改性。</li>
</ul>
<h2 id="当前具体实现"><a class="header" href="#当前具体实现">当前具体实现</a></h2>
<p>　　当前派生实现的 <a href="Features/NPL.zh-CN.html#npla1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80">NPLA1</a> 由 YFramework 提供 <a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 。其中包括 <a href="https://zh.wikipedia.org/wiki/%E8%AF%BB%E5%8F%96%EF%B9%A3%E6%B1%82%E5%80%BC%EF%B9%A3%E8%BE%93%E5%87%BA%E5%BE%AA%E7%8E%AF">REPL (read-eval-print loop)</a> 的解释实现。外部文件的形式的 NPLA1 脚本可被基于这些 API 实现的 <a href="Features/../Tools/SHBuild.zh-CN.html">stage 1 SHBuild</a> 调用并用于 YFramework 的构建。</p>
<p>　　由 YFramework 对外部编码的假设，NPLA1 实现加载的文件流的剩余内容的编码视为 UTF-8 ；同时支持 CR+LF 或 LF 为换行符。</p>
<p><strong>注释</strong> 这些实现基于 YSLib API 提供互操作支持。</p>
<h1 id="绪论"><a class="header" href="#绪论">绪论</a></h1>
<h2 id="正式引用"><a class="header" href="#正式引用">正式引用</a></h2>
<p>　　仅在此给出本文档中的外部引用的名称。其它引用文献的内容详见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<ul>
<li>[ISO C] <a href="https://www.iso.org/standard/74528.html">ISO/IEC 9899</a></li>
<li>[ISO C++] <a href="https://www.iso.org/standard/79358.html">ISO/IEC 14882</a>
<ul>
<li>[ISO C++11] <a href="https://www.iso.org/standard/50372.html">ISO/IEC 14882:2011</a></li>
<li>[ISO C++14] <a href="https://www.iso.org/standard/64029.html">ISO/IEC 14882:2014</a></li>
<li>[ISO C++17] <a href="https://www.iso.org/standard/68564.html">ISO/IEC 14882:2017</a></li>
<li>[ISO C++20] <a href="https://www.iso.org/standard/79358.html">ISO/IEC 14882:2020</a></li>
<li>[WG21] (ISO/IEC JTC1/SC22/WG21) <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers">C++ Standards Committee Papers</a>
<ul>
<li>[WG21 P0135R1] Richard Smith, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0135r1.html">Wording for guaranteed copy elision through simplified value categories</a>, 2016-06-20.</li>
</ul>
</li>
</ul>
</li>
<li>[R<sup>n</sup>RK] <a href="https://web.cs.wpi.edu/~jshutt/kernel.html">Revised Report on the Kernel Programming Language</a>
<ul>
<li>[Shu09] John N. Shutt, <a href="ftp://ftp.cs.wpi.edu/pub/techreports/pdf/05-07.pdf">Revised<sup>-1</sup> Report on the Kernel Programming Language</a>, Technical report WPI-CS-TR-05-07, Worcester Polytechnic Institute, Worcester, MA, March 2005, amended 29 October 2009.</li>
<li><strong>注释</strong> 当前 [R<sup>n</sup>RK] 只有 <tt>n = -1</tt> 的版本。引用确切版本时，同 [Shu10] 中的用法，使用 [Shu09] 标记；但引用时一般同样不涉及其版本差异。</li>
</ul>
</li>
<li>[Shu10] John N. Shutt, <a href="https://web.wpi.edu/Pubs/ETD/Available/etd-090110-124904/unrestricted/jshutt.pdf">Fexprs as the basis of Lisp function application; or, <code>$vau</code>: the ultimate abstraction</a>, Ph.D. Dissertation, WPI CS Department, 2010.</li>
<li>[R<sup>n</sup>RS] <a href="http://www.scheme-reports.org/">Revised Report on the Algorithmic Language Scheme</a>
<ul>
<li>[R<sup>5</sup>RS] <a href="https://schemers.org/Documents/Standards/R5RS/r5rs.pdf">Revised<sup>5</sup> Report on the Algorithmic Language Scheme</a></li>
<li>[R<sup>6</sup>RS] <a href="http://www.r6rs.org/final/r6rs.pdf">Revised<sup>6</sup> Report on the Algorithmic Language Scheme</a></li>
<li>[R<sup>6</sup>RS-Rationale] <a href="http://www.r6rs.org/final/r6rs-rationale.pdf">Revised<sup>6</sup> Report on the Algorithmic Language Scheme -Rationale-</a></li>
<li>[R<sup>7</sup>RS] <a href="https://small.r7rs.org/attachment/r7rs.pdf">Revised<sup>7</sup> Report on the Algorithmic Language Scheme</a></li>
</ul>
</li>
<li>[EGAL] James Noble, Andrew P. Black, Kim B. Bruce, Michael Homer and Mark S. Miller, <a href="http://web.cecs.pdx.edu/~black/publications/egal.pdf">The Left Hand of Equals</a>, Onward! 2016: <em>Proceedings of the 2016 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software</em>, October 2016, pp. 224–237.</li>
<li>[So90] Harald Søndergaard and Peter Sestoft, <a href="http://www.itu.dk/people/sestoft/papers/SondergaardSestoft1990.pdf">Referential transparency, definiteness and unfoldability</a>, <a href="https://link.springer.com/journal/236"><em>Acta Informatica</em></a> 27, 1990, pp. 505–517.</li>
<li>[Rust] <a href="https://doc.rust-lang.org/reference/index.html">The Rust Reference</a>
<ul>
<li>不定期更新。</li>
</ul>
</li>
<li>[Fl91] Matthias Felleisen, <a href="https://www.ccs.neu.edu/racket/pubs/scp91-felleisen.ps.gz">On the Expressive Power of Programming Languages</a>, <em>Science of Computer Programming</em> <a href="https://www.sciencedirect.com/journal/science-of-computer-programming/vol/17/issue/1">Volume 17, Issues 1–3</a>, December 1991, pp. 35–75.</li>
<li>[Fi94] Andrzej Filinski, <a href="https://dl.acm.org/doi/pdf/10.1145/174675.178047">Representing Monads</a>, POPL '94: <em>Proceedings of the 21st ACM SIGPLAN-SIGACT symposium on Principles of programming languages</em>, February 1994, pp. 446–457.</li>
<li>[Hi90] Robert Hieb, R. Kent Dybvig and Carl Bruggema, <a href="https://legacy.cs.indiana.edu/~dyb/pubs/stack.pdf">Representing Control in the Presence of First-Class Continuation</a>, <em>ACM SIGPLAN Notices</em>, Volume 25, Issue 6, Jun. 1990, pp. 66–77.</li>
<li>[Racket] <a href="https://docs.racket-lang.org/">Racket Documentation</a>
<ul>
<li>不定期更新。</li>
</ul>
</li>
<li>[Chu41] Alonzo Church, <a href="https://compcalc.github.io/public/church/church_calculi_1941.pdf"><em>The Calculi of Lambda-Conversion</em></a>, Annals of Mathematics Studies, Princeton: Princeton University Press, 1941.</li>
<li>[Bare84] Hendrik Pieter Barendregt, <a href="https://philpapers.org/rec/BARTLC"><em>The Lambda Calculus: Its Syntax and Semantics</em></a> [<em>Studies in Logic and the Foundations of Mathematics</em> 103], Revised Edition, Amsterdam: North Holland, 1984.</li>
<li>[Cl98] William D. Clinger, <a href="https://www.researchgate.net/profile/William_Clinger/publication/2728133_Proper_Tail_Recursion_and_Space_Efficiency/links/02e7e53624927461c8000000/Proper-Tail-Recursion-and-Space-Efficiency.pdf">Proper Tail Recursion and Space Efficiency</a></li>
<li>[IEC 60559] <a href="https://www.iso.org/standard/80985.html">ISO/IEC 60559</a></li>
<li>[ECMAScript] <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-262/">ECMA-262</a>
<ul>
<li>[ECMAScript 2019] <a href="https://262.ecma-international.org/10.0/">ECMA-262 10.0</a></li>
</ul>
</li>
</ul>
<h2 id="领域设计原则"><a class="header" href="#领域设计原则">领域设计原则</a></h2>
<p>　　本节描述被本文档中的一些原理讨论引用的的公共依据。</p>
<p>　　原则指关于设计和实现的哲学，同时作为一般规则约束设计和实现的工程阶段。</p>
<p>　　关于需求特别是通用目的语言的讨论，参见<a href="https://github.com/FrankHB/pl-docs/blob/master/en-US/calling-for-language-features.md#module">需求概要(en-US)</a> 。</p>
<h3 id="本体论"><a class="header" href="#本体论">本体论</a></h3>
<p>　　为使论述有效，约定<em>本体论(ontology)</em> 规则。</p>
<p>　　基本的本体论规则是约束逻辑系统构造的公理。</p>
<h4 id="正规性"><a class="header" href="#正规性">正规性</a></h4>
<p>　　有效的陈述（如需求描述）应保证操作上可预期结果。</p>
<p>　　在此意义下，缺乏约束性的规则不可预期的风险是代价。</p>
<p>　　推论：规则应适当约定适用范围，以避免外延不清。</p>
<h4 id="存在性"><a class="header" href="#存在性">存在性</a></h4>
<p>　　语义的存在体现本质。</p>
<p>　　仅仅应用语法规则，即限定为<em>语法的文法(syntactic grammar)</em> 的形式系统归纳的设计，不被视为表示任何<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E8%A7%84%E6%80%A7">有效</a>的含义。</p>
<h4 id="名实问题"><a class="header" href="#名实问题">名实问题</a></h4>
<p>　　名义概念的内涵和外延应被足够显式指定，避免指涉上的歧义，允许构造<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E8%A7%84%E6%80%A7">有效的陈述</a>。</p>
<h4 id="不可分的同一性"><a class="header" href="#不可分的同一性">不可分的同一性</a></h4>
<p>　　<a href="https://plato.stanford.edu/entries/identity-indiscernible/">不可分的同一性(the identity of indiscernibles) (en-US)</a> 比较陈述的客体之间是否相同而不需要被重复地处理。</p>
<h3 id="价值观"><a class="header" href="#价值观">价值观</a></h3>
<p>　　价值观是关于价值判断的规则，其输出为二元的值，决定是否接受决策。</p>
<p>　　作为应对普遍需求场景的不同解决方案选型时的价值判断的抽象归纳，价值观被作为比较是否采用设计相关决策的全局依据。</p>
<p>　　以下陈述形式表达价值优先的选项，同时作为公理。</p>
<p><strong>注释</strong> 相同推理结果仍然可能不唯一，这来自于自然语言描述的输入的不精确性。</p>
<h4 id="变化的自由"><a class="header" href="#变化的自由">变化的自由</a></h4>
<p>　　在明确需求的前提下，尽可能保证对现状按需进行改变的可行性和便利性。</p>
<p>　　适用于一般需求。</p>
<p>　　对计算机软件或其它可编程的实体：尽可能避免不必要地损失可修改性，便于保障按需引入或除去<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">接口</a>及其实现的自由。</p>
<p><strong>原理</strong></p>
<p>　　一般地，需求可能随着不可控的外部条件变化。假设已明确的需求不变只能适合相当有限的情形。积极应对变化能提供价值。</p>
<h4 id="避免不必要付出的代价"><a class="header" href="#避免不必要付出的代价">避免不必要付出的代价</a></h4>
<p>　　尽可能消除对满足需求无意义的代价，减少影响需求实现的整体成本。</p>
<p>　　适用于一般需求中设计决策的比较。</p>
<p>　　对计算机软件或其它可编程的实体：不为不需要的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">特性</a>付出代价。</p>
<p><strong>注释</strong></p>
<p>　　一个类似的表述：</p>
<blockquote>
<p>Efficiency has been a major design goal for C++ from the beginning, also the principle of “zero overhead” for any feature that is not used in a program. It has been a guiding principle from the earliest days of C++ that “you don’t pay for what you don’t use”.</p>
</blockquote>
<p>　　— <a href="https://www.iso.org/standard/43351.html">ISO/IEC TR 18015</a></p>
<h4 id="最小接口原则"><a class="header" href="#最小接口原则">最小接口原则</a></h4>
<p>　　在满足需求的前提下，尽可能使用符合倾向减小实现需求代价的单一良基关系下具有极小元的接口设计。</p>
<p><strong>注释</strong> 减小实现需求的代价，如减小设计工作量。</p>
<p>　　这是一条模式规则，依赖具体情形何者符合良基关系的极小元这条非模式规则作为输入。</p>
<p>　　实际使用时，非模式规则可以直接指定为二元关系的子集，或者一种良序的度量。</p>
<p><strong>注释</strong> 例如，“公开函数声明数”“模块数”。</p>
<p>　　这个输入也可能直接对应符合需求集合的某种最小功能集合而不需要附加度量，如表示某种设计的裁剪。</p>
<p>　　注意规则指定的基数是对实现需求有意义的代价，因此不涵盖<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>。</p>
<p>　　在确定的范围内尽可能少地提供必须的接口，避免不必要的假设影响接口适应需求的能力，同时减少实现需求的各个阶段的复杂性。</p>
<p>　　适用于一般需求的实现，特别地，强调“通用”目的时。</p>
<p>　　对需要在计算机上实现的人工语言设计：设计语言不应该进行功能的堆砌，而应该尽可能减少弱点和限制，使剩下的功能显得必要。</p>
<blockquote>
<p>Programming languages should be designed not by piling feature on top of feature, but by removing the weaknesses and restrictions that make additional features appear necessary.</p>
</blockquote>
<p>　　— [R<sup>n</sup>RS] &amp; [R<sup>n</sup>RK]</p>
<p><strong>注释</strong></p>
<p>　　其它各个领域中的实质等价一些表述包括：</p>
<ul>
<li>用于安全系统设计的<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E7%89%B9%E6%9D%83%E5%8E%9F%E5%88%99">最小特权原则</a>。</li>
<li>用于自然科学理论设计的<a href="https://zh.wikipedia.org/zh-cn/%E5%A5%A5%E5%8D%A1%E5%A7%86%E5%89%83%E5%88%80">奥卡姆剃刀(Occam’s Razor)</a> 原理，避免不必要的假设引入诉诸无知(argument from ignorance) 谬误。</li>
</ul>
<h4 id="关注点分离原则"><a class="header" href="#关注点分离原则">关注点分离原则</a></h4>
<p>　　<a href="https://zh.wikipedia.org/zh-cn/%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB">关注点分离(separation of concerns, SoC)</a> 原则 ：局部设计的内容应和需求的陈述或其它隐含的设计前提分别一一对应。</p>
<p>　　适用于一般需求的实现，特别是其中依赖认识论观点的过程。</p>
<p><strong>原理</strong></p>
<p>　　这条规则利用需求和设计内容陈述中概念外延普遍蕴含的<em>局域性(locality)</em> ，提供给定代价下更多的可行性或求解给定问题时使用较小的代价，用于：</p>
<ul>
<li>应对不可控复杂条件下使问题可解。</li>
<li>局部可复用现有解的子集。</li>
</ul>
<p>　　此外，尽管并非总是必要，应用知识内容的简单假设、<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>和本原则可在认识论上导出还原论。</p>
<h3 id="形而上学"><a class="header" href="#形而上学">形而上学</a></h3>
<p>　　根据作为需求的<a href="Features/NPL.zh-CN.html#%E4%BB%B7%E5%80%BC%E8%A7%82">价值观</a>，归纳适用于通用目的语言应有的构成及其性质（形而上学(metaphysics) ）的设计规则，包括三条价值判断实现公理：</p>
<ul>
<li>设计应尽可能满足<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>。</li>
<li>设计应尽可能满足<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>。</li>
<li>设计的正确性应优先于简单性。</li>
</ul>
<p>　　具备这些性质的设计可视为由<a href="Features/NPL.zh-CN.html#%E4%BB%B7%E5%80%BC%E8%A7%82">价值判断</a>蕴含，预设前提为真的设计<a href="Features/NPL.zh-CN.html#%E6%96%B9%E6%B3%95%E8%AE%BA">方法论</a>的实现。</p>
<p><strong>注释</strong></p>
<p>　　注意和 <a href="https://en.wikipedia.org/wiki/Worse_is_better">worse is better</a> 或 <a href="https://en.wikipedia.org/wiki/Worse_is_better#The_MIT_approach">the MIT approach</a> 不同，设计的性质并非完全并列。特别地，<a href="Features/NPL.zh-CN.html#%E5%AE%8C%E6%95%B4%E6%80%A7">完整性</a>和<a href="Features/NPL.zh-CN.html#%E4%B8%80%E8%87%B4%E6%80%A7">一致性</a>都被作为正确性的一部分考虑。</p>
<p>　　因为<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>，具体需求以及判断正确性和简单性的确切依据都可能会随着项目的进展而变化。</p>
<h4 id="正确性"><a class="header" href="#正确性">正确性</a></h4>
<p>　　设计应正确地反映需求，不在需求的基础上新增作为实现细节以外的不确定性。</p>
<p>　　无法确保满足这种<em>正确性(correctness)</em> 要求时，不应继续设计。</p>
<p>　　正确性包含<em>可行性(feasibility)</em> 。</p>
<p>　　若无法满足正确性，则需求输入存在问题。</p>
<p>　　正确性不包含但应逻辑蕴含设计的一些其它性质。若无法实现，则具体性质的定义存在问题。</p>
<p>　　保持正确性作为设计评价的首要依据以使决策简单，同时能符合<a href="Features/NPL.zh-CN.html#%E4%BB%B7%E5%80%BC%E8%A7%82">价值判断</a>。</p>
<h5 id="完整性"><a class="header" href="#完整性">完整性</a></h5>
<p>　　正确性应蕴含<em>完整性(completeness)</em> ，即确保没有需求被遗漏。</p>
<p>　　推论：设计应包含完整的需求响应。</p>
<p><strong>原理</strong></p>
<p>　　对通用编程语言的一个完整性要求是支持<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算</a>上的<em>可表达性(expresiveness)</em> 。</p>
<p>　　这种性质被称为<em>可有效计算性(effective computability)</em> ，或 <em>Turing 完备性(Turing completeness)</em> 。在可物理实现的计算普遍遵循 <a href="https://zh.wikipedia.org/zh-cn/%E9%82%B1%E5%A5%87%EF%BC%8D%E5%9B%BE%E7%81%B5%E8%AE%BA%E9%A2%98">Church–Turing 论题(Church–Turing thesis)</a> 的情形下，这同时是<em>可计算性(computability)</em> 。以上性质一般不加分辨。</p>
<p>　　特定的场合要求更弱的性质。例如，类型检查等情形需要<em>全(total)</em> 计算而确保实现总是<a href="Features/NPL.zh-CN.html#%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%BA%A6%E5%AE%9A">可终止</a>。这种要求在完整的实现中可通过附加的设施（用户提供的标注或证明）保证，而不应通过系统设计的规则静态地排除，否则实现是不完整的。仅在作为领域特定语言时，通过从需求中排除可计算性，静态规则作为优化是被允许的。</p>
<h5 id="一致性"><a class="header" href="#一致性">一致性</a></h5>
<p>　　正确性应蕴含一致性，即内部的逻辑无矛盾性。</p>
<p>　　推论：设计应保证一致性。</p>
<h4 id="简单性"><a class="header" href="#简单性">简单性</a></h4>
<p>　　在满足正确性的前提下，接口设计应尽可能满足简单性(simplicity)，即尽可能少地具有可被继续简化的内容。</p>
<p>　　接口设计的简单性优先于实现的简单性。</p>
<h4 id="可修改性"><a class="header" href="#可修改性">可修改性</a></h4>
<p>　　<em>可修改性(modifiablity)</em> ：在满足需求的前提下，修改应尽可能少地有碍于其它的接口。</p>
<p>　　这是<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>的推论。</p>
<h4 id="避免抽象泄漏"><a class="header" href="#避免抽象泄漏">避免抽象泄漏</a></h4>
<p>　　<em>泄漏的抽象(leaky abstraction)</em> 指抽象的底层复杂性没有被抽象合理地<a href="Features/NPL.zh-CN.html#%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F">隐藏</a>，而在一定程度上构成了利用抽象时的不必要的依赖。</p>
<p>　　这种<em>抽象泄漏(abstraction leak)</em> 的结果直接和<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>、<a href="Features/NPL.zh-CN.html#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99">关注点分离原则</a>和<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>冲突。</p>
<p>　　同时，抽象的有效性被削弱，泄漏构成的不被预期的依赖难以满足<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>；只要有避免抽象泄漏的方法，就不满足<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>。</p>
<p>　　因此，只要可能，避免抽象泄漏。</p>
<p><strong>注释</strong> 在信息安全意义上，抽象泄漏还可能提供难以抵御的附加的攻击信道。</p>
<h4 id="关注资源限制"><a class="header" href="#关注资源限制">关注资源限制</a></h4>
<p>　　为了可实现性，<em>宿主(host)</em> 系统对总的资源（典型地，运行程序需要的存储）有<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定</a>的上限。</p>
<p>　　除此之外，接口抽象不附加接口语义要求以外的限制。</p>
<p>　　这个原则同时利于满足<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>和<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>。而不遵循这个原则的设计在接口描述上违反<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>。</p>
<p>　　在允许实现的前提下，附加具体<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">特性</a>上的使用限制（如 [ISO C] ）可放宽对实现的要求；但无原则地随意选取此处的限制不足以直接证明具体的限制的有效性，而依赖实际实现的情况才能判断，造成<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F">抽象泄漏</a>。</p>
<p><strong>注释</strong> 实例：<a href="https://software-lab.de/doc/faq.html#lambda">PicoLisp</a> 使用符合此原则的设计。</p>
<h4 id="开放性"><a class="header" href="#开放性">开放性</a></h4>
<p>　　<em>开放性(openness)</em> ：除非另行指定，不假定实体不存在。</p>
<p>　　这个原则主要用于建模(modeling) 的依据。对一般的模型，这个原则称为<a href="https://zh.wikipedia.org/zh-cn/%E5%BC%80%E6%94%BE%E4%B8%96%E7%95%8C%E5%81%87%E5%AE%9A">开放世界假定(open-world assumption)</a>。</p>
<p>　　与之相对，<a href="https://zh.wikipedia.org/zh-cn/%E5%B0%81%E9%97%AD%E4%B8%96%E7%95%8C%E5%81%87%E5%AE%9A">封闭世界假定(closed-world assumption)</a> 需要提前设置一个<em>全集(universe)</em> 以保持至少在逻辑的意义上<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E8%A7%84%E6%80%A7">合规</a>。</p>
<p>　　开放世界的元素的全集是模型的结构化规则推断得到的，而非名义上的定义决定。这同时称为模型的语言的<em>论域(universe of disclosure)</em> 。</p>
<p><strong>原理</strong></p>
<p>　　封闭世界假定表面上可能简化实现，但在一般的模型中是不必要的，因为保持问题合规性的论域应已由清晰的需求描述规范，不应为此阻碍实现<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>。</p>
<p>　　使用封闭世界假定的一个主要实用意义是使模型在有限的信息下能推理出逻辑上更强的结论。在重视结论的知识系统中，这通常是一种优化；但在重视表达能力（而通过其它方式辅助求解问题）的通用模型中，这种前提是一种直接的限制。同时，封闭世界假定的优化不保证对所有输入有效，对否定输入还可能导出一些矛盾。</p>
<p><strong>注释</strong></p>
<p>　　开放世界包含的元素的外延及其语言的论域伴随随<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>的修改而改变。</p>
<p>　　开放世界不限制论域中的某个子集是封闭的。例如，论域中可能存在某个子集的所有元素通过一定方式被枚举。</p>
<h3 id="结构和依赖原则"><a class="header" href="#结构和依赖原则">结构和依赖原则</a></h3>
<h4 id="接口设计和实现分离"><a class="header" href="#接口设计和实现分离">接口设计和实现分离</a></h4>
<p>　　语言设计独立于<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言实现</a>。</p>
<p>　　这是同时应用<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>和<a href="Features/NPL.zh-CN.html#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99">关注点分离原则</a>的推论。</p>
<p>　　这种分离允许<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F">避免抽象泄露</a>。</p>
<p>　　典型地，使用提供接口抽象层作为必要构造的架构方法，即分层设计。</p>
<h4 id="最小特权原则"><a class="header" href="#最小特权原则">最小特权原则</a></h4>
<p>　　<a href="https://zh.wikipedia.org/zh-cn/%E6%9C%80%E5%B0%8F%E6%9D%83%E9%99%90%E5%8E%9F%E5%88%99">最小特权原则(principle of least privilege, PoLA)</a> ：除非有必要，接口抽象不提供满足需求以外的其它信息和资源。</p>
<p>　　这是<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>在限制适用领域前提下的等价表述之一，用于避免不必要的访问路径引入额外的安全(safety) 风险，更容易满足（针对恶意使用风险的）安全性(security) 和可信性保证相关的需求。</p>
<p>　　实质上提供例外的必要性之一是接口正确性：不附加不存在于需求以外的安全设计；根据<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E4%BF%AE%E6%94%B9%E6%80%A7">可修改性</a>，这应是实现细节。</p>
<h4 id="最小依赖原则"><a class="header" href="#最小依赖原则">最小依赖原则</a></h4>
<p>　　最小依赖原则(principle of least dependencies) ：除非有必要，接口实现仅使用必要的依赖。</p>
<p>　　这是<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>的推论之一，其非模式规则的输入为：</p>
<ul>
<li>已知必要的依赖较已知必要的依赖和不必要的依赖的并集要求较小的使用和维护成本。</li>
<li>这里的使用包括演绎抽象自身的推理(reasoning) 。依赖较少时，推理时需要搜索的解空间也越小。</li>
</ul>
<h5 id="单一模块依赖倒置原则"><a class="header" href="#单一模块依赖倒置原则">单一模块依赖倒置原则</a></h5>
<p>　　依赖倒置原则(dependence inversion principle) 在单一模块下包含以下含义：</p>
<ul>
<li>抽象（的接口）不应该依赖（实现）细节。</li>
<li>（实现）细节应依赖抽象（的接口）。</li>
</ul>
<p>　　这是最小依赖原则应用在不同抽象的模块化设计中使用以下公设的推论：</p>
<p>　　抽象是细节包含的子集，依赖抽象的接口较依赖实现细节具有更少的依赖。</p>
<h4 id="可复用性"><a class="header" href="#可复用性">可复用性</a></h4>
<p>　　设计应具有<em>可复用性(reusability)</em> ：高层抽象设计的实现应包括复用此设计的实现的设计。</p>
<p>　　这是<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>的推论之一，其非模式规则的输入为以下公设：</p>
<p>　　一般地，高层抽象设计和复用此设计的实现较单一的高层设计的实现更复杂。</p>
<p>　　此前提条件由对需求工作量可行性分析中的度量验证总是成立。</p>
<p>　　推论：除非必要，不分离抽象设计的实现和复用此设计的实现的设计，避免复杂性。</p>
<p>　　全局意义上的不分离设计不违反<a href="Features/NPL.zh-CN.html#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99">关注点分离原则</a>。</p>
<p><strong>注释</strong></p>
<p>　　典型实例：语言是一种高层抽象设计，语言的<em>库(library)</em> 是一种复用语言的设计。因此，语言实现应包括库设计。</p>
<p>　　另一个实例是<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>设计复用<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>。</p>
<h4 id="可组合性"><a class="header" href="#可组合性">可组合性</a></h4>
<p>　　<em>组合(composition)</em> 是一种特定形式的涉及多个实体的复用，允许复用时不修改被复用的其它实体。</p>
<p>　　<em>可组合(composability)</em> 原则：接口的设计应允许不同设计之间的组合满足这些设计响应以外的需求。</p>
<p>　　这是<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>的推论之一，其非模式规则的输入为以下过程推断得到的引理。</p>
<p>　　公设：一般地，在存在充足基础解决方案的情形下，组合现有解决方案的设计较重新给出不依赖这些解决方案的设计的解节约成本。</p>
<p>　　应用<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>，得到引理：</p>
<p>　　一般地，在存在充足基础解决方案和满足需求限制的情形下，组合现有解决方案的设计优于重新设计。</p>
<p>　　即提升可组合性可减少实现被<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7">复用</a>的设计的成本。</p>
<h3 id="接口设计性质和原则"><a class="header" href="#接口设计性质和原则">接口设计性质和原则</a></h3>
<h4 id="统一性"><a class="header" href="#统一性">统一性</a></h4>
<p>　　接口的设计应具有<em>统一性(uniformity)</em> ：尽可能避免特例。</p>
<p>　　这是要求<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>的推论之一，以<a href="Features/NPL.zh-CN.html#%E4%B8%80%E8%87%B4%E6%80%A7">一致性</a>作为非模式规则输入。</p>
<p>　　无限制的特例要求指定更多的附加规则避免潜在的违反一致性的风险，而违反这个要求。</p>
<p><strong>原理</strong></p>
<p>　　在语言设计上，这类似 [R<sup>n</sup>RK] 的设计原则 G1 ：</p>
<ul>
<li>G1a 对象状态(object status) ：语言操作<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>。</li>
<li>G1b 可扩展性(extensibility) ：用户定义的设施能重现内建<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">特性</a>的<em>能力(capability)</em> 。</li>
</ul>
<p>　　以上原则在 NPL 中略有变化。</p>
<p>　　同 [R<sup>n</sup>RK] ，被 G1b 重现能力的特性是内建的(built-in) 。这不同于如 [R<sup>n</sup>RK] G2 指定的基本的(primitive) 特性。</p>
<p>　　[R<sup>n</sup>RK] 的基本特性指不要求作为派生的(derived) ，即以<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>程序实现的特性。而内建特性适合整个<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规范</a>的接口设计约定，不论其实现是否被派生。不被要求重现的部分是实现细节。</p>
<p>　　但是，因为基本特性不要求能通过对象语言特性的组合实现，在不考虑派生特性的可实现性时，G1b 不会限定基本特性的能力。</p>
<p>　　整体上的 G1b 在和<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>冲突时不被要求。这也避免了 [R<sup>n</sup>RK] §0.1.1 指出的“妥协”。</p>
<p>　　因为语言规范不依赖使用<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>表达，G1b 仅表示用户使用语言的扩展，不表示语言自身的可扩展性；后者通过<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">满足需求的能力</a>和强调支持<a href="Features/NPL.zh-CN.html#%E5%BC%80%E6%94%BE%E6%80%A7">开放性</a>体现。</p>
<p>　　仅通过<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>实现的这种原则在 NPL 的设计中不被视为必要。但偏离这个原则的设计一般同样是不必要的。</p>
<p><strong>注释</strong></p>
<p>　　关于 G1a 的改变，详见<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">一等实体和一等对象</a>。</p>
<h4 id="适用性"><a class="header" href="#适用性">适用性</a></h4>
<p>　　设计应提供<em>适用性(usability)</em> ：合乎预期满足的问题领域的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">特性</a>。</p>
<p>　　对通用目的的领域，应进行权衡。</p>
<p><strong>注释</strong></p>
<p>　　这个原则存在以下的侧重不同使用方式或场景的具体表述。</p>
<p>　　结合用户的经验，这个规则的变体是之一<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%83%8A%E5%A5%87%E5%8E%9F%E5%88%99">最小惊奇原则</a>，强调降低接口的学习和适应成本。</p>
<h5 id="易预测性"><a class="header" href="#易预测性">易预测性</a></h5>
<p>　　设计应符合<em>易预测性(predictability)</em> ：允许但难以偶然实现的危险操作。</p>
<p>　　同 [R<sup>n</sup>RK] 的设计原则 G3 。</p>
<p>　　这里的危险的操作指引起较大代价的不预期或无法预期结果的操作。</p>
<p>　　这是<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>和<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>的推论，包含两方面：</p>
<ul>
<li>避免危险操作的风险是<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E8%A7%84%E6%80%A7">正规性</a>和<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>的推论。</li>
<li>不直接禁止危险的操作以满足上述的允许变化的要求。</li>
</ul>
<p>　　避免危险的操作在许多上下文中可减少程序中易错(error-prone) 的实现的风险。</p>
<h5 id="可用性"><a class="header" href="#可用性">可用性</a></h5>
<p>　　一旦提供<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">特性</a>，应提供<em>可用性(availablity)</em> ：保证一定程度的典型场景下能被使用。</p>
<p>　　绝大多数情形都不能使用的特性是对接口设计的一种浪费，很难符合也通常不符合<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>。</p>
<p>　　可用性的概念有时也指抽象和实体具有的符合这个原则的属性。</p>
<h4 id="最小惊奇原则"><a class="header" href="#最小惊奇原则">最小惊奇原则</a></h4>
<p>　　最小惊奇原则(principle of least astonishment)：在保持合理性的前提下，若能评估目标用户的接受能力，避免违反其直觉的设计。</p>
<p>　　其中，合理性至少应蕴含<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>，一般也蕴含<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>和<a href="Features/NPL.zh-CN.html#%E9%80%82%E7%94%A8%E6%80%A7">适用性</a>同时不违反其它原则（特别应注意尽量保持<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7">可复用性</a>和<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%BB%84%E5%90%88%E6%80%A7">可组合性</a>）。</p>
<p>　　这个原则主要适用于人机交互接口的设计，但也适用于一般的 <a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 。</p>
<p>　　推论：<a href="https://zh.wikipedia.org/zh-cn/%E7%BA%A6%E5%AE%9A%E4%BC%98%E4%BA%8E%E9%85%8D%E7%BD%AE">约定优于配置(convention over configuration)</a> ：约定接口的合理的默认<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">行为</a>，而不是隐藏其行为而提供配置另行实现。</p>
<h4 id="正交性"><a class="header" href="#正交性">正交性</a></h4>
<p>　　在满足<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>的前提下，接口的设计应具有<em>正交性(orthogonality)</em> ：根据需求适当分解为<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7">排除冗余和重复</a>且<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%BB%84%E5%90%88%E6%80%A7">能合理组合</a>的部分。</p>
<p>　　这是<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>和<a href="Features/NPL.zh-CN.html#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99">关注点分离原则</a>在接口设计上的应用。</p>
<p>　　一般地，正交的设计使相同目的可使用更精简的接口组合方式实现。这也使接口具有更强的<em>抽象能力(power of abstraction)</em> 。</p>
<h3 id="方法论"><a class="header" href="#方法论">方法论</a></h3>
<p>　　<em>方法论(methodology)</em> 是严格独立<a href="Features/NPL.zh-CN.html#%E4%BB%B7%E5%80%BC%E8%A7%82">价值判断</a>的规则，是关于<a href="Features/NPL.zh-CN.html#%E4%BB%B7%E5%80%BC%E8%A7%82">价值判断</a>结果参数化的判断规则。</p>
<p>　　不同的价值判断的结果作为方法论输入，决定是否适用此方法。</p>
<p>　　其它方法详见以下各节。</p>
<p><strong>注释</strong></p>
<p>　　一些规则因其主要表述包含价值判断而不在此归纳为方法论，尽管其中一些表述中的前提可以被参数化（如<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">奥卡姆剃刀</a>的“如无必要”的具体必要条件）。</p>
<h4 id="避免不成熟的优化"><a class="header" href="#避免不成熟的优化">避免不成熟的优化</a></h4>
<blockquote>
<p>Premature optimization is the root of all evil (or at least most of it) in programming.</p>
</blockquote>
<p>　　— <em>The Art of Computer Programming</em></p>
<p>　　原始含义适合计算机程序设计中以效率为目标的决策。</p>
<p>　　扩展的外延适用于一般需求，要求：</p>
<ul>
<li>适时收缩理论长度以照顾可操作性。
<ul>
<li>注意断言一个优化过早自身可能就是一个过早的优化。</li>
</ul>
</li>
<li>主动适应需求变更。
<ul>
<li>不同时明确全部的具体需求，只限定需求范围：能使用计算机实现部分语义的任务。</li>
</ul>
</li>
</ul>
<h4 id="封装"><a class="header" href="#封装">封装</a></h4>
<p>　　<em>封装(encapsulation)</em> 是接口设计的合理性准则。</p>
<p>　　封装是<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E5%8F%AF%E5%88%86%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">不可分的同一性</a>的一种实现方式：封装提供的接口以下的所有实现在接口从使用者的角度都是不可分的。</p>
<p><strong>注释</strong> 若存在使用者可感知的<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F">抽象泄漏</a>，这种实现可能失效。</p>
<p>　　以接口的预设风格的价值判断为输入，封装性要求接口满足以下<em>多态性(polymorhism)</em> ：</p>
<p>　　给定接口的替代接口，则替代接口应能代替原接口，当且仅当不引起非预期的可观察的差异。</p>
<p>　　在语言设计中，去除风格参数化的这条原则被作为 <a href="https://zh.wikipedia.org/zh-cn/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99">LSP(Liskov Substitution Principle)</a> 。</p>
<p>　　参数化风格限定并非任意符合 LSP 的接口设计都符合封装性要求。这便于从不期望的设计中剔除不符合其它原则的设计。</p>
<p><strong>注释</strong></p>
<p>　　一些程序设计语言中的封装提供符合 LSP 的<a href="https://zh.wikipedia.org/zh-cn/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">面向对象</a>风格的设施。这些设施把数据和代码组合在一起提供，但仅仅组合并不体现封装性。因此，同时具有<a href="Features/NPL.zh-CN.html#%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F">信息隐藏</a>的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">特性</a>，如 [ISO C++] 的类成员的访问控制的机制，被认为是典型的封装。</p>
<p>　　即便如此，封装在严格意义上和信息隐藏是相互独立的。即便语言不提供信息隐藏而仅仅指定违反封装性不关心实现细节的假设的操作<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">未定义</a>，也不失去封装性。事实上，[ISO C++] 中，使用 <code>reinterpre_cast</code> 无视类的访问控制就是这种例子。</p>
<p>　　另一方面，LSP 事实上关于<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>，不限于以类作为类型的基于类的面向对象风格，实际外延更广。</p>
<h4 id="信息隐藏"><a class="header" href="#信息隐藏">信息隐藏</a></h4>
<p>　　<a href="https://zh.wikipedia.org/zh-cn/%E8%B3%87%E8%A8%8A%E9%9A%B1%E8%97%8F_%28%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8%29">信息隐藏(information hiding)</a> 保持不需要公开的信息不被公开，以使设计符合<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>并支持<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F">避免抽象泄漏</a>。</p>
<p>　　适用于接口及其实现。</p>
<p>　　信息隐藏以是否需要公开信息的<a href="Features/NPL.zh-CN.html#%E4%BB%B7%E5%80%BC%E8%A7%82">价值判断</a>（特别地，关于如何符合最小接口原则）的结果参数化。</p>
<p><strong>注释</strong></p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%B0%81%E8%A3%85">封装</a>的接口通常有助于实现信息隐藏。直接限定避免接口规格具有过多的信息，是另一种直接的实现方式。</p>
<p>　　例如，基于类的<a href="https://zh.wikipedia.org/zh-cn/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">面向对象</a>通过对<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">名称</a>组成的表达式限制对类成员的外部访问，隐藏了类成员的信息，同时提供<a href="Features/NPL.zh-CN.html#%E5%B0%81%E8%A3%85">封装性</a>。</p>
<p>　　其它方式可直接不在外部提供任何访问被封装实体的名称，如 [R<sup>n</sup>RK] 的封装类型(encapsulate type) 和 <a href="https://github.com/tc39/proposal-class-fields/blob/main/PRIVATE_SYNTAX_FAQ.md#how-can-you-model-encapsulation-using-weakmaps">[ECMAScript] 通过 <code>WeakMap</code> 实现的封装</a>。这些封装也同时实现了被封装实体的信息隐藏。</p>
<p>　　即便如此，如关于封装的讨论指出的，封装不一定需要实现信息隐藏。更一般地，信息隐藏的目的也不一定是提供封装。例如，系统的安全性可能直接在需求上要求隐藏特定信息，不论这种信息是否关于某种接口的实现。</p>
<h4 id="模块化"><a class="header" href="#模块化">模块化</a></h4>
<p>　　接口和实现的设计应具有足够的模块化(modularity) ：被划分为若干保持联系的组件即<em>模块(module)</em> ，至少满足<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>和<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%BB%84%E5%90%88%E6%80%A7">可组合性</a>，并强调实现<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7">可复用性</a>。</p>
<p>　　模块化设计通常有利于使设计具有<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E4%BA%A4%E6%80%A7">正交性</a>，但模块化相对可复用性，更侧重可组合性。</p>
<p>　　参数化的输入是需被评估模块化程度的结构设计（包括模块的<em>粒度(granularity)</em> 和组成部分的依赖关系）相对给定需求的实现质量的价值判断。</p>
<h3 id="其它推论和比较"><a class="header" href="#其它推论和比较">其它推论和比较</a></h3>
<p>　　从对<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>的强调可知，较<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>优先考虑<em>通用性(generality)</em> 。</p>
<p>　　这和 [R<sup>n</sup>RK] 中讨论的设计哲学虽然相当不同，但仍允许和 Kernel 具有相似的特性。</p>
<p>　　作为典型的 NPL 的一个<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">派生实现</a>，<a href="Features/NPL.zh-CN.html#npla1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80">NPLA1</a> 具有以下和 Kernel 相似的核心设计：</p>
<ul>
<li>相似的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>算法（差异详见 <a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">NPLA1 求值算法</a>）。</li>
<li><a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">环境</a>可作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>。</li>
<li>支持 <a href="Features/NPL.zh-CN.html#vau-%E6%8A%BD%E8%B1%A1">vau 抽象</a>，且使用<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83%E6%8F%90%E4%BE%9B%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">词法作用域</a>。</li>
<li>强调支持<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>中的<a href="Features/NPL.zh-CN.html#%E5%85%B6%E5%AE%83%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8F%82%E8%80%83">显式求值风格</a>及<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>求值前后的不同。</li>
<li>强调直接求值而非传统 LISP 方言的 <a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%A3%8E%E6%A0%BC"><code>quote</code></a> 。</li>
</ul>
<h1 id="规格说明"><a class="header" href="#规格说明">规格说明</a></h1>
<p>　　在<a href="Features/NPL.zh-CN.html#%E9%99%84%E5%BD%95">附录</a>之前的以下章节给出 NPL 的正式规格说明的公共部分，即<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规范</a>。</p>
<p>　　本文档仅提供部分<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">派生实现</a>的规格说明。关于其它具体规格说明，详见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p>　　在不和其它<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>冲突时，派生实现可能补充或覆盖更确切范围中生效的定义和具体语言规则。</p>
<h2 id="略称"><a class="header" href="#略称">略称</a></h2>
<p>　　仅在不致混淆时使用。</p>
<ul>
<li>实现(implementation) ：<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言实现</a>。</li>
<li>环境(environment) ：<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">实现环境</a>。
<ul>
<li>外部环境：（当前描述的系统边界的）外部的实现环境。</li>
</ul>
</li>
<li>派生实现(derived implementation) ：<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">派生语言实现</a>。</li>
</ul>
<h2 id="补充领域定义"><a class="header" href="#补充领域定义">补充领域定义</a></h2>
<ul>
<li>指令(instruction) ：机器支持的一种可实现<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">程序</a>的编码。</li>
<li>指令集：通过<em>指令(instruction)</em> 的集合提供可编程功能的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">接口</a>。
<ul>
<li><strong>注释</strong> 指令集是提供接口为目的设计的具有相近格式的指令构成的统一<a href="Features/../Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">规范</a>，而非任意指令的集合。</li>
</ul>
</li>
<li>ISA（instruction-set architecture ，指令集架构）：依赖指令集设计的程序之间交互的接口，包括指令集和实现环境的相关假设。
<ul>
<li><strong>注释</strong> 典型情况下，ISA 是软件实现<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">可编程性</a>的最底层次的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">机器接口</a>；更低层次的接口通常依赖不能被纯软件方式访问的机器实现细节。但这并非绝对。</li>
</ul>
</li>
</ul>
<h1 id="整体设计"><a class="header" href="#整体设计">整体设计</a></h1>
<p>　　一些<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>可能显式地由<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">派生实现</a>指定，或补充具体规则。</p>
<p><strong>注释</strong></p>
<p>　　具体讨论设计策略另见需求描述文档。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E9%A2%86%E5%9F%9F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">设计原则</a>的讨论；对本章内容的描述的理解应符合其中的原则。</p>
<h2 id="模型"><a class="header" href="#模型">模型</a></h2>
<p>　　可用计算机实现的语言首先是<em>计算的模型(model of computation)</em> ，或者<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算模型</a>，对<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算</a>进行建模得到。</p>
<p>　　与之相关地，为计算机系统建模作为<em>计算机的模型(model of computer)</em> ，需对有限计算资源的现实进行适应。</p>
<p>　　这些模型可使用<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">形式方法</a>建立，即<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">形式模型</a>。</p>
<p>　　被计算机实现的语言应同时具有这两方面的特征。</p>
<p>　　作为实用的语言，语言还应强调提供<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">可编程性</a>以允许用户利用；这样的语言称为<em>编程语言(programming language)</em> 。</p>
<p>　　本设计尝试在语言的原生设计中应对现有语言缺乏模型问题以避免这些妥协带来的消极影响，同时取得比非模型方法更强的可用性。</p>
<p>　　这种可用性至少体现在语义的精确性可通过模型直接决定；仅为精确性，不需要另行补充模型设计（尽管现有模型可能仍然是不完全形式化的）。</p>
<p><strong>原理</strong></p>
<p>　　以无限的计算资源为前提，理想的模型无法被物理地完全实现，无法直接作为计算机实现的语言的模型。</p>
<p>　　同时，这些模型仅适合对计算建模，并没有强调允许可编程性的实现；扩充可编程设计而保持模型自身的主要性质相当困难。</p>
<p>　　因此，基于计算的模型适配编程语言的设计必然需要妥协：对这些模型的裁剪和补充能提供若干编程语言的模型，但这无可避免地显著地复杂化模型自身，且不利用用户使用简单有效的规则实现通用目的上的可编程性。</p>
<p>　　事实上，使用严格形式化的模型描述编程语言的<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">行为</a>较编程语言自身的发展更落后：</p>
<ul>
<li>大部分编程语言并没有使用模型支持它们的设计。</li>
<li>现实的实用语言，特别地，包括所有主流的<em>工业语言(industrial language)</em> ，几乎都没有在<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">语言规范</a>中给出完整的模型。</li>
<li>通常的实用语言只形式化基本的<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">语法</a>上的规则，无法指导用户精确理解程序的含义。</li>
</ul>
<p>　　这些落后集中体现在的<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">语义</a>模型的缺失，使对编程语言语义的判断取决于规格说明中模型外规则的理解。</p>
<p>　　后验(postpone) 的语义模型可以使用不同<a href="Features/NPL.zh-CN.html#%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E6%96%B9%E6%B3%95">形式语义方法</a>设计，但和语言规范差异的一些本应避免的附加工作，并且通常难以完整地作为标准规格的描述。</p>
<p><strong>注释</strong></p>
<p>　　Turing 机、<a href="https://zh.wikipedia.org/zh-cn/%CE%9B%E6%BC%94%E7%AE%97">无类型 λ 演算(untyped lambda calculus)</a> 等早期计算模型不考虑有限计算资源限制。</p>
<h3 id="计算复杂度约定"><a class="header" href="#计算复杂度约定">计算复杂度约定</a></h3>
<p>　　特定的算法过程具有<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算复杂度</a>要求。除非另行指定：</p>
<ul>
<li>这些复杂度是任意避免符合<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">错误条件</a>的方式调用时求值蕴含的<em>渐进(asymptotic)</em> 时间复杂度。</li>
<li>若指定边界，明确的输入规模以<em>哑变量(dummy)</em> <tt>n</tt> 表示。</li>
<li>指定复杂度的计算保证可<em>终止(terminate)</em> 。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　算法过程也适用<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>上的操作。</p>
<h3 id="资源可用性基本约定"><a class="header" href="#资源可用性基本约定">资源可用性基本约定</a></h3>
<p>　　在<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机</a>的配置中，任意通过<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80"><em>元语言(metalanguage)</em></a> 语法描述的资源总是可用的。</p>
<p>　　为避免对具体资源的总量和实现细节做出假设，除此之外，本设计只要求模型蕴含<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权</a>语义（即便不严格形式化——注意作为元语言的描述模型使用的形式语言仍然可能是实现细节）。</p>
<p>　　具体计算机系统的实现中，保证基本可用的资源被直接映射到程序执行(execution) 的环境中。尽管和适配的软件环境相关，这最终由硬件实现物理地保证。</p>
<p><strong>原理</strong></p>
<p>　　在严格的<a href="Features/NPL.zh-CN.html#%E5%85%B3%E6%B3%A8%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6">资源限制要求</a>下，<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9E%8B">模型</a>不能隐藏预设的无限资源的前提。</p>
<p>　　因此，有必要做出基本的<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>约定以允许表达明确的要求以避免不可实现。</p>
<h2 id="适用领域"><a class="header" href="#适用领域">适用领域</a></h2>
<p>　　为尽可能解决<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9E%8B">模型</a>相关的问题，优先以<a href="Features/NPL.zh-CN.html#%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0">通用目的</a>而不是<em>领域特定(domain-specific)</em> 语言作为评估<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言特性</a>设计的参考原则。</p>
<p>　　领域特定语言的特性应能合理地从支持通用目的的特性中<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">派生</a>，且不影响实际的可用性。</p>
<h2 id="形式语义方法"><a class="header" href="#形式语义方法">形式语义方法</a></h2>
<p>　　<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">形式语义</a>方法是建立<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9E%8B">语义模型</a>的形式方法。</p>
<p>　　形式语义方法主要有<em>公理语义(axiomatic semantics)</em> 、<em>指称语义(denotational semantic)</em> 和<em>操作语义(operational semantics)</em> 。</p>
<p>　　操作语义可分为在<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机</a>中指定具体<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">规约</a>步骤状态的<em>结构化操作语义(structural operational semantics)</em>（或<em>小步(small-step)</em> 语义），及仅指定规约的输入和输出的<em>自然语义(natural semantics)</em>（或<em>大步(big-step)</em> 语义）。</p>
<p>　　非确定语义：经验语义，不需要使用自然语言解释的部分。</p>
<p>　　本文档不直接给出形式语义。<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>确定的经验语义可在一定条件下转写为上述形式语义方法表达的形式。</p>
<h2 id="程序实现"><a class="header" href="#程序实现">程序实现</a></h2>
<p>　　<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">程序</a>是语言的具体派生。实现程序即在语言的基础上指定具体派生规则。</p>
<p>　　<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言实现</a>外的程序是<em>用户程序(user program)</em> 。</p>
<p>　　以程序或另行指定的其它形式实现的可复用程序被归类为<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7">库</a>。</p>
<p><strong>注释</strong> 一般地，不论是语言实现还是用户程序，都可能使用库。</p>
<p>　　除非另行指定，一个程序支持多个库的实例，之间不共享内部的状态。</p>
<p>　　语言特性包含不依赖库的<em>核心语言特性(core language feature)</em> 和<em>库特性(library feature)</em> 。</p>
<h2 id="规范模型"><a class="header" href="#规范模型">规范模型</a></h2>
<p>　　NPL 是抽象的语言，没有<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">具体语言实现</a>，但一些直接影响实现表现形式的规则被本节限定。</p>
<p>　　NPL 的实现可进行<em>抽象解释(abstraction interpret)</em> ，其目标不一定是<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">程序</a>。</p>
<p>　　任一 NPL 实现（和派生实现）的<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">符合性</a>由以下 NPL 符合性规则定义：文档指定的满足对实现的<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">要求</a>的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>子集，包括本节、<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95">基本文法</a>、<a href="Features/NPL.zh-CN.html#npl-%E5%85%AC%E5%85%B1%E8%AF%AD%E4%B9%89">语义</a>和其它派生实现定义的规则。</p>
<p>　　这类规则总是包含对应语言的<a href="Features/NPL.zh-CN.html#npl-%E5%85%AC%E5%85%B1%E8%AF%AD%E4%B9%89">语义的 NPL 公共子集</a>，且蕴含<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">实现行为</a>的要求。</p>
<p>　　<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>约定的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定</a>的程序或实现的属性及实现行为在符合性要求上等价。满足这类规则的前提下，实现选取特定的未指定的属性及对<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定行为</a>的特定实现的选择不影响实现的符合性。</p>
<p><strong>原理</strong></p>
<p>　　基于抽象机可直接定义最小的符合性要求，如 <a href="https://eel.is/c++draft/intro.abstract#6">C++ 的规则</a>。</p>
<p>　　NPL 没有直接在此定义同等具体的规则，而以一般的要求取代。这允许派生实现对不同的具体规则<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">进行补充和调整</a>。特别地，这允许<a href="Features/NPL.zh-CN.html#%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E6%96%B9%E6%B3%95">不同的方式</a>提供语义规则。</p>
<p>　　蕴含实现行为的要求的一个主要例子是关于<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">状态</a>的规则。除了允许由实现定义和派生实现指定的不同，这实质上提供和上述具体规则等价的默认情形，而简化派生实现需要的对语言规则的补充和调整。</p>
<h3 id="实现的执行阶段"><a class="header" href="#实现的执行阶段">实现的执行阶段</a></h3>
<p>　　一个 NPL 的完整实现应保证行为能符合以下的<em>执行阶段(phase of execution)</em> ：</p>
<ul>
<li><em>分析(analysis)</em> 阶段：处理代码，取得适当的 <a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">IR</a> 。</li>
<li><em>（目标）代码生成(target code generation)</em> ：以 IR 作为输入，生成可被其它阶段执行的代码，即<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">目标代码(target code)</a> 。
<ul>
<li><strong>注释</strong> 一般意义的代码生成可以有多个子阶段，包括多种内部 IR 的翻译，直至得到<em>最终目标代码(final target code)</em> 作为输出。</li>
</ul>
</li>
<li>运行：运行生成的最终目标代码。
<ul>
<li><strong>注释</strong> 最终目标代码的形式视不同而定，可能有附加的封装格式。例如<a href="Features/../Terminology.zh-CN.html">编译器</a>的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">目标代码(object code)</a> 经<em>链接(linking)</em> 为可<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">执行</a>的<em>映像(image)</em> ，被<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">加载</a>后形式才能运行。</li>
</ul>
</li>
</ul>
<p>　　其中分析阶段是任意实现必要的，依次包含：</p>
<ul>
<li>词法分析(lexical analysis) ：必要时转换字符编码；<em>转义(escape)</em> 并提取记号。</li>
<li>语法分析(syntactic analysis) ：语法检查（检验语法<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>）并尝试匹配记号和语法规则中的<a href="Features/NPL.zh-CN.html#%E8%AF%AD%E6%B3%95">语法元素</a>。</li>
<li>语义分析(semantic analysis) ：语义检查（检验语义正确性）并实现其它语义规则。</li>
</ul>
<p>　　以上的具体阶段不要求和实际实现中的一一对应，但应保证顺序一致。</p>
<p>　　运行之前的阶段总称为<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80"><em>翻译(translation)</em></a> ，包含各个<em>翻译阶段(phase of translation)</em> 。</p>
<p>　　对有<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">宿主语言</a>支持的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">嵌入实现</a>或目标不是程序的情况，代码生成及之后的阶段不是必须的。</p>
<p>　　宿主语言实现可提供作为<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">客户语言</a>的 NPL 的<em>本机(native)</em> 实现。</p>
<p>　　宿主语言实现提供 NPL 实现环境，同时对 NPL 环境的操作可影响 NPL 程序，这些情形都是<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元编程</a>，NPL 在此同时是<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>。</p>
<p>　　嵌入实现的宿主语言可直接运行语义分析的结果（中间表示）。</p>
<p>　　在语义不变的前提下，允许实现一次或多次翻译部分代码产生部分中间结果并复用。</p>
<p>　　<em>运行时(runtime)</em> 程序实现运行阶段。</p>
<p>　　其它可能的阶段由派生实现定义，但应满足所有阶段具有确定的全序关系，且不改变上述指定的阶段的顺序。符合这些条件的附加阶段称为扩展阶段。</p>
<p><strong>注释</strong></p>
<p>　　字符编码是被翻译的源中的二进制表示相关的模式。</p>
<h3 id="并发实现"><a class="header" href="#并发实现">并发实现</a></h3>
<p>　　一个实现可能具有计算模型意义上的<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">并发</a>属性，即<em>并发实现(concurrent implementation)</em> 。</p>
<p>　　一个实现中顺序执行以上执行阶段的控制流称为一个<em>执行线程(thread of execution)</em> ，简称<em>线程(thread)</em> 。</p>
<p>　　一个实现在整个执行过程中可以有一个或多个线程被执行。是否支持多线程执行（多线程翻译和/或多线程运行）由派生实现定义。</p>
<h3 id="阶段不变量约束"><a class="header" href="#阶段不变量约束">阶段不变量约束</a></h3>
<p>　　若某些状态在某个执行阶段 k 被唯一确定为不可变状态，且在之后的状态下是不变量，则此状态称为满足 k 阶段不变量约束的。</p>
<h2 id="正确性-1"><a class="header" href="#正确性-1">正确性</a></h2>
<p>　　<em>正确性(correctness)</em> 规则约束被执行的程序，包含语法正确性和语义正确性。</p>
<p>　　当正确性规则被发现违反时，实现进入异常执行状态。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%BF%BB%E8%AF%91%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%A7%84%E5%88%99">翻译时正确性规则</a>以外的异常执行条件和状态由派生实现定义。</p>
<h3 id="翻译时正确性规则"><a class="header" href="#翻译时正确性规则">翻译时正确性规则</a></h3>
<p>　　翻译时的异常状态要求给出用于区分正常状态特定的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">行为</a>作为<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">诊断</a>，包括<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">诊断消息</a>和其它派生实现定义的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">实现行为</a>。</p>
<p>　　语法正确性规则是翻译时正确性规则。</p>
<p>　　部分形式上的正确性规则在翻译时确保。</p>
<p>　　允许翻译时确保的形式上正确的程序是<em>合式的(well-formed)</em> ；反之<em>不合式(ill-formed)</em> 。</p>
<p>　　合式的程序符合语法和语义的正确性的规则。</p>
<p>　　其中，实现被要求确保通过翻译的程序符合语法规则和翻译时确保的<em>可诊断(diagnosable)</em> 语义规则。</p>
<p>　　不合式的程序不保证被完整地翻译，应在运行前终止执行阶段。</p>
<h3 id="错误"><a class="header" href="#错误">错误</a></h3>
<p>　　<em>错误(error)</em> 是不满足预期的正确性或其它派生实现定义的不变性质时的特定诊断。</p>
<p>　　非正确性或不满足这些不变性的条件是<em>错误条件(error condition)</em> 。</p>
<p>　　满足错误条件时，实现可<em>引起(signal)</em> 错误。</p>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RS] 中的某些版本指定错误可以不诊断不同，引起错误蕴含诊断。</p>
<h2 id="实现行为"><a class="header" href="#实现行为">实现行为</a></h2>
<p>　　实现的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">行为</a>由具有存在非特定空间上限的存储的<em>抽象机(abstract machine)</em> 描述。这种描述对应的语言的语义是<em>抽象机语义(abstract machine semantics)</em> 。</p>
<p>　　若语言规则明确特定的行为可被忽略，则被忽略之后的实现行为与之前在语言规则中视为等价。翻译的实现可选取这些等价行为中的任一具体行为。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">派生实现</a>可通过<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E6%A8%A1%E5%9E%8B">显式的未指定规则</a>定义附加的等价性。</p>
<p>　　不论程序是否满足<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性规则</a>，实现对程序的执行都可能存在<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未定义行为</a>，此时实现的行为不需要满足正确性规则指定的行为要求。</p>
<p>　　特定的语言规则引入未定义行为。程序的执行在适用这些规则指定的条件时，引起未定义行为。</p>
<p>　　特定的语言规则排除未定义行为的引入，以满足一定的<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>。这不排除程序的执行可能因同时使用的其它语言规则引起的未定义行为。</p>
<p><strong>注释</strong></p>
<p>　　抽象机语义是一种<a href="Features/NPL.zh-CN.html#%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E6%96%B9%E6%B3%95">操作语义</a>。</p>
<p>　　抽象机语义也可非形式地定义语言的正式的(normative) 语义和行为要求，例如 <a href="https://eel.is/c++draft/intro.abstract">C++ 抽象机</a> 。</p>
<h2 id="简单实现模型约定"><a class="header" href="#简单实现模型约定">简单实现模型约定</a></h2>
<h3 id="嵌入宿主语言实现"><a class="header" href="#嵌入宿主语言实现">嵌入宿主语言实现</a></h3>
<p>　　一个派生实现使用外部语言 L 简单实现模型 NPL-EMA ，若满足：</p>
<ul>
<li>以 L 为宿主语言的嵌入实现，不包含<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">扩展执行阶段</a>。</li>
<li>单一实现不保证提供<a href="Features/NPL.zh-CN.html#%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0">多线程执行</a>的支持，但对资源的使用进行适当的分组，以允许多个实现同时在宿主中多线程执行。</li>
</ul>
<p>　　宿主语言提供的实现环境称为宿主实现环境，简称<em>宿主环境(host environment)</em> 。</p>
<p><strong>注释</strong></p>
<p>　　若支持多线程执行，需要附加的显式同步。</p>
<p>　　这种实现可能提供宿主多线程对应的实体，其中包含需要的被隔离的资源。</p>
<p>　　其它语言的实现也可能提供类似的设计，例如 <a href="https://v8.github.io/api/head/classv8_1_1Isolate.html">V8 的 <code>v8::Isolate</code></a> 。</p>
<h1 id="基本文法"><a class="header" href="#基本文法">基本文法</a></h1>
<p>　　本章约定基本的 NPL <a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">文法</a>规则中，包括语法及对应的基础词法。对应的语义<a href="Features/NPL.zh-CN.html#npl-%E5%85%AC%E5%85%B1%E8%AF%AD%E4%B9%89">在下文列出</a>。</p>
<p>　　多态文法规则：<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">派生实现</a>可完全不提供本章明确定义的词法和语法构造的支持，仅当提供同构的替代文法且符合语义规则。</p>
<h2 id="基本文法概念"><a class="header" href="#基本文法概念">基本文法概念</a></h2>
<ul>
<li>字符(character) ：组成语言代码的最小实体。</li>
<li>基本翻译单元(basic transation unit) ：作为<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">翻译</a>输入的任意连续字符的有限序列（可以是空序列）。</li>
<li>翻译单元(translation unit) ：基本翻译单元的集合，之间满足由派生实现定义的规则。</li>
</ul>
<p>　　<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">程序</a>以翻译单元或具体操作指定的以翻译单元进行<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">翻译</a>得到的其它变换形式表示。</p>
<h2 id="字符集和字符串"><a class="header" href="#字符集和字符串">字符集和字符串</a></h2>
<ul>
<li>字符集(character set) ：对一个实现而言不变的字符的有限集合。</li>
<li>基本字符集(basic character set) ：实现环境必须支持的字符集。具体由派生实现定义。</li>
<li>字符串(character string) ：字符集上的序列。</li>
</ul>
<p>　　除非另行指定，关于字符集定义的其它概念同 [ISO C++11] 对 character 和 character set 的有关定义。</p>
<p><strong>注释</strong></p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">字符编码</a>基于字符集定义。</p>
<p>　　一般地，一个翻译单元只具有同一个字符编码。</p>
<h2 id="词法规则"><a class="header" href="#词法规则">词法规则</a></h2>
<p>　　<em>词法规则(lexical rules)</em> 约定在字符基础上的最小一级的可组合为<a href="Features/NPL.zh-CN.html#%E8%AF%AD%E6%B3%95">语法</a>元素单位直接关联的文法规则。</p>
<p>　　约定<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>语法 <code>&lt;x&gt;</code> 表示词法元素 <code>x</code> ，<code>::=</code> 表示定义，<code>|</code> 表示析取。</p>
<h3 id="基本词法构造"><a class="header" href="#基本词法构造">基本词法构造</a></h3>
<p>　　文法：</p>
<pre><code>&lt;token&gt; ::= &lt;literal&gt; | &lt;$punctuator&gt; | &lt;$identifier&gt;
</code></pre>
<ul>
<li>分隔符(delimiter) ：代码中标记特定字符序列模式的字符序列。</li>
<li>词素(lexeme) ：代码中以分隔符确定边界的字符序列。</li>
<li>记号(token) ：词素的顶级分类。</li>
</ul>
<p>　　属于记号的语法元素可以是以下的词法分类：</p>
<ul>
<li>字面量(literal) ：一种记号，参见<a href="Features/NPL.zh-CN.html#%E5%AD%97%E9%9D%A2%E9%87%8F">以下描述</a>。</li>
<li>标点(punctuator) ：由派生实现定义的特定字符序列的集合，可具有一定语义功能。</li>
<li>标识符(identifier) ：除字面量和标点以外的记号</li>
</ul>
<p>　　代码中邻接的分隔符和非分隔符不构成一个词素。</p>
<p>　　不在记号内包含的空白符是分隔符，而不是词素。</p>
<p>　　标点是分隔符，也是词素。</p>
<p>　　超过一个字符的标点可能在匹配字符序列确定是否构成词素时具有词法歧义。此时，应指定消歧义规则确保存在唯一可接受的匹配方式，或引起词法<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">错误</a>终止翻译。</p>
<p>　　除非派生实现指定，字面量以外的记号不包含分隔符。</p>
<p>　　记号是可能附带附加<a href="Features/NPL.zh-CN.html#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90">词法分析</a>信息的词素。词法分析后得到的记号可以用词素映射到词法分类的有序对表示，但 NPL 不要求在此阶段保持分类也不限定表示的构造。</p>
<p>　　可以保证 [ISO C++11] 的 identifier 的定义，或在上述标识符中插入字符 <code>$</code> 构造得到的标识符属于 NPL 标识符。</p>
<p>　　派生实现可定义其它能构成标识符的词素。</p>
<p><strong>注释</strong></p>
<p>　　NPL 不指定超过一个字符的分隔符，因此默认没有词法歧义。派生实现可指定这些规则。</p>
<p>　　NPL 是<em>自由形式(free form)</em> 的语言，空白符原则上不构成字面量以外的词素和语义。</p>
<h3 id="转义序列和字符序列"><a class="header" href="#转义序列和字符序列">转义序列和字符序列</a></h3>
<p>　　文法：</p>
<pre><code>&lt;char-escape-content-seq&gt; ::= &lt;$single-escape-char&gt; | &lt;$escape-prefix-char&gt;&lt;$escape-content-seq&gt;
&lt;char-seq&gt; ::= &lt;$literal-char&gt; | &lt;char-escape-seq&gt;
</code></pre>
<p>　　包含 <code>&lt;char-escape-seq&gt;</code> 的 <code>&lt;char-seq&gt;</code> 包括：</p>
<ul>
<li><code>\'</code></li>
<li><code>\&quot;</code></li>
<li><code>\\</code></li>
<li><code>\a</code></li>
<li><code>\b</code></li>
<li><code>\f</code></li>
<li><code>\n</code></li>
<li><code>\r</code></li>
<li><code>\t</code></li>
<li><code>\v</code></li>
</ul>
<p>　　<code>&lt;char-seq&gt;</code> 的含义同 [ISO C++] 的对应转义序列。</p>
<p><strong>注释</strong> 这是 [ISO C++] 的 <code>&lt;simple-escape-sequence&gt;</code> 词法分类中除了 <code>&quot;\?&quot;</code> 的情形，也是 [R<sup>6</sup>RS] 在 <code>&lt;string element&gt;</code> 中支持的字面情形。</p>
<h3 id="字面量"><a class="header" href="#字面量">字面量</a></h3>
<p>　　文法：</p>
<pre><code>&lt;literal-content&gt; ::= &lt;char-seq&gt; | &lt;literal-char-seq&gt;&lt;literal-data&gt;
&lt;code-literal&gt; ::= '&lt;literal-content&gt;'
&lt;data-literal&gt; ::= &quot;&lt;literal-content&gt;&quot;
&lt;string-literal&gt; ::= &lt;code-literal&gt; | &lt;data-literal&gt;
&lt;literal&gt; ::= &lt;string-literal&gt; | &lt;$derived-impldef-literal&gt;
</code></pre>
<ul>
<li>代码字面量(code literal) ：以 ' 作为起始和结束字符的记号。</li>
<li>数据字面量(data literal) ：以 &quot; 作为起始和结束字符的记号。</li>
<li>字符串字面量(string literal) ：代码字面量或数据字面量。</li>
<li>扩展字面量(extended literal) ：由派生实现定义的非代码字面量或数据字面量的记号。</li>
<li>字面量(literal) ：代码字面量、数据字面量、字符串字面量或扩展字面量。</li>
</ul>
<p>　　派生实现定义的解释可排除代码字面量作为字符串字面量。</p>
<p><strong>原理</strong></p>
<p>　　传统的字面量一般是<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">自求值项</a>，这包括一般的字符串字面量。</p>
<p>　　代码字面量可提供非自求值项的处理方式。</p>
<h3 id="分隔符"><a class="header" href="#分隔符">分隔符</a></h3>
<p>　　以下单字符标点是 NPL 图形分隔符：</p>
<ul>
<li><code>(</code></li>
<li><code>)</code></li>
<li><code>,</code></li>
<li><code>;</code></li>
</ul>
<p>　　以下单字符标点是 NPL 分隔符：</p>
<ul>
<li>NPL 图形分隔符</li>
<li>空白符（字符串 &quot; \n\r\t\v&quot; 中的字符之一）</li>
</ul>
<p><strong>注释</strong></p>
<p>　　空白符同 [ISO C++] <code>std::isspace</code> 在 C 区域下的定义，不含<code>空字符(null character)</code> 。</p>
<p><strong>原理</strong></p>
<p>　　NPL 图形分隔符可不和其它字符组合而作为单独的记号。因此，这不包含构成字面量的字符 <code>'</code> 和字符 <code>&quot;</code> 。</p>
<p>　　NPL 分隔符用于一般分隔记号（而不是识别<a href="Features/NPL.zh-CN.html#%E5%AD%97%E9%9D%A2%E9%87%8F">字面量</a>）的外部描述，也没有显式地包含这些字符，但词法分析仍应把按字面量规则把这些字符作为必要时区分不同记号的边界。</p>
<h3 id="词法分析"><a class="header" href="#词法分析">词法分析</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">词法分析</a>输入<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95%E6%A6%82%E5%BF%B5">翻译单元</a>，输出记号序列。</p>
<p>　　以下规则（按优先顺序）定义了词法分析转换输入为输出的步骤：</p>
<ul>
<li>反斜杠转义：连续两个反斜杠被替换为一个反斜杠。</li>
<li>引号转义：反斜杠之后紧接单引号或双引号时，反斜杠会被删除。</li>
<li>断行连接：反斜杠之后紧接换行符的双字符序列视为续行符，被删除使分隔的行组成逻辑行。</li>
<li>字面量：未被转义的单引号或双引号后进入字面量解析状态，无视以下规则，直接逐字节输出原始输入，直至遇到对应的另一个引号。</li>
<li>窄字符空白符替换：单字节空格、水平/垂直制表符、换行符被替换为单一空格；回车符会被忽略。</li>
<li>原始输出：其它字符序列逐字节输出。</li>
</ul>
<p>　　不对空字符特殊处理。</p>
<p><strong>注释</strong></p>
<p>　　因为不一定是 <a href="Features/NPL.zh-CN.html#%E5%88%86%E9%9A%94%E7%AC%A6">NPL 分隔符</a>，转义字符不总是分隔标识符。</p>
<h2 id="语法"><a class="header" href="#语法">语法</a></h2>
<p>　　本节指定 NPL 作为<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">语法</a>。</p>
<p>　　约定<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>语法 <code>&lt;x&gt;</code> 表示语法元素 <code>x</code> ，<code>::=</code> 表示定义，<code>|</code> 表示析取。</p>
<p>　　程序被作为<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言实现</a>组成部分的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">语法分析</a>程序<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">规约</a>，结果能确定其和一定的语法元素匹配。</p>
<p>　　规约时应进行语法规则的检查。</p>
<h3 id="基本语法构造"><a class="header" href="#基本语法构造">基本语法构造</a></h3>
<p>　　NPL 的基本语法单元是可递归构造的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>，或派生实现指定的其它语法构造。</p>
<p>　　构成基本语法单元的规则参见<a href="Features/NPL.zh-CN.html#%E8%AF%8D%E6%B3%95%E8%A7%84%E5%88%99">词法规则</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%BF%BB%E8%AF%91%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%A7%84%E5%88%99">合式</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95%E6%A6%82%E5%BF%B5">基本翻译单元</a>应是一个或多个基本语法单元。</p>
<h3 id="表达式"><a class="header" href="#表达式">表达式</a></h3>
<p>　　文法：</p>
<pre><code>&lt;expression&gt; ::= &lt;atom-expression&gt; | &lt;composite-expression&gt; | &lt;list-expression&gt;
</code></pre>
<p>　　<em>表达式(expression)</em> 是受表达式语法约束的记号序列，可以是：</p>
<ul>
<li><em><a href="Features/NPL.zh-CN.html#%E5%8E%9F%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F">原子表达式(atom expression)</a></em></li>
<li><em><a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F">复合表达式(composite expression)</a></em></li>
<li><em><a href="Features/NPL.zh-CN.html#%E5%88%97%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">列表表达式(list expression)</a></em></li>
</ul>
<p>　　构成表达式的表达式是被构成的表达式的<em>子表达式(subexpression)</em> 。</p>
<h4 id="原子表达式"><a class="header" href="#原子表达式">原子表达式</a></h4>
<p>　　文法：</p>
<pre><code>&lt;atom-expression&gt; ::= &lt;token&gt;
</code></pre>
<p>　　原子表达式不能被表示为其它表达式的语法构成形式的复合。</p>
<h4 id="复合表达式"><a class="header" href="#复合表达式">复合表达式</a></h4>
<p>　　文法：</p>
<pre><code>&lt;composite-expression&gt; ::= &lt;token-expression&gt; | &lt;expression-token&gt;
</code></pre>
<p>　　复合表达式是原子表达式和表达式的复合，即语法意义上的直接<em>并置连接(juxtaposition)</em> ，不在被复合的表达式之间存在其它记号。</p>
<p>　　同一个表达式可能被按原子表达式出现的位置以不同的方式规约为复合表达式。允许的规约复合表达式的方式由派生实现定义。</p>
<h4 id="列表表达式"><a class="header" href="#列表表达式">列表表达式</a></h4>
<p>　　文法：</p>
<pre><code>&lt;list-expression&gt; ::= &lt;left-list-bound&gt; &lt;expression&gt;* &lt;right-list-bound&gt;
&lt;left-list-bound&gt; ::= ( | &lt;extended-left-list-bound&gt;
&lt;right-list-bound&gt; ::= ) | &lt;extended-right-list-bound&gt;
</code></pre>
<p>　　列表表达式是在其他表达式的序列（可能为空）左右附加一组 <code>&lt;left-list-bound&gt;</code> 和 <code>&lt;right-list-bound&gt;</code> 作为边界构成的表达式。</p>
<p>　　<code>&lt;left-list-bound&gt;</code> 和 <code>&lt;right-list-bound&gt;</code> 是不同的标点。</p>
<p>　　边界为 <code>(</code> 和 <code>)</code> 的表达式是基本列表表达式。其它可能的边界由派生实现定义，构成扩展列表表达式。</p>
<p><strong>注释</strong></p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%88%97%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">列表表达式</a>的边界是 <a href="Features/NPL.zh-CN.html#%E5%88%86%E9%9A%94%E7%AC%A6">NPL 图形分隔符</a>。</p>
<h3 id="名称"><a class="header" href="#名称">名称</a></h3>
<p>　　NPL 的<em>名称(name)</em> 是符合语法规则约束的若干<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">记号</a>的集合。</p>
<p>　　存在非空的名称集合可被作为<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>。</p>
<p><strong>原理</strong></p>
<p>　　<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">名称</a>的集合是<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">广义实体</a>和<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">实体</a>的差集。</p>
<p>　　语言规则对语言可表达的名称添加要求，以使语言的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源代码</a>能够直接使用名称。</p>
<p>　　名称在源代码形式之外也可广泛存在，且能通过不唯一的方式构造。因此，语言规则允许不和源代码形式一一对应的名称。</p>
<p><strong>注释</strong></p>
<p>　　构成名称的集合的表现形式不唯一。</p>
<p>　　特定的名称可能为空集。</p>
<p>　　约束通常包含顺序，即其中的记号构成确定顺序的序列。</p>
<p>　　记号或记号集合经<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">编码</a>，一般可实现为可表达的字符串。</p>
<h3 id="语法形式"><a class="header" href="#语法形式">语法形式</a></h3>
<p>　　<em>语法形式(syntactic form)</em> 是词法上满足特定<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">形式</a>的语法构造。</p>
<p>　　除非派生实现另行指定，语法形式总是表达式。</p>
<h3 id="语句"><a class="header" href="#语句">语句</a></h3>
<p>　　以派生实现定义的标点结尾的表达式称为<em>语句(statement)</em> 。</p>
<p>　　语句语法的<em>分组(grouping)</em> 规则以及是否隐式地作为列表表达式<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>由派生实现定义。</p>
<h3 id="简单文法约定"><a class="header" href="#简单文法约定">简单文法约定</a></h3>
<p>　　一个派生实现使用简单文法 NPL-GA ，若满足：</p>
<ul>
<li>翻译单元同<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95%E6%A6%82%E5%BF%B5">基本翻译单元</a>。</li>
<li>只支持左原子表达式构成<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F">复合表达式</a>。</li>
<li>只支持基本<a href="Features/NPL.zh-CN.html#%E5%88%97%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">列表表达式</a>。</li>
<li>标点为单个<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95%E6%A6%82%E5%BF%B5">字符</a>。</li>
<li>若支持语句，总是 NPL-GA <a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　NPL-GA 允许一些典型的<em>分析器(parser)</em> 简化设计作为实现。</p>
<p>　　在<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>的形式文法仅作为语法规则，使用<a href="Features/NPL.zh-CN.html#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90">词法分析</a>的结果提供作为<em>语法类别(syntactic category)</em> 的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">词素</a>的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">串</a>作为输入的情况下，NPL-GA 支持 LL(1) 文法分析，即使用 NPL-GA 语法。</p>
<p>　　若延迟<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F">复合表达式</a>和<a href="Features/NPL.zh-CN.html#%E5%88%97%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">列表表达式</a>中的选择到分析器外（之后可能由语义处理），检查语法的判定程序可进一步简化，仅判断记号 <code>(</code> 和 <code>)</code> 的匹配。</p>
<p>　　若词法分析处理直接对 <code>(</code> 和 <code>)</code> 和进行<em>记号化(tokenize)</em> 标记，则 NPL-GA 分析器不需要支持其它判定。这样的分析器实现的 NPL-GA 子集等效 LL(0) 文法。但由于 NPL-GA 不限定语法元素具体数量，等效 LL(0) 分析器当且仅当输入的串终止时接受输入，因此是<em>平凡的(trivial)</em> ，通常不具有实际意义，因为：</p>
<ul>
<li>形式上这里只有算法步骤的多少的差异，而几乎所有实现的语言都不把它作为<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>。</li>
<li>即便需要统计串的长度，也应可以在之前（词法分析）计算，使用语法分析完成这个任务在此是低效的。</li>
</ul>
<p>　　反之，在分析 NPL-GA 语法前扩展其它语法<em>预处理(preprocessing)</em> 规则可以支持更多的文法扩展。这样的文法扩展可接受扩展的非 NPL-GA 文法，但仍允许保持语法分析器的实现使用 NPL-GA 语法。</p>
<h1 id="npl-公共语义"><a class="header" href="#npl-公共语义">NPL 公共语义</a></h1>
<p>　　NPL 的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">语义规则</a>构成<a href="https://en.wikipedia.org/wiki/Formal_system#Deductive_system"><em>演绎系统(deductive system)</em> (en-US)</a> ，通过对<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95%E6%A6%82%E5%BF%B5">翻译单元</a>中的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>表达。</p>
<p>　　除非<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">派生实现</a>另行指定，仅使用表达式指定关于<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>中的计算的语义。</p>
<p>　　基本语义规则要求：</p>
<ul>
<li>所有不需要<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">诊断消息</a>的规则由派生实现定义。</li>
<li>本章内的规则应不引入<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未定义行为</a>。</li>
</ul>
<p>　　NPL 允许程序具有语义等价的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定行为</a>。派生实现可能通过约定和限制其具体选项的选取以指定更具体的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">实现行为</a>。</p>
<h2 id="基本语义概念"><a class="header" href="#基本语义概念">基本语义概念</a></h2>
<ul>
<li>区域(region) ：和特定位置代码关联的有限<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">实体</a>集合。</li>
<li>范围(range) ：一个连续区间。
<ul>
<li>此处“连续”的概念由派生实现定义，默认参照数学的形式定义。</li>
</ul>
</li>
<li>声明(declaration) ：引入单一<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0">名称</a>的表达式。</li>
<li>声明区域(declarative region) ：对某一个声明及其引入的名称，通过<a href="Features/NPL.zh-CN.html#%E5%A3%B0%E6%98%8E%E5%8C%BA%E5%9F%9F%E7%BA%A6%E5%AE%9A">声明区域规则</a>决定的范围。</li>
<li>有效名称(valid name) ：可以唯一确定<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">指称</a>的实体的名称。</li>
<li>有效命名实体(valid named entity) ：有效名称指称的实体。</li>
<li>名称隐藏(name hiding) ：若同一个名称在同一个位置属于超过一个声明区域，则应能通过<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E8%A7%81%E5%90%8D%E7%A7%B0">名称隐藏规则</a>确定唯一有效的声明以指定有效名称和对应的有效命名实体，此时有效名称隐藏其它声明区域声明的名称，有效命名实体隐藏可以使用被隐藏名称指称的实体。</li>
<li>作用域(scope) ：声明区域的子集，满足其中指定的名称是有效名称。</li>
<li>生存期(lifetime) ：逻辑上关于实体的<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>的连续区间的抽象，是一个闭集。</li>
<li>同一性(identity) ：实体上的一种等价关系，允许实体具有标识不相等特定的属性（如占据存储）。</li>
<li>对象(object) ：可确定同一性的实体。</li>
<li>常量(constant) ：满足某种不变量的约束以和不可变<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">状态</a>关联的实体。具体由派生实现定义。注意不和变量对立（表示不可变状态的变量可能是常量）。</li>
<li>值(value) ：表达式关联的不可变状态。
　　* 作为实体，对象总是关联值作为它的内容，称为<em>对象的值(value of object)</em> 。</li>
<li>未指定值(unspecified value) ：<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定</a>的值。</li>
<li>修改(modification) ：使状态改变的操作。</li>
<li>作用(effect) ：语言支持的一定上下文内的表达式规约蕴含的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">计算作用</a>。</li>
<li>副作用(side effect) ：对表达式的值以外的表示的改变的作用。</li>
<li>幂等性(idempotence) ：重复后即不改变状态的性质。</li>
<li>项(term) ：特定的演绎系统中处理的对象，是带有基本递归构造的元素，可对应语法中的表达式。
<ul>
<li><strong>注释</strong> 这样的演绎系统主要是<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E9%87%8D%E5%86%99%E7%B3%BB%E7%BB%9F">项重写系统</a>。</li>
</ul>
</li>
<li>子项(subterm) ：具有递归形式构造的文法描述的参与构成项的项。</li>
<li>变量(variable) ：通过声明显式引入或通过演绎系统规则隐式引入的以名称指称的实体。</li>
<li>绑定(binding) ：引入变量的操作或结果，其中后者是变量的名称和引入的被变量表示的实体构成的有序对。</li>
<li>约束变量(bound variable) ：子项中出现的名称被绑定的变量，即其指称可能依赖具体上下文的变量。
<ul>
<li>同名的约束变量的整体重命名替换不保证不改变指称进而可能影响语义。</li>
</ul>
</li>
<li>自由变量(free variable) ：子项中出现的非约束变量。</li>
<li>组合子(combinator) ：不是变量也不含相对任何项的自由变量作为子项的项。</li>
<li>转换(conversion) ：根据基于特定等价性（假设）前提的两个项之间的自反的演绎。</li>
<li>规约(reduction) ：两个项之间的、<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">实例</a>是某个转换的子集的满足反自反的演绎。</li>
<li>抽象求值(abstract evaluation) ：对表达式的不取得作用的规约。</li>
<li>具体求值(concrete evaluation) ：对表达式的取得作用的规约。</li>
<li>求值(evaluation) ：抽象求值或具体求值。</li>
<li>求值结果(evaluation result) ：作用的子集，是求值得到的用于替换被求值的表达式的表达式或其它由派生实现定义的实体。不和其它结果混淆时，简称<em>结果(result)</em> 。</li>
<li>控制状态(control state) ：实现中决定求值的状态。</li>
<li>控制作用(control effect) ：引起控制状态改变的作用。在 NPL 中，控制作用是在对象或派生实现定义的实体上引起改变的副作用。</li>
<li>相等关系(equality relationship) ：定义在值的集合上的等价关系。</li>
<li>布尔值(boolean value)：逻辑真或逻辑假。</li>
<li>谓词(predicate) ：若具有结果，则结果是布尔值的计算实体。</li>
<li>一等实体(first-class entity) ：语言表达的中允许足够操作的子集（使用的判定准则和 [R<sup>n</sup>RK] Appendix B 的 first-class object 的约定一致）的实体。</li>
<li>一等对象(first-class object) ：可确定同一性的一等实体。</li>
<li>访问(access) ：从实体上取得状态或修改实体。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　在实现执行的上下文，生存期概念兼容 <a href="https://www.iso.org/standard/63598.html">ISO/IEC 2382</a> 的 lifetime 定义：</p>
<blockquote>
<p>portion of the execution duration during which a language construct exists</p>
</blockquote>
<p>　　定义绑定的有序对作为抽象表示，不需要被对象语言支持。对象语言可支持其它具体的有序对数据结构。</p>
<p>　　典型地，作用包括计算得到的值、引起的副作用以及其它可由区域和变化的状态二元组描述的实体。</p>
<p>　　一等对象同时是对象。</p>
<p>　　为满足可在表达式中通过求值被使用，一等实体总是能关联表达求值结果的值，称为实体的值。</p>
<h3 id="表示"><a class="header" href="#表示">表示</a></h3>
<p>　　<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">表示</a>用于表现演绎实例、具体实现及其中一部分实体的状态。</p>
<p><strong>注释</strong> 其中的一部分实体可以是某个值。</p>
<p>　　因为保证同一性，对象的值作为<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可变状态</a>的表示时，即对象存储的值。</p>
<p><strong>注释</strong> 变量不一定是可变状态的表示。</p>
<p>　　<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">外部表示</a>和<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">内部表示</a>是相对的。不同<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">外部环境</a>可以有不同的外部表示，这些外部表示相对其它外部环境而言可以不是外部表示。</p>
<p>　　外部表示可能被<em>读取(read)</em> 处理为内部表示。内部表示可能被<em>写入(write)</em> 处理为外部表示。</p>
<p>　　读取和写入操作的副作用分别是<em>输入(input)</em> 和<em>输出(output)</em> 。</p>
<p>　　外部表示为元素序列时，读取和写入是非特定格式数据和元素序列之间的转换，若不含其它<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>，其操作是进行<em>反序列化(deserialize)</em> 和<em>序列化(serialize)</em> 。</p>
<p>　　内部表示为对象时，读取和写入包含对象和非特定格式数据之间的转换，其操作是进行<em>列集(marshall)</em> 和<em>散集(unmarshall)</em> 。</p>
<p>　　除非另行指定，不要求对象语言提供内部表示到外部表示的转换。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95">文法</a>约定基准的表示作为<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">翻译</a>的输入。这种表示是翻译所在外部环境的外部表示，即<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源代码</a>；翻译结果是对象语言代码，简称<em>对象代码(object code)</em> ，可以是另外的外部表示。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95%E6%A6%82%E5%BF%B5">翻译单元</a>是这里被翻译的外部表示。</p>
<p>　　由<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95">基本文法</a>，空白符和参与的表示，不一一对应。为便于输出标准化，NPL 约定以下<em>规范(canonical)</em> 外部表示：</p>
<ul>
<li>对列表，输出的表示是以 <code>(</code> 和 <code>)</code> 作为边界，元素以单个 <code> </code> 为分隔符的序列，其中的元素在括号中被递归地嵌套表示。</li>
<li>对非列表的存在唯一的对应词法形式（如字面量）的值，输出这个值的词法形式。</li>
<li>其它值的外部表示<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定</a>。
<ul>
<li><strong>注释</strong> 值自身可能<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定</a>。<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">未指定值</a>通常蕴含未指定的外部表示，但不绝对。</li>
</ul>
</li>
</ul>
<p>　　谓词在模型中表示为数学关系、映射或单值函数；在对象语言中可有不同的表示，如<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数</a>。</p>
<p>　　其它外部表示和内部表示的外延由派生实现定义。</p>
<h3 id="演绎规则"><a class="header" href="#演绎规则">演绎规则</a></h3>
<p>　　演绎系统具有的演绎规则决定演绎推理(deductive reasoning) 的输出。</p>
<p>　　指定转换输入和输出之间的关系的演绎规则是转换规则。</p>
<p>　　两两可转换的对象的传递闭包构成<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">等价类</a>，称为可转换等价类。除非另行指定，以下只讨论具有单一可转换等价类的转换规则演绎系统，即（抽象）<em>重写系统(rewriting system)</em> 。</p>
<p>　　对象之间的转换保持某种<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">等价关系</a>的等价<em>变换(transformation)</em> 。对象之间的规约是其中的子集，即以存在等价关系的一个对象替代另一个对象的有向转换。</p>
<p>　　若两个对象具有规约到相同结果的变换，这两个对象<em>可连接的(joinable)</em> 。</p>
<p>　　若任意两个对象等价蕴含对象可连接，则此重写系统具有 <em>Church–Rosser 属性(Church–Rosser property)</em> 。</p>
<p>　　若可从任意一个对象规约到的任意两个对象可连接，则重写系统具有<em>汇聚性(confluence)</em> 。</p>
<p>　　若可从任意一个对象的一步规约到的任意两个对象可连接，则重写系统具有<em>局部汇聚性(local confluence)</em> ，或称为<em>弱汇聚性(weak confluence)</em> 。</p>
<p>　　若可从一个对象规约到的任意两个对象可连接，则此对象具有汇聚性。</p>
<p>　　若可从一个对象的一步规约到的任意两个对象可连接，则此对象具有局部汇聚性，或称为弱汇聚性。</p>
<p>　　规约中可包括涉及<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">实现环境</a>的交互。</p>
<p>　　若规约用于求值，汇聚性限定为：满足任意以此规则变换前和变换后的项被分别规约时，两者的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>相等。</p>
<h3 id="项重写系统"><a class="header" href="#项重写系统">项重写系统</a></h3>
<p>　　作为<a href="Features/NPL.zh-CN.html#%E6%BC%94%E7%BB%8E%E8%A7%84%E5%88%99">重写系统</a>的实例，一个<a href="https://en.wikipedia.org/wiki/Rewriting#Term_rewriting_systems"><em>项重写系统(term rewriting system)</em></a> 包含以下组成：</p>
<ul>
<li>语法元素(syntactic element) 的集合。
<ul>
<li>项及其子项是语法元素的非空的串。</li>
</ul>
</li>
<li>辅助语义函数(auxiliary semantic function) 的集合。
<ul>
<li>可通过语义变量(semantic variable) 指称其中的元素。</li>
</ul>
</li>
<li><em>重写规则(rewrite rule)</em> 的集合。
<ul>
<li>重写规则指定<em>重写(rewrite)</em> ：接收项输入并产生作为重写的输入的项，和被重写的项之间满足某种<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">等价关系</a>即<em>重写关系(rewrite relation)</em> 。</li>
<li>重写规则集合以包含语法元素和语义变量的重写关系在<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>中表达为<em>模式(scheme)</em> 。</li>
</ul>
</li>
</ul>
<p>　　为表达计算，限制特定的重写关系使之不满足自反性，得到<em>规约关系(reduction relation)</em> ，即指定<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">规约</a>。对应地，双向的重写规则限制为其子集的单向的<em>规约规则(reduction rule)</em> 。经限制的系统是<em>项规约系统(term reduction system)</em> 。</p>
<p>　　规约关系视为表达计算查询(computational query) 的项和答案(answer) 的项之间的映射。此时，项规约系统被作为一种<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9E%8B">计算模型</a>。</p>
<ul>
<li><strong>注释</strong> 为表达计算的答案的确定性，需要确保规约可能取得<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">范式</a>。</li>
</ul>
<h3 id="状态和行为"><a class="header" href="#状态和行为">状态和行为</a></h3>
<p>　　状态不变由实现定义的<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">等价关系</a>决定。</p>
<p>　　除非派生实现另行指定，约定：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">实现行为</a>总是可使用状态进行描述。</li>
<li>存在<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>为<em>可观察(observable)</em> 行为的必要条件。</li>
<li>在实现外部<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>某个状态的操作（输入/输出操作）是副作用。</li>
</ul>
<p>　　若存在状态等价性以外描述的行为描述，由派生实现指定。</p>
<p>　　可观察行为如有其它外延，由派生实现指定；否则存在副作用是存在可观察行为的充分条件。</p>
<p>　　实现应满足实现行为和语义蕴含的可观察行为等价，其余行为等价性<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定</a>。</p>
<p>　　实现可支持实体具有对外部不引起可观察行为差异的<em>隐藏状态(hidden state)</em> 。</p>
<p>　　隐藏状态和程序约定的一些状态作为<em>管理状态(administrative state)</em> ，以隐藏局部的状态变化对程序中其它状态的影响。</p>
<p>　　非管理状态是<em>数据状态(data state)</em> 。</p>
<p><strong>原理</strong></p>
<p>　　形式上，可观察的性质影响特定的项的<em>操作等价性(operational equivalence)</em> ：替换操作等价的项得到的两个规约在可观察性质上是等价的，即两个规约的结果相等（对应行为不可分辨）。因此，可观察的性质可形式化为作为这些等价规约的结果的参数。</p>
<p>　　最简单的做法，如 [Shu10] §8.3.2 把具有可观察性质的项处理为常量语法域(syntactic domain) ，不需要附加定义相等性或影响其它规约规则。</p>
<p>　　对语义蕴含的可观察行为等价的要求指定了允许实现进行<em>语义保持变换(semantic preserving transformation)</em> 不能修改可观察性质的内涵，进而明确了实现对程序的可优化的界限。</p>
<p>　　数据状态和管理状态的分类类似 [R<sup>n</sup>RK] 中改变对象的性质上对状态的划分，但不仅仅应用在关于改变对象的判断上。</p>
<p>　　改变对象意义上和 [R<sup>n</sup>RK] 对应的具体实例是<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">实体的不可变性</a>。</p>
<p><strong>注释</strong></p>
<p>　　不严格要求实现行为和<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机语义</a>蕴含的所有推论一致。</p>
<p>　　NPL 派生实现不保证是纯函数式语言，其中的<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算</a>允许描述状态的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">改变</a>。表达式的求值的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>和 [ISO C] 以及 [ISO C++] 类似。不同的是，本文档的定义明确指定<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制作用</a>的更一般外延：改变<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制状态</a>，即便这些状态并非从属<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等实体</a>。特别地，最简单的条件分支也明确具有副作用。</p>
<h3 id="作用使用原则"><a class="header" href="#作用使用原则">作用使用原则</a></h3>
<p>　　派生实现可定义其它的作用。</p>
<p>　　副作用应仅在必要时引入。</p>
<p><strong>原理</strong></p>
<p>　　允许派生实现定义不同的作用以维护<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>。</p>
<p>　　不同<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>对<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">行为</a>的影响可能依赖作用之间的顺序。</p>
<p>　　因此，副作用应仅在必要时引入，且通常需明确区分是否依赖副作用以避免非预期的行为。这有助于保持<a href="Features/NPL.zh-CN.html#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测性</a>和<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%BB%84%E5%90%88%E6%80%A7">可组合性</a>。</p>
<p><strong>注释</strong></p>
<p>　　派生实现可定义的其它的作用可能是副作用。</p>
<h2 id="实体语义"><a class="header" href="#实体语义">实体语义</a></h2>
<p>　　实体是语言中主要表达的目标。</p>
<p>　　本节提供和实体相关的公共定义和语义规则，并归纳关于<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等实体</a>和<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>的性质。</p>
<p>　　仅在特定局部上下文中操作非一等实体。</p>
<p><strong>原理</strong></p>
<p>　　限制非一等实体出现的规则有助于<a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">统一性</a>。</p>
<p><strong>注释</strong></p>
<p>　　根据<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">一等实体和一等对象</a>，<a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">规则 G1a</a> 是限制非一等实体的规则的推论。</p>
<p>　　一等实体的<em>一等(first-class)</em> 性质体现在语言支持的操作限制足够小，使之实例的全集可以涵盖任意<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">求值上下文</a>中。</p>
<p>　　一个一等性质的反例是 [ISO C] 的数组类型的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>无法作为函数的形式参数。推论：[ISO C] 的数组对象不是一等对象。</p>
<h3 id="实体的等价性"><a class="header" href="#实体的等价性">实体的等价性</a></h3>
<p>　　<em>等价谓词(equivalence predicate)</em> 是判断<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">等价关系</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">谓词</a>。</p>
<p>　　等价谓词可定义一些<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">等价类</a>划分。</p>
<p>　　语言提供等价谓词判断两个项之间是否满足等价关系，满足判断等价关系的需要。</p>
<p>　　作用于<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">实体的值</a>的等价谓词（若存在）定义实体的<em>相等(equality)</em> 关系。</p>
<p><strong>注释</strong> 这类似一般的值的集合上可能存在的相等关系。</p>
<p>　　决定相等关系的谓词是相等谓词，可判断实体和实体的值<em>相等(equal)</em> 。</p>
<p>　　除非另行指定，默认实体上的具体等价关系是<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">实体的同一性</a>。</p>
<p>　　对象语言不要求提供默认的具体等价关系，即任意两个实体不一定可以比较等价。</p>
<p>　　已知可比较等价的任意实体之间的等价关系也不具有唯一性。</p>
<p>　　一般地，设计等价谓词需注意避免一些现实的使用困难，如<a href="https://www.craigstuntz.com/posts/2020-03-09-equality-is-hard.html">关于相等性的困难</a>。</p>
<p>　　为使等价关系在实体全集上<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">良定义</a>，等价谓词可能在特定情形弱化为同一性。</p>
<p>　　一般地，弱化应具有可用性理由，这可能和既有等价谓词和等价关系的蕴含的设计相关。</p>
<p><strong>原理</strong></p>
<p>　　等价谓词在避免依赖良序(well-ordering) 和良基(well-founded) 的理论中满足最小依赖原则，尽管其实现仍可能依赖序关系。</p>
<p>　　等价谓词的用途和上下文相关。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>在作为等价关系蕴含实体上的任何其它等价关系。被蕴含的等价关系可具有更多的限制条件。</p>
<p>　　实体的同一性是普遍的，但不是普适的，它仍不足以在所有上下文中都被关注。</p>
<p>　　决定普适的等价谓词中蕴含的统一的等价关系是不可能的，因此语言中应允许共存多个等价谓词。具体等价谓词的设计可由派生实现及语言的用户提供。</p>
<p>　　等价谓词设计中弱化等价性的一个例子是 [R<sup>6</sup>RS] 的<a href="http://www.r6rs.org/r6rs-editors/2005-August/000840.html">记录(record) 对象的相等性</a>。</p>
<p><strong>注释</strong></p>
<p>　　一些情况部分值的集合不满足数学意义上的等价（如浮点数的 <a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">NaN</a> ），但在此忽略这种可被单独扩展的情况。</p>
<p>　　以下不同准则的操作是相等关系的实例（参见 [EGAL] ）：</p>
<ul>
<li><em>抽象相等(abstract equality)</em></li>
<li><em><a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>相等(reference equality)</em></li>
<li>EGAL ([EGAL])</li>
</ul>
<h4 id="实体的同一性"><a class="header" href="#实体的同一性">实体的同一性</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>是实体上的等价关系的一个主要实例。</p>
<p>　　同一性决定的等价类之间的实体相同，即其整体和任意的<em>属性(property)</em> 在任意上下文中等价。</p>
<p>　　相同的实体在语言中不需要被区分，可直接替换而不影响程序的语义和行为。后者蕴含<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为等价</a>。</p>
<p>　　实体的同一性可体现在以下隐含的默认规则：</p>
<ul>
<li>不同上下文的实体默认相互独立而不保证能被视为相同（在任意上下文中等价）。</li>
<li>通过语言构造引入的超过一个实体，默认为不相同的实体。</li>
<li>除非另行指定，表示具有同一性的实体的语言构造和其它实体不被要求<a href="Features/NPL.zh-CN.html#%E5%85%B1%E4%BA%AB%E5%BC%95%E7%94%A8">共享</a>指称相同的具有同一性的实体。</li>
</ul>
<p>　　语言在<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等实体</a>上提供的同一性的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">具体判断依据</a>和具体语言支持的特性相关。</p>
<p><strong>原理</strong></p>
<p>　　同一性决定任意两个实体可在语言中不依赖具体操作的行为被直接区分，即满足 Leibneiz 法则(Leibneiz's law) ，或称为<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E5%8F%AF%E5%88%86%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">不可分的同一性</a>。</p>
<p>　　基于这个性质，可在实体上定义和 [So90] 相容的更强的（不依赖语言设计中不存在副作用的）<em>引用透明性(referential transparency)</em> 。</p>
<p>　　同一性的引入默认是名义的，即断言具有同一性的实体和其它实体上的行为相互独立，而不需要附加证明。这种假设避免了一般地证明任意实体具有同一性的困难。</p>
<p>　　若不依赖直接在实体上标记等价类等依赖名义同一性假设的方法，证明一个实体具有同一性而非已知的其它实体，需证明任意的其它允许在程序中构造的实体和这个实体上的任意作用的可观察行为无关。在不限定具体的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">计算作用</a>属于会影响可观察行为的计算作用的确切集合时，这是计算上不可能的。因此，支持这类证明会有效地限制语言在支持不同的计算作用种类上的<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">可扩展性</a>。</p>
<p>　　反之，从不同的对象上取消同一性（而允许实现共享资源等目的）一般是容易的：只要证明不存在影响可观察行为的计算作用即可。这种证明可以由程序名义地表达，例如标记某个实体上只涉及纯计算而没有副作用。</p>
<p>　　另一方面，这也提示纯计算在各种计算作用中具有的特殊性不足以使其作为唯一的可扩展配置的起点。</p>
<p>　　最平凡的起点应是没有任何计算作用的空计算。这无法表达计算，而必须要求扩展才具有实用性。而<a href="Features/NPL.zh-CN.html#%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0">通用目的语言</a>需要支持一般的计算作用，这同时包含支持纯计算。</p>
<p>　　从一般的计算作用排除副作用而得到纯计算，只需要添加可被系统证明的假设，这种机制可以嵌入到系统的规约规则中；而以支持纯计算的系统扩展表达一般的计算，需要引入不足以被对象语言求值规则描述其语义的间接表示（即需要被规约以外的规则翻译），并暴露更多和表达一般计算的目的无关的实现细节。</p>
<p><strong>注释</strong></p>
<p>　　和不可分的同一性相对，存在同一性的不可分性(the indiscernibility of identicals) 。两者可被二阶语言形式地描述。</p>
<p>　　对象语言可提供同一性的相关操作，如：</p>
<ul>
<li>[ISO C] 的非空对象指针的比较操作比较指向的相同类型对象的同一性。</li>
<li>[R<sup>n</sup>RS] 和 [R<sup>n</sup>RK] 的 <code>eq?</code> 过程/应用子比较两个<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>的同一性。</li>
</ul>
<h4 id="实体的不可变性"><a class="header" href="#实体的不可变性">实体的不可变性</a></h4>
<p>　　通过特定的等价关系可定义具体的<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">不可变状态</a>的集合。</p>
<p>　　这些集合可用于定义以这些状态为值的实体的<em>不可变性(immutability)</em> ，进而定义不保持可变性的<em>改变(mutation)</em> 操作和具体的其中可能影响<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">修改</a>操作。</p>
<p>　　通过限定不同的修改操作，定义不同的<em>可修改性(modifiability)</em> 和对立的<em>不可修改性(nonmodifiability)</em> 。</p>
<p>　　通过明确不可修改性拒绝支持修改操作（例如通过通过实体的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>拒绝特定的修改操作），或通过不提供修改操作，语义规则保证实体不被修改操作改变状态。</p>
<p><strong>注释</strong> 例如，关于 [ISO C++] 的非类且非数组类型的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>不可修改，尽管要求非纯右值的语义规则可被视为是一种类型检查。</p>
<p>　　（不依赖和影响<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">实体同一性</a>的）同一个实体上的修改操作是改变操作。只有具有<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">可变状态</a>的实体可能支持这些操作。</p>
<p>　　不论是否能区分同一性，实体可能关联不排除影响<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>的可变状态。</p>
<p>　　一般地，一个实体不一定保证可区分是否具有不可变性以及具有何种不可变性（也蕴含一般不可区分可修改性），因为不可变性依赖实体的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>进行约定。</p>
<p><strong>注释</strong> 按<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">定义</a>，引起表达式的值以外的改变的作用是副作用。</p>
<p>　　潜在引起实体的一些内部状态的变化的操作可不被视为影响不可变性而不被视为实体的（整体意义上的）改变操作。这种实体具有<em>内部可变性(interior mutability)</em> 。</p>
<p>　　可引起实体变化的状态按设计上是否<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">隐藏局部变化</a>分为两类：</p>
<ul>
<li><em>可变管理状态(mutable administrative state)</em>
<ul>
<li>可变管理状态的改变作为<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">管理状态</a>的改变，不被视为对象（整体）改变的对象内部状态的改变。</li>
</ul>
</li>
<li><em>可变数据状态(mutable data state)</em>
<ul>
<li>可变数据状态的改变是对象的改变。</li>
</ul>
</li>
</ul>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">隐藏状态</a>在可变性的意义上视为可变管理状态。</p>
<p>　　推论：</p>
<ul>
<li>引起实体内的可变管理状态的改变的操作不一定是改变对象的操作。</li>
<li>引起实体内的隐藏的可变状态的改变的操作不一定是修改操作。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　基于等价关系而不是预设具体表示之间的相等定义可变性，避免抽象的目的（如<a href="Features/NPL.zh-CN.html#%E5%B0%81%E8%A3%85">封装性</a>）<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F">依赖特定相等关系的实现细节</a>，支持<a href="Features/NPL.zh-CN.html#%E5%BC%80%E6%94%BE%E6%80%A7">开放世界假定</a>。</p>
<p>　　这种设计的一类典型反例是在预设排除副作用的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯的</a>的设计为基础进行扩展定义改变操作，包括：</p>
<ul>
<li>默认使用不可变数据结构，并在此基础上扩展出可变的数据结构（如 [Rust] ）；</li>
<li>默认支持保证排除副作用的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>，仅在有限的上下文中通过特定构造模拟支持非纯求值（如 Haskell 等纯函数式语言）。</li>
</ul>
<p>　　一般地，这类策略对<a href="Features/NPL.zh-CN.html#%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0">通用目的语言</a>是过度设计，因为这实质上要求所有不存在改变操作的实体操作都完全排除副作用，不支持指定不同类别或层次保留不同改变操作并划分不同等价类的可能性，而限制表达的能力或增加实现相同抽象的复杂性。</p>
<p>　　关联可变状态的实体通常是对象，因为支持区分<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">同一性</a>而能支持发生在不同实体上的作用引起独立的状态的改变而分别影响可观察行为，但这并非绝对。只要允许构造出按等价关系判断具有不相同状态，非对象实体仍可支持内部可变性等不能排除影响可观察行为的性质。这不通过需要区分同一性的状态改变。</p>
<p>　　不区分同一性允许实现任选其中的实例代替其它实例。因此，在抽象机语义上依赖这些实体的不同等价状态表现的所有<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">良定义行为</a>都应被允许，即未指定行为。</p>
<p>　　内部可变性同 [Rust] 的 <code>RefCell&lt;T&gt;</code> 等使用的模式以及 [ISO C++] 的 <code>mutable</code> ，允许对象具有可变管理状态，而不影响依赖可变或可修改的对象整体意义上的类型检查。</p>
<p>　　和 [Rust] 不同而和 [ISO C++] 更加类似，这里的内部可变性仅限关于对象不可变性，和对象是否被<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%88%AB%E5%90%8D">别名</a>正交（一些实例分析参见<a href="https://stackoverflow.com/questions/63487359">这里</a>）。</p>
<p>　　但是，和 [Rust] 及 [ISO C++] 都不同，这里不要求不可变性通过<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>强制。</p>
<p><strong>注释</strong></p>
<p>　　可变和不可变的状态的区分类似 [R<sup>n</sup>RK] 。</p>
<p>　　其它语言也遵循类似的设计。作为非对象实体的可变性的一个例子，<a href="https://eel.is/c++draft/dcl.ref#4">C++ 引用是否要求存储未指定</a>，尽管占用存储这一状态并非是语言支持的可变状态。这一规则直接允许 C++ 实现不需要依赖 <a href="https://eel.is/c++draft/intro.abstract#footnote-6">as-if 规则</a>即可选取占用和不占用存储的方式实现引用的实例（乃至在运行时改变选取策略），即便是否占用存储可能对应 C++ 程序的不同的可观察行为。</p>
<p>　　改变或修改实体后，实体可能仍然具有和之前等价的状态。</p>
<p>　　支持不同等价的不可变性的一个用例是，有序的数据结构中的键需要保持的（通过序关系定义的）等价关系和键的可修改性是两种不同的等价关系。作为它的一个具体的反例，C++ 标准库要求关联容器的键具有 <code>const</code> 修饰，没有区分两种等价性，导致无法修改等价的键（除非具有 mutable 数据成员），而引起一些不必要的复杂。</p>
<h3 id="实体的副本"><a class="header" href="#实体的副本">实体的副本</a></h3>
<p>　　在已知的实体以外，实体，作为其<em>副本(copy)</em> ，满足：</p>
<ul>
<li>实体和实体的副本满足某种<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">等价</a>，至少蕴含<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">实体的值</a>之间满足<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">不可变性</a>。</li>
<li>若一个实体是对象，它的副本和它不<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一</a>。</li>
</ul>
<p>　　除非另行指定，若实体的副本无法被创建，引起创建副本的操作<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　若实体的副本可被创建，它可能通过：</p>
<ul>
<li><em>复制(copy)</em> 实体：创建副本后，保持原实体的值<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">不变</a>。</li>
<li><em>转移(move)</em> 实体：创建副本后，原实体被转移而具有<em>有效但未指定(valid but unspecified)</em> 的状态；若可能取得实体的值，其值<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定</a>。
<ul>
<li><strong>原理</strong> 要求有效，隐含其<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>时具有<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">良定义行为</a>。</li>
<li><strong>注释</strong> 参见<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">未指定状态</a>。</li>
<li><strong>注释</strong> 这类似 [ISO C++] <a href="https://eel.is/c++draft/lib.types.movedfrom">[lib.types.movedfrom]</a> 。</li>
</ul>
</li>
<li><em>析构性转移(destructively move)</em> 实体：创建副本后，原实体的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>结束，不再可<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>。</li>
<li>其它派生实现指定的创建实体副本的不同方式。</li>
</ul>
<h3 id="实体数据结构"><a class="header" href="#实体数据结构">实体数据结构</a></h3>
<p>　　实体的集合上可定义关联关系：集合的包含关系或其它实现定义的<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">严格偏序关系</a>。被关联的实体称为<em>子实体(subentity)</em> 。</p>
<p>　　子实体可以是作为数据结构的一部分。这种数据结构可以是一般的<em>图(graph)</em> 。</p>
<p>　　数据结构也可在对象语言中通过实体包含关系以外的途径定义。</p>
<p><strong>注释</strong></p>
<p>　　例如，限定包含关系构成的图中的<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权关系</a>附加限制，详见<a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">自引用数据结构和循环引用</a>。</p>
<h3 id="续延"><a class="header" href="#续延">续延</a></h3>
<p>　　<em>续延(continuation)</em> 是特定<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87">上下文</a>中描述未来的<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算</a>的实体。</p>
<p>　　续延描述的计算在后继的规约中实现，在此之前可能被<em>调度(schedule)</em> 或指定不同的计算内容。上下文可决定这些计算中可变的参数化部分。</p>
<p>　　计算可通过切换续延蕴含<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制状态</a>改变而具有<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制作用</a>。</p>
<p>　　当前规约的上下文中对应的续延是<em>当前续延(current continuation)</em> 。</p>
<p>　　按对控制的限制，续延可分为<em>无界续延(undelimited continuation)</em> 和<em>有界续延(delimited continuation)</em> 等不同形式。</p>
<p>　　续延蕴含<em>子续延(child continuation)</em> 作为最后的一系列子计算。</p>
<p>　　形式上，若续延表示为一个计算步骤的序列，子续延的表示是续延的表示的后缀。</p>
<p>　　推论：无界续延的子续延是无界续延；有界续延的子续延是有界续延。</p>
<p><strong>注释</strong></p>
<p>　　续延可由符合<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E9%87%8D%E5%86%99%E7%B3%BB%E7%BB%9F">项规约系统</a>的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E8%A7%84%E5%88%99%E5%92%8C%E6%B1%82%E5%80%BC">规约步骤</a>的集合或未指定的其它形式的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">表示</a>。</p>
<p>　　不同形式的续延的调用都能具有类似的控制作用，但表达能力不尽相同。</p>
<p>　　有界续延可从无界续延或有界续延通过添加<em>续延界限(delimiter)</em> （或称为<em>提示(prompt)</em> ）派生。派生的结果是原续延的一部分，表达原续延对应的计算的<em>子计算(subcomputation)</em> ，又称<em>部分续延(partial continuation)</em> 。</p>
<p>　　在仅使用<em>局部变换(local transformation)</em> 即 Felleisen <em>宏表达(macro-expressible)</em> ([Fl91]) 的意义上，[Fi94] 指出：</p>
<ul>
<li>有界续延和可变状态（存储）可实现无界续延。</li>
<li>嵌入在语言中的任意表达<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">计算作用</a>的<em>单子(monad)</em> 的构造可用有界续延实现。</li>
</ul>
<h3 id="一等实体和一等对象"><a class="header" href="#一等实体和一等对象">一等实体和一等对象</a></h3>
<p>　　NPL 区分两类不同的一等实体：只关心关联（作为对象时）的值的，和同时关心作为对象的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">其它属性</a>的一等对象。</p>
<p>　　其中，后者允许更多的操作，且允许作为前者使用，反之无法直接保证：一等对象总是一等实体，一等实体不保证可作为一等对象使用。</p>
<p>　　逻辑上，一等实体可以关联其它对象（作为一等对象时关联可以是存储）。关联的对象的（表达式相关的）值是一等实体关联的值，可对应一等对象存储值。关联的值或存储的值是一等实体或一等对象的属性。</p>
<p>　　除非派生实现指定，NPL 的一等实体都是一等对象。</p>
<p><strong>注释</strong></p>
<p>　　派生实现可以定义非一等对象的其它一等实体。</p>
<p>　　除非派生实现指定，非一等对象也不是一等实体。</p>
<h4 id="一等对象的同一性"><a class="header" href="#一等对象的同一性">一等对象的同一性</a></h4>
<p>　　一等对象通过保证具有<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>强调不相同的对象总是存在至少一种<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">总是不相同的属性</a>。</p>
<p>　　一般地，语言规则选取其中一种属性作为名义(nominal) 同一性属性。</p>
<p>　　一等对象具有名义同一性，定义为可比较名义同一性属性<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">相等</a>；名义同一性的相等即名义同一性属性相等。</p>
<p>　　名义同一性在名义上标识相同的对象，区分不相同的对象，即便后者可能仍然在行为上完全符合同一性的要求。</p>
<p>　　形式上，一等对象是名义同一性属性和它作为一等实体的关联的对象作为非对象（无视同一性）的其它属性集合（如<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">存储的值</a>）的二元组。</p>
<p>　　为简化设计，NPL 约定以下默认规则：</p>
<ul>
<li>除非另行指定，名义同一性属性指定为对象在<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机语义</a>下的存储位置。
<ul>
<li>对象占据存储位置起始的若干存储。</li>
<li>存储位置的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>未指定；派生实现可指定具体的表示。</li>
</ul>
</li>
<li>在语言规则中，一等对象满足<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">实体的同一性</a>的默认规则。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　由语言特性而非<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>提供表达同一性的支持是必要的，这体现在通过在<a href="Features/NPL.zh-CN.html#%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0">通用目的语言</a>中省略同一性的表达再由实现或用户程序引入的做法一般是不可行的：</p>
<ul>
<li>由 <a href="https://zh.wikipedia.org/zh-cn/%E8%8E%B1%E6%96%AF%E5%AE%9A%E7%90%86">Rice 定理</a>，非平凡(non-trivial) 的程序语义性质无法被<a href="Features/NPL.zh-CN.html#%E5%AE%8C%E6%95%B4%E6%80%A7">可计算地</a>实现，而确定程序中任意对象的同一性蕴含判定“和特定程序行为一致”这种非平凡语义性质，无法被通过证明程序行为的等价或其中的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">实体在任意上下文上的等价</a>任意地引入，因此若无法确定用户程序不需要任意的同一性（这是一种平凡情形），指定“不需要引入同一性”总是只能在特定的程序上由语言设计者或用户具体地决定。</li>
<li>作为通用目的语言若需要描述能适应语言自身实现问题的特性，总是依赖具体语言的逻辑上的<a href="https://zh.wikipedia.org/zh-cn/%E9%9D%9E%E7%9B%B4%E8%B0%93%E6%80%A7">直谓(predicative) 的</a>规则（如资源抽象），除非语言规则是空集（这是一种平凡情形），这不可能完全由用户程序提供。</li>
</ul>
<p>　　语言的设计中显式区分一等实体和一等对象的支持而非只直接支持一等对象仍然是必要的，主要原因是：</p>
<ul>
<li>一等实体的具体表现形式通常是实现细节而要求不被依赖，为了支持前者不被显式表达，满足<a href="Features/NPL.zh-CN.html#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99">关注点分离原则</a>。</li>
<li>一等实体的普遍支持允许以<a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">统一</a>的方式抽象<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可变状态</a>，且扩展使便于满足<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>。</li>
</ul>
<h4 id="可变状态和普遍性"><a class="header" href="#可变状态和普遍性">可变状态和普遍性</a></h4>
<p>　　NPL 对一等实体提供普遍的支持。</p>
<p>　　除非另行指定，NPL 不限制一等实体上可能具有的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>，包括<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>。</p>
<p><strong>原理</strong></p>
<p>　　一等实体的普遍支持体现在：</p>
<ul>
<li>在一般的一等实体上引入可变状态，实质上提供了<em>一等副作用(first-class side effect)</em> ，而不把<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">可修改性</a>限于特定的数据结构（如<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">求值环境</a>）。</li>
<li>允许以一致的方式和实现的外部环境进行<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>，特别地，允许物理上提供状态抽象的设备实体的状态直接映射为一等对象。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　特别地，一等对象默认支持可变状态。</p>
<p>　　派生实现可附加规则改变本节中对一等对象的默认要求，提供不同的保证或性质，包括<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>上的其它一等实体上的不同作用。</p>
<h3 id="同一性关联扩展性质"><a class="header" href="#同一性关联扩展性质">同一性关联扩展性质</a></h3>
<p>　　NPL 中，对象的同一性关联的属性包括明确开始和终止的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>。</p>
<p>　　推论：对象是表示能明确生存期开始和终止的实体。</p>
<p>　　一等对象之间总是能准确地判断影响程序语义的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">同一性</a>：仅当能证明不改变<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>时，两个一等对象的同一性可能未指定。</p>
<p><strong>原理</strong></p>
<p>　　通过一等对象关联同一性，允许语言提供依赖同一性差异的特性。</p>
<p><strong>注释</strong></p>
<p>　　同一性在这个意义上不是对象自身确定的性质（而是对象和解释对象表示的可能由外部提供的实现的共同确保的性质），不是应被隐藏的内部实现，因此 [EGAL] 中有关自我诊断(autognosis) 的结论不适用；而代理(proxy) 仍然可通过语言提供适当的隐藏同一性的手段可靠地实现。</p>
<h4 id="一等状态"><a class="header" href="#一等状态">一等状态</a></h4>
<p>　　确保区分同一性的<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">状态</a>是<em>一等状态(first-class state)</em> 。</p>
<p>　　一等对象能直接表示一等状态。</p>
<p>　　一等状态是否通过其它特性派生是未指定的。</p>
<p><strong>原理</strong></p>
<p>　　一等对象相对一等实体的附加规则限制集中体现在允许一等对象映射到的支持上。</p>
<p>　　注意并非所有一等对象都需要支持一等状态；否则几乎总是会<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">付出本不必要的代价</a>也难以避免违反<a href="Features/NPL.zh-CN.html#%E9%80%82%E7%94%A8%E6%80%A7">适用性</a>；因此有必要区分一等状态的对象和非一等状态的对象。</p>
<p>　　这种区分实质上更普遍地对具体的计算操作也存在意义，自然地引入了类似 [ISO C++] 的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">值类别</a>；最简单的设计如区分<em>左值(lvalue)</em> 和<em>右值(rvalue)</em> 分别关联是否需要支持一等状态的对象。</p>
<p>　　为支持一等状态，有必要支持判断两个对象的同一性，确保<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">修改</a>某个对象的操作不会关联到任意其它对象，以允许特定对象关联特定的一等状态。</p>
<p>　　为允许一等状态和<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">外部环境</a>的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>，不能总是假定只有一类总是可被程序局部预知的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">修改操作</a>（典型地，定义为“设置<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>”操作，如 [R<sup>n</sup>RK] §3.1 ）影响状态，而应允许和特定对象关联的求值时的不透明的副作用。</p>
<p>　　若不考虑互操作，则一等对象用有限的不同<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">等价谓词</a>]即能提供区分同一性的操作；否则，等价谓词的设计即便保持<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E4%BA%A4%E6%80%A7">正交</a>，也需区分不同的一等对象对各种<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>的不同支持情况。</p>
<p>　　避免指定一等对象的可派生方式有助于<a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">统一性</a>。</p>
<p>　　基于 [Fi94] ，结合可变状态能被表达为单子（如<a href="https://www.pauldownen.com/publications/delimited-control-effects.pdf">这里</a>）的事实，<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">有界续延</a>可实现状态。</p>
<p>　　相对地，基于 [Fl91] ，<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">无界续延</a>和<a href="Features/NPL.zh-CN.html#%E5%BC%82%E5%B8%B8">异常</a>不能实现一般意义的可变状态，参见<a href="https://www.researchgate.net/profile/Hayo-Thielecke/publication/2487383_Contrasting_Exceptions_and_Continuations/links/53e12dba0cf2235f352738e5/Contrasting-Exceptions-and-Continuations.pdf">这里</a>的推论 5.13 。</p>
<p>　　因为同一性可以在引入状态时被编码而在之后不需改变，使用有界续延等非一等的状态可支持实现状态的同一性。因此，在此不对是否基本要求作出限定。</p>
<p>　　但是，使用有界续延实现状态仅仅是实现细节，且通常具有一些非预期的实现性质：</p>
<ul>
<li>这实质要求实现同一性无界续延具有区分同一性的能力（相当于 [ISO C++] 的左值），而引起不正交的内部设计。</li>
<li>同时，在现有实现普遍提供状态的原生支持（存储器）的常见情况下，编码状态会付出本不必要的代价。</li>
</ul>
<p>　　为满足非常规的实现环境或更优先的原则（如<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>和<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>），派生实现仍可使用有界续延派生一等状态，同时提供访问更基本的不依赖可变状态的接口，以使上述影响不再是非预期的。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>仍不被禁止使用这种方式自行提供类似的实现，以确保<a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">不约定一等状态作为基本的内建特性时</a>，语言的设计不违反 <a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">G1b</a> 。</p>
<p><strong>注释</strong></p>
<p>　　实现在一般实体上支持的<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">隐藏状态</a>不被程序可编程地指定，不是一等状态。</p>
<p>　　允许和特定对象关联的求值时的不透明的副作用的一个实例是 [ISO C] 和 [ISO C++] 的 <code>volatile</code> 类型对象。</p>
<h4 id="一等作用"><a class="header" href="#一等作用">一等作用</a></h4>
<p>　　语言可指定特定的求值自动创建对象。</p>
<p>　　基于此规则可在传递时附加不同的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>，即实现可随一等对象传递的<em>一等作用(first-class effect)</em> 。</p>
<p><strong>原理</strong></p>
<p>　　典型地，<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值传递</a>时，被传递后的对象和<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">实际参数</a>表示的对象具有不同的同一性，即按值传递时创建<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">新的对象</a>。</p>
<p>　　基于被创建的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">副本</a>的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">不变性</a>，这里的一等作用可包括用于维护对象的<a href="Features/../Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">不变性</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>，<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E5%8F%98%E7%8A%B6%E6%80%81%E5%92%8C%E6%99%AE%E9%81%8D%E6%80%A7">包括可能的副作用</a>，作为<a href="https://zh.wikipedia.org/zh-cn/%E5%A5%91%E7%BA%A6%E5%BC%8F%E8%AE%BE%E8%AE%A1">契约式编程(programming by contract)</a> 的基础实现方式。</p>
<p>　　这种不变性可包括对象的生存期。通过限制特定表达式求值的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用域</a>内销毁对象以确保对象生存期有限，即基于作用域的对象管理(scope-based object management) 。</p>
<p>　　基于作用域的对象管理可直接对应有限资源的普遍性质，使一等对象作为资源的抽象，确保资源的创建和销毁的副作用符合资源操作的语义，同时避免隐式的泄漏。</p>
<p>　　配合<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">一等状态</a>，对象语言中的一等对象允许直接表示超过程序运行时自身的生存期的状态。这允许不在程序运行时持久储存的数据能直接被一等对象进行操作，而不需要依赖外部系统的约定并减少冗余操作（例如，从外部持久的“文件”上打开“流”以及其上的持久化操作），更符合<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>。</p>
<p><strong>注释</strong></p>
<p>　　这里的资源抽象的惯用法在 C++ 中称为 RAII(resource aquisition is initialization) 。</p>
<h4 id="所有权抽象"><a class="header" href="#所有权抽象">所有权抽象</a></h4>
<p>　　配合<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E4%BD%9C%E7%94%A8">一等作用</a>，实体的<em>所有权(ownership)</em> 自然地适用对抽象为对象的资源进行约束。</p>
<p>　　NPL 的设计避免要求对象语言隐含单一的<em>根(root)</em> 所有者作为其它资源的所有者。</p>
<p><strong>原理</strong></p>
<p>　　避免单一所有者适应抽象不同系统的需要，并满足<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>：</p>
<ul>
<li>当不需要这样的所有者时，保持设计的<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>，同时满足<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>和<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>。</li>
<li>当需要这样的所有者时，仍然允许实现或派生实现引入。</li>
</ul>
<p>　　注意<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">规约</a>允许蕴含<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>的所有者用于提供规约时不在对象语言中可抽象为一等对象访问的资源，这样的所有者不需要是全局的；若实现为在不同规约实例乃至全局共享的资源，也不应在对象语言被依赖。</p>
<p>　　只要程序没有明确要求所有者，单一的全局所有者违反<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E4%BE%9D%E8%B5%96%E5%8E%9F%E5%88%99">最小依赖原则</a>，且不支持不清楚所有者状态时对特定对象之间进行所有权的局部推理(local reasoning) ：</p>
<ul>
<li>这种情形若不配合原始的明确目的（而间接明确资源的所有者）的设计说明，人类读者直接阅读实现理解和验证其正确性是困难的，即损失了可读性。
<ul>
<li>一种解决方式是读者自行模拟运行程序再从中推理出可简化的资源所有关系，这首先相当于要求读者模拟非确定性垃圾回收(GC, garbage collection) 的运行机制。这通常是困难的工作。</li>
</ul>
</li>
<li>而机器通常更无法推理这些问题，因为设计和抽象的目的一般不是以机器可读的方式编码的。
<ul>
<li>GC 可以回收资源，但无法准确统计哪些回收是必要的，也无法准确追溯原始实现并推理出应当在何种情况下静态地插入释放资源的操作，因为 GC 自始至终缺乏“允许任意延迟释放操作”以外的程序变换的<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">保持语义不变</a>的证明所需的程序元信息（包括目的）。</li>
</ul>
</li>
</ul>
<p>　　为满足<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>，当需要表达局部所有权关系时，使用单一的全局所有者使用户无法直接在对象内嵌(embedding) 这种关系而需另行编码所有权信息，这存在以下问题：</p>
<ul>
<li>使整体设计直接违反<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>。</li>
<li>要求局部所有权以和全局默认机制的不一致的方式表达，损失<a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">统一性</a>并放弃<a href="Features/NPL.zh-CN.html#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99">局域性</a>而在满足需求时造成接口<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F">抽象泄漏</a>。</li>
</ul>
<p>　　此外，即便使用时不要求区分对象的局部所有权关系，全局的分配释放机制也比局部的机制有更大的实现复杂性和约束。为实现对内部有限的资源的有效管理，局部所有权在实现中仍是必要的。</p>
<p>　　在使用全局所有者如全局的垃圾回收的实现中，这种必要性被隐藏在全局所有者内部实现，语言的整体设计不会更<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单</a>。</p>
<p>　　使用全局所有者的资源管理假定启发式(heuristic) 策略以节约现实中无法接受的非预期性开销。这仍无法保证总是对不同的场景同样有效，以至于默认存在以下问题：</p>
<ul>
<li>设计至少违反变化的自由和<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>之一。</li>
<li>在不引入支持用户配置策略的扩充设计时，违反变化的自由总是无法避免的。</li>
<li>若引入其它设计支持用户配置策略，简单性违反难以避免，且实际基本上没有被避免。</li>
<li>即便能通过扩充设计避免违反简单性，也不能避免<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">不必要付出的代价</a>。</li>
<li>不论是否引入扩充设计，都会使资源管理的一般开销更难以估计，而使设计整体的可用性评估更困难，容易使用户决策和避免不必要付出的代价冲突。</li>
</ul>
<h3 id="一等引用"><a class="header" href="#一等引用">一等引用</a></h3>
<p>　　NPL 的一等对象即对象自身，不要求区分引用和<em>被引用对象(referent)</em> 的普遍概念。</p>
<p>　　反之，通过使引用和其它一些非引用的对象同为<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">一等对象</a>，NPL 支持作为一等对象的<em>一等引用(first-class reference)</em> 。</p>
<p>　　一等引用支持一等对象作为被引用对象。除非另行指定，若实现允许<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>作为被引用对象，可作为被引用对象的非一等对象由实现定义。</p>
<p>　　特定的操作可能预期非引用，或总是隐含通过引用<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>被引用对象，这不改变引用被作为一等对象使用的普遍支持。</p>
<p>　　一等引用的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">相等关系</a>定义为被引用对象的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">名义同一性相等</a>。</p>
<p>　　一等对象的使用仍然可以通过要求引用访问以避免在任意上下文中需要不同的对象副本。但这并不应排除其它形式的一等对象操作。</p>
<p><strong>原理</strong></p>
<p>　　尽管满足 [R<sup>n</sup>RK] Appendix B 的准则(criteria) ，一等对象和 [R<sup>n</sup>RK] 及 Java 等语言要求的设计不同。</p>
<p>　　注意有引用的语言的语义中不能排除被引用对象，否则无法确定引用对象的值的表达式的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>（例如来自对象<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">存储的值</a>）以表达<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算</a>；相反，无视引用而直接对值操作仍然能实现一些足够有意义的程序。</p>
<p>　　因此，若存在引用，无法忽略非引用（即便非引用不能在对象语言被直接使用）。</p>
<p>　　另一方面，引用可以由不指定为引用的一般对象上添加语义规则区分，而作为一般的对象的特例。</p>
<p>　　要求语言操作的一等对象总是关联到引用的设计实质上使对象语言的一等对象都是引用。但这不表示引用是自然的一等实体，因为引用的作用仅是操作被引用对象，不要求引用自身能被作为一等对象。</p>
<p>　　一等引用的相等性定义允许在相等的引用上推理<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">引用透明性</a>。</p>
<p>　　考虑此设计决策时关注的有以下几节中的依据。其它依据参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h4 id="共享引用"><a class="header" href="#共享引用">共享引用</a></h4>
<p>　　共享引用是共享资源的引用。共享的资源（通常是存储空间）自身具有同一性，以<em>位置(location)</em> 标记。共享不同位置（即作为不同一等对象的）的引用可能引用同一个被引用对象。</p>
<p><strong>原理</strong></p>
<p>　　合理的共享引用可以节约实现占用的资源，提供更好的性能。但共享引用的实现仍可能有附加的开销，因此并不能保证使用共享引用一定能提供更好的性能。通常这种情形至少包括一些典型的对资源独占一次使用（具有独占所有权(unique ownership) ）的情况。</p>
<p>　　更重要地，并非任意引用的共享都不改变程序的语义和行为，不合理的使用可能造成非预期的作用。</p>
<p>　　任意地引入共享引用而使用户不便预测其作用破坏<a href="Features/NPL.zh-CN.html#%E9%80%82%E7%94%A8%E6%80%A7">适用性</a>：</p>
<ul>
<li>这包含直接破坏<a href="Features/NPL.zh-CN.html#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测性</a>，并在需要排除共享的场景中缺乏<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>。</li>
<li>特别地，这和具有副作用的<em>非确定性(non-deterministic)</em> 编程冲突。</li>
<li>典型的<a href="Features/NPL.zh-CN.html#%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0">多线程并发执行</a>若需对象上的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>，需要保护和排除不必要的共享，确保独占<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权</a>以避免<em>竞争条件(race condition)</em> 。</li>
<li>也有其它的一些类似的容易被忽略的<a href="https://okmij.org/ftp/continuations/map-story.html">非确定性地破坏假设的场景</a>。</li>
<li>另见共享改变。</li>
</ul>
<p>　　区分是否需要表达共享的情形一般不能由语言实现预知。和<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">使用全局所有者的问题</a>类似，使对象默认共享的设计若需避免违反<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>，在此相对不默认共享引用的设计违反<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>。</p>
<p>　　默认共享引用可能是隐式的，即语言的实现不通过程序<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">代码</a>中的显式标注的操作而引入共享的引用，且往往无法保证通过一等对象上的操作避免被引用的对象被其它一等对象引用——无法使用对象语言的操作排除共享引用（即便是新创建的对象也没有保证，尽管实现上不必要）。</p>
<p>　　在要求一等对象都是引用的设计中，一般地，只有不要求名义同一性的非对象的实体才能安全地共享引用，但在非对象实体上的类似引用的机制并没有保证通过一等引用提供为语言特性。</p>
<p>　　其它情形中，允许引用之间的隐式的共享使<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">不相同的对象</a>可能共享状态而破坏<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">同一性的行为保证</a>：程序无法可靠地避免共享状态导致的对<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>的影响，此时共享状态的改变非预期地影响其它对象，其行为不具有<a href="Features/NPL.zh-CN.html#%E4%B8%80%E8%87%B4%E6%80%A7">一致性</a>。</p>
<p>　　为了排除破坏同一性和适用性的问题，语言的设计需要限制引起问题的操作的可用性（例如，[R<sup>n</sup>RK] 和 [R<sup>n</sup>RS] 不提供使用一等引用的改变操作以保证变化能通过程序源代码中有限的语法上下文被推理），但这样的策略限制设计的<a href="Features/NPL.zh-CN.html#%E5%85%B6%E5%AE%83%E6%8E%A8%E8%AE%BA%E5%92%8C%E6%AF%94%E8%BE%83">通用性</a>。</p>
<p>　　因为共享引用的影响的普遍性，不提供可避免隐式共享引用的设计的造成的缺陷也是普遍的。</p>
<p>　　由于显式的引用可以由用户控制在局部使用，更容易推理其影响，可避免类似的缺陷。</p>
<p>　　关于共享改变和程序无法可靠地避免共享状态导致的对可观察行为的影响，参见参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>注释</strong></p>
<p>　　一些语言的设计指定或隐含的规则在程序代码操作的一等对象上普遍地引入隐式共享的引用，如：</p>
<p>　　[R<sup>n</sup>RK] 中的引用和被引用对象明确地分离，且 <code>$define!</code> 和 <code>set-car!</code> 等<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">改变操作</a>要求设置对象引用的其它对象为特定的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>确定的被引用对象，无法排除被设置的引用被共享；这实质要求所有可能包含其它引用的可被改变的对象中的引用都需要能构成隐式的共享。</p>
<p>　　[R<sup>n</sup>RS] 明确指出特定的空对象的唯一性（即便因为不保证具有位置，不一定保证以位置决定的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">名义同一性</a>），蕴含这些对象上总是可构造或超过一个引用必须构造隐式的共享引用；其它变量引用(variable reference) 未指定排除隐式的共享。</p>
<h5 id="对象别名"><a class="header" href="#对象别名">对象别名</a></h5>
<p>　　除非在语言规则中添加复杂的约束（如通过<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型</a>的机制）以证明特定上下文可避免共享引用，无法避免引用引入不必要的对象<em>别名(aliasing)</em> 。</p>
<p>　　若公开这样的性质作为接口约束，违反<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>。</p>
<p>　　隐式的共享使涉及<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">修改</a>的操作的特性更难设计，参见共享改变。</p>
<p>　　关于共享改变，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　对象别名一旦引入，通常难以在所有被别名的对象生存期结束前消除。</p>
<p>　　证明对象不被别名是困难的，因为这逻辑上要求在局部知悉所有被别名的对象的存在性，而不具有<a href="Features/NPL.zh-CN.html#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99">局域性</a>。</p>
<h3 id="自引用数据结构和循环引用"><a class="header" href="#自引用数据结构和循环引用">自引用数据结构和循环引用</a></h3>
<p>　　特定的数据结构在逻辑上要求内部具有相互指涉的引用，即<em>自引用(self-referencing)</em> 。</p>
<p>　　自引用可实现为一等对象集合内的<em>循环引用(cyclic reference)</em> ，即允许对象属于有限次迭代访问被引用对象的操作的传递闭包（非空的<em>链(chain)</em> ，称为引用对象链）的构造。</p>
<p>　　NPL 的不保证支持这种方式实现自引用。</p>
<p><strong>原理</strong></p>
<p>　　NPL 的设计不保证支持通过循环引用实现自引用，以避免一些固有缺陷。即便派生语言允许提供扩展支持，但本节讨论的原理仍然适用。</p>
<p>　　避免自引用的构造使实体构成的数据结构由一般的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">图</a>退化为（可共享节点的）树形数据结构，即 DAG（Directed Acyclic Graph ，有向无环图）。</p>
<p>　　这样的设计在实现上避免外部所有者（如<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">全局 GC</a> ）。</p>
<p>　　避免一般的循环引用的普遍理由是：<a href="https://zh.wikipedia.org/zh-cn/%E9%9D%9E%E7%9B%B4%E8%B0%93%E6%80%A7"><em>非直谓性(impredicativity)</em></a> 并非是抽象上必要的普遍特性。一般的循环引用在抽象上即应通过特殊进行归纳，这并非<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F">泄漏抽象</a>。</p>
<p>　　反之，需求决定的抽象上不必要的情形下，假定循环引用的存在反而妨碍抽象的构造，可能避免某些有用的普遍性质（例如，保证程序可终止；另见<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">强规范化性质</a>），而违反<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>、<a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">统一性</a>和<a href="Features/NPL.zh-CN.html#%E9%80%82%E7%94%A8%E6%80%A7">适用性</a>，并引起若干具体设计问题。</p>
<p>　　关于通过任意对象支持循环引用的问题，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h4 id="一般引用数据结构的一般实现"><a class="header" href="#一般引用数据结构的一般实现">一般引用数据结构的一般实现</a></h4>
<p>　　通过一些替代原语，在不支持循环引用的情形仍可支持自引用数据结构。</p>
<p>　　语言可以提供在不支持一般的循环引用的对象构造中保存无所有权的一等实体引用其它实体，构造出不蕴含所有权的仅以特定对象构成的循环引用，而在外部引入对象作为所有这些构成引用的对象的所有者的机制。</p>
<p>　　在这个基础上，一般的自引用或循环引用需要的附加指涉仍然可通过添加不蕴含所有权语义的引用解决。这些引用是<em>弱引用(weak reference)</em> ，区分于具有所有权的引用是<em>强引用(strong reference)</em> 。</p>
<p>　　强引用总是可转换为弱引用使用。弱引用通过<em>解析(resolve)</em> 取得强引用。解析可能失败，以允许弱引用指涉已经不存在的对象，而避免影响对象<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>和所有权关系。</p>
<p>　　若支持这种受限形式的循环引用，具体特性由派生实现定义。</p>
<p><strong>原理</strong></p>
<p>　　没有理由表明通过任意对象支持循环引用是自引用数据结构的唯一实现方式，不论使用自引用数据结构的普遍程度。</p>
<p>　　自引用数据结构可通过在更高的抽象层次上编码，转换为由用户（而不是语言实现）指定明确的外部所有者的形式消除上述所有问题，同时对外部保证同等的功能<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>。</p>
<p>　　使用受限的循环引用同时避免带有所有权的循环引用也是 C 和 C++ 等语言惯用的实现图(graph) 的数据结构的合理方式。</p>
<h3 id="实体类型"><a class="header" href="#实体类型">实体类型</a></h3>
<p>　　NPL 不要求预设具体的实体及对象类型的设计，因此不要求用户使用语言体现整体上的<a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">可扩展性</a>。</p>
<p>　　特别地，NPL 不要求表达式具有预设的不同<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型</a>。</p>
<p><strong>原理</strong></p>
<p>　　放弃对预设类型的要求允许由派生实现指定类型的外延而满足<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>。</p>
<p>　　除不必涉及<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>外，[R<sup>n</sup>RK] 中定义的封装的(encapsulated) 类型的概念及类型<a href="Features/NPL.zh-CN.html#%E5%B0%81%E8%A3%85">封装性</a>（ [R<sup>n</sup>RK] 原则 G4 ）仍然适用，且一般仍然需要满足；差异是派生实现因为扩展不满足的情形也不影响此实现的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E6%A8%A1%E5%9E%8B">一致性</a>（尽管使用扩展的程序可能不可移植）。</p>
<p>　　尽管<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">值类别</a>可抽象为特殊的类型，表达式中的对象的类型和值类别的规则应分别讨论，因为两者正交：两者的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">确定</a>和<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">检查</a>机制都相互独立。</p>
<h2 id="名称规则"><a class="header" href="#名称规则">名称规则</a></h2>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0">名称</a>和能标识特定含义、符合<a href="Features/NPL.zh-CN.html#%E8%AF%8D%E6%B3%95%E8%A7%84%E5%88%99">名称词法约束</a>的表达式一一对应。</p>
<p>　　具体的外延由派生实现定义。</p>
<p>　　表示名称的表达式不同于名称，但在无歧义时，语言中可直接以名称代指表达式和对应的词法元素。</p>
<h3 id="声明区域约定"><a class="header" href="#声明区域约定">声明区域约定</a></h3>
<p>　　对引入名称 <code>n</code> 的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">声明</a> <code>D</code> ，对应的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">声明区域</a>始于紧接 <code>n</code> 的位置，终于满足以下条件的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">记号</a><code>)</code>（若存在）或<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95%E6%A6%82%E5%BF%B5">翻译单元</a>末尾（不存在满足条件的记号 <code>)</code> ）：</p>
<ul>
<li>记号 <code>)</code> 和与之匹配的记号 <code>(</code> 构成的表达式包含 <code>D</code> 。</li>
<li>此记号之前不存在满足上一个条件的其它的记号 <code>)</code> 。</li>
</ul>
<h3 id="可见名称"><a class="header" href="#可见名称">可见名称</a></h3>
<p>　　名称隐藏规则：若<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">声明</a> <code>D</code> 是表达式 <code>E</code> 的子集，且不存在 <code>D</code> 的子集声明同一个名称，则 <code>D</code> 声明了<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">有效名称</a>，隐藏了 <code>E</code> 中其它同名的名称。</p>
<p>　　在<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">声明区域</a>中，没有被隐藏的名称是<em>可见(visible)</em> 的。有效名称实质蕴含可见名称。</p>
<h3 id="名称解析"><a class="header" href="#名称解析">名称解析</a></h3>
<p>　　<em>名称解析(name resoultion)</em> 是通过名称确定名称指定的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">实体</a>的操作。</p>
<p>　　不保证名称解析总是成功。</p>
<p>　　除非另行指定，成功的名称解析没有<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>。</p>
<p>　　除非另行指定，直接作为<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>步骤的不成功的名称解析<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　一般地，名称解析包括<em>名称验证(name verification)</em> 和<em>名称查找(name lookup)</em> 两个阶段。</p>
<p>　　名称验证确定名称是<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E8%A7%81%E5%90%8D%E7%A7%B0">可见名称</a>，同时可能排除部分无效名称。</p>
<p>　　名称查找进一步确定名称唯一指称的实体的（蕴含确定名称有效），仅在名称验证成功后进行。</p>
<p>　　不同名称经过名称查找的结果可能等效。等效的有效名称视为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一的</a>，规则由派生实现定义。</p>
<p>　　名称解析从保存名称的目标中查找名称。若查找失败，解析可继续从替代的其它目标中进行。这种机制称为<em>重定向(redirection)</em> 。重定向后的解析可继续包含名称验证和名称查找的步骤。</p>
<p>　　以上约定以外的具体规则以及失败的行为由派生实现定义。</p>
<h3 id="命名空间"><a class="header" href="#命名空间">命名空间</a></h3>
<p>　　<em>命名空间(namespace)</em> 是<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">实体</a>。命名空间可以由名称指称。</p>
<p>　　是否实现命名空间为程序中可由用户指定可变的实体及<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">求值环境</a>，由派生实现定义。</p>
<h4 id="命名空间指称"><a class="header" href="#命名空间指称">命名空间指称</a></h4>
<p>　　总是没有名称<em>指称(denotation)</em> 的命名空间是<em>匿名命名空间(anonymous namespace)</em> 。</p>
<p>　　没有有效名称指称的命名空间是<em>未命名命名空间(unnamed namespace)</em> 。</p>
<p>　　NPL 定义一个抽象的匿名命名空间，称为<em>根命名空间(root namespace)</em> 。未命名命名空间的支持由派生实现定义。</p>
<p>　　NPL 约定一个在实现中的有效名称总是指称一个命名空间。有效名称指称的命名空间的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>和<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">有效名称的同一性</a>对应。</p>
<p><strong>注释</strong></p>
<p>　　匿名命名空间和未命名命名空间不同。前者可能是一个系统的默认约定，一般整体唯一存在（如<em>全局(global)</em> 命名空间）；后者只是对某些接口隐藏，可以有多个。</p>
<h4 id="命名空间成员"><a class="header" href="#命名空间成员">命名空间成员</a></h4>
<p>　　除了用于指称的名称外，一个命名空间可以和若干其它名称关联。</p>
<p>　　通过派生实现定义的对命名空间的操作可以取得的名称是这个命名空间的<em>成员(member)</em> 。</p>
<p>　　若无歧义，命名空间的成员指称的实体也称为这个命名空间的成员。</p>
<p>　　命名空间直接包含成员，称为直接成员。</p>
<p>　　除了根命名空间和其它派生实现定义外，命名空间可以作为另一个命名空间的成员，此时命名空间内的成员（若存在）是包含其的命名空间的间接成员。</p>
<p>　　命名空间对成员的直接包含和间接包含总称为包含，是反自反的、反对称的、传递的二元关系。</p>
<h4 id="简单名称和限定名称"><a class="header" href="#简单名称和限定名称">简单名称和限定名称</a></h4>
<p>　　命名空间的直接<a href="Features/NPL.zh-CN.html#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%88%90%E5%91%98">成员</a>的标识符在这个命名空间中是有效名称，称为<em>简单名称(simple name)</em> 。</p>
<p>　　命名空间及其成员按包含关系依次枚举标识符组成的序列是一个名称，称为在这个命名空间中的<em>限定名称(qualified name)</em> 。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%8C%87%E7%A7%B0">根命名空间</a>的限定名称称为<em>全限定名称(fully qualified name)</em> 。</p>
<p>　　限定名称的语法由派生实现定义。</p>
<p><strong>注释</strong></p>
<p>　　限定名称的语法的一个实例是标识符之间作为逻辑上的<a href="Features/NPL.zh-CN.html#%E5%88%86%E9%9A%94%E7%AC%A6">分隔符</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">记号</a>。</p>
<h2 id="规约规则和求值"><a class="header" href="#规约规则和求值">规约规则和求值</a></h2>
<p>　　对象语言的<a href="Features/NPL.zh-CN.html#%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E6%96%B9%E6%B3%95">操作语义</a>可通过作为计算模型的<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E9%87%8D%E5%86%99%E7%B3%BB%E7%BB%9F">项规约系统的规约规则</a>中由规约规则描述的规约<em>步骤(step)</em> 指定。</p>
<p>　　除非派生实现另行指定，规约蕴含 NPL 程序的执行，可完全表示程序执行的语义。</p>
<p>　　推论：NPL 规约规则形式地蕴含 NPL 语义规则。</p>
<p>　　为表达明确的目的，<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>也可约定<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E9%80%89%E6%B1%82%E5%80%BC%E8%A7%84%E5%88%99">其它更抽象形式的求值规则</a>，以蕴含这些规约规则，而不是直接描述规约规则的形式语义。</p>
<p>　　描述 NPL 对象语言的操作语义也可被视为<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">特定的对象语言</a>，其规约可以视为求值。但除非另行指定，以下表达式仅指对象语言的表达式，其求值仅指关于对象语言中表达式的求值，而非一般的规约。</p>
<p>　　规约规则可要求被规约的项符合一定的结构（如具有特定类型的值）作为前提，否则规约出错，程序执行中止。</p>
<p>　　根据规约规则描述的行为是否对应对象语言中的求值，规约分为两类：表达式的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值规约</a>和<a href="Features/NPL.zh-CN.html#%E7%AE%A1%E7%90%86%E8%A7%84%E7%BA%A6">管理规约</a>。</p>
<h3 id="求值规约"><a class="header" href="#求值规约">求值规约</a></h3>
<p>　　一个规约可以描述表达式的求值。直接表达一个表达式求值的规约是一个求值规约。</p>
<p>　　以<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项重写系统</a>描述，求值规约的输入是作为表达式的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>，称为<em>待求值项(evaluating term)</em> 。</p>
<p>　　待求值项经求值规约取得<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>。</p>
<p><strong>注释</strong> 求值结果可能是<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>或<a href="Features/NPL.zh-CN.html#%E5%BC%82%E5%B8%B8">异常</a>退出的等其它作用。</p>
<p>　　以下项称为<em>被规约项(reduced term)</em> ：</p>
<ul>
<li>待求值项。
<ul>
<li><strong>注释</strong> 因为可附加等价<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">空求值</a>的恒等规约，不需要区分项是否已被规约。即使表达式从未被求值，其表示也可视为待求值项。</li>
</ul>
</li>
<li>规约步骤的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">中间表示</a>中完全依赖求值规约的输入的子集的项。</li>
<li>表示<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>的项。</li>
</ul>
<p>　　求值规约规则构成对象语言的<em>求值算法(evaluaton algorithm)</em> 。</p>
<p>　　求值算法的输入是被求值的表达式和支持<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">上下文相关求值</a>中的上下文。</p>
<p>　　求值的基本操作以满足特定规则的<em>替换(substituion)</em> 规则或其组合表示。</p>
<p>　　除非另行指定，以下讨论的排除求值副作用的重写系统具有<a href="Features/NPL.zh-CN.html#%E6%BC%94%E7%BB%8E%E8%A7%84%E5%88%99">汇聚性</a>。</p>
<p>　　这保证求值满足值替换规则：表达式的值的计算通过已知的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">子表达式</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>替换决定。</p>
<p>　　除非派生实现另行指定，子表达式的值仅由求值得到。</p>
<p><strong>注释</strong> 此时<a href="Features/NPL.zh-CN.html#%E9%80%92%E5%BD%92%E8%95%B4%E5%90%AB%E8%A7%84%E5%88%99">递归蕴含规则</a>中的求值依赖规则是这个规则的推论。</p>
<h3 id="管理规约"><a class="header" href="#管理规约">管理规约</a></h3>
<p>　　求值规约以外的规约称为<em>管理(administrative)</em> 规约。</p>
<p>　　管理规约可以是一个不完整的求值规约，或者和求值规约的步骤没有交集。</p>
<p>　　管理规约可使用对象语言不可见和不可直接操作的非<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">一等状态</a>的<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">管理状态</a>。</p>
<p>　　表示非<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>的项的规约总是管理规约。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">抽象求值</a>中不在对象语言<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>中可表达的中间规约是管理规约实现。</p>
<p><strong>注释</strong></p>
<p>　　管理规约描述语言的表达式以外的<a href="Features/NPL.zh-CN.html#%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E6%96%B9%E6%B3%95">操作语义</a>。</p>
<p>　　实现也可使用的管理规约描述特定于实现的（而在对象语言中未指定的）语义性质。</p>
<h3 id="规约顺序"><a class="header" href="#规约顺序">规约顺序</a></h3>
<p>　　<em>先序(sequenced before)</em> 关系是两个规约之间存在的一种<em>偏序关系(partial order)</em> ，对实现中规约之间的<em>顺序(order)</em> 提供约束。</p>
<p>　　<em>后序(sequenced after)</em> 是先序的逆关系。</p>
<p>　　<em>非决定性有序(indeterminately sequenced)</em> 是先序或后序的并集。</p>
<p>　　<em>无序(unsequenced)</em> 是非决定性有序在求值二元关系全集上的补集。</p>
<p>　　规约规则的顺序直接适用于求值，其顺序为<em>求值顺序(evaluation order)</em> 。</p>
<p>　　规约规则的顺序也适用在能以其形式描述相对顺序的事件上。这些事件称为<em>规约事件(reduction event)</em> 。</p>
<p><strong>注释</strong> 规约事件的实例如两个对象的<a href="Features/NPL.zh-CN.html#%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>的起始，或者某个<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">计算作用</a>。</p>
<p>　　一些事件的顺序是通过推理具有<em>因果性(causality)</em> 的依赖关系决定的，包括：</p>
<ul>
<li>规约中值的计算依赖规约的输入。</li>
<li>从一个实体上确定作为值的属性的<em>读(read)</em> 依赖这个属性。</li>
<li>在一个实体上可以作为值保留的属性的<em>写(write)</em> 被这个属性依赖。</li>
<li>由派生实现定义的其它情形。</li>
</ul>
<p><strong>注释</strong> 外部<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>作为实体的读取和写入是这里的属性的特例。</p>
<p>　　为了确定相关的值，依赖关系可直接替换为后序关系。</p>
<p>　　由二元关系的一般性质（特别地，偏序关系的传递性），可推导其它一些事件之间的确定顺序，如同一个实体属性上的读依赖（已知的）决定了这个属性的先前的写。</p>
<p>　　NPL 约定以下非决定性规约规则：除因果性和二元关系的一般性质的推论外，任意项之间的规约之间无序。</p>
<p>　　应用在求值顺序上，有以下推论（非决定性求值规则）：除因果性和二元关系的一般性质的推论外，任意表达式的求值之间无序。</p>
<p><strong>原理</strong></p>
<p>　　非决定性规约规则允许在语言中表达<a href="Features/NPL.zh-CN.html#%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0">并发实现</a>。</p>
<p><strong>注释</strong></p>
<p>　　读和写作为影响可观察行为的事件结果，具有因果性。此外，也可以抽象为计算作用并由程序操作；这里不做要求。</p>
<h3 id="求值性质"><a class="header" href="#求值性质">求值性质</a></h3>
<p>　　两个具体求值等价，当且仅当两者的作用相等。</p>
<p>　　两个求值等价，当且仅当作为具体求值时等价，或其中每个求值的变换实质蕴含另一个。</p>
<p>　　没有副作用的求值是<em>纯的(pure)</em> 。纯求值仅有值的计算或抽象求值。</p>
<p>　　值为被求值的表达式自身的具体求值或不包含变换为存在不等价求值的表达式的抽象求值为<em>恒等(identity)</em> 求值。</p>
<p>　　恒等的纯求值是<em>空求值(empty evaluation)</em> 。</p>
<p>　　作用是空集的表达式求值是<em>空作用求值(null effect evaluation)</em> 。</p>
<p><strong>注释</strong> 推论：空作用求值是空求值。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E8%AF%AD%E6%B3%95%E5%BD%A2%E5%BC%8F">语法形式</a>固定且求值总是空求值的表达式是<em>空表达式(empty expression)</em> ，这仅由派生实现可选提供。</p>
<h3 id="范式"><a class="header" href="#范式">范式</a></h3>
<p>　　<em>规范化形式(normalized form)</em> ，或简称<em>范式(normal form)</em> ，是由派生实现定义的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>，被一组<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">规约</a>规则确定，满足：</p>
<ul>
<li>通过有限的规约步骤后得到。</li>
<li>按规约规则，规范形式上不存在不<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">和空求值等价</a>的进一步规约。</li>
</ul>
<p>　　在具有 <a href="Features/NPL.zh-CN.html#%E6%BC%94%E7%BB%8E%E8%A7%84%E5%88%99">Church–Rosser 属性的重写系统</a>中，一个对象若具有范式则唯一。</p>
<p>　　表达式在得到规范形式后规约终止，且蕴含求值终止。</p>
<p>　　得到范式的规约步骤称为<em>规范化(normalization)</em> 。</p>
<p>　　若表达式规约总是能得到规范形式（求值总是能在有限规约步骤后终止），则具有<em>强规范化(strong normalization)</em> 性质。</p>
<p>　　实现应避免引起对象语言的语义表达以外的无法保证强规范化性质的操作（如直接无条件的递归规约调用）。</p>
<p>　　除非派生实现另行指定，不保证强规范化性质。</p>
<p>　　保证得到范式的规约是规范化规约。</p>
<p>　　具体求值得到的范式若可作为表达式，其<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>和被求值的项等价，即仅允许<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">恒等求值</a>而仍是范式；这样的项称为<em>自求值项(self-evaluating term)</em> 。</p>
<p>　　作为表达式的自求值项是<em>自求值表达式(self-evaluating expression)</em> 。</p>
<p>　　重复求值直至取得自求值项的求值结果是<em>最终求值结果(final evaluation result)</em> 。</p>
<h3 id="规范化中间表示"><a class="header" href="#规范化中间表示">规范化中间表示</a></h3>
<p>　　第一个<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">子表达式</a>（头表达式）是范式的表达式是 HNF（Head Normal Form ，头范式）。</p>
<p>　　头表达式是可直接求值为范式的表达式是 WHNF（Weak HNF，弱头范式）。</p>
<p><strong>注释</strong> 约定求值到 WHNF 提供保证强规范化性质的一般手段，可用于<a href="Features/NPL.zh-CN.html#%E4%B8%A5%E6%A0%BC%E6%80%A7">非严格求值</a>。</p>
<p>　　WHNF 的头表达式是<em>操作符(operator)</em> ，存在对应 HNF 的头表达式的<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">最终求值结果</a>。</p>
<p><strong>注释</strong> 详见<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>。</p>
<p>　　WHNF 中除了操作符以外的子表达式是<em>操作数(operand)</em> 。</p>
<p>　　操作数以具有限定顺序或不限定顺序的数据结构表示。</p>
<p>　　按操作数的数据结构对应有<em>操作数列表(operand list)</em> 和<em>操作数树(operand tree)</em> 。其中操作数树是有限的树形数据结构的 <a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">DAG</a> ，其具体构造和表示由派生实现定义。</p>
<p><strong>注释</strong> 操作数树和 [R<sup>n</sup>RK] 类似。语言可能进一步约定有序的数据结构表示操作数的组成部分之间在求值上不等价。</p>
<p>　　这种能以操作符和操作数的组合表达的计算形式是<em>操作(operation)</em> 。</p>
<p>　　操作的<em>结果(result)</em> 是表达规约步骤得到的范式；操作的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>是取得对应结果的规约步骤的作用。</p>
<p>　　若操作的结果不依赖<a href="Features/NPL.zh-CN.html#%E7%AE%A1%E7%90%86%E8%A7%84%E7%BA%A6">管理规约</a>，操作的结果和作用即这种可求值为 WHNF 表达式的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>和作用。</p>
<p><strong>注释</strong> 另见<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>。</p>
<p>　　关于 DAG ，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h3 id="组合求值"><a class="header" href="#组合求值">组合求值</a></h3>
<p>　　表达式和<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">子表达式</a>之间的求值需满足一定约束。</p>
<h4 id="递归蕴含规则"><a class="header" href="#递归蕴含规则">递归蕴含规则</a></h4>
<p>　　表达式和子表达式之间的求值满足以下递归蕴含规则：</p>
<ul>
<li>求值依赖规则：除非另行指定，表达式被求值实质蕴含子表达式被求值。</li>
<li>顺序依赖规则：子表达式值的计算<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序</a>所在的表达式值的计算。</li>
<li>平凡求值规则：指定一个表达式是<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E6%80%A7%E8%B4%A8">纯求值</a>或<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E6%80%A7%E8%B4%A8">空求值</a>对应实质蕴含其子表达式的求值被指定为纯求值或空求值。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　一般地，一些<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">求值策略</a>可以不遵循求值依赖规则。</p>
<p>　　顺序依赖规则是<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">因果性</a>的具体表现之一。对不被求值的表达式，此规则不生效。构造不同的表达式进行计算可实现和直接违反此规则等效的作用，但因为是不同的表达式，实际上不违反此规则。</p>
<p>　　附加的顺序依赖规则可由特定的实体构成的表达式的求值隐含指定。相同的表达式可能在不同上下文中使用不同的规则。</p>
<h4 id="严格性"><a class="header" href="#严格性">严格性</a></h4>
<p>　　若表达式的任意子表达式的求值总是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">非空求值</a>且<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序</a>表达式求值，则这个表达式的求值是<em>严格的(strict)</em> ；反之，求值是<em>非严格的(non-strict)</em> 。</p>
<p>　　推论：严格求值满足<a href="Features/NPL.zh-CN.html#%E9%80%92%E5%BD%92%E8%95%B4%E5%90%AB%E8%A7%84%E5%88%99">顺序依赖规则</a>。</p>
<p>　　非严格求值在规约时可保留未引起作用（通常即未被求值）的部分子表达式，允许实现根据先序的求值作用确定的选择性求值，即包括未指定是否作为<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">空求值</a>的子表达式求值，如分支判断或短路求值。</p>
<p><strong>注释</strong> 例如：ISO C++ 的条件表达式存在可能未被求值的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>，属于非严格求值；<code>++</code> 表达式不作为<em>完全表达式(full expression)</em> 时，副作用可超出此表达式的求值（不满足顺序依赖规则），也是非严格求值。</p>
<p>　　表达式经过<em>严格性分析(strictness analysis)</em> 确定是否严格求值，通过<em>严格性分析器(strictness analyzer)</em> 在<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">语义分析</a>时实现。</p>
<p>　　<em>中间值(thunk)</em> 是保留不直接实现具体求值的部分子表达式的特定的数据结构。</p>
<p><strong>注释</strong> 例如，通过保留中间值待延迟求值，可实现子表达式值的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按需传递</a>。</p>
<h4 id="顺序求值"><a class="header" href="#顺序求值">顺序求值</a></h4>
<p>　　明确的词法顺序可为同一个表达式的若干子表达式提供一致的有序<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">求值策略</a>：从左到右或从右到左。为一致性，不需要考虑其它特定顺序作为一般规则。</p>
<p>　　递归文法表示的表达式和子表达式之间存在相对内外顺序：子表达式在表达式的内部。此求值顺序可对应表达式树的遍历顺序。</p>
<h4 id="替换策略"><a class="header" href="#替换策略">替换策略</a></h4>
<p>　　对应项的规约规则的表达式的重写规则由派生实现定义，典型的可选项包括：</p>
<ul>
<li>名称替换：保证替换前后项对应的<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0">名称</a>不变。</li>
<li>实体替换：保证替换前后项关联的实体不变。</li>
<li>值替换：保证替换前后项关联的表达式的值满足实现定义的相等关系。这包括以下不同的变体：
<ul>
<li>值副本替换：保证替换前后项关联的表达式的值满足值替换的关系，且以实现定义的方式引用不同的实体副本。</li>
<li><a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>替换：保证替换前后项关联的表达式的值满足值替换的关系，且以实现定义的方式引用同一实体。</li>
</ul>
</li>
</ul>
<h4 id="求值策略"><a class="header" href="#求值策略">求值策略</a></h4>
<p>　　组合严格、顺序求值和替换策略可得到不同性质的求值策略。</p>
<p>　　除非派生实现约定，表达式求值策略可以随具体<a href="Features/NPL.zh-CN.html#%E8%AF%AD%E6%B3%95%E5%BD%A2%E5%BC%8F">语法形式</a>不同而不同。</p>
<p>　　典型性质组合如下：</p>
<ul>
<li>严格求值：
<ul>
<li>应用序(applicative order) ：以<em>最左最内(leftmost innermost)</em> 优先的顺序求值。
<ul>
<li>最左的顺序仅在操作数是<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">有序数据结构</a>时有意义；不考虑操作数内部构造时，仅表示操作数作为子表达式总是被求值，和严格求值等价。</li>
</ul>
</li>
<li>按值传递(pass by value) ：使用值替换的严格求值。
<ul>
<li>按值的副本传递(pass by value copy) ：创建<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">值的副本</a>进行替换的严格求值。</li>
<li>按<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>传递(pass by reference) ：使用引用替换的严格求值。</li>
</ul>
</li>
<li>共享对象传递(pass by shared object) ：使用的共享机制以及对象和值或引用的关系由派生实现定义。</li>
<li>部分求值(partial evaluation) ：允许求值分为多个<em>阶段(phase)</em> 分别进行。</li>
</ul>
</li>
<li>非严格求值：
<ul>
<li>正规序(normal order) ：以<em>最左最外(leftmost outmost)</em> 优先的顺序求值。
<ul>
<li>最左的顺序的意义同应用序。</li>
</ul>
</li>
<li>按名传递(pass by name) ：使用名称替换且保持作为名称的表达式最后被替换的求值。</li>
<li>按需传递(pass by need) ：按名传递但允许合并作用相同的表达式。</li>
</ul>
</li>
<li><a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">非决定性</a>求值：
<ul>
<li>完全归约(full reduction) ：替换不受到作用之间的依赖的限制。</li>
<li>按预期传递(pass by future) ：并发的按名传递，在需要使用参数的值时同步。</li>
<li>乐观求值(optimistic evaluation) ：部分子表达式在未指定时机部分求值的按需求值，若超出约定时限则放弃并回退到按需求值。</li>
</ul>
</li>
</ul>
<h3 id="可选求值规则"><a class="header" href="#可选求值规则">可选求值规则</a></h3>
<p>　　应满足的本节上述约定的最小求值规则和语义外的具体求值的规则和语义由派生实现定义。</p>
<p>　　派生实现的求值可满足以下节指定语义，此时应满足其中约定的规则。</p>
<p>　　若可选求值规则逻辑上蕴含规约规则，则被蕴含的规约规则的直接表述可在语言规则中被省略。</p>
<h3 id="上下文相关求值"><a class="header" href="#上下文相关求值">上下文相关求值</a></h3>
<p>　　在被求值的表达式以外，对应的规约规则在实现此规约的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>中可能是<a href="Features/../Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">上下文</a>相关的，这种附加依赖的上下文为<em>求值上下文(evaluation context)</em> 。</p>
<p>　　求值上下文被作为元语言实现对象求值规则时的输入，可指定项所在的位置等不被被规约的项必然蕴含的附加信息。</p>
<p>　　由派生实现定义的特定求值上下文称为<em>尾上下文(tail context)</em> 。以尾上下文求值可提供附加的保证。</p>
<p>　　元语言中，一般的求值上下文 <code>C</code> 形式化为具有占位符 <code>[]</code> 和可选前缀 <code>v</code> 及可选后缀 <code>e</code> 的递归组合的串：</p>
<pre><code>C ::= [] | Ce | vC
</code></pre>
<p>　　其中 <code>e</code> 是被求值表达式，<code>v</code> 是作为<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">范式</a>的值。</p>
<p>　　除非另行指定，NPL 对象语言的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>使用的求值上下文总是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">求值环境</a>。</p>
<p><strong>原理</strong></p>
<p>　　通过附加适当的求值规则保证对象语言中的表达式总是可唯一地被分解为这种表示，抽象的求值上下文可直接实现对象语言的求值。但语义描述和实现的基准都以<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机</a>替代，因为：</p>
<ul>
<li>抽象机语义允许不依赖<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源程序</a>的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>和构造（如特定的表达式的文法）。</li>
<li>这种分解一般要求遍历对象语言的源程序而难以具有较好的可实现性质，如<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算复杂度</a>。</li>
<li>为满足良好的可实现性质，需描述实现中可能具有的离散状态与只和其中个别状态关联的局部的求值规则时，这种分解通常会渐进演化为某种抽象机的表示。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　使用求值环境作为默认的上下文确保一般的求值总是能支持变量的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">绑定</a>。</p>
<p>　　对象语言的实现同时能够支持其它上下文，即使它不在求值算法中出现。这样的上下文可能被求值上下文蕴含而可被推理确定。</p>
<h2 id="λ-完备语义和对应语法"><a class="header" href="#λ-完备语义和对应语法">λ 完备语义和对应语法</a></h2>
<p>　　作为通用语言，求值规则表达的系统可具有和<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9E%8B">无类型 λ 演算</a>对应的形式和计算能力。</p>
<p>　　基于此语义的派生实现应允许以下几种互不相交的表达式集合：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">名称表达式</a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">匿名函数</a></li>
<li><a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数应用</a></li>
</ul>
<p>　　NPL 不要求以上表达式中函数以外的表达式求值的<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">强规范化</a>。</p>
<p><strong>注释</strong></p>
<p>　　无类型 λ 演算保证名称表达式（变量）和函数（ λ 抽象）的规约的强规范化，但不保证函数应用规约的强规范化。</p>
<p>　　扩展的 λ 演算（如<a href="https://zh.wikipedia.org/zh-cn/%E7%AE%80%E5%8D%95%E7%B1%BB%E5%9E%8B%CE%BB%E6%BC%94%E7%AE%97">简单类型 λ 演算</a>）可保证规约函数应用的强规范化。</p>
<h3 id="名称表达式"><a class="header" href="#名称表达式">名称表达式</a></h3>
<p>　　<em>名称表达式(name expression)</em> 是表示变量的 λ 项。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%8E%9F%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F">原子表达式</a>的由派生实现定义的非空子集是名称表达式。其它作为名称表达式的表达式<a href="Features/NPL.zh-CN.html#%E8%AF%AD%E6%B3%95%E5%BD%A2%E5%BC%8F">语法形式</a>由派生实现定义。</p>
<p>　　名称表达式不被进一步规约；其求值是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">值替换规则</a>的平凡形式。</p>
<h3 id="函数"><a class="header" href="#函数">函数</a></h3>
<p>　　<em>函数(function)</em> 是一种参与特定规约规则的实体，也可以指求值为函数实体的表达式。</p>
<p>　　一般地，函数表达式在 <a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">WHNF</a> 下作为<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作符</a>被求值，其<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">最终求值结果</a>为函数实体，或函数对象（若函数在语言中允许作为对象）。</p>
<p>　　NPL 中，作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>的函数表达式的最终求值结果是<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>。</p>
<p>　　一个函数表达式是以下两种表达式之一：</p>
<ul>
<li>保持<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">等价地</a>求值到其它函数表达式上的<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">名称表达式</a>，称为<em>具名函数表达式(named function expression)</em> ，简称<em>具名函数(named function)</em> 。</li>
<li>满足本节以下规则的由派生实现定义的<em>匿名函数表达式(anonymous function expression)</em> ，简称<em>匿名函数(anonymous function)</em> 。</li>
</ul>
<p>　　函数应确定替换重写规则<a href="Features/NPL.zh-CN.html#%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5">被替换的目标</a>，即<em>函数体(function body)</em> 。</p>
<p>　　除非派生实现另行指定，函数不需要被进一步规约，此时其求值是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">值替换规则</a>的平凡形式。</p>
<p>　　在<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">类型系统</a>中，函数可被指派<em>函数类型(function type)</em> 。函数类型能蕴含<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">参数</a>和结果的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型</a>。</p>
<p><strong>注释</strong> 例如，在简单类型 λ 演算中，函数类型是<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型构造器</a> <code>→</code> 组合输入（参数）和结果（输出）类型的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">复合类型</a>。</p>
<h4 id="函数内部的变量"><a class="header" href="#函数内部的变量">函数内部的变量</a></h4>
<p>　　匿名函数可以显式指定（<em>绑定(bind)</em> ）包含若干变量使之成为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">约束变量</a>的语法构造。</p>
<p>　　通过创建函数时的显式的语法构造引入的这种变量称为函数的<em>形式参数(formal parameter, parameter)</em> 。</p>
<p>　　除绑定外，匿名函数可以<em>捕获(capture)</em> 若干在函数体以外的同名变量，即<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">自由变量</a>。</p>
<p>　　通过绑定或捕获引入的变量允许在函数体中允许使用。</p>
<p>　　使用<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83%E6%8F%90%E4%BE%9B%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">词法作用域</a>时，若匿名函数所在<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用域</a>的存在同名的<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0">名称</a>，则被捕获的名称被<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">隐藏</a>。形式参数隐藏被捕获的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">变量名</a>。</p>
<p>　　派生实现的语义规则应满足和 λ 演算的语义的 α-转换(alpha-conversion) 规则不矛盾。</p>
<p><strong>注释</strong> <a href="Features/NPL.zh-CN.html#vau-%E6%8A%BD%E8%B1%A1">Vau 演算</a>在没有限定<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">环境</a>时不考虑一般意义上的自由变量。</p>
<p>　　函数应用的求值决定被绑定的变量和函数体内的变量之间的关系，参见<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>。此时，<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">求值策略</a>蕴含的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">替换策略</a>蕴含被绑定的变量和函数体内的变量之间的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>。</p>
<p>　　类似地，在被捕获的变量到函数体内捕获的变量之间，也有和替换策略一一对应的不同捕获策略。</p>
<p>　　除非另行指定，变量被<em>按引用捕获(captured by reference)</em> 而非<em>按值的副本捕获(captured by value copy)</em> ，即通过捕获引入的变量是被捕获变量的引用而不是副本。</p>
<p><strong>原理</strong></p>
<p>　　捕获为引用而不是副本，保持被捕获的变量和函数体内同名变量的同一性，在实体是对象时不影响可观察行为。若这些捕获未被使用，可被实现直接移除。</p>
<h4 id="过程"><a class="header" href="#过程">过程</a></h4>
<p>　　<em>过程(procedure)</em> 是操作符<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">具现</a>的<em>可调用(callable)</em> 的实体，决定特定的可提供求值的作用（包括决定求值结果）的<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算</a>。</p>
<p>　　函数表达式的<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">最终求值结果</a>由过程实体的作用中的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">结果</a>决定，以派生实现定义的方式关联。</p>
<p>　　通过函数表达式可指定可选的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">实际参数</a>，发生过程<em>调用(call)</em> 。过程的调用蕴含计算。</p>
<p>　　过程中和过程外的计算的组合满足<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">因果性</a>：</p>
<ul>
<li>以求值描述的过程中的计算整体非<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">后序</a>于引起过程中计算的外部环境的计算。</li>
<li>以求值描述的过程中的任意计算非后序于对应计算结果的值的计算，即值的计算结果是决定值的计算的<em>依赖(dependency)</em> 。</li>
</ul>
<p>　　<em>主调函数(caller function)</em> 等<em>调用者(caller)</em> 或其它引起过程中的计算的实体转移<em>控制(control)</em> 到过程中的计算而使之<em>进入(enter)</em> 到<em>被调用者(callee)</em> 的过程。</p>
<p>　　过程可能被限制只有<em>一次(one-shot)</em> 调用有效；其它过程是<em>多次(multi-shot)</em> 的。</p>
<p>　　多次过程调用时控制可能通过调用被再次转移，即<em>嵌套调用(nested call)</em> 。</p>
<p>　　一些被多次调用的过程可能被多次进入，即<em>重入(reenter)</em> 。</p>
<p>　　一个调用中的重入相同或不同过程的次数称为调用的<em>深度(depth)</em> 。</p>
<p>　　推论：嵌套调用是深度大于 1 的调用。</p>
<p>　　通过嵌套调用直接（总是以自身作为调用者）或间接（通过其它调用者转移控制）的重入是<em>递归调用(recursive call)</em> 。</p>
<p>　　过程可以<em>返回(return)</em> 取得计算的值并可同时改变<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制状态</a>，影响之后的计算。</p>
<p><strong>原理</strong></p>
<p>　　一次过程，特别是在其内部涉及和<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">续延</a>或<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83%E6%8F%90%E4%BE%9B%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">闭包</a>的实现交互时，相对多次过程可能具有因其对持有资源的要求较宽松，而具有较小的性能开销。</p>
<p><strong>注释</strong></p>
<p>　　对象语言中的过程在描述操作语义的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>中可表示为函数，其应用可对应对象语言中过程的隐式调用。</p>
<p>　　违反一次过程调用有效地约束的程序典型地<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　注意过程不一定可作为可被对象语言直接表达的<em>一等(first-class)</em> 函数，但同时在元语言中仍然可能可行。如<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">无界续延</a>，因为可能不符合<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数的类型要求</a>，详见<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延的捕获和调用</a>中的原理。</p>
<p>　　一次重入的过程调用分配的资源对应一个<a href="Features/NPL.zh-CN.html#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">活动记录帧</a>。</p>
<h4 id="过程调用的计算顺序"><a class="header" href="#过程调用的计算顺序">过程调用的计算顺序</a></h4>
<p>　　按计算的顺序约束和默认返回控制的方式，可能有不同的形式。</p>
<p>　　<em>例程(routine)</em> 的求值不<em>交叉(interleave)</em> ，即例程中的计算和之外的计算<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">非决定性有序</a>。</p>
<p>　　作为不同的例程，不考虑被保存<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">续延</a>时：</p>
<ul>
<li><em>子例程(subroutine)</em> 在返回一次后不重新进入。</li>
<li><em>协程(coroutine)</em> 则可能引起多次返回。</li>
</ul>
<p>　　引起多次返回对应改变<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制作用</a>。</p>
<p>　　一般的续延支持返回多次并可能支持和调用者并发的计算，而协程蕴含的控制作用的改变对应不同续延的替换，也能实现类似的支持。</p>
<p>　　NPL 支持函数求值得到过程。对象语言中的过程可能支持使用这些形式的一种或多种，具体形式由派生实现指定。</p>
<p>　　协程可能限制转移向下一步骤的计算转移的方向，即调用者和被调用者被通过创建其的语法构造确定，而不能在之后改变。</p>
<p>　　协程创建时一般指定例程，或以当前的控制状态创建。后者类似<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延捕获</a>。</p>
<p>　　根据是否只提供一种不区分转移方向的原语，协程分为<em>对称(symmetric)</em> 和<em>非对称(asymmetric)</em> 协程：</p>
<ul>
<li>对称协程转移控制到另一个协程，不需要单独区分不同的操作。</li>
<li>非对称协程又称为<em>半(semi)</em> 协程，对控制的转移分为<em>调用(invoke)</em> 和<em>出让(yield)</em> 操作，其中：
<ul>
<li>调用操作转移控制到被调用的协程，恢复之前保存的上下文（若有）或创建时的初始上下文。</li>
<li>出让操作<em>暂停(suspend)</em> 和保存当前上下文并返回控制到它的调用者。
<ul>
<li>转移控制可被实现调度。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　根据是否协程持有<a href="Features/NPL.zh-CN.html#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">活动记录帧</a>，协程分为<em>有栈(stackful)</em> 和<em>无栈(stackless)</em> 的。</p>
<ul>
<li>两者提供不同的资源<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权</a>，而可能影响使用这些特性的程序中的资源的<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>。</li>
<li>特别地，无栈协程不保证活动记录的可用性，无法直接支持创建的协程作为一等对象使用。</li>
</ul>
<p>　　因为具有类似的改变控制的能力，有栈的、可作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>的<em>全协程(full coroutine)</em> 可替代<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">一等续延</a>。</p>
<p><strong>原理</strong></p>
<p>　　全协程可视为是在计算上<a href="Features/NPL.zh-CN.html#%E5%AE%8C%E6%95%B4%E6%80%A7">可表达性</a>等价的<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">一次续延</a>：</p>
<ul>
<li>参见<a href="http://www.cs.tufts.edu/comp/250RTS/archive/roberto-ierusalimschy/revisiting-coroutines.pdf">这里</a>。</li>
<li>其中，对称的协程类似一次<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">无界续延</a>，非对称的协程类似一次<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">有界续延</a>。</li>
<li>在核心语言支持<em>存储(store)</em> 即<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">可修改</a>的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">一等状态</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>的前提下，非对称协程和对称协程在可表达性上等价。
<ul>
<li>有界续延可不依赖其它副作用表达状态，但<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">无界续延无法表达</a>。</li>
</ul>
</li>
<li>对称协程可实现一次续延。
<ul>
<li><strong>注释</strong> 另见<a href="http://www.inf.puc-rio.br/~roberto/docs/MCC15-04.pdf">这里</a>，但这个实现没有检查续延调用内部可能的非预期重入，且不满足 [Hi90] 中的 <a href="Features/NPL.zh-CN.html#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C-ptc">PTC 要求</a>。</li>
</ul>
</li>
<li>因此，作为一等对象时，协程可作为一等续延的替代实现方式。</li>
</ul>
<p>典型的设计中，函数表达式默认创建例程，而协程使用特设的语法标记过程得到。</p>
<ul>
<li>其中，<code>yield</code> 关键字一般对应非对称协程中的出让操作。</li>
<li><strong>注释</strong> 另见<a href="https://cs.indiana.edu/~sabry/papers/yield.pdf">这里</a>。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　关于过程的参数和过程调用之间的计算顺序，参见<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">求值策略</a>。</p>
<h4 id="λ-抽象"><a class="header" href="#λ-抽象">λ 抽象</a></h4>
<p>　　λ 抽象(lambda abstraction) 是 λ 演算中的基本构成之一，提供匿名函数。</p>
<p><strong>注释</strong> λ 抽象的语法包含的形式是典型的操作符。</p>
<p>　　在原始的无类型 λ 演算中，λ 抽象<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">不支持蕴含副作用</a>，子表达式求值顺序任取而不改变<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">范式</a>的存在性和值。</p>
<p>　　在使用<a href="Features/NPL.zh-CN.html#%CE%BB-%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">热情求值</a>的语言中，λ 抽象创建的过程是应用<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>。</p>
<h4 id="vau-抽象"><a class="header" href="#vau-抽象">vau 抽象</a></h4>
<p>　　Vau 抽象(vau abstraction) 是 vau 演算 ([Shu10]) 中的基本构成之一。</p>
<p>　　Vau 抽象创建的过程是操作<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>。</p>
<p><strong>注释</strong> 使用 vau 抽象可实现引入 λ 抽象的操作符，如 [R<sup>n</sup>RK] 提供的 <code>$vau</code> 操作合并子。</p>
<h3 id="函数合并"><a class="header" href="#函数合并">函数合并</a></h3>
<p>　　具有操作符和操作数的项的组合可被特定的方式进行规约。这种组合是<em>函数合并(function combination)</em> ，包含：</p>
<ul>
<li>具有至少一个约定位置的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">子项</a> <code>E1</code> 的<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F">复合表达式</a> <code>E</code> ，当且仅当 <code>E1</code> 是被求值作为<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作符</a>的函数时，<code>E</code> 是<em>函数合并表达式(function combination expression)</em> 。</li>
<li>其它具有操作符和操作数的项是非表达式形式的函数合并。以下操作符和操作数记作 <code>E1</code> 和 <code>E2</code> 。</li>
</ul>
<p>　　以下规则中，非表达式形式的函数合并也可被视为表达式求值。</p>
<p>　　求值函数合并时，子项 <code>E1</code> 总是被求值。</p>
<p>　　除 <code>E1</code> 外表达式的剩余子项 <code>E2</code> 是<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>，在 E 被求值时以操作数决定的值等效<em>替换(substitute)</em> 函数的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">形式参数</a>。</p>
<p>　　替换形式参数的值是<em>实际参数(actual argument, argument)</em> 。</p>
<p>　　函数合并的求值是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">值替换规则</a>的非平凡形式。</p>
<p>　　若替换操作数 <code>E2</code> 在合并中被求值，函数合并 E 是函数应用表达式，简称<em>函数应用(function application)</em> 。</p>
<p>　　若操作符是 λ 抽象，<code>E2</code> 视为一个整体，则函数应用替换规则对应 λ 演算的 β-规约(beta-reduction) 规则。</p>
<p>　　其它函数合并使用的替换规则由派生实现指定。</p>
<p>　　派生实现应指定函数合并<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">规约</a>的结果是<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">规范形式</a>，它对应的值是函数合并的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>替换被求值的表达式的实体，称为<em>函数值(function value)</em> 。</p>
<p>　　函数应用匹配实际参数和对应的引入形式参数的构造。匹配可能失败。确定匹配参数成功的条件是等价关系，称为参数匹配一致性，由参数匹配的等价关系指定。</p>
<p>　　匹配成功的每个实际参数和被匹配的目标（可能是形式参数）具有一对一或多对一的对应关系。</p>
<p>　　伴随参数匹配，实现可引入其它必要的操作（如为匹配分配资源和确定上述对应关系）。这些操作可具有和确定参数对应关系的匹配之间<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">非决定性有序</a>的副作用。</p>
<p>　　仅当上述必要操作及所有实际参数的匹配成功，替换 <code>E1</code> 决定的某个关联表达式中和形式参数结构一致的子表达式为实际参数。替换参数的结构一致性是等价关系。</p>
<p>　　表达式相等蕴含参数匹配一致性和替换结构一致性。实现可分别定义其它规则扩充这些等价关系的外延。</p>
<p>　　替换参数的值蕴含对实际参数的计算的依赖，即参数的值的计算<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序</a>函数应用的求值；但其它求值顺序没有保证。</p>
<p><strong>注释</strong></p>
<p>　　一般地，根据 <code>E1</code> 的值，操作数或操作数的求值结果被作为实际参数。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">过程</a>及其调用在其操作语义的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>中通常表达为函数及函数合并。</p>
<p>　　若过程的结果被忽略，则通常表达为<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">单元类型</a>的值。</p>
<p>　　此外，一些语言中忽略过程的结果是<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">空类型</a>，以检查错误的使用。NPL 不要求语言具有<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态类型</a>规则，也不要求这些检查。</p>
<h4 id="函数调用"><a class="header" href="#函数调用">函数调用</a></h4>
<p>　　求值函数合并包含子表达式的求值：总是求值操作符，并可能求值操作数。若这些求值都没有退出，则发生函数<em>调用(call)</em> ，函数是<em>被调函数(called function)</em> 。</p>
<p>　　若被调函数存在形式参数，函数调用首先以操作数的直接子表达式作为实际参数，匹配实际参数和形式参数。</p>
<p>　　若实际参数匹配的目标可指定一个变量，则伴随参数匹配的操作包括以特定规则<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">绑定</a>的形式参数。</p>
<p>　　绑定的实际参数和对应的形式参数作为不同的实体时，作为伴随参数匹配的必要操作的一部分，发生<em>参数传递(parameter passing)</em> 。参数传递使形式参数具有作为实际参数值的副本。参数传递可能使和实际参数相关的资源被复制或转移。</p>
<p>　　实现在函数合并的求值中应提供函数调用的支持。</p>
<p>　　函数调用确定副作用的边界：保证参数表达式在函数应用被求值之前被求值。</p>
<p>　　在控制<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">返回</a>时，函数调用内部确定的函数值最终替换被求值的函数合并，即为<em>返回值(return value)</em> 。</p>
<p>　　若函数是<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">过程</a>，对应的函数调用是<em>过程调用(procedure call)</em> 。</p>
<p>　　若一个函数的调用仍待返回，则该函数调用是<em>活动的(active)</em> 。</p>
<p>　　调用总是不蕴含非<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>的函数是<em>纯函数(pure function)</em> 。</p>
<p>　　函数调用的中蕴含的求值对应的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E8%A7%84%E5%88%99%E5%92%8C%E6%B1%82%E5%80%BC">规约步骤</a>的集合是它的<em>动态范围(dynamic extent)</em> 。</p>
<p>　　函数中被<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">捕获</a>的实体的引用和求值函数中的计算创建的对象的引用构成函数计算的结果时，引用可能<em>逃逸(escape)</em> ，即在调用的动态范围以外可访问。</p>
<p>　　派生实现可能约定附加的名义特征区分其它情形相同的调用，称为<em>调用约定(calling convention)</em> 。</p>
<p><strong>注释</strong></p>
<p>　　典型实现的函数指称过程，函数调用是过程调用。</p>
<p>　　一般地，被调用的函数及函数调用的作用的等价性通常不能被确定。</p>
<p>　　一个重要的子类是<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">不能确定具体表示</a>的情形，参见<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>。其它函数一般也有类似限制。</p>
<p>　　关于函数调用中的求值，另见函数调用的<a href="Features/NPL.zh-CN.html#%E7%BB%88%E6%AD%A2%E4%BF%9D%E8%AF%81">终止保证</a>。</p>
<p>　　和 [R<sup>n</sup>RS] 不同，动态范围仅对求值定义，而不是关于环境中的绑定显示<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">计算作用</a>的属性。这种属性事实上对象的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>，仅对对象而非更一般的实体有效。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">续延</a>可用其动态范围表示。</p>
<p>　　本文档的动态范围的概念定义和 [R<sup>n</sup>RK] §7.1 的定义兼容，但不依赖其对续延的描述，也适用<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机语义</a>，是 [R<sup>n</sup>RK] 的一般化。</p>
<p>　　[Racket] 使用求值的规约步骤在表达式上定义动态范围。NPL 不在表达式上采用类似的定义，因为：</p>
<ul>
<li>类似 [R<sup>n</sup>RK] ，NPL 强调支持对象语言中的<a href="Features/NPL.zh-CN.html#%E5%85%B6%E5%AE%83%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8F%82%E8%80%83">显式求值风格</a>及表达式求值前后的不同。</li>
<li>类似 [R<sup>n</sup>RK] ，进一步地，NPL 派生语言（如 NPLA1 ）可明确支持在对象语言中指定<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">求值环境</a>而改变求值的上下文，表达式不能被预期通常以<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">上下文</a>无关的方式被求值。</li>
</ul>
<p>　　调用约定可提升实现细节，为<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>提供接口保证，避免非预期的不兼容实现的混合。</p>
<h4 id="合并子"><a class="header" href="#合并子">合并子</a></h4>
<p>　　除非另行指定，NPL 假定函数合并满足以下典型情形，即函数合并的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作符</a>求值为以下类型的<em>合并子(combiner)</em> 之一：</p>
<ul>
<li>对操作数的直接<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作</a>（而不要求对操作数求值）的合并子是<em>操作合并子(operative combiner)</em> ，简称<em>操作子(operative)</em> 。</li>
<li>进行函数应用的合并子是<em>应用合并子(applicative combiner)</em> ，简称<em>应用子(applicative)</em> 。</li>
<li>由派生实现定义的<em>扩展合并子(extended combiner)</em> 。</li>
</ul>
<p>　　合并子的函数应用（依赖对操作数进行至少一次求值）是<em>合并子应用(combiner application)</em> 。</p>
<p>　　合并子应用使用<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">应用序</a>。</p>
<p>　　应用子总是对应一个<em>底层(underlying)</em> 合并子，可通过底层合并子上的一元的<em>包装(wrap)</em> 操作得到；其逆操作为<em>解包装(unwrap)</em> 。</p>
<p>　　解包装结果不是扩展合并子的合并子称为<em>真合并子(proper combiner)</em> 。</p>
<p>　　合并子上可以定义若干等价关系，这些等价关系蕴含关于函数应用替换的基本形式：</p>
<p>　　若对任意上下文，替换一个应用中的合并子为另一个不改变函数应用替换的结果，则这两个合并子等价（对应 λ 演算的 β-等价）。</p>
<p><strong>注释</strong></p>
<p>　　合并子被<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">调用</a>时通常<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">返回</a>且仅返回一次。</p>
<p><strong>注释</strong> 详见<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延的捕获和调用</a>。</p>
<p>　　由于程序可能引入未知具体表示的合并子（如从其它模块链接），以上等价可能无法判定，不要求实现提供。</p>
<p>　　因为本设计不依赖 λ 抽象的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">内部表示</a>（特别是支持<a href="Features/NPL.zh-CN.html#%CE%BB-%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">惰性求值</a>为目的的），不依赖 η-变换的<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>，也不要求支持更强的 βη-等价。</p>
<p>　　派生实现可按需定义较弱的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">等价谓词</a>，保证其判定结果蕴含上述等价关系的结果。</p>
<h4 id="续延的捕获和调用"><a class="header" href="#续延的捕获和调用">续延的捕获和调用</a></h4>
<p>　　语言可提供作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等实体</a>的<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">续延</a>即<em>一等续延(first-class continuation)</em> 。</p>
<p>　　续延的<em>捕获(capture)</em> <a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">具现</a><a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">当前续延</a>为对象语言中可操作的一等续延。</p>
<p>　　类似<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">过程</a>，续延可被<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">一次或多次调用</a>，称为<em>续延调用(continuation call)</em> 。</p>
<p>　　续延调用接受一个<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">实际参数</a>作为传递给后继<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E8%A7%84%E5%88%99%E5%92%8C%E6%B1%82%E5%80%BC">规约步骤</a>使用的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>。除非另行指定，续延参数被<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值传递</a>。被调用的续延可<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>参数并执行其蕴含的其余规约步骤。</p>
<p>　　和接受实际参数对应，续延可被假定关联一个等效的<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">应用子</a>，具有一个<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">形式参数</a>，这个应用子的<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">底层合并子</a>被<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">调用</a>时<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%9D%A1%E4%BB%B6">非正常地</a>传递它的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>给关联的续延。</p>
<p>　　对象语言可支持符合<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数类型要求</a>的一等续延作为函数。作为一等续延的函数可直接作为<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>构成<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>进行<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>，而实现续延调用。</p>
<p>　　除非派生实现另行指定，NPL 的一等续延不是函数。</p>
<p>　　函数应用（如<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">合并子调用</a>）可隐含（<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>的）续延调用。</p>
<p>　　续延调用的其它的具体形式由派生实现定义。</p>
<p>　　除非在捕获的续延上存在特定的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制作用</a>，合并子被调用时以当前续延<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回</a>且仅返回一次。</p>
<p>　　类似<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数应用表达式</a>，<em>续延应用(continuation application)</em> 表达式是求值时蕴含<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延调用</a>的表达式。</p>
<p><strong>原理</strong></p>
<p>　　在 Scheme 中，一等续延即过程。</p>
<p>　　在限制<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>的函数不蕴含控制作用时，类似 Scheme 等支持的无界<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">续延</a>不是函数。一个理由不能以常规方式为无界续延指定是函数<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型</a>。参见<a href="https://okmij.org/ftp/continuations/undelimited.html#introduction">这里</a>的介绍。</p>
<p>　　在 Kernel 和其它一些语言中，续延不是过程，而具有不同的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义类型</a>。这种不同于 Scheme 的设计是有意的。</p>
<p>　　NPL 一等续延不限制是否和函数类型同一，因此无界续延仍可被视为函数（或更确切地，即程序入口作为边界的有界续延）。</p>
<p>　　类似 [R<sup>n</sup>RK] 的设计，因为一等续延的调用可引起和更常见的过程调用显著不同的控制作用，续延调用有必要和过程调用在对象语言的语法上显式区分以满足<a href="Features/NPL.zh-CN.html#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测性</a>，因此一等续延一般不是函数。</p>
<p>　　续延关联的等效应用子的原理同 [R<sup>n</sup>RK] §7 和 §7.2.5（应用子 <code>continuation-&gt;applicative</code>）的原理，但略有不同：</p>
<ul>
<li>作为一等对象的续延和续延的实际参数是否求值无关，因此不是合并子，<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>不需要支持续延作为函数合并被求值；但续延可通过特定的操作转换为应用子。</li>
<li>续延和操作子在被调用时都接受一个实际参数对象。
<ul>
<li>对前者，对象典型地表示计算的结果，即已被求值。</li>
<li>对后者，对象是操作数。典型地，操作子作为应用子的底层合并子，操作数已被作为应用子的实际参数被求值算法求值。</li>
<li>类似 [R<sup>n</sup>RK] 而和 [R<sup>n</sup>RS] 不同，因为<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>可接受非真列表作为参数，非列表的操作数可以和非列表的续延实际参数直接对应。
<ul>
<li>因为函数合并的这种性质，续延关联的应用子的应用和续延应用存在直接的一一对应关系。</li>
</ul>
</li>
</ul>
</li>
<li>但是，为避免和<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>冲突，[R<sup>n</sup>RK] 的<em>选择器(selector)</em> 支持在此未被要求。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　类似过程，续延及其调用在其操作语义的元语言中能表示为元语言的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数应用</a>，通常表达为<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数</a>及<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>。</p>
<p>　　续延捕获在语法上类似函数对变量的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">捕获</a>。被捕获的实体通常以引用保存。被捕获的实体通常是隐式的，即不在对象语言程序中出现。</p>
<p>　　在支持一等续延且捕获的续延可被复制的语言中，实现需要考虑活动记录的复制，参见 [Hi90] 。</p>
<p>　　关于控制作用，另见续延调用<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%9D%A1%E4%BB%B6">对程序控制的改变</a>。</p>
<h4 id="活动记录"><a class="header" href="#活动记录">活动记录</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">活动的</a>合并子分配的对象称为<em>活动记录(activation record)</em> 。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>以活动记录引用涉及的变量。每个调用的活动记录中可保存多个变量。活动记录可能因此持有状态，即便不一定可被函数调用外的操作直接修改。</p>
<p>　　嵌套的函数调用具有多次分配的活动记录。为强调其中的对应关系，每一个调用关联其中的一个<em>帧(frame)</em> 。</p>
<p>　　在确定一次分配的一个活动记录对应一次函数调用的实现中，一个活动记录和一个活动记录的帧同义。</p>
<p>　　活动记录的集合可能构成特定的数据结构。例如限制只支持嵌套的子例程调用（而不支持一般的<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延调用</a>）时，具有后入先出(LIFO, last-in-first-out) 的栈的结构。</p>
<h3 id="λ-求值策略"><a class="header" href="#λ-求值策略">λ 求值策略</a></h3>
<p>　　在<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">变量</a>绑定值后，兼容 λ 演算规约语义（特别地，β-规约）的表达式的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">具体求值</a>根据是否传递操作数对使用<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按需传递</a>的情形分为三类：</p>
<ul>
<li>（完全）<em>惰性求值(lazy evaluation)</em></li>
<li>部分惰性求值</li>
<li><em>热情求值(eager evaluation)</em></li>
</ul>
<p>　　其中，惰性求值总是使用按需传递，热情求值总是不使用按需传递，部分惰性求值不总是使用或不适用按需传递。</p>
<p>　　在保证不存在非<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>时这些求值的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">计算作用</a>没有实质差异。存在非纯求值时，使用的 λ 求值策略由派生实现定义。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E4%B8%A5%E6%A0%BC%E6%80%A7">非严格求值</a>严格蕴含惰性求值。两者经常但不总是一致，例如，实现可能<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">并行地</a>热情求值，并舍弃部分结果以实现非严格求值。</p>
<p>　　热情求值蕴含<a href="Features/NPL.zh-CN.html#%E4%B8%A5%E6%A0%BC%E6%80%A7">严格求值</a>。两者也经常但不总是一致，例如，实现可能使用应用序严格求值。但因为非严格的热情求值缺乏性能等可局部优化的实用动机，这种不一致的情况通常不作为附加的语言特性提供（而仅为简化实现默认作为全局策略使用）。</p>
<p><strong>注释</strong></p>
<p>　　由于实现可能确定特定表达式的作用对约定必须保持的<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">程序行为</a>没有影响而可能省略求值，按<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机</a>语义的严格求值在实际实现中通常是不必要的。</p>
<p>　　惰性求值可通过中间值<a href="Features/NPL.zh-CN.html#%E4%B8%A5%E6%A0%BC%E6%80%A7">延迟求值</a>实现。</p>
<h2 id="上下文"><a class="header" href="#上下文">上下文</a></h2>
<p>　　<em>上下文(context)</em> 是表达式关联的状态的特定集合。</p>
<p><strong>注释</strong> 这里不是<a href="Features/../Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">自指概念</a>。</p>
<p>　　一个上下文是<em>显式的(explicit)</em> ，当且仅当它可以通过<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">名称表达式</a>访问。</p>
<p>　　一个上下文是<em>隐式的(implicit)</em> ，当且仅当它不是显式的。</p>
<p>　　隐式的上下文通常是<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">管理状态</a>。</p>
<p>　　确定上下文的状态或对可变上下文的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">修改</a>是对上下文的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>。</p>
<p>　　规约规则中，以未指定子项参数化的项是一个上下文。</p>
<p>　　本节以外其它关于上下文的具体规则由派生实现定义。</p>
<p><strong>注释</strong></p>
<p>　　参数化的子项可在（<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>的）语法上被表示为一个<em>洞(hole)</em> ，详见<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">上下文相关求值</a>中的语法 <code>[]</code> 。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">过程实体</a>能影响<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">函数表达式</a>关联的上下文，参见<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">函数和函数应用的求值环境</a>。</p>
<h3 id="求值环境"><a class="header" href="#求值环境">求值环境</a></h3>
<p>　　<em>求值环境(evaluation environment)</em> 是在求值时可访问的隐式上下文，提供可通过<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>访问的变量的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">绑定</a>。</p>
<p>　　不和<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">实现环境</a>相混淆的情况下，求值环境简称（变量或对应的局部绑定所在的）为<em>环境(environment)</em> 。</p>
<p>　　能被通过名称解析成功访问变量的绑定是<em>可见的(visible)</em> 。</p>
<p>　　环境<em>包含(contain)</em> 若干个<em>局部绑定(local binding)</em> ，即不通过其它环境即保证可见的<em>被绑定实体(bound entity)</em> 。</p>
<p>　　环境<em>展示(exhibit)</em> 可见的绑定。</p>
<p>　　一个环境是<em>空环境(empty environment)</em> ，当且仅当其中包含的局部绑定集合是空集。</p>
<p><strong>注释</strong></p>
<p>　　按绑定的定义，求值环境的局部绑定集合即变量的名称和通过声明引入的被变量表示的实体构成的映射。</p>
<p>　　包含和展示的定义同 [R<sup>n</sup>RK] 。</p>
<h4 id="实现环境提供的求值环境"><a class="header" href="#实现环境提供的求值环境">实现环境提供的求值环境</a></h4>
<p>　　实现环境可能在实现以外提供附加的求值环境作为任务通信的机制，如环境变量。</p>
<p>　　除非派生实现另行指定，语言支持的求值环境和这些机制蕴含的求值环境的交集为空。语言可以库的形式提供 <a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 另行支持。</p>
<h4 id="函数和函数应用的求值环境"><a class="header" href="#函数和函数应用的求值环境">函数和函数应用的求值环境</a></h4>
<p>　　在典型的对象语言中 <a href="Features/NPL.zh-CN.html#%CE%BB-%E6%8A%BD%E8%B1%A1">λ 抽象</a>中指定的替换构造具有<em>局部作用域(local scoping)</em> ，其中可访问 λ 抽象外部词法意义上<em>包含的(enclosing)</em> 求值环境的变量，对应求值环境为<em>局部环境(local environment)</em> 。</p>
<p>　　在基于<em>词法作用域(lexical scoping)</em> 的对象语言中，引入 λ 抽象对应的语言构造支持<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">捕获</a>引入函数时所在的作用域的环境，称为<em>静态环境(static environment)</em> 。</p>
<p>　　相对地，<em>动态作用域(dynamic scoping)</em> 根据求值时的状态指定指称。</p>
<p>　　<a href="Features/NPL.zh-CN.html#vau-%E6%8A%BD%E8%B1%A1">Vau 抽象</a>进一步支持在局部环境中提供访问<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数应用</a>时的求值环境，即<em>动态环境(dynamic environment)</em> 的机制。</p>
<p>　　除非另行指定，按<em>词法闭包(lexical closure)</em> 规则捕获，即只根据词法作用域确定捕获的指称；若需要支持依赖求值状态动态确定指称时，使用派生实现提供的对求值环境的操作，而不依赖动态作用域。</p>
<p>　　作为<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">过程</a>的实现，词法闭包规则捕获实体创建<em>闭包(closure)</em> 。</p>
<p>　　除非另行指定，NPL 只存在一种作用域，即所有作用域都使用相同的<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>和捕获规则。</p>
<h3 id="互操作上下文"><a class="header" href="#互操作上下文">互操作上下文</a></h3>
<p>　　用于<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>的和求值关联的隐式上下文是<em>互操作上下文(interoperation context)</em> 。</p>
<p>　　除非派生实现另行指定，语言不提供访问互操作上下文的公开接口。</p>
<p><strong>注释</strong></p>
<p>　　一个典型的实例：由 <a href="Features/NPL.zh-CN.html#%E8%A1%A5%E5%85%85%E9%A2%86%E5%9F%9F%E5%AE%9A%E4%B9%89">ISA</a>约定的通用架构寄存器的状态，可能需要在<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>或任务切换过程中保存和重置。</p>
<h2 id="类型"><a class="header" href="#类型">类型</a></h2>
<p>　　<em>类型(type)</em> 是上下文中和特定的实体直接关联或间接关联的元素，满足<a href="Features/NPL.zh-CN.html#%E9%98%B6%E6%AE%B5%E4%B8%8D%E5%8F%98%E9%87%8F%E7%BA%A6%E6%9D%9F">某个执行阶段的不变量约束</a>。</p>
<p>　　<em>类型规则(type rule)</em> 是和类型相关的对象语言的语义规则。</p>
<p>　　实体关联的类型可能被显式地指定，或通过隐式的限定规则推断确定。符合指定和限定要求的类型可有任意多个。</p>
<p>　　实体的类型是被显式指定的实体关联的类型。实体具有实体的类型以及通过其它规则限定的类型。实体是类型的<em>实例(instance)</em> 。</p>
<p>　　类型可用集合<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>。集合的元素是具有其表示的类型的实体。</p>
<p>　　表示类型的集合为空时，表示类型没有实例，是<em>空类型(empty type)</em> 。</p>
<p>　　推论：由集合的形式表达，空类型是唯一的。</p>
<p>　　表示类型的集合只有一个元素时，类型只有一个不可区分的实例，这样的类型是<em>单元类型(unit type)</em> 。</p>
<p>　　和表达式直接关联的类型满足起始阶段不变量约束，称为<em>静态类型(static type)</em> 。</p>
<p>　　和表达式的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>关联的类型满足<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">运行阶段</a>的不变量约束，称为<em>动态类型(dynamic type)</em> 。</p>
<p>　　其它可能存在类型或实现执行阶段的扩展由派生实现定义。</p>
<p>　　除非另行指定，对象的类型是<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">对象的值</a>的类型。</p>
<p>　　NPL 对象类型和<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">存储的值</a>的类型之间的关联未指定。</p>
<p>　　类型在描述类型规则的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>中可作为对象。</p>
<p>　　生成对象的元语言函数是<em>类型构造器(type constructor)</em> 。类型构造器的参数是类型，的函数值是组合这些参数得到的<em>复合类型(compound type)</em> 。</p>
<h3 id="类型系统和类型机制"><a class="header" href="#类型系统和类型机制">类型系统和类型机制</a></h3>
<p>　　称为类型的具体实体和之间的关联由派生实现的<em>类型系统(type system)</em> 规则指定。</p>
<p>　　默认类型系统不附加约束，所有表达式或关联的项都<em>没有指定类型(untyped)</em> ，为退化的<em>平凡类型系统(trivial type system)</em> 或<em>单一类型系统(unityped system)</em> ，实质上是动态类型。</p>
<p>　　对类型系统的分类中，类型也指确定类型的过程称为<em>类型机制(typing discipline)</em> ，其中确定类型的过程称为<em>定型(typing)</em> 。</p>
<p>　　在静态类型之后阶段确定的类型机制是<em>动态定型(dynamic typing)</em> 。</p>
<p>　　除非另行指定，被确定的静态类型的阶段是翻译时阶段；被确定的动态类型的阶段是翻译时之后，即<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">运行时</a>。</p>
<p>　　语言可提供<a href="https://en.wikipedia.org/wiki/Typing_rule">定型规则(typing rule) (en-US)</a> ，指定<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>作为实体在特定的<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87">上下文</a>（称为<em>类型环境(typing environment)</em> ）中的类型。项是类型在这个上下文中的<em>居留(inhabitant)</em> 。</p>
<p>　　类型环境确定<em>类型指派(type assignment)</em> ，即项和类型的之间的<em>定型关系(typing relation)</em> 。定型确定的这种定型关系的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">实例</a>即<em>定型判断(typing judgement)</em> 。</p>
<p>　　不违反类型系统规则下的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">良定义的</a>程序构造是<em>良型的(well-typed)</em> 。</p>
<p>　　根据是否要求项首先都是良型的再指派语义，带有类型的形式系统可具有<a href="https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus#Intrinsic_vs._extrinsic_interpretations"><em>内在(intrinsic)</em> 和<em>外在(extrinsic)</em> 的解释</a>。</p>
<p>　　除非另行指定，NPL 使用外在的解释。</p>
<p><strong>原理</strong></p>
<p>　　默认使用外在解释的理由是：</p>
<ul>
<li>类型的外在解释允许在一个没有指定具体类型系统设计的单一类型系统为基础扩展不同的类型系统，能满足语言自身<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">可扩展</a>的需要。
<ul>
<li>扩展通用目的语言特性的顺序应是从简单到复杂的，而不是相反，因为并不存在已知的万能语言可供裁剪。</li>
<li>这也符合历史顺序：无类型 λ 演算被扩展到不同的有类型 λ 演算，而不是相反；因为有类型 λ 演算的规则明显较无类型 λ 演算多且复杂。</li>
<li>从无类型 λ 演算可以扩展到的一些特性更丰富其它系统，如 <a href="https://en.wikipedia.org/wiki/Lambda-mu_calculus">λμ 演算 (en-US)</a> 和 vau 演算，首先都是无类型的，并不存在可用的内在解释。</li>
</ul>
</li>
<li>为了描述类型规则，外在解释最终需要在整个系统中引入和对象语言不同的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>，而增加复杂性。
<ul>
<li>即便存在强调可扩展的对象语言（如 <a href="https://arxiv.org/abs/0910.2654">MLPolyR</a>），至少语言规范中定义的元语言没有被证明可以和被描述类型规则的对象语言合并。</li>
<li>即便能证明可以合并，这种方式也显著地大大增加了设计的复杂性，违反<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>。</li>
<li>根本上，这种方式损害对象语言设计的<em>光滑性(smoothness)</em> ([Shu10] §1.1.2) ，很可能大大削弱对象语言的<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>。</li>
</ul>
</li>
<li>没有确切的充分依据证明引入类型系统带来的性质是通过非类型论的直接扩展演绎系统的方式不能实现或者其实现有现实困难的。
<ul>
<li>因此先验地要求类型的存在缺乏必要性。即便可实现需求，在通用目的上通常是舍近求远的过度设计。</li>
<li>即便引入类型的方式有现成的工程实践而可以提升工程效率，也可能是<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E6%88%90%E7%86%9F%E7%9A%84%E4%BC%98%E5%8C%96">过早的优化</a>。</li>
<li>更何况现实并没有证据表明存在这样的成功实践。</li>
</ul>
</li>
<li>跳出先验地引入类型的做法，使用先验的内在解释而排除不够清晰明确的含义(meaning) 的语法的方式，在历史上存在更显著的失败。
<ul>
<li>[Chu41] §18 试图排除原始的 λ 演算（称为 λ-K-转换，在 [Bare84][Shu10] 中称为 λ<em>K</em> 演算）中无法取得<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">范式</a>的项（以使之更适用于符号逻辑的目的）：限制 λ 抽象中的约束变量是第二子项的自由变量。
<ul>
<li>非正式地，这在语法上要求每个<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数体</a>中的每个<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">变量</a>必须是某个唯一的函数的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">形式参数</a>，且这个函数的函数体是语法上包含这个变量的表达式，即语言在语法上禁止出现（在声明以外）未使用的形式参数。</li>
<li>限制的 λ 演算在现代（如 [Bare84][Shu10] ）称为 λ<em>I</em> 演算，不支持表达 <a href="https://zh.wikipedia.org/zh-cn/%E7%BB%84%E5%90%88%E5%AD%90%E9%80%BB%E8%BE%91">K 组合子</a>。</li>
</ul>
</li>
<li>[Bare84] §2.2 指出 λ<em>I</em> 演算具有的一些问题，如：
<ul>
<li>对应的理论 <strong>λ<em>I</em></strong> 翻译到<a href="https://zh.wikipedia.org/zh-cn/%E7%BB%84%E5%90%88%E5%AD%90%E9%80%BB%E8%BE%91">组合子逻辑</a>的理论 <strong>CL</strong> 时，项能取得<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">范式</a>的性质不被保持。</li>
<li>范式的概念过于侧重语法，所以在<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">模型</a>中不确定含义。</li>
<li>试图识别编码<a href="https://en.wikipedia.org/wiki/Partial_function">偏函数(partial function) (en-US)</a> 需要的“未定义”的项是不可能的。</li>
<li>λ<em>I</em> 演算定义的偏函数的组合对应的项不一定是 λ<em>I</em> 演算定义的被组合的偏函数的项的组合。</li>
</ul>
</li>
<li>[Bare84] §2.2 指出，这些问题都来自 [Chu41] 选择用无法取得范式的项编码“未定义”的概念。
<ul>
<li>定义可解性(solvability) ，以不可解代替不能取得范式编码“未定义”可解决这个问题。
<ul>
<li>项的可解性定义为存在有限的项序列使前者在后者顺序应用得到 <a href="https://zh.wikipedia.org/zh-cn/%E7%BB%84%E5%90%88%E5%AD%90%E9%80%BB%E8%BE%91">I 组合子</a>（即 λ<em>x</em>.<em>x</em> ）。</li>
</ul>
</li>
<li>在 λ<em>I</em> 演算中，不可解等价不能取得范式。而在 λ 演算中，不可解等价不能取得 <a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">HNF</a> 。</li>
<li>λ 演算没有 λ<em>I</em> 演算的上述问题。</li>
<li>λ<em>I</em> 表述的 Church–Turing 论题仅限于<a href="Features/NPL.zh-CN.html#%E7%BB%88%E6%AD%A2%E4%BF%9D%E8%AF%81">全函数</a>，而 λ 函数表述的论题能扩展到一般形式的偏函数。</li>
</ul>
</li>
<li>即便不考虑上述整体性质，尽管计算上 λ<em>I</em> 演算是 <a href="Features/NPL.zh-CN.html#%E5%AE%8C%E6%95%B4%E6%80%A7">Turing 完备</a>的，它不能编码<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">常量</a>函数。
<ul>
<li>因为也不包含<a href="Features/NPL.zh-CN.html#%E7%AE%A1%E7%90%86%E8%A7%84%E7%BA%A6">管理规约</a>规则，它实际上无法编码<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察性质的项</a>，除非平凡地指定所有项都是可观察的。</li>
</ul>
</li>
<li>以上问题一定程度上揭示了去除似乎冗余但实际在语义上可能非平凡的语法构造是<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E6%88%90%E7%86%9F%E7%9A%84%E4%BC%98%E5%8C%96">不成熟的简化</a>，损害系统的<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>。</li>
<li>要求（可被类型检查的）类型系统直接排除不能取得范式的项，在这个意义上比 λ<em>I</em> 演算对去除特定的项的组合更彻底。
<ul>
<li>即便类型系统能引入其它语义，这以引入不能被对象语言表达的规则为代价，通常需要元语言。</li>
<li>相比之下，同样是引入对象语言表达式无法表达的语义，管理规约是对象语言规则能直接蕴含的，相对具有更小的（工作量和避免兼容问题上的）代价。</li>
</ul>
</li>
<li><strong>注释</strong> 内在解释又被称为 Church 风格的。</li>
</ul>
</li>
<li>哲学意义上，内在解释或本体论上的(ontological) 解释，相比外在解释或语义上的(semantical) 解释需要更强的假设。
<ul>
<li>本体论上的逻辑，如 <a href="https://en.wikipedia.org/wiki/Frege%E2%80%93Church_ontology">Frege-Church 本体论 (en-US)</a>，可能解决一些悖论。</li>
<li>但根本上，没有充分动机指出，不涉及<a href="Features/NPL.zh-CN.html#%E6%BC%94%E7%BB%8E%E8%A7%84%E5%88%99">演绎规则</a>的悖论必须在通用语言内部直接提供规则消除，而不能通过其它方式（例如，由<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>补充前提）解决。
<ul>
<li>指定管理规约可以编码非平凡的表达语言规则外的语义的项可以对这样的前提建模并在语言中适当编码表达。</li>
<li>编码表达这种方式是 NPL 强调 <a href="Features/NPL.zh-CN.html#%E8%AF%8D%E6%B3%95%E8%A7%84%E5%88%99">N(name)</a> 和其它实体分离的主要理由。</li>
</ul>
</li>
<li>本体论假设要求名称以外附加实体以使假设生效。一般地，这些假设以不同语言的陈述作为断言实现。这些陈述涉及特称对象时，在完备性上是可疑的，且容易和<a href="Features/NPL.zh-CN.html#%E5%BC%80%E6%94%BE%E6%80%A7">开放世界假定</a>冲突。</li>
<li>约定不涉及的语言规则的本体论假设在这些意义上也可被认为在效用上的<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E6%88%90%E7%86%9F%E7%9A%84%E4%BC%98%E5%8C%96">不成熟的优化</a>。</li>
</ul>
</li>
</ul>
<p><strong>注释</strong></p>
<p>　　在元语言的意义上，类型系统包含语法和对应的语义，但在对象语言中，定型规则和其它推理规则（如<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>规则）作为语言规则是语义规则，和语法相对独立。</p>
<p>　　实体的类型可被指定为未指定类型，以明确类型的存在性，但不明确具体的类型的构造和表示。</p>
<p>　　形式地，在类型系统中，类型环境和项作为前提，通过定型规则(typing rule) 得到定型判断。定型规则在逻辑上可以是公理或定理。</p>
<p>　　在数理逻辑中，使用结构主义数学方法，集合可以作为描述类型规则的理论（句子集合）的模型，和理论支持描述的类型一一对应。</p>
<h3 id="类型等价性"><a class="header" href="#类型等价性">类型等价性</a></h3>
<p>　　通过显式指定标识（如名称）的方式定义类型的方法是<em>名义类型(nominal typing)</em> ，否则是<em>结构化类型(structrual typing)</em> 。</p>
<p>　　除非另行指定，不同的名义类型不蕴含等价关系。结构化类型之间的等价关系由实现定义。</p>
<p>　　类型的相等关系是一种类型之间的等价关系。两个类型相等，当且仅当它们的实例作为元素的两个集合对应相等。</p>
<p>　　除非另行指定，相等的类型不在语言中区分，且元语言（描述对象语言的规则）中类型作为实体的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>即类型相等性。</p>
<p>　　推论：除非另行指定，不同的类型不等价。</p>
<p>　　除非另行指定，对象语言使用类型相等性实现类型等价性。</p>
<p><strong>原理</strong></p>
<p>　　对象语言中的类型实质上是类型的一种间接的表示，作为实体仍然可以具有不同的同一性。</p>
<p>　　这避免程序可能需要枚举类型的外延（即精确实现出表示它的集合）才能确保确切表示出这个类型这样的计算上不可行的困难。</p>
<p>　　因为可支持的表示的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%85%A8%E9%9B%86">类型全集</a>不同，类型相等是相对的，依赖类型系统的具体实现。一个类型系统可能支持无法在另一个类型系统中精确表示的类型。</p>
<p><strong>注释</strong></p>
<p>　　本节的主要例外参见<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%BA%8F">公共子类型</a>。</p>
<h3 id="类型标注"><a class="header" href="#类型标注">类型标注</a></h3>
<p>　　根据是否需要特定的文法元素指定和项关联的类型即<em>类型标注(type annotation)</em> ，对确定类型的机制可进行分类。</p>
<p>　　类型系统可使用<em>显式类型(explicit typing)</em> ，即在<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">定型</a>时要求类型标注。</p>
<p>　　不使用类型标注的方式是<em>隐式类型(implicit typing)</em> 。</p>
<p>　　在引入实体（特别地，如<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">变量</a>）时指定实体的显式类型标注称为<em>清单类型(manifest typing)</em> 。</p>
<p>　　不使用清单类型而使隐式引入的实体（如值）关联具体类型的机制称为<em>潜在类型(latent typing)</em> 。</p>
<p>　　清单类型是显式类型的实例；除此之外，显式类型还包括<em>铸型(casting)</em> ，即显式指定表达式求值的结果应具有的类型。</p>
<p>　　潜在类型是隐式类型的实例；除此之外，隐式类型还包括<em>类型推断(type interferece)</em> ，即通过隐含的上下文信息判断表达式关联的类型。</p>
<p>　　若类型机制可保证在某个<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">执行阶段</a>内有确定<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">强规范化性质</a>的算法确定类型，则类型机制在该阶段是<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态定型</a>。</p>
<p><strong>注释</strong> 强规范化性质的算法保证终止。</p>
<p>　　语言可能个别指定引入这些类型相关的规则，在保持逻辑相容的前提下可混合使用。</p>
<p>　　显式类型可编码接口的要求，即<em>类型签名(type signature)</em> 。</p>
<p>　　类型签名通常直接指定<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义类型</a>，但同时也可允许非特定的满足结构类型约束的类型。这些类型和类型签名<em>兼容(compatible)</em> 。</p>
<p><strong>原理</strong></p>
<p>　　历史上，表达式的类型和变量的类型在<a href="Features/NPL.zh-CN.html#%CE%BB-%E5%AE%8C%E5%A4%87%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AF%B9%E5%BA%94%E8%AF%AD%E6%B3%95">简单类型 λ 演算</a>中同时被引入。后者修饰 λ 抽象中的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">自由变量</a>，而前者限定剩余的所有项。</p>
<p>　　即便从<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项重写系统</a>中两者是形式上统一的，在实际语用中具有很不同的差异。这集中体现在后者是<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义的</a>，除非附加其它不同的语法设施，并不具有结构化推导的性质，原则上只适合描述接口；而前者能兼容<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">结构化类型</a>，同时适合描述接口及其实现。</p>
<p>　　作为接口的名义类型在作为自由变量以外的上下文中重新复用为不关心其类型（并消除依赖这些信息的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">其它机制</a>）的其它程序构造（一般意义上的表达式），通常需要类型擦除等更复杂的机制和支持的类型系统规则，以消去不再预期和其它类型系统规则交互的类型。</p>
<p>　　和 [R<sup>n</sup>RK] 类似，NPL 不要求使用清单类型，以避免一些一般意义上的全局设计缺陷。这些缺陷包括：</p>
<ul>
<li>过于积极地（非预期地）排除危险但对程序有用的使用，而违反<a href="Features/NPL.zh-CN.html#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测性</a>。</li>
<li>因为移除类型标注需要上述的复杂机制和类型系统规则，具体的清单类型阻碍派生语言定义其它不容易冲突的类型标注规则而使语言具有更好的<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">可扩展性</a>。</li>
<li>因为名义类型的相关规则更容易直接拒绝一些和类型规则不兼容的程序构造而难以简单地变通，往往对程序构造的组合具有更多直接的<a href="Features/NPL.zh-CN.html#%E5%AE%8C%E6%95%B4%E6%80%A7">可表达性</a>限制而破坏通用计算意义上的<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>。
<ul>
<li><strong>注释</strong> 例如，许多类型系统不允许表达 <a href="https://zh.wikipedia.org/zh-cn/%E4%B8%8D%E5%8A%A8%E7%82%B9%E7%BB%84%E5%90%88%E5%AD%90#Y%E7%BB%84%E5%90%88%E5%AD%90">Y 组合子</a>的构造<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">良型</a>。</li>
</ul>
</li>
</ul>
<p>　　若有必要，派生语言仍可限定使用清单类型。一般仍然建议仅在局部引入而避免全局复杂性和因此带来的限制。</p>
<p><strong>注释</strong></p>
<p>　　类型签名来自数理逻辑术语。</p>
<h3 id="类型检查"><a class="header" href="#类型检查">类型检查</a></h3>
<p>　　<em>类型检查(typechecking)</em> 解答程序是否满足类型规则的判定性问题。</p>
<p>　　使用<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">翻译时</a>的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">语义分析</a>或<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">运行时</a>的类型检查分别为静态类型检查和动态类型检查。</p>
<p>　　静态类型检查规则是<a href="Features/NPL.zh-CN.html#%E7%BF%BB%E8%AF%91%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%A7%84%E5%88%99">可诊断语义规则</a>。</p>
<p>　　语言可能个别指定引入类型检查相关的规则，在保持逻辑相容的前提下可混合使用。</p>
<p>　　类型检查失败引起的<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">错误</a>称为<em>类型错误(type error)</em> 。</p>
<p><strong>注释</strong></p>
<p>　　注意静态类型检查和<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态定型</a>以及动态类型检查和<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">动态定型</a>的区别。类型检查和类型机制是不同的规则，不必然包含蕴含关系。</p>
<p>　　类型检查的一个典型的使用场景是<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">类型签名的兼容性</a>校验。</p>
<h3 id="类型全集"><a class="header" href="#类型全集">类型全集</a></h3>
<p>　　<em>类型全集(type universe)</em> 是语言规则中允许表达的类型的总称。</p>
<p><strong>注释</strong> 表达类型的规则构成的模型的语言是语言规则的子集。</p>
<p>　　NPL 避免限定类型全集。派生语言可指定不同的规则。</p>
<p>　　除非派生实现另行指定，程序的用户不能依赖语言规则的限定枚举类型全集中的所有类型。</p>
<p><strong>原理</strong></p>
<p>　　类型全集是<a href="Features/NPL.zh-CN.html#%E5%BC%80%E6%94%BE%E6%80%A7">论域</a>的实例。避免限定类型全集符合<a href="Features/NPL.zh-CN.html#%E5%BC%80%E6%94%BE%E6%80%A7">开放世界假定</a>。</p>
<h4 id="类型谓词"><a class="header" href="#类型谓词">类型谓词</a></h4>
<p>　　判断值是否满足类型<em>居留(inhabitant)</em> 的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">谓词</a>是<em>类型谓词(type predicate)</em> 。</p>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RK] 的基本类型谓词不同，类型谓词定义为只接受一个参数。</p>
<h3 id="类型序"><a class="header" href="#类型序">类型序</a></h3>
<p>　　类型之间可具有序关系。</p>
<p>　　被<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">定型</a>的类型的实体可完全地满足其它类型的约束。前者具有后者的<em>子类型(subtype)</em> 。</p>
<p>　　<em>子类型(subtyping)</em> 关系是一种<a href="https://zh.wikipedia.org/zh-cn/%E9%A2%84%E5%BA%8F%E5%85%B3%E7%B3%BB">预序(preorder) 关系</a>，即自反的、反对称的二元关系。</p>
<p>　　相等的类型符合子类型关系，是<em>平凡的(trivial)</em> 。排除平凡的子类型关系是严格子类型关系。</p>
<p>　　严格子类型是严格预序关系，即反自反、反对称的二元关系。</p>
<p>　　子类型和严格子类型对应的逆关系是<em>超类型(super typing)</em> 和<em>严格超类型(strict supertyping)</em> 关系。</p>
<p>　　多个类型可具有公共的（严格）超类型。这些类型同为一个类型的子类型而<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">等价</a>。</p>
<p>　　除非另行指定，在程序的行为不依赖其中特定的个别不相等的类型而具有差异时，具有相等超类型的等价的子类型视为相同的类型。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">复合类型</a>中其中一部分的类型替换为其子类型，得到的结果和原复合类型可能有如下<a href="https://zh.wikipedia.org/zh-cn/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98#%E5%BD%A2%E5%BC%8F%E5%AE%9A%E4%B9%89">变化(variance)</a> 的对应关系之一：</p>
<ul>
<li><em>协变(covariant)</em> ：类型序被保持，即结果类型是原复合类型的子类型。</li>
<li><em>逆变(contravariant)</em> ：类型序的逆被保持，即结果类型是原复合类型的超类型。</li>
<li><em>不变(invariant)</em> ：不保持类型序，即结果类型和原复合类型之间没有确定的子类型关系。</li>
</ul>
<p>　　同时存在以下派生归类：</p>
<ul>
<li><em>互变(bivariant)</em> ：同时协变和逆变。</li>
<li><em>可变(variant)</em> ：至少协变或逆变之一。</li>
</ul>
<p>　　对接受参数类型得到结果类型的函数<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型构造器</a> → ，以下关系是确定的：</p>
<ul>
<li>参数类型对函数类型逆变。</li>
<li>结果类型对函数类型协变。</li>
</ul>
<p>　　把<a href="Features/NPL.zh-CN.html#%E5%B0%81%E8%A3%85">LSP</a>要求子类型经替换前后保持性质的谓词视为类型构造器，则 LSP 要求的性质是协变的。</p>
<p><strong>注释</strong></p>
<p>　　关于 → 的变化关系的陈述通常直接被作为类型系统中的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">定型规则</a>表达的公理，以和 → 既有的定型规则兼容。</p>
<p>　　一些非普遍的局部类型序的构造器，如数组的下标 <code>[]</code> ，也可对参数有确定的可变关系。</p>
<p>　　在 LSP 的<a href="https://www.cs.cmu.edu/~wing/publications/LiskovWing94.pdf">原始论文</a>提供了两个满足 LSP（文中称为子类型要求(subtype requirement) ）的在<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">过程</a>的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">签名</a>定义子类型的方法，兼容以上传统的函数类型构造器的子类型变化关系，是 → 上的上述关系的扩展：这些定义还支持表达过程的具体前置条件(precondition) 和其中引发的<a href="Features/NPL.zh-CN.html#%E5%BC%82%E5%B8%B8">异常</a>。</p>
<p>　　对一般的谓词，LSP 的行为多态(behavioral polymorphism) 是不可判定的。因此，一般的 LSP 无法被<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>。在<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">类型系统</a>中应用 LSP 需依赖具体能表达性质的谓词，如使用的类型构造器。</p>
<h2 id="程序的控制执行条件"><a class="header" href="#程序的控制执行条件">程序的控制执行条件</a></h2>
<p>　　程序的执行可被<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制作用</a>影响。蕴含这些影响的条件即<em>执行条件(execution condition)</em> 。</p>
<p>　　程序的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制状态</a>决定<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>使用的<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6">续延</a>。</p>
<p><strong>注释</strong> 这和<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">过程的调用</a>类似。</p>
<p>　　更一般地，规约规则指定语言的实现决定程序行为时使用的（对程序不保证可见的）续延，这种在实现中对应的控制状态称为控制执行条件。</p>
<p>　　和控制状态不同，控制执行条件描述语言提供的不同控制机制的分类，而不被作为语言可编程的特性提供。</p>
<p>　　除非另行指定，仅由<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>中蕴含的规约规则决定的执行条件是<em>正常(normal)</em> 的。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">合并子调用以当前续延返回</a>是正常执行的。</p>
<p><strong>注释</strong> 这是正常控制执行条件的一个主要实例。</p>
<p>　　改变程序的正常的控制要求存在控制作用，此时，控制执行条件是<em>非正常(abnormal)</em> 的。</p>
<p>　　除非另行指定，隐含在求值算法中蕴含的规约规则确定的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数应用</a>外的<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延调用</a>是非正常的。</p>
<p><strong>注释</strong> 这是非正常控制执行条件的一个主要实例。</p>
<p>　　具有规约语义的语言总是支持正常控制条件。NPL 中，非正常的控制条件的支持是可选的。</p>
<h3 id="异常"><a class="header" href="#异常">异常</a></h3>
<p>　　由派生实现定义的非正常的控制条件是<em>异常(exceptional)</em> 条件。</p>
<p>　　<em>异常(excpetion)</em> 是通过<em>抛出(throw)</em> 实体（称为异常实体）同时表达满足异常条件的控制作用的语言构造。</p>
<p>　　语言的实现或用户通过特定操作（如求值一个表达式）指定程序满足异常条件，使程序的控制进入<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">异常执行状态</a>，允许程序具有正常条件下可分辨不同行为。</p>
<p>　　程序通过<em>捕获(catch)</em> 并<em>处理(handle)</em> 被抛出的实体，程序可满足不同的恢复正常执行的条件。</p>
<p>　　进入违反<a href="Features/NPL.zh-CN.html#%E7%BF%BB%E8%AF%91%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%A7%84%E5%88%99">翻译时正确性规则</a>的异常执行状态时，由语言实现提供的异常执行机制实现行为。</p>
<p><strong>注释</strong> 这些行为至少蕴含满足翻译时正确性规则要求的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">诊断</a>。</p>
<p>　　进入其它异常执行状态的异常条件包括所有<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">运行时</a>异常条件和直接引起程序异常的用户操作。</p>
<p>　　这些异常条件的具体行为和正常条件下的不同由派生实现指定的运行时状态或直接引起异常（改变程序的控制）或语言构造的语义决定。此时，由实现定义使用的异常执行机制。</p>
<p><strong>注释</strong> 其它异常条件的异常执行机制可能和上述相同或不同。</p>
<p>　　派生语言实现可指定以下规则：</p>
<ul>
<li>符合以上约定的判断改变（进入和退出）异常执行状态的执行机制。</li>
<li>包括抛出和捕获的语言构造和其它可选的引起改变异常条件的上下文。</li>
</ul>
<p>　　若派生实现不指定以上要求的执行机制和上下文，则不支持异常。</p>
<p>　　除非派生实现另行指定，异常的控制作用总是<em>同步(synchronized)</em> 的，即：</p>
<ul>
<li>在初始化异常实体时，保证存在与异常条件关联且可确定单一的<a href="Features/NPL.zh-CN.html#%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0">执行线程</a>的状态作为引起控制状态改变即引发异常的来源。</li>
<li>异常条件的满足不依赖未和引发异常状态同步的程序中的其它的执行状态（包括其它未同步的线程的状态）。</li>
<li>确认满足异常条件和进入异常执行状态之间，上述执行线程内程序仅在引发异常的线程上的程序允许存在<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">计算作用</a>（这保证不被引起可观察行为改变的其它线程的操作中断）。</li>
</ul>
<p>　　除非派生实现另行指定，未捕获的异常总是确定性地(deterministically) 持续引发异常的执行线程中引起控制的转移：</p>
<ul>
<li>若捕获操作有效的上下文，控制转移捕获构造处理对应异常的<em>异常处理器(exception handler)</em> 。</li>
<li>否则，若在活动函数调用中，则单向地从<a href="Features/NPL.zh-CN.html#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">当前活动的函数</a>向其<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">主调函数</a>转移控制，使后者活动。</li>
<li>否则，若没有找到剩余的活动函数调用，则程序异常终止。</li>
</ul>
<p>　　除非派生实现另行指定，上述转移活动函数若成功（包括异常在活动的主调函数嵌套的特定语言构造中被捕获），先前不再活动的活动记录中的资源在控制成功转移后应立即被释放。</p>
<p>　　典型的设计中，求值规则使的正常状态的函数调用要求的活动记录分配和释放满足 FIFO（Last-In First-Out ，后入先出）的顺序，构成了<em>栈(stack)</em> ，活动记录是<em>栈帧(stack frame)</em> 。</p>
<p>　　除非派生实现另行指定，活动函数的转移释放资源，应保证按和创建被其所有的实体的顺序的相反顺序一致的形式释放。这种释放活动记录占用资源的机制称为<em>栈展开(stack unwinding)</em> 。</p>
<h3 id="终止保证"><a class="header" href="#终止保证">终止保证</a></h3>
<p>　　特定的求值具有（确定性地）<em>终止(termination)</em> 保证，当且仅当预期求值总是在有限计算步骤内可描述的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">计算作用</a>。</p>
<p>　　具有终止保证的求值总是取得值或通过非正常控制的计算作用退出求值。</p>
<p>　　不具有终止保证的求值可能不终止，此时它具有取得值以外的计算作用；这种计算作用是<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>。</p>
<p>　　若一个函数的调用总是具有终止保证，则此函数是<em>终止函数(terminating function)</em> 。</p>
<p>　　若一个函数的调用总是取得值，则此函数是<em>全函数(total function)</em> 。</p>
<p><strong>注释</strong> 全函数总是终止函数。</p>
<h1 id="npla"><a class="header" href="#npla">NPLA</a></h1>
<p>　　当前维护的主要派生语言为 <strong>NPLA</strong> ，是 NPL 的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">抽象语言实现</a>和<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">派生实现</a>。</p>
<p>　　NPLA 的参照实现 <a href="Features/NPL.zh-CN.html#npla1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80">NPLA1</a> 是具体语言实现，约定特定于当前参照实现的附加规则和实现。</p>
<p>　　作为原型设计，NPLA 重视可扩展性。</p>
<p>　　作为 NPL 的派生实现，NPLA <a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>的设计遵循 NPL <a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E6%A8%A1%E5%9E%8B">符合性规则</a>，并满足如下要求或附加限制。</p>
<p><strong>注释</strong></p>
<p>　　<a href="Features/NPL.zh-CN.html#npla1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80">NPLA1</a> 是 NPLA 的一个派生实现。</p>
<h2 id="npla-领域语义支持"><a class="header" href="#npla-领域语义支持">NPLA 领域语义支持</a></h2>
<ul>
<li>位(bit) ：表示二进制存储的最小单位，具有 0 和 1 两种状态。</li>
<li>字节(byte) ：<a href="Features/NPL.zh-CN.html#%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2">基本字符集</a>中一个字符需要的最少的存储空间，是若干位的有序集合。</li>
<li>八元组(octet) ：8 个位的有序集合。</li>
</ul>
<h2 id="npla-整体约定"><a class="header" href="#npla-整体约定">NPLA 整体约定</a></h2>
<h3 id="npla-实现环境"><a class="header" href="#npla-实现环境">NPLA 实现环境</a></h3>
<p>　　NPLA 使用<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>为 [ISO C++11]（及其之后的向前兼容的版本）的简单实现模型 <a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">NPL-EMA</a> 。</p>
<p>　　一<a href="Features/NPL.zh-CN.html#npla-%E9%A2%86%E5%9F%9F%E8%AF%AD%E4%B9%89%E6%94%AF%E6%8C%81">字节</a>占用的位和<a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>一致（至少占用 8 个二进制位）。</p>
<p>　　除非另行指定，NPLA 使用宿主语言提供的异常作为<a href="Features/NPL.zh-CN.html#%E5%BC%82%E5%B8%B8">异常执行机制</a>。</p>
<h3 id="附加功能"><a class="header" href="#附加功能">附加功能</a></h3>
<p>　　NPLA 支持<em>数值(numerical value)</em> ，但不要求支持具体的数值计算。</p>
<p>　　NPLA 实现为派生实现提供<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">数值类型</a>和相关的操作的基本支持。</p>
<p>　　除非另行指定，若派生实现支持数值计算，其实现兼容 <a href="Features/NPL.zh-CN.html#npla-%E6%95%B0%E5%AD%A6%E5%8A%9F%E8%83%BD">NPLA 数学功能</a>的实现。</p>
<h3 id="npla-词法和语法"><a class="header" href="#npla-词法和语法">NPLA 词法和语法</a></h3>
<p>　　词法分析可接受多字节文本编码的字符串形式的源代码，但不假设其编码中除 0（空字符 NUL ）以外的具体代码点被编码的数值，不<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">转换编码</a>。</p>
<p>　　使用可选的语法预处理和 <a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">NPL-GA 语法</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2">字符集</a>的约定同<a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>。</p>
<h3 id="npla-标识符"><a class="header" href="#npla-标识符">NPLA 标识符</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">NPL 标识符</a>外的以下<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">词素</a>也是 NPLA 标识符：</p>
<ul>
<li>在构成 NPL 标识符的词素中插入有限个非 <a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">NPL 分隔符</a>的字符且不构成 <a href="Features/NPL.zh-CN.html#npla-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F">NPLA 扩展字面量</a>的词素。</li>
<li>全由 <code>+</code> 或 <code>-</code> 构成的词素。</li>
</ul>
<h3 id="npla-扩展字面量"><a class="header" href="#npla-扩展字面量">NPLA 扩展字面量</a></h3>
<p>　　NPLA <a href="Features/NPL.zh-CN.html#%E5%AD%97%E9%9D%A2%E9%87%8F">扩展字面量</a>包括：</p>
<ul>
<li>以 <code>#</code> 、<code>+</code> 或 <code>-</code> 起始的但不全是 <code>+</code> 或 <code>-</code> 构成的、长度大于 1 的词素。</li>
<li>十进制数字字符起始的词素（当被支持时）。</li>
</ul>
<p>　　全由十进制数字字符的词素表示十进制<a href="Features/NPL.zh-CN.html#%E9%99%84%E5%8A%A0%E5%8A%9F%E8%83%BD">数值</a>。派生实现可定义其它作为数值的词素。这些词素作为字面量时，是<em>数值字面量(numerical literal)</em> 。</p>
<h3 id="npla-名称和字面量求值"><a class="header" href="#npla-名称和字面量求值">NPLA 名称和字面量求值</a></h3>
<p>　　名称仅被实现为和<a href="Features/NPL.zh-CN.html#%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>的一个真子集一一对应的表示（参见<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">类型映射</a>）。</p>
<p>　　除非派生实现另行指定，只有<a href="Features/NPL.zh-CN.html#%E5%AD%97%E9%9D%A2%E9%87%8F">代码字面量</a>不是<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">自求值表达式</a>，其余字面量都求值为<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">右值</a>。</p>
<p>　　代码字面量求值时解释为名称。</p>
<p>　　数据字面量是自求值的字符串的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">外部表示</a>。</p>
<p>　　数值字面量是自求值的数值的外部表示。</p>
<p>　　存在不保证先求值的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">子表达式</a>的<a href="Features/NPL.zh-CN.html#%E8%AF%AD%E6%B3%95%E5%BD%A2%E5%BC%8F">语法形式</a>是<em>特殊形式(special form)</em> 。</p>
<p>　　特定的名称是<em>保留名称(reserved name)</em> 。</p>
<p>　　除非另行指定，在<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源代码</a>中使用保留名称作为实体的名称的程序<a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">行为未定义</a>。</p>
<h3 id="npla-求值的表示"><a class="header" href="#npla-求值的表示">NPLA 求值的表示</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">规范形式</a>是特定<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型</a>的 [ISO C++] 对象。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>失败可被忽略而不<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">终止</a>实现演绎；保证名称表达式求值的<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">强规范化</a>。</p>
<p>　　不要求提供<a href="Features/NPL.zh-CN.html#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">命名空间</a>实现的可变实体。</p>
<p>　　不保证求值都是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>；非<a href="Features/NPL.zh-CN.html#npla-%E5%90%8D%E7%A7%B0%E5%92%8C%E5%AD%97%E9%9D%A2%E9%87%8F%E6%B1%82%E5%80%BC">特殊形式</a>使用<a href="Features/NPL.zh-CN.html#%CE%BB-%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">热情求值</a>；其它情形使用热情求值或<a href="Features/NPL.zh-CN.html#%CE%BB-%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">惰性求值</a>的方式由具体特殊形式约定。</p>
<p>　　对象语言的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数</a>默认为<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">过程</a>，过程默认实现为<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E7%9A%84%E8%AE%A1%E7%AE%97%E9%A1%BA%E5%BA%8F">子例程</a>。过程指定的计算结果和函数表达式<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">最终求值结果</a>的<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">关联</a>是<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">过程调用</a>结果的恒等映射。</p>
<p><strong>注释</strong> 即过程调用的结果总是同函数值。</p>
<p>　　除非另行指定，实现<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数</a>的宿主数据结构<a href="Features/NPL.zh-CN.html#npla-%E5%9F%BA%E7%A1%80%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">生存期要求</a>默认同<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>。</p>
<p>　　除非另行指定，<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值传递</a>支持<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96">复制初始化</a>对象的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E4%BD%9C%E7%94%A8">一等作用</a>。</p>
<p><strong>原理</strong></p>
<p>　　NPLA 函数不支持类似 [ISO C++] 的类型退化(decay) 。作为动态类型语言，需要被转换的值在<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作</a>内部实现，不需要在<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>上另行附加转换。</p>
<p>　　按值传递的复制初始化和宿主语言的对应语义类似。</p>
<h3 id="npla-类型系统"><a class="header" href="#npla-类型系统">NPLA 类型系统</a></h3>
<p>　　NPLA 使用<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">隐式类型</a>而非<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">显式类型</a>。</p>
<p>　　NPLA 使用<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">潜在类型</a>：<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>具有类型；不指定<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">动态类型</a>以外的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">显式类型（如清单类型）</a>的机制可由派生实现指定可选地引入。<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>也可能添加类型标注和不同的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">类型机制</a>的支持。</p>
<p>　　除非派生实现另行指定，引入的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态类型</a>应和<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">动态类型</a>一一对应。</p>
<p>　　NPLA 使用和<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>相容的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">动态类型检查</a>。除非派生实现另行指定或<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">类型映射</a>的需要，使用的类型检查规则和宿主语言一致。</p>
<p>　　宿主语言对象的值描述状态，且宿主语言要求的对 <code>volatile</code> 左值的操作属于<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>。</p>
<h2 id="npla-互操作支持"><a class="header" href="#npla-互操作支持">NPLA 互操作支持</a></h2>
<p>　　NPLA 的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>应能提供 NPLA 及派生实现的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">本机实现</a>。</p>
<p>　　NPLA 的派生实现提供特定的和宿主语言的<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>支持，可其中和 NPLA 提供的关于互操作的具体行为不同的部分应由实现定义。</p>
<p><strong>注释</strong> 对派生实现，NPLA 约定的具体默认互操作特性是可选的。但是，一般的约定如<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">开放类型系统</a>仍被要求。</p>
<p>　　NPLA 和派生实现可约定互操作的具体实现的要求，以确保实现的状态可预测。</p>
<p>　　本机实现可以具有 C++ 的实现兼容的二进制接口的函数提供，这些函数称为<em>本机函数(native function)</em> 。</p>
<p>　　本机实现可直接支持本机函数在实现中被调用。若被支持，具体接口由派生实现指定。</p>
<p>　　本机函数作为函数的实现，其调用的求值可具有和非本机的函数一致的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">作用</a>，但不需要具有可被对象语言表达的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数体</a>。</p>
<p>　　为确保函数求值的作用可能保持一致，本机函数应符合和本机函数调用时使用的规约一致的方式使用，即在宿主语言的意义上至少符合以下规约<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">调用约定</a>：</p>
<ul>
<li>被调用时的子项被作为以 <a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">WHNF</a> 形式表示的被调用的表达式使用。</li>
<li>调用后具有项被重写为必要的值以表示<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>。</li>
</ul>
<p>　　本机函数的返回值应能表达任意的非本机函数调用的返回值，即通过求值函数调用中函数体的非本机函数的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>。</p>
<p><strong>注释</strong></p>
<p>　　宿主语言自身的调用约定（通常和实现的 <a href="Features/NPL.zh-CN.html#%E8%A1%A5%E5%85%85%E9%A2%86%E5%9F%9F%E5%AE%9A%E4%B9%89">ISA</a> 相关）作为 C++ 实现自身的 <a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">ABI</a> ，在此是中立的，没有提供特设的支持的要求。</p>
<h3 id="类型映射"><a class="header" href="#类型映射">类型映射</a></h3>
<p>　　<em>类型映射(type mapping)</em> 指定对象语言和宿主语言之间的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%9E%8B">实体类型</a>之间的关系，是前者中的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型</a>到后者中的类型的映射。</p>
<p>　　作为类型映射目标的宿主语言类型或其<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>称为<em>宿主类型(hosted type)</em> 。</p>
<p>　　作为宿主语言类型的宿主类型是典型的。其它宿主类型是非典型的。</p>
<p>　　具有特定<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">动态类型</a>的对象语言的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>在宿主语言具有宿主类型，以宿主语言的值表示，称为<em>宿主值(hosted value)</em> 。</p>
<p>　　在<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>的意义上，宿主值在作为对象语言的值的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>中以<em>宿主对象(hosted object)</em> 的形式被保存并可在宿主语言中访问。</p>
<p>　　对象语言的值被对象语言的实体类型表示蕴含它被映射的宿主类型表示，反之亦然。</p>
<p>　　类型映射可以是非空的多对一、一对多或一一映射。</p>
<p>　　若类型映射是一一映射，其类型等价性同宿主语言的语义规则；否则，由类型的语义规则约定。</p>
<p>　　因需提供与作为宿主语言的 [ISO C++] 的互操作支持，所以明确约定实现中部分实体类型对应的 C++ 类型：</p>
<ul>
<li>用于条件判断的单一值的宿主类型是 <code>bool</code> 。</li>
<li><a href="Features/NPL.zh-CN.html#%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a>的宿主类型都是 <code>string</code> 类型。</li>
<li>和字符串的子集一一对应的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">词素</a>的宿主类型是能映射到 <code>string</code> 的另一种类型。</li>
</ul>
<p><strong>注释</strong> <code>string</code> 是占位符，不要求是和 <a href="https://eel.is/c++draft/string.classes#basic.string">[ISO C++] 的 <code>std::basic_string</code></a> 相关的类型。但一般地，<code>string</code> 类型应具有和 <code>std::string</code> 相近的操作以便实现对象语言语义及支持互操作。</p>
<p>　　推论：字符串和词素可直接比较相等性或排序。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E9%99%84%E5%8A%A0%E5%8A%9F%E8%83%BD">NPLA 数值</a>在对象语言中具有<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">数值类型</a>，具体类型映射未指定，但在 NPLA 数学功能提供可选实现。派生实现可显式扩充或替换定义其它数值类型的类型映射。</p>
<p>　　其它宿主类型<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">由实现定义</a>。具体宿主类型参见以下各节和对象语言类型对应的描述。</p>
<p>　　宿主类型在对应的 C++ <a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 中可能以类型别名的形式引入。</p>
<p><strong>原理</strong></p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">类型系统</a>是<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%85%A8%E9%9B%86">开放</a>的，可能提供不被对象语言支持的宿主语言类型和值。</p>
<p>　　但符合已指定的类型的实体需能被视为同种类型的实体使用，即子类型。</p>
<p><strong>注释</strong></p>
<p>　　非典型的宿主类型可以是特定的宿主类型的值的子集，即便这样的类型不被宿主语言的类型系统直接表示。</p>
<p>　　不被对象语言支持的值的一个例子是实现使用的<em>中间值(thunked value)</em> 。</p>
<p>　　关于中间值、<code>string</code> 类型的具体要求、NPLA 数学功能的规格说明和由实现定义的命名空间，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h2 id="npla-未定义行为"><a class="header" href="#npla-未定义行为">NPLA 未定义行为</a></h2>
<p>　　一般地，NPLA 规则不排除<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未定义行为</a>。其中，<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>的未定义行为是非特定体系结构或其它 [ISO C++] 意义上不可预测或不可移植的行为。</p>
<p>　　除非派生实现另行指定，NPLA 约定仅有具有以下情形的程序引入未定义行为：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>中引起宿主语言的未定义行为或不满足<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">约定的要求</a>而可能引入派生实现定义的未定义行为。</li>
<li><a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>无法提供资源而引起宿主语言的未定义行为（如宿主语言的实现无法提供宿主语言函数调用的自动对象隐式使用的资源）。</li>
<li>违反<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">资源所有权语义</a>约束的操作，包括但不限于：
<ul>
<li>违反<a href="Features/NPL.zh-CN.html#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>的操作。
<ul>
<li><strong>注释</strong> 例如，违反按<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象和关联对象所有权</a>的推论不能确保满足<a href="Features/NPL.zh-CN.html#npla-%E5%9F%BA%E7%A1%80%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">生存期要求</a>的操作。</li>
</ul>
</li>
<li>除非另行指定，构造任意的循环引用。</li>
</ul>
</li>
<li>使用特定的词法构造。</li>
</ul>
<p>　　除非派生实现另行指定，NPLA 约定：</p>
<ul>
<li>若程序的执行蕴含宿主语言中不保证排除未定义行为的操作，执行可包含宿主语言的未定义行为。</li>
<li>否则，非互操作引入的<a href="Features/NPL.zh-CN.html#%E7%AE%A1%E7%90%86%E8%A7%84%E7%BA%A6">管理规约</a>可能存在未定义行为，当且仅当它是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值规约</a>的一部分且求值规约可能存在未定义行为。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　满足<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">错误条件</a>的程序可能<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起错误</a>，也可引起未定义行为而不要求引起错误。这允许减少实现的复杂性。</p>
<p>　　对宿主语言的未定义行为的单独处理允许描述互操作。</p>
<p>　　程序的执行允许宿主语言的未定义行为，同时允许形式上不可靠，但仍可通过宿主的外部环境提供附加保证的实现，而保留可实现性：</p>
<ul>
<li>典型地，宿主语言不保证调用的活动记录总是可用。
<ul>
<li>例如，[ISO C++] 指定程序在自动对象无法分配时具有未定义行为。</li>
<li>这种情形形式上无法排除，但不影响实用（否则，任意 [ISO C++] 程序都是不可移植的）。</li>
</ul>
</li>
<li>实现仍应保守使用资源，以尽可能地避免引起宿主语言的未定义行为。</li>
<li>通过宿主的外部提供附加保证的实现类似保证为<a href="Features/NPL.zh-CN.html#%E5%AE%8C%E6%95%B4%E6%80%A7">完整性</a>的前提下通过加入附加的限制来使设计符合要求。</li>
</ul>
<p>　　对管理规约的约定同时蕴含对 NPLA 实现的要求。这保证未定义行为不会被任意地在对象语言以外被引入。</p>
<p><strong>注释</strong></p>
<p>　　为简化互操作实现，部分 NPLA 未定义行为可能在实现中被检查以预防（尽可能避免）宿主语言的未定义行为，但这种检查不保证完全覆盖所有引起未定义行为的条件，不应预期其行为可移植。</p>
<p>　　关于构造循环引用可能引起的问题，另见<a href="Features/NPL.zh-CN.html#%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F">内存泄漏</a>。</p>
<h3 id="常规宿主资源分配要求"><a class="header" href="#常规宿主资源分配要求">常规宿主资源分配要求</a></h3>
<p>　　一般地，本机实现要求资源分配失败时，引起（可能派生）<code>std::bad_alloc</code> 或另行指定的宿主异常而非宿主语言的未定义行为；但因为宿主语言缺乏保证，可能并非所有宿主语言实现都能保证实现这项特性。</p>
<p>　　实际的实现中非极端条件下（如宿主调用栈接近不可用）通常可支持实现这些行为。</p>
<p>　　宿主语言实现支持时，具有可预期的失败（而 NPLA 或宿主语言的非未定义行为）的 NPLA 实现的要求称为常规宿主资源分配要求。</p>
<h3 id="嵌套调用安全"><a class="header" href="#嵌套调用安全">嵌套调用安全</a></h3>
<p>　　宿主语言的 <a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 提供<em>嵌套调用安全(nested call safety)</em> ，当且仅当：</p>
<p>　　若调用没有宿主语言无法分配资源的未定义行为，则同时避免因宿主语言的嵌套调用<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">深度</a>过大时引起的这样的未定义行为。</p>
<p>　　嵌套调用安全应包括支持可能通过对象语言构造的输入使对应宿主语言的操作中的嵌套调用不保证的情形。</p>
<p>　　对象语言的实现可假定限制避免无限创建<a href="Features/NPL.zh-CN.html#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">活动记录</a>即满足嵌套调用安全的要求。</p>
<p><strong>原理</strong></p>
<p>　　嵌套调用安全允许不限制嵌套深度的可靠的调用，如递归调用。</p>
<p>　　宿主语言实现在宿主语言的<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">尾上下文</a>可能支持<a href="Features/NPL.zh-CN.html#tco-%E5%AE%9E%E7%8E%B0%E7%AD%96%E7%95%A5%E6%A6%82%E8%BF%B0">宿主 TCO</a> 而使递归调用满足嵌套调用安全，但这并不是语言提供的保证，不应在可移植的实现中依赖。</p>
<p>　　[ISO C++] 并没有明确指定关于深度的限制，嵌套调用可能因资源耗尽而引起未定义行为。</p>
<p>　　严格来说，这种未指定深度是可移植性上的缺陷，因为任意小的深度的调用（甚至深度为 1 的非嵌套调用）都可引起未定义行为而不需要遵循任何 [ISO C++] 的要求，却仍然满足实现的<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">符合性</a>。</p>
<p>　　[ISO C] 也有相同的问题。</p>
<p>　　实际实现中，具体深度限制依赖实现。在宿主语言缺乏保证的状况下，添加附加假定对可实现性是必要的。</p>
<p><strong>注释</strong></p>
<p>　　对应宿主语言的操作中的嵌套调用不保证的情形的主要例子是保证<a href="Features/NPL.zh-CN.html#%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%AB%8B">宿主语言中立</a>。</p>
<p>　　非嵌套调用安全的情形在过程嵌套调用深度过大时，可因为宿主语言的存储资源消耗导致的宿主语言实现的未定义行为，典型地包括实现中的<em>栈溢出(stack overflow)</em> 。</p>
<p>　　不限深度的重入不一定引起无限的活动记录的创建：<a href="Features/NPL.zh-CN.html#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C-ptc">尾调用</a>应能保证嵌套调用安全。</p>
<h3 id="npla-并发访问"><a class="header" href="#npla-并发访问">NPLA 并发访问</a></h3>
<p>　　当前所有 NPLA 实现中都没有显式的<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">并发</a>访问控制。</p>
<p>　　一般地，为避免并发访问引起的宿主语言的未定义行为，需要通过本机实现在外部使用不同的资源实例或附加适当的同步。</p>
<h2 id="npla-一等对象类型"><a class="header" href="#npla-一等对象类型">NPLA 一等对象类型</a></h2>
<p>　　除<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">类型映射</a>，NPLA 约定能作为一等对象的类型支持的抽象的类型，作为实现的最小要求的一部分。</p>
<p>　　以下章节扩充 NPLA 的其它类型，这些类型中的一部分可能作为一等对象。</p>
<p>　　基于<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">开放类型系统</a>，派生实现可定义其它类型，不论是否被<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>支持。</p>
<p><strong>原理</strong></p>
<p>　　这些类型在<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>等规则的描述中适用。</p>
<h3 id="有序对"><a class="header" href="#有序对">有序对</a></h3>
<p>　　两个不同对象可作为<em>元素(element)</em> 构成<em>有序对(ordered pair, pair)</em> 。</p>
<p>　　有序对的元素是<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>。</p>
<p>　　当且仅当若有序对的两个元素不同，交换元素得到的有序对和原有序对不同。</p>
<p><strong>注释</strong></p>
<p>　　一些编程语言中，构造有序对的操作称为 <code>cons</code> ，有序对又称为 cons 对。</p>
<h3 id="广义列表"><a class="header" href="#广义列表">广义列表</a></h3>
<p>　　<em>列表(list)</em> 一种<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型</a>，它的对象可能具有<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>。</p>
<p>　　<em>空列表(empty list)</em> 是不含有子对象的列表。其它列表是<em>非空(nonempty)</em> 列表。</p>
<p>　　每个非空列表是一个<a href="Features/NPL.zh-CN.html#%E6%9C%89%E5%BA%8F%E5%AF%B9">有序对</a>对象，满足：</p>
<ul>
<li>有序对对象的第一个元素是列表的元素。</li>
<li>若有序对对象的第二个元素是有序对，则这个有序对对象的第一个元素是列表的元素；否则，最后一个不是有序对对象的子对象是列表的元素。</li>
</ul>
<p><strong>注释</strong> 推论：同一个列表的元素不是另一个元素的子对象；不同元素之间不具有所有权，生存期不相交。</p>
<p>　　从非空列表对象中取得元素<em>分解(decompose)</em> 列表对象。若经有限次分解，不再可取得列表对象的元素，则列表对象被完全分解。</p>
<p>　　完全分解的列表的最后一个元素之外的其它元素是列表的<em>前缀(prefix)</em> 元素。</p>
<p>　　对象具有前缀元素，当且仅当对象是列表且具有前缀元素。</p>
<p>　　<em>真列表(proper list)</em> 是空列表，或能经完全分解得到最后元素是空列表的列表。其它列表是<em>非真列表(improper list)</em> 。</p>
<p><strong>注释</strong> 推论：非真列表是非空列表。</p>
<p>　　<em>广义列表(generalized list)</em> 是真列表或非真列表。</p>
<p>　　广义列表的元素是<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>。广义列表对元素具有所有权。</p>
<p>　　广义列表是完全分解的元素的<em>序列(sequence)</em> 。</p>
<p>　　作为广义列表的非真列表是<em>无环的(acyclic)</em> ，不包含<em>环(cycle)</em> 。</p>
<p><strong>注释</strong> 同一般的 NPL 约定，NPLA 对象不支持<a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">自引用和循环数据结构</a>。</p>
<p>　　除非另行指定，以下列表指真列表。</p>
<p>　　<em>子有序对(subpair)</em> 是一个有序对完全分解的序列中的元素的真子集构成的子对象。</p>
<p>　　<em>子列表(sublist)</em> 是一个列表中的元素的真子集构成的列表子对象。</p>
<p><strong>注释</strong></p>
<p>　　无环非真列表和真列表类似，可通过 <code>cons</code> 逐次构造。</p>
<p>　　非列表的有序对的元素可能具有自引用，而不是广义列表的元素，因此不是广义列表。NPLA 的一等对象不支持这种情形。</p>
<h3 id="符号"><a class="header" href="#符号">符号</a></h3>
<p>　　<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80"><em>符号(symbol)</em></a> 是未被求值的非<a href="Features/NPL.zh-CN.html#%E5%AD%97%E9%9D%A2%E9%87%8F">字面量</a><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">记号</a>的类型。</p>
<p>　　符号值可构成<a href="Features/NPL.zh-CN.html#%CE%BB-%E5%AE%8C%E5%A4%87%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AF%B9%E5%BA%94%E8%AF%AD%E6%B3%95">名称表达式</a>。</p>
<h2 id="存储和对象模型"><a class="header" href="#存储和对象模型">存储和对象模型</a></h2>
<p>　　NPLA 使用统一的模型对存储和<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">对象</a>进行抽象，并提供关于存储、对象和作为对象的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>以及<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">子项</a>的若干保证。</p>
<p>　　对象语言的存储被视为资源进行管理，称为<em>存储资源(memory resource)</em> 。</p>
<p>　　除非另行指定，语言中不引入<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E8%AF%AD%E4%B9%89">非一等实体</a>。</p>
<p>　　推论：除非另行指定，不引入<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>。</p>
<p><strong>注释</strong></p>
<p>　　一等对象的使用可能受到其它规则的限制，不总是能同时通过对象语言的构造创建和访问。</p>
<p>　　NPL <a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">允许派生实现引入实体的规则</a>不受限制。</p>
<h3 id="npla-基础存储模型和对象模型"><a class="header" href="#npla-基础存储模型和对象模型">NPLA 基础存储模型和对象模型</a></h3>
<p>　　因需提供<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a><a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作支持</a>，除不支持<em>静态(static)</em> 存储和没有提供支持的存储操作外，NPLA 的基础存储模型和对象模型和 [ISO C++11] 相同。</p>
<p>　　当前不支持的存储操作包括<em>分配函数(allocation function)</em> 取得的存储和<em>线程局部(thread-local)</em> 存储。</p>
<p>　　NPLA 还允许类似对象具有未指定的存储或不需要存储的实体，以使<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E8%AF%AD%E4%B9%89">一等实体</a>可涵盖宿主语言在功能上等价的非对象类型（如 C++ 的引用）。这些实体若被支持，其存储实现和互操作接口由派生实现定义。</p>
<p>　　NPLA 中不是<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">一等实体</a>仅由派生实现定义。</p>
<p>　　保证存储性质的差异不被依赖时，不区分一等实体和一等对象的实现方式。</p>
<p>　　在此情况下对象都是<em>固定(pinned)</em> 的，即对象在<em>存储期(storage duration)</em> 内具有宿主语言意义上的确定不变的地址。派生实现可约定扩展作为例外。</p>
<p>　　推论：若一等实体不是一等对象，存储可能和一等对象的存储方式不同。派生实现可在必要时约定与其它一等实体存储的差异。</p>
<p>　　对象的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>是存储期的子集。创建对象基于已确保可访问的存储；销毁对象结束后释放存储。</p>
<p>　　NPLA 支持特定的<a href="Features/NPL.zh-CN.html#%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">非一等对象</a>作为<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>。</p>
<p><strong>注释</strong> 和宿主语言类似。</p>
<p>　　基于宿主操作等意义，作为一等对象相同方式传递的一等实体都在此都视为一等对象；仅当不依赖一等对象的性质时，实现以<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>的方式实现一等实体的操作。</p>
<h3 id="间接值"><a class="header" href="#间接值">间接值</a></h3>
<p>　　特定的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>是<em>间接值(indirect value)</em> 。</p>
<p>　　间接值可以<em>关联(associated)</em> 一个对象。通过间接值可以间接<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>这个对象。</p>
<p>　　间接值可能是<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>或<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>。</p>
<p>　　非一等对象的间接值由实现定义，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p>　　派生实现可以定义其它间接值，称为 NPLA 扩展间接值。</p>
<p>　　一个间接值<em>有效(valid)</em> ，当且仅当存在关联的对象且访问对象不引起<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未定义行为</a>。</p>
<p>　　其它间接值是<em>无效(invalid)</em> 的。</p>
<p>　　除非另行指定，通过无效的间接值试图间接访问关联的对象不满足<a href="Features/NPL.zh-CN.html#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>而引起未定义行为。</p>
<p>　　有效的引用值可能被<em>无效化(invalidate)</em> 而不再有效。</p>
<p>　　派生实现可指定能使间接值无效化的操作。</p>
<p>　　因关联的对象<a href="Features/NPL.zh-CN.html#npla-%E5%9F%BA%E7%A1%80%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">存储期</a>结束而被无效化的间接值是<em>悬空(dangling)</em> 的。</p>
<p><strong>原理</strong></p>
<p>　　间接值可用于代替非间接值，避免求值时改变<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境</a>所有的非<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">所有权</a>。</p>
<p>　　间接值可实现和 [ISO C++] 引用类型的表达式类似的行为。</p>
<p>　　间接访问默认没有对象的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>检查，因此不是安全的。这可能被具体的间接值的规则改变。</p>
<p>　　限制具体的操作能避免或减少在可能访问间接值的操作随意引入具有潜在未定义行为风险。</p>
<p><strong>注释</strong></p>
<p>　　作为一等对象的间接值可能允许复制或转移关联的对象以恢复对应的非间接值作为一等对象直接访问。</p>
<p>　　在<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">使用约定</a>后，本节以下约定要求被 NPLA 实现支持作为一等对象的间接值。非一等对象的间接值由实现定义。派生实现可以定义其它的 NPLA 扩展间接值。</p>
<h4 id="间接值使用约定"><a class="header" href="#间接值使用约定">间接值使用约定</a></h4>
<p>　　间接值生存期规则：被规约对象中间接值的生存期被引用的环境中的对象的生存期的子集。</p>
<p>　　不满足间接值生存期规则的情形，除非提供派生实现定义的其它保证，不保证<a href="Features/NPL.zh-CN.html#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>。</p>
<p>　　以含间接值的项替代不含间接值的项，称为<em>引入(introduce)</em> 间接值。</p>
<p>　　包含间接值的项可被不含引用值的项替代，称为<em>消除(eliminate)</em> 间接值。</p>
<p>　　在特定的适当情形下实现应复制或转移间接值关联的对象以保证<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">满足生存期要求</a>，包括：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%B1%80%E9%83%A8%E9%97%B4%E6%8E%A5%E5%80%BC%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">局部间接值安全保证</a>描述的操作，包括<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>。</li>
<li>为<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>目的，实现定义的其它情形。</li>
<li>派生实现可能定义的其它情形。</li>
</ul>
<p>　　除非另行指定<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起错误</a>，若不能满足上述适当情形条件，则<a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">行为未定义</a>。</p>
<p>　　派生实现可基于本节约定其它规则。</p>
<p><strong>原理</strong></p>
<p>　　为保证间接访问关联对象的内存安全，约定间接值生存期规则。</p>
<p>　　参见局部间接值安全保证和返回值转换。</p>
<p><strong>注释</strong></p>
<p>　　如需直接<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">替换项</a>表示的值，需消除间接值。否则，没有必要提前对项进行操作以提前移除间接值。</p>
<p>　　关于实现定义和派生实现定义的其它情形，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p>　　另见被求值的<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">被规约项中的对象的所有权</a>。</p>
<h4 id="环境间接值"><a class="header" href="#环境间接值">环境间接值</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境引用</a>间接访问环境对象。</p>
<h4 id="引用间接值"><a class="header" href="#引用间接值">引用间接值</a></h4>
<p>　　<em>项引用(term reference)</em> 作为间接值引用一个项，访问这个以这个项作为表示的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>作为关联对象。</p>
<p>　　项引用具有<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">标签</a>。</p>
<h3 id="求值和对象所有权"><a class="header" href="#求值和对象所有权">求值和对象所有权</a></h3>
<p>　　被求值的表达式的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">内部表示</a>中的对象具有 NPLA 对象的<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权</a>。</p>
<p>　　这些内部表示包括<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境对象</a>或<a href="Features/NPL.zh-CN.html#npla-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E4%B9%89">被求值的表达式中的项</a>的情形。</p>
<p>　　对象是表示它的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">被规约项</a>的<em>项对象(term object)</em> 。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">NPLA 临时对象</a>的存储未指定，但<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">部分临时对象被项所有</a>。</p>
<p>　　求值结束而不被使用的项的资源在求值终止时被释放，包括被项独占所有权的这些临时对象。</p>
<p>　　求值终止包括可被实现确定的<a href="Features/NPL.zh-CN.html#%E5%BC%82%E5%B8%B8">异常</a>退出。</p>
<p>　　对名义上被项所有的临时对象，必要时实现可分配内部存储转移项（包括在环境中分配），以满足附加要求（如<a href="Features/NPL.zh-CN.html#%E7%94%9F%E5%AD%98%E6%9C%9F%E9%99%84%E5%8A%A0%E7%BA%A6%E5%AE%9A">生存期附加约定</a>）。</p>
<p>　　对象的所有权随可随对象被转移，参见<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">对象的复制和转移</a>。</p>
<p>　　求值结果可包含<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>，称为<em>结果对象(result object)</em> 。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>时以<a href="Features/NPL.zh-CN.html#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">活动记录</a>保持<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的所有权。活动记录及其帧的具体结构、维护方式和生存期由派生实现定义。</p>
<p>　　除非另行指定，NPLA 只有一种<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">作用域</a>，这种作用域中的名称由<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">环境</a>提供。</p>
<p>　　除非另行指定，NPLA 的活动记录不需要和<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>的结构保证直接对应关系。</p>
<p><strong>原理</strong></p>
<p>　　因为宿主语言函数调用实现（典型地，<em>调用栈(call stack)</em> 及其中的栈帧）不提供可移植的<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>，不要求实现提供活动记录之间的映射关系。</p>
<p><strong>注释</strong></p>
<p>　　临时对象的存储未指定、异常退出和所有权转移类似宿主语言。</p>
<p>　　结果对象和 [ISO C++17]（由提案 [WG21 P0135R1] 引入）中的概念对应。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境对象</a>和<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境引用</a>对其中的对象的所有权。</p>
<h4 id="项对象和关联对象所有权"><a class="header" href="#项对象和关联对象所有权">项对象和关联对象所有权</a></h4>
<p>　　仅在<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">泛左值</a>中允许引入可能访问关联对象的间接值。</p>
<p>　　推论：泛左值的项对象和它作为间接值可关联的对象（若存在）不是临时对象，被环境所有。</p>
<p>　　通常纯右值作为其它项的子项而被独占所有权，求值时可能通过<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">临时对象实质化转换</a>标识创建的<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%A8%E7%A4%BA">表示临时对象的项</a>被纯右值所有，也间接被其它项所有。</p>
<p>　　特定的纯右值可能被<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">环境</a>所有，但应只通过复制等方式访问其值而不依赖所有权关系。</p>
<p>　　关于实现中项的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>和构成以及纯右值被环境所有的例子，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　基于<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>的性质，为保证<a href="Features/NPL.zh-CN.html#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>，避免非预期地超出存储期的间接值访问，限制引入间接值的表达式的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">值类别</a>。</p>
<p>　　因<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%A8%E7%A4%BA">临时对象可能具有和一等对象不同的表示</a>，在此特设规则约定。</p>
<h3 id="内存安全"><a class="header" href="#内存安全">内存安全</a></h3>
<p>　　（非并发）<em>内存安全(memory safety)</em> 是存储资源避免特定类型不可预测错误使用的性质。</p>
<p>　　基本的内存安全保证蕴含非<a href="Features/NPL.zh-CN.html#npla-%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE">并发访问</a>时不引入<a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">未定义行为</a>。这至少满足：</p>
<ul>
<li>对存储的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>总是在提供存储的对象的存储期内，除非有其它另行指定的机制（如<a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>的<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>）保证存储的访问不违反其它语义规则。</li>
<li>宿主环境中不访问未被初始化的值。</li>
</ul>
<p><strong>注释</strong> 实现仍可能因其它规则引起未定义行为；特别地，这包括<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>无法提供资源的未定义行为。</p>
<p>　　派生实现可能扩展内存安全，提供语言规则避免非预期的内存访问错误，提供更一般的高级<em>安全(security)</em> 保证。</p>
<p><strong>注释</strong> 例如，<em>保密性(secrecy)</em> 和<em>完整性(integrity)</em> 。</p>
<p>　　除非另行指定，派生实现不提供扩展的内存安全保证。</p>
<p>　　除非派生实现另行指定，NPLA 不提供<em>数据竞争避免(data race avoidence)</em> 保证。</p>
<p><strong>原理</strong></p>
<p>　　关于内存安全含义的讨论，另见<a href="https://arxiv.org/abs/1705.07354">这里</a>。</p>
<p><strong>注释</strong></p>
<p>　　用户代码应注意避免违反内存安全的访问，包括非并发的，以及并发访问的内存冲突。</p>
<h4 id="非内存安全操作"><a class="header" href="#非内存安全操作">非内存安全操作</a></h4>
<p>　　非内存安全操作是不保证内存安全的操作，在对象语言中即可能引起违反内存安全。</p>
<p>　　这些操作违反内存安全时，引起 <a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">NPLA 未定义行为</a>，且可能未被实现检查而同时引起<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>的未定义行为。</p>
<p>　　对象语言中的非内存安全特性可能直接调用这些操作。NPLA 外依赖此类操作的其它操作也具有类似的性质。</p>
<p><strong>注释</strong></p>
<p>　　派生实现或<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>可能使用补充检查等方式避免未定义行为。</p>
<h4 id="npla-对象语言内存安全保证"><a class="header" href="#npla-对象语言内存安全保证">NPLA 对象语言内存安全保证</a></h4>
<p>　　NPLA 中，确定地引入具有<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">非内存安全操作</a>的对象的操作应仅只包括引入特定的<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>或其它派生实现指定类型的值的操作：</p>
<ul>
<li>调用引入不保证内存安全的间接值的 NPLA <a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 。</li>
<li>调用 NPLA 中其它取<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">对象</a>的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">内部表示</a>的值的间接值使之被<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">修改</a>的 API 。</li>
</ul>
<p>　　排除非内存安全操作以及非内存安全的本机实现，NPLA 实现的对象语言提供基本内存安全保证。</p>
<h4 id="npla-内存安全保证"><a class="header" href="#npla-内存安全保证">NPLA 内存安全保证</a></h4>
<p>　　满足 <a href="Features/NPL.zh-CN.html#npla-%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">NPLA 对象语言内存安全保证</a>同时排除引起宿主语言未定义行为的非内存安全的操作，NPLA 实现提供基本内存安全保证。</p>
<p><strong>注释</strong> 宿主语言未定义行为的非内存安全的操作如超出<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>。</p>
<p>　　除非通过接口约束另行指定，使用 NPLA 实现的派生实现应提供相同的保证。</p>
<p><strong>注释</strong> 例如，添加<a href="Features/NPL.zh-CN.html#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A5">断言检查</a>可能改变<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">实现行为</a>。</p>
<h4 id="运行时内存安全检查"><a class="header" href="#运行时内存安全检查">运行时内存安全检查</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">运行时</a>检查可能帮助排查内存安全的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">实现行为</a>。这包括蕴含运行时检查的接口约束（失败时抛出异常或断言）。</p>
<p>　　此外，实现可能提供可选的运行时检查。这些可选的检查帮助排查未定义行为，而不应被程序实现依赖。</p>
<h4 id="局部间接值安全保证"><a class="header" href="#局部间接值安全保证">局部间接值安全保证</a></h4>
<p>　　访问间接值涉及维护<a href="Features/NPL.zh-CN.html#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全保证</a>时，可能需要<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">提升项</a><a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">消除间接值</a>，以移除允许<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">非内存安全访问</a>的间接值。</p>
<p><strong>原理</strong></p>
<p>　　使用<a href="Features/NPL.zh-CN.html#%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5">删除策略</a>实现<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">过程调用</a>时，其中分配的<em>局部(local)</em> 资源随包含资源引用的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>返回可能<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">逃逸</a>。一般的间接值也有类似的逃逸问题。</p>
<p>　　若其<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">关联</a>的对象（如<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">项引用</a>关联的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>）在调用后不再存在，则间接值不再有效，构成<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">悬空间接值</a>。若这些间接值被<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">调用者</a>获取（如被作为<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>传递），继续<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>这个间接值关联的对象非内存安全。</p>
<p>　　为维护内存安全保证，这些情形应被避免，如通过：</p>
<ul>
<li>通过分析调用处的代码证明确保不存在这样的内存不安全访问。</li>
<li>通过间接值的消除移除这些间接值使这种悬空间接值在调用者中自始不存在。</li>
</ul>
<p>　　替代消除间接值的方式包括通过<em>逃逸分析(escape analysis)</em> 替换间接值，这也能减少间接值的访问而提供更优化的实现。例如，通过对<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境中被绑定对象的使用</a>进行逃逸分析提供优化实现。</p>
<p>　　但是，这不在 NPLA 中被要求，因为：</p>
<ul>
<li>逃逸分析需要完整的所有权信息，这需要附加的开销，否则不总是可行（例如涉及跨多个过程的调用）。</li>
<li>对删除策略，逃逸分析也没有提供不可替代的优化。</li>
</ul>
<h3 id="资源泄漏"><a class="header" href="#资源泄漏">资源泄漏</a></h3>
<p>　　<em>资源泄漏(resource leak)</em> 是不能预期地（决定性地）访问之前被分配的资源的情形。</p>
<p>　　<em>内存泄漏(memory leak)</em> 是存储资源的泄漏。</p>
<p>　　强内存泄漏状态是指存在存储无法通过任何途径访问的状态。若存在存储不被任意对象或其它另行指定的代替对象的实体（如<a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>）所有权的传递闭包包含，即所有权依赖<em>不可达(unreachable)</em> ，则存在强内存泄漏。</p>
<p>　　弱内存泄漏是除了强内存泄漏以外的内存泄漏，和具体预期相关。</p>
<p><strong>原理</strong></p>
<p>　　一般意义下，[Cl98] 中定义的任一空间复杂度类都可以作为形式的预期。因为内存作为存储资源被空间复杂度类度量，满足某个空间复杂度类的无<em>空间泄漏(space leak)</em> 蕴含对应的无内存泄漏。</p>
<p>　　弱内存泄漏的预期的可实现性和实现细节相关，因此 NPLA 不指定具体预期。</p>
<h4 id="资源回收策略"><a class="header" href="#资源回收策略">资源回收策略</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">单一作用域</a>内的资源回收有<em>删除(deletion)</em> 和<em>保留(retention)</em> 的策略。</p>
<p>　　NPLA 不限定具体使用的回收策略，但要求应支持：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">释放一等对象时允许具有副作用</a>。</li>
<li>确保副作用作用时机的确定性，即除<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>指定外，不在<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机语义</a>中延迟副作用的起始。</li>
</ul>
<p>　　为简化语义规则同时避免限制特定的可用资源（如系统中剩余的内存）的变化被派生实现抽象为副作用，除非派生实现指定，不对内存使用保留策略，不使内存超出对象<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>。</p>
<p>　　NPLA 要求实现完全避免除用户程序显式管理资源的资源泄漏以外的强内存泄漏。</p>
<p>　　除非另行指定，NPLA 释放资源的作用顺序未指定。NPLA 不依赖释放的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>的顺序。</p>
<p>　　派生实现可以要求使用不同的规则：</p>
<ul>
<li>指定释放资源的顺序。</li>
<li>可选地支持非确定的释放资源的副作用。</li>
</ul>
<p>　　NPLA释放可能具有的副作用顺序的存储资源和其它资源共享更普遍的所有权抽象资源的<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权语义</a>上的操作：</p>
<p>　　使用删除策略时，<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">活动的过程调用</a>对其中分配的资源具有所有权。</p>
<p>　　注意多个对象构成的系统中，仅存在<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">平等的所有权</a>时的<a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>造成强内存泄漏：除非即从循环引用的对象中区分出具有不同类所有权的对象子集实现所有权正规化，总是存在无法被释放资源的对象。</p>
<p>　　NPLA 不要求实现 GC 等机制避免这类循环引用。</p>
<p>　　关于循环引用避免，另见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　NPLA 不要求实现 <a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">GC</a>。</p>
<p>　　未指定的资源释放的作用顺序使其中可能具有的副作用影响的可观察行为成为<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定行为</a>。</p>
<p>　　除非派生实现要求使用不同的规则支持非确定的资源的副作用，NPLA 的实现不依赖不保证确定性释放资源的副作用顺序的<em>追踪(tracing)</em> GC 。这使追踪 GC 可能被可选地添加(opted-in) 到实现支持特性中。这允许自动资源管理机制中一定程度的<a href="Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>。[ISO C++11] 起直至 [ISO C++20] ，C++ 语言规则支持类似的策略。</p>
<p>　　资源释放副作用的确定性要求和作用顺序未指定的规则不影响实现使用基于引用计数的 GC 策略。这允许实现以简单的方式以用户程序不直接可见的方式引入共享资源，在避免资源泄漏的意义上兼顾<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>和<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>。但为<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">避免单一所有者</a>，此时在对象语言应提供特性使用户程序可以创建隔离共享者的资源实体。</p>
<p>　　基于非预期的循环引用不可避免地造成实现开销而违反<a href="Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>（即使这种开销可能并不总是可观察）NPLA 不要求实现 GC 和对一般对象区分强弱引用等机制避免循环引用。此时，程序应自行避免所有权意义上的<a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>以避免资源泄漏。</p>
<p>　　由于 GC 通常基于具有特定操作的单一资源所有权的所有者的对象池的这一实现特例，不依赖共享所有者的 GC 的设计一般也更容易满足<a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">统一性</a>、<a href="Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>和<a href="Features/NPL.zh-CN.html#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99">关注点分离原则</a>。</p>
<p>　　以上规则允许程序中：</p>
<ul>
<li>不依赖释放可能具有的副作用顺序的资源。</li>
<li>使存储资源和其它资源共享基于更普遍的<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权抽象</a>的资源所有权语义的操作的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E4%BD%9C%E7%94%A8">作用</a>，以一致的方式实现资源管理。</li>
</ul>
<p>　　关于不同的资源回收策略（其中一部分可能引起存储空间资源泄漏）的讨论，详见 [Cl98] 。</p>
<p>　　使用所有权抽象活动记录的资源能更好地满足资源管理机制和具体操作的<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7">可复用性</a>和<a href="Features/NPL.zh-CN.html#%E4%BD%9C%E7%94%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99">作用使用原则</a>的要求。</p>
<h4 id="资源回收安全性"><a class="header" href="#资源回收安全性">资源回收安全性</a></h4>
<p>　　派生实现可补充定义规则在资源回收的作用上提供更强的安全保证。</p>
<p><strong>原理</strong></p>
<p>　　内存泄漏是和<a href="Features/NPL.zh-CN.html#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>不同的另一类非预期的问题，表明语言设计、实现或程序存在缺陷。</p>
<p>　　即便不违反内存安全保证，涉及弱化空间复杂度类预期的内存泄漏仍可损害程序的<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>而引起安全(security) 问题。</p>
<p>　　内存泄漏和违反内存安全同属违反特定的存储访问不变量的<em>错误条件(error condition)</em> ，但因为不论在语言还是程序的设计和实现中，避免的机制相当不同，在此被区分对待。</p>
<p>　　即便不扩展规则提供更强的内存安全保证，仅在资源回收的作用上避免错误条件也是有意义的。</p>
<p>　　存在其它语言使用类似的区分内存泄漏和<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">非内存安全</a>的设计，如 [Rust]（详见<a href="https://doc.rust-lang.org/book/second-edition/ch15-06-reference-cycles.html">相关文档</a>）。</p>
<h3 id="子对象"><a class="header" href="#子对象">子对象</a></h3>
<p>　　对象的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">子实体</a>是对象时，子实体是对象的<em>子对象(subobject)</em> 。</p>
<p>　　除非另行指定，子对象及其性质同宿主语言的约定：在宿主语言的表示中表现为子对象的对象语言中的对象，也是对象语言的子对象。</p>
<p>　　对象语言的其它具有子对象的情形由派生实现定义。</p>
<p>　　对象对它的子对象具有平凡的<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权</a>。</p>
<p>　　对象的子对象的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>不<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序</a>对象的生存期起始，对象的子对象的生存期结束不<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">后序</a>对象的生存期结束。</p>
<p>　　对象的子对象的生存期起始后序对象的生存期起始，对象的子对象的生存期结束先序对象的生存期结束。</p>
<p>　　除非另行指定，同一个的对象不同子对象的存储期起始、存储期结束、生存期起始、生存期结束之间分别无序。</p>
<p>　　对象对其存储期和生存期的其它约束和宿主语言相同。</p>
<p>　　对象可通过<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子对象引用</a>关联和与其生存期相关或无关的其它对象。</p>
<p>　　通过子对象访问的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>上的<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">副作用</a>是否蕴含对象上的副作用未指定。</p>
<p>　　关于内部对象，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　子对象不一定支持<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">可修改</a>的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">一等状态</a>。修改子对象可能导致或不导致对象或先前通过相同方式取得的子对象的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">改变</a>。</p>
<p>　　[ISO C++] 通过类型定义具有的隐含的对象布局共享同类对象的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">内部表示</a>。与之不同，为简化<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>表示的项上的操作，子对象之间不一定共享表示。</p>
<p>　　特别地，通过<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E8%A1%A8%E7%A4%BA">子对象引用项</a>访问的对象的子对象之间不一定具有<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>。</p>
<p>　　关于具体表示，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>注释</strong></p>
<p>　　作为支持子对象作为内部对象的逻辑前提，NPLA 不支持<a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>。</p>
<p>　　[ISO C++] 允许 <code>const</code> 成员提供不支持修改的状态。<a href="Features/NPL.zh-CN.html#npla-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F">NPLA 不要求类似的类型系统支持</a>，没有类似的设计。</p>
<h4 id="项的子对象"><a class="header" href="#项的子对象">项的子对象</a></h4>
<p>　　作为对象的子项是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象</a>的子对象。</p>
<p>　　项可能有其它子对象，其具体表示由实现定义。</p>
<p>　　满足以下条件的替换变换替代项或其子对象，称为项的<em>提升(lifting)</em> ：被提升的项（源）是提升后得到的项（目标）的一个直接、间接子项或项的子对象变换得到的项。</p>
<p>　　提升可能包含附加检查，检查失败时可能<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起错误</a>而不实际进行提升。</p>
<p>　　除非另行指定，提升项<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">修改</a>被替换的对象。</p>
<p><strong>原理</strong></p>
<p>　　项的子对象确定的表示可能被具体的<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>依赖。</p>
<p>　　项的提升可以视为作为语法变换的消去 <a href="Features/NPL.zh-CN.html#%CE%BB-%E5%AE%8C%E5%A4%87%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AF%B9%E5%BA%94%E8%AF%AD%E6%B3%95">λ 抽象</a>的 <a href="https://en.wikipedia.org/wiki/Lambda_lifting">lambda 提升 (en-US)</a> 的一般化，但此处和 λ 抽象没有直接关联。</p>
<p>　　项的提升的变换可以是恒等变换，即直接以子对象作为替换的来源。其它变换如创建<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>和取间接值关联的对象，对应的提升<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">引入和消除间接值</a>。</p>
<p>　　项的提升的检查可包括为满足接口行为的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">语义检查</a>和实现为预防<a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">宿主语言的未定义行为</a>的附加检查。</p>
<p>　　被提升的项往往被<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">转移</a>，因此一般地，需要在宿主语言中<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">可修改</a>。若被提升的项表示对象语言的值，一般也需要在对象语言中可修改。</p>
<h3 id="对象属性"><a class="header" href="#对象属性">对象属性</a></h3>
<p>　　除以上性质外，对象可关联其它元数据以指定对象的<em>属性(property)</em> 。</p>
<p>　　和属性对应的可组成对象的表示的非一等实体统称为<em>标签(tag)</em> 。</p>
<p>　　对象具有的标签决定以下<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E4%BA%A4%E6%80%A7">正交</a>的性质：</p>
<ul>
<li>唯一(unique) 引用：指定<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">对象的值</a>关联到自身以外的不被其它对象<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%88%AB%E5%90%8D">别名</a>的对象。
<ul>
<li>以唯一引用关联的对象进行<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96">复制初始化</a>时，不需要保留关联的对象的值。</li>
</ul>
</li>
<li>不可修改(nonmodifying) ：指定对象的值保持不变。
<ul>
<li>若操作需要修改此对象，则<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起错误</a>。</li>
</ul>
</li>
<li>临时(temporary) 对象：指定对象的值被临时使用。</li>
</ul>
<p>　　唯一引用和不可修改是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>的属性。对象语言中，引用值以外的对象是否具有这些属性未指定。为<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>目的可能具有实现定义的更强的假设。派生实现也可定义更强的假设。</p>
<p>　　临时对象属性类似唯一引用，但限定的可以是对象自身而非关联的其它对象，即引用值自身和<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>可以分别具有临时对象属性。但除了引用值属性外，临时对象属性仅限在<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>上出现。</p>
<p><strong>注释</strong></p>
<p>　　不可修改的对象类似 [ISO C++] 的 <code>const</code> 类型的对象。[ISO C++] 的非类和非数组类型的对象不具有 <code>const</code> 修饰。</p>
<p>　　对象的标签不在大多数对象中可见。另见<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用值的属性</a>。</p>
<h2 id="npla-环境"><a class="header" href="#npla-环境">NPLA 环境</a></h2>
<p>　　<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">求值环境</a>维护名称和作用域。</p>
<p>　　NPLA 的求值环境可以是：</p>
<ul>
<li><em>一等环境(first-class environment)</em> ，即作为对象语言中的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">一等对象</a>的环境。</li>
<li>作为 NPLA <a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>的<em>环境记录(environment record)</em> 。</li>
</ul>
<p>　　环境可引用若干个关联的其它环境对象为<em>父环境(parent environment)</em> ，用于<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">重定向</a>。</p>
<p>　　除非派生实现另行指定：</p>
<ul>
<li>环境可引用有限多个父环境，其数量的上限未指定。</li>
<li>父环境在创建时指定，作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">实体</a>，之后<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">不可变</a>。</li>
</ul>
<h3 id="环境对象"><a class="header" href="#环境对象">环境对象</a></h3>
<p>　　环境作为可保持<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">可变状态</a>的对象，是<em>环境对象(environment object)</em> 。</p>
<p>　　环境对象包含<em>变量名称(variable name)</em> 到表示<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">被绑定实体</a>的映射，称为<em>名称绑定映射(name binding map)</em> ，实现<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">变量绑定</a>。</p>
<p>　　被绑定实体是对象时，称为<em>被绑定对象(bound object)</em> 。NPLA 环境对象中的被绑定实体包含一等对象，因此被绑定实体总是被绑定对象。</p>
<p>　　环境对象对其中的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">名称绑定映射</a>具有独占的<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权</a>。名称绑定映射对其中的对象可具有独占或共享的所有权。因此，环境对象可对包括被绑定实体的名称绑定映射中的对象具有独占或共享的所有权。</p>
<p>　　环境记录之间共享所有权，以<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境引用</a>访问。</p>
<p>　　环境对象是<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>时查找名称的<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">目标</a>。</p>
<p>　　父环境可共享环境记录。通过共享环境记录实现重定向的环境表示是<em>链接的(linked)</em> 而非<em>平坦的(flat)</em> 。</p>
<p><strong>原理</strong></p>
<p>　　仅在可证明符合语义要求等价时，使用平坦的环境表示。</p>
<p>　　对支持一等对象语义的设计，因为明确要求区分<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>，对象的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">存储</a>不能被任意地复制。</p>
<p>　　一般地，仅在可证明父环境对应的环境记录在对象语言和实现内部都不被共享访问（不具有<a href="Features/NPL.zh-CN.html#%E5%85%B1%E4%BA%AB%E5%BC%95%E7%94%A8">共享引用</a>且不被<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%88%AB%E5%90%8D">别名</a>），且不存在任意派生实现定义的对释放顺序引起的可观察行为差异时，才能唯一具有这个父环境的环境为平坦的表示而<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">保持语义不变</a>。</p>
<p><strong>注释</strong></p>
<p>　　变量名通过以和字符串一一对应的值表示，没有直接的值的限制，可能为空串。</p>
<p>　　若环境记录直接持有<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>，则这些对象是环境记录的<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>。</p>
<h3 id="环境引用"><a class="header" href="#环境引用">环境引用</a></h3>
<p>　　环境引用是对象语言中访问环境记录的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">一等对象</a>。</p>
<p><strong>注释</strong> 环境引用不是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>。后者关联的被引用对象是一等对象。</p>
<p>　　环境引用共享环境对象的<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权</a>。</p>
<p>　　根据所有权管理机制的不同，环境引用包括<a href="Features/NPL.zh-CN.html#%E4%B8%80%E8%88%AC%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%80%E8%88%AC%E5%AE%9E%E7%8E%B0">环境强引用</a>和<a href="Features/NPL.zh-CN.html#%E4%B8%80%E8%88%AC%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%80%E8%88%AC%E5%AE%9E%E7%8E%B0">环境弱引用</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境强引用</a>可能共享环境对象的所有权，对<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境对象的名称绑定映射</a>持有的项具有间接的所有权。</p>
<p>　　作为<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>，环境引用可被复制或转移。</p>
<p>　　复制或转移环境引用不引起被引用的环境对象被复制。因此，<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值传递</a>环境引用不引起其中所有的对象被复制。另见<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>。</p>
<p><strong>原理</strong></p>
<p>　　区分环境对象和环境引用在纯函数式语言不是必要的，因为不需要关心<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境中的子对象</a>的复制影响<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>。</p>
<p>　　否则，为支持影响可观察行为的环境的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">修改</a>，非环境记录的环境引用是必要的。</p>
<p>　　环境引用也是一种较简单且一般普遍高效的父环境的实现表示，可直接实现<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">链接的</a>环境而不需要证明和实现特设的其它内部表示能和<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机</a>意义上链接的环境保持语义等价。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延捕获</a>若复制续延，可能引起关联的环境的复制，影响可观察行为并引起不必要的实现开销。为此，区分环境引用是必要的。</p>
<p>　　以环境引用作为一等对象使访问<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>等环境记录的子对象时需要间接访问，在环境实际不需要被复制的大部分其它场景引起开销。这种开销是可接受的，因为：</p>
<ul>
<li>考虑到一等环境的普遍性，有必要有效支持对象语言中创建环境临时对象（而不仅仅是环境对象的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>）的使用使之避免复制。</li>
<li>实现可能提供附加的证明以在优化的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">翻译</a>过程中替换环境引用为环境记录或其它不需要间接访问的中间表示，以消除这些开销。</li>
</ul>
<p>　　不论这样的证明是否存在，环境强引用和弱引用仍在对象语言中区分，以明确接口上的<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权语义</a>。</p>
<p>　　引入环境弱引用作为一般的引用机制，且仅在必要时使用环境强引用，以避免过于容易<a href="Features/NPL.zh-CN.html#%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5">引入循环引用引起强内存泄漏</a>，符合<a href="Features/NPL.zh-CN.html#%E9%80%82%E7%94%A8%E6%80%A7">适用性</a>。</p>
<h3 id="当前环境"><a class="header" href="#当前环境">当前环境</a></h3>
<p>　　NPLA 对象语言中，表达式的求值隐含对应一个环境对象作为<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>需要的<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">上下文</a>输入，称为<em>当前环境(current environment)</em> 。</p>
<h2 id="npla-表达式语义"><a class="header" href="#npla-表达式语义">NPLA 表达式语义</a></h2>
<p>　　本节约定对象语言中的表达式相关的语义规则，特别是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值规则</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%88%97%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">列表表达式</a>作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>是<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">列表</a>。</p>
<h3 id="值类别"><a class="header" href="#值类别">值类别</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>归类为具有以下基本的<em>值类别(value category)</em> 之一：</p>
<ul>
<li><em>泛左值(glvalue)</em> ：求值用于决定被表示的对象的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>的表达式。</li>
<li><em>纯右值(prvalue)</em> ：求值不用于决定对象同一性（而仅用于<a href="Features/NPL.zh-CN.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a><a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>或计算对象中<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">存储的值</a>）的表达式。</li>
</ul>
<p>　　一个泛左值可能被标记为<em>消亡值(xvalue)</em> ，以提供基于不同的所有权的行为。</p>
<p>　　纯右值蕴含对象在<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>的意义上不被共享，类似不被别名的引用的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>不被<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%88%AB%E5%90%8D">共享</a>。</p>
<p>　　<em>左值(lvalue)</em> 是除了消亡值外的泛左值。</p>
<p>　　<em>右值(rvalue)</em> 是消亡值或纯右值。</p>
<p>　　基本的值类别、消亡值、左值和右值都是值类别。</p>
<p>　　求值涉及表达式的值类别仅在必要时约定。</p>
<p>　　表达式的值类别是上下文相关的，相同表达式构造在不同的上下文可能具有不同的值类别。</p>
<p>　　NPLA 表达式允许在源语言语法之外的形式被间接构造，这些表达式同样具有值类别。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值规约</a>可能重写一个表达式为具有不同值类别的为被规约项。即便不能被对象语言表达，只要不和其它语义规则冲突，它们在此被视为其它形式的表达式的表示，即<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象</a>也对应地具有值类别。</p>
<p>　　一般地，NPLA 的表达式不限定从<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">源代码</a>的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">翻译</a>确定，且一个表达式的求值结果不排除继续构成表达式而被求值，因此表达式的值也普遍具有值类别。</p>
<p>　　除非另行指定，若一个 NPLA 表达式没有指定未被求值，则其值类别是其<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>的值类别。</p>
<p><strong>原理</strong></p>
<p>　　值类别根据是否只关心表达式关联的（对象的或非对象的）值，在需要对象时提供区分<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">两类一等实体</a>的机制，同时避免在仅需要表达式关联的值时引入不必要的其它对象。</p>
<p><strong>注释</strong></p>
<p>　　对象语言表达式的值类别和 [ISO C++17]（由提案 [WG21 P0135R1] 引入的特性）类似。</p>
<p>　　值类别在 [ISO C++] 中实质上是一种<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态类型</a>系统。在 NPLA 中以更灵活的可在<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">运行时</a>访问的元数据代替，仍能体现类似的上下文相关性。</p>
<p>　　除了标记消亡值，附加其它元数据也允许区分不同的所有权行为。</p>
<p>　　NPLA 值类别和 [ISO C++] 也有显著的不同，体现在如下扩展：源语言语法外的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">被规约项</a>的项对象视为 NPLA 表达式，也具有值类别。</p>
<p>　　因此，作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>的表达式的值也普遍具有值类别。若存在<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">结果对象</a>，可直接<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B">通过其类型确定</a>。</p>
<p>　　作为静态语言，[ISO C++] 缺乏允许在运行时确定的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>特性，这些不同不在 [ISO C++] 中可用，可以被视为保守的扩展。</p>
<h4 id="类型系统和值类别"><a class="header" href="#类型系统和值类别">类型系统和值类别</a></h4>
<p>　　NPLA 中，值类别作为<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%9E%8B">实体类型</a>，被作为一种内建的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">类型系统</a>。</p>
<p><strong>注释</strong></p>
<p>　　这和 [ISO C++] 不同。[ISO C++] 的“类型”的定义排除值类别，尽管值类别具有类型论意义上所有可作为类型讨论的对象的性质。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用类型</a>。</p>
<h3 id="初始化"><a class="header" href="#初始化">初始化</a></h3>
<p>　　对象被创建后可通过<em>初始化(initialization)</em> 决定其值，并可能存在其它<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>。被决定的值是<em>初始值(initial value)</em> 。</p>
<p>　　决定初始化这些作用的表达式是初始化的<em>初值符(initializer)</em> 。</p>
<p>　　初值符的求值可能有<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>，其求值结果指定特定被初始化的对象的初始值。</p>
<p>　　初始化包括<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>的初始化和作为函数值的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>对象的初始化。</p>
<p>　　初始化被绑定对象可能以<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">修改操作</a>的形式体现，此时修改绑定具有副作用。若这样的副作用存在，每个被初始化的值<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">后序</a>于对应初始的计算。</p>
<p><strong>注释</strong></p>
<p>　　初值符的求值的副作用不属于初始化，其求值结果和对象的初始值不一定相同。</p>
<p>　　和宿主语言不同，初始化不是独立的依赖特定语法上下文的概念，但此处语义上的作用类似。</p>
<p>　　对象的初始化一般可蕴含<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的初始化。</p>
<h4 id="复制初始化和直接初始化"><a class="header" href="#复制初始化和直接初始化">复制初始化和直接初始化</a></h4>
<p>　　初始化包括<em>直接初始化(direct initialization)</em> 和<em>复制初始化(copy initialization)</em> 。</p>
<p>　　函数可能接受<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>参数和返回值，是对函数的形式参数或函数值的复制初始化；其它初始化是直接初始化。</p>
<p>　　复制初始化形式参数和函数值时，函数参数或返回值作为初值符。</p>
<p><strong>注释</strong></p>
<p>　　区分两者和宿主语言类似。</p>
<h4 id="函数参数和函数值传递"><a class="header" href="#函数参数和函数值传递">函数参数和函数值传递</a></h4>
<p>　　部分函数可保证<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">被初始化的对象副本</a>中的值和初值符的值及元数据一致。</p>
<p>　　这样的参数或返回值的初始化的求值称为<em>转发(forwarding)</em> 。</p>
<p>　　转发也包括只部分保留上述部分元数据的情形。</p>
<p>　　在允许保留元数据不变的上下文，转发在<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>中可直接通过<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">转移项</a>实现。</p>
<p>　　转发保持引入这些初始化的表达式（通常是被求值取得函数值的函数表达式）时，其求值结果（函数值）的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">值类别</a>和初值符保持一致。</p>
<p><strong>注释</strong></p>
<p>　　这里的元数据的一个例子是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用值的属性</a>。</p>
<p>　　转发类似宿主语言的<em>完美转发(perfect forwarding)</em> 。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">函数值传递</a>。</p>
<h4 id="对象的复制和转移"><a class="header" href="#对象的复制和转移">对象的复制和转移</a></h4>
<p>　　可使用初值符为参数进行复制或转移操作以<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96">复制初始化</a>对象，创建<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">对象的副本</a>。</p>
<p><strong>注释</strong> 这类似宿主语言中的类类型的值。其它情形另见<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4">复制消除</a>。</p>
<p>　　对象的复制和转移不改变被转移后的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型</a>。</p>
<p>　　对象的复制和转移对应蕴含其子对象被复制和转移。在<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>的意义上，若项<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">具有子对象的独占所有权</a>，这些子对象的复制构造函数和转移构造函数被对应调用。特别地，这里的子对象包括<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主值</a>。</p>
<p>　　可使用转移操作时，不对作为对象的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>进行复制，因此不要求其中的子对象可复制，而避免<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p><strong>注释</strong> 这类似 [ISO C++11] 起选择类的转移构造函数代替复制构造函数。</p>
<p>　　和 [ISO C++11] 起不同，上述可使用转移操作的条件和语法上下文无关：引起选择转移操作的条件由对初值符的谓词而非类似宿主语言的构造函数判断（详见<a href="Features/NPL.zh-CN.html#%E9%BB%98%E8%AE%A4%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2%E7%BA%A6%E5%AE%9A">默认值类别转换约定</a>）。</p>
<p><strong>注释</strong> 同宿主语言。</p>
<p>　　除非另行指定，需要创建实体的副本时：</p>
<ul>
<li>若对象满足可转移条件，则使用转移而不是复制。</li>
<li>其它情形实体被复制。</li>
</ul>
<p><strong>注释</strong> 一个主要的实例是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值的副本传递</a>。</p>
<h4 id="项的转移"><a class="header" href="#项的转移">项的转移</a></h4>
<p>　　一定条件下，作为对象的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>可被整体转移，而避免其中包含的对象的初始化在对象语言中具有可见的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>。</p>
<p>　　在<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>的意义上，对象的转移构造函数不会因作为对象的表示的项的转移被调用。</p>
<p>　　项的转移是<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">析构性转移</a>。</p>
<p>　　一般地，当对象需要被转移且没有约定<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">转移后要求类型不变</a>时，项的整体转移可代替<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">对象的转移</a>，避免初始化新的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主对象</a>，称为宿主对象转移消除。</p>
<p><strong>注释</strong> 若需调用<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>的转移构造函数，需明确避免在代替对象的转移的上下文中进行操作。派生实现可提供这些操作。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87">返回值转换上下文</a>的转移蕴含宿主对象转移消除。</p>
<p>　　若被<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4">复制消除</a>的对象来自不同的项，则复制消除蕴含宿主对象转移消除。这包括所有对象转移的返回值转换上下文的情形。</p>
<h3 id="引用值"><a class="header" href="#引用值">引用值</a></h3>
<p>　　在对象语言中，<em>引用值(reference value)</em> 是作为<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>，可保存在一等对象中。这样的一等对象是<em>引用对象(reference object)</em> 。</p>
<p>　　引用值和引用对象的值具有<em>引用类型(reference type)</em> 。</p>
<p>　　在特定上下文中，引用和其它<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">一等对象</a>的值的相同具有不同的语义，主要体现在引用值被按值直接初始化传递和<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按引用传递</a>时。</p>
<p><strong>注释</strong> 差异和 [ISO C++] 中使用对象类型和引用类型作为参数类似。</p>
<p>　　NPLA 引用值总是假定和<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>关联。</p>
<p><strong>注释</strong> 和宿主类型类似，引用类型没有空值。</p>
<p>　　仅当以下情形中，NPLA 引用值的被引用对象是非<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">一等对象</a>：</p>
<ul>
<li>作为<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　由于<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象</a><a href="Features/NPL.zh-CN.html#%E9%A1%B9%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">被环境所有</a>，为允许<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">规约求值</a>其中的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>，需要不被环境所有的（其它不同的）<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">被规约项</a>作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">表示</a>的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象</a>作为中间值。</p>
<p>　　这种中间值通过间接引用作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>使用，也是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">一种间接值</a>，即引用值。</p>
<h4 id="子对象引用"><a class="header" href="#子对象引用">子对象引用</a></h4>
<p>　　特定的引用值是<em>子对象引用(subobject reference)</em> ，其被引用对象是被另一个对象所有的、作为这个对象的<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的一等对象。</p>
<p>　　子对象引用对特定操作可表现和其它一等对象不同的行为。</p>
<p>　　以下引用是子对象引用：</p>
<ul>
<li><em>子有序对引用(subpair reference)</em> 是<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">子有序对</a>作为被引用对象的引用。</li>
<li><em>子列表引用(sublist reference)</em> 是<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">子列表</a>作为被引用对象的引用。</li>
</ul>
<p>　　语言可能引入其它的子对象引用。</p>
<h4 id="引用值的有效性"><a class="header" href="#引用值的有效性">引用值的有效性</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">作为</a>一种<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>，引用值有效当且仅当访问被引用对象不引起未定义行为。</p>
<p>　　以下约定要求被 NPLA 实现支持的有效的引用值总是无条件地允许访问对象。</p>
<p>　　有效的引用值应通过特定的构造方式引入，包括：</p>
<ul>
<li>在对象语言通过被引用对象初始化引用值。</li>
<li><a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>引入的保证不引起未定义行为的引用值。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　一些对象语言的操作可能引起引用值无效。例如，<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">改变</a>被引用对象可以使已被初始化的有效的引用值成为<em>悬空引用(dangling reference)</em> 。</p>
<h4 id="多重引用"><a class="header" href="#多重引用">多重引用</a></h4>
<p>　　被引用对象也可以是引用值。</p>
<p>　　被引用对象不是引用值的引用值是<em>完全折叠(fully collapsed)</em> 的。</p>
<p>　　除非另行指定，<em>未折叠的(uncollapsed)</em> 引用值指未完全折叠的引用值。</p>
<p><strong>注释</strong></p>
<p>　　这和宿主语言不同。</p>
<h4 id="引用值的属性"><a class="header" href="#引用值的属性">引用值的属性</a></h4>
<p>　　引用值可以具有和作为引用值<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">表示</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>保存的<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">属性</a>相互独立的属性，保存其作为一等对象的状态。</p>
<p>　　属性不可分割：一个引用值明确具有或者不具有一种属性。</p>
<p>　　和<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">对象属性</a>对应，NPLA 指定的引用属性可以是：</p>
<ul>
<li>唯一引用。</li>
<li>不可修改引用。</li>
<li><a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>引用。</li>
</ul>
<p>　　引用值属性指定通过引用对<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的访问假定允许具有的性质，即便被引用对象自身没有具有这些属性。</p>
<p>　　特定的操作使用引用值作为操作数，根据不同的属性决定行为，包括在违反属性引入的假定时<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　在本节要求以外，除非派生实现另行指定，违反这些假定不引起 <a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">NPLA 未定义行为</a>。</p>
<p>　　具体的引用属性满足以下语义规则：</p>
<ul>
<li>唯一引用允许通过引用值访问被引用对象时，对象可被假定不被其它引用而仅通过这个途径访问，即便实际存在其它途径的引用时可能引起不同的行为；在假定的基础上程序具有何种可能的行为是未指定的。</li>
<li>唯一引用可被假定不被共享，被引用对象不被<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%88%AB%E5%90%8D">别名</a>。</li>
<li>通过不可修改引用的左值的对象访问不包含<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">修改</a>。否则，若没有引起错误，程序<a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">行为未定义</a>；但除非另行指定，不引起<a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">宿主语言的未定义行为</a>。</li>
<li>具有临时对象引用属性的引用值是临时对象的引用值，其被引用对象是临时对象。</li>
</ul>
<p><strong>原理</strong> 宿主语言的互操作不被总是要求保证对象语言程序的可移植性，但不应引起实现自身的行为无法预测。</p>
<p>　　对引用值的操作<em>传播(propagate)</em> 特定的引用属性，当且仅当：</p>
<p>　　若操作数是具有特定引用属性的引用值，且结果是引用值时，结果具有和操作数相同的特定属性。</p>
<p><strong>注释</strong></p>
<p>　　引用值属性和对象属性相互独立，类似 [ISO C] 和 [ISO C++] 在指针和引用等复合类型的 <code>const</code> 等限定独立于指向的对象或被引用对象上的类型不同。通过 <code>const</code> 等属性可以在指针或引用类型上单独限制类型，而不影响对应的被间接访问的对象。</p>
<p>　　唯一引用蕴含的假定类似 [ISO C] 约定的 <code>restrict</code> 关键字，但程序违反假定的约束时不引起未定义行为。</p>
<p>　　和 [ISO C++] 核心语言（但不是 <a href="https://eel.is/c++draft/res.on.arguments">[res.on.arguments]</a> 中的标准库绑定到右值引用实际参数的约定）的右值引用类似，唯一引用不总是表示被引用对象不被共享。</p>
<p>　　接受唯一引用的操作可能只假定被引用对象的<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>不被共享，也可能完全不进行假定，这依赖具体操作的语义。若需要和具体操作无关的无条件非共享假定，使用<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>而非作为左值的唯一引用。</p>
<p>　　和宿主语言的 <code>const</code> 限定类型类似，不可修改引用仅针对特定左值的访问；通过共享的其它未被限定的引用仍可修改对象。</p>
<p>　　违反不可修改引用引入的假定的错误可能通过<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>或其它方式引起。</p>
<p>　　临时对象引用类似 [ISO C++] 的<em>转发引用(forwarding reference)</em> 中保留在表达式声明中的类型信息。</p>
<p>　　因为 NPLA 不支持声明元数据，这些信息保存在对象的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>中，且在初始化时被引用值保存；也因此<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">这些元数据可跟随一等对象传递</a>。对临时对象，<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">绑定操作</a>可确保<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">元数据被添加</a>。</p>
<p>　　这也和宿主语言不同。在宿主语言中：</p>
<ul>
<li>无论是标记消亡值的右值引用类型还是标记是否可转发的引用的转发引用推断的类型信息（左值引用或右值引用）都是静态的。</li>
<li>并且，转发的类型信息只在函数模板的局部有效，而不存在对应的跨过程传递机制。</li>
</ul>
<h4 id="引用值的消除"><a class="header" href="#引用值的消除">引用值的消除</a></h4>
<p>　　作为<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>，引用值可被<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">消除</a>，即被其<a href="Features/NPL.zh-CN.html#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">（可能多重）引用</a>关联的被引用对象替代。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">未折叠的引用值</a>消除一次引用值，结果仍是引用值。</p>
<p>　　消除<a href="Features/NPL.zh-CN.html#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">完全折叠的引用值</a>的结果总是<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">右值</a>。</p>
<p>　　推论：因为引用值不<a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>自身，除非引用值<a href="Features/NPL.zh-CN.html#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">已完全折叠</a>，继续消除引用值得到的值和引用值是不同的值。</p>
<p><strong>原理</strong></p>
<p>　　特定的引用值消除可蕴含对不可修改的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">传播</a>的要求。这和 [ISO C++] 初始化引用时遵循的 <code>const</code> 安全性，属于类型安全性的一种。</p>
<p>　　但是，消除引用不一定总是预期这种性质，特别当折叠不被预期时。</p>
<p>　　例如，[ISO C++] 内建指针的不同级 <code>const</code> 不会被隐式转换直接折叠合并。消除间接的指针值不是隐式的（而依赖内建一元 <code>*</code> 操作符），这是因为指针作为类型构造器自身的类型安全需要；是否消除 <code>const</code> 限定符仍然需要基于其它理由考虑。</p>
<p>　　而当被引用对象实现子对象时，修饰被指向的类型的 <code>const</code> 不会自动传播到子对象的类型中，此时可有 <code>std::experimental::propagate_const</code> 可选引入这种性质。</p>
<p>　　对具有非间接访问的子对象的类型，这相当于 [ISO C++] 的 <code>mutable</code> 修饰符，可实现<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">内部可变性</a>。而允许子对象以外直接不传播不可变性，是一种结构性的平凡的扩展：这允许把被引用对象直接视为一种子对象的实现，而非要求引入新的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义类型</a>。</p>
<p>　　在 NPLA 这样没有要求显式类型编码是否可变的语言中，首先要求总是具有不可修改的传播性质会显著增加规则形式上的复杂性。若具体操作需要传播不可修改性，仍可进一步约定。</p>
<p><strong>注释</strong></p>
<p>　　典型地，消除引用值包括：</p>
<ul>
<li>当<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">引用值提升转换</a>的操作数是引用值时，消除被提升的引用值。</li>
<li>当<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">引用折叠</a>的操作数是引用值时，消除被折叠的引用值。</li>
</ul>
<p>　　和引用折叠不同，引用值提升转换不满足对不可修改引用属性的传播性质。</p>
<h4 id="引用折叠"><a class="header" href="#引用折叠">引用折叠</a></h4>
<p>　　和 [ISO C++] 类似，引用值在 NPLA 中默认不被继续引用，使用引用初始化引用会引用到<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>上，即<em>引用折叠(reference collapse)</em> 。</p>
<p>　　引用值被折叠后结果和原引用值不同，当且仅当原引用值是<a href="Features/NPL.zh-CN.html#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">未折叠的引用值</a>。</p>
<p>　　和 [ISO C++] 不同，NPLA 不限制派生实现利用未折叠的引用值。</p>
<p><strong>注释</strong> 特定的操作可能区分未折叠的引用值。</p>
<p>　　引用折叠的结果是不可修改引用，若引用值和作为引用值的被引用对象之一是不可修改引用。</p>
<p>　　引用折叠的结果满足不可修改<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用属性的传播性质</a>。推论：</p>
<ul>
<li>引用折叠的结果是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">唯一引用</a>，当且仅当引用值和作为引用值的被引用对象都是唯一引用。</li>
<li>引用折叠的结果是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">临时对象引用</a>，当且仅当被引用对象是临时对象引用。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　内部表示可支持间接的引用，以允许在对象语言中实现<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">一等引用</a>。</p>
<p>　　引用折叠对不可修改的传播性质的要求和 [ISO C++] 的引用折叠对 <code>const</code> 限定符的处理类似。</p>
<p>　　引用折叠对唯一引用的要求和 [ISO C++] 的右值引用仅通过被折叠的引用都是右值引用类型折叠类似。注意 [ISO C++] 右值引用推断仅用于推断转发引用(forwarding reference) 参数，而非直接声明特定的右值引用类型。</p>
<p>　　和唯一引用不同，临时对象相对唯一引用更接近 [ISO C++] 的声明的右值引用类型信息（而非推断值类别时使用的消亡值表达式的右值引用类型），一般不预期被折叠。</p>
<p><strong>注释</strong></p>
<p>　　未折叠的引用值被折叠时，用于初始化的被引用对象可能仍然是未折叠的引用值。</p>
<h4 id="对象的可转移条件"><a class="header" href="#对象的可转移条件">对象的可转移条件</a></h4>
<p>　　根据项是否具有特定元数据的引用值可判断使用复制代替<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">对象转移的条件</a>。</p>
<p>　　对象的<em>可转移(movable)</em> 条件的判断基于首先基于<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B">值的类型</a>：</p>
<ul>
<li>非引用值（纯右值）总是可转移的。</li>
<li>否则，对象是引用值。可转移由<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用值的属性</a>决定：当引用值是唯一引用且非不可修改，引用值是可转移引用，对应的被引用对象是可转移的。</li>
</ul>
<h4 id="引用值的表示"><a class="header" href="#引用值的表示">引用值的表示</a></h4>
<p>　　作为引用值的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>，<em>引用项(reference term)</em> 是包含<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">项引用</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>。</p>
<p>　　引用项中的项引用对象引用一个（其它的）项，即<em>被引用项(referenced term)</em> ，用于在必要时引入可被引用的一个项而不在 TermNode 中直接储存这个项的值。</p>
<p>　　被引用项表示引用项作为引用值对应的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>。</p>
<p>　　引用项在作为<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象</a>外，<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">保存标签</a>作为<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用值的属性</a>的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>可作为引用值的被引用对象。</p>
<p>　　与此不同，非临时对象的引用值可作为一等对象而总是需要区分作为不同对象的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>。</p>
<p>　　带有<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">临时对象属性</a>的引用值可在特定的操作中被视为和临时对象引用近似的引用值。</p>
<p>　　子对象引用的表示是<em>子对象引用项(subojbect reference term)</em> ，和本节中的其它引用类型的表示兼容，但不完全相同。</p>
<p>　　关于引用项的构成，另见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　因为<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象不是一等对象</a>，临时对象的引用值可代替关联的被引用对象使之作为一等对象被访问。</p>
<p>　　为在对象语言中区分引用值和非引用值的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>是必要的，引用项这样的特设表示是必要的。</p>
<p>　　非引用项的表示则是针对临时对象的一种优化，因为使<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>总是在作为引用值的表示而：</p>
<ul>
<li>相比通常的间接值，避免间接<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>关联的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的开销。</li>
<li>避免<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7">悬空引用</a>。</li>
</ul>
<p>　　带有临时对象属性的引用值和临时对象的引用值不同，参见<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">绑定临时对象属性</a>。</p>
<h4 id="引用值的子类型"><a class="header" href="#引用值的子类型">引用值的子类型</a></h4>
<p>　　根据表示和属性，引用类型具有如下<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>：</p>
<ul>
<li><em>左值引用(lvalue reference)</em> ：以引用项表示的非<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">唯一引用</a>。</li>
<li><em>右值引用(rvalue reference)</em> ：以引用项表示的唯一引用。</li>
</ul>
<p>　　引用值是否作为<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>使用取决于上下文。除非另行指定，引用值都是左值。</p>
<p><strong>注释</strong> 在要求右值的上下文发生<a href="Features/NPL.zh-CN.html#%E9%BB%98%E8%AE%A4%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2%E7%BA%A6%E5%AE%9A">左值到右值转换</a>。</p>
<p>　　引入不同的引用子类型后，NPLA 一等对象的值的类型和<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">值类别</a>存在以下一一对应关系：</p>
<ul>
<li>若类型是左值引用，则对应的值类别是左值。</li>
<li>若类型是右值引用，则对应的值类别是消亡值。</li>
<li>否则，对应的值类别是右值。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　左值引用和左值引用与宿主语言中的对象类型的左值引用与右值引用分别类似。</p>
<p><strong>注释</strong></p>
<p>　　在要求右值的上下文，作为左值的引用值发生<a href="Features/NPL.zh-CN.html#%E9%BB%98%E8%AE%A4%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2%E7%BA%A6%E5%AE%9A">左值到右值转换</a>。</p>
<h3 id="值类别转换"><a class="header" href="#值类别转换">值类别转换</a></h3>
<p>　　具有特定值类别的表达式可转换为不同值类别的表达式：</p>
<ul>
<li>除非另行指定，泛左值总是允许作为纯右值使用。从泛左值取对应右值的操作称为<em>左值到右值转换(lvalue-to-rvalue conversion)</em> 。</li>
<li>从纯右值<a href="Features/NPL.zh-CN.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a>可被对象语言作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>使用的<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的引用值作为<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">消亡值</a>，称为<em>临时对象实质化转换(temporary materialization conversion)</em> 。</li>
</ul>
<p>　　左值到右值转换没有<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">副作用</a>。临时对象实质化转换没有副作用，当且仅当其中初始化临时对象时没有副作用。</p>
<p>　　临时对象实质化转换中，纯右值被<em>实质化(materialized)</em> 。</p>
<p>　　在求值子表达式时，按表达式具有的语义，必要时（如按<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%80%BC%E7%B1%BB%E5%88%AB">相关规则</a>判断上下文的值类别）进行值类别转换。</p>
<p>　　NPLA 还提供可能使结果具有不同的值类别的<em>引用值提升转换(reference value lifting conversion)</em> 。以下规则确定引用值提升转换的结果：</p>
<ul>
<li>若操作数是引用值，则结果是操作数的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>。</li>
<li>否则，结果是操作数。</li>
</ul>
<p>　　引用值提升转换蕴含引用<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">提升</a>，即使用被引用对象替换操作数。</p>
<p><strong>原理</strong></p>
<p>　　为支持<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>作为一等对象（特别是<a href="Features/NPL.zh-CN.html#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">未折叠的引用值</a>），NPLA 提供比左值到右值转换更精细的引用值提升转换。</p>
<p>　　值类别转换在特定求值中适用，因此不影响构造性的规则。</p>
<p>　　特别地，列表左值（列表的引用值）不能代替列表，因此以空列表的引用作为最后一个元素的嵌套有序对是<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">非真列表</a>。这和 [R<sup>7</sup>RS] 约定空列表总是同一对象不同。</p>
<p>　　这种设计使语言规则更容易在局部一致，同时显著减少实现（对象内部表示）的复杂性，并有助于提升实现性能的可预测性。</p>
<p><strong>注释</strong></p>
<p>　　不同值类别表达式的转换和宿主语言中的部分标准转换类似。</p>
<p>　　根据引用值的性质，易知左值到右值转换的规约是引用值提升转换的规约的传递闭包，即：</p>
<ul>
<li>若操作数是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">已完全折叠的引用值</a>，则引用值提升转换等价左值到右值转换。</li>
<li>否则，有限次的引用值提升转换等价左值到右值转换。</li>
</ul>
<p>　　引用值提升转换不<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">传播引用值的属性</a>，参见<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%B6%88%E9%99%A4">引用值的消除</a>。</p>
<p>　　引用值提升转换不传播不可修改属性，类似 [ISO C++] 非引用值的转换在结果中不保留源操作数中的 <code>const</code> 类型。</p>
<p>　　临时对象实质化可实现为空操作，因为项在先前（如<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>蕴含的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">引用值提升转换</a>对<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E8%A1%A8%E7%A4%BA">引用项</a>的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">提升操作</a>的实现中）已被创建。</p>
<p>　　互操作可能引入不以项表达的右值而需要首先创建项。</p>
<h4 id="默认值类别转换约定"><a class="header" href="#默认值类别转换约定">默认值类别转换约定</a></h4>
<p>　　除非另行指定：</p>
<ul>
<li>作为<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作符</a>的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>没有值类别转换。</li>
<li>作为<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>的表达式仅在必要时进行一次左值到右值转换。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　类似宿主语言规则，并非所有上下文都需要转换。类似地，宿主语言的操作符（括<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>的第一个子表达式）可直接使用左值而不需要转换。但和宿主语言不同，因为<a href="Features/NPL.zh-CN.html#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">多重引用</a>，不确定次数的连续的转换结果不同。因此除了上下文要求，有必要约定默认仅转换一次，而非确保转换结果到右值。</p>
<p>　　必要时，具体<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作</a>仍可指定不同的规则。</p>
<p>　　值类别和左值到右值转换在一些上下文的行为类似箱和自动拆箱，约定存在默认转换并不利于维护<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>：</p>
<ul>
<li>特别地，和宿主语言不同，函数不包含充分的信息（参数类型）推断是否接受左值操作数，因此在不提供针对函数的<em>重载(overloading)</em> 一般机制的前提下，<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>不能预知输入的操作数是否是左值，通常需分别支持左值和右值的操作数。</li>
<li>即便提供重载，仍然较单一的值类别更复杂。</li>
</ul>
<p>　　但 NPLA 的设计中，值类别转换已被通过<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确</a>反映需求的<a href="Features/NPL.zh-CN.html#%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">存储和对象模型</a>的设计隐含在项的内部性质中，因此不是可选的。</p>
<p>　　由<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性的优先规则</a>，<a href="Features/NPL.zh-CN.html#%E5%AE%8C%E6%95%B4%E6%80%A7">完整性</a>应先于简单性被满足。</p>
<p>　　而考虑<a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">统一性</a>，对存储和对象模型的设计，用户自行的实现仍要求这些设施（尽管更困难）。</p>
<p>　　关于箱和自动装箱，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h4 id="返回值转换"><a class="header" href="#返回值转换">返回值转换</a></h4>
<p>　　<em>返回值转换(return value conversion)</em> 是一次引用值提升转换和可选的一次临时对象实质化转换的顺序复合。</p>
<p>　　返回值转换用于在对象语言中确定函数调用的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>可包含<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数体</a>的求值结果到返回值的转换。</p>
<p>　　引用值作为间接值，适用<a href="Features/NPL.zh-CN.html#%E5%B1%80%E9%83%A8%E9%97%B4%E6%8E%A5%E5%80%BC%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">局部间接值安全保证</a>。在<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87">返回值转换上下文</a>中确定函数返回值的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E8%B4%A8%E5%8C%96%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87">实质化转换上下文</a>的部分操作<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%B6%88%E9%99%A4">消除引用值</a>，即返回值转换，是这种情形的主要实例。</p>
<p>　　这可约束作为间接值的<a href="Features/NPL.zh-CN.html#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">完全折叠的引用值</a>不<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">逃逸</a>（因此<a href="Features/NPL.zh-CN.html#%E5%B1%80%E9%83%A8%E9%97%B4%E6%8E%A5%E5%80%BC%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">访问被引用对象的值可不超出指向对象的存储期</a>），而保证只考虑项可能是引用值时的内存安全。</p>
<p>　　除非证明不需要<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>，返回值转换中初始化临时对象作为返回值的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象</a>，否则临时对象被<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4">复制消除</a>。是否存在复制消除是未指定行为。</p>
<p>　　不论是否存在返回值转换，返回值的项对象来自返回的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">右值</a>关联的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">临时对象实质化转换</a>。这可能在返回值转换蕴含的<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">项提升</a>操作或之前的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值规约</a>中蕴含。</p>
<p><strong>注释</strong></p>
<p>　　返回值转换不保证<a href="Features/NPL.zh-CN.html#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">未折叠的引用值</a>在消除引用值后的结果不逃逸。</p>
<p>　　为确保内存安全，程序仍需要保证被引用的对象的间接引用的对象生存期结束后，不能访问间接引用的对象。</p>
<p>　　其它间接值的内存安全需要另行保证。</p>
<p>　　是否需要返回值转换由实质化转换上下文中的被调用的函数而非上下文是否需要使用右值决定，无关被转换的表达式是否是左值，因此返回值转换不是<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">左值到右值转换</a>。</p>
<p>　　当前未实现是否需要临时对象的证明。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象和关联对象所有权</a>和<a href="Features/NPL.zh-CN.html#%E5%B1%80%E9%83%A8%E9%97%B4%E6%8E%A5%E5%80%BC%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">局部间接值安全保证</a>。</p>
<h3 id="临时对象"><a class="header" href="#临时对象">临时对象</a></h3>
<p>　　特定的 <a href="Features/NPL.zh-CN.html#npla-%E5%9F%BA%E7%A1%80%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">NPLA 非一等对象</a>是<em>临时对象(temporary object)</em> 。</p>
<p>　　NPLA 允许（但不要求对象语言支持）一等对象构成的表达式通过特定的求值，在中间结果中蕴含这种非一等对象。</p>
<p><strong>注释</strong> 这样的非一等对象不在源语言中可见，一般仅用于<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>。</p>
<p>　　临时对象的<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>不是临时对象。</p>
<p>　　NPLA 对象语言在特定的上下文引入其它临时对象，包括：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%AE%9E%E8%B4%A8%E5%8C%96%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87">实质化转换上下文</a>。</li>
<li><a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87">返回值转换上下文</a>。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　为简化规约和互操作机制的设计，和 [ISO C++17] 不同，引入临时对象不包括延迟初始化或异常对象的创建。</p>
<p>　　关于临时对象的子对象的规则，参见<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">绑定临时对象</a>中的原理。</p>
<p><strong>注释</strong></p>
<p>　　关于临时对象的存储和所有权，参见<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">求值和对象所有权</a>。</p>
<p>　　关于临时对象的表示，参见<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%A8%E7%A4%BA">临时对象的表示</a>。</p>
<p>　　关于避免特定相关对象的<a href="Features/NPL.zh-CN.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a>的要求，参见<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4">复制消除</a>。</p>
<p>　　引入临时对象的一些上下文的和宿主语言类似。</p>
<h4 id="实质化转换上下文"><a class="header" href="#实质化转换上下文">实质化转换上下文</a></h4>
<p>　　可具有（但不保证具有）<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">临时对象实质化转换</a>的上下文包括：</p>
<ul>
<li>使用纯右值初始化被绑定为<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>的变量（如函数的引用类型的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">形式参数</a>）。</li>
<li>求值<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>以初始化<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　一般地，被绑定为引用值的变量在<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">活动调用</a>关联的环境分配临时对象。此时，对象被调用表达式的项独占所有权，同时被绑定的环境独占资源所有权，并实现<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4">复制消除</a>。</p>
<p>　　在不具有转换时，优化的实现可能消除函数调用（内联(inline) 展开）而不分配关联的环境，把临时对象分配到其它环境或者语言不保证可见的存储（如 CPU 寄存器）中，并同时实现复制消除。</p>
<p>　　临时对象实质化转换引入临时对象的规则和 [ISO C++17] 不同：</p>
<ul>
<li>不论表达式是否作为子表达式使其值被使用（未使用的情形对应 [ISO C++] 中的 discarded-value expression ），都允许存在临时对象。</li>
<li>要求复制消除而避免特定对象的<a href="Features/NPL.zh-CN.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a>。</li>
</ul>
<h4 id="返回值转换上下文"><a class="header" href="#返回值转换上下文">返回值转换上下文</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>可引入实质化的临时对象，其中<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%AF%E8%BD%AC%E7%A7%BB%E6%9D%A1%E4%BB%B6">可能转移求值</a>的中间结果；否则，对象被复制。</p>
<p>　　此处被转移对象符合<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">求值和对象所有权</a>规则中的临时对象的定义，但除非另行指定，被转移的对象不在对象语言中可被访问。</p>
<p>　　仅在对象被复制且复制具有副作用时，返回值转换具有等价复制的副作用。</p>
<h4 id="复制消除"><a class="header" href="#复制消除">复制消除</a></h4>
<p>　　NPLA 要求特定上下文中的<em>复制消除(copy elision)</em> ，排除复制或转移操作且保证被消除操作的源和目的对象的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">同一性</a>。</p>
<p>　　复制消除仅在以下转换上下文中被要求，即直接使用被转换的源表达式中的对象作为实质化的对象而不初始化新的临时对象：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%AE%9E%E8%B4%A8%E5%8C%96%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87">实质化转换上下文</a>。</li>
<li>引起对象转移至<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>的<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87">返回值转换上下文</a>。</li>
</ul>
<p>　　非<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>函数的函数体内指定的返回值不属于上述的确定返回值的上下文，但也不要求被复制消除。</p>
<p>　　实现仍可根据<a href="Features/NPL.zh-CN.html#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>来判断是否在允许消除对象复制的上下文中，而进行复制消除。</p>
<p>　　复制消除不在被初始化对象以外引入新的对象语言可见的对象。</p>
<p><strong>原理</strong></p>
<p>　　为维护语言规则的<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>和使用这些规则的程序的行为的<a href="Features/NPL.zh-CN.html#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测性</a>，NPLA 的复制消除限于临时对象的消除。</p>
<p>　　在完成实质化转换前的不完整的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E8%A7%84%E5%88%99%E5%92%8C%E6%B1%82%E5%80%BC">求值规约</a>中的临时对象在逻辑上不需要作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>存在，但纯右值作为对象<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>中的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">子项</a>，随纯右值在宿主语言中作为对象存在，以允许互操作。</p>
<p>　　复制消除的目的 [ISO C++17] 类似。同时，提供语言支持也允许更简单地实现 C++ 互操作性。</p>
<p>　　和 [ISO C++17] 不同的一些要求可简化语言规则和实现，例如：</p>
<ul>
<li>不区分求值结果是否被作为<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>或求值是否为常量表达式。</li>
<li>非<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>函数的规则不要求 <code>return</code> 语句中的特定的表达式，而不需要依赖特定上下文的语法性质。</li>
<li>同时，NPLA 不限制对象的类型（[ISO C++17] 则要求特定的 C++ 类类型）。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　在实现中，被转换的源表达式中的对象是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">待求值项</a>的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象</a>。</p>
<p>　　当前未实现按当前环境判断是否在允许消除对象复制的上下文中进行复制消除。</p>
<h4 id="生存期扩展"><a class="header" href="#生存期扩展">生存期扩展</a></h4>
<p>　　在使用<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>初始化<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>时，<em>扩展(extend)</em> 源表达式的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象</a>的<a href="Features/NPL.zh-CN.html#%E7%94%9F%E5%AD%98%E6%9C%9F%E9%99%84%E5%8A%A0%E7%BA%A6%E5%AE%9A">生存期</a>使之比其它规则决定的生存期延长。</p>
<p>　　这和初始化非引用值类似，但实现需区分是否初始化的是延长生存期的临时对象，以确保之后能区分引用值初始化时是否<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按引用传递</a>。</p>
<h4 id="绑定临时对象属性"><a class="header" href="#绑定临时对象属性">绑定临时对象属性</a></h4>
<p>　　若<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E8%B4%A8%E5%8C%96%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87">实质化转换上下文</a>支持<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">绑定临时对象</a>，按引用绑定（即绑定初始化使用<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按引用传递</a>）的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>是<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>。</p>
<p>　　引入引用值的形式参数需要满足的要求由引入绑定的操作或派生实现指定。</p>
<p><strong>原理</strong></p>
<p>　　绑定临时对象时指定临时对象属性允许区分<a href="Features/NPL.zh-CN.html#%E7%94%9F%E5%AD%98%E6%9C%9F%E6%89%A9%E5%B1%95">通过引用绑定延长生存期的临时对象</a>和非引用绑定的对象。</p>
<p>　　一般地，表达式中的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>（非引用值）被绑定为临时对象，即被绑定的对象在初始化后具有<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">临时对象属性</a>。</p>
<p>　　这对应宿主语言中的转发引用参数（如 <code>std::forward</code> ）中的情形：</p>
<ul>
<li>若模板参数 <code>P</code> 对应转发引用函数参数 <code>P&amp;&amp;</code> ，其中 <code>P</code> 是对象或对象的右值引用类型，保留从实际参数<em>推导(deduce)</em> 得到的但不是实际参数类型的信息。</li>
<li>没有绑定临时对象属性的对象则同一般的非引用类型的对象类型参数（非转发引用）。</li>
</ul>
<p>　　<code>P</code> 在宿主语言中通过值类别推断，但不表示值类别。</p>
<p>　　类似宿主语言，这种操作数表达式的值类别以外的形式是一种<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">类型推断</a>。因为推断规则和宿主语言的<em>类型推导(type deducing)</em> 相似，这种上下文可支持类似宿主语言的参数转发。但和宿主语言的 <code>std::forward</code> 不同，此处推断的右值除了是<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">消亡值</a>外，也可以是<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>。</p>
<p>　　临时对象属性在绑定特定形式的参数时具有和 <code>P</code> 编码的附加信息类似的作用：</p>
<ul>
<li>不具有临时对象属性的引用值作为<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>，在初始化临时对象的引用时被视为<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>（不影响其余属性）。</li>
<li>其它表达式的推断结果是右值。</li>
</ul>
<p>　　带有临时对象属性的引用值和临时对象的引用值不同。特别地，作为引用属性值的临时对象属性允许在<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">运行时</a>作为对象的元数据<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>以及跟随对象被跨过程传递，这无法被宿主语言支持，因为 <code>P</code> 表示的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态类型</a>信息不在函数外可用，仅在模板的类型参数 <code>P</code> 中而不在运行时可访问的元数据中（事实上，也不在对象的动态类型中）保留。关于其应用，参见<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">进一步讨论</a>。</p>
<p><strong>注释</strong></p>
<p>　　因为宿主语言的引用折叠，以上 <code>P</code> 和 <code>P&amp;&amp;</code> 一致。</p>
<p>　　被绑定的这些对象可作为临时对象引用关联的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">绑定操作</a>。</p>
<h4 id="临时对象的表示"><a class="header" href="#临时对象的表示">临时对象的表示</a></h4>
<p>　　作为一等对象的临时对象和其它一等对象表示方式一致。</p>
<p>　　非一等对象临时对象包括：</p>
<ul>
<li>所有权可<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">被项独占</a>而不能作为一等对象访问的对象。</li>
<li>具有<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">临时对象标签</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>作为内部表示的对象。</li>
</ul>
<p>　　对临时标签对象决定的非一等对象，去除临时对象标签后，应具有一等对象表示。</p>
<p>　　在<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E8%A1%A8%E7%A4%BA">项引用</a>以外的临时对象标签仅在<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>上存在。</p>
<p>　　关于一等对象表示，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　至少在逻辑上，临时对象作为对象语言中不可见的对象和一等对象相同的宿主类型（即项）作为内部表示。因此，区分其内部表示并非通过宿主语言中的类型，而需通过运行时性质确定。</p>
<p>　　一些表示可能仅出现在临时对象中，而不是合法的一等对象表示。实现可据此进行一定运行时检查，以排除<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>或者错误实现中的误用。</p>
<p>　　对临时对象标签决定的非一等对象和一等对象表现之间的要求简化实现的一些操作，使<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">实质化</a>不需依赖另行分配的资源。</p>
<p>　　临时对象的子对象不是临时对象，简化对临时对象的一些操作，也减少可能使临时对象标签扩散（到非预期的上下文影响一等对象表示）而误用。</p>
<p>　　关于被绑定对象的规则，参见<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">绑定临时对象</a>中的原理。限制标签的使用范围以使之不和其它表示冲突。</p>
<p>　　关于实现中项的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>和简化实现的例子，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>注释</strong></p>
<p>　　直接构成项的非一等对象可以是通过<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源代码</a>中的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">外部表示</a>经<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">翻译</a>变换得到的具有内部表示的数据结构的非一等对象，参见上述实现中项的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>。</p>
<h3 id="表达式的类型"><a class="header" href="#表达式的类型">表达式的类型</a></h3>
<p>　　NPLA 的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">类型系统</a>使用<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">隐式类型</a>；默认使用<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">潜在类型</a>，保证<a href="Features/NPL.zh-CN.html#npla-%E6%95%B4%E4%BD%93%E7%BA%A6%E5%AE%9A">表达式的值具有类型</a>。</p>
<p>　　NPLA 表达式的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型</a>是表达式<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>的类型。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">空求值</a>的求值结果要求未求值的<a href="Features/NPL.zh-CN.html#%E7%BF%BB%E8%AF%91%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%A7%84%E5%88%99">合式的</a>表达式应具有和<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">语法分析</a>的实现的输出兼容的类型。</p>
<p>　　实现对特定的上下文的表达式可使用<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">类型推断</a>。由此确定的类型类似宿主语言的表达式的类型。</p>
<p>　　表达式具有<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">值类别</a>。值类别的指派规则作为<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">定型规则</a>是<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%80%BC%E7%B1%BB%E5%88%AB">类型系统的一部分</a>。但除非另行指定，值类别和 NPLA 及派生语言规则中描述的表达式的类型<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E4%BA%A4%E6%80%A7">正交</a>。</p>
<p>　　关于语法分析的实现和其中处理的类型，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>注释</strong></p>
<p>　　类型系统和 Scheme 及 Kernel 语言类似；除了表达式具有值类别这点和 Scheme 和 Kernel 不同而类似宿主语言。</p>
<p>　　表达式的类型和 [R<sup>7</sup>RS] 的 expression type 无关，后者是<a href="Features/NPL.zh-CN.html#%E8%AF%AD%E6%B3%95%E5%BD%A2%E5%BC%8F">语法形式</a>的约定（在 [R<sup>5</sup>RS] 和 [R<sup>7</sup>RS] 中称为 form ）；因为存在<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>的类型，不需要这种约定。</p>
<p>　　NPLA 中值类别和表达式的类型正交，这类似宿主语言。这简化了相关<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型规则</a>的描述。</p>
<h2 id="生存期附加约定"><a class="header" href="#生存期附加约定">生存期附加约定</a></h2>
<p>　　和宿主语言不同，NPLA 子表达式的求值顺序可被不同的函数（特别允许显式指定对特定<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>求值的<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">操作子</a>）中的求值调整，不需要特别约定。</p>
<p>　　NPLA 不存在宿主语言意义上的<a href="Features/NPL.zh-CN.html#%E4%B8%A5%E6%A0%BC%E6%80%A7">完全表达式</a>，但在按宿主语言规则判断生存期时，使用<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>的<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">函数合并</a>视同宿主语言的完全表达式，其本机函数调用不引起函数内创建的对象的生存期被延长。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的<a href="Features/NPL.zh-CN.html#npla-%E5%9F%BA%E7%A1%80%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">生存期</a>同时约束隐含的隐式宿主函数调用（如复制构造）。</p>
<p>　　为保证求值表达式取得的临时对象的<a href="Features/NPL.zh-CN.html#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>，函数合并同时满足以下规则：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作符</a>和未被求值的操作数的直接或间接子表达式关联的对象以及求值操作数的子表达式引入的临时对象的生存期结束的作用应不<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">后序</a>于<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">活动调用</a>结束。</li>
<li>生存期起始和结束的顺序被确定(determined) 时，和对应所在的表达求值之间的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序</a>关系同构；否则，其顺序满足<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">非决定性有序</a>关系。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　生存期的顺序约束确保引入临时对象时，其生存期不会任意地被<a href="Features/NPL.zh-CN.html#%E7%94%9F%E5%AD%98%E6%9C%9F%E6%89%A9%E5%B1%95">扩展</a>而超过<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>的求值。</p>
<p>　　具体操作可在以上约束下指定被求值的操作数可能引入的临时对象的生存期。</p>
<h2 id="尾上下文约定"><a class="header" href="#尾上下文约定">尾上下文约定</a></h2>
<p>　　NPLA 表达式<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值规约</a>中最后一个规约步骤中的上下文是<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">尾上下文</a>。</p>
<p>　　尾上下文在 NPLA 中可满足一些附加的性质。</p>
<h3 id="真尾规约"><a class="header" href="#真尾规约">真尾规约</a></h3>
<p>　　尾上下文涉及的存储在特定情况下满足调用消耗的空间有上界（即空间复杂度 <tt>O(1)</tt> ）。</p>
<p>　　满足这种情况下的规约称为<em>真尾规约(proper tail reduction)</em> 。</p>
<h3 id="尾调用和-ptc"><a class="header" href="#尾调用和-ptc">尾调用和 PTC</a></h3>
<p>　　在尾上下文规约的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">调用</a>是<em>尾调用(tail call)</em> 。</p>
<p>　　以<a href="Features/NPL.zh-CN.html#%E7%9C%9F%E5%B0%BE%E8%A7%84%E7%BA%A6">真尾规约</a>的实现尾调用允许具有不限定数量的(unbounded) <a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">活动调用</a>，称为 PTC（proper tail call ，真尾调用）。</p>
<p>　　PTC 占用<a href="Features/NPL.zh-CN.html#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">活动记录</a>满足真尾规约的上界的要求。</p>
<p>　　当宿主语言提供函数调用支持 PTC 时，可直接使用宿主语言的 PTC 调用，否则，需要使用其它替代实现机制确保 PTC 。</p>
<p>　　非对象语言的调用的上下文中，若被调用时间接使用，也仍需要保证 PTC 。</p>
<p>　　PTC 确保仅有一个<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">活动</a>的调用。不满足 PTC 的情形下，语言没有提供用户访问非<a href="Features/NPL.zh-CN.html#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">活动记录帧</a>资源的手段，因此可以认为是资源泄漏。但为简化语义规则，NPLA <a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">不要求避免相关的弱内存泄漏</a>。</p>
<p>　　NPL 不保证一般对象存在<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>，NPLA 也不添加保证活动记录帧中保存引用，销毁活动记录的帧可能影响环境中的变量生存期而改变语义。</p>
<p>　　因此，除非依赖本节中以下的规则，NPLA 不保证 PTC 支持；实现更一般的 PTC 依赖派生实现定义的附加规则。</p>
<p>　　为满足 PTC ，在<a href="Features/NPL.zh-CN.html#%E7%94%9F%E5%AD%98%E6%9C%9F%E9%99%84%E5%8A%A0%E7%BA%A6%E5%AE%9A">生存期附加约定</a>的基础上，尾上下文内可以确定并调整对象生存期结束时机：</p>
<ul>
<li>作为<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>及其参数可以<a href="Features/NPL.zh-CN.html#%E7%94%9F%E5%AD%98%E6%9C%9F%E6%89%A9%E5%B1%95">延长生存期</a>至多到尾上下文结束。</li>
<li>被证明不再需要之后引用的对象，或未被绑定到活动记录上的项中的对象，可以缩短生存期。</li>
<li>被延长生存期的对象生存期起始和结束的相对顺序保持不变。</li>
<li>被缩短生存期的不同对象生存期结束的相对顺序保持不变。</li>
</ul>
<p>　　推论：被缩短生存期和延长生存期的对象的生存期结束的相对顺序保持不变。这由没有被调整生存期的对象与被调整生存期对象之间的生存期结束的<a href="Features/NPL.zh-CN.html#%E5%B0%BE%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BA%A6%E5%AE%9A">顺序关系</a>的传递性保证。</p>
<p>　　延长临时对象生存期和宿主语言中允许扩展非完全表达式内的临时对象的效果类似，但条件不同。</p>
<p><strong>注释</strong></p>
<p>　　以上规则中被调整生存期的对象一般仅是参数和函数体内创建的对象。因此，不保证理论上允许的尾上下文的都满足 PTC 。一个例子是合并子中可以保存<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">动态环境</a>，这个环境可能被递归的调用引用，而无法提前释放。</p>
<p>　　理论上 PTC 不要求延长生存期，仅要求特定情形下缩短生存期，且其它情形被释放的对象生存期不延长到尾上下文外。</p>
<p>　　允许延长生存期是<a href="Features/NPL.zh-CN.html#%E7%94%9F%E5%AD%98%E6%9C%9F%E9%99%84%E5%8A%A0%E7%BA%A6%E5%AE%9A">生存期附加约定</a>的结果。</p>
<h3 id="ptr"><a class="header" href="#ptr">PTR</a></h3>
<p>　　PTC 的活动记录性质也在一般的递归规约时体现，被称为 PTR（proper tail recursion ，真尾递归）。</p>
<p>　　和 PTC 不同，PTR 要求的递归规约不一定是对象语言中的调用，以 PTR 描述时仅强调递归，不考虑尾上下文的适用性。</p>
<p>　　通过特定的保持语义等价的变换，对象语言可要求尾上下文作用于函数调用以外的上下文中（例如非<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>的语法上下文）使用真尾规约实现。</p>
<p>　　除非派生实现另行指定，NPLA 对象语言不指定使函数调用以外的上下文作为尾上下文的要求；函数调用以外的尾上下文规约的仅可能用于实现的元语言中的<a href="Features/NPL.zh-CN.html#%E7%AE%A1%E7%90%86%E8%A7%84%E7%BA%A6">管理规约</a>；非管理规约的真尾规约都用于尾调用。</p>
<p>　　此时，PTR 等价被递归调用的 PTC 。但由于支持 PTC 在非递归规约情形时也影响语言实现的一般构造，所以描述要求时一般不以 PTR 代替 PTC 或真尾规约。</p>
<p>　　关于 PTR 在 Scheme 为基础的形式模型，参见 [Cl98] 。</p>
<p>　　PTR 的一个更激进的实现优化方式是 evlis tail recursion ，参见以下文献和参考资料：</p>
<ul>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.83.8567&amp;rep=rep1&amp;type=pdf">Continuation-Based Program Transformation Strategies</a></li>
<li>[Cl98]</li>
<li><a href="https://www.akalin.com/evlis-tail-recursion">Evlis tail recursion</a></li>
</ul>
<p>　　因为 NPLA 使用<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">链接的环境</a>，不支持实现其中更激进的 safe-for-space 保证。</p>
<p><strong>原理</strong></p>
<p>　　为支持<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">一等对象</a>，可被共享的环境一般不支持<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">平坦的表示</a>。</p>
<p>　　不具有 safe-for-space 保证时，实现对程序的闭包变换(closure conversion) 可能创建多余的<a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>且无法被运行时有效地分辨，而造成<a href="Features/NPL.zh-CN.html#%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F">资源泄漏</a>。通过明确支持这类保证的变换（如 http://flint.cs.yale.edu/flint/publications/escc.pdf ）可避免变换引起资源泄漏。</p>
<p>　　只要捕获自由变量的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">静态环境</a>可被程序在创建函数时明确指定，safe-for-space 保证就不是必须的：避免在<a href="Features/NPL.zh-CN.html#%E7%94%9F%E5%AD%98%E6%9C%9F%E6%89%A9%E5%B1%95">语义规则约定</a>之外的生存期延长和资源泄漏是<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>的责任；NPLA 程序可精确控制对象生存期，同时应当避免<a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">循环引用</a>。</p>
<p>　　对 safe-for-space 保证的证明（如 [Cl98] 和 <a href="https://zoep.github.io/icfp2019.pdf">Closure Conversion Is Safe for Space</a> ），隐含要求和上述一等对象支持冲突的条件：环境中引用的对象总是可被复制的没有可观察行为的值。这实质上要求支持<a href="Features/NPL.zh-CN.html#%E5%85%B1%E4%BA%AB%E5%BC%95%E7%94%A8">共享引用</a>乃至可能要求一等对象都是<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>。</p>
<p>　　因为使用链接的环境的要求，一般情形<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">不支持</a>对 safe-for-space 的变换。</p>
<p>　　即便允许类似的变换，这也仅保证不存在<a href="Features/NPL.zh-CN.html#%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F">不可达</a>，仍然不保证资源被及时回收——<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">全局机制</a>可能具有不确定的延迟而造成的实时资源泄漏。</p>
<h3 id="tco"><a class="header" href="#tco">TCO</a></h3>
<p>　　TCO（Tail Call Optimization ，尾调用优化）是在以尾上下文规约时，允许减少修改规约状态的优化。</p>
<p>　　一般地，TCO 可重新排列规约过程中的被语义允许调整的副作用和其它不影响可观察行为的<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">状态</a>的调用，减小空间开销。</p>
<p>　　TCO 的这种性质可以在宿主语言不支持 <a href="Features/NPL.zh-CN.html#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C-ptc">PTC</a> 时用于实现<a href="Features/NPL.zh-CN.html#%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%AB%8B">对象语言的 PTC</a> 。</p>
<p><strong>注释</strong></p>
<p>　　关于 TCO 和 PTC 的差异，另见<a href="https://groups.google.com/d/msg/comp.lang.lisp/AezzhxTliME/2Zsq7HUn_ssJ">这里</a>。</p>
<h4 id="宿主语言中立"><a class="header" href="#宿主语言中立">宿主语言中立</a></h4>
<p>　　C++ 不要求实现支持 PTC ，也不保证支持 TCO 。因此，对象语言的 PTC 要求显式的 TCO 实现。</p>
<p>　　为可移植地支持 TCO ，NPLA 不依赖宿主语言中不可移植的<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>的活动记录（通常是体系结构相关的栈）。</p>
<p><strong>注释</strong></p>
<p>　　尾调用可避免尾上下文中非<a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8%E5%AE%89%E5%85%A8">嵌套调用安全</a>的情形的<a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8%E5%AE%89%E5%85%A8">宿主语言实现的未定义行为</a>，但不保证非尾上下文中具有类似的性质。</p>
<h4 id="tco-实现策略概述"><a class="header" href="#tco-实现策略概述">TCO 实现策略概述</a></h4>
<p>　　TCO 包括以下形式：</p>
<ul>
<li>静态 TCO ：实现时替换宿主语言中不保证满足 PTC 的构造为满足 PTC 的构造。</li>
<li>动态 TCO ：运行时调整直接或间接表示对象语言构造的数据结构和状态，使状态占用的空间复杂度满足 PTC 要求。</li>
</ul>
<p>　　静态 TCO 也适合非对象语言的调用的<a href="Features/NPL.zh-CN.html#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C-ptc">上下文</a>。</p>
<p>　　不依赖宿主语言特性的静态 TCO 包括以下形式：</p>
<ul>
<li>替换宿主语言实现中的不保证满足 PTC 的递归调用为满足 PTC 的结构（如循环结构），包括直接编码和自动的变换(transformation) ，称为宿主(host) TCO 。</li>
<li>替换不满足 PTC 的对象语言原语为满足 PTC 的表达形式，称为目标(target) TCO 。</li>
</ul>
<p>　　不依赖宿主语言特性的动态 TCO 包括以下形式：</p>
<ul>
<li>通过合并不同<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">活动调用</a>中活动记录占用的冗余状态，减少宿主语言的活动调用同时占用的总空间，称为 TCM（Tail Call Merging ，尾调用合并）。</li>
<li>引入具有便于操作<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制作用</a>的构造，同时作为一些其它优化的基础，以消除部分活动记录状态的分配，称为 TCE（Tail Call Elimination ，尾调用消除）。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　本节的内容不影响对象语言的语义，但可能影响<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>的接口兼容性和实现质量。</p>
<p>　　关于对实现的具体影响，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h2 id="npla-数学功能"><a class="header" href="#npla-数学功能">NPLA 数学功能</a></h2>
<p>　　NPLA 数学功能（模块 NPLAMath ）提供数学功能和相关支持。</p>
<p>　　关于 NPLA 数学功能的规格说明的其它部分，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h3 id="数值类型"><a class="header" href="#数值类型">数值类型</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#%E9%99%84%E5%8A%A0%E5%8A%9F%E8%83%BD">NPLA 数值</a>是 NPLA 对数学意义上的<em>数(number)</em> 的建模。</p>
<p>　　被建模的数是 NPLA 数值的<em>真值(true value)</em> 。</p>
<p>　　NPLA 数值的集合到真值的集合的映射是满射；除此之外，也存在不被 NPLA 数值建模的数，这些数可能被 NPLAMath 未来的版本支持作为真值。</p>
<p>　　除非另行指定，NPLA 数值的行为由对应的真值的数学含义决定。</p>
<p>　　基于宿主语言的类型系统，NPLA 支持以下按数值范围从小到大排列的本机整数和浮点数作为<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>：</p>
<ul>
<li><code>signed char</code></li>
<li><code>unsigned char</code></li>
<li><code>signed short</code></li>
<li><code>unsigned short</code></li>
<li><code>int</code></li>
<li><code>unsigned</code></li>
<li><code>long</code></li>
<li><code>unsigned long</code></li>
<li><code>long long</code></li>
<li><code>unsigned long long</code></li>
<li><code>float</code></li>
<li><code>double</code></li>
<li><code>long double</code></li>
</ul>
<p>　　文法表示：</p>
<p>　　支持的数值类型以 <code>&lt;number&gt;</code> 表示，具有以下表示数值的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>：</p>
<ul>
<li><code>&lt;complex&gt;</code> ：复数。</li>
<li><code>&lt;real&gt;</code> ：实数。</li>
<li><code>&lt;rational&gt;</code> ：有理数。</li>
<li><code>&lt;integer&gt;</code> ：整数。</li>
</ul>
<p>　　其子类型由数学定义蕴含，即以上类型中，后者依次是前者的子类型。</p>
<p>　　当前所有数值都是 <code>&lt;real&gt;</code> ，因此暂时没有针对 <code>&lt;number&gt;</code> 值是否属于 <code>&lt;real&gt;</code> 和 <code>&lt;complex&gt;</code> 的类型检查。</p>
<p>　　和数学意义上的实数不同，<code>&lt;real&gt;</code> 也包含以下可带符号(sign) 的<em>特殊值(special value)</em> ：</p>
<ul>
<li>无限大值。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/NaN">NaN(not a number)</a> 值。</li>
</ul>
<p>　　对应地，<code>&lt;complex&gt;</code> 也包含实部和/或虚部是上述特殊值的特殊值。</p>
<p><strong>注释</strong> 当前所有复数都是实数，因此虚部总是 0 。</p>
<p>　　根据数值是否完全保留真值在数学上的唯一性即<em>精确性(exactness)</em> ，数值分为<em>精确数(exact number)</em> 和<em>不精确数(inexact number)</em> 。</p>
<p>　　精确数和对应的真值总是相等；不精确数和真值不严格相等。</p>
<p>　　有限的不精确数的偏离程度可通过实数描述，即（绝对）<em>误差(error)</em> 。精确数的误差恒等于 0 。</p>
<p>　　除非另行指定，特定不精确数的具体的误差是未指定的。</p>
<p>　　数值的绝对<em>精度(precision)</em> 是其内部表示蕴含的误差的上界的倒数。对确定使用进位制的表示，精度也指精确表示的数值位数。</p>
<p>　　数值的<em>任意精度(arbitrary precision)</em> 指除<a href="Features/NPL.zh-CN.html#%E8%B5%84%E6%BA%90%E5%8F%AF%E7%94%A8%E6%80%A7%E5%9F%BA%E6%9C%AC%E7%BA%A6%E5%AE%9A">实现环境的可用资源（一般即存储空间）限制</a>外，不限制精度。</p>
<p><strong>注释</strong> 为支持更多数学上有意义的真值，未来可能引入其它类型来表示任意精度的整数、有理数及数学意义上的扩展（如复数和四元数）。</p>
<p>　　数值的内部表示中能以实数描述的度量应至少具有整数数量级精度，即误差不大于 1 。</p>
<p>　　精确数和不精确数在数值上可能相等，而<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">类型不同</a>。</p>
<p>　　宿主类型中的本机整数和浮点类型是数值类型的子类型，分别称为 fixnum 和 flonum 。这些类型在项的内部表示预期直接占据本机存储而不需要动态分配。</p>
<p>　　Fixnum 总是精确数；flonum 总是不精确数。</p>
<p><strong>注释</strong> 当前实现中，所有数值是 fixnum 或 flonum 之一。两者分别是宿主的整数类型（排除字符和 <code>bool</code> 类型）以及浮点数类型。</p>
<p>　　Flonum 支持带符号的无限大值以及 NaN 值作为特殊值。其它值都是有限值。特殊值可能具有不唯一的内部表示，但和有限值的表示都不同。</p>
<p>　　Flonum 中可存在小的非零数，可能和其它数值不同的内部表示而更容易在计算中损失精度，即非规格化(denormalized) 数值。</p>
<p>　　整数值的数值具有整数类型。这包括所有的 fixnum ，以及 flonum 中是整数的数值。这不和宿主类型直接对应。</p>
<p><strong>注释</strong> 一个 flonum 是整数，当且仅当它的值取整后结果和原值相等。这里的取整使用可使用任意的舍入。[R<sup>7</sup>RS] 对不精确数有类似的定义（仅使用 round ）。</p>
<p>　　对 fixnum ，<code>+0</code> 和 <code>-0</code> 是相等的数值。Flonum 不同符号的零值在值的表示中可以不同，但在数学意义上相等，表示同一个数。实现中的其它和具体表示无关的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">等价谓词</a>是否表现这种不同是未指定的。</p>
<p><strong>注释</strong></p>
<p>　　NPLA 的不同的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义</a>数值类型的集合到宿主类型的集合的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">类型映射</a>是满射，即本节指定的宿主类型总是关联至少一个能表示它的值的 NPLA 数值类型。</p>
<p>　　同时，NPLA 数值类型可以映射到其它类型，特别地，NPLA 整数的类型映射目标是宿主语言整数类型和包含整数值的非典型<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>的并。所以，NPLA 数值整体的类型映射不构成简单的一对多或多对多关系。</p>
<p>　　特殊值同 ISO/IEC 10967–1 (LIA–1) 定义，引用 [IEC 60559] (IEEE-754) 的具体值，仅适用于浮点数。</p>
<p>　　无限大值在数学上属于<em>超实数(hyperreal number)</em> ，在浮点数实现中属于<em>扩展实数(extended real number)</em> 。</p>
<p>　　无限大值的符号在数学意义上是必要的，因此也被要求区分。</p>
<p>　　精确性、fixnum 和 flonum 等区分同 [R<sup>6</sup>RS] ，但具体实现要求不尽相同。</p>
<p>　　NaN 不是数学意义上的数，表示特定的没有数学定义的计算结果。NaN 和任何数值比较总是不相等。</p>
<p>　　NPLA 的宿主语言支持的 NaN 值带有符号。不是所有实现都区分符号，如 [ECMAScript] 。</p>
<p>　　整数精度外的数量级精度仅在确定使用的进位制底数时和绝对精度可比较，因此常用于描述特定实现的内部表示（例如，[ISO C] 定义的浮点数精度即有效数字的位数）。但是，不比较具体大小时，有限的数量级精度和绝对精度性质可以一致，这种上下文可不区分两者。</p>
<p>　　大多数不精确数的浮点表示的高效实现使用底数 2 。</p>
<p>　　参照 [IEC 60559] ，浮点格式的无限大值和有限数值是浮点数；NaN 不是浮点数。两者统称为<em>浮点数据(floating-point datum)</em> 。</p>
<p>　　宿主类型中实现为 [IEC 60559] 的<em>非规格化(denormalized)</em> 浮点数是具有不唯一的内部表示的小的非零数值。使用 IEEE-754 2008 以来的定义，这些数是<em>非规格(subnormal)</em> 数。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，本文档没有指定可选的模块，也没有指定精确的 ±∞ 值。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，不精确数不指定边界和<em>主值(primary value)</em> ，NaN 值被显式提供而不是唯一的 <code>#undefined</code> 值，非规格数不作为 <code>#undefined</code> 。这同时不要求在任意的操作中检查 <code>#undefined</code> 值并<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　尽管容易损失精度，区分不同的非规格数的数值仍然有意义。同时，也避免和 NaN 用以表示数学上未定义操作的结果（如 0 除以 0 ）引起混淆。</p>
<p>　　数值相等和一般对象相等可使用不同的等价谓词。和一般对象比较不同，数值相等比较可对参数要求数值类型，否则引起错误。两者比较结果可能也不总是相同。如 Scheme 的 <code>=</code> 和 <code>eqv?</code> 以及 Kernel 的 <code>=?</code> 和 <code>equal?</code> 。</p>
<h3 id="数值操作约定"><a class="header" href="#数值操作约定">数值操作约定</a></h3>
<p>　　在对象语言中，数值操作是可使用数值作为算法输入的值的操作。NPLA1 提供本机 API 支持这些操作的实现。</p>
<p>　　数值操作数和非数值操作数分别是具有和不具有数值类型的操作数。</p>
<p>　　数值操作蕴含对应的数值计算，接受至少一个数值或非数值操作数，预期得到<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">计算结果</a>。</p>
<p><strong>注释</strong> 非预期情形可<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　其中，计算结果依赖影响计算结果的操作数，并依赖至少一个数值操作数。</p>
<p>　　除非另行指定：</p>
<ul>
<li>在数学上有意义的前提下，数值操作同时支持以上尽可能多的数值类型的操作数。</li>
<li>数值操作对预期的数值操作数进行<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>，失败时出错。</li>
<li>数值操作不区分数值操作数中对应的真值相等的精确数或不精确数。</li>
<li>可假定数值操作数和计算过程中不出现 <a href="https://en.wikipedia.org/wiki/NaN#Signaling_NaN">SNaN(signaling NaN) (en-US)</a> 值。</li>
<li>若作为操作数的精确数决定计算结果在数学上未定义，则引起错误。</li>
<li>不精确数计算中的舍入方式未指定。</li>
<li>若计算结果是数值，则：
<ul>
<li>若被计算结果依赖的任一操作数中具有 NaN 值，则依赖这个操作数的数值操作结果也是 NaN 值。</li>
<li>输出的类型的值域能表示操作结果；除操作的语义和本节的其它规则蕴含外，具体类型未指定。</li>
<li>若作为操作数的精确数决定的计算结果是不精确数表示的有限数值，则这个不精确数应是所有相同内部表示的数值中和结果的真值误差最小的数值。</li>
<li>对数学上封闭的计算，结果具有不超过所有数值操作数范围的数值类型。</li>
<li>除非不能在结果类型中表示计算结果的范围：
<ul>
<li>若数值操作的所有数值操作数都是精确数，结果不是不精确数。</li>
<li>数值操作的实现不损失按数学定义得到的中间结果的<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">精度</a>；结果的<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">误差</a>仅来自其依赖的数值操作数引入的累积误差。</li>
</ul>
</li>
<li>若计算结果是不精确数，则：
<ul>
<li>若计算结果是小于最小可唯一表示的 <code>&lt;real&gt;</code> 值，则对应的数值操作结果是不精确数 0 。</li>
<li>计算结果中真值等于 0 的数值以及 NaN 值的符号是未指定的。</li>
<li>若计算结果中无限大数值不能通过数学上有意义的方式确定符号，则对应的数值操作结果是无限大值或 NaN 之一，具体选择未指定。</li>
</ul>
</li>
<li>数值的宿主类型未指定。</li>
</ul>
</li>
</ul>
<p><strong>原理</strong></p>
<p>　　因为典型的高效实现实现依赖<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">外部环境</a>对浮点数的支持，设计策略以保持<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>的便利性相关。</p>
<ul>
<li>NPLAMath 实现不访问 SNaN 值，也不需要访问宿主语言的浮点环境，但不假设总是使用默认浮点环境。
<ul>
<li>这不阻止和使用 SNaN 的<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>的程序链接和调用，这有助于保持互操作性。</li>
<li>NPLAMath 实现不保证检查访问浮点环境的副作用是否存在。若互操作需要改变浮点环境，应避免破坏实现的假设。</li>
</ul>
</li>
<li>不依赖零值的符号、NaN 的符号以及 SNaN 的处理和许多<a href="Features/NPL.zh-CN.html#%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0">宿主实现</a>的默认情形一致而能简化一般的实现，如：
<ul>
<li><a href="https://gcc.gnu.org/wiki/FloatingPointMath">GCC</a> 。</li>
<li><a href="https://docs.microsoft.com/cpp/build/reference/fp-specify-floating-point-behavior">Microsoft VC++</a> 。</li>
<li>不要求使用 GCC 时启用 <code>-ffloat-store</code> 。Microsoft VC++ 默认的 <code>/fp:precise</code> 的类似语义也不被依赖。</li>
</ul>
</li>
</ul>
<p><strong>注释</strong></p>
<p>　　数值操作可能允许非数值的操作数，这些操作数也可被计算结果依赖。</p>
<p>　　因为 <a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">flonum</a> 能表示所有实数数值范围，所以实数范围以内的操作不会引入操作数以外的其它 flonum 类型。</p>
<p>　　数值操作抛出异常的要求不一定在每一个实现数值操作的 <a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 中蕴含，因为这些 API 不一定是数值操作的完整实现。</p>
<p>　　抛出异常和<a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>的异常和浮点异常没有直接关联。</p>
<p>　　若数值操作指定非数值计算结果（如<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">布尔值</a>）或者不能表示的 NaN 值的计算结果，则即使依赖 NaN 数值操作数，也不是 NaN 值。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，数值操作不支持不同的全局模式。</p>
<p>　　特定情形下，精确数可能替换计算结果中的不精确数：</p>
<ul>
<li>当按数学定义能被精确表示时，计算结果可以是符合要求的任意一个类型的精确数。</li>
<li>否则，当实现能证明不精确数值足够小到不足以影响结果的表示，且存在真值相等的可用的精确数时，可使用这个精确数代替不精确数。</li>
<li>当前实现没有这类证明机制。</li>
</ul>
<p>　　IEEE-754 使用<em>渐进下溢(gradual underflow)</em> ，使零值和相邻的非零浮点数的真值之差不会显著大于其它两个浮点数真值的差，而使小的非零浮点数之间的差不等于零。这体现了支持<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">非规格化数</a>的实际作用。但一般数值计算仍需要累积误差。</p>
<p>　　虽然可能影响结果，浮点数实现的内部状态（如舍入模式）的访问不被直接支持。</p>
<p>　　浮点数 0 和 0 之差的符号可能取决于舍入模式。数值操作一般不保证结果 0 的符号，但以依赖<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E8%A1%A8%E7%A4%BA">表示的形式</a>仍可确定符号。</p>
<p>　　除满足必要的精度要求的前提外，互操作以外目的的数值的宿主类型的具体选择在维持计算正确性的意义上通常不重要，因此默认不要求指定。</p>
<p>　　对特殊值，因为 [R<sup>n</sup>RS] 只要求 <code>.0</code> 后缀的特殊值字面量，需保持兼容时，程序可只使用这些形式的字面量。为此，实现可使用带有 <code>.0</code> 后缀特殊值的数值字面量的对应的宿主类型，以减少潜在的可移植问题。</p>
<p>　　关于派生实现支持的数值字面量，参见 <a href="Features/NPL.zh-CN.html#npla1-%E6%95%B0%E5%80%BC%E5%AD%97%E9%9D%A2%E9%87%8F">NPLA1 数值字面量</a>。</p>
<h3 id="数值表示"><a class="header" href="#数值表示">数值表示</a></h3>
<p>　　支持解析的数值以字符串作为外部表示。作为字面量时，构成<a href="Features/NPL.zh-CN.html#npla-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F">数值字面量的词法</a>。</p>
<p>　　数值的外部表示起始的 <code>+</code> 和 <code>-</code> 指定符号。若符合规则的数值字面量没有指定符号，则隐含为 <code>+</code> 。</p>
<p><strong>注释</strong> 不精确数可能在内部表示支持不同符号的<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">零值</a>。</p>
<p>　　数值的外部表示和内部表示应支持<em>往返(round-trip)</em> 转换，即转换的内部或者外部表示输出可被输入接受。</p>
<p>　　往返转换中，精确数转换保持任意（无限）精度；不精确数经有限次转换不继续损失精度。</p>
<p><strong>注释</strong> 即便损失精度，也应总是满足结果至少不低于<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">整数精度</a>。</p>
<p>　　支持的表示具体包括（优先匹配较长的模式）：</p>
<p>　　匹配<a href="https://zh.wikipedia.org/zh-cn/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a> <code>(+|-)?[0-9]+</code> ：十进制精确数数值。</p>
<p>　　不论符号，当前精确数数值字面量默认都具有<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a> <code>int</code> ，除非其绝对值太大而无法被表示，使用其它类型代替。</p>
<p>　　除非精确数字面量的数值超过所有 <a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">fixnum</a> 的可表示范围，都具有 fixnum 值。</p>
<p>　　除非精确数字面量的数值超过所有支持的精确数的可表示范围，都是精确数。</p>
<p><strong>注释</strong> 当前精确数的表示范围是 fixnum 中宿主类型的值域的并集，因此超过 fixnum 可表示范围的数值不是精确数。</p>
<p>　　匹配正则表达式 <code>(+|-)?[0-9]+\.[0-9]*</code> 或 <code>(+|-)?[0-9]+(\.[0-9]*)?(E|e|S|s|F|f|D|d|L|l)(+|-)?[0-9]+</code> ：十进制不精确数数值。</p>
<p>　　不精确数数值字面量的解析使用未指定的浮点数舍入模式，其<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">误差</a>不大于最后一个在规格化范围内表示的十进制小数位为 1 时的绝对值的真值大小。</p>
<p><strong>注释</strong> 不精确数值解析的误差和具体宿主语言支持相关；误差以任意可能符合宿主语言要求的舍入模式下的最大值计。</p>
<p>　　第一种形式是直接记法。</p>
<p>　　第二种形式是<a href="https://zh.wikipedia.org/zh-cn/%E7%A7%91%E5%AD%A6%E8%AE%B0%E6%95%B0%E6%B3%95">科学记数法(scientific notation)</a> ，在指示指数的指数字母前后匹配的数字序列分别是有效数字(significand) 和指数(exponent) 。</p>
<p>　　科学记数法使用的有效数字和指数构成的真值和内部表示可具有误差；指数字母表示不同精度：</p>
<ul>
<li><code>E</code> 或 <code>e</code> ：默认精度。</li>
<li><code>S</code> 或 <code>s</code> ：短(short) 精度。</li>
<li><code>F</code> 或 <code>f</code> ：单精度(float) 。</li>
<li><code>D</code> 或 <code>D</code> ：双精度(double) 。</li>
<li><code>L</code> 或 <code>l</code> ：长精度(long) 。</li>
</ul>
<p>　　同组的字母含义等价。以上精度中，默认精度不低于双精度；其它精度依次不低于之前的一个。</p>
<p>　　精度可影响内部存储的宿主类型。</p>
<p>　　若字面量指定的数值小于或大于使用的类型的数值表示范围，则值为对应类型具有相同符号的零值或<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">无限大值</a>。</p>
<p><strong>原理</strong></p>
<p>　　浮点数解析存在不同精度的算法。</p>
<p>　　若以二进制浮点数和经过舍入的十进制表示相互转换不损失精度为前提，宿主语言的 <a href="http://eel.is/c++draft/numeric.limits"><code>std::numeric_limits</code></a> 的 <a href="http://eel.is/c++draft/numeric.limits.members#14"><code>max_digits10</code></a> 位十进制数字足够表示。</p>
<p>　　（对 [IEC 60559] 的二进制浮点数情形的证明参见<a href="https://www.itu.dk/~sestoft/bachelor/IEEE754_article.pdf">这里</a>的 Theorem 15 。）</p>
<p>　　但是，对任意有效输入的结果误差都不大于 1 <a href="https://zh.wikipedia.org/zh-cn/%E6%9C%80%E5%90%8E%E4%B8%80%E4%BD%8D%E4%B8%8A%E7%9A%84%E5%8D%95%E4%BD%8D%E5%80%BC">ULP(unit in the last place)</a> 的不经舍入的值完全精确值(full precision) 的精确解析算法，对实现的要求较高，且性能可能明显较低，故不作要求。</p>
<p>　　（对 [IEC 60559] 的二进制浮点数的情形，需要数十倍的中间存储，参见<a href="https://stackoverflow.com/questions/554063/62542806">这里</a>。）</p>
<p>　　和宿主语言的 <code>std::strtod</code> 不同，允许使用宿主语言中的任意浮点数舍入模式，而不要求不同浮点数舍入模式下的结果一致性。</p>
<p>　　浮点数精度的 <code>float</code> 和 <code>double</code> 在典型实现中的内部表示格式同 [IEC 60559] 的二进制的单精度和双精度浮点数。</p>
<p><strong>注释</strong></p>
<p>　　串模式 <code>(+|-)</code> 表示带有可选前缀符号（仅限一个），影响值的数值。</p>
<p>　　同 klisp 而不同于 [R<sup>n</sup>RS] 的字面量词法，小数点不能出现在词素中符号以外的第一个字符；但 klisp 的 <code>string-&gt;number</code> 没有这个限制。</p>
<p>　　同 [R<sup>n</sup>RS] 而不同于 klisp（两者包括字面量词法和 <code>string-&gt;number</code> ），小数点允许出现在词素的结尾。</p>
<p>　　当前不精确数数值都具有宿主类型 <code>double</code> 。即便 <code>long double</code> 可能具有更大的数值范围，也不能通过解析数值表示直接取得。</p>
<p>　　类似地，[Racket] 默认不启用 <a href="https://docs.racket-lang.org/reference/extflonums.html">extflonum</a>。关于数值操作也类似，参见<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">数值操作约定</a>。</p>
<p>　　当前允许在<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主值</a>不能完全存储不精确数的字面量数字时，解析十进制不精确数字面量存储的值可能和字面量的数值的真值之间具有超过 1ULP 的误差。这可能影响和精确数之间的比较。</p>
<p>　　当前实现使用四舍五入。</p>
<p>　　关于宿主语言中 <a href="http://www.eel.is/c++draft/cstdlib.syn#lib:strtod"><code>std::strtod</code></a>（同 [ISO C] 标准库的 <code>strtod</code> ）舍入要求的一些问题，参见：</p>
<ul>
<li><a href="https://www.exploringbinary.com/incorrectly-rounded-conversions-in-gcc-and-glibc/">Incorrectly Rounded Conversions in GCC and GLIBC</a></li>
<li><a href="https://www.sourceware.org/bugzilla/show_bug.cgi?id=3479">Incorrect rounding in <code>strtod()</code></a></li>
</ul>
<p>　　数值字面量的词法同 [R<sup>n</sup>RS] 的一个子集。</p>
<p>　　[R<sup>n</sup>RS] 指出实现可能允许用户修改不同的默认精度。这指出精度不是固定的，但不是实现要求。
　　[R<sup>n</sup>RK] 的有限数的对应子集接近 [R<sup>n</sup>RS] 的设计，但没有明确指定字面量词法规则。其中对精度的表述略有不同：</p>
<ul>
<li>没有指定大写字母。</li>
<li>指定 <code>s</code> 、<code>f</code> 、<code>d</code> 和 <code>l</code> 的精度递增，没有显式允许不同的精度映射到相同的内部格式。</li>
<li>没有显式允许用户指定的默认精度。</li>
</ul>
<p>　　但是，SINK 和 klisp 实际上都不符合前两点，而更符合 Scheme 的实现。[R<sup>n</sup>RK] 在此可能不完善或表述有误。</p>
<p>　　当前 klisp 的实现不允许 <code>E</code> 和 <code>e</code> 之前没有小数点，且在存在 <code>E</code> 或 <code>e</code> 时省略之后的指数的任意部分，和 SINK 以及 [R<sup>n</sup>RS] 都不同。本设计遵循后者。</p>
<p>　　当前 NPLAMath 精度对应的宿主类型指派如下：</p>
<ul>
<li><code>e</code> ：同 <code>d</code> 。</li>
<li><code>s</code> ：同 <code>f</code> 。</li>
<li><code>f</code> ：<code>float</code> 。</li>
<li><code>d</code> ：<code>double</code> 。</li>
<li><code>l</code> ：<code>long double</code> 。</li>
</ul>
<h1 id="npla1-核心语言"><a class="header" href="#npla1-核心语言">NPLA1 核心语言</a></h1>
<p>　　NPL 是独立设计的，但其派生语言和其它一些语言有类似之处；这些语言和 NPL 方言之间并不具有派生关系。但为简化描述，部分地引用这些现有<a href="Features/../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">语言规范</a>中的描述，仅强调其中的不同。</p>
<p>　　NPLA1 符合 NPL 和 NPLA 的语言规则，其<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">实现环境</a>还应提供本章起的其它程序接口。</p>
<p>　　互操作中的一些接口处理的值可约定<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>。但这些类型不一定在<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>层次上稳定，可能在之后的版本变化。稳定性由具体实现提供的附加规则（若存在）保证。</p>
<p>　　NPLA1 和 Kernel 语言（即 [R<sup>n</sup>RK] ）的特性设计（如 <a href="Features/NPL.zh-CN.html#vau-%E6%8A%BD%E8%B1%A1">vau</a>和作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>的环境表达<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">过程抽象</a>）有很多类似之处，因此许多概念是通用的；但从<a href="Features/NPL.zh-CN.html#%E9%A2%86%E5%9F%9F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">设计哲学</a>到本章介绍的各个细节（如<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">默认求值规则</a>）都存在深刻的差异。</p>
<p>　　部分名称指定的操作和 [R<sup>n</sup>RS] 或 <a href="http://klisp.org/docs/index.html">klisp</a> 指定的类似。</p>
<p>　　以下章节主要介绍和 Kernel 约定不同的设计。各节的通用约定不再在之后的各个接口单独说明。</p>
<h2 id="npla1-对象语言约定"><a class="header" href="#npla1-对象语言约定">NPLA1 对象语言约定</a></h2>
<p>　　NPLA1 仅使用<a href="Features/NPL.zh-CN.html#npla-%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83">宿主语言</a>的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型</a>和<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>作为在对象语言可表达的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">状态</a>。</p>
<p>　　在 <a href="Features/NPL.zh-CN.html#npla">NPLA</a> 的基础上，NPLA1 要求对象语言支持以一等对象作为表达式并被<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">类型等价性</a>基于<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">类型映射</a>及其实现，由 [ISO C++] 的语义规则定义。</p>
<p>　　值等价性由<a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>的 <code>==</code> 表达式的结果定义。</p>
<p>　　除非另行指定，所有类型的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">外部表示</a>都是允许从作为内部表示的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>确定的同<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>的空字符结尾的字符串（即 [ISO C++] 的 <a href="https://eel.is/c++draft/defns.ntcts">NTCTS</a> ）。</p>
<p>　　关于作为表达式的求值和类型映射的实现，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h3 id="标识符附加规则"><a class="header" href="#标识符附加规则">标识符附加规则</a></h3>
<p>　　当前仅支持<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">标识符</a>作为<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">名称</a>。</p>
<p>　　部分名称是<a href="Features/NPL.zh-CN.html#npla-%E5%90%8D%E7%A7%B0%E5%92%8C%E5%AD%97%E9%9D%A2%E9%87%8F%E6%B1%82%E5%80%BC">保留名称</a>：含有 <code>$$</code> 的名称保留给宿主交互使用；含有 <code>__</code> 的名称保留给 NPLA1 实现。</p>
<p>　　在 <a href="Features/NPL.zh-CN.html#npla-%E6%95%B4%E4%BD%93%E7%BA%A6%E5%AE%9A">NPLA 规则</a>的基础上，在<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">内部表示</a>中显式使用保留给实现的标识符的程序<a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">行为未定义</a>。</p>
<p><strong>注释</strong> 这包含在源代码以外的中间表示使用的情形，但不包含作为用户输入的数据。</p>
<h2 id="npla1-互操作约定"><a class="header" href="#npla1-互操作约定">NPLA1 互操作约定</a></h2>
<p>　　基本规则参见 <a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">NPLA 互操作支持</a>。</p>
<p>　　非 NPLA1 实现提供的类型的宿主 <code>==</code> 操作不要求支持<a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8%E5%AE%89%E5%85%A8">嵌套调用安全</a>。</p>
<p>　　作为 NPLA1 嵌套调用安全的约定的扩展，若存在 == 操作不支持嵌套调用安全的类型，具体类型由派生实现的定义。</p>
<p>　　对象语言操作和互操作不修改对象语言中已经可见的<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">一等环境</a>的<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">父环境</a>。</p>
<p><strong>原理</strong></p>
<p>　　NPLA1 中提供的类型仍需要支持嵌套调用安全，以满足嵌套调用安全的约定中的要求。</p>
<p>　　关于 NPLA1 嵌套调用安全的具体约定和其它实现原理，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p>　　避免修改已在对象语言可访问的一定对象的父环境符合同 [R<sup>n</sup>RK] 的环境<a href="Features/NPL.zh-CN.html#%E5%B0%81%E8%A3%85">封装性</a>对对象语言的要求。这允许实现假定仅在有限的上下文中父环境可修改，而减少优化实现的难度。</p>
<h2 id="npla1-程序实现"><a class="header" href="#npla1-程序实现">NPLA1 程序实现</a></h2>
<p>　　本章指定 NPLA1 对象语言的<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">核心语言特性</a>。包含<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">库特性</a>的其它设计参见 <a href="Features/NPL.zh-CN.html#npla1-%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83">NPLA1 参照实现环境</a>。</p>
<p><strong>原理</strong></p>
<p>　　一般的语言能支持不同实现形式的库，包括<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源程序</a>和其它无法判断是否和特定源程序关联的翻译后的程序。</p>
<p>　　复用这些程序时，可能需要根据不同的形式而分别处理：源代码被读取和<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>而加载，而其它格式的翻译形式可能直接映射存储后经特定的检查即被加载。</p>
<p>　　但是在可复用的意义上，这些不同的形式是一致的，都视为库。</p>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RK] 不同，库不限定其实现形式。[R<sup>n</sup>RK] 指定的库实质上是可使用对象语言派生实现的库。</p>
<p>　　典型的静态语言不保证程序执行时能对源程序进行翻译，因此加载程序的限制通常更大，可能无法处理源程序形式的库而首先需要分离翻译为其它格式。NPL 一般不具有这个限制。</p>
<p>　　关于对象语言的<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">派生实现</a>，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h3 id="外部环境-1"><a class="header" href="#外部环境-1">外部环境</a></h3>
<p>　　基于 <a href="Features/NPL.zh-CN.html#npla-%E6%95%B4%E4%BD%93%E7%BA%A6%E5%AE%9A">NPLA 整体约定</a>，由 <a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">NPL-EMA</a> ，NPLA 的实现不假定存在多线程执行环境。</p>
<p>　　但是，宿主语言可支持多线程环境执行，<a href="Features/NPL.zh-CN.html#npla-%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE">可引起宿主语言的未定义行为</a>。</p>
<p>　　作为 NPLA 的派生，NPLA1 对象语言程序也具有相同的性质，除非另行指定需要和<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">外部环境</a>交互的特定操作，不需要假定 NPLA1 引入存在多线程执行环境。</p>
<h3 id="附加元数据"><a class="header" href="#附加元数据">附加元数据</a></h3>
<p>　　NPLA1 实现可提供和<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">实现环境</a>或具体 NPLA 对象关联的附加的资源，用于提供程序运行时可得到的附加信息，如源代码位置。</p>
<p>　　是否存在这些<em>附加元数据(extra metadata)</em> 和附加元数据的具体内容可影响特定的行为。</p>
<p><strong>注释</strong> 如符合<a href="Features/NPL.zh-CN.html#%E8%AF%8A%E6%96%AD">诊断</a>中要求的实现的具体行为。</p>
<p>　　这些影响是未指定的，但除 NPLA1 程序直接依赖具体数据而进行的操作外，不应影响程序的其它语义（例如，引起程序终止）。</p>
<h3 id="npla1-扩展支持"><a class="header" href="#npla1-扩展支持">NPLA1 扩展支持</a></h3>
<p>　　本章中除<a href="Features/NPL.zh-CN.html#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>的限制外，不支持的特性可能会在之后的实现中扩展并支持。</p>
<h3 id="npla1-未定义行为"><a class="header" href="#npla1-未定义行为">NPLA1 未定义行为</a></h3>
<p>　　NPLA1 对象语言程序中的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未定义行为</a>包括 <a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">NPLA 未定义行为</a>和以下扩展 NPLA 未定义行为：</p>
<ul>
<li>特定情形下<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">访问被修改的环境中绑定的对象</a>。</li>
<li>特定情形下违反对环境的使用要求。</li>
<li>NPLA1 库约定的未定义行为。</li>
</ul>
<p>　　派生语言可约定其它未定义行为。</p>
<p><strong>原理</strong></p>
<p>　　扩展 NPLA 未定义行为可提供更严格的要求使实现更简化。</p>
<p>　　关于环境的一些未定义行为可视为违反<a href="Features/NPL.zh-CN.html#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>，而不需要单独实现。</p>
<h2 id="接口文法约定"><a class="header" href="#接口文法约定">接口文法约定</a></h2>
<p>　　为描述对象语言规则和程序接口，本节约定<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">文法</a>形式。</p>
<p><strong>注释</strong> 这仅用于描述接口，不依赖 NPL 语言的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95">基本文法</a>。</p>
<p>　　规约操作中项的约束通过以 <code>&lt;&gt;</code> 中的同类名称表示。</p>
<p>　　为区分同类约束的不同项，约束的名称后（在 <code>&gt;</code> 之前）的可带有以 1 起始的正整数序数。除非另行指定，这些序数仅用于区分不同的同类约束项，无其它附加含义。</p>
<p>　　本节描述的项是被用于<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>（参见<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值算法</a>）的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>或它们的直接文法组合。前者应能涵盖<a href="Features/NPL.zh-CN.html#%E5%8E%9F%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F">原子表达式</a>、其<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>以及预期在对象语言中实现<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">对象语言求值算法</a>所需的 <a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">NPLA1 用户程序</a>构造。</p>
<p>　　库可参照本节的方式约定通过项的文法，以支持仅在特定库使用的操作数。</p>
<p>　　除非另行指定，本节的对应要求同时适用于本节中和这些库中引入的项。</p>
<h3 id="元文法基本约定"><a class="header" href="#元文法基本约定">元文法基本约定</a></h3>
<p>　　<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>文法：</p>
<ul>
<li><code>...</code> ：Kleene 星号，重复之前修饰的项 0 次或多次。</li>
<li><code>+</code> ：重复之前修饰的项 1 次或多次。</li>
<li><code>?</code> ：重复之前修饰的项 0 次或 1 次。</li>
</ul>
<p><strong>注释</strong></p>
<p><code>...</code> 一般在结尾出现，表示元素构成列表。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，不使用 <code>.</code> 分隔有序对，不使用元素名称的复数表示列表。</p>
<h3 id="实体元素文法约定"><a class="header" href="#实体元素文法约定">实体元素文法约定</a></h3>
<p>　　指定具名的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数</a>的文法中，第一项以<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>的形式在所在的环境中提供，指定求值结果指称为<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>的函数的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">名称</a>；其后指定的文法中不同的元素对应合并子的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>或其被作为调用时的<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">形式参数树</a>的子项。</p>
<p>　　除非另行指定，在操作数可能是左值时，仅当对应以 <a href="Features/NPL.zh-CN.html#%E5%85%83%E6%96%87%E6%B3%95%E5%9F%BA%E6%9C%AC%E7%BA%A6%E5%AE%9A"><code>...</code> 或 <code>?</code> 形式</a>中最后的一项（若存在）时，支持匹配作为<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的有序对的非<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">前缀元素</a>不是空列表的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>的情形。</p>
<p>　　名义不同的约束可能蕴含相同的<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF%E6%A3%80%E6%9F%A5">检查</a>。</p>
<p>　　除非另行指定，应用子的操作数的约束也适用其<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">底层合并子</a>。</p>
<p>　　文法形式上，使用本节约定指定<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">应用子的操作数</a>时，指定表达式形式的求值结果。</p>
<p><strong>注释</strong> 这和 [R<sup>n</sup>RK] 和 [Shu10] 中的斜体标识符的标记不同，但含义（表示语义变量(semantic variable) ）和效果实质相同。</p>
<p>　　操作数可能是左值或右值，按具体操作的需要，在必要时可被转换。</p>
<p>　　除可能具有的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>关系，本节约定的不同类型的操作数构成的集合之间不相交。一般规则参见<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB">类型分类</a>。</p>
<p>　　根据是否可作为操作子中指定不被求值的函数参数，本节的操作数及其<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">子项</a>分为<a href="Features/NPL.zh-CN.html#%E6%9C%AA%E6%B1%82%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">未求值的操作数</a>和<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">求值得到的操作数</a>。</p>
<p><strong>原理</strong></p>
<p>　　约束可用于区分特定的含义，但不直接指定和具体的<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF%E6%A3%80%E6%9F%A5">检查</a>对应，以便被实现优化，例如合并名义不同的检查。</p>
<p>　　文法形势的匹配应避免歧义。</p>
<p><strong>注释</strong></p>
<p>　　底层合并子适用应用子的约束，意味着按求值算法，被求值的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>对象不能是<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">非真列表</a>。</p>
<p>　　对非<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">前缀元素</a>的支持和<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">绑定匹配</a>规则对应。其中：</p>
<ul>
<li>仅<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">结尾序列</a>支持匹配以空列表以外的值的引用值作为非前缀元素的<a href="Features/NPL.zh-CN.html#%E6%9C%89%E5%BA%8F%E5%AF%B9">有序对</a>操作数左值的被引用对象中的非前缀元素<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>。</li>
<li>非结尾序列的元素因计算前缀元素数而被要求在同一个对象的前缀元素中。</li>
<li>作为操作数被绑定时，若元素是引用值：
<ul>
<li>它不被<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%B6%88%E9%99%A4">消除</a>。</li>
<li>它的被引用对象中的元素（若存在）不被视为初始化<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>中的其它<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>的子对象。</li>
</ul>
</li>
<li>若有序对操作数的非前缀元素是空列表的引用值，则有序对操作数构成列表。
<ul>
<li>有序对操作数的非前缀元素不会匹配<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">形式参数树</a>中的<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>而被绑定到变量。</li>
</ul>
</li>
<li>关于操作数匹配的规则避免匹配操作数序列时对文法元素的对应关系可能具有歧义。</li>
</ul>
<h4 id="未求值的操作数"><a class="header" href="#未求值的操作数">未求值的操作数</a></h4>
<p>　　未求值的操作数的文法约定如下：</p>
<ul>
<li><code>&lt;symbol&gt;</code> ：<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号</a>。
<ul>
<li><strong>注释</strong> 内部使用和 <a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;string&gt;</code></a>一一对应的表示，不提供符号和外部表示的其它映射关系。</li>
</ul>
</li>
<li><code>&lt;symbols&gt;</code> ：元素为 <code>&lt;symbol&gt;</code> 的列表，形式为 <code>(&lt;symbol&gt;...)</code> 。</li>
<li><code>&lt;eformal&gt;</code> ：表示可选提供的环境名称的 <code>&lt;symbol&gt;</code> 或 <code>#ignore</code> ，或这些值的引用值。
<ul>
<li><strong>注释</strong> 通常为动态环境。</li>
</ul>
</li>
<li><code>&lt;expression&gt;</code> ：待求值的表达式。
<ul>
<li><strong>注释</strong> 这是 <a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">NPL 语法</a>的直接实现。</li>
</ul>
</li>
<li><code>&lt;expressions&gt;</code> ：形式为 <code>&lt;expression&gt;...</code> 的待求值形式。
<ul>
<li>求值时，<code>&lt;expressions&gt;</code> 被作为单一表达式（即视为求值 <code>(&lt;expression&gt;...)</code> ）。</li>
</ul>
</li>
<li><code>&lt;binding&gt;</code> ：绑定列表的元素，形式为 <code>&lt;symbol&gt; &lt;body&gt;</code> ，用于指定被求值的表达式和绑定参数的符号值。
<ul>
<li>和 Kernel 不同，<code>&lt;symbol&gt;</code> 后不要求是整个 <code>&lt;expression&gt;</code> 。</li>
</ul>
</li>
<li><code>&lt;binding&gt;</code> 绑定列表，形式为 <code>&lt;symbol&gt; &lt;expressions&gt;</code> ，用于指定被求值的表达式和绑定参数的符号值。</li>
<li><code>&lt;bindings&gt;</code> ：绑定列表，即元素为 <code>&lt;binding&gt;</code> 的列表，形式为 <code>(&lt;binding&gt;...)</code> 。</li>
<li><code>&lt;body&gt;</code>： 出现在元素的末尾 <code>&lt;expressions&gt;</code> 形式，用于<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E4%BD%93">函数体</a>等替换求值的目标。</li>
<li><code>&lt;expression-sequence&gt;</code> ：同 <code>&lt;expression&gt;...</code> 但蕴含顺序求值其中的子项。
<ul>
<li>求值 <code>&lt;expression-sequence&gt;</code> 的结果是求值其最后一个子表达式（若存在）的结果，或当不存在子表达式时为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">未指定值</a>。</li>
</ul>
</li>
<li><code>&lt;consequent&gt;</code> ：同 <code>&lt;expression&gt;</code> ，仅用于 <a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;test&gt;</code></a> 求值结果经<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">左值到右值转换</a>不为 <code>#f</code> 时。</li>
<li><code>&lt;alternative&gt;</code> ：同 <code>&lt;expression&gt;</code> ，仅用于 <code>&lt;test&gt;</code> 求值结果经左值到右值转换为 <code>#f</code> 时。</li>
<li><code>&lt;ptree&gt;</code> ：形式参数树，是包含符号值或 <code>#ignore</code> 及其它形式参数树构成的 <a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">DAG</a> 的表达式。
<ul>
<li>语法要求由上下文无关文法描述：<code>&lt;ptree&gt; ::= &lt;symbol&gt; | #ignore | () | (&lt;ptree&gt;...)</code> 。</li>
</ul>
</li>
<li><code>&lt;definiend&gt;</code> ：被绑定项的目标的 <code>&lt;ptree&gt;</code> 。
<ul>
<li>引入绑定时，蕴含按<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">绑定规则</a>附加 <code>&lt;ptree&gt;</code> 以外的<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">绑定匹配</a>等语义检查。</li>
</ul>
</li>
<li><code>&lt;formals&gt;</code> ：作为形式参数的 <code>&lt;ptree&gt;</code> 。同 <code>&lt;definiend&gt;</code> 但允许<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">派生实现</a>定义更多检查。</li>
<li><code>&lt;clauses&gt;</code> ：元素为条件分支的列表，形式为 <code>(&lt;test&gt; &lt;body&gt;)...</code> 。</li>
<li><code>&lt;variable&gt;</code> ：<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">变量</a>。用于表示被<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">声明</a>的名称。
<ul>
<li>同 <code>&lt;symbol&gt;</code> ，其中的处理与作为非列表的 <code>&lt;formals&gt;</code> 相同。</li>
</ul>
</li>
</ul>
<p>　　关于 <code>eval</code> ，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　以 <code>&lt;expressions&gt;</code> 代替 <code>&lt;expression&gt;</code> 可避免语法中要求过多的括号及 <code>eval</code> 等求值形式中显式构造列表的需要。</p>
<p>　　因为 <code>&lt;body&gt;</code> 存在元素的末尾，明确元素中的其它词法元素后即可自然确定边界。</p>
<p>　　<code>&lt;body&gt;</code> 可以是多个表达式的词法组合，允许具体使用时不需要附加括号即可实现整体求值。</p>
<p>　　特别地，作为其它 <code>&lt;body&gt;</code> 嵌套的 <code>&lt;body&gt;</code> 实例在这种情况下，可以更有效地减少嵌套一层以上的括号。</p>
<p>　　<code>&lt;body&gt;</code> 整体求值的一个必要条件：构成 <code>&lt;body&gt;</code> 的表达式不被以其它方式分别求值，如蕴含<a href="Features/NPL.zh-CN.html#%E6%96%87%E6%B3%95%E5%85%83%E7%B4%A0%E8%A1%A5%E5%85%85%E7%BA%A6%E5%AE%9A">顺序求值</a>。</p>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RK] 不同，<code>&lt;body&gt;</code> 可以是多个表达式的词法组合。</p>
<p>　　尽管 <code>&lt;body&gt;</code> 不保证可直接构成一个表达式（而是构成某个表达式的所在元素中的多个子表达式），一般仍被作为一个整体求值。</p>
<p>　　被整体求值时，这些表达式被视为某个假想的表达式，这个表达式包含被整体求值的表达式作为子表达式。</p>
<p>　　若 <code>&lt;body&gt;</code> 存在超过一个子表达式，按求值算法的 <a href="Features/NPL.zh-CN.html#npla1-%E8%A7%84%E8%8C%83%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">NPLA1 规范求值算法步骤</a>，表达式分别作为合并子和之后的参数。</p>
<p>　　若 <code>&lt;body&gt;</code> 不存在子表达式，则结果是 <code>()</code> 而不是 <code>#inert</code> 。这和 [R<sup>n</sup>RK] 的经重定义而隐含 <code>$sequence</code> 的 <code>$vau</code> 以及 <code>$let</code> 等合并子不同，但和 <code>eval</code> 仍然相同。</p>
<h4 id="求值得到的操作数"><a class="header" href="#求值得到的操作数">求值得到的操作数</a></h4>
<p>　　求值得到的操作数的文法约定如下：</p>
<ul>
<li><code>&lt;object&gt;</code> ：一般对象，包括引用对象的<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8">引用值</a>。</li>
<li><code>&lt;reference&gt;</code> ：对象引用值。</li>
<li><code>&lt;pair&gt;</code> ：<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">有序对</a>。
<ul>
<li><strong>注释</strong> 可构成<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表或非真列表</a>。</li>
</ul>
</li>
<li><code>&lt;list&gt;</code> ：<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">列表</a>：空列表或第二个元素为空列表的有序对。</li>
<li><code>&lt;lists&gt;</code> ：元素都是列表的列表。</li>
<li><code>&lt;boolean&gt;</code> ：<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">布尔值</a>，值为 <code>#t</code> 或 <code>#f</code> 的集合。
<ul>
<li>是<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">类型映射</a>指定的用于条件判断的单一值的类型。</li>
<li>推论：<code>&lt;boolean&gt;</code> 对应的宿主类型是 <code>bool</code> 。</li>
</ul>
</li>
<li><code>&lt;test&gt;</code> ：类似 <code>&lt;object&gt;</code> ，通常预期为 <code>&lt;boolean&gt;</code> ，作为条件。
<ul>
<li>当<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>非 <code>#f</code> 时条件成立。</li>
<li><strong>原理</strong> 和 Scheme 类似但和 Kernel 不同，非 <code>#t</code> 的值在决定分支时视同 <code>#f</code> ，以允许在 <code>&lt;boolean&gt;</code> 外自然扩展的逻辑代数操作。</li>
<li><strong>原理</strong> 和 Common Lisp 不同，不使用空列表（或符号值 <code>nil</code> ）代替 <code>#f</code> ，以避免需要特设的规则以特定的其它类型的值（如 Common Lisp 的符号值 <code>t</code> ）表示逻辑真（这在逻辑非操作中不可避免）。</li>
</ul>
</li>
<li><code>&lt;combiner&gt;</code> ：<a href="Features/NPL.zh-CN.html#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>。</li>
<li><code>&lt;applicative&gt;</code> ：<a href="Features/NPL.zh-CN.html#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">应用子</a>。</li>
<li><code>&lt;operative&gt;</code> ：<a href="Features/NPL.zh-CN.html#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">操作子</a>。</li>
<li><code>&lt;predicate&gt;</code> ：<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">谓词</a>，是应用操作数的求值结果的值为 <code>&lt;test&gt;</code> 的 <code>&lt;applicative&gt;</code> 。
<ul>
<li><strong>注释</strong> 通常实现结果是 <code>&lt;boolean&gt;</code> 的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>。</li>
</ul>
</li>
<li><code>&lt;environment&gt;</code> ：<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">一等环境</a>。</li>
<li><code>&lt;parent&gt;</code> ：指定环境的<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">父环境</a>的值，包括：
<ul>
<li>环境引用值：<code>&lt;environment&gt;</code> 或以 <code>&lt;environment&gt;</code> 值作为被引用对象的 <code>&lt;reference&gt;</code> 。</li>
<li>元素为环境引用值的 <code>&lt;list&gt;</code> 。</li>
<li><a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>是元素为环境引用值的 <code>&lt;list&gt;</code> 的 <code>&lt;reference&gt;</code> 。</li>
</ul>
</li>
<li><code>&lt;string&gt;</code> ：字符串。
<ul>
<li>字符串是包括<a href="Features/NPL.zh-CN.html#npla-%E5%90%8D%E7%A7%B0%E5%92%8C%E5%AD%97%E9%9D%A2%E9%87%8F%E6%B1%82%E5%80%BC">数据字面量</a>作为表示的值的类型。</li>
<li>字符串的内部表示在具体实现中保持一致。除非另行指定，使用 <a href="https://www.iso.org/standard/76835.html">ISO/IEC 10646</a> 定义的 UCS 的 UTF-8 编码，其值不包含空字符（编码数值为 0 的 UCS 代码点）。</li>
<li>关于当前实现，另见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</li>
<li><strong>注释</strong> 为<a href="Features/NPL.zh-CN.html#npla1-%E4%BA%92%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">互操作</a>的兼容性，一般建议实现使用兼容 [ISO C++] 中定义的 <a href="https://eel.is/c++draft/multibyte.strings#2">NTMBS(null-terminated multibyte string)</a> 的方式表达。</li>
</ul>
</li>
<li>此外，支持的数值操作数参见 <a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">NPLA 数值类型</a>。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　<code>&lt;object&gt;</code> 等求值得到的操作数不保证是语法意义上连续的词法组合，不能由多个表达式构成，因此即便出现在元素末尾，也不能如 <code>&lt;body&gt;</code> 一样减少括号。</p>
<p>　　<code>&lt;object&gt;</code> 作为<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%85%A8%E9%9B%86">类型全集</a>，其元素可被断言在<a href="Features/NPL.zh-CN.html#%E5%BC%80%E6%94%BE%E6%80%A7">论域</a>内，即任何其它类型都是 <code>&lt;object&gt;</code> 的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>。<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>可对此进行验证。</p>
<p>　　和 [R<sup>n</sup>RK] 的理由不同，允许布尔代数以外扩展的比较判断在此不认为是易错的，而是有意的设计(by design) 。这避免预设地假定类型的名义语用作用（“角色(role) ” ），也避免限制语言和派生语言的类型全集的设计。</p>
<p><strong>注释</strong></p>
<p>　　空列表构成的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">单元类型</a>是真列表的子类型，而不是有序对的子类型。</p>
<p>　　非空真列表是有序对的子类型。</p>
<h4 id="文法元素补充约定"><a class="header" href="#文法元素补充约定">文法元素补充约定</a></h4>
<ul>
<li>除非另行指定，以 <code>&lt;symbols&gt;</code> 指定的值被作为 <code>&lt;definiend&gt;</code> 或 <code>&lt;formals&gt;</code> 使用时不引起错误。
<ul>
<li><strong>注释</strong> <code>&lt;symbols&gt;</code> 在被其它上下文使用时仍可能引起错误。</li>
</ul>
</li>
<li><code>&lt;symbols&gt;</code> 形式的符号列表在绑定变量名时支持引用标记字符 <a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6"><code>&amp;</code> 和 <code>%</code></a>。符号作为被绑定的初值符时，移除符号中发现的这些引用标记字符。</li>
<li><code>&lt;definiend&gt;</code> 和 <code>&lt;formals&gt;</code> 不要求重复符号值检查。另见<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">绑定操作</a>。</li>
<li>使用 <code>&lt;formals&gt;</code> 的情形包括合并子基本操作和可通过这些操作派生的操作在对应位置的操作数。
<ul>
<li><strong>原理</strong> [R<sup>n</sup>RK] 和 [Shu10] 都没有显式区分 <code>&lt;definiend&gt;</code> 和 <code>&lt;formals&gt;</code> ，两者在上下文中实质可互换，差别仅在 [R<sup>n</sup>RS] 中的 define 形式中定义的位置可具有和 <code>&lt;formals&gt;</code> 不兼容的扩展形式。</li>
<li><strong>注释</strong> 这实质等价使用 [Shu09] 中的记法，即 <code>&lt;formals&gt;</code> 用于除和 [Shu09] 的 <code>$define!</code> 类似外的所有操作（包括 <code>$set!</code> 和 <code>$let</code> 等，而不论是否对应 <code>&lt;body&gt;</code> ）。这些上下文中总是隐含了上述的可派生实现的要求。</li>
</ul>
</li>
<li><code>&lt;body&gt;</code> 不蕴含顺序求值子项。
<ul>
<li><strong>原理</strong> 这也允许 <code>&lt;body&gt;</code> 中的表达式被<a href="Features/NPL.zh-CN.html#%E6%9C%AA%E6%B1%82%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">整体求值</a>。</li>
</ul>
</li>
</ul>
<p>　　关于合并子基本操作，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　和传统 Lisp 方言（包括 [R<sup>n</sup>RS] 和 [R<sup>n</sup>RK] ）的函数体不同，<code>&lt;body&gt;</code> 的各个表达式之间不蕴含顺序求值。</p>
<p>　　因此，和 [R<sup>n</sup>RK] 不同，<code>$vau</code> 不需要在基本操作之后再次派生。这使操作的功能更加正交。</p>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RK] 不同，<code>&lt;symbols&gt;</code> 、<code>&lt;definiend&gt;</code> 和 <code>&lt;formals&gt;</code> 具有一些附加的约定支持；<code>&lt;body&gt;</code> 不蕴含顺序求值子项；NPLA1 的符号可通过<a href="Features/NPL.zh-CN.html#npla-%E5%90%8D%E7%A7%B0%E5%92%8C%E5%AD%97%E9%9D%A2%E9%87%8F%E6%B1%82%E5%80%BC">代码字面量求值</a>得到。</p>
<h2 id="npla1-对象语言语法"><a class="header" href="#npla1-对象语言语法">NPLA1 对象语言语法</a></h2>
<p>　　基于 NPLA 基本语法约定参见 <a href="Features/NPL.zh-CN.html#npla-%E6%95%B4%E4%BD%93%E7%BA%A6%E5%AE%9A">NPLA 整体约定</a>。</p>
<p>　　NPLA1 表达式符合 <a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">NPL 表达式语法</a>。</p>
<p><strong>注释</strong></p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">NPL-GA</a>包含的<a href="Features/NPL.zh-CN.html#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90">转义规则</a>中包含 <code>&lt;char-escape-seq&gt;</code> 的 <code>&lt;char-seq&gt;</code> 要求类似 [R<sup>6</sup>RS] 在字符串中的元素；其中仅有 \ 和 &quot; 被 [R<sup>5</sup>RS] 直接支持，而 [R<sup>7</sup>RS] 不支持 \v 。</p>
<p>　　后者支持的其它转义字符序列词法可被派生实现以 <code>&lt;$literal-char&gt;</code> 的形式另行指定（其中 [R<sup>7</sup>RS] 可涵盖对应 <code>&lt;char-escape-seq&gt;</code> 的功能）。</p>
<h3 id="npla1-字面量"><a class="header" href="#npla1-字面量">NPLA1 字面量</a></h3>
<p>　　基于 <a href="Features/NPL.zh-CN.html#npla-%E8%AF%8D%E6%B3%95%E5%92%8C%E8%AF%AD%E6%B3%95">NPLA 词法规则</a>，本节指定<a href="Features/NPL.zh-CN.html#%E5%AD%97%E9%9D%A2%E9%87%8F">字面量</a>的词素集合。</p>
<p>　　派生实现可指定不同的字面量，但不应和已指定词法构造的记号冲突，包括本节指定的字面量。</p>
<p>　　NPLA1 字面量都是<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>，但总是允许<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">实质化转换</a>为消亡值并引入允许<a href="Features/NPL.zh-CN.html#npla1-%E4%BA%92%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">互操作</a>的<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>。</p>
<p><strong>注释</strong> 这和宿主语言的字符串字面量是左值不同。当前 NPLA1 对象语言不提供能引起互操作差异的接口（字符串字面量不被修改），以后可能改变。</p>
<h4 id="字符串字面量"><a class="header" href="#字符串字面量">字符串字面量</a></h4>
<p>　　字符串字面量的类型为 <a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;string&gt;</code></a>。</p>
<h4 id="npla1-数值字面量"><a class="header" href="#npla1-数值字面量">NPLA1 数值字面量</a></h4>
<p>　　基于 <a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">NPLA 数值类型</a>和<a href="Features/NPL.zh-CN.html#npla-%E5%90%8D%E7%A7%B0%E5%92%8C%E5%AD%97%E9%9D%A2%E9%87%8F%E6%B1%82%E5%80%BC">数值字面量</a>，NPLA1 数值字面量的类型为 <code>&lt;number&gt;</code> 。</p>
<p>　　除非另行指定，数值的具体宿主类型未指定。</p>
<p><strong>注释</strong> 部分数值可指定具体的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>。</p>
<p>　　NPLA1 支持 <code>&lt;integer&gt;</code> 类型的精确数数值字面量和 <a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">flonum</a> 不精确数数值字面量。</p>
<p>　　支持的字面量包括词素符合 NPLAMath <a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E8%A1%A8%E7%A4%BA">数值表示</a>的字面量，以及：</p>
<p>　　匹配正则表达式 <code>(+|-)(inf|nan)\.(0|f|t)</code> ：带符号的特殊 flonum 值。</p>
<p>　　其中，<code>inf</code> 指定无限大值，<code>nan</code> 指定 NaN 值；后缀 0 、f 和 t 指定值具有宿主类型 double 、float 和 long double 。</p>
<p>　　派生实现可定义其它数值字面量。</p>
<p><strong>注释</strong></p>
<p>　　以上字面量包含十进制数值的字面量。其它字面量是 <a href="Features/NPL.zh-CN.html#npla-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F">NPLA 扩展字面量</a>。</p>
<p>　　无限大值和 NaN 值同 [Racket] 的字面量词法（参见 https://docs.racket-lang.org/reference/numbers.html ），除这些类型总是启用，且使用明确属于 flonum 且对应明确宿主类型的 long double 代替不被作为一般 flonum 的 extflonum 。</p>
<p>　　<a href="https://srfi.schemers.org/srfi-73/srfi-73.html">[SRFI-73]（已撤消）</a>提出扩展 [R<sup>5</sup>RS] 的带有 <code>#e</code> 或 <code>#i</code> 前缀的精确数和不精确数无限大值字面量，其中<a href="Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">前缀及精确数的支持</a>和 [R<sup>n</sup>RK] 类似。NPLA1 不支持无限大值精确数。</p>
<p>　　关于无限大值的在 [R<sup>n</sup>RS] 的一些实现情形，另见<a href="https://people.csail.mit.edu/jaffer/III/RAWI">这里</a>。</p>
<h4 id="npla1-扩展字面量"><a class="header" href="#npla1-扩展字面量">NPLA1 扩展字面量</a></h4>
<p>　　NPLA1 支持 <a href="Features/NPL.zh-CN.html#npla-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F">NPLA 扩展字面量</a>作为部分数值字面量。</p>
<p>　　NPLA1 还支持以下以 <code>#</code> 起始的扩展字面量：</p>
<ul>
<li><code>#t</code> ：<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">布尔值</a>逻辑真，类型为 <code>&lt;boolean&gt;</code> 。</li>
<li><code>#f</code> ：布尔值逻辑假，<code>&lt;boolean&gt;</code> 。</li>
<li><code>#true</code> ：同 <code>#t</code> 。</li>
<li><code>#false</code> ：同 <code>#f</code> 。</li>
<li><code>#inert</code> ：类似 Kernel 的 <code>#inert</code> 字面量，</li>
<li><code>#ignore</code> ：类似 Kernel 的 <code>#ignore</code> 字面量。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　<code>#inert</code> 和 <code>#ignore</code> 类似 [R<sup>n</sup>RK] 。</p>
<p>　　从表达上，<code>#inert</code> 和 <code>#ignore</code> 仍都可以被视为特定<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">单元类型</a>的值：等价的类型判断谓词可以直接使用值的相等关系确定。</p>
<p>　　和 [R<sup>n</sup>RS] 及 klisp 不同，不需要因兼容性支持扩展字面量中不同的大小写变体，特别是 [R<sup>6</sup>RS] 的 <code>#T</code> 和 <code>#F</code> 。</p>
<p><strong>注释</strong></p>
<p>　　[R<sup>5</sup>RS] 和 [R<sup>n</sup>RK] 指定 <code>#t</code> 和 <code>#f</code> 。[R<sup>7</sup>RS] 指定同义的 <code>#true</code> 和 <code>#false</code>（参见 https://small.r7rs.org/ticket/219/ ）。</p>
<p>　　后者被认为可提供若干可读性，但<a href="https://small.r7rs.org/ticket/526/">具有冗余</a>。本文档中，以下不使用 <code>#true</code> 和 <code>#false</code> 替代 <code>#t</code> 和 <code>#f</code> 。</p>
<p>　　派生实现可扩展支持，提供非 <code>&lt;boolean&gt;</code> 类型的布尔值，使用与这些字面量不同的对应表示。</p>
<h3 id="npla1-函数合并"><a class="header" href="#npla1-函数合并">NPLA1 函数合并</a></h3>
<p>　　以下使用 <a href="Features/NPL.zh-CN.html#%E5%85%83%E6%96%87%E6%B3%95%E5%9F%BA%E6%9C%AC%E7%BA%A6%E5%AE%9A"><code>...</code></a>作为函数的操作数时，可支持没有操作数的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>。此情形下应用表达式仍需要前缀 <code>()</code> ，但不在以下规约文法中显式地表示。</p>
<p><strong>注释</strong></p>
<p>　　和 Scheme 及 Kernel 不同，求值算法决定求值为<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并表达式</a>的语法表达不需要括号，且具有不同的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6%E6%B1%82%E5%80%BC">函数合并形式</a>。</p>
<h2 id="对象语言内存安全保证"><a class="header" href="#对象语言内存安全保证">对象语言内存安全保证</a></h2>
<p>　　对象语言可能提供关于<a href="Features/NPL.zh-CN.html#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>的检查。</p>
<p>　　除非另行指定，假定实现进行<a href="Features/NPL.zh-CN.html#npla1-%E4%BA%92%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">互操作</a>无法保证内存安全。</p>
<h3 id="对象语言基本内存安全保证"><a class="header" href="#对象语言基本内存安全保证">对象语言基本内存安全保证</a></h3>
<p>　　对象语言提供关于内存安全的基本保证：不存在违反内存安全相关的要求以外的未定义行为（包括<a href="Features/NPL.zh-CN.html#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>等）、不存在不保证内存安全的互操作且不存在<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E5%AE%89%E5%85%A8%E9%97%B4%E6%8E%A5%E5%80%BC%E8%AE%BF%E9%97%AE">不安全间接值访问</a>时，对象语言的程序执行保证内存安全。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">非内存安全操作</a>在对象语言中以不安全间接值访问的一部分情形体现。</p>
<h3 id="不安全操作"><a class="header" href="#不安全操作">不安全操作</a></h3>
<p>　　<em>不安全(unsafe)</em> 操作是可能在程序的执行中引入<a href="Features/NPL.zh-CN.html#npla1-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">未定义行为</a>的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作</a>。</p>
<p>　　这里的未定义行为包含在操作中直接引入的未定义行为，以及因为操作被执行而使程序在之后无法确保排除的未定义行为。</p>
<p>　　不安全操作是实现可选提供的。</p>
<p>　　当前对象语言不支持<a href="Features/NPL.zh-CN.html#npla-%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE">并发访问</a>对象。数据竞争仅可由和宿主语言的互操作引入。</p>
<h3 id="不安全间接值访问"><a class="header" href="#不安全间接值访问">不安全间接值访问</a></h3>
<p>　　对象语言的不安全<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值访问</a>包括：</p>
<ul>
<li>通过<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">无效的间接值</a>的间接访问。</li>
<li>通过可能由实现定义的其它不安全间接值访问。</li>
</ul>
<h4 id="无效的环境引用"><a class="header" href="#无效的环境引用">无效的环境引用</a></h4>
<p>　　环境对象被销毁导致<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E9%97%B4%E6%8E%A5%E5%80%BC">作为间接值的环境引用</a>被<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">无效化</a>。</p>
<p><strong>注释</strong></p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E7%94%9F%E5%AD%98%E6%9C%9F">环境生存期</a>。</p>
<h4 id="无效的引用值"><a class="header" href="#无效的引用值">无效的引用值</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">作为间接值的引用值</a>是间接值的实例，因此无效的间接值包含无效的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>，通过无效间接值访问包括无效的引用值的访问。</p>
<p>　　对象语言不提供<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7">悬空引用</a>以外构造无效引用值的操作。</p>
<p>　　对象语言中可引入悬空引用的情形包括：</p>
<ul>
<li>调用可能返回引用值的合并子，且没有另行保存函数体求值所在的<a href="Features/NPL.zh-CN.html#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>，<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>对应的对象不在生存期内：
<ul>
<li>绑定到形式参数的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">右值</a>保存在过程调用的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">局部环境</a>中，退出<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数体</a>的求值，局部环境被释放后，返回的其引用是悬空引用。</li>
<li>实现等效上述情形的派生操作的使用，如：
<ul>
<li><a href="Features/NPL.zh-CN.html#%E6%9C%AA%E6%B1%82%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">绑定列表</a><a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">传递引用</a>且<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">传递的引用值被求值</a>使用。</li>
<li>间接保留引用值可能提供变量绑定，这些绑定的目标对象可能依赖环境（如合并子的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">静态环境</a>），被销毁时访问被依赖的环境（如合并子调用求值函数体）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　关于间接保留引用值和互操作可能引入悬空引用的情形，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>注释</strong></p>
<p>　　另见<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8">对象语言的引用值</a>。</p>
<h4 id="其它无效的间接值"><a class="header" href="#其它无效的间接值">其它无效的间接值</a></h4>
<p>　　使用其它不保证内存安全的操作可引入<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">不具有内存安全保证的间接值</a>访问实体。</p>
<p>　　这些间接值可能因为和<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7">悬空引用</a>相同的情形<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">无效化</a>。</p>
<h3 id="保留间接值"><a class="header" href="#保留间接值">保留间接值</a></h3>
<p>　　对象的（直接或间接）<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>是间接值时，对象包含间接值。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>对象为间接值或使之包含间接值时，对象保留间接值。</p>
<p>　　被保留的间接值是对应的通过修改得到或包含的间接值。</p>
<p>　　本节中的概念对应适用于具体的间接值，如被保留的引用值和函数<a href="Features/NPL.zh-CN.html#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E7%9B%AE%E6%A0%87">在结果中保留引用值</a>。</p>
<h4 id="被保留的引用值的目标"><a class="header" href="#被保留的引用值的目标">被保留的引用值的目标</a></h4>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>返回（在对象语言中允许出现的，下同）间接值或包含间接值的对象时，在<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>中保留间接值。</p>
<p>　　函数调用修改环境使<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境对象</a>保留间接值（绑定间接值或包含间接值作为子对象的对象作为<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>）时，在环境中保留间接值。</p>
<p>　　函数调用修改<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>或其子对象，使之保留间接值时，在对象中保留间接值。</p>
<p>　　在函数值中保留间接值、在环境中保留间接值、在对象中保留间接值的函数保留间接值。</p>
<p>　　被保留的间接值被函数调用的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>蕴含时，函数在结果中保留间接值。</p>
<p><strong>注释</strong></p>
<p>　　函数调用的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">求值结果</a>排除<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>即函数值。</p>
<p>　　在结果中保留间接值包含以下情形：</p>
<ul>
<li>在函数值中保留间接值。</li>
<li>在环境中保留间接值，环境是函数值或其子对象。</li>
<li>在对象中保留间接值，对象是函数值的子对象。</li>
</ul>
<h4 id="被保留的引用值的来源"><a class="header" href="#被保留的引用值的来源">被保留的引用值的来源</a></h4>
<p>　　函数返回包含间接值的对象由参数的值决定时，保留参数中的间接值。</p>
<p>　　按被保留的间接值的来源，这分为以下两个子类：</p>
<ul>
<li>直接保留间接值：接受间接值参数。</li>
<li>间接保留间接值：接受的参数或参数在特定环境中被求值得到的结果决定是否直接保留间接值。
<ul>
<li><strong>注释</strong> 如合并子或构成<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">形式参数树</a>的可能带有<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">引用标记字符</a>的<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>。</li>
</ul>
</li>
</ul>
<h4 id="保留间接值的操作"><a class="header" href="#保留间接值的操作">保留间接值的操作</a></h4>
<p>　　操作可保留间接值：</p>
<ul>
<li>使用函数调用实现的操作可通过<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>保留间接值。</li>
<li>其它实现方式可等效地保留间接值。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　在结果中保留间接值的操作不区分被保留的间接值的来源和目标。但多数情形下，这通过函数值保留参数中的间接值蕴含。</p>
<h4 id="保留间接值和内存安全"><a class="header" href="#保留间接值和内存安全">保留间接值和内存安全</a></h4>
<p>　　保留间接值操作的内存安全的一个必要条件是所有被保留的间接值在之后的使用中都满足内存安全。</p>
<p>　　保留间接值在操作后可能因<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值无效</a>（如<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7">悬空引用</a>），无法继续保证内存安全。</p>
<p>　　在环境中保留间接值时，应保证环境具有足够的生存期，以避免间接值依赖无效的环境引用导致访问环境中对象的未定义行为。</p>
<h3 id="对象语言接口的安全保证机制"><a class="header" href="#对象语言接口的安全保证机制">对象语言接口的安全保证机制</a></h3>
<p>　　对象语言接口的安全保证机制提供不同接口的分类，通过允许区分是否具有内存安全保证的接口帮助程序利用<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">对象语言基本内存安全保证</a>。</p>
<p>　　通过避免或限制使用<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">不安全操作</a>，实现上述安全保证。</p>
<p>　　因为允许引入 <a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">NPLA 未定义行为</a>，无法提供安全证明的<a href="Features/NPL.zh-CN.html#npla1-%E4%BA%92%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">互操作</a>应视为不安全操作。</p>
<p>　　基于<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值算法</a>的安全保证的非形式的证明框架概述如下：</p>
<ul>
<li>任意步骤中，访问间接值指定的目标对象是安全的，仅当间接值是安全的。</li>
<li><a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>的求值是安全的，仅当引用的环境是安全的。</li>
<li>合并子调用的求值是安全的，仅当合并子、操作数及调用的操作是安全的。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　满足安全保证的推理如下：</p>
<ul>
<li>因为 NPLA 实现的非互操作引入的、非求值规约的<a href="Features/NPL.zh-CN.html#%E7%AE%A1%E7%90%86%E8%A7%84%E7%BA%A6">管理规约</a>不存在未定义行为，以上求值算法中的步骤中通过排除不安全的实体能保证规约中不存在未定义行为。</li>
<li>因为<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E8%A7%84%E5%88%99%E5%92%8C%E6%B1%82%E5%80%BC">规约决定程序执行的语义</a>，在求值中排除不安全的实体可以保证不存在未定义行为，而满足安全保证。</li>
</ul>
<h4 id="安全性附加证明"><a class="header" href="#安全性附加证明">安全性附加证明</a></h4>
<p>　　一些不安全操作是否蕴含未定义行为可能依赖具体调用使用的操作数。</p>
<p>　　若能证明特定的前提保证任意的调用实例中的操作数满足附加的安全假设，则这些不安全操作的调用仍可保证安全。</p>
<p>　　排除不确保安全性假设的互操作时，NPLA1 提供附加调用安全：若不存在<a href="Features/NPL.zh-CN.html#%E9%9A%90%E8%97%8F%E7%8E%AF%E5%A2%83">隐藏环境</a>中绑定的可修改对象的引用，则仅因可能违反<a href="Features/NPL.zh-CN.html#%E8%A2%AB%E7%BB%91%E5%AE%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%80%BC%E5%92%8C%E5%8F%AF%E8%A7%82%E5%AF%9F%E8%A1%8C%E4%B8%BA">值稳定性</a>的不安全操作的调用是安全的。</p>
<p>　　派生实现可对特定调用附加使用限制以便提供证明，或定义其它的调用并提供更强的保证。</p>
<h2 id="诊断"><a class="header" href="#诊断">诊断</a></h2>
<p>　　NPLA1 的特定<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值步骤</a>可引起<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">诊断</a>。</p>
<p>　　引起诊断时<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>被终止，或在失败可被恢复时以其它派生实现定义的方式继续求值。</p>
<p>　　其它引起诊断的条件可被派生实现补充指定。</p>
<p><strong>注释</strong> 注意<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未定义行为</a>取消对诊断的要求。</p>
<p>　　本节以外的<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">诊断消息</a>的其它形式未指定。</p>
<p><strong>注释</strong></p>
<p>　　引起诊断的求值包括：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">抽象求值</a>的失败。
<ul>
<li>例如，REPL(read-eval-print loop) 中进行的翻译。</li>
</ul>
</li>
<li>在<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">环境</a>中访问指定名称的对象失败时。</li>
<li>特定的函数应用。</li>
</ul>
<p>　　其它求值条件详见具体操作的规定。</p>
<h3 id="npla1-错误"><a class="header" href="#npla1-错误">NPLA1 错误</a></h3>
<p>　　NPLA1 中的<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">错误</a>是按接口的约定不符合预期的<a href="Features/NPL.zh-CN.html#%E5%BC%82%E5%B8%B8">正常条件</a>（如<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF%E6%A3%80%E6%9F%A5">不被正常处理的操作数类型</a>）引起的诊断。</p>
<p>　　求值特定的表达式可<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起错误</a>，包括：</p>
<ul>
<li>违反<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值算法</a>步骤中的要求而直接引起的<em>语法错误(syntax error)</em> 。</li>
<li>其它情形引起的<em>语义错误(semantic error)</em> 。</li>
</ul>
<p>　　以<a href="Features/NPL.zh-CN.html#%E6%8E%A5%E5%8F%A3%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">接口文法约定</a>的形式约定的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作</a>中，除<a href="Features/NPL.zh-CN.html#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>外，<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96">绑定初始化</a>之前的<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">参数绑定</a>失败是语法错误。</p>
<p>　　语法错误包含两类：</p>
<ul>
<li>总是依赖程序运行时确定的值不满足特定操作的要求引起动态语法错误。</li>
<li>其它语法错误违反<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">语法正确性</a>要求，是静态语法错误。</li>
</ul>
<p>　　类似地，语义错误包含两类：</p>
<ul>
<li>总是依赖程序运行时确定的值不满足特定操作的要求引起动态语义错误。</li>
<li>其它语义错误违反<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">语义正确性</a>要求，是静态语义错误。</li>
</ul>
<p>　　静态语法错误可能通过语法分析从源代码决定。</p>
<p>　　引起动态语法错误或动态语义错误依赖的值是合并子的具体实际参数的值，以及派生实现可选指定的其它的值。</p>
<p>　　引起动态语法错误或动态语义错误的情形包括求值特定的函数应用，由具体操作指定。</p>
<p>　　程序可通过<em>引发(raise)</em> 一个<em>错误对象(error object)</em> 指定引起诊断。</p>
<p>　　除非另行指定，NPLA1 的错误对象不需要是 NPLA1 支持的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">对象</a>，而可以仅在<a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>中可见。</p>
<p>　　因果性引起的错误可构成错误之间具有依赖关系。</p>
<p>　　错误对象的其它具体形式由派生实现指定。</p>
<h3 id="npla1-异常"><a class="header" href="#npla1-异常">NPLA1 异常</a></h3>
<p>　　NPLA1 的当前诊断使用的<a href="Features/NPL.zh-CN.html#%E5%BC%82%E5%B8%B8">异常</a>执行机制由宿主语言支持，通过宿主语言中的异常类型区分不同的异常条件。</p>
<p>　　NPLA1 约定的所有要求引起异常的诊断情形都是错误。</p>
<p><strong>注释</strong> 用户操作引起异常不一定是错误。</p>
<p>　　不引起未定义行为的翻译失败应<a href="Features/NPL.zh-CN.html#%E5%BC%82%E5%B8%B8">抛出异常</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">引发错误对象</a>可能通过抛出异常实现。此时，被抛出的宿主语言异常对象是错误对象。被抛出的异常类型可具有被显式指定的 <code>public</code> 基类，这些基类应无歧义以允许宿主语言捕获。</p>
<p>　　若存在<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">依赖错误</a>且引发被依赖的错误对象使用抛出异常实现，使用宿主语言标准库的<em>嵌套异常(nested error)</em> 机制实现依赖错误。</p>
<p>　　当前没有提供相关操作，但抛出的宿主异常在具有<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>的意义上是 NPLA1 的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>。</p>
<p>　　关于抛出异常的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>，参见项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h3 id="运行时错误条件"><a class="header" href="#运行时错误条件">运行时错误条件</a></h3>
<p>　　除非另行指定，实现应对以下全局的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">运行时</a><a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">错误条件</a>按要求引起诊断。</p>
<p>　　当实现无法提供需要的资源，<em>资源耗尽(resource exhaustion)</em> 。此时，引发特定的关于资源耗尽的错误对象。</p>
<p>　　除非另行指定，上述表示资源耗尽的错误对象满足宿主语言的以下类型的异常对象：</p>
<ul>
<li>宿主资源耗尽时，异常类型满足<a href="Features/NPL.zh-CN.html#%E5%B8%B8%E8%A7%84%E5%AE%BF%E4%B8%BB%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E8%A6%81%E6%B1%82">常规宿主资源分配要求</a>的类型。</li>
<li>否则，同<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%82%E5%B8%B8">异常</a>。</li>
</ul>
<p><strong>注释</strong> [ISO C++] 的本机实现宿主资源耗尽时，一般抛出派生 <code>std::bad_alloc</code> 的异常对象。这不包括<a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">本机实现无法提供资源的未定义行为</a>。</p>
<h3 id="错误检查"><a class="header" href="#错误检查">错误检查</a></h3>
<p>　　<em>检查(check)</em> 是限定成功的操作应满足的（必要非充分）条件引起诊断的操作。检查失败时要求引起诊断。</p>
<p>　　<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">良定义的</a>检查应具有<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">强规范化性质</a>，以保证有限数量的检查总在有限的计算步骤内终止。在进行检查的<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">上下文</a>，实现假定检查良定义。</p>
<p><strong>注释</strong> 实现不需在此之前对检查的这个性质附加检查。</p>
<p>　　检查条件限定检查的通过或失败。除非另行指定，通过的检查没有<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>，失败时总是具有作用。</p>
<p><strong>注释</strong> 检查失败通常可引起<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>。</p>
<p>　　NPLA1 要求在特定上下文进行<a href="Features/NPL.zh-CN.html#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>。派生实现可定义其它检查。</p>
<p>　　函数操作的语义可单独指定检查，具体形式由具体操作指定。</p>
<h4 id="npla1-类型检查"><a class="header" href="#npla1-类型检查">NPLA1 类型检查</a></h4>
<p>　　基于<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义类型</a>，对象语言实现应具有语义规则指定的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>，以确保程序的执行符合操作的必要前置条件。</p>
<p>　　操作的语义可要求以下的类型检查：</p>
<ul>
<li>对<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">求值得到的操作数</a>，按<a href="Features/NPL.zh-CN.html#%E6%8E%A5%E5%8F%A3%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">文法约定</a>的约束进行类型检查。</li>
<li>根据特定对象状态，指定<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">动态类型</a>的检查。
<ul>
<li><strong>注释</strong> 可通过类型检查规则明确要求对象具有特定的属性，例如<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">可修改</a>。</li>
</ul>
</li>
</ul>
<p>　　实现可能添加其它不违反语义要求的类型检查。</p>
<p>　　基于<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B">表达式的类型</a>，对应对象语言表达式的表示实体的元素可指定操作数上明确的类型要求。</p>
<p>　　部分实体从属于其它实体类型而构成<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>关系；部分的规约操作取得求值结果保证结果中的值可能具有的特定类型集合，这些类型也一并在以下描述中给出；其它情形不指定类型。</p>
<p>　　规约预期符合约束。若违反由项的表示的对象的动态类型不匹配导致，则求值失败；否则，行为未指定。</p>
<p>　　类型检查的完成应<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序</a>依赖被检查特定类型的值的访问。</p>
<p>　　除非另行指定，类型检查和程序中的其它作用（包括不同的其它类型检查）的顺序未指定。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型错误</a>引发错误对象。</p>
<p>　　若<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">合并子调用</a>不接受<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">非真列表</a>参数构成<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>，检查参数是<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>，即<em>参数列表(parameter list)</em> 。对参数列表的类型检查的完成应先序于其中任意子表达式的求值。</p>
<p><strong>原理</strong></p>
<p>　　类型检查有助于维护程序的正确性，并及早发现编程错误。</p>
<p>　　但是，类型检查自身存在开销；在一个阶段中集中检查类型的限制不是必要的。特别地，<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">静态类型检查</a>不被要求。</p>
<p>　　这些设计同时确保程序容易在程序在实现的不同<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">执行阶段</a>重现相同的检查逻辑乃至直接复用其实现。</p>
<p>　　为减小开销等目的，实现可能合并不同类型检查，而不改变程序的<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>。</p>
<p>　　对子表达式的求值需<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>子表达式。因此，对参数列表的检查蕴含顺序要求。</p>
<p><strong>注释</strong></p>
<p>　　一个值可被多次针对不同的对象进行类型检查。</p>
<p>　　不同的类型检查中，对特定类型的值的访问之间没有必然的隐含联系。</p>
<h2 id="npla1-外部表示"><a class="header" href="#npla1-外部表示">NPLA1 外部表示</a></h2>
<p>　　<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">外部表示</a>若被确定，由实现和派生实现定义。</p>
<p>　　NPLA1 不要求对象和其它实体存在外部表示，也不要求外部表示唯一。</p>
<p><strong>注释</strong></p>
<p>　　对外部表示的存在性要求和 [R<sup>n</sup>RK] 不同。</p>
<p>　　NPLA1 当前直接使用其它已被指定的表示规则，如<a href="Features/NPL.zh-CN.html#npla1-%E4%BA%92%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">互操作</a>隐含的宿主语言对象表示。</p>
<p>　　NPLA1 当前不提供可移植的互操作接口（包括一些基本 I/O 操作），也不约定其涉及的外部表示形式。</p>
<h2 id="表达式语义"><a class="header" href="#表达式语义">表达式语义</a></h2>
<p>　　表达式具有和<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">语法构造</a>不直接相关的且可能<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">上下文相关</a>的语义。</p>
<p>　　部分语义不需要通过<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>体现。</p>
<h3 id="npla1-规范求值算法"><a class="header" href="#npla1-规范求值算法">NPLA1 规范求值算法</a></h3>
<p>　　以<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">被求值的表达式</a>和所在的环境作为参数，NPLA1 使用以下<em>规范(canonical)</em> 求值算法取得表达式的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>：</p>
<ol>
<li><a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">自求值</a>：若被求值的表达式不是<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>且不是<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">有序对</a>，则求值结果是自身。</li>
<li><a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>：若被求值的表达式是一个符号值，则被视为<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">变量名</a>，求值结果是它在<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">上下文</a>（当前环境确定的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83%E6%8F%90%E4%BE%9B%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">词法作用域</a>）中变量绑定确定的对象的经<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">引用折叠</a>的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B">左值引用</a>。</li>
<li>否则：
<strong>注释</strong> 被求值的表达式是有序对。
<ol>
<li>若被求值的表达式是具有一个<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">元素</a>（<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">子表达式</a>）的<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">列表</a>，则求值结果是这个子表达式的求值结果。否则，继续以下求值步骤。
<strong>注释</strong> 被求值的表达式是具有不少于一个元素的列表或非真列表。</li>
<li>若被求值的表达式第一个子表达式是空列表，则移除，并继续以下求值。
<strong>注释</strong> 起始空列表的语法用于继续求值可能不提供<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">实际参数</a>的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>。具有实际参数的函数合并不一定需要起始空列表。</li>
<li>对第一个子表达式求值。</li>
<li>以第一个子表达式的求值结果作为<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作符</a>，以其余子表达式作为操作数，求值<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">合并</a>。</li>
</ol>
</li>
</ol>
<p>　　有序对以外的表达式被求值时：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">标识符</a>的值是构成标识符的符号值。</li>
<li><a href="Features/NPL.zh-CN.html#%E5%AD%97%E9%9D%A2%E9%87%8F">代码字面量</a>的值是去除其边界的 <code>'</code> 的标识符构成的符号值。
<strong>注释</strong> 代码字面量可表达直接作为标识符时不能作为符号值的词素的转义，例如 <code>''</code> 是一个空的符号值；而 <code>'#ignore'</code> 和 <code>42</code> 这样的形式允许其中的表达作为变量名，而不是字面量。</li>
<li><code>#t</code> 和 <code>#f</code> 求值为自身，是<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">布尔值</a>。</li>
<li><code>#ignore</code> 和 <code>#inert</code> 求值为自身，具有和其它值不同的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">单元类型</a>。</li>
<li>数值字面量求值为<em>数值(numerical value)</em> 。</li>
</ul>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">非空列表</a>和代码字面量以外的对象作为表达式，都是<a href="Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F">自求值表达式</a>。</p>
<p><strong>原理</strong></p>
<p>　　NPLA1 规范<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>和 [R<sup>n</sup>RK] 中定义的 Kernel 求值算法（以及 [Shu10] 中定义的 <a href="Features/NPL.zh-CN.html#%E5%85%B6%E5%AE%83%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8F%82%E8%80%83">vau 演算</a>）类似，差异为：</p>
<ul>
<li>求值算法不直接约定取得 <a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">WHNF</a> 以外的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">子项</a>是否被求值，而由被调用的第一个子项决定。</li>
<li><a href="Features/NPL.zh-CN.html#%E8%AE%B0%E5%8F%B7%E6%B1%82%E5%80%BC">对符号值的求值</a>包含对<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>的区分。</li>
<li>要求一个子项的列表总是使用其列表元素求值。</li>
</ul>
<p>　　最后一个差异在对象语言中是实质性的，它决定<a href="Features/NPL.zh-CN.html#%E5%88%97%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">列表表达式</a>和其中的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">子表达式</a>的求值总是等价。</p>
<p>　　求值算法保持<a href="Features/NPL.zh-CN.html#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>。</p>
<p>　　NPLA1 翻译单元中，未求值的表达式满足以下性质：</p>
<ul>
<li>作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">记号</a>的标识符是<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号</a>类型的值。</li>
<li><a href="Features/NPL.zh-CN.html#%E5%88%97%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">列表表达式</a>中若不含有<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">子表达式</a>，则这个表达式是<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">空列表</a>；否则，是非空的<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>，子表达式是它的<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">元素</a>。</li>
</ul>
<p>　　NPLA1 规范求值算法和 [R<sup>n</sup>RK] 的求值算法具有近似的简单性。</p>
<p>　　因为 NPLA1 <a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">不支持存在环的非真列表</a>，<a href="Features/NPL.zh-CN.html#%E6%9C%89%E5%BA%8F%E5%AF%B9">cons 对</a>的描述被对应替换。</p>
<p>　　求值算法使用的环境同 [R<sup>n</sup>RK] 。</p>
<p>　　同 [R<sup>n</sup>RK] ，而非 [R<sup>n</sup>RS] ，NPLA1 规范求值算法避免对<em>顶层(top-level)</em> 的特殊引用，以避免<a href="Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">上下文相关性</a>的不同规则带来的复杂性和限制。</p>
<p>　　使用顶层的不同求值规则的限制可能简化一些编译实现需要的假设。但这泄漏了抽象，且在实际使用中<a href="https://gist.github.com/samth/3083053">引起大量问题</a>。</p>
<p>　　特别地，不同的顶层的特设规则相对更动态，反映<a href="https://calculist.blogspot.com/2009/01/fexprs-in-scheme.html">一些用户对 fexpr 的期望</a>，但在此这已被 vau 抽象替代。因此，使用不同的顶层求值规则以提供更强的动态性是多余的。</p>
<p>　　另一方面，当前环境一般允许被<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">具现</a>为<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">一等环境</a>在程序中可编程地访问而代表求值算法使用的上下文。为不同的上下文特设不同的顶层求值规则也是多余的。</p>
<p>　　关于实现，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p>　　以下各节补充描述 NPLA1 规范求值算法的局部性质。</p>
<p><strong>注释</strong></p>
<p>　　关于 WHNF 求值在 Kernel 中的描述，参见 [R<sup>n</sup>RK] 关于 <code>unwrap</code> 的 Rationale 的描述。</p>
<p>　　语法分析器的实现应使结果取得和这些性质兼容的中间表示。</p>
<h4 id="函数合并求值"><a class="header" href="#函数合并求值">函数合并求值</a></h4>
<p>　　求值算法向函数合并传递当前环境作为<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">函数合并的动态环境</a>。</p>
<p>　　为支持没有操作数的函数应用，需约定其它表达式表达求值为<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并的应用表达式</a>：</p>
<ul>
<li>当<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F">复合表达式</a>的第一个子表达式是空列表（<code>()</code>）时，求值为一个函数合并。
<ul>
<li><strong>注释</strong> 对没有操作数的情形，这是唯一被直接支持函数应用的语法</li>
</ul>
</li>
<li>否则，求值的作用同移除第一个子项 <code>()</code> 后的剩余形式。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　关于区分函数类型的替代设计（使用 <code>$</code> 作为第一个<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">子项</a>）的一个例子，参见<a href="https://eighty-twenty.org/2011/09/29/fexprs-remain-inscrutable#comment-422279775">这里</a>。</p>
<p>　　基于其中类似的对语义的影响（区分函数合并是否针对一个操作子）上的理由，这不被使用。</p>
<p>　　与此不同，尽管在对象语言中接受 <code>()</code> 的使用也需要求值算法的显式支持，这在目的上是纯语法意义上的——仅在无法避免语法歧义时，才必须使用。</p>
<p>　　只要能确定求值算法使用的环境，就能静态地区分复合表达式是否是函数合并。此时，其中的第一个子表达式是否显式为 <code>()</code> 不影响关于语义的推理。使用不同的内部中间表示可完全消除是否使用 <code>()</code> 的函数合并的差异；或者，也可以约定在代码中默认使用第一个子项是 <code>()</code> 的表达式作为函数合并的规范形式，而把第一个子项不是 <code>()</code> 的形式视为隐含 <code>()</code> 的语法糖。</p>
<p>　　因此，相对使用 <code>$</code> 而言，使用 <code>()</code> 的设计具有更少的缺陷（尽管需要更多的字符）。</p>
<h4 id="空列表求值"><a class="header" href="#空列表求值">空列表求值</a></h4>
<p>　　空列表 <code>()</code> 作为表达式是自求值表达式，而不是没有函数的空过程调用。</p>
<p><strong>原理</strong></p>
<p>　　关于 <code>()</code> 的求值规则避免这种简洁有用的语法导致<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">语法错误</a>。</p>
<p><strong>注释</strong></p>
<p>　　这和 [R<sup>n</sup>RS] 不同而同 [R<sup>n</sup>RK] 。在前者构造空列表需要 <code>'()</code> 。</p>
<p>　　和 Kernel 不同的函数合并求值规则使这个设计和函数求值字面上没有直接的关联，避免了 Kernel 中为什么 <code>()</code> 不是词法上类似的如 <code>(f x)</code> 这样的表达式的特例的问题。</p>
<p>　　注意以 <code>()</code> 作为前缀并不要求要求特定函数的子类型而可能破坏子类型<a href="Features/NPL.zh-CN.html#%E5%B0%81%E8%A3%85">封装性</a>的假设。</p>
<h4 id="记号求值"><a class="header" href="#记号求值">记号求值</a></h4>
<p>　　具有不同大小写字符的标识符不同。</p>
<p>　　可使用（能在求值时作为名称的）<a href="Features/NPL.zh-CN.html#npla-%E5%90%8D%E7%A7%B0%E5%92%8C%E5%AD%97%E9%9D%A2%E9%87%8F%E6%B1%82%E5%80%BC">代码字面量</a>即 '' 分隔）表达没有分隔符时被解释为字面量或其它值的符号值。</p>
<p>　　<a href="Features/NPL.zh-CN.html#npla-%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B">符号值</a>作为<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">名称表达式</a>，经<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>求值，访问当前环境中的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>。</p>
<p>　　其中，若被绑定对象是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>，结果是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">被折叠一次</a>的引用值；否则，结果是被绑定对象作为<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的引用值。</p>
<p>　　求值的结果是确保为<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>引用值。</p>
<p>　　结果不继续特别处理。引用值在此作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>，作为表达式时<a href="Features/NPL.zh-CN.html#%E9%BB%98%E8%AE%A4%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2%E7%BA%A6%E5%AE%9A">不发生左值到右值转换</a>。</p>
<p><strong>注释</strong></p>
<p>　　标识符大小写敏感的设计和 [R<sup>5</sup>RS] 及 klisp 不同，而和 [R<sup>6</sup>RS] 相同。和 [R<sup>7</sup>RS] 的默认行为相同，但不提供切换大小写不敏感的方法。</p>
<p>　　代码字面量和 klisp 使用 <code>||</code> 作为分隔符的语法不同，但作用类似。</p>
<p>　　和 klisp 不同，NPLA1 允许使用 <code>.</code> 作为变量名，但在特定的上下文不被求值时符号值 <code>.</code> 可被特别处理，如<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">绑定匹配</a>时忽略以 <code>.</code> 为符号值的绑定。</p>
<p>　　和 klisp 不同，NPLA1 允许使用 <code>++</code> 等全以 <code>+</code> 或 <code>-</code> 组成的字符序列构成标识符。</p>
<p>　　以 <code>#</code> 、<code>+</code> 或 <code>-</code> 起始的不能构成标识符的词素是 <a href="Features/NPL.zh-CN.html#npla-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F">NPLA 扩展字面量</a>。</p>
<h3 id="对象语言求值算法"><a class="header" href="#对象语言求值算法">对象语言求值算法</a></h3>
<p>　　除非另行指定，NPLA1 对象语言的求值总是使用 <a href="Features/NPL.zh-CN.html#npla1-%E8%A7%84%E8%8C%83%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">NPLA1 规范求值算法</a>。</p>
<p>　　在输入求值算法接受的语法形式之前，求值使用基于<a href="Features/NPL.zh-CN.html#%E4%B8%AD%E7%BC%80%E8%AF%AD%E6%B3%95">中缀语法</a>识别的分隔符进行处理。</p>
<p>　　由此引起的其它语法差异参见<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>。</p>
<h4 id="中缀语法"><a class="header" href="#中缀语法">中缀语法</a></h4>
<p>　　NPLA1 提供符合特定谓词指定的过滤条件的中缀分隔项替换为特定<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">名称表达式</a>指定的前缀操作形式的列表。</p>
<p>　　这些中缀变换作为预处理操作，可识别和接受 <a href="Features/NPL.zh-CN.html#%E8%AF%AD%E5%8F%A5">NPL-GA 语法</a>外的记号，即转换扩展的 <a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">NPL-GA 文法</a>输入为严格的 NPL-GA 语法要求的源语言。</p>
<p>　　中缀变换递归替换构成表达式的形如 <code>&lt;expression&gt; (&lt;infix&gt; &lt;expression&gt;)*</code> 的记号序列为 <code>&lt;transformed-infix&gt; &lt;expression&gt;+</code> 形式的记号序列。</p>
<p>　　其中，被支持的中缀记号 <code>&lt;infix&gt;</code> 是 <code>;</code> 或 <code>,</code> ，而 <code>&lt;transformed-infix&gt;</code> 是语法不可见的中缀变换函数。</p>
<p>　　其中，分隔符 <code>,</code> 优先组合。</p>
<p>　　分隔符对应的 <code>&lt;transformed-infix&gt;</code> 分别表示对被分隔的序列参数进行有序和无序列表求值（替换后合并子功能对应<a href="Features/NPL.zh-CN.html#npla1-%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83">参照实现环境</a>中函数 <code>$sequence</code> 和 <code>list%</code> 求值后的合并子）。</p>
<p>　　对分隔符的处理使用和组合顺序相反的两遍分别对 <code>;</code> 和 <code>,</code> 遍历替换。</p>
<p>　　变换的不同 <code>&lt;expression&gt;</code> 的实例以相同的词法顺序在变换后的结果中被保存。</p>
<p>　　关于函数 <code>$sequence</code> 和 <code>list%</code> ，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h4 id="求值算法实现风格"><a class="header" href="#求值算法实现风格">求值算法实现风格</a></h4>
<p><strong>原理</strong></p>
<p>　　和 Scheme 不同而和 Kernel 类似，求值通常使用显式的风格（详见 [Shu10] ）而不是依赖 <code>quote</code> 的隐式风格；这和不需要括号的语法特性无关。</p>
<h3 id="值类别和类型"><a class="header" href="#值类别和类型">值类别和类型</a></h3>
<p>　　基本内容参见 <a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">NPLA 值类别</a>和<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B">表达式的类型</a>。</p>
<p>　　特定的表达式维护<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">可修改性</a>。</p>
<p><strong>注释</strong> 这类似宿主语言的 <code>const</code> 类型限定，但只适合<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>且仅使用<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">隐式类型</a>。</p>
<p>　　特定的操作集合可约定关于确定结果值类别和类型的具体规则，如<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E7%BA%A6%E5%AE%9A">子对象访问约定</a>。</p>
<h3 id="绑定操作"><a class="header" href="#绑定操作">绑定操作</a></h3>
<p>　　绑定操作决定<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>或具有符号值的数据结构与项的对应关系，并<a href="Features/NPL.zh-CN.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a><a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>而引入<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">变量</a>。</p>
<p>　　作为<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数语法</a>的推广，两者分别由绑定操作使用<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">形式参数</a>和<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>指定。</p>
<p>　　操作数的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>具有树的构造，即<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数树</a>。</p>
<p>　　为决定形式参数对应的操作数，形式参数和操作数树或它们的<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的结构被比较，即绑定<em>匹配(match)</em> 。匹配操作数树的形式参数对应也可具有树的构造，即<em>形式参数树(formal parameter tree)</em> 。</p>
<p>　　被匹配的操作数是操作数树作为<a href="Features/NPL.zh-CN.html#%E6%9C%89%E5%BA%8F%E5%AF%B9">有序对</a>的<a href="Features/NPL.zh-CN.html#%E6%9C%89%E5%BA%8F%E5%AF%B9">元素</a>。类似地，形式参数是形式参数树作为有序对的元素。</p>
<p>　　绑定操作初始化对应的变量的名称和值分别由形式参数树和操作数树决定。</p>
<p>　　NPLA1 形式参数树具有特定的语法规则：树的叶节点为<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>、符号的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>或其它形式参数树构成的 <a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">DAG</a> 。若构造的形式参数树不符合语法规则，<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF">引起错误</a>，不进行绑定。</p>
<p>　　成功的匹配决定形式参数对应的操作数或其<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">子项</a>，作为其<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">实际参数</a>。这种对应关系是单射但不一定是满射，即匹配成功后，每个参数总存在对应的操作数或其子项，而操作数和子项允许不对应形式参数而被忽略。</p>
<p>　　被绑定的项的操作数中的元素对应是<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>中的元素。</p>
<p>　　形式参数树中的引用值可能被间接访问其<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>一次，其余元素在匹配时被<a href="Features/NPL.zh-CN.html#%E9%BB%98%E8%AE%A4%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2%E7%BA%A6%E5%AE%9A">视为右值</a>。</p>
<p>　　绑定操作符合以下节的绑定规则。</p>
<p><strong>原理</strong></p>
<p>　　被绑定的参数可作为函数的形式参数。绑定操作对形式参数的处理也可以作为其它初始化变量的语法构造的基础。</p>
<p>　　作为推广，绑定操作也可以引入函数的形式参数以外的变量。</p>
<p><strong>注释</strong></p>
<p>　　形式参数树的节点可以是符号的引用值，但不支持<a href="Features/NPL.zh-CN.html#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">多重引用</a>。</p>
<p>　　关于对形式参数树的具体的语法要求，另见 <a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0"><code>&lt;ptree&gt;</code> 的定义</a>。</p>
<p>　　因为 NPLA1 支持的<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>都具有<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>的形式，操作数或其子项总能直接被作为函数的实际参数。</p>
<p>　　DAG 要求和 Kernel 类似。</p>
<p>　　和 Kernel 不同，操作数树同时支持作为<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用</a>的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>和非引用的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">右值</a>，在实现上需要解析引用。</p>
<h4 id="绑定初始化"><a class="header" href="#绑定初始化">绑定初始化</a></h4>
<p>　　绑定的对象节点的值和子节点元素被<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96">复制初始化</a>。</p>
<p>　　绑定前不对形式参数或实际参数中的元素求值。</p>
<p>　　除非另行指定，不同变量的绑定初始化之间<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">非决定性有序</a>。</p>
<p>　　绑定初始化不<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>形式参数，但可能因<a href="Features/NPL.zh-CN.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化转移初值符而修改操作数</a>。</p>
<p><strong>注释</strong></p>
<p>　　初始化元素类似宿主语言的参数传递中可发生初始化。</p>
<p>　　若形式参数或实际参数可能由求值得到，需在匹配前另行处理。</p>
<p>　　由<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">非决定性规约规则</a>，一般地，变量仅通过初值的求值决定的<a href="Features/NPL.zh-CN.html#%E9%80%92%E5%BD%92%E8%95%B4%E5%90%AB%E8%A7%84%E5%88%99">依赖关系</a>及<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>决定之间初始化的相对顺序。</p>
<p>　　因为绑定的初始化不负责实际参数的求值，一般地，即使初值符位于相邻的语法构造，也不保证隐含顺序；这和宿主语言不同。</p>
<p>　　初始化的顺序规则和宿主语言初始化不同的函数参数类似。</p>
<h4 id="绑定临时对象"><a class="header" href="#绑定临时对象">绑定临时对象</a></h4>
<p>　　被绑定的<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>不具有<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">临时对象属性</a>。</p>
<p><strong>原理</strong></p>
<p>　　因为<a href="Features/NPL.zh-CN.html#%E8%AE%B0%E5%8F%B7%E6%B1%82%E5%80%BC">记号求值</a>保证求值<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>是左值，被绑定的对象<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>最终得到的引用值不包含<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">唯一引用属性</a>。</p>
<p>　　这不清除绑定临时对象引入到表示被绑定对象的项或引用值中的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">其它属性</a>，因此其它属性可跟随一等对象<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">被跨过程传递</a>（若不经过<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>或其它操作）。</p>
<p>　　同<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">绑定临时对象属性</a>的讨论，被传递的属性类似宿主语言的指定转发引用参数类型，以下记作 <code>P</code> 。</p>
<p>　　特别地，被传递的属性包含临时对象属性。这对应宿主语言中 <code>P</code> 是左值引用。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">跨过程传递并不被宿主语言支持</a>。因此，一般仅限为了实现类似宿主语言的根据值类别和类型转发参数的<em>转发上下文(forwarding context)</em> 中使用。</p>
<p>　　通过从传递的属性中提取的<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">标签</a>访问引用<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用值的属性</a>代替保存<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境引用</a>并以其它底层的方式查询作为<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的被绑定对象的元数据能以更低的开销实现一些常见的相同的目的，如判断被引用对象是否表示可被转移的资源。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%A8%E7%A4%BA">临时对象的表示</a>、<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">非递归绑定</a>和<a href="Features/NPL.zh-CN.html#%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">递归绑定</a>。</p>
<p><strong>注释</strong></p>
<p>　　使用<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">引用标记字符</a>可保留来自引用值实际参数的作为引用值属性的临时对象属性。</p>
<p>　　使用引用标记字符 <code>&amp;</code> 可启用转发推断值类别。</p>
<h4 id="绑定匹配"><a class="header" href="#绑定匹配">绑定匹配</a></h4>
<p>　　绑定匹配以一个形式参数树和操作数树作为输入，比较两者的结构并尝试关联形式参数树中的子项到操作数蕴含的对象，以<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96">创建变量绑定</a>。</p>
<p>　　若绑定匹配成功，则可能进行以符号值为名称的对应变量的<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96">绑定初始化</a>；否则，绑定匹配失败，引起错误。</p>
<p>　　绑定匹配确定每一个符号值的过程<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序</a>这个符号值确定的变量的绑定初始化。</p>
<p>　　绑定匹配不<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>形式参数，在匹配成功进行绑定初始化前不修改操作数。</p>
<p>　　匹配使用如下算法搜索形式参数树和操作数的对应位置：</p>
<ul>
<li>初始化输入的形式参数树为当前形式参数，函数合并构成的操作数树作为当前操作数。</li>
<li>对每一对当前形式参数和当前操作数，比较两者（除非另行指定，操作数的值是引用值的，视为匹配<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>，下同）：
<ul>
<li>若两者都是有序对，则：
<ul>
<li>若形式参数有序对元素的结尾元素不是符号也不是有序对，则参数匹配失败。</li>
<li>若形式参数是列表，且元素的结尾元素是以 <code>.</code> 起始的符号值，则存在<em>省略(ellipsis)</em> ；保存移除	<code>.</code> 的符号值，并从子项中移除结尾元素，继续进行比较。</li>
<li>若形式参数和操作数的（直接）<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">前缀元素</a>数相等，或存在省略时移除结尾元素后的形式参数前缀元素数不大于操作数子节点的元素数，则：
<ul>
<li><strong>注释</strong> 直接比较前缀元素数，不计算有序对的非前缀元素是引用值且其被引用对象是非空列表时具有的元素数。</li>
<li>忽略形式参数中的省略的元素，以深度优先搜索从左到右逐一递归匹配两者的元素。</li>
<li>若存在省略的元素，若保存移除 <code>.</code> 的符号值非空，以移除 <code>.</code> 的符号值作为形式参数，匹配操作数构成的<em>结尾序列(trailing sequence)</em> 。</li>
<li>否则，若形式参数是非列表的有序对（最后的元素非空），匹配结尾序列。
<ul>
<li><strong>注释</strong> 结尾序列支持匹配有序对操作数的非前缀元素。这个元素可能是引用值，它的被引用对象被作为操作数继续匹配并进行<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">非递归绑定</a>。</li>
</ul>
</li>
<li>否则，若所在的形式参数列表的结尾元素是 <code>.</code> ，参数匹配成功，忽略结尾序列，不绑定对象。</li>
<li>否则，没有其余元素需要匹配，参数匹配成功。
<ul>
<li><strong>注释</strong> 先前对形式参数和操作数的节点数判断同时确保结尾序列为空。</li>
</ul>
</li>
<li>匹配结尾序列的规则参见非递归绑定。
<ul>
<li><strong>注释</strong> 结尾序列预期匹配的操作数是空列表或有序对。对操作数是列表的情形，结尾序列是<em>结尾列表(trailing list)</em> 。</li>
</ul>
</li>
</ul>
</li>
<li>否则，若不存在省略，列表的元素数不相等，参数匹配失败。</li>
<li>否则，操作数的子节点不足，参数匹配失败。</li>
</ul>
</li>
<li>若形式参数是空列表，则：
<ul>
<li>若实际参数不是空列表，则参数匹配失败。</li>
<li>否则，参数匹配成功。</li>
</ul>
</li>
<li>若形式参数是引用值且没有因为本条匹配规则递归进入匹配，则以其被绑定对象代替当前形式参数递归匹配。</li>
<li>若形式参数不是符号，则参数匹配失败。</li>
<li>若形式参数不是 <code>#ignore</code> ，则尝试绑定操作数到以符号值确定的名称的形式参数。
<ul>
<li>若符号值以一个<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6"><em>引用标记字符</em></a>起始，则被绑定的变量名中去除此前缀。</li>
<li>若去除前缀得到的符号为空，则忽略操作数，不绑定对象。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　绑定匹配时不检查重复的符号值。若形式参数树中出现重复的符号值，可被多次匹配成功。这可导致之后的绑定初始化中，只有其中某个未指定的绑定生效，其它绑定被覆盖。</p>
<p><strong>原理</strong></p>
<p>　　虽然可能匹配被引用对象，操作数匹配不蕴含时引用值不被<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%B6%88%E9%99%A4">消除</a>。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，明确直接比较前缀元素数，因为：</p>
<ul>
<li>这允许在元素数不同时给出更具有针对性的诊断，避免误用。</li>
<li>这能避免匹配在任何情形都总是顺序地依赖每一个操作数的值，允许<a href="Features/NPL.zh-CN.html#%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0">并发实现</a>。</li>
</ul>
<p>　　实现使用的表示允许访问元素数具有 <tt>O(1)</tt> 的时间复杂度，而访问前缀元素数具有 <tt>O(n)</tt> 时间复杂度。但限制不访引用值时，不会有较大的附加开销。</p>
<p><strong>注释</strong></p>
<p>　　函数合并构成的操作数树包括作为合并子的第一个子项和作为操作数的之后余下的子项。</p>
<p>　　数据结构和匹配算法类似 Kernel 中用于 <code>$define!</code> 和 <code>$vau</code> 等<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">操作子</a>的递归的匹配机制，但有以下不同（另见 <a href="Features/NPL.zh-CN.html#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">NPLA1 合并子</a>）：</p>
<ul>
<li>不支持 <a href="Features/NPL.zh-CN.html#%E6%9C%89%E5%BA%8F%E5%AF%B9">cons 对</a>的中缀 <code>.</code> ，但支持形式参数树中的列表最后以带省略的符号值匹配多个列表项的参数，绑定结尾序列。</li>
<li>对参数子项的符号值中可选的 <code>.</code> 起始以及之后可选的前缀作为标记字符作为引用标记进行处理。</li>
<li>不提供转义，若符号值去除可选的前缀及标记字符 <code>.</code> 后为空则忽略绑定。</li>
<li>若参数子项<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按引用传递</a>则间接访问并绑定<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>。</li>
<li>只支持<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">无环列表</a>，且不检查（因为 API 已经保证只支持真列表）。</li>
<li>列表外的 <code>.</code> 起始的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">词素</a>当前视为普通的符号，但此行为可能会在未来改变）。</li>
</ul>
<p>　　被忽略的绑定不保存绑定的对象。</p>
<p>　　不在列表内最后位置的带有前缀 <code>.</code> 的形式参数绑定的是普通的变量，不忽略绑定。</p>
<p>　　和 Kernel 不同，不检查重复符号值，且绑定匹配<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">对特定模式的形式参数进行不同的处理</a>。</p>
<p>　　其它一些不支持 cons 对的语言，如 [ECMAScript 2019] 的 <code>rest</code> 参数支持类似结尾列表的效果。</p>
<p>　　绑定匹配和创建绑定的初始化之间的顺序约定是必要的，因为这里约定的是一般的规约规则而非求值规则，<a href="Features/NPL.zh-CN.html#%E9%80%92%E5%BD%92%E8%95%B4%E5%90%AB%E8%A7%84%E5%88%99">递归蕴含规则</a>等求值的默认规则不适用。</p>
<p>　　绑定匹配允许<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">并行化</a>。</p>
<h4 id="引用标记字符"><a class="header" href="#引用标记字符">引用标记字符</a></h4>
<p>　　应用在形式参数树叶节点符号值的前缀 <code>%</code> 、<code>&amp;</code> 或 <code>@</code> 为标记字符表示名称绑定的可按需引入引用，称为引用<em>标记字符(sigil)</em> 。</p>
<p>　　绑定引用时，可使用引用推断规则：</p>
<ul>
<li>引用值<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值的副本传递</a>给形式参数，非引用值<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按引用传递</a>给<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">形式参数</a>。</li>
<li>否则，操作数按值的副本传递给形式参数。</li>
</ul>
<p>　　标记字符引起的绑定的差异为：</p>
<ul>
<li>不存在标记字符时，对操作数<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值的副本</a>绑定，实际参数的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">值的副本</a>传递给对应的形式参数。
<ul>
<li>若实际参数是<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">泛左值</a>，则实际参数上首先隐含<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">左值到右值转换</a>。</li>
</ul>
</li>
<li>存在标记字符 <code>%</code> 或 <code>&amp;</code> 时，按上述的引用推断规则直接绑定或转发操作数。
<ul>
<li>当实际参数是引用值时，在<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">可能对其它属性进行的处理</a>后，隐含一次<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">引用折叠</a>。</li>
</ul>
</li>
<li>存在标记字符 <code>@</code> 时，绑定以实际参数作为<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的引用值，不论操作数的类型和值类别。
<ul>
<li>初始化引用值时，没有<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%B6%88%E9%99%A4">引用值的消除</a>。</li>
</ul>
</li>
</ul>
<p><strong>注释</strong></p>
<p>　　除<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">复制消除</a>转移有序对操作数的子对象外，绑定时不修改被绑定操作数。</p>
<p>　　支持修改操作数的绑定的其它标记字符可能在未来支持。</p>
<h4 id="非递归绑定"><a class="header" href="#非递归绑定">非递归绑定</a></h4>
<p>　　非递归绑定在一次匹配之后创建对应的变量绑定。</p>
<p>　　合并使用或不使用<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">引用标记字符</a>的情形，非<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">结尾序列</a>的单一参数对象的<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96">绑定初始化</a>包含以下过程：</p>
<ul>
<li>若不存在标记字符 <code>@</code> ，则：
<ul>
<li>若操作数为<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%AF%E8%BD%AC%E7%A7%BB%E6%9D%A1%E4%BB%B6">可转移的</a>对象的引用值，则被绑定对象是按以下规则初始化的蕴含隐含的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">引用折叠</a>的引用值：
<ul>
<li>存在标记字符时，使用<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">引用推断规则</a>，被绑定对象是操作数直接初始化的引用值，其属性由操作数的（引用值）的属性决定：
<ul>
<li>当存在标记字符 <code>&amp;</code> 、绑定非结尾序列且作为操作数的引用值的属性包含<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">唯一引用属性</a>时，其中包含绑定<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象属性</a>。
<ul>
<li><strong>注释</strong> 使用 <code>%</code> 可避免操作数中的唯一引用属性在被绑定对象中蕴含<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">临时对象属性</a>。</li>
</ul>
</li>
<li>否则，被绑定对象的属性和作为操作数的引用值的属性相同。</li>
</ul>
</li>
<li>否则，被绑定对象是操作数<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96">复制初始化</a>（复制或转移）的值。</li>
</ul>
</li>
<li>否则，若<a href="Features/NPL.zh-CN.html#%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">操作数属性</a>指定可修改的临时值或有标记字符 <code>%</code> 时的临时值，操作数是可转移的非引用值，被绑定的对象是临时对象。</li>
<li>否则，当存在标记字符 <code>&amp;</code> 时，被绑定对象是操作数的引用值，其属性是操作数属性和<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">操作数项的属性</a>的并，但总是排除绑定临时对象属性。
<ul>
<li><strong>注释</strong> 此处的被绑定对象可在<a href="Features/NPL.zh-CN.html#%E8%AE%B0%E5%8F%B7%E6%B1%82%E5%80%BC">作为符号求值</a>时被折叠并在结果中<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">进一步去除</a>可能具有的<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">唯一引用属性</a>。</li>
</ul>
</li>
<li>否则，被绑定对象是复制自操作数的值。</li>
</ul>
</li>
<li>否则，被绑定对象的是操作数的引用值：
<ul>
<li>绑定操作数的引用时，要求引用的是列表中的项，否则引起错误。</li>
<li>被绑定的对象应是不唯一的值（直接绑定操作数右值以外的值），被绑定对象是操作数的引用值。</li>
</ul>
</li>
</ul>
<p>　　绑定结尾序列包含以下情形：</p>
<ul>
<li>若不存在标记字符 <code>@</code> ，则：
<ul>
<li>若操作数为可转移的对象的引用值，按非结尾序列的规则绑定操作数。</li>
<li>否则，若操作数属性指定可修改的临时值或有标记字符 <code>%</code> 时的临时值，按非结尾序列的规则绑定操作数。</li>
<li>否则，创建新的有序对，在其中以相应的标记字符（若存在）绑定各个元素子对象。</li>
</ul>
</li>
<li>否则，创建新的有序对，在其中以标记字符 <code>@</code> 绑定各个元素子对象。</li>
</ul>
<p>　　绑定结尾序列创建新的有序对并绑定元素子对象时，作为列表<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">完全分解</a>得到的每个元素组合的列表，满足：</p>
<ul>
<li>若操作数是临时对象，则操作数子项在绑定元素子对象时被<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4">复制消除</a>。</li>
<li>组合的列表是非真列表，当且仅当操作数是非真列表。</li>
<li>子对象的元素是对应的操作数以对应的引用标记字符（若存在）绑定单一参数得到的值。
<ul>
<li><strong>注释</strong> 若不存在引用标记字符，元素被对应复制初始化。</li>
</ul>
</li>
<li>若操作数是非真列表：
<ul>
<li><strong>注释</strong> 此时需初始化组合中的非列表结尾元素。</li>
<li>当不存在标记字符或存在标记字符 <code>%</code> 时，组合的最后一个元素是操作数中的最后一个元素的副本。</li>
<li>否则，组合中的最后一个元素是新创建的<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子对象引用</a>。
<ul>
<li>其被引用对象的表示中没有子项。</li>
</ul>
</li>
</ul>
</li>
<li>创建的有序对初始化完成后，参与初始化被绑定对象：
<ul>
<li>若存在标记字符 <code>&amp;</code> ，则创建子对象引用作为被绑定对象，其被引用对象是创建的有序对。
<ul>
<li>被创建的子对象引用的被引用对象的表示应避免复制初始化任何操作数一等对象。</li>
</ul>
</li>
<li>否则，创建的有序对直接被作为被绑定对象。
<ul>
<li>若存在标记字符，同时视为<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">绑定临时对象</a>，设置其表示的<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">临时对象标签</a>使之具有临时对象属性。</li>
</ul>
</li>
</ul>
</li>
<li>被绑定对象的元素总是不具有临时对象属性。
<ul>
<li><strong>原理</strong> 这使实现能<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">避免临时对象的子对象具有临时对象属性</a>。</li>
</ul>
</li>
</ul>
<p>　　绑定临时对象外的引用临时对象视为对被引用对象的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>。</p>
<p><strong>注释</strong> 这意味着除绑定临时对象外，若绑定操作数的初始化的引用值时实际引用临时对象，则<a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">因超出生存期的对象访问，行为未定义</a>。</p>
<p>　　仅在绑定临时对象且操作数可转移或使用标记字符 <code>%</code> 时使用复制消除。</p>
<p><strong>原理</strong></p>
<p>　　绑定的默认行为对引用值特殊处理，是为了满足 <a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">G1b</a> ，而不是像某些语言（如 [ISO C] 和 [Rust] ）仅通过内建的机制提供特定的<em>左值上下文(lvalue context)</em> 。</p>
<p>　　绑定的默认行为不使用<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">析构性转移</a>的操作（类似 [Rust] 的设计），原因是考虑到绑定的副作用影响操作数（即便因为对象被销毁而不一定是修改操作）和破坏<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">幂等性</a>（特别是指定<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">过程调用</a>的形式参数时）违反<a href="Features/NPL.zh-CN.html#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测性原则</a>。</p>
<p>　　为允许调用<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主对象</a>的<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">转移构造函数</a>，限制复制消除。初始化引用之外的参数创建也不是 [ISO C++17] 约定要求消除复制的上下文。</p>
<p>　　作为操作数的引用值中的唯一引用在使用 <code>&amp;</code> 引用标记字符时可同时蕴含<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">绑定临时对象属性</a>，这使绑定为变量的消亡值可能以名称表达式求值结果（不会是消亡值）的引用值访问时，能和其它引用值区分。提供这种设计的理由是：</p>
<ul>
<li>以下两种涉及<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">消亡值</a>的资源访问可被统一：
<ul>
<li>直接访问消亡值表达式。
<ul>
<li>消亡值表示即将被转移的资源。</li>
</ul>
</li>
<li>以消亡值初始化一个带有 <code>&amp;</code> 引用标记字符的非结尾序列变量，并以这个变量的名称作为表达式进行访问。
<ul>
<li>这通常需要使变量指称消亡值引用的资源，而不仅仅是表示即将被转移的消亡值自身。</li>
<li>具有临时对象属性的引用值通过右值初始化，相当于宿主语言中的右值引用，典型地表示能被转移的资源（而不一定需要立刻被转移）。</li>
<li>初始化变量同时转移资源，相当于宿主语言中复制初始化时调用转移构造函数转移操作数的资源到变量（对象或绑定到临时对象的引用），使之表示转移后的资源。</li>
</ul>
</li>
<li>尽管值类别可能不同，这两种表达式都可以表示蕴含被转移的资源的对象。</li>
</ul>
</li>
<li>直接求值名称表达式往往比其它替代方式更直接高效，但结果总是<a href="Features/NPL.zh-CN.html#%E8%AE%B0%E5%8F%B7%E6%B1%82%E5%80%BC">左值</a>而不具有<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">唯一引用属性</a>，而使用临时对象属性允许在求值的结果中被保留。
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">项引用</a>（而不是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">临时对象引用</a>）中的临时对象属性不影响值类别。</li>
<li>类似地，在宿主语言中，和值类别不同的状态以右值引用类型声明的形式编码在类型系统中。
<ul>
<li>引用值中的临时对象属性接近宿主语言中<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">转发引用</a>蕴含的静态类型。</li>
</ul>
</li>
<li>但和宿主语言不同，临时对象属性能随初始化后的引用值跨过程传递，而无需多次转发并在每次推导引用类型。</li>
</ul>
</li>
<li>基于上述规则，对象语言中特定的转发操作处理可统一的方式处理两种表达式以转移资源。这种设计能简化一般的使用。
<ul>
<li>引用值支持临时对象属性对有效的转发对象应用子的实现是必要的。
<ul>
<li>通过对象属性，转发对象操作可避免总是从实际的操作数提取值类别的需要，允许作为应用子而非<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">操作子</a>。</li>
<li>若不使用临时对象属性，则需要其它方式编码和值类别不同的状态以和消亡值区分，例如宿主语言的静态类型信息。
<ul>
<li>这会增加语言规则的复杂性。</li>
</ul>
</li>
</ul>
</li>
<li>需要转发资源时，一般只需要使用转发对象操作；其它情形可安全忽略引用值中的临时对象属性。</li>
<li>类似地，在宿主语言中，编码在类型系统中的状态在特定上下文中用于实现<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%80%BC%E4%BC%A0%E9%80%92">完美转发</a>。
<ul>
<li>宿主语言中，右值引用类型的变量作为左值（而不是消亡值）被访问，在大多数操作中没有和其它左值区分的意义。</li>
<li>在 <code>std::forward</code> 这样需要区分引用类型的转发操作（实例是一个函数，而不是宏）中，右值引用类型在局部是有意义的。</li>
<li>但是这仍然存在限制：因为没有跨过程传递的状态支持，明确具体类型还是需要程序显式指定 <code>std::forward</code> 的类型参数（或者宏），而不是 C++ 函数（应用子）的方式实现。</li>
</ul>
</li>
</ul>
</li>
<li>消亡值应和<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>在初始化其它变量时转移资源的作用一致，对应唯一引用属性和临时对象属性的相似处理。
<ul>
<li>通过唯一引用属性仍可区分一个具有临时对象属性的引用值以消亡值还是纯右值初始化。</li>
</ul>
</li>
<li>可使用 <code>&amp;</code> 以外的引用标记字符避免这里的行为而被初始化的被绑定对象（引用值）中引入非预期的临时对象属性。</li>
</ul>
<p>　　绑定结尾序列和非结尾序列的非递归绑定规则略有不同。</p>
<ul>
<li>特别地，除非被绑定对象是引用值，引用标记字符（不论是否存在）同时被作用到作为一等对象的元素上。这是因为：
<ul>
<li>此时，需要把操作数作为一等对象进行分解，使用引用标记字符或者不使用引用标记字符不破坏其它语义规则。</li>
<li>和非引用结尾序列相比，这使有序对的两个元素在初始化时的规则不同，但这具有合理性，因为：
<ul>
<li>有序对作为（非真）列表时，结尾元素和其它元素的地位不是相同的。</li>
<li>有序对的元素在 NPLA 对象表示中即已不对称，地位不可交换。</li>
<li>这种设计简化了一些重要的派生实现。</li>
</ul>
</li>
</ul>
</li>
<li>蕴含绑定<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">临时对象属性</a>的规则不适用绑定结尾序列中的元素，因为：
<ul>
<li>结尾序列的元素不具有名称，而不是通过绑定创建的能作为名称访问表达式的变量。访问元素需通过其它方式（如对象语言中的<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E7%BA%A6%E5%AE%9A">子对象访问操作</a>），方法和结果不唯一（如可能具有不同的值类别，可能即时转移资源等），不具有和消亡值的统一性。</li>
<li>引入附加的临时对象属性容易引起非预期的转移。除子对象访问时可能发生的直接转移（通常较明确），随引用值跨过程传递的临时对象属性在之后可能继续引起其它转移。因为首先通过子对象而非名称表达式访问，这种转移的存在性在创建变量绑定的位置通常不显然而无法预知，容易误用。</li>
<li>一旦不需要附加的临时对象属性，去除属性而得到引用值通常是较为困难的，需要对象语言提供特设的操作或绑定新的对象（尽管引入临时对象属性可能同样困难）。</li>
</ul>
</li>
</ul>
<p><strong>注释</strong></p>
<p>　　引用折叠的结果满足<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">不可修改引用属性的传播性质</a>。其它情形应满足 <a href="Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">NPLA1 引用值使用约定</a>。因此，仅有使用标记字符 <code>%</code> 进行消除引用时，被消除的引用值的不可修改属性被忽略。</p>
<p>　　绑定临时对象外不和 [ISO C++] 一样可能延长右值类类型<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的生存期。</p>
<p>　　具有引用标记字符的形式参数支持引入引用值并支持绑定引入<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的实际参数。</p>
<h4 id="递归绑定"><a class="header" href="#递归绑定">递归绑定</a></h4>
<p>　　形式参数树子项和操作数树的子项成功<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">匹配</a>后绑定子项。</p>
<p>　　递归的<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">绑定匹配</a>对应递归的绑定创建，允许以操作数树的子项对应初始化形式参数树的各个子项。</p>
<p><strong>注释</strong> 和形式参数树中的<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">结尾列表</a>的符号值被视为整体不同，递归绑定可包含项和其子项的多次递归的匹配。</p>
<p>　　绑定算法应确定和当前处理的操作数树的属性，即<em>操作数属性(operand property)</em> 。其中蕴含的表示操作数的项对应的<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">标签</a>，称为<em>操作数标签(operand tags)</em> 。</p>
<p>　　操作数属性和形式参数的引用标记字符结合决定是否<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按引用传递</a>初始化，并判断<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96">绑定初始化</a>时是否允许转移。</p>
<p>　　绑定匹配递归处理子项时，应确定子项的操作数标签，以指定子项可能具有的上下文相关的差异。</p>
<p>　　绑定初始时，操作数应为<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>。此时，以临时对象标签作为初始操作数标签。</p>
<p><strong>注释</strong> 这指定指定操作数是可被唯一使用的临时值。与此不同，若项表示作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>，应<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%A8%E7%A4%BA">不具有临时对象标签</a>。</p>
<p>　　一个项的子项的操作数标签由这个项的操作数标签（处理子项时，代表先前确定的所在的项的标签；以下称为当前操作数标签）和本节中以下约定的子项继承规则决定：</p>
<ul>
<li>若操作数子项不是引用值，则子项的操作数标签和当前操作数标签相同。</li>
<li>否则，匹配的子项是这个引用值的<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>，子项的操作数标签以操作数子项中的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用值的属性</a>和当前操作数标签按以下引用项继承约束限定：
<ul>
<li>子项的操作数标签不包含<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">临时对象标签</a>。
<ul>
<li><strong>原理</strong> 这使实现能避免临时对象的子对象具有<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象标签</a>。</li>
</ul>
</li>
<li>子项的操作数标签是否包含<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">唯一引用标签</a>同引用值的属性。</li>
<li>子项的操作数标签是否包含其它标签同对应的当前操作数标签。</li>
<li>在以上基础上，引用值的属性向子项的操作数标签对应的属性<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">传播</a>：若前者包含不可修改属性，后者应包含不可修改标签。</li>
</ul>
</li>
</ul>
<p>　　绑定需转移子项（包括<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">绑定子项的复制消除</a>）时，使用<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">项的转移</a>。</p>
<p>　　绑定临时对象属性标签可影响<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">参数转发</a>。若需按类似宿主语言的成员表达式的值类别而不是成员是否为非左值引用进行转发，需确保被转发的值不是带有临时对象标签的引用值。</p>
<p>　　操作数标签中：</p>
<ul>
<li>唯一引用标签由所在的项单独决定。</li>
<li>临时对象标签仅在递归绑定时所在的所有列表项都是非引用值时包含。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用值的不可修改属性</a>标记不可修改项而避免非临时对象的转移。这和宿主语言中的非 <code>mutable</code> 类数据成员访问操作符决定 <code>const</code> 限定符的规则类似。</p>
<p>　　子项标签继承规则保证使用 <code>&amp;</code> 或 <code>%</code> <a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">标记字符</a>时，值类别的决定规则和宿主语言的成员访问操作符类似：</p>
<ul>
<li>列表左值中的元素总是被绑定为<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>。</li>
<li>列表右值的元素按元素是否为引用被绑定左值或<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">消亡值</a>。</li>
<li>特别地，<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">项引用</a>的临时对象标签不被继承到作为子项的被引用对象，因为即便被引用的列表对象是一个临时对象，它的元素不被作为纯右值匹配。这和宿主语言中成员访问操作符访问的右值是消亡值而不是纯右值类似。</li>
</ul>
<p>　　使用对象语言，若需判断列表左值中的元素是否为引用值，可直接绑定列表操作数为引用并按需转换为消亡值再递归绑定列表元素。</p>
<h3 id="绑定构造"><a class="header" href="#绑定构造">绑定构造</a></h3>
<p>　　部分<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>的求值包含<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">形式参数树</a>，通过<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">绑定规则</a>在<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">环境</a>中引入绑定，其调用指定<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">绑定操作</a>。具有这样的语法构造的表达式是<em>绑定构造(binding construct)</em> 。</p>
<p>　　一些绑定构造使用 <a href="Features/NPL.zh-CN.html#%E6%9C%AA%E6%B1%82%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;binding&gt;</code></a>提供在一个表达式多次出现的形式参数树和操作数树。</p>
<p><strong>注释</strong></p>
<p>　　绑定在<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>上的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>引入<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">变量</a>。</p>
<p>　　按<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96">绑定初始化</a>的约定，<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数树</a>的子节点初始化被绑定的形式参数树的对应子节点。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，各种绑定构造可使用 <a href="Features/NPL.zh-CN.html#%E6%9C%AA%E6%B1%82%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;body&gt;</code></a> 提供操作数。</p>
<p>　　对绑定项的处理和 [R<sup>n</sup>RK] 的其它不同参见<a href="Features/NPL.zh-CN.html#%E6%96%87%E6%B3%95%E5%85%83%E7%B4%A0%E8%A1%A5%E5%85%85%E7%BA%A6%E5%AE%9A">文法元素补充约定</a>。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a>。</p>
<h4 id="强递归绑定"><a class="header" href="#强递归绑定">强递归绑定</a></h4>
<p>　　除类似 Kernel 的常规绑定外，NPLA1 的部分绑定构造支持延迟附加的绑定的形式。</p>
<p>　　强递归绑定支持若同时绑定的递归<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>构成<a href="Features/NPL.zh-CN.html#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>，则递归绑定的值都是未指定的内部表示而不<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　强递归绑定是对象语言的绑定构造实现的附加机制，形式参数树的递归匹配仍使用<a href="Features/NPL.zh-CN.html#%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">递归绑定</a>。</p>
<h4 id="参数转发"><a class="header" href="#参数转发">参数转发</a></h4>
<p>　　绑定构造可支持<em>参数转发(argument forwarding)</em> ，根据实际参数确定形式参数中是否为引用值，保留<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E5%92%8C%E7%B1%BB%E5%9E%8B">值类别和可修改性</a>。</p>
<p><strong>注释</strong> 类似<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">宿主语言中的转发引用</a>参数。</p>
<h4 id="作用顺序"><a class="header" href="#作用顺序">作用顺序</a></h4>
<p>　　绑定构造引起的绑定初始化的作用<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">顺序</a>满足<a href="Features/NPL.zh-CN.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a>的约定。</p>
<p>　　若其中存在<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>，其顺序还满足：</p>
<ul>
<li>若存在同一形式参数树子节点的不同绑定的操作，则这些操作的副作用之间<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">非决定性有序</a>。</li>
<li>不同<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>的形式参数树子节点的绑定操作的副作用之间<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">无序</a>。</li>
<li>形式参数树的子节点上的绑定操作的副作用<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序</a>所在的节点上的绑定操作的其它副作用。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　这些规则允许<a href="Features/../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">并行的</a>深度优先遍历的绑定实现。深度优先遍历使任一时刻成功完成绑定的对象集中，相对其它策略其状态更<a href="Features/NPL.zh-CN.html#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测</a>。</p>
<h2 id="对象语义"><a class="header" href="#对象语义">对象语义</a></h2>
<p>　　关于对象的存储，基本内容参见 <a href="Features/NPL.zh-CN.html#%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">NPLA 存储和对象模型</a>。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">对象语言内存安全保证</a>。</p>
<h3 id="npla1-对象同一性"><a class="header" href="#npla1-对象同一性">NPLA1 对象同一性</a></h3>
<p>　　NPLA1 的对象是<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>。由定义，NPLA1 的对象默认确保<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>。</p>
<p>　　例外参见 <a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">NPLA1 子对象</a>。</p>
<p>　　对象的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>通常不保证其作为<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>和其它对象都不同一，包括<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">唯一引用</a>的情形。但除非另行指定，作为函数实际参数的对象若是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B">右值引用</a>，则实现可假定被引用对象唯一。</p>
<p><strong>注释</strong></p>
<p>　　关于右值引用的保证类似 [ISO C++] <a href="https://eel.is/c++draft/res.on.arguments">[res.on.arguments]</a> 。注意这在对象语言而非宿主语言中适用。</p>
<h3 id="npla1-子对象"><a class="header" href="#npla1-子对象">NPLA1 子对象</a></h3>
<p>　　基本内容参见 <a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">NPLA 子对象</a>。</p>
<p>　　子对象可具有引用值。</p>
<p>　　子对象引用访问的被引用对象不保证具有同一性。</p>
<p><strong>原理</strong></p>
<p>　　和宿主语言不同，通过相同方式构造的子对象引用访问的被引用对象<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">未指定是否为同一对象</a>。</p>
<p><strong>注释</strong></p>
<p>　　和宿主语言不同，NPLA1 对象语言不直接提供访问子对象的内建语法。</p>
<h4 id="子对象访问约定"><a class="header" href="#子对象访问约定">子对象访问约定</a></h4>
<p>　　作为<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">使用名称表达式访问对象</a>的推广，特定操作可使用非环境的其它对象显式地访问其子对象。</p>
<p>　　除非另行指定，这些<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>操作以本节约定的规则确定结果的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E5%92%8C%E7%B1%BB%E5%9E%8B">值类别和类型</a>。</p>
<p>　　若指称非环境对象的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a> <code>E1</code> 是访问操作的（被求值的）实际参数，子对象来自这个参数指定的对象；否则，子对象来自 <code>E1</code> 引用的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境对象</a>中的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>。</p>
<p>　　具体的访问操作确定具体的被访问的子对象。</p>
<p>　　访问操作中：</p>
<ul>
<li>若指定结果是引用值，或指定<a href="Features/NPL.zh-CN.html#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E7%9B%AE%E6%A0%87">（在结果中）保留引用值</a>且被访问的对象实际存在可被保留的引用值，则结果是被访问的子对象的可能经<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">引用折叠</a>的引用值。</li>
<li>否则，结果是被访问的被访问的子对象<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96">复制初始化</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>。
<ul>
<li>此时，按<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%AF%E8%BD%AC%E7%A7%BB%E6%9D%A1%E4%BB%B6">对象的可转移条件</a>判断复制或转移。</li>
</ul>
</li>
</ul>
<p>　　访问操作的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">结果</a>的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B">值的类型和值类别满足一一对应</a>，且结果经值类别转换后和被访问的子对象的类型相同。访问操作中没有明确指定的结果的值类别以此通过结果的类型推断。</p>
<p>　　若通过以上约定，仍没有明确结果的值类别，则按以下默认规则确定：</p>
<ul>
<li>若被访问的子对象是引用值，则结果是<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">泛左值</a>。</li>
<li>否则，若 <code>E1</code> 是<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>，则结果是左值。</li>
<li>否则，结果是<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">右值</a>。</li>
</ul>
<p>　　结果是具有被访问的子对象类型对应的值，它的更具体的值类别通过上述等价关系按结果的类型对应确定。</p>
<p>　　<code>E1</code> 或被访问的子对象的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">传播</a>引用值的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%B6%88%E9%99%A4">不可修改属性</a>。</p>
<p>　　被访问的子对象访问若具有影响值类别或被传播以外的其它属性被保留，对应在结果中出现。</p>
<p>　　<em>成员访问(member access)</em> 操作访问称为对象的<em>成员(member)</em> 的子对象，满足本节的约定。</p>
<p>　　具体操作可具有其它改变结果的值类别和类型的约定而实际使用不同的规则。</p>
<p><strong>原理</strong></p>
<p>　　确定结果的值类别和类型的方式类似按宿主语言的成员访问确定对表达式 <code>E1.E2</code> 的值类别和类型。<code>E1</code> 不一定是左值。</p>
<p>　　NPLA1 没有形如 <code>E1.E2</code> 的特设对象访问表达式语法，而以具体的访问操作代替，因此可具有近似但不同的规则。</p>
<p>　　特别地，除非 <code>E1</code> 引用环境，在 <code>E1.E2</code> 中显式指定被访问的子对象的表达式 <code>E2</code> 在访问操作中一般并不存在。代替这里的 <code>E2</code> 的是由具体访问操作指定被访问的子对象，其类型直接代替 <code>E2</code> 的类型。</p>
<p>　　其中，按有序对访问列表的最后一个元素时，被访问的子对象不是引用值，即视为<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>。这里不蕴含<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>，不会有<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">值类别转换</a>。</p>
<p>　　通过被访问的子对象的类型和 <code>E1</code> 的值类别确定结果的值类别的默认规则类似 C++ 成员访问表达式 <code>E1.E2</code> 确定值类别的规则，但略有不同：</p>
<ul>
<li>因为不保证存在名称表达式 <code>E2</code> ，不需要<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值算法</a>使用类似 C++ 的 <code>unqualified-id</code> 一致的方式使结果总是左值。</li>
<li>被访问的对象是右值引用值时，结果是右值引用值（即<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">消亡值</a>），而不一定是左值。</li>
<li>和 C++ 不同，NPLA 消亡值总是右值引用类型，NPLA 纯右值也此类似 C++ 纯右值实质化转换初始化的消亡值，因此逻辑上需要 C++ 消亡值的情形和此处的 NPLA 右值近似。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　初始化非引用值的复制初始化（包括以下的替换消亡值为右值）可能通过<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>实现。</p>
<p>　　在对象表示上，传播<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用值的不可修改属性</a>决定 <code>E1</code> 指定的被访问对象或被访问的子对象若具有<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">不可修改属性</a>，结果也具有不可修改属性。</p>
<p>　　典型地，被保留的其它属性包括<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">临时对象引用</a>。临时对象引用可被继续绑定而可实现<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">按需转发</a>被引用对象。</p>
<p>　　按默认规则访问相当于这些规则确定的值类似 C++ 表达式 <code>std::forward&lt;decltype(E1.E2)&gt;(E1.E2)</code> 的值。</p>
<p>　　具体操作可具有其它改变结果的值类别和类型的约定而实际使用不同的规则。</p>
<p>　　例如，推断结果的值类别的规则中的左值和消亡值可被替换为右值，则近似 C++ 表达式 <code>std::forward&lt;std::remove_cvref_t&lt;decltype(E1.E2)&gt;&gt;(E1.E2)</code> 。</p>
<p>　　传播引用值属性和宿主语言及<a href="Features/NPL.zh-CN.html#%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">递归绑定</a>规则类似。</p>
<h3 id="对象的修改和改变"><a class="header" href="#对象的修改和改变">对象的修改和改变</a></h3>
<p>　　对象作为实体可修改和改变，可具有<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">可变数据状态</a>及<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">可变管理状态</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#npla-%E6%95%B4%E4%BD%93%E7%BA%A6%E5%AE%9A">NPLA 约定</a>的<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>同<a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>的对象，其修改也同这些对象的修改。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">隐藏状态</a>在针对对象语言的的讨论中被排除。除非另行指定（由具体操作的语义蕴含），所有可变状态都不属于这些被排除的状态。</p>
<p>　　改变对象可引起<a href="Features/NPL.zh-CN.html#%E7%BF%BB%E8%AF%91%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%A7%84%E5%88%99">诊断</a>：</p>
<ul>
<li>对明确不可变的对象进行改变的操作<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">引起错误</a>。</li>
<li>具体操作的语义中，所有操作都允许的不要求诊断错误的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">改变操作</a>隐式地指定可变管理状态的改变。</li>
</ul>
<p>　　以下状态是可变管理状态：</p>
<ul>
<li>环境中的被绑定对象。</li>
</ul>
<p>　　除非另行指定，其余可变状态都是可变数据状态。</p>
<p>　　类似宿主语言（如关于 <code>const</code> 限定符的语义），生存期开始前或结束后的（可能并未完成构造的）对象中的子对象的修改不是对象的修改；对应地，此处的子对象的变化也不是对象的改变操作。</p>
<p>　　改变上述的被排除的状态的修改操作不被视为对象语言中的对象的改变操作。</p>
<p>　　对包含所有权的子对象的修改是对所在对象的修改。</p>
<p>　　除非另行指定，NPLA1 不限制任意对象不可修改。</p>
<p>　　等价关系和限制不可修改性的方法的方式不唯一，因此不可修改性也不唯一。</p>
<p>　　因为<a href="Features/NPL.zh-CN.html#npla1-%E5%A4%96%E9%83%A8%E8%A1%A8%E7%A4%BA">外部表示不唯一</a>，不需要基于此定义一种正规的关于外部表示的等价判断形式。</p>
<p>　　对象的不保证<a href="Features/NPL.zh-CN.html#npla1-%E5%AF%B9%E8%B1%A1%E5%90%8C%E4%B8%80%E6%80%A7">同一性</a>的<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的修改和改变不保证蕴含对对象的修改和改变。</p>
<p><strong>原理</strong></p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">开放类型映射</a>不保证非特定对象之间的不可修改性具有唯一的定义。</p>
<p>　　对象的修改和改变作用在确定的对象上。</p>
<p>　　若不同的对象之间不具有同一性，则作用之间无关。因此，修改和改变作为副作用，<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">不保证在不同一的对象之间共享</a>。</p>
<p><strong>注释</strong></p>
<p>　　所有对对象的状态的约定针对同一个对象。</p>
<p>　　对象的子对象作为可变管理状态，使不可变对象具有允许这些状态改变的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">内部可变性</a>而和对象的可变性不同。</p>
<p>　　对诊断的要求类似 [R<sup>n</sup>RK] 。</p>
<p>　　环境中的被绑定对象在仅讨论不可变性的意义外仍是数据对象。</p>
<p>　　引起对象内的可变管理状态的改变而不改变对象的操作在宿主语言<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">可通过类的 <code>mutable</code> 数据成员实现</a>，但 NPLA1 不提供特性使任意的<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的可修改性的限制如宿主语言的 <code>const</code> 限定符自动传播（而一般需要使用<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E7%BA%A6%E5%AE%9A">成员访问操作</a>），因此也不需要提供对应的类型检查修改机制。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，NPLA1 支持直接修改对象，而不只是通过指定子对象关联的被引用对象的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">改变操作</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%86%BB%E7%BB%93">冻结</a>操作是使环境对象上具有类似宿主语言的 <code>const</code> 传播约束的操作；和宿主语言不同，这不是静态类型系统约束。</p>
<h4 id="赋值"><a class="header" href="#赋值">赋值</a></h4>
<p>　　NPLA1 的<em>赋值(assignment)</em> 操作专指以引用值操作数指定对象且不引起同一性改变的<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">对象修改</a>。</p>
<p>　　使用复制和转移的赋值称为<em>复制赋值(copy assignment)</em> 和<em>转移赋值(move assignment)</em> 。</p>
<p>　　被修改的对象由赋值操作的目的操作数决定。赋值操作的值来自源操作数。</p>
<p>　　复制赋值时不会<a href="Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4">复制消除</a>对象。若被赋值的源操作数的值在复制出错，目的操作数引用的对象不被修改。</p>
<p>　　注意避免使用引用值作为操作数的<em>自赋值(self assignment)</em> 引起<a href="Features/NPL.zh-CN.html#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>。</p>
<p>　　除非另行指定，赋值操作不保留源操作数的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E5%92%8C%E7%B1%BB%E5%9E%8B">值类别</a>和可修改性。</p>
<p><strong>注释</strong></p>
<p>　　区分复制赋值和转移赋值类似宿主语言。</p>
<p>　　注意这和 Kernel 的赋值操作包含以特定对象进行替换（可使用<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">项的转移</a>实现）而使对象被修改的情形不同。</p>
<p>　　作为推论，赋值不保证子对象的同一性不被改变；子对象的引用仍可能被赋值<a href="Features/NPL.zh-CN.html#%E6%97%A0%E6%95%88%E5%8C%96">无效化</a>。</p>
<p>　　通过对象的<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象引用</a>修改对象的子对象不保证作用在对象上。</p>
<h4 id="转移导致的修改"><a class="header" href="#转移导致的修改">转移导致的修改</a></h4>
<p>　　转移可导致被转移对象的外部可见的修改。</p>
<p>　　转移不需要是直接显式求值特定的函数调用的副作用。</p>
<p><strong>注释</strong> 例如，使用<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">唯一引用</a>初始化对象，可<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">转移</a>表示<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的项。</p>
<p>　　和<a href="Features/NPL.zh-CN.html#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>不同，当前实现不直接通过初始化<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">转移</a><a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主对象</a>。</p>
<p>　　被转移的对象在转移后具有<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">有效但未指定</a>的状态。</p>
<p><strong>注释</strong></p>
<p>　　当前实现中，当项被转移后，表示的值为 <code>()</code> 。这和<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>等引入<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">实质化临时对象</a>时可能具有的转移的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>（仅在互操作时可见）不保证相同。</p>
<p>　　作为推论，通过转移对象的<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象引用</a>修改对象的子对象不保证作用在对象上。但和其它修改不同，这同时是被转移对象后的状态的规则覆盖。</p>
<h3 id="无效化"><a class="header" href="#无效化">无效化</a></h3>
<p>　　若对象的<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8">引用值保持有效</a>，则指称的左值的对象<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>不变。</p>
<p>　　作为<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>的派生实现，对象语言中的引用值的<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">无效化</a>包括以下情形：</p>
<ul>
<li>被引用的对象存储期已结束（此时引用值是<a href="Features/NPL.zh-CN.html#%E6%97%A0%E6%95%88%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC">悬空引用</a>）。</li>
<li>对象被除通过<a href="Features/NPL.zh-CN.html#%E9%87%8D%E7%BB%91%E5%AE%9A">重绑定</a>、<a href="Features/NPL.zh-CN.html#%E8%B5%8B%E5%80%BC">赋值</a>和另行指定的情形以外的方式<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>，而引起对象同一性的改变。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　对项的重绑定或赋值仍可能因为对子项的修改蕴含被替换的对象的销毁，引起<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1">生存期结束</a>，而使其表示的对象的引用值无效化。</p>
<h3 id="类型分类"><a class="header" href="#类型分类">类型分类</a></h3>
<p>　　NPLA1 不要求支持任意<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B">类型的集合表示</a>不相交，即<em>分区(partition)</em> 。</p>
<p>　　但除非另行指定，基于<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E5%85%83%E7%B4%A0%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">实体元素文法</a>引入的类型仍被分区。</p>
<p><strong>原理</strong></p>
<p>　　不要求分区这避免全局地假定<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%85%A8%E9%9B%86">类型全集</a>的具体表示，并支持开放的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">类型映射</a>。</p>
<p>　　NPLA1 的<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E8%B0%93%E8%AF%8D">类型谓词</a>是一元谓词，<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E8%B0%93%E8%AF%8D">只接受一个参数</a>，以强调语言提供的接口的<a href="Features/NPL.zh-CN.html#%E6%AD%A3%E4%BA%A4%E6%80%A7">正交性</a>。</p>
<p><strong>注释</strong></p>
<p>　　通过指定<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型关系</a>可使两个<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义类型</a>作为集合相交。</p>
<p>　　列表类型只包括<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>。</p>
<p>　　不要求分区、类型判断谓词、列表类型的设计都和 Kernel 不同。</p>
<h2 id="npla1-对象语言数据结构"><a class="header" href="#npla1-对象语言数据结构">NPLA1 对象语言数据结构</a></h2>
<p>　　本节指定在 NPLA1 允许以<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E8%AF%AD%E4%B9%89">一等实体</a>被使用的基本元素。</p>
<p>　　<a href="Features/NPL.zh-CN.html#npla-%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B">NPLA 一等对象</a>是 NPLA1 一等对象。</p>
<p><strong>注释</strong></p>
<p>　　部分设计原则和规则和 Kernel 不同。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E4%B9%89">对象语义</a>。</p>
<h3 id="npla1-引用"><a class="header" href="#npla1-引用">NPLA1 引用</a></h3>
<p>　　NPLA1 基于 NPLA <a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">项引用</a>支持实体的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用</a>。</p>
<p>　　NPLA1 语义中对<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">广义实体</a>的构成依赖的使用也被称为引用，这不限被对象语言中的引用值表达。另见<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境引用</a>。</p>
<p>　　NPLA1 <a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">明确允许不通过对象的引用保存对象</a>，但是也允许使用对象引用；即对象和对象的引用都可作为<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>。</p>
<p>　　这也允许子对象直接被所在的对象蕴含。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>都通过<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>表示。另见<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">一等引用</a>、<a href="Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA">表示</a>和<a href="Features/NPL.zh-CN.html#%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">存储和对象模型</a>。</p>
<p>　　引用值在创建时即引用在生存期内的对象。</p>
<p><strong>注释</strong></p>
<p>　　引用和 Kernel 及 Scheme 的引用类似。</p>
<p>　　明确允许不通过对象的引用保存对象和 Kernel 不同详见<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E8%AF%AD%E4%B9%89">实体语义</a>。</p>
<h4 id="npla1-引用值使用约定"><a class="header" href="#npla1-引用值使用约定">NPLA1 引用值使用约定</a></h4>
<p>　　除非另行指定：</p>
<ul>
<li>不在求值引入右值引用。</li>
<li>引用值的<a href="Features/NPL.zh-CN.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初始值</a>经过不超过一次<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">引用折叠</a>。</li>
<li>为在表达式的求值结果中取得折叠的引用值：
<ul>
<li>当<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>是<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>时，引用值被<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">折叠一次</a>。</li>
<li>否则，引用值通过蕴含一次<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">引用值提升转换</a>的方式被<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%B6%88%E9%99%A4">消除</a>一次。</li>
</ul>
</li>
<li>违反<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">不可修改引用</a>引入的假定的修改操作引起<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型错误</a>。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　按 <a href="Features/NPL.zh-CN.html#npla1-%E8%A7%84%E8%8C%83%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">NPLA1 规范求值算法</a>，隐含<a href="Features/NPL.zh-CN.html#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>直接求值名称表达式的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>是左值。这和宿主语言求值的 <code>unqualified-id</code> 在除了<em>枚举器(enumerator)</em> 外的大多数情形中类似。</p>
<p>　　在此，这被约定为默认情形。其它情形需要附加的规则指定。</p>
<p>　　特定的显式指定环境和名称表达式的操作访问环境中的被绑定对象，其求值结果可以是<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>或<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">消亡值</a>。这和宿主语言的涉及成员访问的表达式（形如 <code>E1.E2</code> 或 <code>E1-&gt;E2</code> ）类似。环境相当于宿主语言中形如 <code>E1</code> 的对象表达式。</p>
<p>　　因为类型系统的不同，类比成员访问的表达式时，忽略 C++ 的位域(bit-field) 、静态成员、成员函数和枚举器的访问规则。</p>
<p>　　此处 <code>E1</code> 总是被视为左值，所以类似宿主语言的规则，结果的值类别由环境中的对象类型确定：当且仅当对象是左值时，结果是左值；否则是消亡值。</p>
<p>　　因为 NPLA 的左值和消亡值是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B">引用值</a>，存在推论：</p>
<ul>
<li>当且仅当对象是左值时，显式指定环境的成员访问的结果是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B">左值引用</a>。</li>
<li>否则，结果是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B">右值引用</a>（<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">唯一引用</a>）。</li>
</ul>
<p>　　访问不作为被绑定对象的子对象时，通常并非如宿主语言为支持推断参数类型的方式使用引用折叠，构造折叠的引用值默认不直接使用<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">引用折叠的规则</a>（除临时对象标签外同 [ISO C++] ），而直接由被引用对象确定。</p>
<p>　　对访问列表中的子项构成的子对象引用，这也和宿主语言的涉及成员访问的表达式类似，除以下不同：</p>
<ul>
<li>元素是引用值时允许结果是唯一引用（而不是宿主语言的左值）。
<ul>
<li>这是因为在此唯一引用指定的是结果的值的类型，而非类似宿主语言声明的右值引用类型。</li>
</ul>
</li>
<li>元素是临时对象的引用值时，允许引用值上的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">临时对象属性</a>在访问中被区分（类似宿主语言以成员访问表达式作为 <code>decltype</code> 的操作数的结果）。</li>
</ul>
<p>　　访问被绑定对象使用引用值也满足<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">不可修改引用属性的传播性质</a>，避免被绑定对象被任意非预期地修改。</p>
<p>　　其它情形是否需要满足不可修改引用属性的传播性质和具体操作相关，因此不明确要求。</p>
<p>　　对违反不可修改引用引入的假定的修改操作要求错误<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">避免隐式的 NPLA 未定义行为</a>，因此引入类型错误作为<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">违反引用值的属性引入的错误</a>。</p>
<p><strong>注释</strong></p>
<p>　　<a href="Features/NPL.zh-CN.html#npla1-%E4%BA%92%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">互操作</a>可能引入右值引用。</p>
<p>　　访问子对象的具体规则参见<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E7%BA%A6%E5%AE%9A">子对象访问约定</a>。</p>
<p>　　作为列表或者环境中绑定对象的一部分，引用值可能通过<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>或对象语言提供的操作访问。这同时确定值类别。</p>
<p>　　蕴含一次引用值提升转换的方式包括<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>。</p>
<h4 id="循环引用"><a class="header" href="#循环引用">循环引用</a></h4>
<p>　　除非另行指定（如<a href="Features/NPL.zh-CN.html#%E5%BC%BA%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">强递归绑定</a>），对象中的循环引用引起 <a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">NPLA 未定义行为</a>。</p>
<p><strong>注释</strong></p>
<p>　　循环引用破坏一些实现的假设而引起非预期的访问。</p>
<h4 id="自引用数据结构"><a class="header" href="#自引用数据结构">自引用数据结构</a></h4>
<p>　　因为不支持<a href="Features/NPL.zh-CN.html#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>，不支持引用自身的<a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">自引用数据结构</a>。</p>
<p><strong>注释</strong> 另见<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">列表</a>。</p>
<h3 id="npla1-环境"><a class="header" href="#npla1-环境">NPLA1 环境</a></h3>
<p>　　NPLA1 支持<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">一等环境</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境对象</a>也可能是语言中显式约定的和<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境引用</a>不同的非一等对象。</p>
<p>　　NPLA1 的环境可关连一个或多个<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">父环境</a>，其<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">重定向</a>使用 DFS（Depth-First Search ，深度优先搜索）遍历目标。</p>
<p>　　环境中的一等对象是环境对象的<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>。子对象是环境，即环境子对象。</p>
<p><strong>注释</strong></p>
<p>　　除了支持非一等对象的环境，和 Kernel 类似。</p>
<h4 id="隐藏环境"><a class="header" href="#隐藏环境">隐藏环境</a></h4>
<p>　　语言实现可提供环境对象以外的非一等环境。总是不能被对象语言以一等对象访问的环境是<em>隐藏环境(hidden environment)</em> 。</p>
<p>　　一般地，隐藏环境是某一个（非隐藏的）一等环境的直接或间接父环境（而能通过求值等间接操作被访问）。</p>
<h4 id="新环境"><a class="header" href="#新环境">新环境</a></h4>
<p>　　<em>新(fresh)</em> 环境是新创建的环境。</p>
<p>　　新环境和先前的其它的（特别地，包括<a href="Features/NPL.zh-CN.html#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>）不共享相同环境对象。</p>
<p>　　除非另行指定，新环境是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">空环境</a>。</p>
<p>　　创建新环境的一个例子是 <a href="Features/NPL.zh-CN.html#vau-%E6%8A%BD%E8%B1%A1">vau 抽象</a>实现<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">过程调用</a>。</p>
<h4 id="环境的稳定性"><a class="header" href="#环境的稳定性">环境的稳定性</a></h4>
<p>　　环境在特定情形保证<em>稳定性(stability)</em> ：一个环境是<em>稳定的(stable)</em> ，仅当总是可假定绑定维持一定意义的等价性，而可确保访问其中同名实体的<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为等价</a>。</p>
<p>　　违反关于环境的稳定性的要求的程序具有<a href="Features/NPL.zh-CN.html#npla1-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">未定义行为</a>。</p>
<p>　　当前要求确保的稳定性包括：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E9%9A%90%E8%97%8F%E7%8E%AF%E5%A2%83">隐藏环境</a>的<a href="Features/NPL.zh-CN.html#%E9%87%8D%E7%BB%91%E5%AE%9A">绑定有效稳定性</a>和<a href="Features/NPL.zh-CN.html#%E8%A2%AB%E7%BB%91%E5%AE%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%80%BC%E5%92%8C%E5%8F%AF%E8%A7%82%E5%AF%9F%E8%A1%8C%E4%B8%BA">值稳定性</a>。</li>
<li>从构造时即明确要求的一等环境的稳定性，包括<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9D%97%E7%A8%B3%E5%AE%9A%E6%80%A7">模块稳定性</a>和可能由派生实现定义的其它稳定性。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　一般地，环境的稳定性要求构造环境时不能依赖非特定的动态环境（作为被<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>访问的父环境），因为这些环境的绑定可能具有在构造环境之后确定的绑定，而不能确保环境中的名称具有可预知的含义。</p>
<p>　　环境的稳定性简化分析程序的推理过程，也在许多上下文中允许程序更易被优化。</p>
<p>　　从稳定的环境多次访问对象的计算作用是幂等的。这允许合并多次访问为一次而不改变程序的行为，允许具有较小的实现开销。</p>
<p>　　环境的稳定性不易被可靠地判定甚至不可能被判定（例如，一个无法检查但可信的来源提供的环境），因此语言规则在此不要求进行检查。</p>
<p><strong>注释</strong></p>
<p>　　[R<sup>n</sup>RK] 的 <code>make-kernel-standard-environment</code> 若通过共享基础环境作为隐藏的父环境实现，也具有这里的稳定性。</p>
<p>　　但是，Kernel 不提供<a href="Features/NPL.zh-CN.html#npla1-%E5%AF%B9%E8%B1%A1%E5%90%8C%E4%B8%80%E6%80%A7">同一性保证</a>，也没有通过对象的引用<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a><a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的操作，因此不需要支持<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">不可修改引用</a>即可保证值稳定性。</p>
<h4 id="环境生存期"><a class="header" href="#环境生存期">环境生存期</a></h4>
<p>　　对象语言的实现提供给<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>使用的<a href="Features/NPL.zh-CN.html#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">初始环境</a>的环境对象及其中的子对象满足：</p>
<ul>
<li>其创建<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序于</a>用户程序的对象的创建。</li>
<li>除非提供为不满足<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7">环境的稳定性</a>的环境中的被绑定对象，其销毁后序于用户程序的对象的销毁。</li>
</ul>
<p>　　程序引用环境中的名称时，应确保环境在生存期内。</p>
<p><strong>注释</strong></p>
<p>　　环境中不满足稳定性的被绑定对象可能被修改且具有外部可见的<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>。若这个对象是一个环境的唯一强引用，则对应的环境对象在替换为其它值时被销毁。</p>
<p>　　特别地，应注意使用函数时引入父环境的生存期。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">对象语言内存安全保证</a>。</p>
<h4 id="环境中的绑定"><a class="header" href="#环境中的绑定">环境中的绑定</a></h4>
<p>　　环境中的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">绑定</a>的抽象不依赖对象语言中表达的引用的概念，允许直接关联一个没有引用的值。</p>
<p>　　环境中的<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">绑定对被绑定的对象具有所有权</a>。除在环境中绑定中间值的<a href="Features/NPL.zh-CN.html#%E4%B8%8D%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">不安全操作</a>，这种直接所有权是独占的。</p>
<p>　　绑定的变量名是<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>构成的<a href="Features/NPL.zh-CN.html#%CE%BB-%E5%AE%8C%E5%A4%87%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AF%B9%E5%BA%94%E8%AF%AD%E6%B3%95">名称表达式</a>，<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">解析</a>的结果总是<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>。</p>
<p><strong>注释</strong></p>
<p>　　环境中的绑定不依赖引用以及绑定所有权和 Kernel 的设计不同。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">一等引用</a>和<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>。</p>
<h4 id="重绑定"><a class="header" href="#重绑定">重绑定</a></h4>
<p>　　环境中允许变量以相同的名称被重新绑定，即<em>重绑定(rebinding)</em> 。</p>
<p><strong>注释</strong> 和 Scheme 类似。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>的<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8">引用</a>不因其引用的对象被重绑定操作替换值而被无效化。</p>
<p>　　重绑定替换被绑定对象的值，不改变对象的<a href="Features/NPL.zh-CN.html#npla1-%E5%AF%B9%E8%B1%A1%E5%90%8C%E4%B8%80%E6%80%A7">同一性</a>。若其中存在<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>，则子对象被销毁，任何子对象的引用值被<a href="Features/NPL.zh-CN.html#%E6%97%A0%E6%95%88%E5%8C%96">无效化</a>。</p>
<p>　　特别地，若继续访问已被<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值</a>指称的引用值引用的对象，则超出生存期访问而引起 <a href="Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">NPLA 未定义行为</a>。</p>
<p>　　任意<a href="Features/NPL.zh-CN.html#%E9%9A%90%E8%97%8F%E7%8E%AF%E5%A2%83">隐藏环境</a> <tt>e</tt> 应满足以下绑定有效稳定性：通过引用值间接访问 <tt>e</tt> 中绑定的对象时绑定保持有效（蕴含不被移除或重绑定），保持被绑定对象的生存期和 <tt>e</tt> 对其<a href="Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权</a>。</p>
<p>　　这避免因为上述访问违反<a href="Features/NPL.zh-CN.html#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>而引起 NPLA 未定义行为。</p>
<p>　　关于无效化，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h4 id="被绑定对象的值和可观察行为"><a class="header" href="#被绑定对象的值和可观察行为">被绑定对象的值和可观察行为</a></h4>
<p>　　任意<a href="Features/NPL.zh-CN.html#%E9%9A%90%E8%97%8F%E7%8E%AF%E5%A2%83">隐藏环境</a>的 <tt>e</tt> 的任意<a href="Features/NPL.zh-CN.html#npla1-%E5%AF%B9%E8%B1%A1%E5%90%8C%E4%B8%80%E6%80%A7">同一</a>被绑定对象 <tt>o</tt> 应满足以下的<em>值稳定性(value stability)</em> ：若 <tt>o</tt> 上发生<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">使其改变的副作用（如被修改）</a>，则之后在以 <tt>e</tt> 或任意以 <tt>e</tt> 作为直接或间接父环境的环境中直接以<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>或 <tt>o</tt> 的引用值访问 <tt>o</tt> 时，<tt>o</tt> 的值和发生作用前的 <tt>o</tt> 的值在影响<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>的意义上等价。</p>
<p>　　若不满足值稳定性，访问副作用发生后的对象引起<a href="Features/NPL.zh-CN.html#npla1-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">扩展 NPLA 未定义行为</a>。</p>
<p>　　以下情形使对象<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">改变</a>的副作用不受值稳定性要求的约束：</p>
<ul>
<li>对象通过合并子调用的返回值或其中的<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子对象引用</a>指定（不论合并子是否是隐藏环境中的<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>）。</li>
<li>对象间接访问具有<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">内部可变性</a>的对象的<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">可变管理状态</a>。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　通过限制<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a><a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">不可修改</a>可以维护<a href="Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的值稳定性。</p>
<p>　　对象<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">间接访问具有内部可变性的对象的可变管理状态</a>的一类典型实例是一等环境中的绑定中的子对象（即便这个一等环境对象是隐藏环境中的子对象）。</p>
<h4 id="冻结"><a class="header" href="#冻结">冻结</a></h4>
<p>　　环境可进行<em>冻结(freeze)</em> 。<em>冻结的(frozen)</em> 环境中取得的绑定和引用值<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">不可修改</a>。</p>
<p>　　特定的环境<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>要求环境不在冻结状态以确保不变量，要求<a href="Features/NPL.zh-CN.html#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>。检查失败则<a href="Features/NPL.zh-CN.html#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">引起类型错误</a>。</p>
<p>　　冻结一个已被冻结的环境没有作用。</p>
<p><strong>注释</strong> 冻结环境是<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">幂等</a>操作。</p>
<p>　　NPLA1 <a href="Features/NPL.zh-CN.html#%E9%9A%90%E8%97%8F%E7%8E%AF%E5%A2%83">隐藏环境</a>是冻结的。</p>
<p>　　当前 NPLA1 对象语言不提供在已有环境撤销冻结或在冻结的环境中添加、移除绑定或<a href="Features/NPL.zh-CN.html#%E9%87%8D%E7%BB%91%E5%AE%9A">重绑定</a>的方法。</p>
<p>　　若程序中使用其它方法（附加初始化或提供本机实现操作）撤销冻结或在冻结的环境中添加、移除绑定或重绑定而使对象语言安全性保证失效，这种方法应由派生实现定义，否则程序<a href="Features/NPL.zh-CN.html#npla1-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">行为未定义</a>。</p>
<p>　　关于对象语言安全性保证，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　环境的冻结操作类似 [ECMAScript] 的对象的冻结操作。类似地，冻结环境不会冻结其中的变量绑定中可能存在的<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">环境子对象</a>。</p>
<h3 id="npla1-广义列表"><a class="header" href="#npla1-广义列表">NPLA1 广义列表</a></h3>
<p>　　NPLA1 的<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">广义列表</a>是<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>或者无环的<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">非真列表</a>，其<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">元素</a>不构成<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">环</a>。</p>
<p>　　列表的<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8">引用</a>构成其它对象时，也不构成<a href="Features/NPL.zh-CN.html#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">环</a>。</p>
<p><strong>原理</strong> 排除环使处理列表的操作不需要考虑一些复杂的<a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">自引用</a>情形。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>的<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">形式参数树</a>是可能是<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号</a>或真列表。</p>
<p><strong>注释</strong> 形式参数树可作为表达式直接在<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源程序</a>中表达。</p>
<p>　　通常意义的列表即<a href="Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>。</p>
<p>　　除非另行指定，NPLA1 列表类型指<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">真列表</a>。非真列表的类型是<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">有序对</a>。</p>
<p><strong>原理</strong></p>
<p>　　和 Scheme 及 Kernel 不同，NPLA 支持的列表都是真列表。另见<a href="Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">关于自引用数据结构和循环引用的分析</a>。</p>
<p>　　列表的这些特性确保基于列表的数据结构在对象语言逻辑上的简单性。也因此 NPLA1 对应的操作中，没有对环存在性的检查。</p>
<p>　　没有环的结构能保证所有权语义能按需嵌入(embed) 到列表中，即列表可保证表示为同构的具有对节点所有权的嵌套 <a href="Features/NPL.zh-CN.html#%E6%9C%89%E5%BA%8F%E5%AF%B9">cons 对</a>。</p>
<h4 id="有序对的子对象和子对象引用"><a class="header" href="#有序对的子对象和子对象引用">有序对的子对象和子对象引用</a></h4>
<p>　　有序对的元素是有序对的<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>，有序对对作为元素的表示具有所有权。同一个有序对的元素节点之间没有所有权关系。</p>
<p>　　部分操作可能修改有序对的子对象。</p>
<p>　　除非另行指定，有序对的子对象被转移，使用<a href="Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">项的转移</a>。被转移的子对象在被转移后不在被转移的有序对中存在。</p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子有序对引用</a>可被<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>引入。</p>
<p>　　关于子对象被修改和转移，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>注释</strong></p>
<p>　　<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子有序对引用</a>和<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子列表引用</a>是<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子对象引用</a>。</p>
<p>　　当前有序对引用总是引用至少一个有序对的元素。</p>
<p>　　由绑定使用引用标记字符的<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">非递归绑定</a>的规则，绑定列表的子对象引用不直接共享操作数有序对对象，而共享元素是原容器元素的（<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">经折叠的</a>）引用值的有序对，是子有序对引用。</p>
<p>　　这类似宿主语言的容器对象一般不能转换为共享容器部分元素的 C++ 对象引用。</p>
<h3 id="npla1-合并子"><a class="header" href="#npla1-合并子">NPLA1 合并子</a></h3>
<p>　　除非另行指定（如<a href="Features/NPL.zh-CN.html#%E5%BC%BA%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">强递归绑定</a>），对象语言中的所有合并子都是<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">真合并子</a>。</p>
<p>　　NPLA1 对象语言不提供其它合并子的普遍操作。</p>
<p><strong>注释</strong> 但<a href="Features/NPL.zh-CN.html#npla1-%E4%BA%92%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">互操作</a>意义上的 NPLA1 API 可支持其它合并子。</p>
<p>　　合并子和操作数组合构成的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>是一个 NPLA1 对象，称为<em>函数合并对象(function combination object)</em> 。</p>
<p><strong>注释</strong> <a href="Features/NPL.zh-CN.html#npla1-%E8%A7%84%E8%8C%83%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值算法</a>可接受的函数合并对象是<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">有序对</a>。<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并表达式</a>作为函数合并对象是<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">列表</a>。</p>
<p>　　NPLA1 的合并子使用<em>包装数(wrapping count)</em> 存储可能需要求值操作数的次数。</p>
<p>　　在不出错时行为和不使用包装数而直接使用嵌套子对象实现的行为完全一致，但在到达实现支持的最大包装数时继续包装即<em>包装数溢出(wrapping count overflow)</em> ，行为可能不相同：</p>
<p>　　若某个操作使合并子超出上限，则符合<a href="Features/NPL.zh-CN.html#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF%E6%9D%A1%E4%BB%B6">非宿主资源耗尽的错误条件</a>。</p>
<p>　　实现支持的最大包装数应满足：若发生包装数溢出，则直接创建和包装数相同个数的合并子符合<a href="Features/NPL.zh-CN.html#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF%E6%9D%A1%E4%BB%B6">宿主资源耗尽的错误条件</a>。</p>
<p><strong>原理</strong></p>
<p>　　为<a href="Features/NPL.zh-CN.html#%E5%8F%AF%E4%BF%AE%E6%94%B9%E6%80%A7">可修改性</a>，允许非真合并子。这可在互操作中表示类似合并子但在语言中不可见的非一等对象。</p>
<p>　　为维护语言规则的<a href="Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>，合并子默认是真合并子。</p>
<p>　　NPLA1 对象语言不提供其它合并子的普遍操作，这不保证完全满足类似 <a href="Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7">G1b</a> 的原则。</p>
<p>　　尽管<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%9E%8B">没有要求</a>，这种规约也更符合 G1b ；同时，这易于移植 Kernel 代码。</p>
<p><strong>注释</strong></p>
<p>　　Kernel 的合并子对应 NPL 的<a href="Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90">真合并子</a>。</p>
<p>　　对最大包装数的要求需要实现支持包装数是能和宿主资源的空间相较规模的值，这保证使用包装数的实现的空间效率不弱于不使用包装数而直接分配合并子包装的实现。</p>
<p>　　这也表示通常<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>的操作不会发生包装数溢出：若包装操作的次数导致包装数溢出，则直接分配合并子的替代操作也应由于宿主资源耗尽而失败。</p>
<h3 id="npla1-数值"><a class="header" href="#npla1-数值">NPLA1 数值</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#%E9%99%84%E5%8A%A0%E5%8A%9F%E8%83%BD">数值支持</a>的实现兼容<a href="Features/NPL.zh-CN.html#npla-%E6%95%B0%E5%AD%A6%E5%8A%9F%E8%83%BD">NPLA 数学功能</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#npla1-%E6%95%B0%E5%80%BC%E5%AD%97%E9%9D%A2%E9%87%8F">NPLA1 数值字面量</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>是数值。</p>
<h2 id="函数的间接值使用约定"><a class="header" href="#函数的间接值使用约定">函数的间接值使用约定</a></h2>
<p>　　引用值作为间接值，首先符合作为实体的<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8">引用</a>的使用约定。</p>
<h3 id="间接值作为实际参数"><a class="header" href="#间接值作为实际参数">间接值作为实际参数</a></h3>
<p>　　除非另行指定，一般地，函数接受左值引用操作数，使用引用的对象的值和直接使用右值作用相同，但不会修改被左值引用的对象。</p>
<p>　　这等价隐含无副作用的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">左值到右值转换</a>。</p>
<p><strong>注释</strong></p>
<p>　　另行指定的例子如<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91">函数参数转发</a>。</p>
<p>　　此处的左值引用和宿主语言中的（ <code>const</code> 非 <code>volatile</code> ）左值作用类似。</p>
<h3 id="间接值作为函数值"><a class="header" href="#间接值作为函数值">间接值作为函数值</a></h3>
<p>　　部分<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>总是非引用值。</p>
<p>　　这些操作对应的函数调用返回非引用值。</p>
<p>　　返回非引用值的行为应等价<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>。</p>
<p>　　其它操作可具有引用值结果，对应的函数调用可返回引用值。</p>
<p><strong>原理</strong></p>
<p>　　函数值非引用值可满足具体操作的语义要求（如非引用值的<a href="Features/NPL.zh-CN.html#%E5%88%9B%E5%BB%BA%E5%92%8C%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0">构造器</a>），减少误用的可能性，并帮助提供<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">内存安全保证</a>。</p>
<h3 id="保留引用值"><a class="header" href="#保留引用值">保留引用值</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E9%97%B4%E6%8E%A5%E5%80%BC">保留间接值</a>，包括<a href="Features/NPL.zh-CN.html#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%9D%A5%E6%BA%90">直接保留间接值和间接保留间接值</a>，适用<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>的情形，对应地称为保留引用值、直接保留引用值和间接保留引用值。</p>
<p>　　除非另行指定，被保留的引用值不被<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">折叠</a>。</p>
<p><strong>原理</strong></p>
<p>　　必要时要求引用折叠可避免引入非预期的引用的引用值。</p>
<p>　　被保留的引用值可能<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">逃逸</a>或不逃逸而通常不能直接证明具有<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">内存安全保证</a>。</p>
<h3 id="保留环境引用"><a class="header" href="#保留环境引用">保留环境引用</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E9%97%B4%E6%8E%A5%E5%80%BC">保留间接</a>值适用<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境引用</a>。</p>
<p><strong>注释</strong></p>
<p>　　和<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">保留引用值</a>的情形不同，因为只允许通过环境引用在对象语言中访问环境对象及其子对象，访问环境但不保留环境引用的操作<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">只可能在（不保证内存安全的）互操作中出现</a>。</p>
<h2 id="函数参数和函数值传递约定"><a class="header" href="#函数参数和函数值传递约定">函数参数和函数值传递约定</a></h2>
<p>　　函数可能<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0">接受引用值参数</a>和<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">返回引用值</a>，是对函数的形式参数或函数值的<a href="Features/NPL.zh-CN.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a>。</p>
<p>　　在复制初始化形式参数和<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>时，部分函数保证被初始化的值和<a href="Features/NPL.zh-CN.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初值符</a>的<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E5%92%8C%E7%B1%BB%E5%9E%8B">值类别和可修改性</a>一致。这些初始化是<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%80%BC%E4%BC%A0%E9%80%92">转发</a>操作。</p>
<p><strong>注释</strong></p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%80%BC%E4%BC%A0%E9%80%92">函数参数和函数值传递</a>。</p>
<h3 id="传递非引用值参数"><a class="header" href="#传递非引用值参数">传递非引用值参数</a></h3>
<p>　　一些函数的参数进行<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">左值到右值转换</a>，实现参数的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值传递</a>。</p>
<p>　　这类似宿主语言中直接使用对象类型的形式参数。</p>
<h3 id="函数参数转发"><a class="header" href="#函数参数转发">函数参数转发</a></h3>
<p>　　一些求值为引用值的函数的部分实际参数被保留，而不进行<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">左值到右值转换</a>。</p>
<p>　　这些值以保留值类别不变的形式被直接作为操作数，用于调用其它合并子。这种参数被<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%80%BC%E4%BC%A0%E9%80%92">转发</a>。</p>
<p><strong>注释</strong></p>
<p>　　这些参数的转发类似<a href="Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>支持的<a href="Features/NPL.zh-CN.html#%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91">参数转发</a>。</p>
<p>　　参数转发的实现可判断<a href="Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB">值类别</a>后分别对<a href="Features/NPL.zh-CN.html#%E4%BC%A0%E9%80%92%E9%9D%9E%E5%BC%95%E7%94%A8%E5%80%BC%E5%8F%82%E6%95%B0">传递非引用值</a>或直接传递引用值提供实现，或直接使用绑定构造。前者支持本机实现。</p>
<h3 id="返回非引用值"><a class="header" href="#返回非引用值">返回非引用值</a></h3>
<p>　　返回非引用值和参数的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值传递</a>类似：若初始化函数值的初值符是引用，复制或转移被引用对象的值而不是引用值。</p>
<p><strong>注释</strong></p>
<p>　　这类似宿主语言中返回 <code>auto</code> 类型。</p>
<h3 id="函数值转发"><a class="header" href="#函数值转发">函数值转发</a></h3>
<p>　　一些其它保留引用值的操作中，引用值来自参数，且难以通过自身的逻辑单独决定可否安全地直接返回引用值。</p>
<p>　　此时，在返回之前根据特定参数是否为引用值，可选地转换<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>以确定是否保留引用值，即进行转发。</p>
<p>　　特定的显式转发操作转发<a href="Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>使临时对象被转移，以转发的值作为结果，可不同于使用<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>：</p>
<ul>
<li>同返回值转换，转发转移右值，复制左值。</li>
<li>但当转发临时对象可确定唯一使用时，也转移临时对象。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　函数值转发使某些操作在默认情况下满足间接值生存期规则而保持内存安全，符合<a href="Features/NPL.zh-CN.html#%E9%80%82%E7%94%A8%E6%80%A7">适用性原则</a>。</p>
<p><strong>注释</strong></p>
<p>　　确定是否保留引用值的机制类似 [ISO C++14] 中从没有括号的 <code>id-expression</code> 上推断返回 <code>decltype(auto)</code> 类型是否为引用类型。</p>
<p>　　函数值转发的实现可通过判断是否需要转发引用而<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">按需决定返回引用值或非引用值</a>，或使用标准库的相关函数。前者支持本机实现。</p>
<p>　　另见<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%AF%E8%BD%AC%E7%A7%BB%E6%9D%A1%E4%BB%B6">对象的可转移条件</a>。</p>
<p>　　显式转发操作把右值、消亡值和带有<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">临时对象属性</a>的<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B">左值引用</a>视为被转发的目标。</p>
<p>　　转发列表对象的<a href="Features/NPL.zh-CN.html#%E6%9C%89%E5%BA%8F%E5%AF%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子对象</a>可能转移这个对象。</p>
<h3 id="创建和访问对象的函数"><a class="header" href="#创建和访问对象的函数">创建和访问对象的函数</a></h3>
<p>　　<em>构造器(constructor)</em> 是用于创建对象的函数。</p>
<p>　　除非显式指定创建的对象具有引用值类型，构造器是<em>典型的(typical)</em> ，<a href="Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E9%9D%9E%E5%BC%95%E7%94%A8%E5%80%BC">返回非引用值</a>。</p>
<p>　　部分操作涉及对其它对象具有所有权的对象。</p>
<p>　　一部分对象的构造器创建的对象完全通过其它对象的引用或<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">对象的值</a>作为构造器的参数而决定，且创建的对象对这些参数具有所有权，这样的对象称为容器(container) 。</p>
<p>　　容器构造器的参数作为容器的<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>，是容器的<em>元素(element)</em> 。</p>
<p>　　以容器对象或其引用作为参数，取得容器元素对象或其引用的函数是容器元素<em>访问器(accessor)</em> 。</p>
<p>　　标准库提供一些属于构造器和访问器的操作。除非另行指定，标准库的访问器符合<a href="Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E7%BA%A6%E5%AE%9A">子对象访问约定</a>。</p>
<p><strong>注释</strong></p>
<p>　　容器的元素扩展了<a href="Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">有序对和列表的元素</a>的概念。</p>
<p>　　一些不是容器的对象（如<a href="Features/NPL.zh-CN.html#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">真合并子</a>）可通过非容器形式的构造器创建。</p>
<h3 id="转发参数或返回值的实现"><a class="header" href="#转发参数或返回值的实现">转发参数或返回值的实现</a></h3>
<p>　　没有约定需要转发的情形不使用显式的转发。</p>
<p><strong>注释</strong></p>
<p>　　可<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91">转发参数</a>或<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%80%BC%E8%BD%AC%E5%8F%91">转发返回值</a>的函数可包含以下实现方式：</p>
<ul>
<li>使用特定的操作，以需被转发的表达式作为其操作数。</li>
<li>（仅对参数转发）使用<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">标记字符</a> <code>%</code> 的<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">参数绑定</a>的变量。</li>
</ul>
<p>　　上述特定的操作可在被求值的表达式中构造显式的转发。</p>
<h1 id="npla1-参照实现环境"><a class="header" href="#npla1-参照实现环境">NPLA1 参照实现环境</a></h1>
<p>　　NPLA1 提供参照实现环境。其实现可在内部使用 NPLA1 <a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">库特性</a>，提供给 NPLA1 <a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>。</p>
<p>　　NPLA1 参照实现环境和用户程序遵循部分不同的要求和约定。</p>
<p>　　本章中的其它约定适用 NPLA1 参照实现环境，且可选地被用户程序使用。</p>
<h2 id="npla1-初始求值环境"><a class="header" href="#npla1-初始求值环境">NPLA1 初始求值环境</a></h2>
<p>　　NPLA1 以环境对象中的绑定作为公开的接口提供库特性，以进一步提供<em>初始环境(initial environment)</em> 作为<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">求值环境</a>，即用户程序初始的<a href="Features/NPL.zh-CN.html#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>。</p>
<p>　　这些环境对象包含两类：</p>
<ul>
<li>自身是<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">核心语言特性</a>，而不是公开为库特性可访问的一等环境。</li>
<li>自身是作为库特性的一等环境对象（通常是其它环境的<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>）。</li>
</ul>
<p>　　作为核心语言特性时，这些环境对象可以不是<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">一等环境</a>，但应能和一等环境在<a href="Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>中的作用一致：作为<a href="Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83">父环境</a>。</p>
<p>　　NPLA1 实现提供的这种由实现初始化的作为核心语言特性的环境对象称为<em>根环境(root environment)</em> 。</p>
<p>　　NPLA1 实现提供<em>基础环境(ground environment)</em> 。基础环境应包含语言规范要求提供的所有绑定，且不包含名称除<a href="Features/NPL.zh-CN.html#%E6%A0%87%E8%AF%86%E7%AC%A6%E9%99%84%E5%8A%A0%E8%A7%84%E5%88%99">保留名称</a>外的绑定。</p>
<p>　　基础环境是<a href="Features/NPL.zh-CN.html#%E9%9A%90%E8%97%8F%E7%8E%AF%E5%A2%83">隐藏环境</a>，不被直接访问。</p>
<p>　　除非另行指定，根环境和作为库特性的一等环境对象初始化后在用户程序访问前被<a href="Features/NPL.zh-CN.html#%E5%86%BB%E7%BB%93">冻结</a>。</p>
<p>　　初始环境是一个包含基础环境作为直接或间接父环境的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">空环境</a>。</p>
<p>　　实现可选地提供基础环境以外的根环境，允许派生实现定义在用户程序中<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改其中的绑定</a>的机制（而不一定是隐藏环境），直至被实现初始化参考环境的特定用户程序封装或冻结而避免进一步修改。</p>
<p>　　如有必要，用户程序可通过派生实现定义的方式引入其它根环境。</p>
<p><strong>原理</strong></p>
<p>　　这些环境对象设计为在参照实现环境提供，因为：</p>
<ul>
<li>不都保证能在用户程序中可移植地创建，而有必要在参照实现环境中提供。</li>
<li>提供的库特性在可移植程序中可能经常出现，而适合在参照实现环境中提供。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　提供基础环境和 Kernel 类似。</p>
<p>　　特性设计注记：</p>
<ul>
<li>为避免依赖逻辑上复杂的形式，一些特性当前在当前设计中排除。
<ul>
<li>例如，依赖一阶算术的操作、其硬件加速形式的 ISA 表示的整数操作及依赖这些操作实现的<a href="https://en.wikipedia.org/wiki/Numerical_tower"><em>数值塔(numerical tower)</em> (en-US)</a> 被整体忽略。</li>
</ul>
</li>
<li>上述忽略的特性可由派生实现补充，在派生根环境后按需进行 AOT(ahead-of-time) 优化（如 Kernel 的 <code>$let-safe!</code> 中包含的内容，其中引用基础环境的符号不再可变），然后组成类似基础环境。</li>
</ul>
<p>　　通过派生实现定义的方式一般依赖<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>。</p>
<h3 id="npla1-实现环境初始化"><a class="header" href="#npla1-实现环境初始化">NPLA1 实现环境初始化</a></h3>
<p>　　<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">实现环境</a>的初始化完成初始环境的准备，包括蕴含所有初始环境依赖的资源<em>基础上下文(ground context)</em> 的初始化。</p>
<p>　　初始化基础上下文蕴含的根环境是<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值</a>默认使用的求值环境，初始化后可直接封装为基础环境使用。</p>
<p>　　派生实现可在以上初始化结束之后，在运行用户程序之前完成其它初始化。</p>
<p>　　初始化成功后，用户程序被运行；否则，程序非正常终止。</p>
<p>　　以上初始化同时可能提供<a href="Features/NPL.zh-CN.html#npla1-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F">扩展字面量</a>支持。</p>
<p><strong>注释</strong></p>
<p>　　对初始化失败而终止的程序，建议但不要求实现给出诊断。</p>
<h3 id="导入符号"><a class="header" href="#导入符号">导入符号</a></h3>
<p>　　在环境中定义另一个环境中的同名变量，使被定义的变量是后者的引用值或值的副本，则称指定此变量名的<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>在后者被<em>导入(import)</em> 前者。</p>
<p><strong>注释</strong> 用户程序可导入环境中的符号值使用库中的绑定。</p>
<h2 id="模块-1"><a class="header" href="#模块-1">模块</a></h2>
<p>　　NPLA1 以绑定提供的语言特性被分组归类为<a href="Features/NPL.zh-CN.html#%E6%A8%A1%E5%9D%97%E5%8C%96">模块</a>。</p>
<p><strong>注释</strong> 同 [R<sup>n</sup>RK] 。</p>
<p>　　模块的<em>源(source)</em> 提供特性的实现，可以是本机实现或者 NPLA1 程序。对应的模块分别是本机模块和<a href="Features/../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源程序</a>模块。</p>
<p>　　模块的源可以是实现内建的，或位于实现环境提供的外部资源（如文件系统）。</p>
<p>　　因为模块以绑定的集合的形式提供，需被包含在可访问的环境，或包含环境作为<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的其它对象中。</p>
<p>　　以<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">环境对象</a>作为模块的源的模块化方式称为<em>环境作为模块(environment as module)</em> 。[R<sup>n</sup>RK] 的 <code>get-module</code> 的结果和参照实现扩展环境的模块是这种方式的例子。</p>
<p>　　模块可能包含<em>子模块(submodule)</em> 提供其特性子集。以环境作为模块时，<a href="Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83">环境子对象</a>可作为子模块。</p>
<p>　　从模块的源得到提供一个模块的所有绑定集合的环境对象的过程称为模块的<em>加载(loading)</em> 。</p>
<p>　　模块加载可能失败。失败的模块加载<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　<a href="Features/NPL.zh-CN.html#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">根环境</a>加载的失败不被直接依赖这些环境的 NPLA1 用户程序处理（而视为实现初始化的运行时错误）。</p>
<p>　　一般地，模块和加载模块得到的环境对象没有直接对应关系：一个模块的绑定可以由一个或多个环境提供，一个已被加载的环境可能提供零个或多个程序可见的模块。但除非另行指定，一个模块的绑定不在超过一个的不相交的环境（之间没有直接或间接父环境关系）中提供。</p>
<p>　　程序可通过加载外部模块来源取得模块。除非另行指定，这种模块以一个一等环境对象（可包含作为环境的直接或间接子对象）中的绑定提供。</p>
<h3 id="标准库模块的初始化和加载"><a class="header" href="#标准库模块的初始化和加载">标准库模块的初始化和加载</a></h3>
<p>　　标准库实现可作为<a href="Features/../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言实现</a>。<a href="Features/NPL.zh-CN.html#npla1-%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96">实现环境初始化</a>以提供模块时，可访问不作为公开接口提供的模块的源。</p>
<p><strong>注释</strong> 派生实现可同时以标准库以外形式提供这些源为公开接口，用户程序也可显式地加载这些源对应的模块。</p>
<p>　　除非另行指定：</p>
<ul>
<li>若这些源可能引起引入非公开的接口的副作用，则对应的模块不应被用户程序直接加载。</li>
<li>假定加载这些模块时，<a href="Features/NPL.zh-CN.html#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>是和标准环境或与其等价的其它环境。
<ul>
<li>其中，等价指使用其它环境不引入程序<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>差异。</li>
<li><strong>注释</strong> 等价的环境的例子包括以标准环境为父环境的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">空环境</a>，以及这样的空环境<a href="Features/NPL.zh-CN.html#%E5%AF%BC%E5%85%A5%E7%AC%A6%E5%8F%B7">导入符号</a>的得到的结果。</li>
<li><strong>注释</strong> 若模块的加载不访问加载时初始的当前环境（通常仅在本机模块上适用），加载模块使用的环境可不影响可观察行为而不影响假定（即便和标准环境不等价）。</li>
</ul>
</li>
</ul>
<p>　　违反以上要求或假定的程序<a href="Features/NPL.zh-CN.html#npla1-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">行为未定义</a>。</p>
<p>　　关于标准环境，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　以源程序模块实现时，一般不要求检查<a href="Features/NPL.zh-CN.html#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">初始环境</a>。这能有效减少实现的复杂性。</p>
<p>　　因为标准环境不提供用户程序检查是否和其中定义的实体一致的直接的方法，通过替代的检查可能排除符合假定的初始环境。</p>
<p><strong>注释</strong></p>
<p>　　这里的初始化可包含派生实现定义的其它初始化。</p>
<p>　　虽然 NPLA1 标准库不作为接口保证提供这些源，这里的假定和 [ISO C++] <a href="https://eel.is/c++draft/using.headers">[using.headers]</a> 对引入标准库头的程序位置的限制类似：语言实现能有效地假定源程序中引入标准库头的上下文，因此标准库中的名称具有预期的含义。</p>
<h3 id="模块稳定性"><a class="header" href="#模块稳定性">模块稳定性</a></h3>
<p>　　提供模块绑定的环境依赖已知来源的绑定而确保<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7">稳定</a>。</p>
<p>　　除非另行指定，模块中的特性依赖提供模块绑定的环境的生存期。</p>
<p>　　除非另行指定，标准库实现应确保其中的模块在程序的生存期中可用。</p>
<p><strong>原理</strong></p>
<p>　　特性依赖性允许实现操作的模块中绑定的<a href="Features/NPL.zh-CN.html#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>可具有静态环境是提供模块绑定的环境的<a href="Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的合并子的实现。</p>
<p><strong>注释</strong></p>
<p>　　稳定要求同 [R<sup>n</sup>RK] 的 <code>get-module</code> 的约定。但因为<a href="Features/NPL.zh-CN.html#%E8%A2%AB%E7%BB%91%E5%AE%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%80%BC%E5%92%8C%E5%8F%AF%E8%A7%82%E5%AF%9F%E8%A1%8C%E4%B8%BA">值稳定性</a> ，<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7">和 Kernel 不同</a>，NPLA1 的稳定绑定<a href="Features/NPL.zh-CN.html#%E8%A2%AB%E7%BB%91%E5%AE%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%80%BC%E5%92%8C%E5%8F%AF%E8%A7%82%E5%AF%9F%E8%A1%8C%E4%B8%BA">一般不可修改</a>。</p>
<p>　　对标准库模块，稳定性要求一般表示其中的特性不能依赖用户程序运行时的非特定的<a href="Features/NPL.zh-CN.html#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>，而可依赖从<a href="Features/NPL.zh-CN.html#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">基础环境</a>及从基础环境派生的<a href="Features/NPL.zh-CN.html#%E6%96%B0%E7%8E%AF%E5%A2%83">新环境</a>。</p>
<p>　　生存期可用的规则一般要求标准库实现在初始化后保存<a href="Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境强引用</a>。</p>
<h2 id="库接口约定"><a class="header" href="#库接口约定">库接口约定</a></h2>
<p>　　<a href="Features/NPL.zh-CN.html#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">基础环境</a>的特性在<a href="Features/NPL.zh-CN.html#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">根环境</a>中直接绑定，统称根环境特性。</p>
<p>　　关于特性的约束作用于接口描述。不改变<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>时，实现可使用不同的未指定的根环境提供绑定。</p>
<p>　　描述模块接口的小节可以指定适用于该小节的模块约定。此时，描述的边界应能和其余的<a href="Features/NPL.zh-CN.html#%E5%BA%93%E6%8E%A5%E5%8F%A3%E5%AE%9E%E4%BD%93">实体</a>区分。</p>
<p>　　接口可能提供关于宿主语言<a href="Features/NPL.zh-CN.html#npla1-%E4%BA%92%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">互操作的约定</a>，作为对提供这些支持的实现的要求。</p>
<p>　　关于 NPLA1 根环境特性，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>注释</strong></p>
<p>　　具体根环境的存在性未指定。在同一个环境中可见的不同变量可能来自不同的根环境。</p>
<p>　　接口描述的顺序同 [R<sup>n</sup>RK] §4 的原理，允许接口仅依赖先前出现的接口派生实现。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，库主要提供<a href="Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB">一元谓词</a>，也不需要为 <code>&lt;body&gt;</code> 隐含 <code>$sequence</code> 支持重新定义 <code>$vau</code> 等操作，不需要拆分 Kernel 的核心库特性到 [R<sup>n</sup>RK] §5 和 §6 。</p>
<h3 id="库接口实体"><a class="header" href="#库接口实体">库接口实体</a></h3>
<p>　　按实体区分，NPLA1 的库特性有两类：<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">对象</a>和<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作</a>。</p>
<p>　　对象语言中可实现的操作以<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0">函数</a>的形式提供，可以是<a href="Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>的<a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>函数或由现有操作派生的<a href="Features/NPL.zh-CN.html#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>。</p>
<p>　　除此之外，派生实现可指定提供对象或操作对应的<a href="Features/NPL.zh-CN.html#%E9%9D%9E%E5%B8%B8%E8%A7%84%E5%87%BD%E6%95%B0">非常规函数</a>。</p>
<p>　　操作的<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">结果</a>是对应的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>在<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%9D%A1%E4%BB%B6">正常控制</a>下取得的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>，即<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>；操作的作用即<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">函数调用的作用</a>。</p>
<p>　　根据操作的功能描述，对应的函数可能具有<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%9D%A1%E4%BB%B6">非正常的控制条件</a>。此时，函数调用不取得函数值，操作不具有结果。</p>
<p><strong>注释</strong> 非正常退出时，函数调用的求值结果可以是<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">错误对象</a>或派生实现定义的其它表示求值结果的实体。</p>
<p>　　除非另行指定，函数调用时具有的<a href="Features/NPL.zh-CN.html#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF%E6%9D%A1%E4%BB%B6">错误条件</a>是非正常的控制条件；其中，以<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%82%E5%B8%B8">异常</a>实现错误条件的情形具有<a href="Features/NPL.zh-CN.html#%E5%BC%82%E5%B8%B8">异常条件</a>。</p>
<p>　　特定的操作约定对应的函数是<a href="Features/NPL.zh-CN.html#%E7%BB%88%E6%AD%A2%E4%BF%9D%E8%AF%81">终止函数</a>或<a href="Features/NPL.zh-CN.html#%E7%BB%88%E6%AD%A2%E4%BF%9D%E8%AF%81">全函数</a>；这不适用于满足错误条件的情形。</p>
<p>　　特定的操作约定对应的函数<a href="Features/NPL.zh-CN.html#%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%BA%A6%E5%AE%9A">作为算法过程满足计算复杂度约定</a>。</p>
<p><strong>注释</strong> 排除错误条件，指定复杂度的函数是终止函数。</p>
<p>　　本章其余各节适用 NPLA1 对象语言中的这些操作。</p>
<p>　　操作中的大部分具有特定的名称，满足<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E7%BA%A6%E5%AE%9A">函数名称约定</a>。</p>
<p>　　其它操作不具有特定名称，可由上述操作间接地提供，如蕴含在某些操作涉及的<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>中。</p>
<p><strong>注释</strong></p>
<p>　　在对象语言中不能直接表达的操作不能作为库特性，这些操作不对应库接口实体，其结果和作用仍照<a href="Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">更一般的规则</a>处理。</p>
<p>　　渐进复杂度常以 <a href="https://zh.wikipedia.org/zh-cn/%E5%A4%A7O%E7%AC%A6%E5%8F%B7"><tt>O</tt> 记号</a>指定上界。</p>
<p>　　若函数调用总是取得值，指定复杂度的函数同时是全函数。</p>
<h3 id="库特性实现分类"><a class="header" href="#库特性实现分类">库特性实现分类</a></h3>
<p>　　库特性分为<em>基本的(primitive)</em> 和<em>派生的(derived)</em> 。</p>
<p><strong>原理</strong></p>
<p>　　前者在设计上不分解为更小的其它特性的组合，通常需要本机实现；后者可由可移植的 NPLA1 源代码实现。</p>
<p><strong>注释</strong></p>
<p>　　区分基本和派生的特性在设计上类似 [R<sup>n</sup>RK] 中的基本和库特性。</p>
<p>　　注意和 [R<sup>n</sup>RK] 的库特性不同（而更接近宿主语言），NPLA1 的库特性是以 NPLA1 程序使用的接口而非实现的角度定义的，不总是使用对象语言实现，外延更广。</p>
<h3 id="标准库"><a class="header" href="#标准库">标准库</a></h3>
<p>　　本文档中要求的通过<a href="Features/NPL.zh-CN.html#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">基础环境</a>直接或间接提供的<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">库</a>总称<em>标准库(standard library)</em> 。</p>
<p>　　标准库的接口随语言规范在本章和参照实现扩展环境约定。</p>
<p>　　<em>核心库(core library)</em> 是提供直接绑定在基础环境中的、保证可派生实现的接口的标准库模块。</p>
<p>　　在参照实现环境中的不同标准库模块的绑定都可在基础环境访问。</p>
<p>　　在参照实现扩展环境中的标准库模块以其它环境（通常作为基础环境的子对象提供）中的绑定和基础环境隔离。</p>
<p>　　派生实现可以库的形式提供语言扩展或其它功能特性，扩充标准库。</p>
<p>　　关于参照实现扩展环境，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>注释</strong></p>
<p>　　因为<a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">库的定义</a>和 [R<sup>n</sup>RK] 指定的不同，类似 [R<sup>n</sup>RK] §4 约定的基本特性，属于 NPLA1 <a href="Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">库特性</a>。</p>
<h3 id="扩展库"><a class="header" href="#扩展库">扩展库</a></h3>
<p>　　基础环境也可提供的附带的其它接口，和标准库使用相同的约束。</p>
<p>　　一些操作的描述使用等价的表达式求值指定。除非另行指定，这些表达式中：</p>
<ul>
<li>若<a href="Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7">符号值</a>和先前出现的函数同名，则指称对应的操作。</li>
<li>默认使用基础环境作为求值环境。</li>
</ul>
<h2 id="常规函数约定"><a class="header" href="#常规函数约定">常规函数约定</a></h2>
<p>　　本节提供<a href="Features/NPL.zh-CN.html#%E5%BA%93%E6%8E%A5%E5%8F%A3%E5%AE%9E%E4%BD%93">作为库特性的函数</a>的默认规则以简化库特性的描述。</p>
<p><strong>注释</strong> 库的一般派生实现和用户程序的实现也建议参照本节约定。</p>
<p>　　除非另行指定，操作以指定名称的变量的形式提供，求值为可参与<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>的一等实体（但函数合并不一定保证是<a href="Features/NPL.zh-CN.html#%E7%BF%BB%E8%AF%91%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%A7%84%E5%88%99">合式的</a>可求值的表达式）。</p>
<p>　　除非另行指定，函数作为表达式，求值为<a href="Features/NPL.zh-CN.html#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>，其函数合并的求值蕴含<a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>。</p>
<p>　　除非另行指定，本文档约定的函数在其调用不依赖用户程序提供的非终止函数时，总是<a href="Features/NPL.zh-CN.html#%E7%BB%88%E6%AD%A2%E4%BF%9D%E8%AF%81">终止函数</a>。</p>
<p>　　若满足上述条件的函数不具有<a href="Features/NPL.zh-CN.html#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF%E6%9D%A1%E4%BB%B6">错误条件</a>，忽略因实现环境引发的错误（如<a href="Features/NPL.zh-CN.html#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF%E6%9D%A1%E4%BB%B6">宿主资源耗尽</a>），视为（对象语言中的）全函数。</p>
<p><strong>注释</strong></p>
<p>　　无条件遍历访问<a href="Features/NPL.zh-CN.html#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用子对象</a>的程序具有未定义行为，在讨论终止函数时已被排除。</p>
<h3 id="函数值约定"><a class="header" href="#函数值约定">函数值约定</a></h3>
<p>　　除非另行指定：</p>
<ul>
<li><a href="Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>不是<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>，以便通过保证满足<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>生存期规则维护<a href="Features/NPL.zh-CN.html#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>。</li>
<li>函数不在函数值中<a href="Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">保留引用值</a>，即<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">函数值经过返回值转换</a>。
<ul>
<li><strong>注释</strong> 保留引用值时，函数值仍可能是非引用值。</li>
</ul>
</li>
<li>若函数值保留引用值，引用值被<a href="Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">折叠</a>。</li>
</ul>
<h3 id="实际参数约定"><a class="header" href="#实际参数约定">实际参数约定</a></h3>
<p>　　除非另行指定：</p>
<ul>
<li>函数的实际参数的<a href="Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">传递</a>不具有影响<a href="Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>的<a href="Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>。
<ul>
<li><strong>注释</strong> 这一般要求避免复制宿主语言中复制时具有副作用的对象。</li>
</ul>
</li>
<li>函数的实际参数若被求值，<a href="Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0">隐含左值到右值转换</a>。</li>
</ul>
<h3 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h3>
<p>　　除非另行指定：</p>
<ul>
<li>若函数合并指定的操作的<a href="Features/NPL.zh-CN.html#%E6%8E%A5%E5%8F%A3%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">约束</a>或要求<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF%E6%A3%80%E6%9F%A5">检查</a>的条件不被满足，<a href="Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF">引起错误</a>。</li>
<li>引起错误时<a href="Features/NPL.zh-CN.html#npla1-%E5%BC%82%E5%B8%B8">抛出异常</a>。</li>
</ul>
<p>　　求值时引起的错误使求值中断，<a href="Features/NPL.zh-CN.html#%E4%BD%9C%E7%94%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99">可引起副作用</a>，这样的副作用总是<a href="Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">后序</a>于已被求值的表达式中引起的副作用。</p>
<p>　　被错误处理和检查的函数不<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>参数或者函数调用外创建的对象。</p>
<h3 id="非常规函数"><a class="header" href="#非常规函数">非常规函数</a></h3>
<p>　　<a href="Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B">续延</a>是默认不符合<a href="Features/NPL.zh-CN.html#%E5%B8%B8%E8%A7%84%E5%87%BD%E6%95%B0%E7%BA%A6%E5%AE%9A">常规函数约定</a>的例外。</p>
<p>　　非常规函数归类为对象而非<a href="Features/NPL.zh-CN.html#%E5%BA%93%E6%8E%A5%E5%8F%A3%E5%AE%9E%E4%BD%93">操作</a>，但调用时<a href="Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">错误处理</a>同常规函数。</p>
<p><strong>注释</strong></p>
<p>　　类似 [R<sup>n</sup>RK] 而和 [R<sup>n</sup>RS] 不同，作为一等对象的续延和续延的实际参数是否求值无关，因此不是合并子，且默认<a href="Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值算法</a>不支持续延作为函数合并被求值；但续延可通过特定的操作转换为应用子。</p>
<h1 id="附录"><a class="header" href="#附录">附录</a></h1>
<h2 id="进一步阅读-1"><a class="header" href="#进一步阅读-1">进一步阅读</a></h2>
<p>　　关于 NPL 语言<a href="Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0">派生实现</a>的具体实现，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h2 id="kernel-实现"><a class="header" href="#kernel-实现">Kernel 实现</a></h2>
<p>　　NPL 文法是 S-表达式语法和 Kernel 兼容语义的简化，某些 NPLA1 程序可以原封不动地作为 Kernel 程序运行。因为参考文献可用性以及相似性几乎独一无二，建议深入使用前参照 Kernel 相关的文档并实际使用，以和 NPL 进行比较（当前 NPL 开发文档也引用包括 [R<sup>n</sup>RK] 在内的一些规格说明）。现有较完整可用的一个 Kernel 实现是 <a href="http://klisp.org/">Klisp</a> 。</p>
<h2 id="计划支持特性"><a class="header" href="#计划支持特性">计划支持特性</a></h2>
<p>　　在 Kernel 中已存在但当前 NPLA1 未支持，而计划在未来添加的特性：</p>
<ul>
<li>一等续延(first-class continuation)
<ul>
<li><a href="http://okmij.org/ftp/continuations/against-callcc.html">基于一些显著的理论和实现可用性的理由</a>，需要考察有界续延(delimited continuation) （如 <code>shift</code>/<code>reset</code> ）而不是传统的 <code>call/cc</code> 的支持。</li>
<li>和 Klisp 的异步实现方式类似但不同，NPLA1 核心已使用一种同 <a href="http://www.ccs.neu.edu/home/dvanhorn/pubs/vanhorn-might-icfp10.pdf">CESK-style 的抽象机</a>的异步风格独立重新实现（<a href="http://www.brics.dk/RS/05/16/BRICS-RS-05-16.pdf">原理参考</a>），并兼容混合原有实现。并且状态支持已提供基本操作，但仍待更多测试。</li>
</ul>
</li>
<li><a href="http://klisp.org/docs/Promises.html#Promises">Promises</a>
<ul>
<li>虽然 NPLA1 之前有部分原生实现，但计划改用基于封装类型派生。</li>
</ul>
</li>
<li><a href="http://klisp.org/docs/Keyed-Variables.html#Keyed-Variables">Keyed Variables</a>
<ul>
<li>有效的 keyed dynamic varabile 实现可能依赖一等续延数据结构。</li>
<li>有效的 keyed static varabile 实现需要调整环境数据结构。</li>
</ul>
</li>
<li><a href="http://klisp.org/docs/Ports.html#Ports">Ports</a>
<ul>
<li>需要调查内存映射文件和其它系统支持。</li>
</ul>
</li>
<li><a href="http://klisp.org/docs/Libraries.html#Libraries">Libraries</a>
<ul>
<li>可能需要提供多种不同的接口。</li>
</ul>
</li>
</ul>
<p>　　已提供但考虑可能优化实现的特性：</p>
<ul>
<li><a href="http://klisp.org/docs/Encapsulations.html#Encapsulations">封装类型</a>
<ul>
<li>需要调查互操作相关的特性和持久化支持。</li>
</ul>
</li>
</ul>
<p>　　计划考虑提供其它设计替代选项的 Klisp 特性：</p>
<ul>
<li><a href="http://klisp.org/docs/Characters.html#Characters">Characters</a>
<ul>
<li>满足互操作要求的前提下，使用设计更合理的类型替代。</li>
</ul>
</li>
<li><a href="http://klisp.org/docs/Vectors.html#Vectors">Vectors</a>
<ul>
<li>使用更完善的用户自定义派生类型替代。</li>
</ul>
</li>
</ul>
<p>　　其它 NPL 计划实现特性：</p>
<ul>
<li>模块化框架</li>
<li>支持类型系统的子语言
<ul>
<li>类似 <a href="https://docs.racket-lang.org/ts-reference/index.html">Typed Racket</a> 。</li>
</ul>
</li>
<li>测试框架</li>
<li>基于 <code>$let-safe</code> 的静态环境操作替换优化</li>
<li>用于编译的中间代码格式和二进制代码生成框架
<ul>
<li>类似 <a href="https://www.scheme.com/">Chez Scheme</a> 对 <a href="http://nanopass.org/">Nanopass</a> 的使用。</li>
</ul>
</li>
<li><a href="https://en.wikipedia.org/wiki/Metacompilation">元编译(metacompilation)(en-US)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="概述-2"><a class="header" href="#概述-2">概述</a></h1>
<p>　　Sysroot 是具有特定逻辑布局根目录兼容的目录，一般在文件系统中实现。</p>
<p>　　Sysroot 主要用于本机程序的开发环境构建和部署，以后也可能用于交叉构建(cross building) 。</p>
<p>　　在利用 Sysroot 开发之前有必要了解开发注意事项：</p>
<ul>
<li><a href="Build.zh-CN.html">构建</a></li>
<li><a href="Prerequisitions.zh-CN.html">先决条件</a></li>
</ul>
<p>　　Sysroot 使用的文件系统路径满足<a href="Run.zh-CN.html">运行</a>环境对外部文件的路径的约定。</p>
<p>　　当前 Sysroot 仅支持 MinGW 和 Linux 环境。</p>
<p>　　关于本文档讨论以外的脚本的其它行为，参见<a href="Tools/Scripts.zh-CN.html">脚本</a>的有关说明。</p>
<h1 id="布局"><a class="header" href="#布局">布局</a></h1>
<p>　　在满足前述要求的前提下，Sysroot 部署实例使用的文件系统布局原则上和<a href="https://zh.wikipedia.org/zh-cn/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86">一般类 UNIX 系统使用的布局</a>同构，具体子目录布局如下：</p>
<ul>
<li><code>.shbuild</code> ：使用 <a href="Tools/SHBuild.zh-CN.html">SHBuild</a> 构建时的临时目录（可以在部署后手动删除）。</li>
<li><a href="Tools/Scripts.zh-CN.html">系统前缀字符串</a>指定的作为<a href="Tools/Scripts.zh-CN.html">安装路径前缀</a>的最后一个路径组件的目录文件名（如 <code>usr</code> ）：被部署的用户空间目录，其中的内容使用 <a href="http://www.tldp.org/LDP/Linux-Filesystem-Hierarchy/html/usr.html">Linux</a> 等现代 UNIX 变体类似的约定：
<ul>
<li><code>bin</code> ：二进制文件。</li>
<li><code>include</code> ：头文件。</li>
<li><code>lib</code> ：库文件。</li>
<li><code>share</code> ：共享的数据文件。
<ul>
<li><code>share/NPLA1</code> ：NPLA1 脚本部署位置。</li>
</ul>
</li>
<li><code>var</code> ：程序运行时可修改的数据。</li>
</ul>
</li>
</ul>
<p>　　其中，除 <code>var</code> 外，这些目录中的内容在安装或维护部署情形外通常应保持只读。</p>
<p>　　对 MSYS2 支持的宿主和目标平台，系统前缀字符串指定的路径和 MSYS2 构建系统的 <code>/etc/msystem</code> 脚本指定的 <code>MSYSTEM_PREFIX</code> 的值一致。</p>
<ul>
<li>对 MinGW32 和 MinGW64 ，这也对应 <a href="https://www.msys2.org/wiki/MSYS2-introduction/#subsystems">MSYS2 支持的子系统路径</a>。</li>
<li>MSYS2 可能支持其它平台的组合，可能直接可用，但并不保证每个配置都提供支持和被测试。详见<a href="Prerequisitions.zh-CN.html">先决条件</a>中关于平台的描述。</li>
</ul>
<p>　　上述 <code>bin</code> 目录可以加入<a href="Run.zh-CN.html">环境变量 <code>PATH</code></a> 中以便其中的程序被命令行执行。当前若使用 <a href="YDE.zh-CN.html">YDE</a> 构建脚本，这是必要的。</p>
<p>　　依赖 Sysroot 的程序可预期以上布局符合约定，且功能允许时可访问这些子目录或其它文件，而不被要求能在不符合预期的环境下正常运行。这些程序可能根据上述子目录中的内容判断需要的不同操作。安装或者维护 Sysroot 布局的程序提供附加的保证，不依赖全部或者部分路径符合预期，而在必要时可创建文件使布局满足这些预期。具体的操作可在不同程序的功能描述中明确。</p>
<p>　　没有在此约定的 Sysroot 中的子目录和其它文件路径为未来的版本保留：这些路径不被当前版本使用，但可能被之后的版本使用。依赖 Sysroot 的程序和用户应注意避免占用保留路径引起变更版本时引起的兼容问题。</p>
<p><strong>注意</strong> Sysroot 实例的布局<em>不是</em><a href="Features.zh-CN.html">版本库文件布局</a>。但是，关于部署文件时有关被部署的文件的要求，参见版本库文件布局中的相关约定。</p>
<h1 id="安装脚本"><a class="header" href="#安装脚本">安装脚本</a></h1>
<p>　　YSLib 项目提供生成可打包的 Sysroot 的安装脚本，位于 <code>Tools/Scripts/install-sysroot.sh</code> 。输出的 Sysroot 的默认位置为版本库根目录下的 <code>sysroot</code> 目录。安装 Sysroot 时构建和部署多个项目，详见以下各节。</p>
<h2 id="基本安装"><a class="header" href="#基本安装">基本安装</a></h2>
<p>　　使用 <a href="Tools/SHBuild.zh-CN.html">SHBuild</a> 构建和部署运行环境，包括库和工具。</p>
<p><strong>建议阅读以下关于选项以及<a href="Tools/Scripts.zh-CN.html">脚本</a>说明后再运行命令。</strong></p>
<p>　　可进入 <code>bash</code> 运行以下 GNU bash 脚本：</p>
<pre><code>Tools/install-sysroot.sh
</code></pre>
<p>　　直接在默认输出位置构建和部署基础环境。</p>
<p><strong>注意</strong> 当前构建脚本默认使用 <code>uname</code> 判断构建系统的体系结构。对 MSYS2 等环境，结果为基本系统的体系结构而不一定和作为构建目标的宿主系统相同。如使用 64 位基本系统构建 32 位目标，需确保环境变量 <code>MSYSTEM</code> 设置为 <code>MINGW32</code>（在启动 MSYS2 提供的 shell 入口时应正确设置，但直接调用 <code>bash</code> 并不保证），或使用以下命令代替：</p>
<pre><code>SHBuild_Host_Arch=i686 Tools/install-sysroot.sh
</code></pre>
<p>　　此处<a href="Prerequisitions.zh-CN.html">自动环境检测</a>的机制同 shell 脚本 <code>Tools/Scripts/SHBuild-common.sh</code> 中的函数 <code>SHBuild_PrepareBuild</code> ，详见<a href="Tools/Scripts.zh-CN.html">脚本</a>的说明。</p>
<h2 id="构建和部署"><a class="header" href="#构建和部署">构建和部署</a></h2>
<p>　　构建过程包括 <code>SHBuild</code> 可用的<a href="Tools/SHBuild.zh-CN.html">多阶段构建</a>。</p>
<p>　　构建时在 Sysroot 输出目录种保存中间输出。当前不清理这些中间输出。</p>
<p>　　通过脚本选项，在 <a href="Tools/SHBuild.zh-CN.html">stage 2 SHBuild</a> 需要的库时，也可生成其它的 YSLib 库（静态库和调试版本的库）。</p>
<p>　　YSLib 库和依赖的外部的第三方库的二进制文件和对应的头文件在构建后被部署到 Sysroot ，并在之后用于构建 stage 2 SHBuild 。</p>
<p>　　完成构建 stage 2 SHBuild 后，脚本部署 stage 2 SHBuild 和脚本（参见以下节）到 Sysroot 。</p>
<h3 id="脚本部署"><a class="header" href="#脚本部署">脚本部署</a></h3>
<p>　　在 stage 2 SHBuild 构建后，部署 SHBuild 同时安装（复制）版本库中的以下位置的 脚本文件（无视路径前缀）到 Sysroot 的对应安装路径：</p>
<ul>
<li>NPLA1 脚本安装到 <code>share/NPLA1</code> ：
<ul>
<li><code>Tools/Script/SHBuild-BuildApp.txt</code></li>
<li><code>Tools/Script/SHBuild-YSLib-common.txt</code></li>
</ul>
</li>
<li>Shell 脚本安装到 <code>bin</code> ：
<ul>
<li><code>Tools/Script/SHBuild-common.sh</code></li>
<li><code>Tools/Script/SHBuild-common-options.sh</code></li>
<li><code>Tools/Script/SHBuild-common-toolchain.sh</code></li>
<li><code>Tools/Script/SHBuild-BuildApp.sh</code></li>
<li><code>Tools/Script/SHBuild-BuildPkg.sh</code></li>
</ul>
</li>
</ul>
<h3 id="可选工具"><a class="header" href="#可选工具">可选工具</a></h3>
<p>　　通过脚本选项，在部署 stage 2 SHBuild 后，也可安装 <code>Tools</code> 下的其它工具：</p>
<ul>
<li><a href="Tools/RevisionPatcher.zh-CN.html">RevisionPatcher</a></li>
<li><a href="Tools/SXML2XML.zh-CN.html">SXML2XML</a></li>
<li><a href="Tools/ProjectGenerator.zh-CN.html">ProjectGenerator</a></li>
</ul>
<h2 id="构建中间文件"><a class="header" href="#构建中间文件">构建中间文件</a></h2>
<p>　　当前工具不对构建的中间文件显式管理。若需清理，可以手动删除对应的文件或所在的生成目录。一般生成的文件和源代码的目录结构对应。</p>
<p>　　若需要预编译头文件在后续重复构建时的性能提升，或者意图重新生成这些文件，可以手动清理这些文件。预编译头文件一般在对应项目生成其它的文件的顶层目录相同；可手动搜索构建目录中所有 <code>.gch</code> 文件并删除后再运行构建脚本。默认生成预编译头文件前硬链接被预编译的头文件并在同一个目录中生成，包括以下位置：</p>
<ul>
<li>存储库中的 <code>Tools/SHBuild</code>（即源代码目录），用于 <a href="Tools/SHBuild.zh-CN.html">stage 1 SHBuild</a> 构建。</li>
<li>安装 stage 1 SHBuild 后默认在<a href="Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">构建中间输出目录 <code>$SHBuild_BuildDir</code></a> 下的 <code>.shbuild</code> 等作为 SHbuild 输出目录的子目录。</li>
</ul>
<h2 id="构建时的诊断"><a class="header" href="#构建时的诊断">构建时的诊断</a></h2>
<p>　　一些构建时的诊断可被安全忽略：</p>
<ul>
<li><a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-buildsh">预编译头文件文件不匹配引起的编译器警告</a>。</li>
<li>在输出标记为 <code>(ignored)</code> 被忽略的链接器错误。
<ul>
<li>这些错误典型地出现在 <a href="https://bugs.launchpad.net/gcc-arm-embedded/+bug/1853451">MinGW 平台启用 LTO 时</a>。
<ul>
<li>这应不会影响生成的二进制文件。</li>
<li>默认以 release 配置构建时，启用 LTO 而可能引起错误。</li>
<li>设置启用 LTO 编译器和链接器选项时，<a href="Tools/SHBuild.zh-CN.html#%E5%BC%95%E5%AF%BC">引导 stage 1 SHBuild</a> 最后的链接器可能引起错误。</li>
<li>可<a href="https://github.com/official-stockfish/Stockfish/pull/2978">在链接器选项使用 <code>-save-temps</code></a>变通。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　若不需要使用预编译头文件或仅需要避免警告，可参考<a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-buildsh">脚本的说明设置变量跳过预编译头文件或添加忽略警告的选项</a>。</p>
<h1 id="sysroot-开发指令"><a class="header" href="#sysroot-开发指令">Sysroot 开发指令</a></h1>
<p>　　使用 Sysroot 开发，首先需安装 Sysroot 环境，参见以上<a href="Sysroot.zh-CN.html#%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC">安装脚本的说明</a>。</p>
<h2 id="应用程序构建脚本"><a class="header" href="#应用程序构建脚本">应用程序构建脚本</a></h2>
<p>　　YSLib 应用程序可使用 SHBuild 构建。为简化构建流程，使用应用程序构建脚本包装对 SHBuild 的调用。</p>
<p>　　应用程序构建脚本不限制实现使用的语言，但在版本库中提供的脚本应符合<a href="Tools/Scripts.zh-CN.html">公共的约定</a>；此外，具体脚本可能需要指定适当的 <code>PATH</code> 以确保外部的工具可被调用。</p>
<p>　　典型地，应用程序构建脚本是 shell 脚本，可依赖 Sysroot 环境已构建的 Sysroot 环境，并调用 NPLA1 脚本。</p>
<p>　　<a href="ProjectDependencies.zh-CN.html">YSTest</a> 支持使用脚本 <code>/YSTest/SHBuild-YSTest.sh</code> 构建，可作为例子参考。和其它在安装脚本部署的 stage 2 应用不同，当前默认情况下使用版本库中的 <code>build</code> 目录下的平台目录存放生成的文件（中间文件和生成的可执行程序示例）。</p>
<h2 id="部署"><a class="header" href="#部署">部署</a></h2>
<p>　　除安装脚本外，当前不提供直接部署程序。</p>
<p>　　参照<a href="Run.zh-CN.html">运行</a>确定二进制依赖项位置和调整运行时的配置。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述-3"><a class="header" href="#概述-3">概述</a></h1>
<p>　　YDE 是 YSLib Desktop Environment 的简称，预期作为一个基于 YFramework 的桌面环境。</p>
<p>　　当前是一个 YSLib 的顶级子项目，构建需要 <a href="Sysroot.zh-CN.html">Sysroot</a> 支持。</p>
<p>　　YDE 包含一系列的<em>包(package)</em> 在单独的目录中作为次级子项目。</p>
<h1 id="构建-2"><a class="header" href="#构建-2">构建</a></h1>
<p>　　当前只提供 <code>build-all.sh</code> 使用 <a href="Tools/Scripts.zh-CN.html">SHBuild-BuildApp.txt</a> 构建所有包。</p>
<h2 id="准备-5"><a class="header" href="#准备-5">准备</a></h2>
<ul>
<li>参见<a href="Development.zh-CN.html">开发说明</a></li>
<li>参见 <a href="Sysroot.zh-CN.html">Sysroot</a> 和<a href="GettingStarted.zh-CN.html">入门</a> 的说明配置环境，确保 Sysroot 部署的 <code>usr/bin</code> 目录在 <code>PATH</code> 中</li>
<li>运行 <code>build-all.sh</code> ，可以提供参数</li>
</ul>
<p>　　构建的结果参见 <code>SHBuild-BuildApp.txt</code> 的文档。</p>
<h1 id="包列表"><a class="header" href="#包列表">包列表</a></h1>
<ul>
<li>ImageBrowser 图像浏览工具</li>
<li>Clock 模拟时钟</li>
</ul>
<h1 id="运行-1"><a class="header" href="#运行-1">运行</a></h1>
<p>　　参见<a href="Run.zh-CN.html">运行</a>了解所有基于 YFramework 的程序的说明。</p>
<p><strong>使用配置 <code>yconf.txt</code> ，详见<a href="Run.zh-CN.html">关于运行的说明</a>。</strong></p>
<h2 id="imagebrowser"><a class="header" href="#imagebrowser">ImageBrowser</a></h2>
<p>　　运行程序会打开命令行第一个参数作为路径的文件。支持从资源管理器拖拽到程序。</p>
<p>　　支持 YFramework 支持的图像格式：</p>
<ul>
<li>BMP</li>
<li>GIF</li>
<li>PNG</li>
<li>非渐进 JPEG</li>
</ul>
<p>　　支持滚轮缩放。</p>
<p>　　单击右上角退出按钮退出程序。</p>
<p>　　右键单击界面其它部分弹出上下文菜单。有以下菜单项：</p>
<ul>
<li>退出：关闭窗口，退出程序。</li>
<li>查看原始大小：当显示的图像不是原始大小时，缩放图像到原始大小。</li>
<li>翻转：旋转 180° 。</li>
<li>顺时针旋转：顺时针旋转 90° 。</li>
<li>逆时针旋转：逆时针旋转 90° 。</li>
<li>复制：复制当前显示的（可能经过缩放的）图像内容到剪贴板。</li>
</ul>
<p>　　旋转时保持图像中心位置不变。</p>
<p>　　中键单击界面其它部分查看原始大小。</p>
<p>　　支持键盘快捷键：</p>
<ul>
<li><code>Ctrl+C</code> 复制</li>
</ul>
<h2 id="clock"><a class="header" href="#clock">Clock</a></h2>
<p>　　右键单击界面退出程序。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="概要-2"><a class="header" href="#概要-2">概要</a></h1>
<p>　　本文档记录发布工程(release engineering) 相关的规则、历史记录和相关计划。</p>
<p>　　发布策略控制版本更新。</p>
<p>　　关于版本(revison) 的详细规则参见 YSLib 项目文档 <code>doc/ProjectRules.txt</code> 。</p>
<h1 id="分支branching"><a class="header" href="#分支branching">分支(Branching)</a></h1>
<p>　　一个项目可有多个分支(branch) ，包括至少一个保持工作进行的活动(active) 分支。</p>
<p>　　发布时使用活动分支，以项目版本库的分支为准。</p>
<p>　　当前只有主分支(master branch) 。</p>
<h1 id="标识identification"><a class="header" href="#标识identification">标识(Identification)</a></h1>
<p>　　阶段(phase) 标识连续的版本，描述一个分支在一个时期内版本的发布状态。</p>
<p>　　当前位于 Alpha 非正式发布阶段。</p>
<h2 id="迭代阶段iteration-phase"><a class="header" href="#迭代阶段iteration-phase">迭代阶段(Iteration phase)</a></h2>
<p>　　迭代阶段是工程意义上的版本标识，适用于所有在开发、测试和维护生命周期中的分支，包括仅包含开发和测试版本的场合。</p>
<p>　　PreAlpha 阶段不对 API（应用程序编程接口）稳定性进行任何保证。</p>
<p>　　Alpha 阶段尽量保证公开 API 的非向后兼容的修改最小化，但仍然不保证兼容。</p>
<p>　　Beta 阶段保证主要项目的 API 向后兼容性。非兼容的改动不再在当前迭代周期内引入，否则视为缺陷。</p>
<p>　　Beta 阶段开始提供面向非开发者的部署方案。</p>
<p>　　允许在每个迭代周期中按以上顺序补充新的阶段。</p>
<p>　　关于项目内的提交版本(revision) ，详见项目文档 <code>doc/Dependencies.txt</code> 的约定。</p>
<h2 id="发布阶段release-phase"><a class="header" href="#发布阶段release-phase">发布阶段(Release phase)</a></h2>
<p>　　发布阶段使用的版本标识是被用户用于区分产品特性的标识。</p>
<p>　　正式标记形式为以 <code>V</code> 起始，跟随符合<a href="http://semver.org/lang/zh-CN/">语义化版本</a>规范<strong>语法</strong>的版本号。作为扩展，表示分支的版本号中的 <code>.y</code> 或 <code>.y.z</code> 以及表示具体版本的非可选部分的后缀 <code>.0</code> 或 <code>.0.0</code> 可省略。对省略后缀 <code>.0</code> 或 <code>.0.0</code> 的具体版本号，视为和不省略这些后缀的版本具有等价的含义。</p>
<p>　　版本号同时符合语义化版本规范的<strong>语义</strong>：在语言实现保持兼容的前提下，相同<em>主版本(major version)</em> 的发布应保持公开的命令行调用接口、API 和 ABI 向后兼容。主版本变化可引入不和先前迭代周期中保证兼容的改动。</p>
<p>　　由公开的<a href="Home.zh-CN.html">兼容性约定</a>，除非另行指定，作为公开的命令行接口的工具在相邻的<em>次版本(minor version)</em> 之间向后兼容。一般地，若工具实现的公开功能被继续支持，命令行工具不在提供向后兼容功能的替代工具前被移除。</p>
<p><strong>注意</strong> 非标记为发布版本的开发版本不需要保证以上要求。</p>
<p>　　不兼容未来计划的改动的特性可标记为<em>弃用(deprecated)</em> 以表示可能在之后不继续支持。</p>
<h3 id="非正式版"><a class="header" href="#非正式版">非正式版</a></h3>
<p>　　非正式版的版本号小于 1.0.0 ，不保证任何 ABI（应用程序二进制接口）兼容性。</p>
<p>　　所有非正式版共享一组迭代阶段。</p>
<h3 id="正式版"><a class="header" href="#正式版">正式版</a></h3>
<p>　　正式版的初始版本号为 1.0.0 。</p>
<p>　　正式版提供版本检查的 API 。</p>
<p>　　正式版对应的开发和测试版本使用以上除 PreAlpha 以外的阶段，具有上述相同的要求。</p>
<h1 id="支持策略"><a class="header" href="#支持策略">支持策略</a></h1>
<p>　　支持策略基于发布规则。</p>
<p>　　当前仅对最新的非正式版及版本库活动开发分支上的最新提交版本(tip) 提供公开支持。</p>
<p>　　正式版适用的规则另行具体指定。</p>
<h1 id="持续集成continuous-integration"><a class="header" href="#持续集成continuous-integration">持续集成(Continuous integration)</a></h1>
<h2 id="构建-3"><a class="header" href="#构建-3">构建</a></h2>
<p>　　提供有限的构建自动化(build automation) 支持。</p>
<p>　　关于使用的构建工具，参见<a href="Prerequisitions.zh-CN.html">先决条件</a>，并参见<a href="Build.zh-CN.html">构建</a>过程。</p>
<p>　　在宿主环境下使用项目内自行开发的工具支持，参见 <a href="Tools/SHBuild.zh-CN.html">SHBuild</a> 和 <a href="Sysroot.zh-CN.html">Sysroot</a> 。</p>
<h1 id="里程碑和路线图"><a class="header" href="#里程碑和路线图">里程碑和路线图</a></h1>
<p>　　本节略述发布版本的参照目标，包括重要的特性实现。</p>
<p>　　关于包含较详细特性变更说明的发布版本的发布注记(release note) ，参见版本库中的文档 <code>doc/Dependencies.txt</code> ；关于提交版本的详细变更记录(change log) ，参见项目文档 <code>doc/ChangeLog.*.txt</code> 。</p>
<h2 id="已实现的重要特性"><a class="header" href="#已实现的重要特性">已实现的重要特性</a></h2>
<h3 id="prealpha"><a class="header" href="#prealpha">PreAlpha</a></h3>
<p>　　PreAlpha 阶段实现平台中立的基础设施和 GUI 。每个发布版本包含重要的新增特性。</p>
<ul>
<li><strong>PreAlpha 1</strong> 实现可在 DS 和 DeSmuME 运行的 GUI 程序。</li>
<li><strong>PreAlpha 2</strong> 完善 GUI 部件并提供框架。</li>
<li><strong>PreAlpha 3</strong> 支持 MinGW32 移植和动态库：平台中立设计的验证实现。</li>
<li><strong>PreAlpha 4</strong> 支持基于 <a href="Features/NPL.zh-CN.html">NPL</a> 的配置设置、构建工具 <a href="Tools/SHBuild.zh-CN.html">SHBuild</a> 和运行时加载的 GUI 。</li>
<li><strong>PreAlpha 5</strong> 支持桌面程序特性：界面风格、动画及分离构建等。</li>
</ul>
<h3 id="alpha"><a class="header" href="#alpha">Alpha</a></h3>
<p>　　Alpha 阶段仍包含若干重要特性改进，但发布版本不再以添加单一特性为重点，而侧重提升环境的整体可用性。</p>
<ul>
<li><strong>V0.6</strong> 完善项目结构并提升宿主环境下的开发可用性支持。
<ul>
<li>添加整体测试。</li>
<li>添加桌面环境 YDE 。
<ul>
<li>当前主要用于示例。</li>
</ul>
</li>
<li>添加和完善若干专用于支持开发的工具。
<ul>
<li>添加 <a href="Tools/ProjectGenerator.zh-CN.html">ProjectGenerator</a> ，支持生成 Code::Blocks 项目。</li>
<li>支持宿主环境下的 SHBuild 自举 <a href="Sysroot.zh-CN.html">Sysroot</a> 部署。</li>
</ul>
</li>
</ul>
</li>
<li><strong>V0.7</strong> 完善各个平台的实现行为和互操作接口。
<ul>
<li>替换 DS 的文件系统实现。</li>
<li>支持宿主环境下的 YSLib 多个映像实例共存。
<ul>
<li>每个映像实例包括动态库和配置文件等<a href="Run.zh-CN.html">运行时支持环境</a>。</li>
<li>映像实例可以是 Sysroot ，也可以手动部署。</li>
<li>不要求映像实例具有相同的版本。</li>
<li>当前对环境变量透明；必要时，仍需手动指定 <a href="Run.zh-CN.html"><code>PATH</code></a> 。</li>
<li>当前全面支持仅限 MinGW32 ：配置位置不再依赖当前工作目录。</li>
</ul>
</li>
<li>按独立的语言解释实现添加 NPL 接口。</li>
</ul>
</li>
<li><strong>V0.8</strong> 完善内部互操作性和部署。
<ul>
<li>改进运行时对象操作 API 。</li>
<li>扩充 NPLA/NPLA1 。
<ul>
<li>设计和实现新的求值规则。</li>
<li>提供较完整的 REPL 支持。</li>
</ul>
</li>
<li>在 SHBuild 中使用 NPLA1 代替系统默认的 shell 环境，用于实现部分 Sysroot 部署。</li>
</ul>
</li>
<li><strong>V0.9</strong> 增强 NPL 和部署环境。
<ul>
<li>继续完善 NPL 接口并提升实现性能。
<ul>
<li>默认使用异步调用实现，避免嵌套调用过深时的未定义行为，并支持 PTC 。</li>
<li>节点和环境等数据结构支持分配器。</li>
<li>显著优化分析器和求值的性能。</li>
<li>添加 NPLA1 源代码信息支持，并增强错误信息。</li>
<li>添加更多的标准库操作。</li>
</ul>
</li>
<li>增强配置管理。
<ul>
<li>支持后备路径。</li>
<li>支持检测类 FHS 的文件系统布局。</li>
</ul>
</li>
<li>Sysroot 安装构建脚本。</li>
</ul>
</li>
</ul>
<h2 id="重点计划目标"><a class="header" href="#重点计划目标">重点计划目标</a></h2>
<ul>
<li><strong>V0.10</strong> 计划进一步增强 NPL 和构建环境。
<ul>
<li>继续完善 NPL 接口并提升实现性能。</li>
<li>支持多个运行时实例交互。</li>
<li>基于 Sysroot 的多平台自动化部署方案。</li>
</ul>
</li>
</ul>
<h1 id="待定事项todos"><a class="header" href="#待定事项todos">待定事项(TODOs)</a></h1>
<p>　　版本发布的待定事项参照上述目标。</p>
<p>　　<a href="Home.zh-CN.html">贡献到问题跟踪系统</a>的内容可能包含特性请求和没有立刻解决的缺陷记录，其实现会被考虑列入待定事项。</p>
<p>　　完整列表当前仅被内部参照，没有公开。</p>
<h1 id="版本发布记录"><a class="header" href="#版本发布记录">版本发布记录</a></h1>
<p>　　发布页可能包括后续开发信息。</p>
<p>　　关于被发布的资源，参见<a href="Archives.zh-CN.html">归档</a> 。</p>
<h2 id="prealpha-发布页"><a class="header" href="#prealpha-发布页">PreAlpha 发布页</a></h2>
<h3 id="prealpha-1"><a class="header" href="#prealpha-1">PreAlpha 1</a></h3>
<p>http://tieba.baidu.com/p/767225536 。</p>
<p>http://www.yayabo.cn/forum.php?mod=viewthread&amp;tid=3878 。</p>
<h3 id="prealpha-2"><a class="header" href="#prealpha-2">PreAlpha 2</a></h3>
<p>http://tieba.baidu.com/p/1043526998 。</p>
<p>http://www.yayabo.cn/forum.php?mod=viewthread&amp;tid=17543 。</p>
<h3 id="prealpha-3"><a class="header" href="#prealpha-3">PreAlpha 3</a></h3>
<p>http://tieba.baidu.com/p/1511876559 。</p>
<p>http://www.yayabo.cn/forum.php?mod=viewthread&amp;tid=22988 。</p>
<h3 id="prealpha-4"><a class="header" href="#prealpha-4">PreAlpha 4</a></h3>
<p>http://tieba.baidu.com/p/2288320823 。</p>
<p>http://www.yayabo.cn/forum.php?mod=viewthread&amp;tid=25961 。</p>
<h3 id="prealpha-5"><a class="header" href="#prealpha-5">PreAlpha 5</a></h3>
<p>http://tieba.baidu.com/p/3069607390 。</p>
<p>http://www.yayabo.cn/forum.php?mod=viewthread&amp;tid=26450 。</p>
<h2 id="alpha-发布页"><a class="header" href="#alpha-发布页">Alpha 发布页</a></h2>
<h3 id="06"><a class="header" href="#06">0.6</a></h3>
<p>http://tieba.baidu.com/p/3747376832 。</p>
<p>http://www.yayabo.cn/forum.php?mod=viewthread&amp;tid=26718 。</p>
<h3 id="07"><a class="header" href="#07">0.7</a></h3>
<p>http://tieba.baidu.com/p/4701412006 。</p>
<h1 id="版本日程记录"><a class="header" href="#版本日程记录">版本日程记录</a></h1>
<p>　　记录的时间来自存档和提交记录，使用时区 UTC+8 。</p>
<p>　　发布版本的计划时间为截止时间。评估计划完成情况时，实际时间应早于此时间。</p>
<h2 id="prealpha-1"><a class="header" href="#prealpha-1">PreAlpha</a></h2>
<p>　　早期开发版本计划未定。发布版本为每 100 个开发更新版本中形成。</p>
<p>　　计划（追溯）及里程碑版本：</p>
<ul>
<li><strong>PreAlpha 0</strong> 2009-02 W3
<ul>
<li>PALibTest: 2009-10-10</li>
</ul>
</li>
<li><strong>PreAlpha 1</strong> 2010-03 W1
<ul>
<li>YSTest b98: 2010-05-05</li>
</ul>
</li>
<li>使用 <a href="https://www.mercurial-scm.org/">Mercurial</a>
<ul>
<li>YSLib b132 2010-07-13</li>
</ul>
</li>
</ul>
<p>　　使用版本控制，开发更新版本对应提交版本。提交版本仅主分支版本。更新频率逐步控制为 8 提交版本/月，其中月以自然月计，折合 4 周工作量。</p>
<p>　　计划及实际发布版本：</p>
<ul>
<li><strong>PreAlpha 2</strong> 2011-03 W4
<ul>
<li>YSLib b200: 2011-04-11</li>
</ul>
</li>
<li><strong>PreAlpha 3</strong> 2012-04 W2
<ul>
<li>YSLib b300: 2012-04-12</li>
</ul>
</li>
<li><strong>PreAlpha 4</strong> 2013-04 W4
<ul>
<li>YSLib b400: 2013-04-24</li>
</ul>
</li>
<li><strong>PreAlpha 5</strong> 2014-05 W2
<ul>
<li>YSLib b500: 2014-05-30</li>
</ul>
</li>
</ul>
<h2 id="alpha-1"><a class="header" href="#alpha-1">Alpha</a></h2>
<p>　　保持提交和发布版本更新频率不变。</p>
<p>　　计划及实际发布版本：</p>
<ul>
<li><strong>V0.6</strong> 2015-05 W4
<ul>
<li>YSLib b600: 2015-05-26</li>
</ul>
</li>
<li><strong>V0.7</strong> 2016-06 W2
<ul>
<li>YSLib b700: 2016-06-11</li>
</ul>
</li>
</ul>
<p>　　为便于特性整合和进度统计，2017 Q2 计划提交和发布版本基准周期增加 1 倍。</p>
<p>　　新的发布计划日程安排于 2017-07-01 启用。追溯 Alpha 发布历史并调整截止日程：</p>
<ul>
<li><strong>V0.6</strong> 2016-06 W2</li>
<li><strong>V0.7</strong> 2018-07 W2</li>
</ul>
<p>　　使用以下日程同步计划过渡到新的截止日期：</p>
<ul>
<li>同步目标外推 4 次，并对每个发布版本递增添加 4 周发布准备，至 <strong>V0.11</strong> 2027-01 W2 。</li>
<li>计划使用在新的基准周期外的至多和原提交周期相同的额外缓冲时间和截止日程同步。
<ul>
<li>因此，提交版本周期至多为原周期的 3 倍；即更新频率控制为至少 8/3 提交版本/月 。</li>
</ul>
</li>
<li>同时，抽取 6 周用于 <strong>V0.8</strong> 发布准备。
<ul>
<li>原计划外推 <strong>V0.8</strong> 发布时间为 2017-06 W4 ，推迟后为 2017-08 W2 。</li>
<li>新计划外推 1 次 2018-08 W2 ，同步版本后相差 24 月，补充到后续发布版本中。</li>
</ul>
</li>
</ul>
<p>　　随之改订的计划及待定发布版本：</p>
<ul>
<li><strong>V0.8</strong> 2017-08 W2
<ul>
<li>YSLib b800: 2017-08-10</li>
</ul>
</li>
<li><strong>V0.9</strong> 2020-10 W2
<ul>
<li>YSLib b900: 2020-10-13</li>
</ul>
</li>
<li><strong>V0.10</strong> 2023-12 W2
<ul>
<li>YSLib b1000: TBD</li>
</ul>
</li>
<li><strong>V0.11</strong> 2027-01 W2
<ul>
<li>YSLib b1100: TBD</li>
</ul>
</li>
</ul>
<h2 id="beta"><a class="header" href="#beta">Beta</a></h2>
<p>　　待定。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概要-3"><a class="header" href="#概要-3">概要</a></h1>
<p>　　归档文件目前存放于以下位置：</p>
<ul>
<li><a href="http://pan.baidu.com">百度云网盘</a>：进入 <a href="http://pan.baidu.com/s/1mgjxaY0#list/path=%2FShared%2FYSLib">YSLib 主仓库</a>查看所有发布的文件，可转存或直接下载。
<ul>
<li>因为分享限制，地址可能需要更新。</li>
</ul>
</li>
<li><a href="https://osdn.net">OSDN</a>：进入 <a href="https://osdn.net/projects/yslib/releases/">YSLib 项目下载页</a>查看发布的文件。</li>
</ul>
<p><strong>注意</strong> 作为归档的压缩包文件一般统一使用 7z ，但不同的归档使用不同的压缩算法和选项，对系统资源要求不尽相同。作为极端情况，V0.6 后的 <code>doc</code> 下的压缩包使用具有 1.5GiB 字典的 PPMd 达到约 5% 的压缩比，这一般也要求解压缩时需<strong>预留 20 倍压缩包大小的空余空间，以及 1.5GiB 空余（物理）内存</strong>。</p>
<h1 id="命名规约"><a class="header" href="#命名规约">命名规约</a></h1>
<p>　　文件名使用 <code>[平台环境标识-]包名-版本[-配置]</code>.后缀 。“<code>[]</code>”中为可选项。特定平台的目录名可参照此规约。</p>
<p>　　对于二进制文件和库文件，<a href="Terminology.zh-CN.html">平台环境标识</a>使用目标三元组分类：<code>archc-OS-toolchain</code> ；不限定体系结构的使用 &quot;<code>any</code>&quot; 。</p>
<p>　　发布时若文件没有更新，则不另行更新版本。若某个包不存在预期的版本，尝试使用之前最近的版本代替。</p>
<h2 id="顶级目录结构"><a class="header" href="#顶级目录结构">顶级目录结构</a></h2>
<ul>
<li><code>src</code> 可用于直接构建的源代码（包括外部依赖项的二进制库文件）包</li>
<li><code>example</code> 示例代码</li>
<li><code>doc</code> 文档（打包的 Doxygen 文档）</li>
<li><code>any</code> 体系结构中立的文件（头文件和数据文件）</li>
<li><code>arm-ds-eabi</code> DS 平台文件</li>
<li><code>i686-w64-mingw32</code> Win32 平台文件</li>
<li><code>arm-linux-androideabi</code> Android ARM 平台文件</li>
<li><code>x86_64-linux-gnu</code> Linux x64 平台文件</li>
</ul>
<p><strong>注意</strong> 因为包含所有平台的库文件过大且文件重复，考虑到存储和传输开销，V0.9 起不提供 YSLib 整体的源代码包（位于 <code>src</code>）。请直接参照<a href="GettingSources.zh-CN.html">获取源代码</a>中的来源，同步版本库或下载源代码，再下载所需平台的外部依赖项的归档文件，并按<a href="Development.zh-CN.html">开发说明</a>存储到相应位置。Sysroot 归档中仍包含对应的外部依赖项。</p>
<h2 id="包概要"><a class="header" href="#包概要">包概要</a></h2>
<p>以下为各个具体体系结构目录下的包的概要（并不一定保证每个体系结构具有所有这些包）。</p>
<ul>
<li><code>External</code> 外部依赖项</li>
<li><code>Sysroot</code> 打包的 Sysroot 文件</li>
<li><code>YSTest</code> YSTest 二进制文件</li>
<li><code>YDE</code> 二进制文件</li>
</ul>
<p>　　内容详见以下二进制文件说明。</p>
<p>　　以下为 <code>any</code> 目录下的包的概要。</p>
<ul>
<li><code>yslib-data</code> YSLib 运行时依赖的数据文件，参见<a href="Run.zh-CN.html">运行说明</a></li>
<li><code>ybase-header</code> YBase 头文件</li>
<li><code>yframework-header</code> YFramework 头文件</li>
</ul>
<p>V0.6 起不单独提供头文件，可使用源代码包或 Sysroot 包代替。</p>
<p>　　此外，源代码包名以 <code>-src</code> 为后缀，在 <code>src</code> 目录下；而 <code>Doxygen-html</code> 是通过 Doxygen 生成的 HTML/XHTML 文档的包名，在 <code>doc</code> 目录下。</p>
<h1 id="二进制文件说明"><a class="header" href="#二进制文件说明">二进制文件说明</a></h1>
<p>　　<a href="Releases.zh-CN.html">Beta 阶段</a>前，二进制文件不用于对所有被支持的平台提供完整可用的环境。</p>
<p>　　除以下另行指定，V0.6(build 600) 起，仅第一类支持（支持等级详见 YSLib 项目文档 <code>doc/ProjectRules.txt</code> ）且具有 Sysroot 的平台配置提供完整的二进制文件，包括库和示例项目等。</p>
<h2 id="external"><a class="header" href="#external">External</a></h2>
<p>　　单独<a href="Build.zh-CN.html">构建</a>的<a href="Development.zh-CN.html">外部依赖项</a>，一般是二进制库文件。对所有支持的平台提供。</p>
<p>　　V0.6(build 600) 起<a href="Development.zh-CN.html">版本库中不再保持二进制文件</a>。源代码包 <code>src-*.7z</code> 中包括已经编译的外部依赖项。此外，各个平台目录下的 <code>External-*.7z</code> 单独对依赖项打包，可参照前文中的位置自行放置。</p>
<h2 id="sysroot"><a class="header" href="#sysroot"><a href="Sysroot.zh-CN.html">Sysroot</a></a></h2>
<p>　　b600 起提供在 release 配置下构建部署的 MinGW Sysroot ，包名为 <code>Sysroot</code> 。</p>
<p>　　因为归档文件限制，符号链接压缩为空文件。如需使用符号链接位置的库，可以手动恢复，流程参见<a href="Tools/Scripts.zh-CN.html">构建脚本</a>。</p>
<h2 id="ystest"><a class="header" href="#ystest">YSTest</a></h2>
<p>　　源代码中默认构建的<a href="Features.zh-CN.html">测试用示例项目</a>，按内容命名为 YReader 。</p>
<h2 id="yde"><a class="header" href="#yde"><a href="YDE.zh-CN.html">YDE</a></a></h2>
<p>　　b600 起提供 release 配置下在 Sysroot 上构建的 YDE 合集，包名为 <code>YDE</code> 。</p>
<p>　　其中的可执行文件依赖 YBase 和 YFramework 动态库。</p>
<h1 id="构建环境"><a class="header" href="#构建环境">构建环境</a></h1>
<p>　　<a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared">这里</a>提供了 YSLib 历史和当前版本使用的构建环境相关的归档，其中 YSLib 目录即上述发布仓库。</p>
<h2 id="基本环境和工具链"><a class="header" href="#基本环境和工具链">基本环境和工具链</a></h2>
<p>　　仅提供宿主环境操作系统为 Windows 的二进制文件。</p>
<h3 id="mingw32-目标和宿主环境"><a class="header" href="#mingw32-目标和宿主环境">MinGW32 目标和宿主环境</a></h3>
<ul>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2Fsf.net%2Fmingwbuilds">mingw-builds</a></li>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2Fsf.net%2Fmingw-w64%2Fmingw-builds">合并到 mingw-w64 发布的 mingw-builds</a></li>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2Fsf.net%2FMSYS2%2FBase">MSYS2</a></li>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2Fsf.net%2FMSYS2%2FREPOS%2FMINGW">MSYS2 MinGW 包</a></li>
</ul>
<h3 id="ds-1"><a class="header" href="#ds-1">DS</a></h3>
<ul>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2Fsf.net%2FdevkitPro">devkitPro</a></li>
</ul>
<h3 id="android-1"><a class="header" href="#android-1">Android</a></h3>
<ul>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2FProgram%2FAndroid%2Fwindows-x86_64">Android 独立工具链和 SDK 工具</a></li>
</ul>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<ul>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2Farchlinux.org">ArchLinux 包</a></li>
</ul>
<h2 id="文档工具"><a class="header" href="#文档工具">文档工具</a></h2>
<ul>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2Fdoxygen.nl">Doxygen</a>
<ul>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2Fgraphviz.org">GraphViz</a></li>
</ul>
</li>
</ul>
<h2 id="外部依赖项的源代码"><a class="header" href="#外部依赖项的源代码">外部依赖项的源代码</a></h2>
<ul>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2Fsf.net%2Ffreetype">FreeType2</a></li>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2Fsf.net%2Ffreeimage%2FSource%20Distribution">FreeImage</a>
<ul>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2Fsf.net%2Flibjpeg-turbo">LibJPEG-Turbo</a></li>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2Fsf.net%2Flibpng">LibPNG</a>
<ul>
<li><a href="https://pan.baidu.com/s/18CcFi4qGRwDMKkIt553tTQ#list/path=%2FShared%2Fsf.net%2Flibpng%2Fzlib">ZLib</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="shbuild"><a class="header" href="#shbuild">SHBuild</a></h1>
<p>　　位于 <code>Tools/SHBuild</code> ，是可以用来递归遍历目录编译链接本机程序和调用其它相关功能的命令行工具。当前仅支持 MinGW32/MinGW64 环境。其它平台详见以下章节。</p>
<p>　　直接（不带参数）运行 <code>SHBuild</code> 查询使用方法和选项等说明。</p>
<h2 id="构建-4"><a class="header" href="#构建-4">构建</a></h2>
<p>　　本节说明 SHBuild 的构建。关于使用 SHBuild 构建用户程序，参见前述概要和之后的章节。</p>
<p>　　除非另行指定，其它章节也适用于本节内构建的非最终阶段 SHBuild 。本章仅补充仅适用于这些 SHBuild 的特点和功能。</p>
<p>　　关于使用 <code>bash</code> 构建库、SHBuild 、测试项目和基于 SHBuild 上的用户程序，参见<a href="Tools/../Sysroot.zh-CN.html">关于 <strong>MinGW Sysroot</strong> 的说明</a>。</p>
<p>　　当前只支持<a href="Tools/../Terminology.zh-CN.html">本机构建</a>。</p>
<p>　　除了指定调用编译器等工具的名称外的其它情形对 SHBuild 是<em>透明(transparent)</em> 的，即 SHBuild 不使用<a href="Tools/../Terminology.zh-CN.html">目标平台的标识</a>执行不同逻辑。这样，也可能不经修改调用命令的情况下成功<a href="Tools/../Terminology.zh-CN.html">交叉构建</a>，但当前未测试。</p>
<h3 id="引导"><a class="header" href="#引导">引导</a></h3>
<p>　　SHBuild 支持<em>引导(bootstrapping</em>) ，即在受支持的构建环境中直接构建 SHBuild ，不依赖预先构建的 SHBuild 二进制映像。</p>
<p>　　运行脚本 <code>Tools/Scripts/SHBuild-build.sh</code> 生成 SHBuild 可执行文件。</p>
<p>　　脚本直接选取 YSLib 中的源文件作为依赖进行构建。因为直接调用编译器驱动链接，不支持显式指定并行编译，相对比较慢。编译的结果是静态链接的，二进制映像较大。</p>
<p>　　这个过程只需要 C++ 工具链和 shell ，不需要直接调用 <code>make</code> ，但 GCC 使用 <code>-flto</code> 进行优化仍然需要 GNU make 。</p>
<p>　　如能成功使用以下的多阶段构建方法（会按需调用引导脚本），一般不建议使用直接构建的版本。</p>
<h3 id="自举"><a class="header" href="#自举">自举</a></h3>
<p>　　SHBuild 支持<em>自举(self hosting)</em> ，即可使用构建的 SHBuild 继续构建自身。</p>
<p>　　除需 <code>SHBuild</code> 可执行程序外，对外部环境的要求和引导一致。</p>
<p>　　SHBuild 一直使用简单的源代码结构，设计初期即支持自举，现时仍不限制自举需要的版本。但由于仅测试相同版本的自举构建，因此一般建议使用相同版本。</p>
<p>　　以下多阶段构建在引导的基础上自举构建 SHBuild 。</p>
<p>　　此外，也可以直接使用 <code>SHBuild-self-host.sh</code> 和 <code>SHBuild-self-host-DLL.sh</code> 进行直接自举。这两个脚本主要用于内部测试。</p>
<h3 id="多阶段构建"><a class="header" href="#多阶段构建">多阶段构建</a></h3>
<p>　　使用<a href="Tools/Scripts.zh-CN.html">工具脚本</a>安装 <a href="Tools/../Sysroot.zh-CN.html">Sysroot</a> 时，按需构建 SHBuild 。当前这个过程分为两步：</p>
<p>　　运行<a href="Tools/Scripts.zh-CN.html#toolsinstall-sysrootsh">Sysroot 安装脚本</a>可直接完成以下多个阶段的构建和目标程序的部署(deployment) ：</p>
<ul>
<li>Stage 1 ，即第一阶段：<a href="Tools/SHBuild.zh-CN.html#%E5%BC%95%E5%AF%BC">引导</a>。
<ul>
<li>这个阶段运行 <a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-buildsh"><code>Tools/Scripts/SHBuild-build.sh</code></a> 构建 stage 1 SHBuild 。
<ul>
<li>若已存在构建了的 stage 1 SHBuild 可执行程序，Sysroot 安装脚本不再重新构建 stage 1 SHBuild 。
<ul>
<li>可指定非空的 <code>SHBuild_Rebuild_S1</code> 环境变量值以要求 Sysroot 安装脚本无视已存在的 stage 1 SHBuild 的可执行程序而重新构建。</li>
</ul>
</li>
<li><strong>原理</strong> 为可维护性，stage 1 SHBuild 的构建直接使用静态链接，且过程依赖避免系统库（工具链提供的环境）以外的外部二进制依赖项和网络连接。
<ul>
<li>不依赖外部工具的串行构建可能相当费时，但仍可被接受。</li>
</ul>
</li>
</ul>
</li>
<li>引导结果为 stage 1 SHBuild 程序，主要用于下一阶段使用，不保证具有所有 SHBuild 的功能特性。
<ul>
<li>可执行程序不被另行部署。</li>
<li>一般不建议直接使用。</li>
</ul>
</li>
<li><strong>原理</strong> 因为 stage 1 的目的是引导宿主构建的 SHBuild 并构建 YSLib 和其它依赖 YSLib 的应用，所以使用不依赖 YSLib 项目输出的原始的<a href="Tools/../Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">宿主环境</a>。
<ul>
<li>依照<a href="Tools/../Development.zh-CN.html">开发说明</a>配置的宿主环境是受支持的可用于运行构建工具的环境作为 stage 1 构建和运行环境。
<ul>
<li>构建时依赖这个环境的脚本运行环境运行构建脚本，并依赖其中的工具链进行编译链接。</li>
</ul>
</li>
<li>显然地，stage 1 不使用已被部署的 <code>SHBuild</code> 可执行程序。</li>
<li>因为不假设 <a href="Tools/../Development.zh-CN.html#npla1-%E8%84%9A%E6%9C%AC">NPLA1</a> 实现（默认由 SHBuild 提供）的可用性，<a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-buildsh">构建 stage 1 SHBuild 的脚本</a>是 <a href="Tools/../Development.zh-CN.html#shell-%E8%84%9A%E6%9C%AC">shell 脚本</a>而非 <a href="Tools/../Development.zh-CN.html#npla1-%E8%84%9A%E6%9C%AC">NPLA1 脚本</a>。</li>
</ul>
</li>
</ul>
</li>
<li>Stage 2 ，即第二阶段：<a href="Tools/SHBuild.zh-CN.html#%E8%87%AA%E4%B8%BE">自举</a>。
<ul>
<li>这个阶段在 Sysroot 安装脚本内调用成功引导的 stage 1 SHBuild 运行 NPLA1 脚本程序继续构建。
<ul>
<li>继续构建通过运行 <a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-yslib-buildtxt"><code>Tools/Scripts/SHBuild-YSLib-build.txt</code></a> 实现，步骤包括：
<ul>
<li>构建 YBase 和 YFramework 库。</li>
<li>自举构建 <code>SHBuild</code> ，链接到之前构建的 YFramework 和 YBase 动态库。</li>
</ul>
</li>
<li>Sysroot 安装脚本可通过 <a href="Tools/../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><code>SHBuild</code> 环境变量</a>指定 YSLib 库构建过程中使用的 SHBuild 命令。
<ul>
<li>若不指定变量 <code>SHBuild</code> ，默认值是（先前应已被检查并确保按需构建的）stage 1 SHBuild 的路径。</li>
<li><strong>原理</strong> 默认不需要另行部署 SHBuild 即可完成自举和之后的安装。但若在当前宿主环境中已存在可用的 <code>SHBuild</code> 可执行程序，指定 <code>SHBuild</code> 可避免 Sysroot 安装脚本中默认的不必要的 stage 1 SHBuild 构建。</li>
</ul>
</li>
</ul>
</li>
<li>自举结果为 stage 2 SHBuild 。
<ul>
<li>这是当前最终生成的 SHBuild ，链接和运行依赖上述 YBase 和 YFramework 动态库。</li>
<li>当前 stage 2 SHBuild 总是需要 release 动态库，因此除非先前已部署（足够新版本的兼容的）对应配置的库，不包含这个目标时 stage 2 SHBuild 会符合预期地构建失败。</li>
</ul>
</li>
<li><strong>原理</strong> 构建 YSLib 库是整个 Sysroot 环境安装的主要目标，是构建 stage 2 SHBuild 前的必要步骤，整体一般比构建 stage 1 SHBuild 更加费时，但是：
<ul>
<li>借助 SHBuild ，这些构建目标的编译过程是可并行的。</li>
<li>NPLA1 脚本接收的环境变量可通过调用 Sysroot 安装脚本指定，允许更灵活地控制构建使用的并行任务数等选项，且同时允许选择性仅构建和安装部分构建配置（包括 debug 或 release 模式，静态或动态库）的目标而节约开销。</li>
</ul>
</li>
</ul>
</li>
<li>使用 SHBuild 运行当前 YSLib 存储库中的特定的 NPLA1 脚本可选地构建其它目标，包括 <code>Tools</code> 中的 <code>SHBuild</code> 以外的二进制工具。
<ul>
<li>默认使用新近生成的 stage 2 SHBuild 可执行程序。</li>
<li>可通过 <a href="Tools/../Development.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><code>SHBuild</code> 环境变量</a>指定使用的 SHBuild 命令以被 NPLA1 脚本递归地调用。</li>
<li>这同时作为直接的部署后环境可用性测试，因而不提供指定其它 SHBuild 工具的选项。</li>
</ul>
</li>
<li>安装 stage 2 SHBuild 和（可选的）其它工具。
<ul>
<li><a href="Tools/../Development.zh-CN.html#%E8%84%9A%E6%9C%AC">开发脚本</a>中的<a href="Tools/Scripts.zh-CN.html">一部分被部署到 Sysroot</a> 的 stage 2 运行环境，也可在开发 YSLib 应用以外的情形被直接运行。</li>
</ul>
</li>
</ul>
<p>　　两个阶段需要的外部环境对应称为 stage 1 环境和 stage 2 环境；部署 stage 2 SHBuild（和可选的目标）后的环境是部署后环境。</p>
<p>　　作为更一般的开发环境和最终用户部署基于 Sysroot 的 YSLib 的应用的运行环境，stage 2 和部署后环境相对 stage 1 环境具有更多的假设和更少的限制：</p>
<ul>
<li>用于构建时，假定 <code>PATH</code> 中存在兼容的 <code>SHBuild</code> 可执行程序的命令。
<ul>
<li>在 Sysroot 构建 YSLib 的库时，默认使用先前 stage 1 SHBuild ，其它情形默认使用 stage 2 SHbuild 。</li>
<li>应确保 SHBuild 程序和使用的 NPLA1 脚本的版本匹配，一般来自同一个 Sysroot 安装。
<ul>
<li>若 <code>SHBuild</code> 没有与更新版本的脚本匹配，运行可能失败，这不被支持。
<ul>
<li>此时仍建议重新构建 stage 1 SHBuild ；参见以上 stage 1 的说明。</li>
</ul>
</li>
<li>但除非另行指定，NPLA1 脚本的内容不依赖具体实现环境，且仅通过 SHBuild 调用。</li>
<li>这些实际脚本通过可直接复制到兼容的安装的位置部署。
<ul>
<li>但这些位置不保证作为公开接口而保持不变；同时需注意在运行环境中具有可读权限。</li>
</ul>
</li>
<li>因此除非必要，一般仍建议使用 Sysroot 默认配置进行部署。</li>
</ul>
</li>
<li>除非另行指定，Sysroot 构建不依赖 stage 1 和 stage 2 的 SHBuild 中可能具有的差异。
<ul>
<li>因此，可（通过环境变量）指定任意的预先安装的和 NPLA1 脚本匹配版本的 SHBuild 程序。</li>
</ul>
</li>
<li>一般建议开发环境中把某个 Sysroot 的 <code>bin</code> 目录加入 <code>PATH</code> 环境变量，以使用其中的 <code>SHBuild</code> 命令。
<ul>
<li>使用这个环境开发时，运行环境和 stage 2 构建环境相同，且可使用 stage 2 SHBuild 和其它工具。</li>
<li>需要使用不同的 SHBuild 程序时仍可通过 <code>SHBuild</code> 环境变量指定。否则，变量 <code>SHBuild</code> 的默认值是 <code>SHBuild</code> ，因此 <code>PATH</code> 环境变量应存在名为 <code>SHBuild</code> 可执行程序。这被这个环境中默认满足。</li>
<li>在 Windows 系统中，被 Sysroot 构建和部署的 SHBuild 的可执行文件名总是 <code>SHBuild.exe</code> 。除非有同名的目录（在部署中不会出现），在 Windows 的命令行运行这个可执行文件不需要后缀。</li>
<li>在其它运行环境中，被 Sysroot 部署的 SHBuild 的可执行文件通常是 <code>SHBuild</code> 。但在此之前，<a href="Tools/SHBuild.zh-CN.html#%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%BC%8F">为避免和同名的目录冲突，使用 SHBuild 构建时直接得到的可执行文件总是带有 <code>.exe</code> 扩展名</a>。</li>
</ul>
</li>
</ul>
</li>
<li>这些环境使用 NPLA1 脚本而不是 stage 1 的 shell 脚本提供可用的构建功能。
<ul>
<li>这些功能<a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-yslib-commontxt">部分相似但也有一定差异</a>。</li>
</ul>
</li>
</ul>
<p>　　由于<a href="Tools/../Terminology.zh-CN.html">多平台构建</a>的自然要求，这些环境需要相同（本机构建），或至少保持兼容性。当前工具脚本没有另行显示指定使用不同平台的接口，因此只支持本机构建。</p>
<h2 id="运行-2"><a class="header" href="#运行-2">运行</a></h2>
<p>　　通过以下方式调用 <code>SHBuild</code> 命令输出帮助消息并退出：</p>
<ul>
<li>没有命令行参数。</li>
<li>使用 <code>-h</code> 或 <code>--help</code> 作为命令行参数。</li>
</ul>
<p>　　通过以下方式调用 <code>SHBuild</code> 命令输出版本信息并退出：</p>
<ul>
<li>使用 <code>-V</code> 或 <code>--version</code> 作为命令行参数。</li>
</ul>
<p>　　其它情形调用 <code>SHBuild</code> ，使用参数执行命令，支持不同的运行模式：</p>
<ul>
<li>构建模式：调用递归扫描指定的目录以调用构建后端工具。</li>
<li>命令模式：执行内建的功能。</li>
</ul>
<p>　　命令模式以 <code>-xcmd,</code> 起始的选项指定。其它情形的运行使用构建模式。</p>
<p>　　命令行参数 <code>--</code> 钱的参数中，以 <code>-x</code> 起始的特定选项（详见帮助消息）被作为 SHBuild 选项。命令行参数 <code>--</code> 后的参数不被识别为 SHBuild 选项，而被传递给后端或作为命令模式的参数。</p>
<h3 id="构建模式"><a class="header" href="#构建模式">构建模式</a></h3>
<p>　　构建模式递归扫描指定的源代码目录，以其中符合内建规则要求的文件作为输入，调用相应的后端命令行构建。构建包括对符合内建规则的输入的编译，以及对得到的目标文件进行链接。除 SHBuild 选项的命令行参数直接传除递给后端编译器。若需要构建复杂项目，可以使用其它的脚本支持。</p>
<p>　　调用的构建后端工具的名称以及链接器命令行选项可使用<a href="Tools/../Development.zh-CN.html">环境变量</a>指定。此外，若环境变量 <code>SHBuild_CFLAGS</code> 和 <code>SHBuild_CXXFLAGS</code> 被定义为非空值，调用 C 和 C++ 编译器命令行时，变量的值会先于生成的命令选项以及上述命令行选项被传递。关于支持的环境变量，详见运行 <code>SHBuild</code> 的说明。</p>
<p>　　调用的后端命令行的不同的命令行选项之间应确保以空白符间隔。环境变量确定的选项不被检查；由 SHBuild 生成的命令行选项之间以一个空格分隔。</p>
<p>　　使用 SHBuild 构建若得到的库文件，则按<a href="Tools/../Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">宿主平台</a>确定添加的文件扩展名；而可执行文件总是带有 <code>.exe</code> 后缀，以避免递归扫描生成的输出文件目录和可执行文件重名导致无法生成。</p>
<p>　　通过<a href="Tools/../Development.zh-CN.html#%E8%84%9A%E6%9C%AC">开发脚本</a>等方式部署 SHBuild 输出的文件时，可以调整安装的文件名。</p>
<h3 id="内建规则"><a class="header" href="#内建规则">内建规则</a></h3>
<p>　　遍历扫描目录时，不需要使用领域特定语言的外部脚本，<code>SHBuild</code> 识别名称符合特定模式串的文件。</p>
<p>　　当前支持后缀名区分源文件。</p>
<p>　　文件名符合以下通配符模式的文件视为 C 源文件：</p>
<ul>
<li><code>*.c</code></li>
</ul>
<p>　　文件名符合以下通配符模式的文件视为 C++ 源文件：</p>
<ul>
<li><code>*.cpp</code></li>
<li><code>*.cc</code></li>
<li><code>*.cxx</code></li>
</ul>
<p>　　对以上文件，对应的内建 C 和 C++ 编译器规则分别被调用。其它文件不被视为源文件。</p>
<p>　　和 <code>make</code> 类似，SHBuild 的内建规则依赖文件修改时间(mtime) 判断一个目标是否最新。</p>
<p>　　内建规则使用的编译器和环境变量参见帮助消息。</p>
<h3 id="命令模式"><a class="header" href="#命令模式">命令模式</a></h3>
<p>　　参见帮助消息。</p>
<h2 id="构建应用程序"><a class="header" href="#构建应用程序">构建应用程序</a></h2>
<p>　　使用 SHBuild 构建应用程序所需的环境和多阶段构建的最后一个阶段的相同。当前和自举时相同，即 stage 2 环境。</p>
<h2 id="其它平台"><a class="header" href="#其它平台">其它平台</a></h2>
<p>　　除构建 stage 1 SHBuild 外，当前未正式支持 Linux 。</p>
<p>　　因为 SHBuild 本身和直接依赖的代码已经保证了可移植性，所以静态链接可以成功。得到的可执行文件除了没有扩展名，用法和前述 MinGW 下相同。</p>
<p>　　使用进一步编译 YFramework 可能会出错，因为 YFramework 中宿主 GUI 支持未在 Linux 上实现。这不影响已经构建的 SHBuild 的可用性。</p>
<p><strong>已知限制</strong> 若系统时间不正确，可能导致冗余的重复构建或无法构建。若文件时间戳无法被正确更新（如编译器或者文件系统实现问题导致无法在命令执行后正确地更新被修改的文件时间，或者不恰当的缓存配置导致修改时间没有立即更新），可能导致冗余的重复构建。</p>
<p>　　当前不支持上述以外的其它平台。</p>
<h2 id="npl-支持"><a class="header" href="#npl-支持">NPL 支持</a></h2>
<p>　　SHBuild 运行 <code>-xcmd,RunNPL</code> 和 <code>-xcmd,RunNPLFile</code> 命令支持解释 <a href="Tools/../Features/NPL.zh-CN.html">NPLA1</a> 翻译单元。</p>
<p>　　调用方式详见帮助文本。</p>
<p>　　后者的翻译单元为文本文件。当前支持文件头可选的 UTF BOM 。**若找到 BOM ，直接跳过继续读取文件内容。在 SHBuild 中不假设文件编码，直接以窄字符流透明地处理。后续编码内容格式按<a href="Tools/../Features/NPL.zh-CN.html"> YFramework 提供的当前实现</a>的方式支持。</p>
<p>　　因此，一般应使用 UTF-8 + BOM ，或不带 BOM 的 UTF-8 作为编码。</p>
<h3 id="应用"><a class="header" href="#应用">应用</a></h3>
<p>　　当前 stage 1 SHBuild 构建 YSLib 库使用<a href="Tools/Scripts.zh-CN.html">脚本</a>已以此方式实现。Shell 脚本调用 stage 1 SHBuild 解释这些脚本，其中进一步调用 stage 1 SHBuild 执行其它构建命令。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="revisionpatcher"><a class="header" href="#revisionpatcher">RevisionPatcher</a></h1>
<p>　　位于 <code>Tools/RevisionPatcher</code> ，是开发过程中用于修改版本工具。</p>
<p>　　当前只支持从标准输入中提取版本号，内容要求为补丁文件。</p>
<p>　　默认使用标准输出打印结果，内容为从补丁文件提取的目标文件名以及新的版本号。</p>
<p>　　不修改任何其它文件。</p>
<p>　　版本号通过补丁内的信息计算。使用规则参见 YSLib 项目文档 <code>doc/ProjectRules.txt</code> 。</p>
<p>　　仅测试了 <code>hg diff</code> 导出的补丁文件。</p>
<h2 id="构建-5"><a class="header" href="#构建-5">构建</a></h2>
<p>　　依赖 YBase 和 YFramework 库，没有特别的构建支持，可以使用 stage 2 <a href="Tools/SHBuild.zh-CN.html"><code>SHBuild</code></a> ，详见 <a href="Tools/Scripts.zh-CN.html">sysroot 安装脚本</a> 。</p>
<h3 id="清单manifest-文件"><a class="header" href="#清单manifest-文件">清单(manifest) 文件</a></h3>
<p>　　因为文件名包含 <code>patch</code> ，<a href="https://github.com/bmatzelle/gow/issues/156">Windows 可能默认要求以管理员权限运行</a> 。安装脚本使用 manifest 文件指定免除此需要。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="revisionpatcher-1"><a class="header" href="#revisionpatcher-1">RevisionPatcher</a></h1>
<p>　　位于 <code>Tools/SXML2XML</code> ，用于转换 <a href="http://okmij.org/ftp/Scheme/xml.html">SXML</a> 文档到 <a href="http://www.w3.org/TR/rec-xml">XML</a> 文档。</p>
<p>　　当前只支持 UTF-8 编码，不支持 XML 命名空间。</p>
<p>　　默认使用标准输出打印结果。</p>
<h2 id="构建-6"><a class="header" href="#构建-6">构建</a></h2>
<p>　　依赖 YBase 和 YFramework 库，没有特别的构建支持，可以使用 stage 2 <a href="Tools/SHBuild.zh-CN.html"><code>SHBuild</code></a> ，详见 <a href="Tools/Scripts.zh-CN.html">sysroot 安装脚本</a> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="projectgenerator"><a class="header" href="#projectgenerator">ProjectGenerator</a></h1>
<p>　　位于 <code>Tools/ProjectGenerator</code> ，用于生成项目文件。</p>
<p>　　当前只支持 UTF-8 编码的 Code::Blocks <code>.cbp</code> 文件。</p>
<p>　　使用标准输出打印结果。</p>
<h2 id="构建-7"><a class="header" href="#构建-7">构建</a></h2>
<p>　　依赖 YBase 和 YFramework 库，没有特别的构建支持，可以使用 stage 2 <a href="Tools/SHBuild.zh-CN.html"><code>SHBuild</code></a> ，详见 <a href="Tools/Scripts.zh-CN.html">sysroot 安装脚本</a> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述-4"><a class="header" href="#概述-4">概述</a></h1>
<p>　　YSLib 项目提供一系列工具脚本。这些脚本主要集中位于 <code>Tools</code> 和 <code>Tools/Scripts</code> 。其余特定局部用途的脚本可能位于其它目录，这些脚本可能依赖版本库内的工具脚本或 YSLib 安装时部署的工具脚本。</p>
<p>　　关于脚本的解释环境和其它一般规则，参见<a href="Tools/../Development.zh-CN.html#%E8%84%9A%E6%9C%AC">关于脚本的开发说明</a>。</p>
<p><strong>注释</strong> 维护者和开发者需要阅读开发说明，以保持脚本程序符合文档的描述。其中的一些信息（如关于环境变量等运行时环境的描述）也可能提供对脚本的非开发者用户有帮助的说明，作为<a href="Tools/../Run.zh-CN.html">运行环境</a>中说明的补充。</p>
<h1 id="tools"><a class="header" href="#tools">Tools</a></h1>
<p>　　未归类的工具目录。这个目录的脚本是可用于整个项目或非特定子项目的工具脚本，如公用的构建脚本。</p>
<p>　　工具脚本位于版本库目录 <code>Tools</code> 及其子目录 <code>Scripts</code> 下。</p>
<p>　　工具主要用于开发，包括构建和版本库维护。</p>
<p>　　一部分工具脚本也可被部署到 <a href="Tools/../Sysroot.zh-CN.html">Sysroot</a> 。在 <a href="Tools/SHBuild.zh-CN.html">stage 2 SHBuild</a> 安装后运行的脚本可依赖安装的 Sysroot 实例的文件系统布局。支持维护版本库的开发脚本应保证在此之前（不依赖 Sysroot 的实例或仅依赖构建 stage 1 后可用的有限环境）可用。</p>
<h2 id="toolsinstall-sysrootsh"><a class="header" href="#toolsinstall-sysrootsh">Tools/install-sysroot.sh</a></h2>
<p>　　Sysroot 安装脚本。用于直接构建和部署基础环境。</p>
<p>　　构建时会调用 <code>Tools/Scripts</code> 目录下的脚本，按需构建 <a href="Tools/SHBuild.zh-CN.html">stage 1 SHBuild</a> 后间接调用 <code>SHBuild</code> 构建 <code>YBase</code> 和 <code>YFramework</code> 的静态库和动态库，再构建依赖于动态库的 <code>SHBuild</code> 。</p>
<p>　　构建使用变量 <code>SHBuild_BuildDir</code> 指定的路径作为中间输出目录，默认为 YSLib 版本库根目录下的 <code>build/$(SHBuild_GetBuildName)</code> 目录。</p>
<p>　　构建脚本同时可安装文件，完成 Sysroot 所需文件的部署。安装的起始目标位置由称为<strong>安装路径</strong>的目录路径指定，其字符串形式去除结尾分隔符的目录文件名为<strong>安装路径前缀</strong>。安装过程在必要时可创建 Sysroot 根目录、安装路径指定的目录及其子目录。安装路径的确定方式详见以下的使用方式。</p>
<p>　　部署时使用 stage 1 SHBuild 更新文件和目录，在必要时创建符号链接或硬链接，若失败则改为普通复制。仅当被部署的文件为中间目标启用硬链接，以免后续操作意外覆盖源文件。注意在 Windows 上创建符号链接可能因为权限不足失败，取决于用户和组策略。建议使用系统管理权限运行以避免可能的权限问题。</p>
<h3 id="基本使用"><a class="header" href="#基本使用">基本使用</a></h3>
<p>　　脚本接受在 stage 2 使用的 <code>SHBuild</code> 命令行中的选项为命令行参数，如</p>
<pre><code>Tools/install-sysroot.sh -xj,2
</code></pre>
<p>　　使用 2 个并行线程构建。</p>
<p>　　脚本也支持变量配置构建使用的路径，默认相当于使用如下 bash 命令配置变量：</p>
<pre><code class="language-bash">: ${SHBuild_SysRoot:=&quot;$YSLib_BaseDir/sysroot&quot;}
SHBuild_PrepareBuild
: ${SHBuild_BuildDir:=&quot;$YSLib_BaseDir/build/$(SHBuild_GetBuildName)&quot;}
</code></pre>
<p>　　其中：</p>
<ul>
<li><a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_preparebuild"><code>SHBuild_PrepareBuild</code></a> 是 <code>Tools/Scripts/SHBuild-common.sh</code> 中的函数。</li>
<li>各个变量参见<a href="Tools/../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">开发文档中的环境变量的说明</a>。</li>
</ul>
<p>　　在 stage 1 SHBuild 构建调用 NPLA1 脚本 <code>Tools/Scripts/SHBuild-YSLib*.txt</code> ，调用方式和接受的配置（构建目标等）、具体默认设置和注意事项见对应 shell 脚本的文档相关章节。</p>
<h1 id="toolsscripts"><a class="header" href="#toolsscripts">Tools/Scripts</a></h1>
<p>　　这个目录的脚本可用于整个项目或项目核心部分的构建工具使用。</p>
<p>　　当前有以下脚本忽略重复的 <code>.</code> 或 <code>source</code> 命令：</p>
<ul>
<li>SHBuild-common.sh</li>
</ul>
<p>　　以前缀 <code>SHBuild_</code> 起始的名称保留使用。</p>
<p>　　其中，前缀 <code>SHBuild_Env_</code> 总是表示环境配置的只读变量名。这些变量若未被指定，可在第一次访问时（具体时机未指定）初始化为：</p>
<ul>
<li><code>SHBuild_Env_Arch</code> ：参见函数 <code>SHBuild_CheckUName</code> 。</li>
<li><code>SHBuild_Env_OS</code> ：参见函数 <code>SHBuild_CheckUName</code> 。</li>
<li><code>SHBuild_Env_TempDir</code> ：缓存函数 <code>SHBuild_GetTempDir</code> 的输出。</li>
<li><code>SHBuild_Env_uname</code> ：缓存命令 <code>uname</code> 的输出。</li>
<li><code>SHBuild_Env_uname_m</code> ：缓存命令 <code>uname -m</code> 的输出。</li>
</ul>
<h2 id="toolsscriptsgenerateprojectssh"><a class="header" href="#toolsscriptsgenerateprojectssh">Tools/Scripts/GenerateProjects.sh</a></h2>
<p>　　调用 <a href="Tools/ProjectGenerator.zh-CN.html">ProjectGenerator</a> 生成项目文件。</p>
<p>　　当前支持生成所有 <code>.cbp</code> 文件。</p>
<p>　　要求可使用 <code>hg</code> 或 <code>git</code> 命令取版本库根目录，否则不保证输出到正确的路径。</p>
<h3 id="变量-projectgenerator"><a class="header" href="#变量-projectgenerator">变量 ProjectGenerator</a></h3>
<p>　　调用 RevisionPatcher 的命令。默认直接使用 <code>which ProjectGenerator</code> 的结果，一般要求可执行文件在环境变量 <code>PATH</code> 中。</p>
<h2 id="toolsscriptspatchrevisionsh"><a class="header" href="#toolsscriptspatchrevisionsh">Tools/Scripts/PatchRevision.sh</a></h2>
<p>　　开发过程中使用 <a href="Tools/RevisionPatcher.zh-CN.html">RevisionPatcher</a> 维护源文件中版本号的脚本。</p>
<p>　　当前只支持 Mercurial 或 Git 版本库的已添加或修改的未提交文件。</p>
<p>　　使用的版本控制系统会被检查。通过检查的条件、确定使用的版本控制的机制及支持的控制检查的环境变量同 Tools/Scripts/SHBuild-YSLib*.txt 公用的版本控制系统支持，参见以下相关章节的说明。</p>
<p>　　若检查都失败，则脚本出错，不再继续运行。</p>
<p>　　脚本利用 <code>hg</code> 或 <code>git</code> 命令把未提交的这些修改导出为补丁备份到版本库根目录的 <code>bak.patch</code> ，然后使用这些内容调用 RevisionPatcher 取得文件和对应的新的版本号列表，最后使用 <code>sed</code> 查找对应文件并更新版本号。</p>
<p>　　脚本依赖 <code>sed</code> 命令。使用的 <code>sed</code> 应支持 <code>-b -i</code> 选项。可使用 Linux 或 MSYS2 的发行版中的 sed 4.8 程序。</p>
<p><strong>警告</strong> 某些 Win32 版本的 <code>sed</code> ，如 MSYS2 MinGW64 sed 4.4 可能损坏文本文件的行尾。有些替代版本可能解决<a href="https://stackoverflow.com/questions/4652652">这一问题</a>。</p>
<p><strong>注释</strong> 当前不检查特定版本 <code>sed</code> 对选项的支持。</p>
<p>　　若没有找到 <code>\version r</code> 模式的版本号前缀则忽略写入版本号。写入的版本号不影响换行符。</p>
<p><strong>注释</strong> 这个脚本可用于自动化。例如，在 Mercurial 仓库的 <code>hgrc</code> 的 <code>[hooks]</code> 节中添加 <code>precommit.PatchRevision = bash Tools/Scripts/PatchRevision.sh</code> 可在每次提交前调用这个脚本。在 YSLib 中，仅在主分支版本中启用。</p>
<h3 id="变量-patchbegin"><a class="header" href="#变量-patchbegin">变量 PatchBegin</a></h3>
<p>　　匹配版本号的起始行，应为一个表示行数的正整数。默认值为 <code>&quot;1&quot;</code> 。</p>
<h3 id="变量-patchend"><a class="header" href="#变量-patchend">变量 PatchEnd</a></h3>
<p>　　匹配版本号的结束行，应为一个表示行数的正整数。默认值为 <code>&quot;20&quot;</code> 。</p>
<h3 id="变量-revisionpatcher"><a class="header" href="#变量-revisionpatcher">变量 RevisionPatcher</a></h3>
<p>　　调用 RevisionPatcher 的命令。默认值为 <code>which RevisionPatcher</code> 的结果。</p>
<p><strong>注释</strong> 可执行文件可以在环境变量 <code>PATH</code> 中。</p>
<h3 id="变量-patchhg"><a class="header" href="#变量-patchhg">变量 PatchHg</a></h3>
<p>　　指定使用 Mercurial 。参见以上确定使用 Mercurial 或 Git 的说明。</p>
<h3 id="变量-patchgit"><a class="header" href="#变量-patchgit">变量 PatchGit</a></h3>
<p>　　指定使用 Git 。参见以上确定使用 Mercurial 或 Git 的说明。</p>
<h2 id="toolsscriptsshbuild-bootstrapsh"><a class="header" href="#toolsscriptsshbuild-bootstrapsh">Tools/Scripts/SHBuild-bootstrap.sh</a></h2>
<p>　　编译 <a href="Tools/SHBuild.zh-CN.html">stage 1 SHBuild</a> 时被包含的脚本。</p>
<p>　　其中指定了静态链接需要依赖的 YSLib 源文件以及头文件路径等。</p>
<h2 id="toolsscriptsshbuild-buildsh"><a class="header" href="#toolsscriptsshbuild-buildsh">Tools/Scripts/SHBuild-build.sh</a></h2>
<p>　　编译 <a href="Tools/SHBuild.zh-CN.html">stage 1 SHBuild</a> 的脚本。</p>
<p>　　使用变量 <code>SHBuild_Output</code> 指定输出路径。默认值为 <code>SHBuild</code> ，即在当前工作目录下生成名为 <code>SHBuild</code> 的可执行文件（视宿主平台不同可能带后缀如 Win32 带 <code>.exe</code> ）。</p>
<p>　　调用函数 <code>SHBuild_CheckPCH</code> 检查预编译头：若变量 <code>SHBuild_NoPCH</code> 非空则跳过预编译头，否则使用预编译头包含标准库头。预编译的头文件目标由 YBase 下的 <code>stdinc.h</code> ，之后构建时包含预编译头路径为 <code>$SHBuild_PCH_stdinc_h</code> 。后者的默认路径为当前工作目录下的 <code>stdinc.h</code> 。</p>
<p>　　因为升级或更换编译器和/或选项，可导致预编译头文件（ <code>.gch</code> 文件）不和生成的环境匹配而不被识别。</p>
<p><strong>注意</strong> 预编译头文件不保证对不同的操作系统版本兼容，参见<a href="Tools/../Prerequisitions.zh-CN.html">先决条件</a>中 PC(Win32) 平台关于操作系统版本的说明。</p>
<p>　　不被识别的预编译头文件通常：</p>
<ul>
<li>可引起编译器警告，并忽略预编译头文件。
<ul>
<li>若仅需避免产生警告，确保编译器命令行使用恰当选项，如添加 <code>-Wno-invalid-pch</code> 。</li>
</ul>
</li>
<li>可能引起无法构建的错误。</li>
</ul>
<p>　　一般仍然需要避免使用不匹配的预编译头文件。若无法保证预编译头文件和使用的工具链和选项匹配：</p>
<ul>
<li>可设置变量 <code>SHBuild_NoPCH</code> 的值非空以跳过预编译头文件的使用。</li>
<li>可以手动删除生成的预编译头文件。在没有设置变量 <code>SHBuild_NoPCH</code> 的情形下构建通常会默认自动生成。
<ul>
<li><strong>注释</strong> 具体的支持和生成预编译头文件的位置参见具体构建目标的说明，如 <a href="Tools/../Sysroot.zh-CN.html#%E6%9E%84%E5%BB%BA%E4%B8%AD%E9%97%B4%E6%96%87%E4%BB%B6">Sysroot</a> 。</li>
</ul>
</li>
</ul>
<p><strong>已知缺陷</strong> 构建时不自动更新预编译头。</p>
<h2 id="toolsscriptsshbuild-buildappsh"><a class="header" href="#toolsscriptsshbuild-buildappsh">Tools/Scripts/SHBuild-BuildApp.sh</a></h2>
<p>　　应用程序构建脚本。这个脚本被保留，不再具有实际功能。</p>
<p>　　<strong>这个脚本是公开的工具</strong>，被 <code>Tools/install-sysroot.sh</code> 部署到安装路径下的 <code>bin</code> 目录下。</p>
<h2 id="toolsscriptsshbuild-buildpkgsh"><a class="header" href="#toolsscriptsshbuild-buildpkgsh">Tools/Scripts/SHBuild-BuildPkg.sh</a></h2>
<p>　　包构建脚本。当前只支持构建应用程序，具体步骤和使用的参数参见 <code>Tools/Script/SHBuild-BuildApp.txt</code> 。</p>
<p>　　<strong>这个脚本是公开的工具</strong>，被 <code>Tools/install-sysroot.sh</code> 部署到安装路径下的 <code>bin</code> 目录下。</p>
<h2 id="toolsscriptsshbuild-commonsh"><a class="header" href="#toolsscriptsshbuild-commonsh">Tools/Scripts/SHBuild-common.sh</a></h2>
<p>　　被应用程序构建脚本包含的脚本，提供公共基础功能。</p>
<p>　　<strong>这个脚本是公开的工具</strong>，被 <code>Tools/install-sysroot.sh</code> 部署到安装路径下的 <code>bin</code> 目录下。</p>
<p><strong>注意</strong> 这个脚本包含 <code>INC_SHBuild_common</code> 守卫变量检查，默认重复包含只被执行一次。</p>
<h3 id="函数-shbuild_popd"><a class="header" href="#函数-shbuild_popd">函数 SHBuild_Popd</a></h3>
<p>　　同 <code>bash</code> 内建 <code>popd</code> 但不回显标准输出。</p>
<h3 id="函数-shbuild_pushd"><a class="header" href="#函数-shbuild_pushd">函数 SHBuild_Pushd</a></h3>
<p>　　同 <code>bash</code> 内建 <code>pushd</code> 但不回显标准输出。</p>
<h3 id="函数-shbuild_put"><a class="header" href="#函数-shbuild_put">函数 SHBuild_Put</a></h3>
<p>　　使用 <code>printf</code> 输出非格式字符串。</p>
<h3 id="函数-shbuild_puts"><a class="header" href="#函数-shbuild_puts">函数 SHBuild_Puts</a></h3>
<p>　　使用 <code>printf</code> 输出非格式的换行的字符串。</p>
<p>　　换行符由变量 <code>SHBuild_EOL</code> 指定。当前默认值通过检查 <code>$COMSPEC</code> 是否定义，以确保 Windows 环境（包括 MSYS ）使用 CR+LF ，其它情况使用 LF 。</p>
<p>　　这个函数在可用时可用于代替 <code>echo</code> ，以取得对环境更好的适应性。</p>
<p><strong>注意</strong> 具体的检查逻辑实现可能在以后改变。</p>
<h3 id="函数-shbuild_assertnonempty"><a class="header" href="#函数-shbuild_assertnonempty">函数 SHBuild_AssertNonempty</a></h3>
<p>　　断言第一参数为名称的变量非空，否则显示出错并退出。</p>
<p>　　使用 <code>eval</code> 实现。</p>
<h3 id="函数-shbuild_checkedcall"><a class="header" href="#函数-shbuild_checkedcall">函数 SHBuild_CheckedCall</a></h3>
<p>　　检查第一参数为名称的命令存在，否则显示出错并退出。</p>
<p>　　使用 <code>hash</code> 实现以优化性能。</p>
<h3 id="函数-shbuild_checkedcallsilent"><a class="header" href="#函数-shbuild_checkedcallsilent">函数 SHBuild_CheckedCallSilent</a></h3>
<p>　　同 SHBuild_CheckedCall ，但不显示错误外的标准输出。</p>
<h3 id="函数-shbuild_initreadonly"><a class="header" href="#函数-shbuild_initreadonly">函数 SHBuild_InitReadonly</a></h3>
<p>　　断言第一参数为名称的变量非空，若空则使用 <code>eval</code> 对后续求值并初始化第一参数指定的只读变量。若发生初始化则在标准输出中显示。</p>
<h3 id="函数-shbuild_2m"><a class="header" href="#函数-shbuild_2m">函数 SHBuild_2m</a></h3>
<p>　　接受 1 个表示路径的参数，调用 <code>cygpath</code> 转换路径到 Windows 混合风格路径。</p>
<p>　　当 <code>cygpath</code> 不存在时返回原路径。</p>
<h3 id="函数-shbuild_2u"><a class="header" href="#函数-shbuild_2u">函数 SHBuild_2u</a></h3>
<p>　　接受 1 个表示路径的参数。</p>
<p>　　调用 <code>cygpath</code> 转换 Windows 路径到 UNIX 路径。</p>
<p>　　当 <code>cygpath</code> 不存在时返回原路径。</p>
<h3 id="函数-shbuild_echoescape"><a class="header" href="#函数-shbuild_echoescape">函数 SHBuild_EchoEscape</a></h3>
<p>　　当标准输出使用终端时调用 <code>echo -ne</code> 输出参数指定的 ANSI 转义序列。</p>
<p><strong>已知缺陷</strong> 不检查 <code>$TERM</code> 支持。</p>
<h3 id="函数-shbuild_echovar"><a class="header" href="#函数-shbuild_echovar">函数 SHBuild_EchoVar</a></h3>
<p>　　接受 2 个参数 x 和 y ，以特定颜色显示为 x = y 的形式。</p>
<h3 id="函数-shbuild_echovar_n"><a class="header" href="#函数-shbuild_echovar_n">函数 SHBuild_EchoVar_N</a></h3>
<p>　　接受 1 个参数 x ，调用 <code>SHBuild_EchoVar</code> 显示为 x = $x 的形式。</p>
<p>　　右侧求值时会替换参数中的 <code>.</code> 为 <code>_</code> 。</p>
<h3 id="函数-shbuild_checkuname"><a class="header" href="#函数-shbuild_checkuname">函数 SHBuild_CheckUName</a></h3>
<p>　　调用 <code>SHBuild_CheckedCall</code> 初始化只读变量 <code>SHBuild_Env_OS</code> 和 <code>SHBuild_Env_Arch</code> 的值。</p>
<p>　　变量 <code>SHBuild_Env_OS</code> 的值通过分类系统的值（一般即 <code>SHBuild_Env_uname</code> 的值）标识操作系统：</p>
<ul>
<li><code>OS_X</code> ：输入匹配 *Darwin* ，用于标识 OS X 系统</li>
<li><code>Win32</code> ：输入匹配 *MIGW* 或 *MSYS* ，用于标识 Windows （桌面）系统</li>
<li><code>Linux</code> ：输入匹配 *Linux* ，用于标识 Linux 系统。</li>
<li><code>unknown</code> ： 不支持的系统。</li>
</ul>
<p>　　变量 <code>SHBuild_Env_Arch</code> 的值通过分类输入的处理器体系结构的值（一般即 <code>SHBuild_Env_uname_m</code> 的值）标识体系结构：</p>
<ul>
<li><code>x86_64</code> ：输入匹配 x86_64 或 i*86-64 。</li>
<li><code>i*86</code> ：输入匹配 i*86 ，使用原值。</li>
<li><code>aarch64</code> ：输入是 aarch64 。</li>
<li><code>unknown</code> ：不支持的体系结构。</li>
</ul>
<p>　　若同时指定环境变量 <code>SHBuild_Env_Arch</code> 和 <code>SHBuild_Env_OS</code> ，不进行<a href="Tools/../Prerequisitions.zh-CN.html">自动环境检测</a>，不依赖 <code>uname</code> 。</p>
<h3 id="函数-shbuild_gettempdir"><a class="header" href="#函数-shbuild_gettempdir">函数 SHBuild_GetTempDir</a></h3>
<p>　　取临时目录的路径。</p>
<p>　　依次检查以下环境变量的值，若非空则作为结果：</p>
<ul>
<li><code>TMPDIR</code></li>
<li><code>TEMP</code></li>
<li><code>TMP</code></li>
</ul>
<p>　　若这些环境变量都没有非空值，则使用经过 <code>SHBuild_2m</code> 转换的 <code>/tmp</code>（被 <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap10.html#tag_10_01">POSIX.1 要求支持</a>）作为结果。</p>
<p><strong>注意</strong> 以上过程在所有平台上都一致。这是自适应环境的基本接口，因此不对环境变量的值的合法性进行判断。若结果不表示一个可访问的目录，在访问以此构造的文件路径时可能引发错误。应用程序一般需自行检查或保证使用的环境中这些路径可访问。</p>
<p><strong>说明</strong> 以上检查中，支持的环境变量符合<a href="https://en.wikipedia.org/wiki/TMPDIR">惯例(en-US)</a> 。检查环境变量的顺序（偶然地）和一些类似功能的实现（如 <a href="https://dev.mysql.com/doc/refman/8.0/en/temporary-files.html">MySQL 在 Windows 上</a>）一致，和其它一些特定平台的 API（如 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-gettemppathw">Win32 API</a> ）及另一些不作为公开行为的实现（如 <a href="https://gcc.gnu.org/onlinedocs/gcc-4.8.5/libiberty/Functions.html#index-choose_005ftmpdir-66">libiberty 的 <code>choose_tmpdir</code></a> ）可能不一致。被支持的环境变量可用性举例：</p>
<ul>
<li><code>TMPDIR</code> ：<a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html">POSIX.1 要求的环境变量</a> 。</li>
<li><code>TEMP</code> ：被 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-gettemppathw">Win32 文件 API</a> 等使用。</li>
<li><code>TMP</code> ：被 Win32 文件 API 和 <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/tempnam-wtempnam-tmpnam-wtmpnam?view=msvc-160">Microsoft C 运行时 API</a> 等使用。</li>
<li>另见<a href="https://devblogs.microsoft.com/oldnewthing/20150417-00/?p=44213">对 MS-DOS 和 Microsoft Windows 使用的临时目录环境变量解释</a>。</li>
</ul>
<p><strong>已知限制</strong> 不检查路径是否表示实际可写的目录。另见文件访问约定。</p>
<p>　　当前脚本实现假定临时目录可写，不满足条件时，文件操作可能失败。脚本使用的临时文件前也不保证检查文件可写。若此文件不可写（例如，在之前被 <code>root</code> 等高权限用户创建），则依赖文件可写的操作可能失败。对构建脚本，这可能导致依赖临时文件进行检查判断失效，而使错误的选项被使用。</p>
<p>　　一般地，脚本可使用特定的例程（如 Shell 脚本可选地使用<a href="https://stackoverflow.com/questions/2792675">在许多环境中可用的 <code>mktemp</code> 命令</a>）随机化文件名减少冲突。若需要更可靠地避免上述问题，可在运行脚本前清理临时目录，或预先设置 <code>SHBuild_GetTempDir</code> 访问的环境变量指定确保可写的空目录，同时避免并发调用脚本导致不安全并发访问此目录中的临时文件。脚本不使用其它方法确定直接使用的临时目录，但脚本间接调用的外部工具仍可能导致不安全的访问，而无法保证可靠。</p>
<h3 id="函数-shbuild_platform_detect"><a class="header" href="#函数-shbuild_platform_detect">函数 SHBuild_Platform_Detect</a></h3>
<p>　　通过参数指定的操作系统和体系结构名，并结合环境变量，确定平台名称，检查非空并返回。</p>
<p>　　当前支持的结果包括：</p>
<ul>
<li>MinGW64</li>
<li>MinGW32</li>
<li>MinGW_Clang64</li>
<li>MinGW_Clang32</li>
<li>MinGW_UCRT64</li>
<li>MinGW_ClangARM64</li>
<li>第一个参数指定的操作系统名</li>
</ul>
<p>　　当前 <code>Win32</code> 系统外的结果和 <code>SHBuild_CheckUName</code> 初始化 <code>SHBuild_Env_OS</code> 的结果一致。否则，处理如下：</p>
<ul>
<li>若环境变量 <code>MSYSTEM</code> 设置为 <code>MINGW64</code> 或 <code>MINGW32</code> ，结果对应为 <code>MinGW64</code> 或 <code>MinGW32</code> 。</li>
<li>否则，若操作系统名为 <code>Win32</code> ：
<ul>
<li>若体系结构为 <code>x86_64</code> ，则结果为 <code>MinGW64</code> 。</li>
<li>否则，结果为 <code>MinGW32</code> 。</li>
</ul>
</li>
<li>否则，结果为操作系统名。</li>
</ul>
<h3 id="函数-shbuild_preparebuild"><a class="header" href="#函数-shbuild_preparebuild">函数 SHBuild_PrepareBuild</a></h3>
<p>　　准备构建环境。初始化以下变量使之具有非空值：</p>
<ul>
<li><code>SHBuild_Env_TempDir</code></li>
<li><code>SHBuild_Env_Arch</code></li>
<li><code>SHBuild_Env_OS</code></li>
<li><code>SHBuild_Host_Arch</code></li>
<li><code>SHBuild_Host_OS</code></li>
</ul>
<h3 id="函数-shbuild_getbuildname"><a class="header" href="#函数-shbuild_getbuildname">函数 SHBuild_GetBuildName</a></h3>
<p>　　取用于进一步初始化构建路径的构建名称。</p>
<p>　　首先断言变量 <code>SHBuild_Env_Arch</code> 和 <code>SHBuild_Env_OS</code> 非空。结果为以变量 <code>SHBuild_Env_OS</code> 和 <code>SHBuild_Env_Arch</code> 的值作为参数调用函数 <code>SHBuild_Platform_Detect</code> 的结果。</p>
<h3 id="函数-shbuild_buildgch"><a class="header" href="#函数-shbuild_buildgch">函数 SHBuild_BuildGCH</a></h3>
<p>　　接受第一个参数指定的路径的头文件安装到第二个参数指定的路径下并使用第三个参数指定的命令行构建 GNU 预编译头。</p>
<h3 id="函数-shbuild_checkpch"><a class="header" href="#函数-shbuild_checkpch">函数 SHBuild_CheckPCH</a></h3>
<p>　　检查是否设置了非空的变量 <code>SHBuild_NoPCH</code> ，否则调用 <code>SHBuild_BuildGCH</code> 并生成 GNU 风格预编译头文件并设置内部变量 <code>SHBuild_IncPCH</code> 为合适的命令行选项用于包含生成的预编译头文件。</p>
<p>　　支持两个参数，同 <code>SHBuild_BuildGCH</code> 的前两个参数。</p>
<h3 id="函数-shbuild_2w"><a class="header" href="#函数-shbuild_2w">函数 SHBuild_2w</a></h3>
<p>　　接受 1 个表示路径的参数，调用 <code>cygpath</code> 转换 UNIX 路径到 Windows 路径。</p>
<p>　　当 <code>cygpath</code> 不存在时返回原路径。</p>
<h3 id="函数-shbuild_install"><a class="header" href="#函数-shbuild_install">函数 SHBuild_Install</a></h3>
<p>　　接受 2 个表示路径的参数，安装前者指定的文件到后者。</p>
<p>　　首先调用 <code>rsync</code> ，若失败调用 <code>cp</code> 。</p>
<p><strong>注意</strong> 防火墙可能导致 <code>rsync</code> 超时失败。</p>
<h3 id="函数-shbuild_installdir"><a class="header" href="#函数-shbuild_installdir">函数 SHBuild_InstallDir</a></h3>
<p>　　接受 2 个表示路径的参数，安装前者指定的目录到后者。</p>
<p>　　首先调用 <code>rsync</code> ，若失败调用 <code>cp</code> 。</p>
<p><strong>注意</strong> 防火墙可能导致 <code>rsync</code> 超时失败。</p>
<h3 id="函数-shbuild_install_exe"><a class="header" href="#函数-shbuild_install_exe">函数 SHBuild_Install_Exe</a></h3>
<p>　　接受 2 个表示路径的参数，安装前者指定的可执行文件到后者。</p>
<p>　　首先调用 <code>SHBuild_Install</code> ，然后在目标上设置可执行权限。</p>
<h3 id="函数-shbuild_install_hardlink"><a class="header" href="#函数-shbuild_install_hardlink">函数 SHBuild_Install_HardLink</a></h3>
<p>　　接受 2 个表示路径的参数，安装前者指定的文件到后者为硬链接。</p>
<p>　　首先删除目标，其次调用 Windows 命令解释器的 <code>mklink</code> ，若失败调用 <code>ln</code> 。</p>
<h3 id="函数-shbuild_install_hardlink_exe"><a class="header" href="#函数-shbuild_install_hardlink_exe">函数 SHBuild_Install_HardLink_Exe</a></h3>
<p>　　接受 2 个表示路径的参数，安装前者指定的可执行文件到后者为硬链接。</p>
<p>　　首先调用 <code>SHBuild_Install_HardLink</code> ，然后在目标上设置可执行权限。</p>
<p><strong>注意</strong> <code>mklink</code> 需要 Windows Vista 后的命令解释器(<code>cmd</code>) 的支持。硬链接需要文件系统（如 NTFS ）支持。</p>
<h3 id="函数-shbuild_install_link"><a class="header" href="#函数-shbuild_install_link">函数 SHBuild_Install_Link</a></h3>
<p>　　接受 2 个表示路径的参数，安装前者指定的可执行文件到后者为符号链接。</p>
<p>　　首先删除目标，其次调用 Windows 命令解释器的 <code>mklink</code> ，若失败调用 <code>ln</code> 。</p>
<p><strong>注意</strong> <code>mklink</code> 需要 Windows Vista 后的命令解释器(<code>cmd</code>) 的支持。符号链接需要文件系统（如 NTFS ）支持。权限不足可能导致 <code>mklink</code> 创建符号链接失败，可在组策略改变相关默认行为。在一些版本的系统上，可能需要<a href="https://support.microsoft.com/en-us/kb/2856739/en-us">进一步的配置</a>以通过链接执行文件。</p>
<h3 id="函数-shbuild_getsystemprefix"><a class="header" href="#函数-shbuild_getsystemprefix">函数 SHBuild_GetSystemPrefix</a></h3>
<p>　　按参数指定的平台名称字符串返回系统前缀字符串。</p>
<p>　　系统前缀用于在文件系统中安装部署。</p>
<p>　　通常系统前缀因为之前仍有非空的其它前缀（如 <code>SHBuild_SysRoot</code> 指定的值）而不是绝对路径的前缀。因此，系统前缀以 <code>/</code> 起始而不需要考虑所在的环境是否符合 FHS 的问题。</p>
<p>　　当前支持的结果包括：</p>
<ul>
<li>参数为 <code>MinGW64</code> 时，结果为 <code>/mingw64</code> 。</li>
<li>参数为 <code>MinGW32</code> 时，结果为 <code>/mingw32</code> 。</li>
<li>否则，结果为 <code>/usr</code> 。</li>
</ul>
<p>　　本函数的结果符合 <a href="Tools/../Sysroot.zh-CN.html">Sysroot</a> 中关于 Sysroot 的目录布局的约定。</p>
<h3 id="函数-shbuild_s2_prepare"><a class="header" href="#函数-shbuild_s2_prepare">函数 SHBuild_S2_Prepare</a></h3>
<p>　　初始化 <a href="Tools/../Sysroot.zh-CN.html">stage 2 Sysroot</a> 环境。</p>
<p>　　函数可使用一个参数作为变量 <code>SHBuild_SysRoot</code> 的默认值。</p>
<p>　　初始化这个变量后，断言其值非空，以其值作为创建目录，若指定的目录已存在则忽略。然后，初始化变量 <code>SHBuild_SystemPrefix</code>（参见 <code>Tools/Scripts/SHBuild-YSLib-build.txt</code> 的说明）。之后，初始化变量 <code>SR_Prefix</code> 的值为 <code>&quot;$SHBuild_SysRoot$SHBuild_SystemPrefix&quot;</code> 。</p>
<h3 id="函数-shbuild_s2_prepare_build"><a class="header" href="#函数-shbuild_s2_prepare_build">函数 SHBuild_S2_Prepare_Build</a></h3>
<p>　　初始化 stage 2 Sysroot 构建环境。</p>
<p>　　函数可使用一个参数。以这个参数调用 <code>SHBuild_S2_Prepare</code> ，然后导出变量 <code>SHBuild</code> 的值为 <code>&quot;$SR_Prefix/bin/SHBuild&quot;</code> 。</p>
<h2 id="toolsscriptsshbuild-common-optionssh"><a class="header" href="#toolsscriptsshbuild-common-optionssh">Tools/Scripts/SHBuild-common-options.sh</a></h2>
<p>　　被应用程序构建脚本包含的基础功能，提供默认的编译器和链接器命令行选项。</p>
<p>　　若某个变量提供默认值且执行脚本时没有非空值，则设置为脚本提供的默认值。</p>
<p>　　<strong>这个脚本是公开的工具</strong>，被 <code>Tools/install-sysroot.sh</code> 部署到安装路径下的 <code>bin</code> 目录下。</p>
<p>　　包含 <code>Tools/Scripts/SHBuild-common-toolchain.sh</code> 确定工具链。</p>
<p><strong>注意</strong> G++ 和 Clang++ 不完全兼容。以下部分变量通过 <code>Tools/Scripts/SHBuild-common-toolchain.sh</code> 中的例程判断 G++ 和 Clang ，并自动使用不同的选项默认值。因此直接通过名称和符号链接等方式伪装会失效而可能导致错误。</p>
<p>　　以下所有变量仅在外部环境设置为空或未设置时提供默认值，按顺序被指定。可在外部设置为非空值以避免被本脚本中的值覆盖。以下仅列出部分相对不容易变动的默认值，其它默认值参见脚本源代码。若不需要默认值，可以提前设置非空值或在 <code>.</code> 指令后直接设置其它（可能为空的）值。</p>
<h3 id="变量-shbuild_debug"><a class="header" href="#变量-shbuild_debug">变量 SHBuild_Debug</a></h3>
<p>　　默认值为空。</p>
<p>　　非空时，指定变量的值：</p>
<pre><code>CXXFLAGS_OPT_DBG='-O0 -g -D_GLIBCXX_DEBUG_PEDANTIC'
LDFLAGS_OPT_DBG=' '
</code></pre>
<h3 id="变量-c_cxxflags_gc"><a class="header" href="#变量-c_cxxflags_gc">变量 C_CXXFLAGS_GC</a></h3>
<p>　　C/C++ 编译器生成二进制节 GC 选项。</p>
<p>　　默认值为 <code>-fdata-sections -ffunction-sections</code> 。</p>
<p>　　设置后会被检查是否支持，参见下文。</p>
<h3 id="变量-ldflags_gc"><a class="header" href="#变量-ldflags_gc">变量 LDFLAGS_GC</a></h3>
<p>　　链接器生成二进制节 GC 选项。</p>
<p>　　默认值为 <code>-Wl,--gc-sections</code> 。</p>
<p>　　设置后会和 <code>C_CXXFLAGS_GC</code> 通过 <code>$CXX</code> 作为编译器编译链接简单程序测试是否支持。若不支持，此变量和 <code>C_CXXFLAGS_GC</code> 都会被置空。</p>
<p><strong>已知限制</strong> <a href="http://sourceforge.net/p/msys2/discussion/general/thread/2d6adff2/?limit=25">Windows 上的工具链可能缺乏 <code>/dev/null</code> 的必要支持</a>，因此此项检查使用的输出路径指定为 <code>/tmp/null</code> 。</p>
<h3 id="变量-c_cxxflags_pic"><a class="header" href="#变量-c_cxxflags_pic">变量 C_CXXFLAGS_PIC</a></h3>
<p>　　C 和 C++ 编译器共用的 PIC （ Position Independent Code ，位置无关代码）生成选项。</p>
<p>　　默认值在 Win32 上为空，其它平台上为 <code>-fPIC -fno-semantic-interposition</code> 。</p>
<p>　　用于保证生成的对象文件可被用于生成动态库。</p>
<h3 id="变量-ldflags_strip"><a class="header" href="#变量-ldflags_strip">变量 LDFLAGS_STRIP</a></h3>
<p>　　链接器剥离符号选项。</p>
<p>　　默认值为 <code>-s</code> 。</p>
<h3 id="变量-c_cxxflags_ext"><a class="header" href="#变量-c_cxxflags_ext">变量 C_CXXFLAGS_EXT</a></h3>
<p>　　指定 C/C++ 语言扩展的选项。</p>
<p>　　默认值和平台相关：若为 Win32 环境则为空，否则为 <code>-D_POSIX_C_SOURCE=200809L</code> 。</p>
<p><strong>注释</strong> 若实现环境没有提供适当的宏定义，YFramework 中使用 POSIX 平台文件系统 API 的实现要求不被满足而可能构建失败。</p>
<h3 id="变量-c_cxxflags_arch"><a class="header" href="#变量-c_cxxflags_arch">变量 C_CXXFLAGS_ARCH</a></h3>
<p>　　C 和 C++ 编译器共用的体系结构相关选项。</p>
<p>　　默认值为空。</p>
<p>　　不限制具体形式，使用 G++ 时可以是 <code>-march=native</code> 。</p>
<h3 id="变量-c_cxxflags_common"><a class="header" href="#变量-c_cxxflags_common">变量 C_CXXFLAGS_COMMON</a></h3>
<p>　　C 和 C++ 编译器共用的公共选项。</p>
<p>　　默认值为 <code>-pipe $C_CXXFLAGS_GC $C_CXXFLAGS_ARCH -pedantic-errors $C_CXXFLAGS_EXT</code> 。</p>
<h3 id="变量-c_cxxflags_opt_lv"><a class="header" href="#变量-c_cxxflags_opt_lv">变量 C_CXXFLAGS_OPT_LV</a></h3>
<p>　　C 和 C++ 编译器优化等级选项。</p>
<p>　　默认值为 <code>-O3</code> 。</p>
<h3 id="变量-c_cxxflags_warning"><a class="header" href="#变量-c_cxxflags_warning">变量 C_CXXFLAGS_WARNING</a></h3>
<p>　　C 和 C++ 编译器共用的警告命令行选项。</p>
<p>　　默认值包括以下列表中的内容：</p>
<ul>
<li><code>-Wall</code></li>
<li><code>-Wcast-align</code></li>
<li><code>-Wdeprecated</code></li>
<li><code>-Wdeprecated-declarations</code></li>
<li><code>-Wextra</code></li>
<li><code>-Wfloat-equal</code></li>
<li><code>-Wformat=2</code></li>
<li><code>-Winvalid-pch</code></li>
<li><code>-Wmissing-declarations</code></li>
<li><code>-Wmissing-include-dirs</code></li>
<li><code>-Wmultichar</code></li>
<li><code>-Wno-format-nonliteral</code></li>
<li><code>-Wredundant-decls</code></li>
<li><code>-Wshadow</code></li>
<li><code>-Wsign-conversion</code></li>
</ul>
<p>　　使用符合项目要求支持的 Clang++ 和 G++ 应支持这些选项。</p>
<h3 id="变量-c_cxxflags_impl_warning"><a class="header" href="#变量-c_cxxflags_impl_warning">变量 C_CXXFLAGS_IMPL_WARNING</a></h3>
<p>　　和特定实现相关的 C 和 C++ 编译器共用的警告命令行选项。</p>
<p>　　默认值包括若干特定实现的选项。</p>
<h3 id="变量-cxxflags_impl_warning"><a class="header" href="#变量-cxxflags_impl_warning">变量 CXXFLAGS_IMPL_WARNING</a></h3>
<p>　　和特定实现相关的 C++ 编译器警告命令行选项。</p>
<p>　　默认值包括若干特定实现的选项。</p>
<h3 id="变量-cxxflags_impl_common"><a class="header" href="#变量-cxxflags_impl_common">变量 CXXFLAGS_IMPL_COMMON</a></h3>
<p>　　和特定实现相关的 C++ 编译器一般命令行选项。</p>
<p>　　默认值包括若干特定实现的选项。</p>
<p>　　默认值按以下方式检查和指定线程参数：</p>
<ul>
<li>通过 <code>-dumpspecs</code> 的内容检查是否匹配 <code>mthreads:</code> 。若成功，编译器和链接器选项添加 <code>-mthreads</code> 。</li>
<li>否则，检查带有 <code>-mthread</code> 选项的构建。若（直接调用编译器驱动）构建通过，则链接器选项添加 <code>-mthreads</code> ，并检查编译。
<ul>
<li>若编译不通过，则编译器选项添加 <code>-D_MT</code> ，否则添加 <code>-mthreads</code> 。</li>
</ul>
</li>
<li>否则，若通过 <code>-dumpspecs</code> 的内容检查匹配 <code>no-pthread:</code> 且带有 <code>-pthread</code> 时无法构建，则保持编译器和链接器选项不变。</li>
<li>否则，编译器和链接器选项添加 <code>-pthread</code> 。</li>
</ul>
<p><strong>注意</strong> 当前不检查失败原因。参见函数 <code>SHBuild_GetTempDir</code> 的已知限制。</p>
<p>　　当前暂不支持判断其它环境。</p>
<h3 id="变量-cxxflags_impl_opt"><a class="header" href="#变量-cxxflags_impl_opt">变量 CXXFLAGS_IMPL_OPT</a></h3>
<p>　　和特定工具相关的 C++ 编译器优化命令行选项。</p>
<p>　　默认值包括若干特定实现的选项。</p>
<h3 id="变量-cflags_std"><a class="header" href="#变量-cflags_std">变量 CFLAGS_STD</a></h3>
<p>　　指定 C 标准的编译器命令行选项。</p>
<p>　　默认值为 <code>-std=c11</code> 。</p>
<h3 id="变量-cflags_warning"><a class="header" href="#变量-cflags_warning">变量 CFLAGS_WARNING</a></h3>
<p>　　C 编译器警告命令行选项。</p>
<p>　　默认值为 <code>$C_CXXFLAGS_WARNING $C_CXXFLAGS_IMPL_WARNING</code> 。</p>
<h3 id="变量-cxxflags_std"><a class="header" href="#变量-cxxflags_std">变量 CXXFLAGS_STD</a></h3>
<p>　　指定 C++ 标准的编译器命令行选项。</p>
<p>　　默认值为 <code>-std=c++11</code> 。</p>
<h3 id="变量-cflags_warning-1"><a class="header" href="#变量-cflags_warning-1">变量 CFLAGS_WARNING</a></h3>
<p>　　C 编译器警告命令行选项。</p>
<p>　　默认值包含以下列表中的内容：</p>
<ul>
<li>变量 <code>CFLAGS_WARNING</code> 的内容</li>
<li><code>-Wctor-dtor-privacy</code></li>
<li><code>-Wnon-virtual-dtor</code></li>
<li><code>-Woverloaded-virtual</code></li>
<li><code>-Wsign-promo</code></li>
<li>变量 <code>CXXFLAGS_IMPL_WARNING</code> 的内容</li>
</ul>
<h3 id="变量-cxxflags_opt_dbg"><a class="header" href="#变量-cxxflags_opt_dbg">变量 CXXFLAGS_OPT_DBG</a></h3>
<p>　　C++ 编译器优化和调试相关的命令行选项。在未设置非空的 <code>SHbuild_Debug</code> 时。</p>
<p>　　默认值包含以下列表中的内容：</p>
<ul>
<li>变量 <code>C_CXXFLAGS_OPT_LV</code> 的内容</li>
<li>变量 <code>CXXFLAGS_OPT_UseAssert</code> 没有被设置非空值时包含 <code>-NDEBUG</code></li>
<li>变量 <code>CXXFLAGS_IMPL_OPT</code> 的内容</li>
<li><code>-fomit-frame-pointer</code></li>
</ul>
<h3 id="变量-cflags"><a class="header" href="#变量-cflags">变量 CFLAGS</a></h3>
<p>　　C 编译器使用的命令行选项。</p>
<p>　　默认值为 <code>$CFLAGS_STD $C_CXXFLAGS_PIC $C_CXXFLAGS_COMMON $CFLAGS_WARNING $C_CXXFLAGS_COMMON_IMPL_ $CXXFLAGS_OPT_DBG</code> 。其中，<code>C_CXXFLAGS_COMMON_IMPL_</code> 是根据支持的编译器在内部定义的非公开变量。</p>
<p><strong>注意</strong> 当前和 C++ 编译器选项共用 <code>CXXFLAGS_OPT_DBG</code> 。</p>
<h3 id="变量-cxxflags"><a class="header" href="#变量-cxxflags">变量 CXXFLAGS</a></h3>
<p>　　C++ 编译器使用的命令行选项。</p>
<p>　　默认值为 <code>$CXXFLAGS_STD $C_CXXFLAGS_PIC $C_CXXFLAGS_COMMON $CXXFLAGS_WARNING $CXXFLAGS_IMPL_COMMON $C_CXXFLAGS_COMMON_IMPL_ $CXXFLAGS_OPT_DBG</code> 。其中，<code>C_CXXFLAGS_COMMON_IMPL_</code> 是根据支持的编译器在内部定义的非公开变量。</p>
<h3 id="变量-ldflags_opt_dbg"><a class="header" href="#变量-ldflags_opt_dbg">变量 LDFLAGS_OPT_DBG</a></h3>
<p>　　链接器优化和调试相关的命令行选项。在未设置非空的 <code>SHbuild_Debug</code> 时。</p>
<p>　　默认值为 <code>$LDFLAGS_STRIP $LDFLAGS_IMPL_OPT $LDFLAGS_GC</code> 。</p>
<h3 id="变量-ldflags"><a class="header" href="#变量-ldflags">变量 LDFLAGS</a></h3>
<p>　　链接器使用的命令行选项。</p>
<p>　　默认值依次包含以下内容：</p>
<ul>
<li>变量 <code>C_CXXFLAGS_PIC</code> 的内容。</li>
<li>和变量 <code>CXXFLAGS_IMPL_COMMON</code> 中等价的线程命令行选项。</li>
<li>变量 <code>LDFLAGS_OPT_DBG</code> 的内容。</li>
<li>可选的其它选项（参见以下 <code>Tools/Scripts/SHBuild-YSLib-common.txt</code> ）。</li>
</ul>
<p>　　默认使用 <code>-Wl,</code> 传递链接器特定的命令行。</p>
<h2 id="toolsscriptsshbuild-common-toolchainsh"><a class="header" href="#toolsscriptsshbuild-common-toolchainsh">Tools/Scripts/SHBuild-common-toolchain.sh</a></h2>
<p>　　被应用程序构建脚本包含的基础功能，提供默认的编译器和链接器等工具的名称。</p>
<p>　　支持 GCC/G++ 和 Clang/Clang++ 。</p>
<p>　　支持 <code>ar</code> 及与其兼容的工具 <code>gcc-ar</code>/<code>llvm-ar</code> 的自动检测。对 Clang++ 和 G++ ，分别使用 <code>llvm-ar</code> 和 <code>gcc-ar</code> 。</p>
<p>　　以下可在环境外部配置，在值确定后被导出：</p>
<ul>
<li><code>CC</code>
<ul>
<li>默认值为 <code>gcc</code> 。</li>
</ul>
</li>
<li><code>CXX</code>
<ul>
<li>默认值为 <code>g++</code> 。</li>
</ul>
</li>
<li><code>AR</code>
<ul>
<li>默认值为变量 <code>CXX</code> 指定的 C++ 编译器确定的自动检测结果；若非 Clang++ 和 G++ ，则使用 <code>ar</code> 。</li>
</ul>
</li>
<li><code>ARFLAGS</code>
<ul>
<li>默认值为 <code>rcs</code> 。</li>
</ul>
</li>
<li><code>LD</code>
<ul>
<li>默认值为变量 <code>CXX</code> 的值。</li>
</ul>
</li>
</ul>
<p>　　<strong>这个脚本是公开的工具</strong>，被 <code>Tools/install-sysroot.sh</code> 部署到安装路径下的 <code>bin</code> 目录下。</p>
<h3 id="函数-shbuild_checkcompiler"><a class="header" href="#函数-shbuild_checkcompiler">函数 SHBuild_CheckCompiler</a></h3>
<p>　　尝试调用以参数指定的编译器，并按检查结果选择和输出参数的值。</p>
<p>　　检查编译器时，首先排除参数指定的编译器不可执行的情形，然后通过尝试编译以参数指定的源程序进行。前四参数分别指定编译器的路径、尝试编译的源程序、检查成功时输出的结果和检查失败时输出的结果，之后的参数指定编译选项。</p>
<p>　　检查前断言前两个参数非空。指定编译选项的参数为空时，第三和第四参数可能不提供或为空。</p>
<p>　　结果是以下之一：</p>
<ul>
<li>空值（第一参数指定不可执行的路径）</li>
<li>第三参数（检查成功时的结果）</li>
<li>第四参数（检查失败时的结果）</li>
</ul>
<h3 id="函数-shbuild_checkcc"><a class="header" href="#函数-shbuild_checkcc">函数 SHBuild_CheckCC</a></h3>
<p>　　尝试调用参数指定的编译器以检查 C 编译器风格。结果是以下之一：</p>
<ul>
<li>空值（不支持的编译器）</li>
<li><code>Clang</code></li>
<li><code>GCC</code></li>
</ul>
<h3 id="函数-shbuild_checkcxx"><a class="header" href="#函数-shbuild_checkcxx">函数 SHBuild_CheckCXX</a></h3>
<p>　　尝试调用参数指定的编译器以检查 C++ 编译器风格。结果是以下之一：</p>
<ul>
<li>空值（不支持的编译器）</li>
<li><code>Clang++</code></li>
<li><code>G++</code></li>
</ul>
<h2 id="toolsscriptsshbuild-self-hostsh"><a class="header" href="#toolsscriptsshbuild-self-hostsh">Tools/Scripts/SHBuild-self-host.sh</a></h2>
<p>　　<a href="Tools/SHBuild.zh-CN.html">SHBuild</a> 自举测试用脚本。</p>
<p>　　使用 SHBuild 编译并静态链接构建 SHBuild 。和 stage 1 SHBuild 类似，直接使用 YSLib 源文件。</p>
<h2 id="toolsscriptsshbuild-self-host-dllsh"><a class="header" href="#toolsscriptsshbuild-self-host-dllsh">Tools/Scripts/SHBuild-self-host-DLL.sh</a></h2>
<p>　　<a href="Tools/SHBuild.zh-CN.html">SHBuild</a> 自举测试用脚本。</p>
<p>　　使用 SHBuild 编译并动态链接构建 SHBuild 。依赖 <code>/usr/lib</code> 中存在的 YFramework 和 YBase 动态库文件。</p>
<h2 id="toolsscriptsshbuild-yslibsh"><a class="header" href="#toolsscriptsshbuild-yslibsh">Tools/Scripts/SHBuild-YSLib.sh</a></h2>
<p>　　作为 stage 1 SHBuild 公共配置脚本被不同的 stage 1 构建脚本包含。</p>
<p>　　包含脚本依次执行：</p>
<ul>
<li>初始化变量 <a href="Tools/../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><code>SHBuild_ToolDir</code></a> 。</li>
<li>初始化变量 <a href="Tools/../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><code>YSLib_BaseDir</code></a> 。</li>
<li>初始化变量 <code>SHBuild_PCH_stdinc_h</code> 。</li>
<li>包含脚本 Tools/Scripts/SHBuild-common-options.sh 。</li>
<li>赋值变量 <code>INCLUDE_PCH</code> 为版本库的 YBase/include/stdinc.h 。</li>
<li>赋值变量 <code>INCLUDES</code> 为版本库目录下的适合作为编译器选项使用的头文件目录列表。</li>
<li>定义函数。</li>
</ul>
<p><strong>注意</strong> 这个脚本包含 <code>INC_SHBuild_YSLib</code> 守卫变量检查，默认重复包含只被执行一次。</p>
<h3 id="变量-shbuild_pch_stdinc_h"><a class="header" href="#变量-shbuild_pch_stdinc_h">变量 SHBuild_PCH_stdinc_h</a></h3>
<p>　　预编译头文件名称，默认为 &quot;<code>stdinc.h</code>&quot; 。</p>
<h3 id="函数-shbuild_s1_initializepch"><a class="header" href="#函数-shbuild_s1_initializepch">函数 SHBuild_S1_InitializePCH</a></h3>
<p>　　初始化 stage 1 使用的预编译头文件。</p>
<pre><code>SHBuild_CheckPCH &quot;$INCLUDE_PCH&quot; &quot;$SHBuild_PCH_stdinc_h&quot;
</code></pre>
<h2 id="toolsscriptsshbuild-yslibtxt"><a class="header" href="#toolsscriptsshbuild-yslibtxt">Tools/Scripts/SHBuild-YSLib*.txt</a></h2>
<p>　　构建 YSLib 用的 NPLA1 脚本，包含以下文件：</p>
<ul>
<li>Tools/Scripts/SHBuild-YSLib-common.txt ：被 <code>Tools/Scripts/SHBuild-YSLib-build.txt</code> 加载的 NPLA1 脚本。</li>
<li>Tools/Scripts/SHBuild-YSLib-build.txt ：使用 SHBuild 构建 debug 或 release 配置的 YBase 和 YFramework 库的 NPLA1 脚本，被 <code>Tools/install-sysroot.sh</code> 调用，其中 SHBuild 默认为 stage 1 SHBuild 。</li>
</ul>
<p>　　调用方式详见 <a href="Tools/SHBuild.zh-CN.html">stage 1 SHBuild 中关于 NPL 支持的说明</a>。</p>
<p>　　可通过外部环境变量配置脚本行为。</p>
<h3 id="版本控制系统支持"><a class="header" href="#版本控制系统支持">版本控制系统支持</a></h3>
<p>　　脚本以相同的方式检查和识别版本控制系统。</p>
<p>　　以下环境变量提示使用 Mercurial 或 Git ：</p>
<ul>
<li>若<a href="Tools/../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量 <code>SHBuild_VCS_hg</code></a> 非空，则检查 <code>hg</code> 命令可用。</li>
<li>否则，若<a href="Tools/../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量 <code>SHBuild_VCS_git</code></a> 非空，则检查 <code>git</code> 命令可用。</li>
<li>否则，依次检查 <code>hg</code> 和 <code>git</code> 命令可用，若 <code>hg</code> 可用则不再检查 <code>git</code> 。</li>
</ul>
<p>　　命令可用需要满足以下条件：</p>
<ul>
<li>被检查的命令应在 <code>$PATH</code> 中。
<ul>
<li>若在 Windows 中使用 shell ，可能需要提前设置环境以确保继承环境变量。
　　* <strong>注意</strong> MSYS2 提供的 <code>mercurial</code> 包的可执行文件是脚本而不是可执行文件，不被 NPLA1 脚本调用的 Windows 命令行支持。
　　* <strong>注释</strong> 不使用 <code>HG</code> 环境变量，因为可能设置为不被支持的 <code>hg</code> 程序路径。事实上，MSYS2 的包 <code>mercurial</code> 安装到 <code>/etc/profile.d/mercurial.sh</code> 设置 <code>HG</code> 为脚本，覆盖从其它位置继承的 <code>hg.exe</code> 。</li>
</ul>
</li>
<li>且当前工作目录求在对应的版本库中，同时确定仓库的顶层目录路径。
<ul>
<li>对 Git ，要求存在工作区。</li>
</ul>
</li>
</ul>
<h2 id="toolsscriptsshbuild-yslib-commontxt"><a class="header" href="#toolsscriptsshbuild-yslib-commontxt">Tools/Scripts/SHBuild-YSLib-common.txt</a></h2>
<p>　　<code>Tools/Scripts/SHBuild-YSLib-common.txt</code> 包含一些公共的库，包括支持类似 <code>Tools/Scripts/SHBuild-common-options.sh</code> 和 <code>Tools/Scripts/SHBuild-common-toolchain.sh</code> 的选项以环境变量的方式配置，但 C 编译器相关的选项除外（不使用而被忽略）。</p>
<p>　　除关于 <a href="Tools/../Development.zh-CN.html#shell-%E8%84%9A%E6%9C%AC">shell 脚本</a>和 <a href="Tools/../Development.zh-CN.html#npla1-%E8%84%9A%E6%9C%AC">NPLA1 脚本</a>之间的一般差异外，与 <code>Tools/Scripts/SHBuild-common-options.sh</code> 和 <code>Tools/Scripts/SHBuild-common-toolchain.sh</code> 的不同为：</p>
<ul>
<li>通过调用函数进入<strong>构建环境变量检测</strong>并在之后进入回调函数中构建。
<ul>
<li>按需初始化变量。构建环境变量检测可能延迟访问以避免不必要初始化的值。配置时为确定变量的默认值的检查的调用顺序可能不同。</li>
<li>使用 debug 模式时，<code>CXXFLAGS_OPT_DBG</code> 设置为 <code>-O0 -g -D_GLIBCXX_DEBUG_PEDANTIC</code> ，不再被环境变量覆盖。</li>
<li>生成变量默认值的选项之间的空白符可能不同（通常可确保为一个空格）。</li>
<li>附加支持构建应用的配置，在导出的变量的默认值中添加扩展的选项（参见以下相关说明）替换 shell 脚本中指定的默认值（可影响其它默认值）。</li>
<li>附加检查 <a href="https://github.com/google/sanitizers/wiki">sanitizer</a> 。参见以下相关章节的说明。</li>
</ul>
</li>
<li>支持更多变量和默认值。除非另行指定，这些变量在构建环境变量检测中使用。参见以下各节。</li>
<li>提供部分和 shell 脚本不同的函数，详见版本库中的 <code>doc/NPL.txt</code> 。</li>
</ul>
<p>　　这个脚本被 <code>Tools/Scripts/SHBuild-YSLib-build.txt</code> 加载，并被 <code>Tools/install-sysroot.sh</code> 间接调用。</p>
<p>　　脚本支持外部调用这个脚本的命令行设置变量的默认值，以覆盖直接指定构建环境变量检测确定的选项，如：</p>
<pre><code>CXX=clang++ CXXFLAGS='-std=c++11 -O2' Tools/install-sysroot.sh
</code></pre>
<p><strong>警告</strong> 使用预编译头选项和缺陷同 <a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-buildsh"><code>Tools/Scripts/SHBuild-build.sh</code></a> 。其中的特性未指定使用 shell 实现，和后者可能存在 shell 环境中可见的差异。</p>
<p>　　<strong>这个脚本是公开的工具</strong>，被 <code>Tools/install-sysroot.sh</code> 部署到安装路径下的 <code>var/NPLA1</code> 目录下。</p>
<h3 id="变量-ldflags_dyn_base"><a class="header" href="#变量-ldflags_dyn_base">变量 LDFLAGS_DYN_BASE</a></h3>
<p>　　指定动态库基础链接选项。</p>
<p>　　默认值和平台相关：若为 Win32 环境则使用 <code>-shared -Wl,--dll</code> ，否则为 <code>-shared</code> 。</p>
<h3 id="变量-ldflags_dyn_extra"><a class="header" href="#变量-ldflags_dyn_extra">变量 LDFLAGS_DYN_EXTRA</a></h3>
<p>　　指定动态库附加链接选项。</p>
<p>　　默认值等价于 <code>-Wl,--no-undefined,--dynamic-list-data,--dynamic-list-cpp-new,--dynamic-list-cpp-typeinfo</code> 。</p>
<h3 id="变量-ldflags_dyn"><a class="header" href="#变量-ldflags_dyn">变量 LDFLAGS_DYN</a></h3>
<p>　　指定动态库链接选项。</p>
<p>　　默认值为 <code>$LDFLAGS_DYN_BASE $LDFLAGS_DYN_EXTRA</code> 。</p>
<h3 id="变量-libs_rpath"><a class="header" href="#变量-libs_rpath">变量 LIBS_RPATH</a></h3>
<p>　　用于指定在运行时 ELF 映像需要的动态库的路径的链接器选项。</p>
<p>　　在 Win32 默认不设置，其它平台默认值为 <code>-Wl,-rpath,'\$ORIGIN:\$ORIGIN/../lib'</code> 。</p>
<h3 id="变量-libpfx"><a class="header" href="#变量-libpfx">变量 LIBPFX</a></h3>
<p>　　库前缀。</p>
<p>　　在 Win32 默认不设置，其它平台默认值为 <code>lib</code> 。</p>
<h3 id="变量-dsosfx"><a class="header" href="#变量-dsosfx">变量 DSOSFX</a></h3>
<p>　　动态库文件名后缀。</p>
<p>　　在 Win32 默认值为 <code>.dll</code> ，其它平台默认值为 <code>.so</code> 。</p>
<h3 id="变量-exesfx"><a class="header" href="#变量-exesfx">变量 EXESFX</a></h3>
<p>　　可执行文件名后缀。</p>
<p>　　在 Win32 默认值为 <code>.exe</code> ，其它平台默认不设置。</p>
<h3 id="sanitizer-检查支持"><a class="header" href="#sanitizer-检查支持">Sanitizer 检查支持</a></h3>
<p>　　构建环境变量检测支持 sanitizer ：若在变量 <code>CFLAGS</code>、<code>CXXFLAGS</code>、<code>LDFLAGS</code> 或 <code>SHBuild_CXXFLAGS</code> 中包含启用被支持的 sanitizer 的选项 （以 <code>-fsanitizer=address</code> 起始），配置最终在 <code>CFLAGS</code>、<code>CXXFLAGS</code> 和 <code>LDFLAGS</code> 最后添加自动调整的选项。</p>
<p>　　构建配置支持 ASan、TSan、MSan、UBSan 和 LSan 。Sanitizer 自身支持的系统和编译器详见 sanitizer 的文档。</p>
<p>　　ASan 使用的选项要求和建议参见 <a href="https://github.com/google/sanitizers/wiki/AddressSanitizer#faq">FAQ</a> 。</p>
<p><strong>注意</strong> <a href="https://gcc.gnu.org/legacy-ml/gcc/2014-10/msg00006.html">GCC 不支持 MSan</a> 。MSan 要求标准库<a href="https://github.com/google/sanitizers/wiki/MemorySanitizerLibcxxHowTo">使用带 MSan 的选项构建</a>，否则<a href="https://github.com/google/sanitizers/issues/542">会有假阳性结果</a>。</p>
<p><strong>注意</strong> 具体调整的选项参见脚本具体实现，不保持构建版本之间稳定。* <strong>注意</strong> 构建脚本不保证构建的二进制程序的具体可用性。构建的程序可能因为程序及 sanitizer 实现的缺陷运行时出错，可能另需具体排查原因修复。</p>
<h3 id="扩展选项的默认值"><a class="header" href="#扩展选项的默认值">扩展选项的默认值</a></h3>
<p>　　变量 <code>LDFLAGS</code> 的默认值依次包含：</p>
<ul>
<li>和 shell 脚本中相同的默认值。</li>
<li>生成可执行程序时且要求按需调整链接器参数时，附加的值：
<ul>
<li>当需要生成 Win32 子系统程序时，附加 <code>-mwindows</code> 。</li>
</ul>
</li>
<li>构建动态可执行程序时，变量 <code>LIBS_RPATH</code> 的内容。</li>
<li>构建动态库或应用时，变量 <code>LDFLAGS_DYN</code> 的内容。</li>
</ul>
<h3 id="shbuild-附加构建选项环境变量"><a class="header" href="#shbuild-附加构建选项环境变量">SHBuild 附加构建选项环境变量</a></h3>
<p>　　若回调函数中调用 SHBuild 构建，可在此之前设置<strong>扩展环境变量</strong>并调用函数 <code>SHBuild_Extend_CallVariables</code> 以更新被 SHBuild 使用的环境变量 <code>LDFLAGS</code> 和 <code>LIBS</code> 的值。这些影响 SHBuild 工具调用构建工具的命令行的 <strong>SHBuild 附加构建选项环境变量</strong>，包括：</p>
<ul>
<li><code>SHBuild_CFLAGS</code></li>
<li><code>SHBuild_CXXFLAGS</code></li>
<li><code>SHBuild_LDFLAGS</code></li>
<li><code>SHBuild_LIBS</code></li>
</ul>
<p>　　除非另行指定，SHBuild 附加构建选项环境变量的默认值为空，不被脚本设置。</p>
<h3 id="其它函数和可在外部设置的其它变量"><a class="header" href="#其它函数和可在外部设置的其它变量">其它函数和可在外部设置的其它变量</a></h3>
<p>　　详见版本库中的 <code>doc/NPL.txt</code> 。</p>
<p>　　其它变量不被构建环境变量检测访问，而通过函数调用生效，如 <code>SHBuild_Extend_CallVariables</code> 。</p>
<h2 id="toolsscriptsshbuild-yslib-buildtxt"><a class="header" href="#toolsscriptsshbuild-yslib-buildtxt">Tools/Scripts/SHBuild-YSLib-build.txt</a></h2>
<p>　　这个脚本当前包括和安装相关的流程，实现 <code>Tools/install-sysroot.sh</code> 在 stage 1 SHBuild 构建后的主要逻辑。</p>
<p>　　脚本使用 <code>Tools/Scripts/SHBuild-YSLib-common.txt</code> 中提供的一些函数。</p>
<p>　　脚本支持 <code>SHBuild_</code> 为前缀的环境变量指定构建和部署目标：</p>
<ul>
<li><code>SHBuild_UseDebug</code> 非空时启用构建和安装 debug 配置的库。</li>
<li><code>SHBuild_UseRelease</code> 非空时启用构建和安装 release 配置的库。</li>
<li><code>SHBuild_NoStatic</code> 非空时跳过静态库构建。</li>
<li><code>SHBuild_NoDynamic</code> 非空时跳过动态库构建。</li>
<li><code>SHBuild_No3rd</code> 非空时跳过第三方库安装。
<ul>
<li>对<a href="Tools/../Development.zh-CN.html#%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96%E9%A1%B9">外部依赖项</a>中的库，只安装启用的配置决定的必要的外部依赖。启用的配置由 <code>SHBuild_UseDebug</code> 和 <code>SHBuild_UseRelease</code> 指定。</li>
</ul>
</li>
<li><code>SHBuild_NoDev</code> 非空时跳过可选的开发工具构建和安装。</li>
<li><code>SHBuild_Rebuild_S1</code> 非空时跳过文件存在性检查，总是重新构建 stage 1 SHBuild 。</li>
<li><code>SHBuild_NoDev</code> 非空时跳过 stage 2 SHBuild 后的开发工具构建和安装。</li>
</ul>
<p>　　以下配置行为的环境变量（其中 <code>SS</code> 表示 SHBuild Settings ）被支持：</p>
<ul>
<li><code>SS_DebugEnv</code> 值非空时启用脚本执行时系统环境相关的调试输出，当前包括：
<ul>
<li>对环境变量修改时输出修改的变量名和对应的值。</li>
</ul>
</li>
<li><code>SS_Verbose</code> 值非空时启用详细消息输出，当前包括：
<ul>
<li>在 <code>LDFLAGS</code> 变量中附加 <code>-mwindows</code> 时提示。</li>
</ul>
</li>
</ul>
<p>　　以下构建时的中间变量可被外部配置，当外部没有配置或为空值时使用默认值：</p>
<ul>
<li><code>SHBuild_SystemPrefix</code> ：系统前缀，在 Sysroot 根路径下决定安装路径。
<ul>
<li>默认值由脚本 <code>Tools/Scripts/SHBuild-YSLib-common.txt</code> 中的函数的调用确定：同 <code>SHBuild_GetSystemPrefix (SHBuild_Platform_Detect SHBuild_Host_OS SHBuild_Host_Arch)</code> 的结果。</li>
<li>脚本 <code>Tools/Scripts/SHBuild-common.sh</code> 中提供 shell 脚本的等价调用：<code>$(SHBuild_GetSystemPrefix (SHBuild_Platform_Detect &quot;$SHBuild_Host_OS&quot; &quot;$SHBuild_Host_Arch&quot;))</code> 。</li>
</ul>
</li>
<li><code>SHBuild_YF_Libs_freetype</code> ：freetype 库链接参数。
<ul>
<li>默认值为 <code>-lfreetype</code> 或 <code>pkg-config --libs freetype2</code> 的输出结果。
<ul>
<li>其中存在 Sysroot <code>libfreetype.a</code> 时默认值为前者。</li>
</ul>
</li>
</ul>
</li>
<li><code>SHBuild_YF_Libs_FreeImage</code> ：FreeImage 库链接参数。
<ul>
<li>默认值为 <code>-lFreeImaged</code> 或 <code>-lFreeImage</code> ，对应 debug 和非 debug 配置。</li>
</ul>
</li>
</ul>
<p>　　<code>Tools/Scripts/SHBuild-YSLib-build.txt</code> 也可能使用其它变量用于传递参数给被调用的命令，包括一些 <code>SHBuild</code> 预期的变量；后者作为公开接口，但<strong>其具体含义和使用不保证在不同版本间稳定</strong>。</p>
<p>　　在 stage 1 构建时，接受以下环境变量：</p>
<ul>
<li><code>INCLUDES_freetype</code> 指定覆盖包含路径的编译器命令行选项。
<ul>
<li>默认值以 <code>-I</code> 起始，使用版本库目录下的 <code>3rdparty/freetype/include</code> 目录带有适当引号的完整路径。</li>
</ul>
</li>
<li><a href="Tools/../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量 <code>SHBuild_VCS_hg</code> 或 <code>SHBuild_VCS_git</code></a> 指定构建时的版本控制系统，作用参见以下说明。</li>
</ul>
<p>　　在 stage 2 构建时接受以下外部环境变量（部分被 SHBuild 直接以环境变量的方式接受）：</p>
<ul>
<li><code>INCLUDES</code> ：包含路径，和非 SHBuild 中的 <code>Makefile</code> 惯用法含义类似。</li>
<li><code>LDFLAGS</code> ：链接命令行选项。</li>
<li><code>LIBS</code> ：作为命令行选项的链接时使用的库路径。</li>
<li><code>LIBS_RPATH</code> ：非 Windows 平台使用的 <code>rpath</code> 路径。</li>
<li>SHBuild 附加构建选项环境变量：参见 Tools/Scripts/SHBuild-YSLib-common.txt 。其中变量 <code>SHBuild_CXXFLAGS</code> 同时作用在预编译头构建。</li>
</ul>
<h3 id="版本字符串"><a class="header" href="#版本字符串">版本字符串</a></h3>
<p>　　在 stage 1 构建 YFramework 前，通过选择的版本控制系统指定确定版本字符串，可在被构建的 YFramework 库中引用。</p>
<p>　　确定版本字符串时，检查对应的命令，具体方式详见以上关于版本控制系统支持的描述。若检查都失败，则版本字符串为空串。否则，使用第一个检查成功的命令生成对应的版本字符串。</p>
<p><strong>已知限制</strong> 若使用 <code>git</code> 生成版本字符串，当前同时依赖 <code>sed</code> 命令。</p>
<p>　　若版本字符串非空，则通过宏定义的方式参与之后的构建。当前影响以下源文件所在的翻译单元：</p>
<ul>
<li><code>YFramework/source/YSLib/Core/YCoreUtilities.cpp</code></li>
</ul>
<p>　　在构建前，若被影响的上述翻译单元已被构建，在生成目录中对应的（以 <code>.d</code> 为扩展名的）依赖文件被修改，以添加对版本控制系统中的特定文件的依赖。这能使最新的版本控制系统的修改影响生成的目标代码，而无需手动修改这些翻译单元的源文件。</p>
<p><strong>已知限制</strong> 当前自动更新依赖的实现同时依赖 <code>sed -i</code> 命令。</p>
<h2 id="toolsscriptsshbuild-buildapptxt"><a class="header" href="#toolsscriptsshbuild-buildapptxt">Tools/Scripts/SHBuild-BuildApp.txt</a></h2>
<p>　　NPLA1 应用程序构建脚本。可利用此工具脚本调用 SHBuild 构建特定<em>配置(configuration)</em> 下使用 YSLib 库和基础环境开发的应用程序。</p>
<p>　　<strong>这个脚本是公开的工具</strong>，被 <code>Tools/install-sysroot.sh</code> 部署到安装路径下的 <code>var/NPLA1</code> 目录下。</p>
<h3 id="基本原理"><a class="header" href="#基本原理">基本原理</a></h3>
<p>　　<strong>配置</strong>是特定用途的一组程序输出的集合。常见软件配置可以区分目标平台，是否为调试配置等。</p>
<p>　　脚本通过设置特定的环境变量并调用 SHBuild 递归扫描指定目录完成构建。其中调用命令由环境变量 <code>SHBuild</code> 指定。若变量 <code>SHBuild</code> 为空，则假定使用脚本程序在 Sysroot 中，由 Sysroot 的布局确定的 SHBuild 的位置作为变量 <code>SHBuild</code> 的默认值。</p>
<p>　　脚本支持区分 debug 和非 debug 配置以及静态和 DLL 配置。详见以下说明。</p>
<p>　　debug 配置总称 debug 模式。非 debug 配置总称 release 模式。</p>
<h3 id="调用方式"><a class="header" href="#调用方式">调用方式</a></h3>
<p>　　无参数调用时，显示帮助文本。以第一参数指定<strong>配置名称</strong>，执行脚本直接一次性配置后构建。之后可选的其它参数被脚本传递给 SHBuild ，详见以下的操作说明。</p>
<h3 id="使用须知"><a class="header" href="#使用须知">使用须知</a></h3>
<p>　　脚本依赖 Sysroot 。</p>
<p>　　这个脚本被 <code>Tools/Scripts/SHBuild-BuildPkg.sh</code> 调用。</p>
<p>　　当前只支持构建，不支持部署。</p>
<p>　　构建时调用的工具链命令行及配置详见 <code>Tools/Scripts/SHBuild-YSLib-common.txt</code> 的说明。</p>
<p>　　需要先确保源代码可访问。<strong>注意</strong>源代码目录会被递归扫描，建议在目录中只包含所有需要构建的源文件或被包含的文件。</p>
<h3 id="操作说明"><a class="header" href="#操作说明">操作说明</a></h3>
<p>　　一般步骤：</p>
<ul>
<li>新建一个 GNU bash 脚本（以下称为<em>用户构建脚本</em> ），调用此脚本（若无法在 <code>PATH</code> 找到，需要使用完整路径）。</li>
<li>以源代码所在目录的路径作为参数，执行通过此脚本包含的 <code>SHBuild_BuildApp</code> 函数，等待构建完成。</li>
<li>直接包含后的脚本仍可使用无参数调用用户构建脚本查看选项和说明。</li>
</ul>
<p>　　简化操作：也可以不创建用户构建脚本，直接在命令行中执行，例子见<a href="Tools/../GettingStarted.zh-CN.html">入门</a>。</p>
<p>　　若有必要，在调用本脚本之前设置 <code>SHBuild_BuildDir</code> 变量为指定输出文件所在的目录的完整路径，如：</p>
<pre><code>export SHBuild_BuildDir=$(dirname &quot;$0&quot;`/../build)
</code></pre>
<p>　　上述命令行指定相对于用户构建脚本上一层目录的 <code>build</code> 子目录下作为基准输出路径。若不显式设置此变量，工具脚本会指定其默认值为用户构建脚本所在的目录。</p>
<p>　　调用本脚本。脚本会自动加入必要的参数调用 SHBuild ，传递的参数依次具体如下：</p>
<ul>
<li>中间变量 <code>SHBOPT</code> 的值，包括根据配置决定的目录设置选项、<code>-xid,include -xmode,2</code> 以及用户在脚本命令行指定的剩余选项 <code>SHBOPT_BASE</code> 。</li>
<li>传递给本脚本的配置名称以外的可选参数。</li>
<li><code>SHBuild_BuildApp</code> 的值，用于编译器的库配置（包含路径以及使用 DLL 需要的宏定义 <code>-DYF_DLL -DYB_DLL</code> ），由脚本根据静态或动态库配置自动确定，无需重复输入类似选项。</li>
</ul>
<p><strong>特别注意</strong> 脚本执行<strong>以输出基准路径作为当前工作目录</strong>，需要以此为基准指定源文件路径（ <code>SHBuild</code> 使用的 <code>SRCPATH</code> 参数）。</p>
<p>　　通过脚本命令行间接传递给 <code>SHBuild</code> 的参数 <code>SHBOPT_BASE</code> 以及函数 <code>SHBuild_BuildApp</code> 的参数都可以进一步对构建过程进行调整，如 <code>-xj,2</code> 指定 2 个并行线程构建。</p>
<p><strong>注意</strong> 以 SHBuild 作为 NPLA1 脚本解释器时，传递的参数可能会被 SHBuild 截获，而不被继续传递给 脚本中调用的 SHBuild 。为避免这种情形，在 <code>-xcmd,RunNPLFile</code> 和本的脚本文件名选项后，可加上 <code>--</code> 分隔其余命令行参数。</p>
<h3 id="配置设置"><a class="header" href="#配置设置">配置设置</a></h3>
<p>　　传递给 SHBuild 指定使用 <code>.配置名称</code> 相对路径（无需另外指定 <code>-xd,</code> 参数）。如 <code>-cdebug</code> 指定输出路径为 <code>.debug</code> 。省略此项默认配置名为 <code>shbuild</code> 。</p>
<p>　　脚本根据以下规则自动检测配置：</p>
<ul>
<li>若配置名称以 <code>debug</code> 起始，或环境变量的 <code>SHBuild_Debug</code> 值非空，则视为使用 debug 配置。</li>
<li>若配置名称以 <code>static</code> 结束，活环境变量 <code>SHBuild_Static</code> 的值非空，则视为使用 static 配置。</li>
</ul>
<h3 id="环境变量-2"><a class="header" href="#环境变量-2">环境变量</a></h3>
<p>　　环境变量 <code>SHBuild_Debug</code> 和 <code>SHBuild_Static</code> 可按上述自动检测配置过程指定配置类型。</p>
<p>　　默认情况下，release 配置会在链接器命令行加入 <code>-mwindows</code> ，<a href="Tools/../Prerequisitions.zh-CN.html">和 debug 配置编译的程序行为不保证相同</a>。设置非空变量 <code>SHBuild_NoAdjustSubsystem</code> 禁用此行为。</p>
<p>　　脚本使用包含 YSLib 库的编译器命令行。脚本已经导出了用于链接器的包含使用 YSLib 库命令行参数的变量 <code>LDFLAGS</code> 和 <code>LIBS</code> 。若有必要，可设置 SHBuild 附加构建选项环境变量（参见 Tools/Scripts/SHBuild-YSLib-common.txt ）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="准备-6"><a class="header" href="#准备-6">准备</a></h1>
<p>　　在开始教程前，掌握以下知识：</p>
<ul>
<li><a href="GettingStarted.zh-CN.html">入门</a></li>
</ul>
<p>　　并对以下内容有基本了解：</p>
<ul>
<li><a href="Development.zh-CN.html">开发说明</a></li>
</ul>
<h1 id="内容目录"><a class="header" href="#内容目录">内容目录</a></h1>
<ul>
<li><a href="Tutorial/Overview.zh-CN.html">综述</a></li>
<li><a href="Tutorial/GUI.zh-CN.html">GUI 应用开发</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基础约定"><a class="header" href="#基础约定">基础约定</a></h1>
<h2 id="关于头文件的补充说明"><a class="header" href="#关于头文件的补充说明">关于头文件的补充说明</a></h2>
<p>　　在<a href="Tutorial/../GettingStarted.zh-CN.html">入门</a>中已经解释了头文件宏的使用。</p>
<p>　　公开的头文件宏的命名是模块路径的直接应用：替换 <code>::</code> 为 <code>_</code> ，加上前缀 <code>YFM_</code> 或 <code>YFM_平台名</code> 。</p>
<p>　　这些宏名直接定义在各个 <code>include</code> 目录的 <code>YModules.h</code> 中。而头文件 <code>&lt;YSBuild.h&gt;</code> 则包含了一系列的 <code>YModules.h</code> 和其它模块的头文件，因此可以直接包含它来简化使用。</p>
<h2 id="命名空间-1"><a class="header" href="#命名空间-1">命名空间</a></h2>
<p>　　YSLib 中不同的次级子项目引入不同的命名空间。</p>
<p>　　关于每个顶级子项目下不同的命名空间参见 <code>doc/YBase.txt</code> 和 <code>doc/YFramework.txt</code> 以及 Doxygen 生成的文档。</p>
<p><strong>注意</strong> 在以下讨论中，若没有特别说明，所有非宏名的标识符都在 <code>namespace YSLib</code> 中。</p>
<p>　　注意避免命名空间使用冲突。除非是在一个很有限的块作用域内，一般而言，<code>using namespace std;</code> 总是不被推荐的，但 <code>using namespace YSLib;</code> 在<strong>非头文件</strong>中则是被允许的。</p>
<p>　　在 YSLib 的头文件中，无论是 <code>using</code> 声明还是 <code>using</code> 指令或是命名空间别名，都是经过<strong>慎重考虑</strong>的，特别是为了实现平台中立的兼容。</p>
<ul>
<li>如 YCLib::Mutex 模块支持标准库的对应接口，即使语言的实现如 libstdc++ 在单线程平台上不提供支持，也通过回退到 YBase::PseudoMutex 而允许不改动用户代码并直接保证空行为。允许不改动用户代码的性质可通过 <code>using namespace platform::Concurrency</code> 实现。</li>
</ul>
<p>　　所有其它不经意的在头文件中使用都应被避免。</p>
<h2 id="标识符命名"><a class="header" href="#标识符命名">标识符命名</a></h2>
<p>　　因为无法完全避免使用不同风格命名的外部依赖，YSLib 强调区分命名的来源而不是使用单一命名风格。</p>
<p>　　YBase 使用和 ISO C++ 标准库相容的风格。YFramework 则约定使用框架名称，其中可能包含一些前缀，如 <code>I</code> 表示只有抽象方法的类（接口类），<code>G</code> 表示用于泛型（与元编程目的相区别）的类模板的名称等。</p>
<p>　　详细的命名规约参见 <code>doc/CommonRules.txt</code> 和 <code>doc/YFramework.txt</code> 。</p>
<h1 id="yslib-应用程序基本模型"><a class="header" href="#yslib-应用程序基本模型">YSLib 应用程序基本模型</a></h1>
<h2 id="程序的启动运行和终止"><a class="header" href="#程序的启动运行和终止">程序的启动、运行和终止</a></h2>
<p>　　启动一个应用一般可以分为两个部分：创建内容；让内容被显示。YSLib 对此提供了整体性的便利解决方案。以下说明以典型的 GUI 程序为例（非 GUI 程序实际上不必要使用特别的支持）。</p>
<p>　　Helper::GUIApplication 模块提供的 <code>GUIApplication</code> 类的单例对象初始化中集成了 GUI 程序必要的初始化。之后，可以部署必要的操作，例如决定哪些内容被初始地呈现。程序通过 Helper::GUIApplication 提供的函数 <code>Execute</code> 调用被封装的<strong>消息循环(message loop)</strong> ，接受用户输入并按需响应。最后，当特定条件被满足时，退出 <code>Execute</code> 函数，程序结束。</p>
<h2 id="消息循环消息和消息队列"><a class="header" href="#消息循环消息和消息队列">消息循环、消息和消息队列</a></h2>
<p>　　消息循环，或称<strong>事件循环(event loop)</strong> ，是交互式应用的典型实现方式。程序通过处理(handling) 不同的<strong>消息(message)</strong> 完成期望的行为。除了少数特殊消息（例如表示“退出”以结束程序的消息），消息循环自身通常不能决定如何处理一个消息，因此需要<strong>分发(dispatching)</strong> 到用户提供程序中。</p>
<p>　　基本的消息循环的是一个<strong>轮询(polling)</strong> 操作，一次循环尝试确定一个需要被处理的消息。所有被处理的消息储存于<strong>消息队列(message queue)</strong> 内。当消息循环从消息队列取得消息时，通常即在队列中删除此消息。适当的操作产生消息发送至消息队列内以待处理。这种机制能让消息之间具有一定的顺序保证。但要注意，为了满足调度的需要，此处的队列并不一定需要是严格先进先出的。YSLib 使用模块 YSLib::Core::YMessage 提供的 <code>Messaging::Message</code> 类表示消息，<code>Messaging::MessageQueue</code> 类表示支持优先级的消息队列。</p>
<p>　　当没有消息需要被处理时即进入<strong>空闲(idle)</strong> 状态，库需要保证消息循环不被立刻终止，可以采取如下操作：</p>
<ul>
<li>发送特定的空闲消息并立即处理。</li>
<li>当可能有其它机制发送消息至消息队列时，放弃处理器资源以便节约能源或（在多任务环境中）使其它程序被调度，预定等待一定时间后再次轮询。</li>
<li>结合以上操作。</li>
</ul>
<p>　　交互式程序中，用户动作和其它外部输入可以被抽象为一个消息。输入消息包含必要的状态数据。用户程序指定此处的响应逻辑，更新特定应用的状态，绘制屏幕图形等。由于一个 GUI 程序在此需要完成的任务具有典型性，可以在更高层次上加以抽象，不一定需要直接控制消息循环。但了解消息循环仍然是必要的。</p>
<h2 id="shell"><a class="header" href="#shell">Shell</a></h2>
<p>　　YSLib 提供称为 Shell 的抽象使交互式程序易于被分隔为不同的实现。每个 Shell 类可以通过覆盖的虚函数 OnGotMessage 提供响应不同的消息一整套逻辑。</p>
<h1 id="进一步阅读-2"><a class="header" href="#进一步阅读-2">进一步阅读</a></h1>
<ul>
<li><a href="Tutorial/GUI.zh-CN.html">GUI 应用开发</a></li>
<li><a href="Tutorial/Configuration.zh-CN.html">程序配置</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="图形支持"><a class="header" href="#图形支持">图形支持</a></h1>
<p>　　YSLib 现阶段不强调图形学功能。作为 GUI 的基础，YSLib 主要在命名空间 <code>Drawing</code> 内提供以下两类图形接口：</p>
<ul>
<li>在 YSLib::Core::YGDIBase 描述图形的位置、大小等几何属性的对象 <code>Point</code> 、<code>Size</code> 和 <code>Rect</code> 。</li>
<li>在 YSLib::Service 中提供简单图形和字形的光栅化、像素操作和块传输等绘制功能。</li>
</ul>
<p>　　在了解 YSLib 开发时会少量涉及上述的第一类接口，需要了解其意义和简单的用法。进一步描述详见接口文档。</p>
<h2 id="标量类型"><a class="header" href="#标量类型">标量类型</a></h2>
<p>　　YSLib 默认使用整数坐标。表示屏幕坐标位置的有符号数类型 <code>SPos</code> 和大小的无符号数类型 <code>SDst</code> 的范围和平台相关，由 YCLib 提供，一般保证至少 16 位，但应避免依赖其具体范围。</p>
<h2 id="类模板和类类型"><a class="header" href="#类模板和类类型">类模板和类类型</a></h2>
<p>　　类模板 <code>GBinaryGroup</code> 表示两个标量的有序对，被用于表示屏幕坐标。以 <code>SPos</code> 作为模板参数的实例 <code>Point</code> 和 <code>Vec</code> 表示点的位置和二维向量，当前是一致的。</p>
<p>　　类 <code>Size</code> 包括两个 <code>SDst</code> 分量，用于表示大小。</p>
<p>　　类 <code>Rect</code> 约定了一个边和屏幕坐标系总是共线的矩形：保存一个左上角位置的 <code>Point</code> 和表示宽度和高度的 <code>Size</code> 对象。</p>
<p>　　一个 Rect 对象可以直接通过位置和大小构造：</p>
<pre><code>Rect r1(Point(10, 20), Size(40, 50));
Rect r2({10, 20}, {40, 50}); // 同上。
Rect r3(10, 20, 40, 50); // 同上。
Rect r4{10, 20, 40, 50}; // 同上。
</code></pre>
<p>　　类模板 <code>GGraphics</code> 表示<em>二维图形接口上下文</em> ，是一个表示缓冲区的指针（不保证具有所有权）和大小组成的数据结构。一般使用的是其实例 <code>Graphics</code> 和 <code>ConstGraphics</code> 。</p>
<p>　　类 <code>PaintContext</code> 包含了 GUI 绘制中的一些必要信息，其中由 <code>Graphics</code> 对象表示目标，<code>Point</code> 对象表示参考位置，<code>Rect</code> 对象表示需要保证绘制的边界范围。</p>
<h1 id="gui-应用接口概述"><a class="header" href="#gui-应用接口概述">GUI 应用接口概述</a></h1>
<h2 id="shell-和-guistate"><a class="header" href="#shell-和-guistate">Shell 和 GUIState</a></h2>
<p>　　Helper::GUIShell 模块提供的类 <code>Shells::GUIShell</code> 是专用于不同平台 GUI 程序处理的 shell ，它隐藏了控制和响应 GUI 需要处理的具体消息，使用户输入被分发到更高级的 <code>UI::GUIState</code> 类的对象中。</p>
<p>　　GUIState 是模块 YSLib::UI::YGUI 提供的平台中立的 GUI 公共逻辑处理的实现。默认 GUIState 对象预先构造的<strong>单态(monostate)</strong> 对象，即被全局共享，可以储存和 GUI 相关的公共状态。</p>
<p>　　通过 YSLib::UI::YGUI 提供的函数 <code>UI::FetchGUIState</code> 取得取默认图形用户界面公共状态：</p>
<pre><code>using namespace UI;
auto&amp; state(FetchGUIState());
</code></pre>
<h2 id="事件event"><a class="header" href="#事件event">事件(event)</a></h2>
<p>　　<code>UI::GUIState</code> 的成员函数被 <code>Shells::GUIShell</code> 直接或间接调用以按需构造不同的<strong>事件</strong> 。</p>
<p>　　一般意义的事件本质上是可以容纳回调(callback) 的对象，是发布-订阅模式的实现。用户通过事件提供的接口注册回调，在事件被触发调用时订阅者可以调用这些被预先发布的回调。</p>
<p>　　YSLib 事件由模块 YSLib::Core::YEvent 提供的 <code>GEvent</code> 类模板提供，包含多播支持，即 <code>GEvent</code> 中可以有多个回调函数，在触发事件时依优先级和插入顺序调用这些回调函数。<code>GEvent</code> 支持的回调通过<strong>事件处理器(event handler)</strong> <code>GHEvent</code> 类模板提供，除限定返回类型 <code>void</code> 外，使用方式基本兼容于 <code>std::function</code> （提供 ISO C++ 定义的<strong>可调用对象(callable object)</strong> 作为回调），此外提供两个方面的增强：</p>
<ul>
<li>可比较相等。这意味着 <code>GEvent</code> 不需要保存特定的引用即可支持查询或移除特定回调（若可调用对象自身支持 <code>==</code> 则通过 <code>==</code> 操作定义结果，否则总是认为同类型可调用对象都相等）。</li>
<li>通过 YBase 库模块 YStandardEx::Functional 的 <code>ystdex::make_expanded</code> 模板提供允许比事件处理器提供模板更少参数的可调用对象的支持，允许省略在右边的若干参数。缺乏此支持时，一个可调用对象的函数形参即使未被使用，仍然需要出现在声明的参数列表中，带来一些不便。</li>
</ul>
<p>　　另外，GEvent 的 <code>operator()</code> 会忽略回调抛出的 <code>std::bad_function_call</code> 异常。</p>
<p>　　和消息不同，YSLib 的事件默认总是被同步处理的。不同的事件使用不同的枚举标识，携带特定类型的<strong>事件参数(event argument)</strong> 对象。</p>
<p>　　用户通过给事件提供不同的可调用对象作为回调，在其中可以实现应用程序特定的逻辑。</p>
<h2 id="部件widget"><a class="header" href="#部件widget">部件(widget)</a></h2>
<p>　　部件是 GUI 的可见元素抽象。体现 GUI 逻辑的事件最终被分发到具体的<strong>部件</strong>上，在部件持有的事件上进行响应。</p>
<p>　　部件具有一系列基本的可视化属性，例如位置和大小。其它一些状态决定它如何被绘制以及和其它部件的关系或者具有用户程序关心的数据。YSLib 中的部件实现模块 YSLib::UI::YWidget 提供的 <code>UI::IWidget</code> 接口以及作为基类的 <code>UI::Widget</code> ，通过处理 <code>UI::Paint</code> 事件使其被绘制。</p>
<p>　　基本的部件只能处理 <code>UI::Paint</code> 标识的绘制事件，可以处理其它事件（例如直接响应表示用户输入的事件）的部件称为<strong>控件(control)</strong> 。模块 YSLib::UI::YControl 提供了控件的基类 <code>UI::Control</code> 。其它大部分部件派生于这个类以提供不同的功能。</p>
<p>　　调整部件的特定属性即可以基本完成一个 GUI 应用。</p>
<p>　　模块 YSLib::UI::YWidgetEvent 提供了 UI::VisualEvent 枚举标识默认支持的 GUI 事件，其中不同的枚举项表示不同的 GUI 事件，可能对应不同的事件参数类型。默认支持的事件参数类型都是类类型的右值引用类型，但和标准库的右值引用参数类型不同，约定被转移后状态可预测。</p>
<p>　　从一个控件取得一个指定事件标识的的事件左值，可以使用 YSLib::UI::YControl 提供的函数模板 <code>UI::FetchEvent</code> 。可以直接在取得的事件上进行操作，所以不必要直接声明一个变量。</p>
<pre><code>using namespace Drawing; // 使用 Drawing::Size 等。模块 YSLib::UI::YControl 已在命名空间 YSLib 中有此声明，若包含了对应的头文件，可以省略。
using namespace UI;
Control ctl(Size(80, 20)); // 创建一个 Control 类型的控件 ctl ，初始大小为 (80, 20) 。
auto&amp; paint_event(FetchEvent&lt;Paint&gt;(ctl)); // 取 ctl 的 UI::Paint 事件，通常是不必要的。

// 使用 lambda 表达式添加回调是简便的做法：
FetchEvent&lt;Click&gt;(ctl) += [](CursorEventArgs&amp;&amp;){
	std::cout &lt;&lt; &quot;Control clicked!&quot; &lt;&lt; std::endl;
};
FetchEvent&lt;Click&gt;(ctl) += []{ // 得力于 GHEvent 允许省略参数的特性，这里可以省略没有用到的形式参数。
	std::cout &lt;&lt; &quot;Control clicked again!&quot; &lt;&lt; std::endl;
};
</code></pre>
<p>　　当 ctl 被点击时，上面 <code>UI::Click</code> 事件上添加的两个回调会被依次执行，在标准输出上输出两行字符串。</p>
<h2 id="指定部件的视图属性"><a class="header" href="#指定部件的视图属性">指定部件的视图属性</a></h2>
<p>　　部件的视图属性包括<strong>位置</strong>和<strong>大小</strong>等。</p>
<p>　　上例中通过指定 <code>Size</code> 对象表示部件初始化时的大小。这个类型和下面涉及的位置以及边界类型都由模块 YSLib::Core::YGDIBase 提供，头文件默认已经被包含在 GUI 中所以不需要显式包含。</p>
<p>　　位置由二维的点 <code>Point</code> 类型表示。此处并没有明确位置是相对于哪个坐标系的。创建部件以后，并没有直接指定部件应在哪被显示，所以这里的位置本身只具有相对意义。</p>
<p>　　也可以通过直接指定 <code>Rect</code> 类型的矩形的<strong>边界</strong>：</p>
<pre><code>Control ctl2(Rect(10, 20, 40, 20)); // 位置为 (10, 20) ，大小为 (40, 20) 。
Control ctl3({10, 20, 40, 20}); // 同上。
</code></pre>
<p>　　出于动态加载部件的需要，YSLib 提供的部件总是可以通过一个 Rect 值构造以及默认构造（相当于 Rect 为空），因此不限于 <code>UI::Control</code> 使用。</p>
<p>　　在创建部件之后，使用函数 <code>GetLocationOf</code> 、<code>GetSizeOf</code> 和 <code>GetBoundsOf</code> 等查询这些属性；相对地，使用函数 <code>SetLocationOf</code> 、<code>SetSizeOf</code> 和 <code>SetBoundsOf</code> 等设置这些属性。通过这些函数设置位置和大小会分别触发 <code>Move</code> 和 <code>Resize</code> 事件。</p>
<h2 id="视图树和容器"><a class="header" href="#视图树和容器">视图树和容器</a></h2>
<p>　　YSLib 提供了单一的<strong>视图树</strong>结构作为显示视图的抽象。通过指定部件所在的<strong>容器</strong>限定显示的范围。容器自身是一个部件，可以嵌套在另外的部件中。容器中的部件（<strong>子部件</strong>）的位置使用容器部件的边界的左上角作为原点，即位置表示子部件的边界的左上角相对于容器的边界的左上角。这样的结构典型地构成一颗树，只有作为树根的<strong>顶层部件</strong>没有容器。</p>
<p>　　容器通过 <code>UI::IWdiget</code> 提供一般的迭代遍历支持。不是所有容器都支持动态添加子部件。模块 YSLib::UI::YPanel 提供一般的面板容器 <code>UI::Panel</code> 支持这个特性：</p>
<pre><code>using namespace Drawing;
using namespace UI;
Panel pnl(Size(200, 100));
Control ctl({10, 20, 100, 40});

pnl += ctl; // ctl 作为 pnl 的子部件，在 pnl 左上角的位置 (10, 20) 显示。
yassume(&amp;pnl == FetchContainerPtrOf(ctl)); // 宏 yassume 由 YBase 提供，默认和标准库的宏 assert 行为一致，表示断言；函数 FetchContainerPtr 取得指向容器的指针。
</code></pre>
<h3 id="顶层窗口top-level-window"><a class="header" href="#顶层窗口top-level-window">顶层窗口(top level window)</a></h3>
<p>　　部件最终需要通过顶层部件的 <code>UI::Paint</code> 事件被显示。在独立实现中，顶层部件一般是模块 YSLib::UI::YDesktop 提供的 <code>UI::Desktop</code> 。在宿主实现中，由于需要和宿主环境的 GUI 集成，使用不同的接口。在一个有桌面环境的宿主平台中，这样的顶层部件一般称为<strong>顶层窗口</strong>。</p>
<p>　　Helper 模块对顶层窗口提供了和平台相关的实现。通过模块 Helper::HostedUI 提供的函数 Host::ShowTopLevel 使一个部件成为一个顶层窗口。</p>
<pre><code>using namespace UI;
Control ctl(Size(200, 100));

Host::ShowTopLevel(ctl);
</code></pre>
<p>　　对 Windows ，<code>Host::ShowTopLevel</code> 支持更多的样式和扩展样式参数调整宿主窗口。具体使用详见 <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms632680(v=vs.85).aspx">MSDN</a> 。当调用 <code>Host::ShowTopLevel</code> 时，会自动创建具有独立线程和（ Win32 意义上的）消息循环 Windows 窗口，这个过程可能发生阻塞。</p>
<h2 id="常用部件"><a class="header" href="#常用部件">常用部件</a></h2>
<p>　　<code>UI</code> 命名空间下除了 <code>Widget</code> 、<code>Control</code> 、<code>Panel</code> 和 <code>YDesktop</code> 几类直接作为框架必要类型的部件外，还有更多提供不同实用功能的部件。</p>
<p>　　注意，非控件的部件不能取 <code>UI::Paint</code> 外的事件，否则会抛出异常。</p>
<h3 id="uilabel"><a class="header" href="#uilabel">UI::Label</a></h3>
<p>　　这是显示文本标签的部件。</p>
<p>　　简单的用法是创建部件后，修改 <code>Text</code> 属性。它接受的是模块 YSLib::Core::YString 提供的 <code>String</code> 类型的 UCS-2 字符串，可以直接通过 <code>std::u16string</code> 或 <code>const char16_t*</code> 等构造。因此内建的 <code>u</code> 前缀的字面量可以直接用于赋值 <code>Text</code> 。YSLib 中 GUI 的其它部分也使用这样的字符串。</p>
<h3 id="uibutton"><a class="header" href="#uibutton">UI::Button</a></h3>
<p>　　按钮控件。</p>
<p>　　类似 <code>UI::Label</code> 可以显示文本，但它是一个控件，可以点击并添加 <code>UI::Click</code> 事件回调。</p>
<h2 id="动态加载"><a class="header" href="#动态加载">动态加载</a></h2>
<p>　　模块 YSLib::UI::Loader 提供了在运行时读取 <a href="Tutorial/../Features/NPL.zh-CN.html">NPLA1</a> 配置加载部件视图树的 API 。</p>
<p>　　这些 API 当前相对不稳定，可能较容易改变，因此不作详细介绍。具体用法可参照<a href="Tutorial/../Features.zh-CN.html">示例程序 YReader</a> 的源代码。</p>
<h1 id="小结"><a class="header" href="#小结">小结</a></h1>
<p>　　通过以上讨论，读者可以回顾<a href="Tutorial/../GettingStarted.zh-CN.html">入门</a>中的示例，分析其中的各个部分的具体意义。</p>
<p>　　在这个基础上，参阅 Doxygen 文档查找 <code>UI</code> 命名空间下的其它 API 以开发自己的 GUI 应用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="程序配置概述"><a class="header" href="#程序配置概述">程序配置概述</a></h1>
<p>　　因为可移植性需求，YSLib 不直接使用特定平台提供的机制（如 <a href="https://en.wikipedia.org/wiki/Windows_Registry">Windows 注册表</a>）。考虑表达能力和实现冗余，YSLib 不使用 <a href="https://en.wikipedia.org/wiki/INI_file">INI</a> 等简单的配置格式。考虑实现复杂性和用户输入配置的简便性，YSLib 避免使用 <a href="https://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language">SGML</a> 及其派生的标记语言，特别地，<a href="https://en.wikipedia.org/wiki/XML">XML</a> 及其派生语言实现作为配置格式。</p>
<p>　　YSLib 提供相关解决方案为基于 <a href="Tutorial/../Features/NPL.zh-CN.html">NPL 派生实现 NPLA1</a> 的配置，在 YFramework 模块 NPL::Configuration 中提供相关 API 。</p>
<h1 id="规则和意义"><a class="header" href="#规则和意义">规则和意义</a></h1>
<p>　　除了整个文件构成的 NPL 表达式外，每一个 NPL 表达式的第一个项应为标识符，表示配置项的名称。其后的项可以是字符串或列表，表示配置项的内容。</p>
<h1 id="用例"><a class="header" href="#用例">用例</a></h1>
<p>　　YFramework 的一部分使用配置决定程序运行时需要的信息，如字体文件的位置。参照<a href="Tutorial/../Run.zh-CN.html">程序运行</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="术语概要"><a class="header" href="#术语概要">术语概要</a></h1>
<p>　　本文档概述及约定 YSLib 基本的概念含义，主要用于<a href="Development.zh-CN.html">开发</a>。</p>
<p>　　一些术语概念适用各种不同的上下文，主要用于开发过程中的设计和规则说明。</p>
<p>　　术语以列表形式的条目列出。通过使用元语言语法 <em>&lt;相关范畴/上下文&gt;</em> 标记指示被修饰或被限定的概念的适用范围。不需要消歧义时，省略标记。</p>
<h1 id="通用领域"><a class="header" href="#通用领域">通用领域</a></h1>
<p>　　除非另行指定，适用于任意<a href="Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">上下文</a>；但存在更具体的上下文的特定概念定义时，优先适用后者。</p>
<h2 id="经验语义"><a class="header" href="#经验语义">经验语义</a></h2>
<p>　　经验语义解释的术语的含义总是假定可被实证，不需要进一步解释。</p>
<p>　　元语言中的标记使用经验语义。标记可被本文档中已归类的章节提供。</p>
<p>　　本文档中非形式地使用在特定理论中严格定义的、和<a href="Terminology.zh-CN.html#%E9%80%9A%E7%94%A8%E7%BA%A6%E5%AE%9A">本章</a>的条目具有逻辑上相容的含义的概念时，不进一步解释。</p>
<h2 id="自指"><a class="header" href="#自指">自指</a></h2>
<p>　　<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E6%8C%87"><strong>自指</strong></a>是概念定义形式上的自我指涉。</p>
<p><strong>举例</strong> “<a href="Terminology.zh-CN.html#%E9%80%9A%E7%94%A8%E9%A2%86%E5%9F%9F">本章</a>”是关于位置的自指。</p>
<p>　　有必要通过自指定义的概念，隐含引入定义内容的过程的<a href="https://zh.wikipedia.org/zh-cn/%E5%BE%AA%E7%92%B0%E8%AB%96%E8%AD%89">循环论证</a>。这些概念的精确内涵和外延依赖<a href="Terminology.zh-CN.html#%E7%BB%8F%E9%AA%8C%E8%AF%AD%E4%B9%89">经验语义</a>的实证，否则在自然语言语言中可能需要循环论证而失去定义的意义。此处的条目内容（包括链接的外部定义）仅仅供参考，而不是精确的内涵和外延。为简化复杂度，限制自指定义的概念都是名词。</p>
<p><strong>举例</strong> 上述注释中，<strong>内涵</strong>和<strong>外延</strong>约定为以下<a href="Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">非自指</a>的概念，因此可依据本文档给出明确的定义来源。</p>
<p><strong>举例</strong> 在程序语言理论中，上下文(context) 指形式上可继续补充内容的构造；文档可能非形式地使用和这个含义相容的概念。</p>
<ul>
<li>实体(entity) ：任意被自然语言表达的目标；不需要通过自然语言先验定义；参见经验语义。</li>
<li>语义(semantics) ：参见经验语义。</li>
<li>经验(experience) ：参见哲学或一般等价的经验语义。</li>
<li>范畴(category) ：参见<a href="https://zh.wikipedia.org/zh-cn/%E8%8C%83%E7%95%B4%E8%AE%BA">范畴论</a>。</li>
<li>态射(morphism) ：参见范畴论。</li>
<li>归纳(induction) ：一种态射，可操作性参见经验语义。</li>
<li>方法学(methodology) ：一个归纳经验得到的范畴；参见哲学或一般等价的经验语义。</li>
<li>方法(method) ：方法学的一个子范畴；可操作性参见经验语义。</li>
<li>概念(concept) ：参见逻辑学。</li>
<li>上下文(context) ：一种概念范畴适用的态射；参见经验语义。</li>
</ul>
<h2 id="非自指"><a class="header" href="#非自指">非自指</a></h2>
<p>　　包含多个一般领域的概念。</p>
<ul>
<li><em>&lt;名词&gt;</em> 形式(form) ：参见经验语义和数学。</li>
<li><em>&lt;概念&gt;</em> 内涵：参见逻辑学。</li>
<li><em>&lt;概念&gt;</em> 外延：参见逻辑学。</li>
<li><em>&lt;概念&gt;</em> 定义(definition) ：确定概念内涵和外延的方法；参见任意一种形式逻辑学。</li>
<li><em>&lt;动词&gt;</em> 抽象(abstracting) ：通过经验语义定义概念范畴或集合的方法。</li>
<li><em>&lt;名词&gt;</em> 抽象(abstraction) ：<em>&lt;动词&gt;</em> 抽象的结果。</li>
<li><em>&lt;动词&gt;</em> 封装(encapsulating) ：从某一个范畴中抽象一个子范畴的方法。</li>
<li><em>&lt;名词&gt;</em> 封装(encapsulation) ：<em>&lt;动词&gt;</em> 封装的结果。</li>
<li>规范(specialization) ：一种提供在特定上下文中可定义的描述的封装，参见工程学（特别是软件工程学，下同）。</li>
<li>接口(interface) ：一种封装，参见工程学。</li>
<li>实现(implementation) ：一种封装，参见工程学。</li>
<li>重用(reusing) ：参见经验语义和工程学。</li>
<li>不变性(invariance) ：满足某种<a href="https://zh.wikipedia.org/zh-cn/%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB">等价关系</a>（自反、传递、对称的<a href="https://zh.wikipedia.org/zh-cn/%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB">二元关系</a>）。</li>
<li>不变量(invariant) ：具有不变性的实体。参见数学和契约式程序设计。</li>
<li>状态(state) ：可以和其它实体关联的、可在某个上下文中保持变化或不变的实体。同一状态总是保持变化或保持不变。状态变化的含义参见经验语义、数学或另行指定。
<ul>
<li>可变状态(mutable state) ：在某个上下文中可能映射到若干其它状态的状态。</li>
<li>不可变状态(immutable state) ：不是可变状态的状态。</li>
</ul>
</li>
<li><em>&lt;动词&gt;</em> 派生(deriving) ：基于重用的操作。</li>
<li><em>&lt;名词&gt;</em> 派生(derivation) ：<em>&lt;动词&gt;</em> 派生的结果。</li>
</ul>
<h1 id="计算机科学"><a class="header" href="#计算机科学">计算机科学</a></h1>
<p>　　包含多个关于数学、逻辑学和计算机领域的概念。</p>
<ul>
<li><em>&lt;动词&gt;</em> 形式化(formalize) ：建立数学意义上的严格<a href="Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">形式</a>。</li>
<li><em>&lt;名词&gt;</em> 形式化(formalization) ：建立形式的过程。</li>
<li>形式方法(formal method) ：包含形式化的<a href="Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">方法</a>。</li>
<li><em>&lt;动词&gt;</em> 建模(model) ：建立形式化输出的形式。</li>
<li><em>&lt;名词&gt;</em> 模型(model) ：建模的结果。</li>
<li>集合(set) ：一种数学模型，参见 <a href="https://zh.wikipedia.org/zh-cn/%E5%86%AF%E8%AF%BA%E4%BC%8A%E6%9B%BC-%E5%8D%9A%E5%86%85%E6%96%AF-%E5%93%A5%E5%BE%B7%E5%B0%94%E9%9B%86%E5%90%88%E8%AE%BA">NBG 集合论</a>。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E7%B1%BB_%28%E6%95%B0%E5%AD%A6%29">类</a>(class) ：参见 NBG 集合论和范畴论。</li>
<li>真类(proper class) ：参见 NBG 集合论和范畴论。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB">二元关系</a>(binary relationship) ：一种基于集合上定义的数学实体。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB">等价关系</a>(equivalence relationship) ：<a href="https://zh.wikipedia.org/zh-cn/%E8%87%AA%E5%8F%8D%E5%85%B3%E7%B3%BB">自反的(reflexive)</a> 、<a href="https://zh.wikipedia.org/zh-cn/%E5%AF%B9%E7%A7%B0%E5%85%B3%E7%B3%BB">对称的(symentric)</a> 且<a href="https://zh.wikipedia.org/zh-cn/%E4%BC%A0%E9%80%92%E5%85%B3%E7%B3%BB">传递的(transitive)</a> 二元关系。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB">偏序关系</a>(paritial order relationship) ：自反的、<a href="https://zh.wikipedia.org/zh-cn/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%85%B3%E7%B3%BB">反对称的(asymentric)</a> 且传递的的二元关系。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB">严格偏序关系</a>(paritial order relationship) ：<a href="https://zh.wikipedia.org/zh-cn/%E8%87%AA%E5%8F%8D%E5%85%B3%E7%B3%BB#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">反自反的(irreflexive)</a>、反对称的且传递的的二元关系。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E7%AD%89%E4%BB%B7%E7%B1%BB">等价类</a>(equivalence class) ：等价关系划分集合得到的类。</li>
<li>可计算性(computability) ：参见数学。
<ul>
<li>通常由 <a href="https://zh.wikipedia.org/zh-cn/%E9%82%B1%E5%A5%87%EF%BC%8D%E5%9B%BE%E7%81%B5%E8%AE%BA%E9%A2%98">Church-Turing 论题</a>定义。</li>
</ul>
</li>
<li>计算(computation) ：由可计算性定义的操作的等价类，可表现为特定的外在的行为(behavior) 。</li>
<li>计算模型(computation model) ：描述计算的模型，是对计算建模的结果。</li>
<li>序列(sequence) ：有序集合。</li>
<li>形式语义(formal semantics) ：使用形式化的方式表达的语义。</li>
<li>形式语言(formal language) : 特定形式化的方式确定的元素的全集。
<ul>
<li><strong>注释</strong> 这也可能作为<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>对应的某种形式语义。这同时是语言对应的<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">语法</a>的外延。</li>
</ul>
</li>
<li>计算复杂度(computational complexity) ：某个形式化计算模型中以有限的正整数作为模型决定的规模(metric) 作为参数的渐进(asymptotic) 性质确定的度量。
<ul>
<li>时间复杂度(time complexity) ：描述步骤规模的计算复杂度。</li>
<li>空间复杂度(space comlexity) ：描述存储规模的计算复杂度。</li>
</ul>
</li>
<li>并发(concurrency) ：计算的非确定性的(non-deterministic) 组合(composition) 的性质。
<ul>
<li>并发的(concurrent) ：已被并发方式组合的。</li>
</ul>
</li>
<li>并行(parallelism) ：确定性的(deterministic) 计算行为蕴含的可提升渐进效率(asymptotic efficiency) 而不改变计算预期的其它行为的性质。
<ul>
<li>并行的(parallel) ：已蕴含并行的。</li>
<li>可并行化的(parallelizable) ：允许改变而蕴含并行的。</li>
<li><strong>注释</strong> 渐进效率可使用渐进形式的复杂度描述。</li>
<li><strong>注释</strong> 一个表达渐进效率的具体例子是<a href="https://en.wikipedia.org/wiki/Big_O_notation">大 O 记号(en-US)</a> 。</li>
</ul>
</li>
<li>二进制(binary) ：实数的二进位制表示格式。</li>
</ul>
<h1 id="规范"><a class="header" href="#规范">规范</a></h1>
<p>　　包含提供<a href="Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">规范</a>的<a href="Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">实体</a>定义。</p>
<ul>
<li>符合性(conformance) ：满足规范的实现性质。</li>
<li>要求(requirement) ：规范对实现的作为判断符合性的条件。</li>
<li>约束(constraint) ：可被<a href="Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">形式</a>表达，用于限制和明确行为的规则。不一定使用形式表达。</li>
<li>违反(violation) ：对约束指定的条件的不满足。</li>
<li>过时的(obsolesent) ：已确认因为存在更合适的选项而建议不继续使用的（接口/特性）。</li>
<li>废弃的(deprecated) ：过时的但因为兼容性等原因，暂时保留的、一般可提供替代的接口或特性。</li>
<li>语言：<a href="Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">模型</a>或者非形式地其它方式定义的一种<a href="Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">接口</a>。</li>
<li><em>&lt;语言&gt;</em> 接口(<em>&lt;language&gt;</em> interface) ：和表达<a href="Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">语义</a>有关的语言的可见的特征。</li>
</ul>
<p>　　包含关于语言的规范的定义。</p>
<ul>
<li><em>&lt;语言&gt;</em> 实现(<em>&lt;language&gt;</em> implementation)：对语言规则中的要求的<a href="Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87"><em>&lt;非自指&gt;</em> 实现</a>。</li>
<li><em>&lt;语言&gt;</em> 人类接口(human interface) ：语义仅对人类有意义（内容改变时可以导致语义的差异性），不提供为涉及作为计算模型实现的语言接口。</li>
<li><em>&lt;语言&gt;</em> 机器接口(machine interface) ：对机器（或特定语言实现的特定部分）有意义的语言接口。注意不同语言实现组成部分可以不同。
<ul>
<li><strong>举例</strong> 对 <a href="https://zh.wikipedia.org/zh-cn/C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8">C 语言的预处理器</a>，C 源代码中的空白符是机器接口，而对翻译器来说则不是。就源代码而言，机器接口总是人类接口的子集。</li>
</ul>
</li>
<li><em>&lt;语言&gt;</em> 特性(*&lt;language&gt; feature) ：作为功能提供的人类接口。</li>
<li>语言规则(language rule) ：约定可实现及应被实现的语言接口的描述，可包含语言特性的表达。</li>
<li>语言规范(language specialization) ：包含正式的(normative) 的语言规则的集合的<a href="Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">规范</a>；或称语言规格说明。</li>
<li>语言实现(language implementation) ：语言提供的接口的实现，是语言的表现形式，可以是具体语言实现或抽象语言实现之一。
<ul>
<li>具体语言实现(concreate language implementation) ：能最终完全表达为可预测的物理现象一一对应的表达<a href="Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">可计算性</a>的实现（如机器指令），一般应为程序。</li>
<li>抽象语言实现(abstract language implementation) ：非具体语言实现的语言实现。形式意义的标准定义的语言属于此类。</li>
</ul>
</li>
<li>派生语言实现(derived language implementation) ：派生已有实现的部分或全部得到的语言实现。以下简作“派生实现”。</li>
<li><em>&lt;语言&gt;</em> 实现环境(environment of implementation) ：对应特定语言实现的特定不变状态（对机器来说可以是配置项，对人来说不确定，所以一般忽略）的集合。</li>
<li><em>&lt;语言&gt;</em> 互操作(interoperation) ：不同的语言实现环境中发生的交互。</li>
<li><em>&lt;语言&gt;</em> 嵌入实现(embedded implemenation) ：在现有的其它语言实现上建立的可共享部分实现环境支持互操作的语言实现。</li>
<li>宿主语言(host language) ：提供嵌入实现的现有实现中使用的语言。</li>
<li>客户语言(guest language) ：嵌入实现中被宿主语言支持实现的语言。</li>
<li>未定义的(undefined) ：可能导致违反<a href="Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">规范</a>的约束但语言规范同时没有要求提供任何可能影响<a href="Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">符合性</a>的保证（如具有诊断消息）的。
<ul>
<li><strong>注释</strong> 表示置于语言规则下的行为等不可预测。</li>
</ul>
</li>
<li>良定义的(well-defined) ：明确地非未定义的。</li>
<li>未指定的(unspecified) ：<a href="Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">规范</a>隐式或显式地允许但不要求唯一确定的至少一个实现选项。
<ul>
<li><strong>注释</strong> 通常允许多种不同的选项；但在特定实现配置下，规则中未指定的选项也可被限制为只有一种可行的选项。</li>
<li><strong>注释</strong> 同一个实现或者不同实现可能确定地或非确定地选取不同的选项而不保证表现一致。</li>
</ul>
</li>
<li>由实现定义的(implementation-defined) ：取决于各个具体语言实现的，要求有文档说明。</li>
<li>由派生实现定义的(derived-implementation-defined) ：取决于各个派生语言实现的，要求除存在默认定义或被派生实现的部分有明确的文档说明。</li>
</ul>
<h1 id="程序设计语言"><a class="header" href="#程序设计语言">程序设计语言</a></h1>
<p>　　提供上下文 <em>&lt;程序设计语言&gt;</em> ，特别是语言规范的定义。</p>
<p>　　主要用例参见存储库中的项目文档 <code>doc/NPL.txt</code> 。</p>
<ul>
<li>广义实体：<em>&lt;通用领域&gt;</em> 实体。语言抽象的目标，不另行定义（意义最终取决于自然语言）。</li>
<li>名称(name) ：一种特殊的广义实体，专用于指称另一个广义实体。</li>
<li>实体(entity) ：非名称的广义实体。</li>
<li>表示(representation) ：以一个符合某种形式的约束的实体指称另一个实体。</li>
<li>符号(symbol) ：<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>允许的不使用其它对象表示的对象。符号可实现名称。</li>
<li>字母表(alphabet) ：符号在语言中的全集。</li>
<li>串(string) ：可能重复出现的符号的有限序列。</li>
<li>文法(grammar) ：描述任意的可形式化的语言规则。</li>
<li>语法(syntax) ：以语言中的串作为基本元素，描述语言的字面(literal) 结构模式(pattern) 的语言规则，通常是文法的一部分。</li>
<li>语义(semantics) ：非语法的考虑逻辑上的释义(interpretation) 或含义(meaning) 的规则、原理和过程，通常可被语法以外的文法描述并可约束含义的表达。</li>
<li>实例(instance) ：具有代表性含义的集合的元素。</li>
<li>代码(code) ：任意有限的语言的实例片段组成的语法范畴。</li>
<li>伪代码(pseudo code)：抽象语言实现的语言的代码。
<ul>
<li><strong>注释</strong> 习惯上和具体语言实现代码完全一致的代码可以不作为伪代码考虑。</li>
</ul>
</li>
<li>程序(program) ：具体语言实现接受的以代码表示的输入，或被变换后对应的输出。</li>
<li>数据(data) ：程序处理的一般信息。
<ul>
<li><strong>注释</strong> 通常不直接作为代码处理。</li>
</ul>
</li>
<li>编码(encode) ：变换数据为确切格式的代码。
<ul>
<li><strong>注释</strong> 格式通常使用语言定义。</li>
</ul>
</li>
<li>解码(decode) ：变换确切格式的代码为数据。
<ul>
<li><strong>注释</strong> 编码和解码可以是对应可逆的。</li>
</ul>
</li>
<li>行为(behavior) ：语言实现或在满足符合性的具体语言实现中的程序的外部表现。
<ul>
<li>基于可操作性考虑，一般仅约束实现的机器<a href="Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">接口</a>。</li>
<li><strong>注释</strong> 程序的行为是具体的<a href="Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算行为</a>的实例。</li>
</ul>
</li>
<li>计算作用(computational effect) ：可被某个形式化计算模型描述的行为。</li>
<li>翻译(translation) ：不同语言的程序之间的变换，可作为语言实现的形式。
<ul>
<li><strong>注释</strong> 输入和输出具有相同表示的恒等变换不被视为翻译。</li>
</ul>
</li>
<li>IR（intermediate representation ，中间表示）：翻译过程中使用的和输入及输出都不同的表示。</li>
<li>翻译器(translator) ：实现翻译的程序。</li>
<li>运行(run) ：实现程序或组成程序的实体的行为的动作。</li>
<li>加载(load) ：运行程序或组成程序的实体时从实现环境取得相关实体的动作，可蕴含创建这些实体的副本或翻译其中的代码到特定形式。</li>
<li>执行(execute) ：处理程序或组成程序的实体，使这些实体或实体的副本作为资源被消费而蕴含这些实体被运行，同时可能蕴含消费实现环境的其它资源。
<ul>
<li><strong>注释</strong> 执行强调资源的消费，是运行的子集。资源被消费后不再可用。因此，除非同时蕴含资源的<em>再生(reclaim)</em> ，被执行的同一实体不预期被再次执行。再生资源包括实体加载时翻译或取得副本，及实现环境中补充的替代资源。</li>
</ul>
</li>
<li>解释(interpretation) ：通过不依赖显式指定的附加的程序翻译而直接运行表现行为的具体语言实现的形式。</li>
<li>解释器(interpreter) ：实现解释的程序。
<ul>
<li><strong>注释</strong> 解释器是翻译器的真子集。</li>
</ul>
</li>
<li>编译(compilation) ：通过依赖显式指定的附加的程序翻译而运行翻译的输出表现行为的具体语言实现的形式。
<ul>
<li><strong>注释</strong> 典型的编译以生成 IR 作为附加的程序翻译过程。</li>
</ul>
</li>
<li>编译器(compiler) ：实现编译的程序。
<ul>
<li><strong>注释</strong> 编译器是翻译器的真子集。</li>
</ul>
</li>
<li>源语言(source language) ：翻译的输入的语言。</li>
<li>目标语言(target language) ：编译的输出的语言。</li>
<li>转译器(transpiler) ：源语言和目标语言都能作为典型的源语言的翻译器。
<ul>
<li><strong>注释</strong> 或称为<strong>源到源翻译器(source-to-source translator)</strong> 。</li>
</ul>
</li>
<li>转译编译器(transcompiler) ：源语言和目标语言都能作为典型的源语言的编译器。
<ul>
<li><strong>注释</strong> 或称为<strong>源到源编译器(source-to-source compiler)</strong> 。</li>
<li><strong>注释</strong> 通常转译器需要明确的 IR ，所以都是转译编译器。</li>
</ul>
</li>
<li>源代码(source code) ：源语言编码的代码。</li>
<li><em>&lt;翻译&gt;</em> 目标代码(target code) ：目标语言编码的代码。</li>
<li>目标代码(code code) ：编译器输出的代码。
<ul>
<li><strong>注释</strong> 编译器输出的目标代码是翻译的目标代码的特例，一般具有<a href="Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">二进制</a>编码。</li>
</ul>
</li>
<li>源程序(source program) ：形式为作为翻译的输入的源代码程序。</li>
<li>复杂度(complexity) ：以程序的规模作为参数的关于程序的直接执行的<a href="Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算复杂度</a>。</li>
<li>元语言(metalanguage) ：描述其它语言的语言。</li>
<li>对象语言(object language)：被元语言操作或实现的语言。</li>
<li>元编程(metaprograming) ：使用元语言编程。</li>
<li>反射(reflection) ：元语言和对象语言相同的元编程。</li>
<li>具现(reification) ：在对象语言中以数据模型作为关联实体以表示程序的语义。</li>
<li>诊断(diagnostics) ：明确的对特定预期或非预期执行的行为的响应的总和。</li>
<li>诊断消息(diagnostic message) ：用于和用户交互的表现诊断的告知及提示。</li>
<li>未定义行为(undefined behavior) ：<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">未定义的</a>行为。</li>
<li>良定义行为(well-defined behavior) ：<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">良定义的</a>行为。</li>
<li>未指定行为(unspecified behavior) ：<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">未指定的</a>行为。
<ul>
<li><strong>注释</strong> 由实现选取<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规范</a>中可能允许的指定行为的不确定选项，这些选项可能由显式或隐式的语言规则确定。</li>
<li><strong>注释</strong> 推论：由实现定义的行为是未指定行为。在本文档中，为最小化依赖，不在正式规则中明确这些关系。</li>
</ul>
</li>
<li>语言特性(language feature) ：语言提供的功能接口，可以是具体语言特性或抽象语言特性之一。</li>
<li>具体语言特性(concrete language feature) ：完全没有派生语言实现定义的语言特性。</li>
<li>抽象语言特性(abstract language feature) ：非具体语言特性的语言特性。</li>
<li>外部环境(external environment) ：和程序及被翻译的程序没有交集的和实现环境无关的状态。</li>
<li>外部表示(external representation) ：具有特定形式的用于和外部环境交互的表示。</li>
<li>内部表示(internal representation) ：非外部表示的表示。</li>
<li>可编程性(programmability) ：允许使用程序提供实现的性质。</li>
<li>API（application programming interface ，应用程序编程接口）：提供可编程性以实现程序之间交互的接口。</li>
<li>ABI（application binary interface ，应用程序二进制接口）：提供可编程性以实现二进制编码的程序之间交互的接口。
<ul>
<li><strong>注释</strong> ABI 可以是明确指定了二进制形式的程序之间的 API ，也可以是不依赖二进制编码实现的程序的 API 的实现细节。</li>
</ul>
</li>
</ul>
<h1 id="项目管理"><a class="header" href="#项目管理">项目管理</a></h1>
<p>　　提供上下文 <em>&lt;项目&gt;</em> 。</p>
<p>　　主要用例参见版本库中的项目文档 <code>doc/ProjectRules.txt</code> 。</p>
<ul>
<li>涉众(skateholder) ：项目关联的各方的主体。</li>
<li>角色(role) ：依据项目过程中起到的作用，对项目涉众实行一些附加归类。
<ul>
<li><strong>注释</strong> 项目的角色同时可用于项目阶段的描述中。</li>
</ul>
</li>
<li>用户(user) ：使用项目输出的项目涉众。</li>
<li>维护者(maintainer) ：决定项目中各个部分的内容的用户。
<ul>
<li><strong>注释</strong> 维护者可参与和维护部分相关的项目决策。</li>
</ul>
</li>
<li>开发者(developer) ：参与程序库和开发工具的功能修改的用户。
<ul>
<li><strong>注释</strong> 开发者可参与公开的构建过程以完成这些修改。</li>
</ul>
</li>
<li>最终用户(end user) ：独立为项目过程的用户。
<ul>
<li><strong>注释</strong> 最终用户可以不参与提前(ahead-of-time) 构建的项目过程。基于认知需求的差异可能需要从一般用户中单独区分。</li>
</ul>
</li>
</ul>
<h2 id="依赖管理"><a class="header" href="#依赖管理">依赖管理</a></h2>
<p>　　项目管理的客体被分解为特定关联的依赖项。任意两个依赖项之间存在<a href="https://zh.wikipedia.org/zh-cn/%E5%8F%8D%E5%AF%B9%E7%A7%B0%E5%85%B3%E7%B3%BB">反对称</a>和<a href="https://zh.wikipedia.org/zh-cn/%E4%BC%A0%E9%80%92%E5%85%B3%E7%B3%BB">传递</a>的<a href="https://zh.wikipedia.org/zh-cn/%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB">二元关系</a>称为<strong>依赖关系</strong>。<strong>严格依赖关系</strong>是反自反的依赖关系。</p>
<p>　　依赖项和依赖项之间的严格依赖关系统称为<em>依赖(dependency)</em> 。</p>
<h3 id="依赖引用"><a class="header" href="#依赖引用">依赖引用</a></h3>
<p>　　因为依赖关系的传递性，多个依赖关系可能存在无法满足严格依赖关系的情形，即<em>循环依赖(cyclic dependency)</em> 。这导致以确定的顺序解析依赖不可行，增加维护成本。</p>
<p>　　为了避免一定层次上的循环依赖，以该层次内组件为顶点的依赖关系的关系图应明确组织为有向无环图。
在最简单情况下依赖关系可退化为线性顺序依赖。</p>
<h3 id="内部依赖和外部依赖"><a class="header" href="#内部依赖和外部依赖">内部依赖和外部依赖</a></h3>
<p>　　项目中的组成部分之间的依赖称为<strong>内部依赖</strong>，其它依赖为<strong>外部依赖</strong>。</p>
<h2 id="源代码"><a class="header" href="#源代码">源代码</a></h2>
<p>　　<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源代码</a>用于生成指定目标代码。</p>
<p>　　通常源代码以文件形式保存，即源代码文件(source code file) ，简称源文件(source file) 。</p>
<h2 id="版本库"><a class="header" href="#版本库">版本库</a></h2>
<p>　　项目使用的版本控制系统(version controlling system) 具有存储库(repository) 作为持久存储实体，即版本库。</p>
<p>　　当前使用的主要版本控制系统为 <a href="https://www.mercurial-scm.org/">Mercurial</a> 。因为是分布式版本控制，也用于直接分发源代码。</p>
<p>　　每个文件系统上存储的版本库实例中，<code>.hg</code> 目录存储版本库元数据。</p>
<h1 id="设计和模型"><a class="header" href="#设计和模型">设计和模型</a></h1>
<h2 id="环境"><a class="header" href="#环境">环境</a></h2>
<p>　　程序中的某一部分的外界称为<strong>环境(environment)</strong>。根据限定程序的范围，可以有更确切的定义，如<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">实现环境</a>（对一类语言实现而言）、运行时环境（对共享实现环境的一类程序而言）。</p>
<p>　　一般地，实现环境可以分为<em>独立环境(freestanding environment)</em> 和<em>宿主环境(hosted environment)</em> ，区分依据为是否依赖宿主（对部署在单一计算机上的实现，一般指操作系统）的支持。因此，环境有时指操作系统及其提供的外部服务的集合。</p>
<p>　　一些语言，如 ISO C 和 ISO C++ ，可以同时支持宿主环境和独立环境的实现，对应<em>独立实现(freestanding impementation)</em> 和<em>宿主实现(hosted impementation)</em> 。</p>
<h2 id="平台-1"><a class="header" href="#平台-1">平台</a></h2>
<p>　　环境中决定程序适用环境的被依赖的特定资源集合称为<strong>平台环境(platform environment)</strong>，简称<strong>平台(platform)</strong>。平台的典型例子有：</p>
<ul>
<li>运行时支持的<a href="https://zh.wikipedia.org/zh-cn/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%A7%8B">硬件的体系结构</a> ；</li>
<li>操作系统和 <a href="https://zh.wikipedia.org/zh-cn/%E5%BA%94%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8E%A5%E5%8F%A3">ABI</a> 。</li>
</ul>
<p>　　平台的内涵是资源的集合，其构成并非任意。构成平台的特定准则应使之保持相对的稳定和可预期，即可配置；即平台是名义的(nominal) 可配置的资源集合。</p>
<p>　　若平台包含的资源是已知的，则不需要平台的观念，分析其资源子集（即便不构成平台）即可解决几乎平台抽象涉及的所有技术问题（同时这也是定义一个具体平台的基础）。但在简化资源集合的全局性质分析（如比较资源配置方案）和名义抽象以隐藏实现（如为开发者提供预设环境集合）的应用角度上，平台仍有被单独讨论的意义。</p>
<h3 id="兼容性和可移植性"><a class="header" href="#兼容性和可移植性">兼容性和可移植性</a></h3>
<p>　　若一个依赖项对应的平台可以替换，则此依赖项和此平台<em>兼容(compatible)</em> 。<strong>兼容性(compatibility)</strong> 是平台兼容的二元关系。兼容性不是一种<a href="https://zh.wikipedia.org/zh-cn/%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB">等价关系</a>，因为不保证传递。</p>
<p>　　替换平台的过程称为<em>移植(porting)</em> 。移植的可行性称为<strong>可移植性(portability)</strong> 。</p>
<p>　　兼容任意平台的依赖项被称为是<em>平台中立(platform-neutral)</em> 的。</p>
<p>　　当平台中立的依赖项的依赖能被自动满足而不需要考虑时，是<em>平台无关(platform-independent)</em> 的。平台中立<a href="https://zh.wikipedia.org/zh-cn/%E5%AE%9E%E8%B4%A8%E6%9D%A1%E4%BB%B6">实质蕴含</a>平台无关。</p>
<h3 id="依赖和外延"><a class="header" href="#依赖和外延">依赖和外延</a></h3>
<p>　　若平台之间不出现平台的实现（如开发语言的实现）和环境自身的相互依赖，则这些平台相互<em>独立(independent)</em> 。总是保持相互独立的一组平台称为<em>独立平台(independent platforms)</em> 。每一组独立平台保证可以相对于其它独立平台分离开发和测试。</p>
<p>　　注意以上术语和 ISO C 和 ISO C++ 定义的<em>宿主实现(hosted implementation)</em> 和<em>独立实现(freestanding implementation)</em> 的关联和区别。</p>
<p>　　典型的应用场景约定以下类型的平台：</p>
<ul>
<li>构建平台(build platform) ：运行开发环境的平台。</li>
<li>宿主平台(host platform) ：运行构建平台输出代码的平台。</li>
<li>目标平台(target platform) ：运行最终目标代码的平台。</li>
</ul>
<p>　　若宿主平台和构建平台一致，称为<em>本机构建(native build)</em> ；否则，称为<em>交叉构建(corss build)</em> 。</p>
<p>　　通常构建工具在本机构建时提供对构建平台的检查以确定自身是否能够运行；交叉构建环境需要显式指定。</p>
<p>　　目标平台通常和宿主平台一致。指定目标平台的理由是，存在最终不一定在宿主平台上运行的程序，其运行的环境可能需要宿主平台不保证支持的特性，这典型地包括：</p>
<ul>
<li>构建的程序自身是生成其它程序的程序，如编译器和链接器。这些程序生成的平台是目标平台，不需要和它们的宿主平台相同。</li>
<li>构建的程序可以在宿主平台上运行，但在其它平台上具有更完全的特性集。后者被作为目标平台。</li>
</ul>
<p><strong>注意</strong> 此处的宿主平台具有相对意义，不一定脱离被运行的目标平台。一个宿主平台通常自身是宿主实现平台，但这点不被保证。</p>
<h3 id="模拟和仿真"><a class="header" href="#模拟和仿真">模拟和仿真</a></h3>
<p>　　<strong>模拟(emulation)</strong> 指适配和运行为不同平台设计的程序，广义上包括以下两类：</p>
<ul>
<li>环境模拟(environment emulation) ：使用模拟器(emulator)或虚拟机(virtual machine) 等作为宿主平台的程序，模拟运行环境的通用解决方案。</li>
<li>程序模拟(program emulation) ：直接以运行时环境适配层嵌入宿主平台运行时，在具体程序中提供类似被模拟的目标平台的具体特性和接口。</li>
</ul>
<p>　　运行模拟程序的环境和被模拟环境分别是宿主平台和目标平台。</p>
<p>　　注意虚拟机在这个意义下是广义的模拟器，但一般仍然分别对待。</p>
<p>　　环境模拟和程序模拟的主要差异为是否独立的、专用的宿主平台程序作为中介以维护目标平台和宿主平台的隔离。</p>
<p>　　在一般意义上，<strong>仿真(simulation)</strong> 指对需要分析的问题建立的<a href="Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">模型</a>的过程、方法和机制，在软件工程以外也被称为模拟，如计算机模拟(computer simulation) 。对于以计算机系统为目标的仿真，建立的模型可以是具体的实物（包括硬件和软件），称为仿真器(simulator) 。以软件接口为主要操作方式实现的仿真器同时实现了环境模拟，但侧重不同：精确重现需要分析行为，而非实用的功能等价性和体系中的可替换性。</p>
<h3 id="平台配置"><a class="header" href="#平台配置">平台配置</a></h3>
<p>　　实际的平台实现可能复用部分实现，配置之间可存在某种构成依赖关系的<a href="https://zh.wikipedia.org/zh-cn/%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB">偏序关系</a>（如继承关系）。这些在项目中所有被配置的平台称为<em>公共平台(common platform)</em> ，其中能对应生成输出的称为<em>具体平台(concrete platform)</em> ，否则为<em>抽象平台(abstract platform)</em> 。</p>
<p>　　对一个平台配置，程序可提供更多的子配置共用现有的相同的配置。子配置可继续对平台特性具体特化，而对原始配置的用户程序隐藏细节。</p>
<p>　　普遍适用于一般功能配置也可被作为平台配置的一部分而作为子配置。</p>
<p><strong>注释</strong> 例如，多线程和非多线程版本、调试和非调试版本可作为平台配置的功能子配置。</p>
<p><strong>原理</strong> 尽管功能配置提供的特性可能是普遍的，但它的实现依赖的特性不都在每个平台中存在，而可能需要一定程度的模拟和仿真，或可选地提供部分特性。提供功能子配置可把这些特性作为次要的实现细节，和原始的平台上的更显著特性隔离。</p>
<p>　　若存在这样的子配置，应当满足：</p>
<ul>
<li>这些子配置应当在每个部署的用户程序的依赖中保持唯一，即一个环境中不能同时依赖不同的子配置的程序映像。
<ul>
<li><strong>原理</strong> 这样不但不需要保持子配置之间的 <a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">ABI</a> 兼容性，同时 <a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 也可以存在不兼容（而不仅仅是调试符号等附加元数据的差异）。</li>
</ul>
</li>
<li>相应地，依赖不同子配置的用户程序也具有对应的子配置。用户程序可以仅提供其中的部分子配置的程序映像。
<ul>
<li><strong>原理</strong> 对每个子配置需要提供单独的依赖路径以避免冲突，因此一般不能在同一个部署中直接复用不同子配置的程序映像。为了避免不必要的资源占用，支持用户程序仅提供部分子配置（而非所有子配置的映像）是必要的。</li>
</ul>
</li>
<li>除非另行指定，被复用的公开库的程序名称在不同子配置中应当存在差异。
<ul>
<li><strong>原理</strong> 尽管不会同时被一个用户程序依赖，每个部署中，不同的子配置的程序映像通常仍需共存。在名称上要求差异允许文件系统直接支持这种策略。</li>
</ul>
</li>
</ul>
<h3 id="标识"><a class="header" href="#标识">标识</a></h3>
<p>　　不同平台可以标识符加以区分。由于平台受到不同环境因素决定的正交性，通常此类标识符可以分解为表示这些正交环境的标识符的元组形式，用 <code>-</code> 等字符分隔。</p>
<p>　　一种常用的方式是 GNU 构建系统的<a href="https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.69/html_node/System-Type.html#System-Type">系统类型(en-US)</a>，经典表示方式为三元组(triplet) ，或其省略形式：</p>
<ul>
<li>一般包括体系结构、系统厂商和系统软件环境。</li>
<li>第一项不可省略，之后的项可省略。</li>
<li>体系结构一般指定 CPU 要求的最小指令集架构。</li>
<li>系统厂商指集成平台的环境厂商。</li>
<li>系统软件环境保证满足 ABI 要求，可以包含操作系统及本机语言运行时实现的名称。</li>
</ul>
<p>　　确定为宿主环境时，系统软件同时指定操作系统和运行时环境而拆分为两项，三元组扩充为四元组，如 <a href="https://wiki.gentoo.org/wiki/CHOST">Gentoo 使用的 CHOST (en-US)</a>。</p>
<p>　　在不够充分体现平台的必要差异（尤其是体系结构相关的配置）时也可通过自行定义标识符并指定与三元组的对应关系，如 <a href="https://wiki.debian.org/Multiarch/Tuples">Debian multiarch (en-US)</a> 。</p>
<p>　　系统类型用来提供一定程度的兼容（替换和互操作）：</p>
<ul>
<li>系统类型代表了系统厂商的预设的配置集合，因此可提供符合相对上的（事实）标准的构建和运行环境。</li>
<li>这种兼容性有时会被过度依赖，乃至被误认为完全的 ABI 兼容：
<ul>
<li>系统类型不保证涵盖所有 ABI 细节，满足相同的系统类型的程序实例之间不一定符合完全相同的 ABI 而可相互替换或互操作，即原则上即不保证完全的 ABI 兼容。
<ul>
<li><strong>原理</strong> 实现的差异原则上不适合或无法通过系统类型区分。否则，系统类型事实上需要任意地长以涵盖不同细节，而会导致程序部署环境的碎片化，使维护兼容性的原始目的失去主要意义。</li>
</ul>
</li>
<li>一个主要实例：不同构建工具链生成的二进制程序之间不总是保证完全的 ABI 兼容。
<ul>
<li>同一个版本的同一工具链通过某些构建选项即可能构建出不能保证 ABI 兼容的二进制程序映像。
<ul>
<li>例如，GCC 使用 <code>-m</code> 前缀选项可能影响 ABI 。</li>
</ul>
</li>
<li>即便使用工具链发行版固定的默认预设选项，不同版本工具链在设计上不能完全保证二进制兼容性。
<ul>
<li>例如，为兼容 ISO C++11 中关于 <code>std::basic_string</code> 和 <code>std::list</code> 等 <a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 改动，GCC 5 显式提供<a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_dual_abi.html">不同的 ABI 配置</a> 而在支持这些改动的配置上[放弃对原有 libstdc++ 的 ABI 兼容保证。</li>
</ul>
</li>
</ul>
</li>
<li>相同的系统类型可以对应不同的依赖集合，已被作为实用的维护兼容性的方法。
<ul>
<li>这种差异通常隐藏在系统库之下，此时提供不同的二进制兼容映像可以在部署时对依赖系统库的程序隐藏这些差异。</li>
</ul>
</li>
<li><strong>注释</strong> 现代 Microsoft Windows（基于 Windows NT 执行体）是应用包括这类兼容性在内的多种策略的一个典型实例：
<ul>
<li>隐藏二进制差异的主要实例是 Microsoft Windows NT 的 Win32 和 <a href="https://zh.wikipedia.org/zh-cn/%E5%BE%AE%E8%BD%AFPOSIX%E5%AD%90%E7%B3%BB%E7%BB%9F">POSIX 子系统</a>，用户程序通过链接到不同的子系统 DLL ，可共享上层 ABI 。</li>
<li><a href="https://www.cygwin.com/">Cygwin</a> 是一个类似的 POSIX 子系统替代实现，其用户程序当前默认依赖系统库 <code>cygwin1.dll</code> 。</li>
<li>Windows Subsystem for Linux (WSL) 则不是这种兼容性的实例。
<ul>
<li>因为映像格式的差异，它的用户空间程序使用的系统类型更接近 x86_64-pc-linux（具体系统类型取决于安装的发行版；典型地是 x86_64-pc-linux-gnu ）。</li>
<li>部署 WSL 环境需要涉及一整套不同系统类型的二进制映像，仅在子系统的内部实现存在（对 Windows NT 执行体而言的）隐藏实现差异的情形。</li>
</ul>
</li>
<li>不涉及子系统但同样通过 DLL 隐藏二进制的实例是隐藏系统库的版本差异：不同版本的 C 运行时(CRT) 和 Microsoft VC++ 运行时库可以在一个 Windows 系统实例中共存。
<ul>
<li>特别地，MSVCRT 和 UCRT 作为不同的 CRT ，可在同一个系统映像中安装，并作为同一个系统类型的不同实现提供。</li>
<li>同时，不同的 CRT 可具有不同的工具链支持。</li>
<li>不同版本的运行时中每个子配置（多线程和非多线程版本、调试和非调试版本）共用相同的配置，在此不视为存在差异。</li>
<li>CRT 的多版本部署和其它一些系统中 libc 显式影响系统类型不同。
<ul>
<li><strong>原理</strong> 尽管同样是作为语言实现的一部分部署的系统库（至少在通常以此<a href="https://www.gnu.org/licenses/gcc-exception-3.1-faq.html">为由</a>取得<a href="https://www.gnu.org/licenses/gcc-exception-3.1.html">许可证豁免</a>的意义上），仅有后者通常是影响整个系统部署的库，而不适合通过相同的系统类型提供二进制不兼容的版本。否则，这会使整个系统中的几乎所有二进制程序映像之间都不具有二进制兼容性，而无法通过<a href="https://en.wikipedia.org/wiki/Dynamic_linker#Implementations">通常的机制</a>共享二进制代码。</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://www.msys2.org/docs/environments/MSYS">MSYS2 提供的不同环境</a> 是体现上述所有各种不同兼容性方式的一个复杂实例。
<ul>
<li>其中，MSYS2 环境基于 Cygwin ，是通过类似子系统 DLL 部署的兼容层，其用户程序当前默认依赖系统库 <code>msys-2.0.dll</code> 。</li>
<li>其余环境被视为原生的 Win32 应用，使用 Win32 子系统。按体系结构归类分组，每一组内可存在原生的共用相同系统类型的不同实现。
<ul>
<li>例如，<code>/mingw64</code> 、<code>/clang64</code> 和 <code>/ucrt64</code> 中部署的二进制程序共享系统类型 <code>x86_64-w64-mingw32</code> 。</li>
<li>其中 <code>/mingw64</code> 中的程序依赖的 CRT 和另两种共享 <code>x86_64-w64-mingw32</code> 的环境不同，而 <code>/clang64</code> 中的程序依赖的 C++ 运行时库也和另两种环境不同。</li>
</ul>
</li>
</ul>
</li>
<li>上述的这些配置仍然没有穷尽系统库的 ABI 的差异。
<ul>
<li>例如，GCC 工具链中预设了<a href="https://github.com/FrankHB/pl-docs/blob/master/zh-CN/mingw-vs-mingw-v64.md">无法保证 ABI 相互兼容的不同异常处理和线程模型</a>（每个不同的模型同时可需要部署不同的 DLL 作为系统库依赖）。</li>
</ul>
</li>
<li>包括上述 MSYS2 中的每个环境的使用 GCC 的不同发行版都预设了具体的内部依赖，如：
<ul>
<li>MSYS2 中，<code>x86_64-w64-mingw32</code> 环境使用 SEH 异常处理模型，其用户程序当前默认依赖系统库 <code>libgcc_s_seh-1.dll</code> 。</li>
<li>MSYS2 中，<code>i686-w64-mingw32</code> 环境使用 Dwarf2 线程处理模型，其用户程序当前默认依赖系统库 <code>libgcc_s_dw2-1.dll</code> 。</li>
<li>一些发行版如 <a href="https://github.com/niXman/mingw-builds">MinGW-builds</a> 默认使用 SjLj 异常处理模型，其用户程序当前默认依赖系统库 <code>libgcc_s_sjlj-1.dll</code> 。</li>
<li>MSYS2 和大多数其它 <a href="https://www.mingw-w64.org/">MinGW-w64</a> 发行版中长期使用 POSIX 线程模型提供较完善的 C++ 标准库线程特性实现，当前使用 <a href="https://www.mingw-w64.org/#headers-libraries-and-runtime">winpthreads</a> ，其用户程序当前默认依赖系统库 <code>libwinpthread-1.dll</code> 。</li>
<li>预期可在现代环境中替代 <a href="https://www.mingw-w64.org/contribute/#mcfgthread">winpthreads</a> 的 <a href="https://github.com/lhmouse/mcfgthread">mcfgthread</a> 对<a href="https://gcc.gnu.org/pipermail/gcc-patches/2022-October/602704.html">上游的修改已被讨论</a>，使用新的线程模型 <code>mcf</code> ，其用户程序会依赖不同的系统库。</li>
</ul>
</li>
<li>实现系统库时，可依赖非系统库 API 。通常，系统库可直接在运行时依赖 Windows NT 执行体。系统库之间也可存在其它单向的内部依赖。这些情形下，系统库自身不是符合环境要求的程序。
<ul>
<li>例如，mcfgthread 依赖非 Win32 API ，自身不是严格意义的 Win32 程序（尽管构建时仍在运行于 Win32 子系统的假定下链接）。</li>
<li>POSIX 子系统依赖 Win32 系统。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>为了避免兼容性保证过程的复杂性，除非另行指定，关于系统类型：
<ul>
<li>可标识通过源代码部署的单一配置。构建支持和其它外部环境应当被文档明确。</li>
<li>避免认为其它形式部署的唯一依据。特别地，支持可共享相同二进制部署的<a href="Terminology.zh-CN.html#%E5%B9%B3%E5%8F%B0%E9%85%8D%E7%BD%AE">平台子配置</a>。</li>
</ul>
</li>
</ul>
<p>　　除非另行指定：</p>
<ul>
<li>本项目的文档描述使用和三元组兼容的方式指定平台标识的基本形式。</li>
<li>若同一个平台配置存在多个不同的标识符，默认使用以下规则确定：
<ul>
<li>对使用 MinGW-w64 实现的工具链，使用<a href="https://sourceforge.net/p/mingw-w64/wiki2/TypeTriplets/">工具链定义的三元组</a></li>
<li>否则，使用 <a href="https://savannah.gnu.org/projects/config">GNU config</a> 的最新版本中指定的标识符。
<ul>
<li>即 <a href="https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD">config.guess</a> 和 <a href="https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD">config.sub</a> 脚本。</li>
</ul>
</li>
<li><strong>注意</strong> MinGW.org 和 MinGW-w64 都使用 <code>mingw32</code> 而非 <code>mingw64</code> ，这和 GNU guess 不同。应当避免<a href="https://github.com/msys2/MINGW-packages/issues/8020">可能存在的混淆</a>。</li>
</ul>
</li>
<li><strong>注释</strong> 通常不使用 <a href="https://clang.llvm.org/docs/CrossCompilation.html#target-triple">Clang 的三元组</a>。
<ul>
<li><strong>原理</strong> 尽管形式上更清晰，<code>&lt;sys&gt;-&lt;abi&gt;</code> 的划分实际使之成为四元组而非三元组，这种明确划分不总是符合现实的复杂需求。
<ul>
<li>这在关于 ABI 兼容的不明确性和歧义更加显著。这类不一致对适配更多不在现有清单上的平台更加困难，特别是未指定 <code>&lt;vendor&gt;</code> 时。
<ul>
<li><strong>注释</strong> 一个歧义的例子：<code>gnu</code> 在 Linux 上特指 glibc ，而在 Windows 上却指 libstdc++ 代表的 Itanium C++ ABI 实现。后者的 C 运行时库（通称 CRT ）却和 <code>msvc</code> 兼容。</li>
</ul>
</li>
<li>和 GNU guess 不同，Clang 三元组使用的情形相当有限，甚至<a href="https://stackoverflow.com/questions/15036909/">长期以来并不具有用户文档中明确的列表或检查规则</a>。
<ul>
<li>虽然 <code>clang</code> 接受 <code>-triple</code> 指定三元组，<code>clang --print-targets</code> 却输出平台标识符而非三元组。</li>
<li>三元组实际来自 <a href="https://llvm.org/doxygen/Triple_8h_source.html">LLVM 而非 Clang 的支持</a>。</li>
<li>更接近此处需求的是同时使用 LLVM 的 <a href="https://docs.rust-embedded.org/embedonomicon/compiler-support.html#built-in-target"><code>rustc --print target-list</code></a> 的输出。</li>
</ul>
</li>
<li>默认 <code>&lt;unknown&gt;</code> 但不一定在清单中被排除。这种随意性引起一些解析和理解上的困难。
<ul>
<li><strong>注释</strong> 在清单中滥用 <code>&lt;unknown&gt;</code> 的大量（却不是每个）例子可在 <code>rustc --print target-list</code> 的输出中找到。例如，通常读者（和系统维护者）难以理解：为何存在 <code>wasm32-unknown-emscripten</code> 和 <code>wasm32-wasi</code> 的同时还有 <code>wasm32-unknown-unknown</code> 而非 <code>wasm32-unknown</code> ？</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>具体构建过程可按需不同形式的标识符。
<ul>
<li><strong>原理</strong> 平台配置不一定通过系统类型描述。
<ul>
<li><strong>注释</strong> 例如，<code>cmake -G</code> 支持的标识依赖生成系统的配置，而非运行程序的系统类型。</li>
</ul>
</li>
<li><strong>原理</strong> 在不需要关心系统类型中各个组成部分的情形，其它的平台标识符可提供更简单明确的替代。
<ul>
<li><strong>注释</strong> <code>cmake -G clang --print-targets</code> 的结果是一个实例。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多平台构建"><a class="header" href="#多平台构建">多平台构建</a></h3>
<p>　　构建系统中可能涉及多个平台。</p>
<p>　　运行构建系统的环境和被构建的程序的环境不需要相同，对应的平台分别称为宿主平台(host platform) 和目标平台(target platform) 。宿主平台和目标平台相同时称为本机(native) 构建；不同时称为交叉(cross) 构建。</p>
<p>　　多个构建过程可能串联组成更大的构建过程。不同构建过程存在输出和输入之间的依赖。此时，前一过程输出的目标平台需要兼容于后一过程作为输入的宿主平台，否则无法直接运行。典型情况下这些平台是相同的，但也可以存在平台之间自身保证二进制<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>兼容性（如支持 x86_64 的体系结构上混用 i686 和 x86_64 ）的情况。</p>
<p>　　一些构建系统如 <a href="https://gcc.gnu.org/onlinedocs/gccint/Configure-Terms.html">GNU 工具链(en-US) 使用更复杂的术语</a>，单独引入构建(build) 平台。为确保一般性并简化模型，本文档不要求单独使用这个概念，而默认构建平台是第一级构建过程（即 GNU autoconf 的“配置”）的宿主平台。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This page specifies the language features from the standard shall be used in this project, by introducing several rules and then clearifying which features are <em>applied</em> to the project from specific project build revision and time.</p>
<p>This page also includes some related information of external projects about various language implementations.</p>
<p>The interface documentation for this project may be specified in the <code>doc</code> directory of the repository,  in the pages of wiki, or in the Doxygen comments around the declarations in the header files in the source code. All of them are in zh-CN by default.</p>
<p>Unless otherwise specified, notations of date and time are in UTC+8.</p>
<h1 id="notation"><a class="header" href="#notation">Notation</a></h1>
<p>&quot;<strong>NOTE</strong>&quot; indicates note for maintainers and it is not directly from the source of the concerned contents.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>Some external materials are referenced here by links in several categories. Entries in same category are listed ordinally specified by document numbers (if any).</p>
<p>Since only adopted revisions are applied, most superseded reversions are placed together. A paper of a collection of issues can have multiple revisions and it can be adopted more than once (e.g. <a href="http://wg21.link/p0165">P0165</a>); these revisions does not superseds each other.</p>
<h2 id="revision-and-timestamp"><a class="header" href="#revision-and-timestamp">Revision and timestamp</a></h2>
<p>Revisions are designated in forms of b<em>revision-number</em>[<em>time</em>], where <em>revision-number</em> is the number of revision and <em>time</em> is the timestamp issued for that revision in any of ISO 8601:2004 calendar time formats. The timestamp is usually a date conventionally with <em>YYYY</em>-<em>MM</em>-<em>DD</em>.</p>
<h2 id="list-of-items"><a class="header" href="#list-of-items">List of items</a></h2>
<p>Items of features are categorized in different lists with various status. The indentation of a list indicates the context: items with less indentation level cover the topic covering items with more indentation level.</p>
<h2 id="items-and-tags"><a class="header" href="#items-and-tags">Items and tags</a></h2>
<p>Each item in a list is normally specified by (committee) document or CWG/LWG/EWG/LEWG issue/DR(defect report) number with a link and a title. Paper as editor's report or issue/DR list  (but <em>not</em> list about contents out of these contents, e.g. specifically drafted resolution paper of one ore more DRs) should be collectively listed in a few list (so issues can be top-level items otherwise). Each item may be noted with following tags:</p>
<ul>
<li>&quot;adopted&quot; indicating the feature has been incorperated into <strong>the working paper</strong> (but <strong>not</strong> in this document) since the followed time which is usually the content of &quot;Disposition&quot; column from the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers">official document list</a></li>
<li>&quot;based on&quot; indicating one of the base specifications</li>
<li>&quot;dropped&quot; indicating abandoned in development</li>
<li>&quot;overriden by&quot; indicating new item taking effect instead of the current one</li>
<li>&quot;part of&quot; or &quot;parts of&quot; indicating not all contents of the specification</li>
<li>&quot;revised&quot; indicating one of the revised specifications
<ul>
<li>is often unique</li>
<li>should be significant, e.g. adopted previously; otherwise it can already be indexed by other lists of items, and if there are no other list is appropriate, it shall be in the &quot;outdated&quot; list</li>
</ul>
</li>
<li>&quot;see&quot; pointing to revised revisions</li>
<li>&quot;see also&quot; for related materials</li>
<li>&quot;see other derivation&quot; pointing to siblings</li>
<li>&quot;see subsequent&quot; pointing to subsequent new series</li>
<li>&quot;since&quot; with initial project build revision and time of applying (which is only applicable for features adopted or tentatively adopted in this document)</li>
<li>&quot;split from&quot; for the original item containing the material</li>
<li>&quot;subsumed by&quot; for the target of migration (e.g. for duplicated issues)</li>
<li>&quot;with&quot; indicating additional specifications not covered by specified one in the context</li>
</ul>
<h1 id="basic-rules"><a class="header" href="#basic-rules">Basic rules</a></h1>
<p><strong>The Forwarding Compatibility Rule:</strong> All language features incompatible with published/normative future versions of the language specification shall not be mandated or depend on.</p>
<p><strong>The Baseline Implementation Rule:</strong> Each feature being used shall have been implemented in general available version of at least 2 <a href="https://en.wikipedia.org/wiki/Free_and_open-source_software">FOSS</a> implementations.</p>
<h1 id="general-status"><a class="header" href="#general-status">General status</a></h1>
<p>The default configuration, <em>baseline</em>, is specified here. The features explicitly introduced to clearify dependences on the language implementations are also listed in this and following sections.</p>
<h2 id="conformance"><a class="header" href="#conformance">Conformance</a></h2>
<p>The conformance of languages and environments used in this project is specified using published versions of standards and technicle specifications, as well as drafts and proposals. For purpose of specification in this project, all of them are designated as specifications.</p>
<p>Several C++0x features are used since b206[2011-05-03]. These features are also in ISO C++11(ISO/IEC 14882:2011). Previously C++03 with TR1(ISO/IEC TR 19768:2007) was used. New versions of ISO C++ and technicle specifications are also considered:</p>
<ul>
<li>ISO C++14(ISO/IEC 14882:2014)</li>
<li>ISO C++17(ISO/IEC 14882:2017)</li>
<li>ISO C++20(ISO/IEC 14882:2020)</li>
</ul>
<h3 id="baseline"><a class="header" href="#baseline">Baseline</a></h3>
<p>C++11 is now default to conform.</p>
<p>As per the forwarding compatibility rules, all C++03 features conflicted with future versions of C++ (e.g. <code>export</code>) and all features already removed from C++17 (e.g. <code>std::auto_ptr</code>) are disallowed to rely on.</p>
<p>TR1 features are avoided and have been substituted by their C++11 counterparts.</p>
<p><a href="http://eel.is/c++draft">Draft standard</a> is considered in sake of avoiding conflicts with future versions of the standard.</p>
<h3 id="additional-specifications"><a class="header" href="#additional-specifications">Additional specifications</a></h3>
<p>The considered and (possibly incompletely) reviewed technical specifications beyond C++11 are:</p>
<ul>
<li>ISO/IEC TS 19568:2015 Programming Languages — C++ Extensions for Library Fundamentals
<ul>
<li><a href="http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=64031">Published</a> 2015-09-30 (ISO Store)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html">Final draft (N4480)</a> (2015-04-07)</li>
</ul>
</li>
</ul>
<p>(See <a href="http://wongmichael.com/2016/02/28/c17-content-predictionpre-jacksonville-and-post-kona-report/">here</a> for information about adoption in C++17.)</p>
<h2 id="replacements"><a class="header" href="#replacements">Replacements</a></h2>
<p>Several features in specifications beyond C++11 is not directly relied on, but this project provides some replacements (possibly with some custom extensions) as features to ease the work about compatibility.</p>
<p>Replacements are provided in a &quot;(mostly) drop-in&quot; manner, i.e. the base name of API are same, but with allowence of difference on qualified prefix and/or prefixes (of namespaces, mostly, to <code>std</code>; or of headers to be included). This allows user code replacing interface with a few alias declarations without changing of the program well-formedness and behavior. It is easy to change the underlying set of API as well as to pick a subset of them on purpose.</p>
<p>The replacements provided are bidirectionally drop-in replaceable, which can be used interchangably with the features they replace, except the compatibility exceptions specified below. However, such replacements are not guaranteed to be mixed arbitrary with the feature being replacements. The granularity of mixture with guaranteed usablity is a type or a template with any related operations relying on the type signature derived from that entity, unless otherwise specificed in documentation.</p>
<p>Some of other replacements are ony-way drop-in replacements, i.e., guaranteed being able to replace the correspoinding features in specifications without changing of meaning but not the other way.</p>
<h3 id="compatibility-exceptions"><a class="header" href="#compatibility-exceptions">Compatibility exceptions</a></h3>
<p>Several features cannot be implemented portably due to ISO C++ core language features are not available in virous target environments (e.g. in the baseline).</p>
<p>Emulation of (esp. core language) features involved such cases is limited, and it would be implemented in replacements with <em>best effort</em> when it is practibly implementatble.</p>
<p><strong>NOTE</strong> If the core language in the baseline does not limit the feasibility, the replacements shall still be the drop-in replaceable.</p>
<p><strong>Corollary</strong> Features limited by the core language are available <strong>conditionally</strong> depending on which language dialect is being used.</p>
<p><strong>NOTE</strong> Extensions of specific language implementations may loose the limitations, but there are still no guarantees.</p>
<p>For cases where the replaced features cannot be implemented portably in the baseline, the limitations shall be documented on related interface either with <code>\warning</code> command on each instances or with descriptions in the header including them, to inform users the existence of portability risks and the condition of availablity (i.e. which dialects it is guaranteed to work). To avoid frequent need, features totally unusable (e.g. features relying on variable templates) are not provided at all, thus only a few cases should be concerned.</p>
<p>Currently, compatibility limitations include:</p>
<ul>
<li>Availablilty of <code>constexpr</code> on functions and function templates may be limited, when the dialect of an earlier standard (before the edition of the standard requires them) is used.
<ul>
<li>As a result, operations relies on such replacements may not work in contexts requiring constant expressions.</li>
<li>Additional implementation support may improve the availability of <code>constexpr</code>.
<ul>
<li><strong>NOTE</strong> Sometimes, compiler builtins may provide <code>constexpr</code> being implementable without the limitation even an earlier standard is used; sometimes there are just no such extensions.</li>
</ul>
</li>
<li>Replacements of features beyond ISO C++20 shall have <code>constexpr</code> required by the interface, whenever they are implementable portably.
<ul>
<li><strong>Rationale</strong> With <code>std::is_constant_evaluated</code> since C++20, different paths of implementations of portable C++ code are allowed, so reducing the quality specifically for contexts not requring constant expressions is not a problem.</li>
</ul>
</li>
<li>If there are problems of implementation complexity of the replacments targeting before C++20 to meet the requirements of <code>constexpr</code> reducing the quality of the features used in the contexts not requiring constant expressions (e.g. expectable performance degration), <code>constexpr</code> may not be provided by design.
<ul>
<li><strong>Rationale</strong> Before C++14, <code>constexpr</code> has extra limitations on the function body. To work with the baseline without additional implementation complexity, <code>inline</code> may be used instead of <code>constexpr</code>.</li>
<li>Whether the specialized implementation with <code>constexpr</code> provided for C++14 and higher edition of the language standard is unspecified.</li>
<li><strong>NOTE</strong> Providing specialized implementations is a QoI (quality of implementation) issue. Typically, <code>constexpr</code> would be directly enabled when C++14 or some higher edition of the language standard is used.</li>
</ul>
</li>
<li>Concrete instances missing <code>constexpr</code> are listed below.
<ul>
<li><code>ystdex::addressof</code> may not have <code>constexpr</code> for specific types.
<ul>
<li><strong>NOTE</strong> Even the type is complete, there is no guarantee to rule out user-defined overloaded <code>operator&amp;</code> on the object.</li>
<li>In cases where <code>operator&amp;</code> is used, C++11 provides <code>std::addressof</code> to get the correct result. However, it is not designated with <code>constexpr</code>, which is available portably only since C++17.</li>
</ul>
</li>
<li>Replacements of features in <code>&lt;bits&gt;</code> (since C++20) may not have <code>constexpr</code>.</li>
</ul>
</li>
</ul>
</li>
<li>To determine whether a class is declared with <code>final</code> may be impossible.
<ul>
<li>It is not implementable without some implementation support before C++14 introduces <code>std::is_final</code>.</li>
<li><strong>NOTE</strong> <code>std::is_empty</code> is not implementable in portable C++ without such support. However, <code>std::is_empty</code> is provided by C++11 (in the baseline), so there shall be <em>no</em> limitation on determine whether a class is empty.</li>
</ul>
</li>
</ul>
<p>For better compatibility to evolution, additional exceptions are granted here:</p>
<ul>
<li>Type equivalence between provided and replaced types is not guaranteed even if they coexist in a same configuration of C++ implementation.
<ul>
<li>This allows mixture of different components served as different parts of the replaced interface at same time, as well as complement of interface already (insufficiently) implemented by the current C++ implementation.</li>
<li>Types may provided based on old revision of specification (e.g. by inheritance of classes).</li>
</ul>
</li>
<li>The <code>constexpr</code> specifier may be effectively omitteed in interface or implementation of the library when the environment is limited in a configuration with insufficient core language support.
<ul>
<li>The <code>constexpr</code> guaranteed by C++14 is not guaranteed available in a  configuartion ealier than C++14, since it may be missing of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3652.html">relaxing constraints</a> support in the core langauge implementation.</li>
<li>Any <code>constexpr</code> on <code>lambda-expression</code>s is not guaranteed available in a configuration eariler than C++17 even after adoption of <a href="P0170R1"><code>constexpr</code> lambda</a>, since it may be missing in the core langauge implementation.</li>
</ul>
</li>
<li>Operators may be introduced in declarations different to current version of specifications.
<ul>
<li>This is like [objects.within.classes] for private class members.</li>
<li>Comparison operators are no longer guaranteed accessible as independent entities (e.g. as operand of <code>&amp;</code> or accessing using <code>qualified-id</code>).
<ul>
<li>This is same to the direction of future standardization proposed in <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0790r0.html">P0790R0</a>.</li>
<li>This dependes on C++20 <code>&lt;=&gt;</code> operator, but it is not the only way.</li>
</ul>
</li>
<li>Other operators can be similar to get potentional great simplication of implementation.
<ul>
<li>Notably, with <a href="https://en.wikipedia.org/wiki/Barton%E2%80%93Nackman_trick">Barton–Nackman trick</a>, simplification can be achived partially as <code>&lt;=&gt;</code> on most overloadable operators (not only comparison).</li>
<li>Currently, most operators in this project is simplified by using of <code>YBase.YStandard.Operatos</code> API.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="subproject-structure"><a class="header" href="#subproject-structure">Subproject structure</a></h3>
<p>All of the replacements live in the top-level subproject YBase. The overall structure concerned here is:</p>
<ul>
<li>YBase
<ul>
<li>YDefinition (header file <code>ydef.h</code>)</li>
<li>LibDefect</li>
<li>YStandardEx</li>
<li><em>others</em></li>
</ul>
</li>
<li><em>other YSLib or YSLib-like top-level subprojects</em></li>
</ul>
<p>For YBase, all interface of C++ code is in the namespaces specified here. This includes replacements.</p>
<p>There is no well-defined behavior guaranteed if library-wise rules are violated. The rules are:</p>
<ul>
<li>No namespaces name can be introduced as top-level (directly enclosed in <a href="http://eel.is/c++draft/basic.scope.namespace#3">the global namespace</a>) namespace names except the namespaces specified here:
<ul>
<li>Namespaces <a href="http://eel.is/c++draft/namespace.constraints">specified by the standard</a> are used according to these rules.</li>
<li>The namespace <code>ystdex</code> provides most code not from YBase.LibDefect.</li>
<li>Namespace name (glob) pattern 'ystdex_*' are reserved.
<ul>
<li>Some of them may be used as top-level namespaces providing code additional to namespace <code>ystdex</code> without clash in <code>ystdex</code>, e.g. when ADL(argument dependent lookup) is unavoidable.</li>
</ul>
</li>
<li>Reserved namespace with public interface as well as namespace <code>ystdex</code> are collectively specified as <em>public top-level namespaces</em>.
<ul>
<li>Currently public top-level namespaces are:
<ul>
<li>namespace <code>ystdex</code></li>
<li>namespace <code>ystdex_swap</code></li>
</ul>
</li>
</ul>
</li>
<li>To simplify the code, any top-level names without explicit qualified preifx <code>::</code> shall be used as-if they are prefixed with with <code>::</code>.</li>
</ul>
</li>
<li>Only YBase.LibDefect can inject names into namespace <code>std</code> and other namespaces specified by the standard (as parts of implementation) when necessary in provide being <a href="http://eel.is/c++draft/conforming">conforming</a>. Otherwise, they shall be conform to <a href="http://eel.is/c++draft/constraints">the rules of the library user code</a>.</li>
<li>Documented reserved marco names besides <a href="http://eel.is/c++draft/reserved.names">the standard rules</a> shall be also avoided by the library user code.</li>
<li>All other cases are conform to <a href="http://eel.is/c++draft/requirements">the standard rules</a> except that the namespaces provided by the standard are replaced by the top-level namespaces specified above.</li>
</ul>
<p>Except for the file specified as &quot;drop-in replacement&quot;, a header specified by a rule of published standard or specification may or may not be directly aligned to the actual one in YBase, but there are clear many-interface-to-one-header relationship across the interface and headers by splitting the standard header to plural correspoinding header files. The purpose is to break down dependencies and to reduce the overhead of inclusion performed in preprocessing phase.</p>
<p>For other top-level subprojects, no replacements need to be considered. Unless otherwise specified, the baseline applies directly. If there needs replacements, use interface proveded by YBase for preference (but usually <em>not</em> YBase.LibDefect).</p>
<h3 id="components"><a class="header" href="#components">Components</a></h3>
<p>Replacements in YBase consist of following components with caveats:</p>
<ul>
<li><strong>YDefinition</strong>, i.e. <code>ydef.h</code>, provides various vendor-neutral compatible interface of language implementation by conditioanlly-defined preprocessing macros.
<ul>
<li>A few replacemnets are same to YStandardEx direct replacements below, except provided in the top-level namespace directly.</li>
</ul>
</li>
<li><strong>LibDefect</strong> implementation provide some interface conform directly to the standard, as complement of the language implementations provided by system and toolchain vendors.
<ul>
<li>The public headers shall be capable for direct use with any implementation meeting the requirements specified by the YSLib documentation (including following sections) as in-drop replacements for corresponding standard library headers.</li>
</ul>
</li>
<li><strong>YStandardEx replacements</strong> provide remain interface meet the functionality needs.
<ul>
<li><strong>YStandardEx direct replacements</strong> provide adaptive interface compatible and (almost) conforming to multile version of specifications.
<ul>
<li>To support adaptive use, the direct part of replacements may conditionally include different source, whose interface is specified as &quot;<strong>conditionally</strong>&quot; in this document.</li>
<li>The comformance requirements shall be clear to each interface.</li>
<li>Nonconforming interface may only occur with exactly same or one-to-one mapping of interface between namespace <code>std</code> and <code>ystdex</code> in the user code.</li>
<li>Nonconforming interface shall not introduce differences on requirements on the program using that interface.</li>
<li>Nonconforming interface shall be still compatible to other rules. That is, use of the interface shall not alter well-formness and the well-defined behavior of the program, except cases restricted by compatibility limitations.</li>
</ul>
</li>
<li><strong>YStandardEx dedicated replacements</strong> provide interface compatible to specifications as well as their drafts by less conformance requirements compared to direct replacements.
<ul>
<li>Nonconformance may occur in a form same to that in the case of YStandardEx direct replacements.</li>
<li>Nonconformance shall occur in a form that loosing the requirements of rules in the published standard or specification, or in a form with explicitly supported extensions which are not compatible to these rules; otherwise, the interface should be designed as direct replacements or non replacements.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>See following paragraphs for precise definition of components and more detailed descriptions on policies of their use.</p>
<h2 id="evolution"><a class="header" href="#evolution">Evolution</a></h2>
<p>For compatibility, the project may use different sets of rules in each parts. YBase is more stable and conservative to utilize new C++ features.</p>
<h3 id="longterm-policy"><a class="header" href="#longterm-policy">Longterm policy</a></h3>
<p>The longterm policy holds as:</p>
<ul>
<li><code>ydef.h</code>: For compatibility reasons, only a subset of C++11 would be mandated. The precise subset is unspecified and can vary between revisions.</li>
<li>YBase except LibDefect discussed above: Library features beyond C++11 would be used only available.</li>
<li>Other parts of the project: C++ features would be used aggressively (but still restrictd by the rules here, esp. the basic rules). Currently it is still in the baseline.</li>
</ul>
<h3 id="core-language-compatibility-features"><a class="header" href="#core-language-compatibility-features">Core language compatibility features</a></h3>
<p>Some core language feature have fallback in C++03 (e.g. <code>constexpr</code>) or library (e.g. <code>alignof</code>), mostly workaround in <code>ydef.h</code>, as well as some optional extensions (e.g. <code>__has_feature</code> and <code>__builtin_expect</code>) wrapped as implementation details. They are provided by YDefnition.</p>
<p>Some core language features not in the standard but provided by various adapted language implementations have been wrapped in a platform-neutral interface provided by YDefinition.</p>
<h3 id="library-implementation-patches"><a class="header" href="#library-implementation-patches">Library implementation patches</a></h3>
<p>Due to limitations of specific environments, some standard library features might be not usable without alternative implementations. They may be enabled by using additional headers in the module YBase.LibDefect instead of the corresponding standard headers.</p>
<p>As patches, namely parts of language implementations, the code in YBase.LibDefect can be highly implementation-specific. It has significant differences (which may cause undefined behavior without further guarantees) to the usual library and user code:</p>
<ul>
<li>It can be directly intrusive to the global namespace, <code>namespace std</code> and other implementation-specific namespaces, which may be reserved by the standard.</li>
<li>As part of the standard library implementation, it may use names reserved by the standard.</li>
<li>It may have implementation-specific contents intended only for internal use and guarded by conditional inclusion, because they are direct replacements for the standard library.</li>
</ul>
<p>The code has been carefully tuned to be compatible to supported environments, to keep out undefined behavior merely caused by this implementation.</p>
<h3 id="library-compatibility-features"><a class="header" href="#library-compatibility-features">Library compatibility features</a></h3>
<p>To reduce impact on user code to adopt new versions of specifications, several post-C++03 library features are provided in the top-level namespace <code>ystdex</code> (with inlined namespace if the features have been in published standards) in module YBase.YStandardEx, either by <code>using</code> declarations from namespace <code>std</code> iff. provided by the standard library, or being implemented from scratch when the features are not available from the standard library (not the library implementation, i.e. implementation-specific interface are still forbidden).</p>
<p>They are designed to be (bidirectionally) drop-in replacements (with necessary filename change in <code>#include</code> directives) of corresponding specific version of <code>std</code> or <code>std::experimental</code> interface, with a few exceptions:</p>
<ul>
<li>Except for some specialization of standard library templates, the enclosing namespace is not <code>std</code> so name lookup may behave differently to the standard library interface.
<ul>
<li>Use additional 'using ystdex::<em>NAME</em>;' to enable ADL(argument dependent lookup) for <em>NAME</em>.</li>
<li>Note <a href="http://www.eel.is/c++draft/global.functions#4">[global.functions]/4</a> is still conforming similarly. Any ADL beyond <code>namespace ystdex</code> shall be specified by the interface documentation.</li>
</ul>
</li>
<li>The overloaded operators may be implemented by ADL-only manner, i.e. declared as friend functions, rather than namespace scope entities.
<ul>
<li>Currently no entities are declared in this manner except for interface are ready for post-C++14 standard library features.</li>
</ul>
</li>
<li>It is unspecified that whether the concerned types of replacement API is identical to the types in the standard.
<ul>
<li>It is important to know this to avoid type introspection based on wrong type identical assumptions, including:
<ul>
<li>Using <code>static_assert</code> or some other meta operations based on static type equivalence.</li>
<li>RTTI or exception handling based on dynamic type identity.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>They are collectively called as <strong>YStandardEx direct replacements</strong> for the corresponding features being replaced.</p>
<p>YBase user code may use interface in public top-level namespaces instead of the counterparts in the namespaces mentioned above to simplify the migration. For components of direct replacements interface beyond ISO C++11, they are in correspoinding enclosed <strong>standard replacement namespaces</strong> which are inline namespaces enclosed unambiguously in public namespaces with a common namespace prefix pattern with same nested namespaces to the standard interface. For example:</p>
<ul>
<li>Interface first occurred or last updated in ISO C++14 in namespace <code>std</code> is in inline namespace <code>ystdex::cpp2014</code>.</li>
<li><code>std::pmr</code> interface introduced since ISO C++17 is in inline namespace <code>ystdex::pmr::cpp2017</code>.</li>
</ul>
<p>Note that a similar approach is also proposed for <code>std</code> separatedly as <em>shadow namespace</em> in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1473r0.pdf">P1473R0</a> for some slightly different purposes.</p>
<p>If there are multiple published versions of standard having modification on some entities denoted by a same name, there shall be one candidate or at least one extra alias declaration to reference it in the public top-level namespaces unambiguously, allowing omission of the inline namespace name normally but distinguishing on need. Deprecated features is not guaranteed provided unless explicitly specified to reduce confusion and restriction as per the future direction of feature using implied in this document. To avoid misconceptions, other replacements shall neither be provided in standard replacement namespaces or their enclosing namespaces thereof.</p>
<p>Ambiguity across different namespaces with mixture use of them shall also be avoided.</p>
<p>Components for the upcoming standard (in the working draft or Technicle Specifications, but not the published Internaltional Standard) are deliberately experimental as library compatibility features, so they are directly declared in public top-level namespaces.</p>
<p>As per the compatibility limitations of replacements, exceptional rules of compatibility to <code>std</code> interface are granted hereby:</p>
<ul>
<li>For entities used specifically in tag dispatching, only such use is required to be compatible as drop-in replacement. The differences shall be defined in documents about the replacement.</li>
</ul>
<p>Revised components of library compatibility features shall not be deprecated in the current (newest formal) standard.</p>
<h3 id="extended-library-compatibility-features"><a class="header" href="#extended-library-compatibility-features">Extended library compatibility features</a></h3>
<p>Some other interfaces in YBase.YStandardEx are designed as replacements for corresponding specific versions of <code>std</code> or <code>std::experimental</code> interface, as the compatibility features above, but with extra extensions, and with no restriction about the solution of <a href="http://wg21.cmeerw.net/lwg/issue2013%5D">LWG 2013</a> (that is, they may be with extra <code>constexpr</code>). They can be used as ony-way drop-in replacements.</p>
<p>Entities with extended library compatibility features to the replaced entites are collectively called as <strong>YStandardEx dedicated replacements</strong> of the corresponding features being replaced, where each of them meets following requirements:</p>
<ul>
<li>Except extensions, it shall be able to one-to-one mapped to the entity being replaced with exact functionality (albeit the name can be different in several cases, see below).</li>
<li>If it is neither a type nor a template of type (class template or alias template), or it is provided as some part of other compatibility features, its base name (<em>unqualified-id</em>) shall be same to the name of entity being replaced.</li>
<li>Its name shall be declared in public top-level namespaces or enclosed namespaces thereof, except the namespaces excluded by the rules specified previously.</li>
</ul>
<p>Components of extended library compatibility features not being dedicated replacements shall be declared in public top-level namespaces and may be declared in the same header of the compatibility features above.</p>
<h3 id="potential-library-compatibility-features"><a class="header" href="#potential-library-compatibility-features">Potential library compatibility features</a></h3>
<p>Some other interfaces in YBase.YStandardEx are designed close to correspongding specific versions of <code>std</code> or <code>std::experimental</code> interface, to be an implemantation base of above compatibility library features or extended library compatibility features. They are <strong>not</strong> replacements as they are not designed to be conforming to any version of the standard or technical specifications, nor always provided in a drop-in manner. Nevertheless, they may have features which can be directly mapped to the said specifications, with or without some resolutions of LWG issues applied.</p>
<p>Although as implementation of above features, they are totally in details, they can also be used as public interfaces as other parts of YSLib.</p>
<h2 id="reviewed"><a class="header" href="#reviewed">Reviewed</a></h2>
<p>The following editor's report has been fully reviewed (b593[2015-04-23]), which means all the resolutions in the paper are categorized in the following clauses:</p>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2370.html">N2370</a></li>
</ul>
<p><strong>NOTE</strong> There might exist minor differences between editor's report and the paper in the list, e.g. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3059.pdf">N3059</a> (rev 5.2) in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3091.html">N3091</a> is (rev 5.1). For these cases, only the later revisions at the point of time are reviewed and probably would not be updated unless necessary.</p>
<h2 id="to-be-done"><a class="header" href="#to-be-done">To be done</a></h2>
<p>Reviewing of following defect reports and resolutions are work in progress.</p>
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue215">CWG 215</a>: Template parameters are not allowed in <code>nested-name-specifier</code>s</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue218">CWG 218</a>: Specification of Koenig lookup (see also <a href="http://wg21.cmeerw.net/cwg/issue113">CWG 113</a> and <a href="http://wg21.cmeerw.net/cwg/issue143">CWG 143</a>)</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue397">CWG 397</a>: Same address for string literals from default arguments in inline functions?</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue667">CWG 667</a>: Trivial special member functions that cannot be implicitly defined</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1135">CWG 1135</a>: Explicitly-defaulted non-public special member functions
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue1136">CWG 1136</a>: Explicitly-defaulted explicit constructors</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1140">CWG 1140</a>: Incorrect redefinition of POD class</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1145">CWG 1145</a>: Defaulting and triviality</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1149">CWG 1149</a>: Trivial non-public copy operators in subobjects</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1208">CWG 1208</a>: Explicit <code>noexcept</code> in defaulted definition</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4320.html">N4320</a>: Make exception specifications be part of the type system
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue92">CWG 92</a>: Should exception-specifications be part of the type system?</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1946">CWG 1946</a>: <code>exception-specification</code>s vs pointer dereference (see also <a href="https://wg21.cmeerw.net/cwg/issue92">CWG 92</a> and <a href="https://wg21.cmeerw.net/ewg/issue169">EWG 169</a>)</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue2010">CWG 2010</a>: exception-specifications and conversion operators (see also <a href="https://wg21.cmeerw.net/cwg/issue92">CWG 92</a>, <a href="https://wg21.cmeerw.net/cwg/issue1798">CWG 1798</a>, <a href="https://wg21.cmeerw.net/cwg/issue1946">CWG 1946</a>, <a href="https://wg21.cmeerw.net/cwg/issue1975">CWG 1975</a>, <a href="https://wg21.cmeerw.net/cwg/issue1995">CWG 1995</a> and <a href="https://wg21.cmeerw.net/ewg/issue169">EWG 169</a>)</li>
<li><a href="https://wg21.cmeerw.net/ewg/issue169">EWG 169</a>: Make exception specifications be part of the type system</li>
</ul>
</li>
</ul>
<p>Reviewing of following editor's reports is work in progress.</p>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2008.html">N2008</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2283.html">N2283</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2589.html">N2589</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2799.html">N2799</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3001.html">N3001</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3091.html">N3091</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3938.html">N3938</a>
<ul>
<li>LWG motion 3: <a href="https://wg21.cmeerw.net/lwg/issue2188">LWG 2188</a> &quot;Reverse iterator does not fully support targets that overload <code>operator&amp;</code>&quot; with editorial fix</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4583.html">N4583</a>
<ul>
<li>LWG motion 6: <a href="http://wg21.link/p0220r1">P0220R1</a> &quot;Adopt library fundamentals v1 TS components for C++17&quot;) (incompletely applied)</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4603.html">N4603</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4619.html">N4619</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4661.html">N4661</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4714.html">N4714</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4740.html">N4740</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4764.html">N4764</a>
<ul>
<li>CWG motion 15: <a href="http://wg21.link/p0941r2">P0941R2 &quot;Feature-test macros&quot;</a></li>
<li>LWG motion 21: <a href="http://wg21.link/p0879r0">P0879R0 &quot;<code>constexpr</code> for <code>swap</code> and <code>swap</code>-related functions&quot;</a> applied, resolving 1 issue:
<ul>
<li><a href="http://wg21.link/lwg2800">LWG 2800</a>: <code>constexpr</code> <code>swap</code>
The following issues are being waiting to be resolved (and then be reviewed here) formally in public standards.</li>
</ul>
</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4792.html">N4792</a>
<ul>
<li>LWG motion 13: <a href="http://wg21.link/p0318r1">P0318R1 &quot;<code>unwrap_ref_decay</code> and <code>unwrap_reference</code>&quot;</a></li>
<li>LWG motion 21: <a href="http://wg21.link/p0591r4">P0591R4 &quot;Utility functions to implement uses-allocator construction&quot;</a></li>
</ul>
</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue943">CWG 943</a>: Is <code>T()</code> a temporary?
<ul>
<li><strong>NOTE</strong> see also <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2015/p0135r0.html">P0135R0</a></li>
</ul>
</li>
<li><a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2014/n3918.html">N3918</a> Core Issue 1299: Temporary objects vs temporary expressions
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue1299">CWG 1299</a>: “Temporary objects” vs “temporary expressions”
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue1651">CWG 1651</a>: Lifetime extension of temporary via reference to subobject</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1893">CWG 1893</a>: Function-style cast with braced-init-lists and empty pack expansions</li>
</ul>
</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1300">CWG 1300</a>
<ul>
<li>see also <a href="http://wg21.cmeerw.net/cwg/issue914">CWG 914</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1661">CWG 1661</a>: Preservation of infinite loops</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1722">CWG 1722</a>: Should lambda to function pointer conversion function be <code>noexcept</code>?</li>
</ul>
<h1 id="no-actions"><a class="header" href="#no-actions">No actions</a></h1>
<p>There are nothing to do of coding and further documentations for some resolutions.</p>
<p>Note in WG21 terms, NAD means &quot;not a defect&quot;, and TC1 means &quot;Technical Corrigendum 1&quot;.</p>
<h2 id="in-the-baseline"><a class="header" href="#in-the-baseline">In the baseline</a></h2>
<p>These issues are resolved as NAD and thus have been rejected by WG21 in the baseline, and there are no further changes to reopen:</p>
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue37">CWG 37</a>: When is <code>uncaught_exception()</code> <code>true</code>?</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue61">CWG 61</a>: Address of static member function &quot;<code>&amp;p-&gt;f</code>&quot;</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue109">CWG 109</a>: Allowing <code>::template</code> in <em>using-declaration</em>​s</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue130">CWG 130</a>: Sequence points and <em>new-expression</em>​s</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue84">LWG 84</a>: Ambiguity with <code>string::insert()</code></li>
<li><a href="http://wg21.cmeerw.net/ewg/issue91">EWG 91</a>: [tiny] <a href="http://wg21.cmeerw.net/cwg/issue622">Core issue 622</a>, Relational comparisons of arbitrary pointers
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue622">CWG 622</a>: Relational comparisons of arbitrary pointers (see <a href="http://wg21.cmeerw.net/ewg/issue91">EWG 91</a>)</li>
</ul>
</li>
<li>parts of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2173.html">N2173</a>: Core Extensions for Evolution
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue13">CWG 13</a>: <code>extern &quot;C&quot;</code> for Parameters of Function Templates</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue107">CWG 107</a>: linkage of operator functions</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue168">CWG 168</a>: C linkage of static members</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue229">CWG 229</a>: Partial specialization of function templates</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue294">CWG 294</a>: can <code>static_cast</code> drop exception specs (see also <a href="https://wg21.cmeerw.net/cwg/issue87">CWG 87</a>)</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue359">CWG 359</a>: Type definition inside anonymous union</li>
</ul>
</li>
</ul>
<p>These issues were once confirmed but are in NAD status now due to newer feature changes which have been adopted by the standard and by this project, so there are nothing further to do:</p>
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue395">CWG 395</a>: Conversion operator template syntax</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2386">LWG 2386</a>: <code>function::operator=</code> handles allocators incorrectly (see also <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0302r1.html">P0302R1</a>)</li>
</ul>
<p>These resolutions are already adopted as TC1, i.e. in C++03, and still effective (probably revised) in later versions of the standard:</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue25">CWG 25</a>: Exception specifications and pointers to members</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue30">CWG 30</a>: Valid uses of &quot;<code>::template</code>&quot;</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue84">CWG 84</a>: Overloading and conversion loophole used by <code>auto_ptr</code></li>
<li><a href="http://wg21.cmeerw.net/cwg/issue137">CWG 137</a>: <code>static_cast</code> of <em>cv</em> <code>void*</code></li>
<li><a href="http://wg21.cmeerw.net/cwg/issue178">CWG 178</a>: More on value-initialization (see also <a href="http://wg21.cmeerw.net/cwg/issue543">CWG 543</a>)</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue304">CWG 304</a>: Value-initialization of a reference</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue61">LWG 61</a>: Exception-handling policy for unformatted output</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue129">LWG 129</a>: Need error indication from <code>seekp()</code> and <code>seekg()</code></li>
<li><a href="http://wg21.cmeerw.net/lwg/issue136">LWG 136</a>: <code>seekp</code>, <code>seekg</code> setting wrong streams?</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue209">LWG 209</a>: <code>basic_string</code> declarations inconsistent</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue227">LWG 227</a>: <code>std::swap()</code> should require <code>CopyConstructible</code> or <code>DefaultConstructible</code> arguments</li>
<li><a href="www.open-std.org/jtc1/sc22/wg21/docs/papers/2000/n1219.htm">N1219</a>: PROPOSED RESOLUTION TO LIBRARY ISSUE 60
<ul>
<li><a href="http://wg21.cmeerw.net/lwg/issue60">LWG 60</a>: What is a formatted input function?</li>
</ul>
</li>
</ul>
<h2 id="not-related-to-user-code"><a class="header" href="#not-related-to-user-code">Not related to user code</a></h2>
<p>These issues are resolved as NAD or NAD editorial and thus nothing to do for user code:</p>
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue1384">CWG 1384</a>: <code>reinterpret_cast</code> in constant expressions</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue435">CWG 1415</a>: Change &quot;declararation or definition&quot; to &quot;declaration&quot;</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1520">CWG 1520</a>: Alias template specialization vs pack expansion (see also <a href="http://wg21.cmeerw.net/cwg/issue1558">CWG 1558</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue299">LWG 299</a>: Incorrect return types for iterator dereference
<ul>
<li>resolved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue392">LWG 392</a>: 'equivalence' for input iterators</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue526">LWG 526</a>: Is it undefined if a function in the standard changes in parameters?</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue529">LWG 529</a>: The standard encourages redundant and confusing preconditions</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue580">LWG 580</a>: unused allocator members</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue2006">LWG 2006</a>: <code>emplace</code> broken for associative containers
<ul>
<li>proposed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3178.htm">N3178</a>: <code>emplace</code> broken for associative containers</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2204">LWG 2204</a>: <code>reverse_iterator</code> should not require a second copy of the base iterator</li>
</ul>
<p>These post-C++03 draft resolutions are non-normative, purely editorial or conceptional, so no actions could be taken (revised b843[2018-11-10]):</p>
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue113">CWG 113</a>: Visibility of called function</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue119">CWG 119</a>: Object lifetime and aggregate initialization</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue357">CWG 357</a>: Definition of signature should include name</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue404">CWG 404</a>: Unclear reference to construction with non-trivial constructor (<strong>NOTE</strong> partially superseded by new wording in [basic.life] proposed by <a href="https://wg21.cmeerw.net/cwg/issue1751">CWG 1751</a> and <a href="https://wg21.cmeerw.net/cwg/issue2256">CWG 2256</a>)</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue413">CWG 413</a>: Definition of &quot;empty class&quot;</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue452">CWG 452</a>: Wording nit on description of <code>this</code>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2370.html">partially adopted</a></li>
<li><a href="http://wg21.cmeerw.net/cwg/issue538">CWG 538</a>: Definition and usage of structure, POD-struct, POD-union, and POD class
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue327">CWG 327</a>: Use of &quot;structure&quot; without definition</li>
</ul>
</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue582">CWG 582</a>: Template conversion functions</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue594">CWG 594</a>: Coordinating issues 119 and 404 with delegating constructors (see <a href="http://wg21.cmeerw.net/cwg/issue119">CWG 119</a> and <a href="http://wg21.cmeerw.net/cwg/issue404">CWG 404</a>)</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue618">CWG 618</a>: Casts in preprocessor conditional expressions</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue627">CWG 627</a>: Values behaving as types</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue999">CWG 999</a>: “Implicit” or “implied” object argument/parameter?</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue542">LWG 542</a>: <code>shared_ptr</code> observers</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue610">LWG 610</a>: Suggested non-normative note for C++0x (i.e. small function object optimization)</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue616">LWG 616</a>: missing '<code>typename</code>' in <code>ctype_byname</code></li>
<li><a href="http://wg21.cmeerw.net/lwg/issue628">LWG 628</a>: Inconsistent definition of <code>basic_regex</code> constructor</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue640">LWG 640</a>: 27.6.2.5.2 does not handle (<code>unsigned</code>) <code>long long</code> (i.e. for <code>ostream::operator&lt;&lt;</code>), <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2370.html">outdated</a></li>
<li><a href="http://wg21.cmeerw.net/lwg/issue972">LWG 972</a>: The term &quot;Assignable&quot; undefined but still in use</li>
<li>LWG 2135
<ul>
<li><a href="http://wg21.cmeerw.net/lwg/issue2240">LWG 2240</a>: Probable misuse of term &quot;function scope&quot; in [thread.condition]</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2310">LWG 2310</a>: Public exposition only member in <code>std::array</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2434">LWG 2434</a>: <code>shared_ptr::use_count()</code> is efficient</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2755">LWG 2755</a>: §[string.view.io] uses non-existent <code>basic_string_view::to_string</code> function</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2775.htm">N2775</a>: Small library thread-safety revisions</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a>: Iterators in C++0x</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3966.html">N3966</a>: Fixes for <code>optional</code> objects (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4078.html">N4078</a>)</li>
<li>editorial change in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4714.html">N4714</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0134r0.html">P0134R0</a>: Introducing a name for <em>brace-or-equal-initializer</em>​s for non-static data members</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0583r0.pdf">P0583R0</a>: <code>std::byte</code> is the correct name</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1076r1.html">P1076R1</a>: Editorial clause reorganization <a href="https://github.com/cplusplus/draft/blob/master/papers/n4764.md">with modification</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0509r1">P0509R1</a>: Updating &quot;Restrictions on exception handling&quot; (adopted: accepted by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4664.pdf">N4664</a>)
<ul>
<li>see national body comments GB 41 and GB42 in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4664.pdf">N4664</a>: ISO/IEC CD 14882, C++ 2017, National Body Comments</li>
</ul>
</li>
</ul>
<p>These post-C++03 draft resolutions would <strong>never</strong> be depended on because they are only intended useful for language implementations and there shall be no compatibility problems for conforming code (revised b593[2015-04-23]):</p>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2194.pdf">N2194</a>: <code>decltype</code> for the C++0x Standard Library</li>
</ul>
<h2 id="outdated"><a class="header" href="#outdated">Outdated</a></h2>
<p>These resolutions are only about TR1 or features have been formally deprecated/removed from current ISO C++, so shall never be depended on:</p>
<ul>
<li><a href="http://wg21.cmeerw.net/lwg/issue527">LWG 527</a>: <code>tr1::bind</code> has lost its Throws clause</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue588">LWG 588</a>: requirements on zero sized <code>tr1::array</code>s and other details (for <code>std::array</code>, resolved by <a href="http://wg21.cmeerw.net/lwg/issue776">LWG 776</a>)</li>
</ul>
<p>These issues are duplicate (in &quot;dup&quot; status):</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue133">CWG 133</a>: Exception specifications and checking (subsumed by <a href="http://wg21.cmeerw.net/cwg/issue87">CWG 87</a> and <a href="http://wg21.cmeerw.net/cwg/issue92">CWG 92</a>)</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue595">CWG 595</a>: Exception specifications in templates instantiated from class bodies (subsumed by <a href="http://wg21.cmeerw.net/cwg/issue1330">CWG 1330</a>)</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1300">CWG 1300</a>: <code>T()</code> for array types (duplicate of <a href="http://wg21.cmeerw.net/cwg/issue914">CWG 914</a>)</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1568">CWG 1568</a>: Temporary lifetime extension with intervening cast (duplicate of <a href="http://wg21.cmeerw.net/cwg/issue1376">CWG 1376</a>)</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue479">LWG 479</a>: Container requirements and placement new (duplicate of <a href="http://wg21.cmeerw.net/lwg/issue580">LWG 580</a>)</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue486">LWG 486</a>: <code>min</code>/<code>max</code> CopyConstructible requirement is too strict (duplicate of <a href="http://wg21.cmeerw.net/lwg/issue281">LWG 281</a>)</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue2775">LWG 2775</a>: <code>reverse_iterator</code> is does not compile for fancy pointers (duplicate of <a href="https://wg21.cmeerw.net/lwg/issue1052">LWG 1052</a>)</li>
</ul>
<p>These resolutions are superseded by later modification on the working paper:</p>
<ul>
<li><a href="http://wg21.cmeerw.net/lwg/issue759">LWG 759</a>: A reference is not an object (see <a href="http://wg21.cmeerw.net/lwg/issue1204">LWG 1204</a>)</li>
</ul>
<p>These resolutions are overriden by later issues after publication:</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue2022">CWG 2022</a>: Copy elision in constant expressions (overriden by <a href="https://wg21.cmeerw.net/cwg/issue2278">CWG 2278</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue235">LWG 235</a>: No specification of default ctor for <code>reverse_iterator</code> (overriden by <a href="https://wg21.cmeerw.net/lwg/issue1012">LWG 1012</a>)</li>
</ul>
<p>These resolutions are superseded and resolved by later issues before the publication:</p>
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue35">CWG 35</a>: Definition of default-initialization (see <a href="http://wg21.cmeerw.net/cwg/issue178">CWG 178</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2451">LWG 2451</a>: [fund.ts.v2] <code>optional&lt;T&gt;</code> should 'forward' <code>T</code>'s implicit conversions (see <a href="https://wg21.cmeerw.net/lwg/issue2756">LWG 2756</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2745">LWG 2745</a>: [fund.ts.v2] Implementability of <a href="https://wg21.cmeerw.net/lwg/issue2451">LWG 2451</a> (see <a href="https://wg21.cmeerw.net/lwg/issue2756">LWG 2756</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2753">LWG 2753</a>: Optional's constructors and assignments need constraints (see <a href="https://wg21.cmeerw.net/lwg/issue2756">LWG 2756</a>)</li>
<li><a href="https://issues.isocpp.org/show_bug.cgi?id=72">LEWG 72</a>: <code>bad_optional_access</code> should derive from <code>std::exception</code>, not <code>std::logic_error</code> (see <a href="https://wg21.cmeerw.net/lwg/issue2842">LWG 2806</a>)</li>
</ul>
<p>These papers are superseded and newer revisions have been reviewed, so no further actions would be taken:</p>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1489.pdf">N1489</a>: Templates aliases for C++ (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2112.pdf">N2112</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1599.html">N1599</a>: <a href="https://wg21.cmeerw.net/lwg/issue431">Issue 431</a>: Swapping containers with unequal allocators (see subsequent <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2525.pdf">N2525</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1890.pdf">N1890</a>: Initialization and initializers (see subsequent <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1919.pdf">N1919</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1919.pdf">N1919</a>: Initializer lists (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2100.pdf">N2100</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1932.pdf">N1932</a>: Random Number Generation in C++0X: A Comprehensive Proposal (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2032.pdf">N2032</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1961.html">N1961</a>: Wording for range-based for-loop (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2196.html">N2196</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1968.pdf">N1968</a>: Lambda expressions and closures for C++ (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2329.pdf">N2329</a>: Lambda expressions and closures for C++ (Revision 1))</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2032.pdf">N2032</a>: Random Number Generation in C++0X: A Comprehensive Proposal, version 2 (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2079.pdf">N2079</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2062.html">N2062</a>: POD's Revisited (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2102.html">N2102</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2079.pdf">N2079</a>: Random Number Generation in C++0X: A Comprehensive Proposal, version 3 (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2111.pdf">N2111</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2095.html">N2095</a>: <code>long long</code> Goes to the Library (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2114.html">N2114</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2100.pdf">N2100</a>: Initializer lists (Rev 2.) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2215.pdf">N2215</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2102.html">N2102</a>: POD's Revisited; Resolving Core Issue 568 (Revision 1) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2172.html">N2172</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2112.pdf">N2112</a>: Templates Aliases (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2258.pdf">N2258</a>)
<ul>
<li><strong>NOTE</strong> The <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/">page</a> missed the link to Previous Version.</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2151.pdf">N2151</a>: Variadic Templates for the C++0x Standard Library (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2192.pdf">N2192</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2172.html">N2172</a>: POD's Revisited; Resolving Core Issue 568 (Revision 2) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2230.html">N2230</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2192.pdf">N2192</a>: Variadic Templates for the C++0x Standard Library (Revision 1) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2242.pdf">N2242</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2196.html">N2196</a>: Wording for range-based <code>for</code>-loop (revision 1) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2243.html">N2243</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2210.html">N2210</a>: Defaulted and Deleted Functions (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2326.html">N2326</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2202.html">N2202</a>: C99 Compatibility : <code>__func__</code> and predeclared identifiers (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2251.html">N2251</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2215.pdf">N2215</a>: Initializer lists (Rev. 3) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2385.pdf">N2385</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2217.pdf">N2217</a>: Placement Insert for Containers (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2268.pdf">N2268</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2230.html">N2230</a>: POD's Revisited; Resolving Core Issue 568 (Revision 3) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2294.html">N2294</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2236.pdf">N2236</a>: Towards support for attributes in C++ (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2379.pdf">N2379</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2243.html">N2243</a>: Wording for range-based <code>for</code>-loop (revision 2) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2394.html">N2394</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2251.html">N2251</a>: C99 Compatibility : <code>__func__</code> and predeclared identifiers (revision 1) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2340.htm">N2340</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2268.pdf">N2268</a>: Placement Insert for Containers (Revision 1) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2345.pdf">N2345</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2294.html">N2294</a>: POD's Revisited; Resolving Core Issue 568 (Revision 4) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2342.htm">N2342</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2326.html">N2326</a>: Defaulted and Deleted Functions (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2346.htm">N2346</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2329.pdf">N2329</a>: Lambda expressions and closures for C++ (Revision 1) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2413.pdf">N2413</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2345.pdf">N2345</a>: Placement Insert for Containers (Revision 2) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2642.pdf">N2642</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2379.pdf">N2379</a>: Towards support for attributes in C++ (Revision 2) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2418.pdf">N2418</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2385.pdf">N2385</a>: Initializer lists WP wording (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2531.pdf">N2531</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2394.html">N2394</a>: Wording for range-based <code>for</code>-loop (revision 3) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2778.htm">N2778</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2413.pdf">N2413</a>: Lambda Expressions and Closures: Wording for Monomorphic Lambdas (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2487.pdf">N2487</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2418.pdf">N2418</a>: Towards support for attributes in C++ (Revision 3) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2553.pdf">N2553</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2477.pdf">N2477</a>: Uniform initialization design choices (Revision 2) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2532.pdf">N2532</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2487.pdf">N2487</a>: Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 2) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2529.pdf">N2529</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2529.pdf">N2529</a>: Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 3) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2550.pdf">N2550</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2531.pdf">N2531</a>: Initializer lists WP wording (Revision 2) (see subsequent <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2575.pdf">N2575</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2532.pdf">N2532</a>: Uniform initialization design choices (Revision 2) (see subsequent <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2575.pdf">N2575</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2550.pdf">N2550</a>: Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 4) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf">N2927</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2553.pdf">N2553</a>: Towards support for attributes in C++ (Revision 4) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2751.pdf">N2751</a>; the unavailable revised revision N2663 is wrong on <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/">document list</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2575.pdf">N2575</a>: Initializer Lists — Alternative Mechanism and Rationale (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2640.pdf">N2640</a>)</li>
<li><a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2008/n2635.html">N2635</a>: Local and Unnamed Types as Template Arguments (revised by <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2008/n2657.htm">N2657</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2640.pdf">N2640</a>: Initializer Lists — Alternative Mechanism and Rationale (v. 2) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2672.htm">N2672</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2642.pdf">N2642</a>: Proposed Wording for Placement Insert (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2680.pdf">N2680</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2751.pdf">N2751</a>: Towards support for attributes in C++ (Revision 5) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2761.pdf">N2761</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2778.htm">N2778</a>: Wording for range-based <code>for</code>-loop (revision 4) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2930.html">N2930</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2820.pdf">N2820</a>: Adding heterogeneous comparison lookup to associative containers (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2882.pdf">N2882</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2882.pdf">N2882</a>: Adding heterogeneous comparison lookup to associative containers for TR2 (Rev 1) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3465.pdf">N3465</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2904.pdf">N2904</a>: Defining default copy and move (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2953.html">N2953</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2953.html">N2953</a>: Defining Move Special Member Functions (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2987.html">N2987</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2987.html">N2987</a>: Defining Move Special Member Functions (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3044.html">N3044</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3044.html">N3044</a>: Defining Move Special Member Functions (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3053.html">N3053</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3149.html">N3149</a>: From <em>Throws: Nothing</em> to <code>noexcept</code> (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3195.htm">N3195</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3248.pdf">N3248</a>: <code>noexcept</code> Prevents Library Validation (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3279.pdf">N3279</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3433.html">N3433</a>: Clarifying Memory Allocation (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3537.html">N3537</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3465.pdf">N3465</a>: Adding heterogeneous comparison lookup to associative containers for TR2 (Rev 2) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3657.htm">N3657</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3537.html">N3537</a>: Clarifying Memory Allocation (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3664.html">N3664</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3597.html">N3597</a>: Relaxing constraints on <code>constexpr</code> functions (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3652.html">N3652</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3598.html">N3598</a>: <code>constexpr</code> member functions and implicit <code>const</code> (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3652.html">N3652</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3727.html">N3727</a>: A proposal to add <code>invoke</code> function template (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4169.html">N4169</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3873.html">N3873</a>: Improved insertion interface for unique-key maps (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4006.html">N4006</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4240.html">N4240</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4002.pdf">N4002</a>: Cleaning‐up <code>noexcept</code> in the Library (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4227.pdf">N4227</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4006.html">N4006</a>: An improved <code>emplace()</code> for unique-key maps (dropped; see other derivation of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3873.html">N3873</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4017.htm">N4017</a>: Non-member <code>size()</code> and more (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4155.htm">N4155</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4056.html">N4056</a>: Minimal incomplete type support for standard containers (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4371.html">N4371</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4151.html">N4151</a>: TriviallyCopyable <code>reference_wrapper</code> (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4277.html">N4277</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4155.htm">N4155</a>: Non-member <code>size()</code> and more (Revision 1) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4280.pdf">N4280</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4227.pdf">N4227</a>: Cleaning-up noexcept in the Library (Rev 2) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4258.pdf">N4258</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4228.pdf">N4228</a>: Refining Expression Evaluation Order for Idiomatic C++ (see subsequent <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0145r0.pdf">P0145R0</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4240.html">N4240</a>: Improved insertion interface for unique-key maps (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4279.html">N4279</a>)</li>
<li><a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2014/n4334.html">N4334</a>: Wording for <code>bool_constant</code> (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4389.html">N4389</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4371.html">N4371</a>: Minimal incomplete type support for standard containers, revision 2 (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4390.html">N4390</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4390.html">N4390</a>: Minimal incomplete type support for standard containers, revision 3 (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4371.html">N4510</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4429.html">N4429</a>: Rewording inheriting constructors ((<a href="https://wg21.cmeerw.net/cwg/issue1941">core issue 1941</a> et al) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0136r0.html">P0136R0</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4446.html">N4446</a>: The missing <em><code>INVOKE</code></em> related trait (i.e. <code>is_callable</code>) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0077r0.html">P0077R2</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0136r0.html">P0136R0</a>: Rewording inheriting constructors ((<a href="https://wg21.cmeerw.net/cwg/issue1941">core issue 1941</a> et al) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0136r1.html">P0136R1</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0145r0.pdf">P0145R0</a>: Refining Expression Evaluation Order for Idiomatic C++ (Revision 1) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r1.pdf">P0145R1</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0068r0.pdf">P0068R0</a>: Proposal of <code>[[unused]]</code>, <code>[[nodiscard]]</code> and <code>[[fallthrough]]</code> attributes. (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0188r0.pdf">P0188R0</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0189r0.pdf">P0189R0</a> in parts, see subsequent <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0212r0.pdf">P0212R0</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0077r0.html">P0077R0</a>: <code>is_callable</code>, the missing <em><code>INVOKE</code></em> related trait (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0077r1.html">P0077R1</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0077r1.html">P0077R1</a>: <code>is_callable</code>, the missing <em><code>INVOKE</code></em> related trait (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0077r2.html">P0077R2</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r1.pdf">P0145R1</a>: Refining Expression Evaluation Order for Idiomatic C++ (Revision 2) (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r2.pdf">P0145R2</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r2.pdf">P0145R2</a>: Refining Expression Evaluation Order for Idiomatic C++ (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r3.pdf">P0145R3</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0188r0.pdf">P0188R0</a>: Wording for <code>[[fallthrough]]</code> attribute. (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0188r1.pdf">P0188R1</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0189r0.pdf">P0189R0</a>: Wording for <code>[[nodiscard]]</code> attribute. (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0189r1.pdf">P0189R1</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0212r0.pdf">P0212R0</a>: Wording for <code>[[maybe_unused]]</code> attribute. (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0212r1.pdf">P0212R1</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0302r0.html">P0302R0</a>: Deprecating Allocator Support in <code>std::function</code> (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0302r1.html">P0302R1</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1089r2.pdf">P1089R2</a>: Sizes Should Only span Unsigned (see subseqent <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1227r1.html">P1227R1</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1227r0.html">P1227R0</a>: Signed <code>ssize()</code> functions, unsigned <code>size()</code> functions (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1227r1.html">P01227R1</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1227r1.html">P1227R1</a>: Signed <code>ssize()</code> functions, unsigned <code>size()</code> functions (revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1227r2.html">P01227R2</a>)</li>
</ul>
<p>These papers have been previously adopted but superseded by newer adopted papers, so no further actions would be taken:</p>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2525.pdf">N2525</a>: Allocator-specific Swap and Move Behavior (adopted 2008-03, in editor's report <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2589.html">N2589</a>; revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3672.html">N3672</a>: A proposal to add a utility class to represent optional objects (Revision 4) (adopted 2013-04; revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3793.html">N3793</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0077r2.html">P0077R2</a>: <code>is_callable</code>, the missing <em><code>INVOKE</code></em> related trait (adopted 2016-02; revised by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0604r0.html">P0604R0</a>)</li>
</ul>
<p>These features were still under development but the approved versions were superseded (note that the superseded versions may still newer than currently adopted version), and not adopted in this document:</p>
<ul>
<li><a href="http://wg21.cmeerw.net/ewg/issue22">EWG 22</a>: N4030, 3745, N3694 Feature-testing recommendations for C++, N3435 Standardized feature-test macros (for adopted version, see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4200.htm">N4200</a>)
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3435.htm">N3435</a>: Standardized feature-test macros</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3694.htm">N3694</a>: Feature-testing recommendations for C++</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3745.htm">N3745</a>: Feature-testing recommendations for C++</li>
<li><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2014/n4030.htm">N4030</a>: Feature-testing recommendations for C++</li>
<li><a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2015/p0096r0.html">P0096R0</a>: Feature-testing recommendations for C++</li>
<li><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0096r4.html">P0096R4</a>: Feature-testing recommendations for C++ (see subsequent <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0941r0.html">P0941R0</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0941r0.html">P0941R0</a>: Integrating feature-test macros into the C++ WD</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0941r1.html">P0941R1</a>: Integrating feature-test macros into the C++ WD</li>
</ul>
</li>
<li><a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2014/n3890.html">N3890</a>: <code>Container&lt;Incomplete Type&gt;</code> (partially superseded by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4056.html">N4056</a>)</li>
</ul>
<h2 id="revoked"><a class="header" href="#revoked">Revoked</a></h2>
<p>These features were once adopted by the working paper but later removed away, so no actions would be taken until introduced to the draft again:</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue1308">CWG 1308</a>: Completeness of class type within an exception-specification (see <a href="https://wg21.cmeerw.net/cwg/issue1330">CWG 1330</a>)</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue86">LWG 1029</a>: Specialized algorithms for memory management need to be concept-constrained templates</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue1001">LWG 1001</a>: Pointers, concepts and headers (see <a href="http://wg21.cmeerw.net/lwg/issue1178">LWG 1178</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2525.pdf">N2525</a>: Allocator-specific Swap and Move Behavior (i.e. <code>allocator_propagate_*</code>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2620.pdf">N2620</a>: Concepts for the C++0x Standard Library: Diagnostics library</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2736.pdf">N2736</a>: Concepts for the C++0x Standard Library: Numerics (Revision 3)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2755.htm">N2755</a>: Concepts for the C++0x Standard Library: Chapter 17 -Introduction (Revision 2)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2758.pdf">N2758</a>: Iterator Concepts for the C++0x Standard Library (Revision 5)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2759.pdf">N2759</a>: Concepts for the C++0x Standard Library: Algorithms (Revision 5)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2768.pdf">N2768</a>: Allocator Concepts, part 1 (revision 2)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2770.pdf">N2770</a>: Concepts for the C++0x Standard Library: Utilities (Revision 5)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2773.pdf">N2773</a>: Proposed Wording for Concepts (Revision 9)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2774.pdf">N2774</a>: Foundational Concepts for the C++0x Standard Library (Revision 5)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2776.pdf">N2776</a>: Concepts for the C++0x Standard Library: Containers (Revision 4)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2777.pdf">N2777</a>: Concepts for the C++0x Standard Library: Iterators (Revision 4)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2779.pdf">N2779</a>: Concepts for Clause 18: Part 2</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2780.pdf">N2780</a>: Named Requirements for C++0X Concepts, version 2</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2786.pdf">N2786</a>: Simplifying <code>unique_copy</code> (Revision 1)</li>
</ul>
<p>There are actions taken by the committee to remove away some former working draft features which are never used in this project:</p>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2549.htm">N2549</a>: Excision of Clause 31 (i.e. <code>&lt;date_time&gt;</code>)</li>
</ul>
<h2 id="non-defects"><a class="header" href="#non-defects">Non defects</a></h2>
<p>These out-of-baseline issues are resolved as NAD:</p>
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue1005">CWG 1005</a>: Qualified name resolution in member functions of class templates (see also <a href="http://wg21.cmeerw.net/cwg/issue1017">CWG 1017</a>; note <a href="http://wg21.cmeerw.net/cwg/issue515">CWG 515</a> is still effective)</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1334">CWG 1334</a>: Layout compatibility and cv-qualification</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue466">LWG 466</a>: <code>basic_string</code> ctor should prevent null pointer error</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue760">LWG 760</a>: The <code>emplace</code> issue (see <a href="http://wg21.cmeerw.net/lwg/issue2164">LWG 2164</a> which is still open)</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue763">LWG 763</a>: Renaming <code>emplace()</code> overloads (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2680.pdf">N2680</a> renamed one of the overloads to <code>emplace_hint</code>; for related discussion see <a href="http://wg21.cmeerw.net/lwg/issue1302">LWG 1302</a>)</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue1202">LWG 1202</a>: <code>integral_constant</code> needs a spring clean</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue1302">LWG 1302</a>: different emplace semantics for sequence and associated containers</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue2311">LWG 2311</a>: Allocator requirements should be further minimized</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2319">LWG 2319</a>: <code>basic_string</code>'s move constructor should not be <code>noexcept</code></li>
</ul>
<h2 id="not-applicable"><a class="header" href="#not-applicable">Not applicable</a></h2>
<p>Some proposals are not approved.</p>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3400.html">N3400</a>: A proposal for eliminating the underscore madness that library writers have to suffer</li>
</ul>
<p>Some proposals are not applicable yet and to be resolved in future. There also may be workaround provided by C++ implementation extensions or user code.</p>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2683.html">N2683</a>: issue 454: problems and solutions
<ul>
<li><a href="http://wg21.cmeerw.net/lwg/issue454">LWG 454</a>: <code>basic_filebuf::open</code> should accept <code>wchar_t</code> names</li>
</ul>
</li>
</ul>
<h2 id="in-development"><a class="header" href="#in-development">In development</a></h2>
<p>These issues are in &quot;extension&quot; state and not ready to be adopted:</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue476">CWG 476</a>: Determining the buffer size for placement new (see also <a href="https://wg21.cmeerw.net/cwg/issue256">CWG 256</a>)</li>
</ul>
<h1 id="adoption"><a class="header" href="#adoption">Adoption</a></h1>
<p>C++11 core language features and headers below now are being used.</p>
<p>Note: the &quot;adopted&quot; time notes listed in following entries are relative to the working paper.</p>
<h2 id="imported-tr1-headers"><a class="header" href="#imported-tr1-headers">Imported TR1 Headers</a></h2>
<p>TR1(see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf">N1836</a>) headers imported to C++11 are used:</p>
<ul>
<li><code>&lt;array&gt;</code> (since b218[2011-06-14])</li>
<li><code>&lt;type_traits&gt;</code> (since b206[2011-05-03])</li>
<li><code>&lt;tuple&gt;</code> (since b206[2011-05-03])
<ul>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue1191">LWG 1191</a>: <code>tuple</code> <code>get</code> API should respect rvalues</li>
<li>with <a href="http://wg21.cmeerw.net/lwg/issue1382">LWG 1382</a>: <code>pair</code> and <code>tuple</code> constructors should forward arguments</li>
<li>with <a href="http://wg21.cmeerw.net/lwg/issue1384">LWG 1384</a>: Function <code>pack_arguments</code> is poorly named (i.e. <code>forward_as_tuple</code>; since b206[2011-05-03])</li>
<li>with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2244.html">N2244</a>: Wording for <code>decay</code>, <code>make_pair</code> and <code>make_tuple</code></li>
<li>with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2299.html">N2299</a>: Concatenating <code>tuple</code>s, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2370.html">with modification</a> (since b303[2012-04-23])</li>
</ul>
</li>
<li><code>&lt;unordered_map&gt;</code> (since b206[2011-05-03])</li>
<li><code>&lt;unordered_set&gt;</code> (since b206[2011-05-03])</li>
</ul>
<h2 id="new-headers"><a class="header" href="#new-headers">New headers</a></h2>
<p>New headers after C++03 may be used.</p>
<h3 id="c11-baseline"><a class="header" href="#c11-baseline">C++11 baseline</a></h3>
<p>New non-TR1 headers from C++11 are used:</p>
<ul>
<li><code>&lt;atomic&gt;</code> (for all platforms from b590[2015-04-03]; for platforms supporting multithreading since b328[2011-07-25]; for platform MinGW32 since b299[2013-04-08])</li>
<li><code>&lt;chrono&gt;</code> (since b291[2012-03-07])</li>
<li><code>&lt;forward_list&gt;</code> (since b218[2011-06-14]; see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2543.htm">N2543</a>)</li>
<li><code>&lt;initializer_list&gt;</code> (since b297[2012-03-27]; see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2672.htm">N2672</a>)</li>
<li><code>&lt;typeindex&gt;</code> (since b468[2014-01-20])</li>
<li><code>&lt;regex&gt;</code> (since b795[2017-06-11])</li>
<li><code>&lt;system_error&gt;</code> (since b476[2014-02-16]; see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2241.html">N2241</a>)</li>
</ul>
<h3 id="multithreading"><a class="header" href="#multithreading">Multithreading</a></h3>
<p>For all implementations supporting multithreading, these headers are also used:</p>
<ul>
<li><code>&lt;condition_variable&gt;</code> (since b328[2011-07-25]; for platform MinGW32 since b299[2013-04-08])</li>
<li><code>&lt;future&gt;</code> (since b520[2014-07-23])</li>
<li><code>&lt;mutex&gt;</code> (since b328[2011-07-25]; for platform MinGW32 since b299[2013-04-08])</li>
<li><code>&lt;thread&gt;</code> (since b328[2011-07-25]; for platform MinGW32 since b299[2013-04-08])</li>
</ul>
<p>Note: <a href="http://wg21.cmeerw.net/lwg/issue1360">LWG 1360</a> specified single-threaded program should be able to use <code>&lt;atomic&gt;</code>, and resolved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3256.html">N3256</a>. However, the current YSLib doesn't require it for single-threaded programs.</p>
<h3 id="beyond-c11"><a class="header" href="#beyond-c11">Beyond C++11</a></h3>
<p>For rules of baseline, new headers are only used conditionally, mostly for avoiding need of replacements in non-C++11 modes where the specified headers are available.</p>
<ul>
<li>`&lt;memory_resource&gt; (since b842[2018-10-27]
<ul>
<li>replacement provided by <code>&lt;ystdex/memory_resource.h&gt;</code> if not available</li>
</ul>
</li>
<li>`&lt;string_view&gt; (since b833[2018-07-31]
<ul>
<li>replacement provided by <code>&lt;ystdex/string_view.hpp&gt;</code> if not available</li>
</ul>
</li>
<li><code>&lt;optional&gt;</code> (since b831[2018-07-13])
<ul>
<li>replacement provided by <code>&lt;ystdex/optional.h&gt;</code> if not available
<ul>
<li>with parts of <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0032r3.pdf">P0032R3</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="technical-specifications"><a class="header" href="#technical-specifications">Technical Specifications</a></h2>
<p>Technical Specifications are retargetted to standards finally. Not all features are used until they are adopted to the standard draft.</p>
<h3 id="tr1"><a class="header" href="#tr1">TR1</a></h3>
<p>TR1 features was once used, but now retired and corresponding ISO C++ features shall be used, since they are imported from TR1 (see editor's report <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2008.html">N2008</a> and the correspoinding working draft <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2009.pdf">N2009</a>) (since b206[2011-05-03]):</p>
<ul>
<li>TR1 <code>&lt;type_traits&gt;</code> including metafunctions and <code>std::tr1::aligned_storage</code> (since b175[2010-12-23])
<ul>
<li>replaced by C++11 <code>std::aligned_storage</code>, see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2341.pdf">N2341</a> (since b206[2011-05-03])</li>
</ul>
</li>
<li>TR1 <code>&lt;memory&gt;</code> <code>std::tr1::shared_ptr</code> (since b203[2011-04-22])
<ul>
<li>replaced by C++11 <code>std::shared_ptr</code> (since b206[2011-05-03])</li>
<li>with <a href="http://wg21.cmeerw.net/lwg/issue545">LWG 545</a>: When is a deleter deleted?, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2283.html">reworded slightly</a></li>
<li>with <a href="http://wg21.cmeerw.net/lwg/issue575">LWG 575</a>: the specification of <code>~shared_ptr</code> is MT-unfriendly, makes implementation assumptions, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2283.html">reworded slightly</a></li>
<li>see also <a href="http://wg21.cmeerw.net/lwg/issue611">LWG 611</a></li>
</ul>
</li>
</ul>
<p>Some TR1 features are not used, as C++11 features are directly used instead:</p>
<ul>
<li>TR1 <code>&lt;memory&gt;</code> <code>std::tr1::function</code> is superseded by <code>std::function</code> (since b207[2011-05-09])
<ul>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2132">LWG 2132</a>: <code>std::function</code> ambiguity</li>
</ul>
</li>
<li>TR1 <code>&lt;cstdint&gt;</code> types in <code>std::tr1</code> are superseded <code>std</code> types in ISO C++11 (since b209[2011-05-14])
<ul>
<li><strong>NOTE</strong> Previously, <code>&lt;stdint.h&gt;</code> from GCC or ISO C99 was used optionally (since b133[2010-07-16]).</li>
</ul>
</li>
<li>TR1 <code>&lt;cmath&gt;</code> <code>std::tr1::llround</code> is superseded by <code>std::llround</code> (since b260[2011-11-15])
<ul>
<li><strong>NOTE</strong> The feature was not actually relied on, instead ISO C99 <code>llround</code> in the global namespace was used as a workaround for implementations, until YBase.LibDefect.CMath was settled (since b556[2014-11-27]).</li>
</ul>
</li>
</ul>
<p>Some features are not used, but being compatible (see also Neutral of existence features below).</p>
<ul>
<li>TR1 additions to header <code>&lt;cfloat&gt;</code></li>
</ul>
<p>Other superseded TR1 features in the listed headers above may be also relied on since then.</p>
<h3 id="other-tses"><a class="header" href="#other-tses">Other TSes</a></h3>
<p>Although not used directly for evolution rules, some adopted modifications have already in the final draft of technical specifications:</p>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html">N4480</a>: Programming Languages — C++ Extensions for Library Fundamentals
<ul>
<li>with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4288.html">N4288</a>: Strike <code>string_view::clear</code> from Library Fundamentals (adopted 2014-11)</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4562.html">N4562</a>: Working Draft, C++ Extensions for Library Fundamentals, Version 2
<ul>
<li>parts on <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3793.html">N3793</a>: A proposal to add a utility class to represent optional objects (Revision 5)
<ul>
<li>revised previously-adopted <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3672.html">N3672</a>: A proposal to add a utility class to represent optional objects (Revision 4) (adopted 2013-04)
<ul>
<li>moved to Library TS by LWG motion 6 in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3769.pdf">N3769</a></li>
</ul>
</li>
</ul>
</li>
<li>with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3765.pdf">N3765</a>: On Optional</li>
<li>based on <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4282.pdf">N4282</a>: A Proposal for the World's Dumbest Smart Pointer, v4</li>
</ul>
</li>
</ul>
<p>They are listed here for exposition-only use. The actual adoption depends on items depending them on.</p>
<h2 id="adopted-changes"><a class="header" href="#adopted-changes">Adopted changes</a></h2>
<p>Features adopted shall be compatible with rules for general status.</p>
<h3 id="to-be-reviewd"><a class="header" href="#to-be-reviewd">To be reviewd</a></h3>
<p>These pre-C++11 resolutions are believed have been relied on. It is yet to determine the &quot;since&quot; cluase (reviewed b865[2019-08-30]).</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue624">CWG 624</a>: Overflow in calculating size of allocation (see also <a href="https://wg21.cmeerw.net/cwg/issue476">CWG 476</a>)
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue256">CWG 256</a>: overflow calculating size of new array</li>
</ul>
</li>
</ul>
<h3 id="restrictive-improvement"><a class="header" href="#restrictive-improvement">Restrictive improvement</a></h3>
<p>The conformance of following lists of clearer specification with probable stronger restrictions (to the implementation and program-provided code including this project) or fixed specifications aligned with all existed implementations are concerned and took into account (revised b865[2019-08-17]).</p>
<p>For specifications before C++11:</p>
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue96">CWG 96</a>: Syntactic disambiguation using the <code>template</code> keyword</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue201">LWG 201</a>: Numeric limits terminology wrong</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue220">CWG 220</a>: require de-allocation not throw</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue274">LWG 274</a>: a missing/impossible allocator requirement (partially overriden by <a href="https://wg21.cmeerw.net/lwg/issue2447">LWG 2447</a>)</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue294">LWG 294</a>: User defined macros and standard headers</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue300">LWG 300</a>: <code>list::merge()</code> specification incomplete</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue386">LWG 386</a>: Reverse iterator's <code>operator[]</code> has impossible return type</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue416">LWG 416</a>: definitions of <code>XXX_MIN</code> and <code>XXX_MAX</code> macros in <code>climits</code>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2283.html">reworded slightly</a></li>
<li><a href="http://wg21.cmeerw.net/lwg/issue422">LWG 422</a>: explicit specializations of member functions of class templates, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2283.html">reworded slightly</a></li>
<li><a href="http://wg21.cmeerw.net/lwg/issue456">LWG 456</a>: Traditional C header files are overspecified</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue420">LWG 420</a>: is <code>std::FILE</code> a complete type?</li>
</ul>
<p>For specifications between C++11 and C++14:</p>
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue1376">CWG 1376</a>: <code>static_cast</code> of temporary to rvalue reference (see also <a href="http://wg21.cmeerw.net/cwg/1568">CWG 1568</a>)</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1430">CWG 1430</a>: Pack expansion into fixed alias template parameter list</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1493">CWG 1493</a>: Criteria for move-construction</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1570">CWG 1570</a>: Address of subobject as non-type template argument</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1596">CWG 1596</a>: Non-array objects as <code>array[1]</code></li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1629">CWG 1629</a>: Can a closure class be a literal type?</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1672">CWG 1672</a>: Layout compatibility with multiple empty bases</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1751">CWG 1751</a>: Non-trivial operations vs non-trivial initialization</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1885">CWG 1885</a>: Return value of a function is underspecified</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue2013">LWG 2013</a>: Do library implementers have the freedom to add <code>constexpr</code>? (see also <a href="http://stackoverflow.com/questions/22182432/is-gcc-considering-builtins-of-non-constant-expression-functions-to-be-constant">here</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2014">LWG 2014</a>: More restrictions on macro names</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2447">LWG 2447</a>: Allocators and <code>volatile</code>-qualified value types</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3436.html">N3436</a>: <code>std::result_of</code> and SFINAE</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3644.pdf">N3644</a>: Null Forward Iterators (adopted 2013-04)</li>
</ul>
<p>For specifications between C++14 and C++17:</p>
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2129">LWG 2129</a>: User specializations of <code>std::initializer_list</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2139">LWG 2139</a>: What is a <em>user-defined</em> type?</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2150">LWG 2150</a>: Unclear specification of <code>find_end</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2419">LWG 2419</a>: Clang's libc++ extension to <code>std::tuple</code>
<ul>
<li>resolved by <a href="https://wg21.cmeerw.net/lwg/issue2312">LWG 2312</a> and <a href="https://wg21.cmeerw.net/lwg/issue2549">LWG 2549</a></li>
</ul>
</li>
</ul>
<p>For specification beyond C++17 (including drafting and WP state):</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue2256">CWG 2256</a>: Lifetime of trivially-destructible objects</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue3140">LWG 3140</a>: <code>COMMON_REF</code> is unimplementable as specified (adopted 2018-11, in editor's report <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4792.html">N4792</a>)</li>
</ul>
<h3 id="deprecation"><a class="header" href="#deprecation">Deprecation</a></h3>
<p>Features in the following adopted deprecation are <strong>not</strong> depended on (revised b863[2019-08-01]):</p>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0174r2.html">P0174R2</a>: Deprecating Vestigial Library Parts in C++17 (adopted 2016-06; since b835[2018-08-13])</li>
<li>deprecation of <code>shared_ptr</code> <code>unique</code> in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0521r0.html">P0521R0</a>: Proposed Resolution for CA 14 (<code>shared_ptr</code> <code>use_count</code>/<code>unique</code>) (adopted 2016-11; since b835[2018-08-14])
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2776">LWG 2776</a>: <code>shared_ptr</code> <code>unique()</code> and <code>use_count()</code></li>
<li>see national body comment <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0488r0.pdf#CA14">CA 14</a> in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0488r0.pdf">P0488R0</a>: WG21 Working Paper, NB Comments, ISO/IEC CD 14882</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0767r1.html">P0767R1</a>: Deprecate POD
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue2323">CWG 2323</a>: Expunge POD</li>
<li>see national body comment <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0488r0.pdf#US101">US 101</a> in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0488r0.pdf">P0488R0</a>: WG21 Working Paper, NB Comments, ISO/IEC CD 14882 (adopted 2017-11; since b853[2018-02-15])</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0806r2.html">P0806R2</a>: Deprecate implicit capture of <code>this</code> via <code>[=]</code> (adopted 2018-06)</li>
</ul>
<h3 id="removal"><a class="header" href="#removal">Removal</a></h3>
<p>Several features removed in C++17 are <strong>not</strong> depended on (revised b853[2019-02-15]):</p>
<ul>
<li><a href="http://wg21.cmeerw.net/lwg/issue2385">LWG 2385</a>: <code>function::assign</code> allocator argument doesn't make sense</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue2487">LWG 2487</a>: <code>bind()</code> should be <code>const</code>-overloaded, not <em>cv</em>-overloaded
<ul>
<li>in libstdc++ this is an extension (although declared deprecated by <code>_GLIBCXX_DEPR_BIND</code>) but the implementation (<code>std::__volget</code>) is essentially not type-safe (with <code>const_cast</code> to remove <code>volatile</code> in the calls)</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0302r1.html">P0302R1</a>: Removing Allocator Support in <code>std::function</code> (rev 1) (adopted 2016-06)
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2308.html">N2308</a>: Adding allocator support to <code>std::function</code> for C++0x, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2370.html">with modification</a></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2370">LWG 2370</a>: Operations involving type-erased allocators should not be <code>noexcept</code> in <code>std::function</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2501">LWG 2501</a>: <code>std::function</code> requires POCMA/POCCA</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2502">LWG 2502</a>: <code>std::function</code> does not use allocator::construct</li>
<li>see also the replacement <code>ystdex::function</code></li>
</ul>
</li>
</ul>
<h3 id="c11-features"><a class="header" href="#c11-features">C++11 features</a></h3>
<p>C++11 library features used indirectly (not mandated, but with design in mind that could make more interface usable, e.g. macro substitution or template instantiations):</p>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2761.pdf">N2761</a>: Towards support for attributes in C++ (Revision 6)</li>
</ul>
<p>Other C++11 core and library features used directly (without the features the program will either be ill-formed or has unexpected behavior for some input allowed by the API):</p>
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue45">CWG 45</a>: Access to nested classes (since b273[2012-01-01])
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue8">CWG 8</a>: Access to template arguments used in a function return type and in the nested name specifier</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue10">CWG 10</a>: Can a nested class access its own class name as a qualified name if it is a private member of the enclosing class?</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue87">CWG 87</a>: Exception specifications on function parameters (see also <a href="https://wg21.cmeerw.net/cwg/issue25">CWG 25</a>, <a href="https://wg21.cmeerw.net/cwg/issue92">CWG 92</a> and <a href="https://wg21.cmeerw.net/cwg/issue133">CWG 133</a>; since b249[2011-10-15])</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue208">CWG 208</a>: Rethrowing exceptions in nested handlers (since b461[2013-12-23])</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue222">CWG 222</a>: Sequence points and lvalue-returning operators (since b297[2012-03-27])
<ul>
<li>with <a href="http://wg21.cmeerw.net/cwg/issue637">CWG 637</a>: Sequencing rules and example disagree</li>
</ul>
</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue226">CWG 226</a>: Default template arguments for function templates (since b387[2013-03-11])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue254">CWG 254</a>: Exception types in clause 19 are constructed from <code>std::string</code> (since b643[2015-10-08]; i.e. <code>const char*</code> parameter in constructor of standard exception classes)</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue302">CWG 302</a>: Value-initialization and generation of default constructor (since b206[2011-05-03])</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue339">CWG 339</a>: Overload resolution in operand of <code>sizeof</code> in constant expression (since b591[2015-04-10])</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue382">CWG 382</a>: Allow <code>typename</code> outside of templates (since b421[2013-07-03])</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue542">CWG 542</a>: Value initialization of arrays of POD-structs (since b206[2011-05-03])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue49">LWG 49</a>: Underspecification of <code>ios_base::sync_with_stdio</code> (since b599[2015-05-21])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue280">LWG 280</a>: Comparison of <code>reverse_iterator</code> to <code>const reverse_iterator</code> (since b408[2013-05-30])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue438">LWG 438</a>: Ambiguity in the &quot;do the right thing&quot; clause (since b274[2012-01-04])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue611">LWG 611</a>: Standard library templates and incomplete types (since b206[2011-05-03])</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue765">CWG 765</a>: Local types in inline functions with external linkage (since b282[2012-02-04])
<ul>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue1157">LWG 1157</a>: Local types can now instantiate templates</li>
<li>with extra assumption of the identity of types in function templates or in functions of class templates across translation units <a href="http://stackoverflow.com/questions/34717823/can-using-a-lambda-in-header-files-violate-the-odr/34721371#34721371">which is potentially a core language defect</a>
<ul>
<li>see also <a href="Development.zh-CN.html">here(zh-CN)</a> for detailed explanation and requiremnts on implementation</li>
</ul>
</li>
<li>applied to <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2008/n2657.htm">N2657</a></li>
<li>applied to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf">N2927</a></li>
</ul>
</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1104">CWG 1104</a>: Global-scope template arguments vs the <code>&lt;:</code> digraph (since b493[2014-04-16])</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1330">CWG 1330</a>: Delayed instantiation of <code>noexcept</code> specifiers (since b792[2017-06-05])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue49">LWG 49</a>: Underspecification of <code>ios_base::sync_with_stdio</code> (since b565[2015-01-16])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue91">LWG 91</a>: Description of <code>operator&gt;&gt;</code> and <code>getline()</code> for <code>string&lt;&gt;</code> might cause endless loop (since b663[2015-12-18])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue130">LWG 130</a>: Return type of <code>container::erase(iterator)</code> differs for associative containers (since b216[2011-06-08])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue254">LWG 254</a>: Exception types in clause 19 are constructed from <code>std::string</code> (since b643[2015-10-08])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue265">LWG 265</a>: <code>std::pair::pair()</code> effects overly restrictive (since b206[2011-05-03])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue371">LWG 371</a>: Stability of <code>multiset</code> and <code>multimap</code> member functions (since b216[2011-06-08])
<ul>
<li>see also <a href="http://wg21.cmeerw.net/lwg/issue130">LWG 130</a></li>
</ul>
</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue376">LWG 376</a>: <code>basic_streambuf</code> semantics (since b616[2015-07-21])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue419">LWG 419</a>: istream extractors not setting failbit if eofbit is already set (since b437[2015-01-16])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue453">LWG 453</a>: <code>basic_stringbuf::seekoff</code> need not always fail for an empty stream (since b617[2015-07-25])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue534">LWG 534</a>: Missing <code>basic_string</code> members (i.e. <code>basic_string</code> <code>pop_back</code>, <code>back</code> and <code>front</code>; since b315[2012-06-08])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue559">LWG 559</a>: <code>numeric_limits&lt;const T&gt;</code>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2283.html">reworded slightly</a> (since b440[2013-08-29])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue564">LWG 564</a>: <code>stringbuf</code> <code>seekpos</code> underspecified (since b743[2016-11-21])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue589">LWG 589</a>: Requirements on iterators of member template functions of containers (since b216[2011-06-08])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue596">LWG 596</a>: 27.8.1.3 Table 112 omits <code>&quot;a+&quot;</code> and <code>&quot;a+b&quot;</code> modes (since b326[2012-07-19])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue694">LWG 694</a>: <code>std::bitset</code> and <code>long long</code> (since b932[2021-12-04])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue704">LWG 704</a>: MoveAssignable requirement for container value type overly strict (since b206[2011-05-03])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue711">LWG 711</a>: Contradiction in empty <code>shared_ptr</code> (since b784[2017-04-29])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue762">LWG 762</a>: <code>std::unique_ptr</code> requires complete type? (since b238[2011-09-07])</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue811">LWG 811</a>: <code>pair</code> of pointers no longer works with literal <code>0</code> (since b206[2011-05-03])
<ul>
<li>partially superseded when <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4387.html">N4387</a> is conditonally used</li>
</ul>
</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue868">LWG 868</a>: Default construction and value-initialization (since b206[2011-05-03])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue771">LWG 771</a>: Impossible throws clause in [string.conversions] (since b375[2013-01-22])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue772">LWG 772</a>: Impossible return clause in [string.conversions] (since b375[2013-01-22])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue806">LWG 806</a>: <code>unique_ptr::reset</code> effects incorrect, too permissive (since b206[2011-05-03])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue809">LWG 809</a>: <code>std::swap</code> should be overloaded for array types (since b620[2015-08-02])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue817">LWG 817</a>: <code>bind</code> needs to be moved (since b401[2013-05-02])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue900">LWG 900</a>: Stream move-assignment (tentatively since b620[2015-08-01]; since b727[2016-09-17])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue911">LWG 911</a>: I/O streams and move/swap semantic (tentatively since b620[2015-08-01]; since b727[2016-09-17])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue922">LWG 922</a>: [func.bind.place] Number of placeholders (since b437[2013-08-22])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue929">LWG 929</a>: Thread constructor (since b384[2013-03-01])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue993">LWG 993</a>: <code>_Exit</code> needs better specification (since b565[2015-01-16])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue1019">LWG 1019</a>: Make <code>integral_constant</code> objects useable in <em>integral-constant-expression</em>​s (since b590[2015-04-10])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue1040">LWG 1040</a>: Clarify possible sameness of associative container's <code>iterator</code> and <code>const_iterator</code> (since b496[2014-05-01])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue1178">LWG 1178</a>: Header dependencies (since b338[2012-09-13])
<ul>
<li><a href="http://wg21.cmeerw.net/lwg/issue343">LWG 343</a>: Unspecified library header dependencies (see also <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2259.html">N2259</a>)</li>
</ul>
</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue1192">LWG 1192</a>: <code>basic_string</code> missing definitions for <code>cbegin</code> / <code>cend</code> / <code>crbegin</code> / <code>crend</code> (since b546[2014-10-17])</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue1382">LWG 1382</a>: <code>pair</code> and <code>tuple</code> constructors should forward arguments (since b206[2011-05-03])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1626.pdf">N1626</a>: Proposed Resolution for Core Issue 39 (Rev. 1) (since b447[2013-09-25])
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue39">CWG 39</a>: Conflicting ambiguity rules</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1653.htm">N1653</a>: Working draft changes for C99 preprocessor synchronization (since b257[2011-11-04]; used GCC extensions previously for variadic macros and empty macro arguments only)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1720.html">N1720</a>: Proposal to Add Static Assertions to the Core Language (Revision 3) (since b206[2011-05-03])
<ul>
<li>with <a href="http://wg21.cmeerw.net/cwg/issue676">CWG 676</a>: <em>static_assert-declaration</em>​s and general requirements for declarations</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1757.html">N1757</a>: Right Angle Brackets (Revision 1) (since b206[2011-05-03])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1780.html">N1780</a>: Comments on LWG issue 233: Insertion hints in associative containers (since b216[2011-06-08])
<ul>
<li><a href="http://wg21.cmeerw.net/lwg/issue233">LWG 233</a>: Insertion hints in associative containers</li>
<li>see also <a href="http://wg21.cmeerw.net/lwg/issue371">LWG 371</a></li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1811.pdf">N1811</a>: Adding the <code>long long</code> type to C++ (Revision 3) (since b206[2011-05-03])
<ul>
<li>with specializations of <code>numerical_limits</code> in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2114.html">N2114</a>: <code>long long</code> Goes to the Library, Revision 1 (since b932[2021-12-04])</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1822.pdf">N1822</a>: A Proposal to add a max significant decimal digits value to the C++ Standard Library Numeric limits (since b260[2011-11-12]; i.e. <code>numeric_limits::max_digits10</code>)
<ul>
<li>without <a href="http://wg21.cmeerw.net/lwg/issue613">LWG 613</a>: <code>max_digits10</code> missing from <code>numeric_limits</code></li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf">N1836</a>: Draft Technical Report on C++ Library Extensions (Built-in type traits) (since b206[2011-05-03])
<ul>
<li>with <a href="http://wg21.cmeerw.net/lwg/issue1182">LWG 1182</a>: Unfortunate <code>hash</code> dependencies</li>
<li>with <a href="http://wg21.cmeerw.net/lwg/issue1255">LWG 1255</a>: <code>declval</code> should be added to the library (since b260[2011-11-14])</li>
<li>with <a href="http://wg21.cmeerw.net/lwg/issue1270">LWG 1270</a>: <code>result_of</code> should be moved to <code>&lt;type_traits&gt;</code> (since b245[2011-09-23])</li>
</ul>
</li>
<li><code>cbegin</code>/<code>cend</code>/<code>crbegin</code>/<code>crend</code> from <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1913.pdf">N1913</a>: A Proposal to Improve <code>const_iterator</code> Use (version 2) (since b206[2011-05-03])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a>: Rvalue Reference Recommendations for Chapter 23, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2283.html">reworded</a> (since b216[2011-06-08])
<ul>
<li>with <a href="http://wg21.cmeerw.net/lwg/issue759">LWG 759</a> superseded by <a href="http://wg21.cmeerw.net/lwg/issue1204">LWG 1204</a></li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1984.pdf">N1984</a>: Deducing the type of variable from its initializer expression (revision 4) (since b206[2011-05-03]; i.e. <code>auto</code>-typed variables)
<ul>
<li>with <a href="http://wg21.cmeerw.net/cwg/issue615">CWG 615</a>: Incorrect description of variables that can be initialized</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1986.pdf">N1986</a>: Delegating Constructors (revision 3) (since b311[2011-05-25])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1987.htm">N1987</a>: Adding &quot;<code>extern template</code>&quot; (version 2) (since b206[2011-05-03])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2005.pdf">N2005</a>: A maximum significant decimal digits value for the C++0x Standard Library Numeric limits (since b301[2012-04-13])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2179.html">N2179</a>: Language Support for Transporting Exceptions between Threads (since b538[2014-09-28]; i.e. <code>exception_ptr</code> and <code>current_exception</code>, etc)
<ul>
<li>with <a href="http://wg21.cmeerw.net/lwg/issue829">LWG 829</a>: <code>current_exception</code> wording unclear about exception type</li>
<li>with <a href="http://wg21.cmeerw.net/lwg/issue1130">LWG 1130</a>: <code>copy_exception</code> name misleading (i.e. <code>make_exception_ptr</code>; since b550[2014-11-04])</li>
<li>with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3195.htm">N3195</a>: From <em>Throws: Nothing</em> to <code>noexcept</code> (version 2)</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf">N2235</a>: Generalized Constant Expressions—Revision 5 (since b246[2011-09-23]; i.e. <code>constexpr</code>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2238.html">N2238</a>: Minimal Unicode support for the standard library (revision 3) (since b253[2011-10-18])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2239.html">N2239</a>: A finer-grained alternative to sequence points (revised) (since b297[2012-03-27]; notably order of aggregate initialization, see also <a href="http://wg21.cmeerw.net/cwg/issue1030">CWG 1030</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2240.html">N2240</a>: Two missing traits: <code>enable_if</code> and <code>conditional</code>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2283.html">added specification when <code>B</code> is <code>false</code></a> (since b206[2011-05-03])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2241.html">N2241</a>: Diagnostics Enhancements for C++0x (Rev. 1), <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2283.html">reworded</a> (since b476[2014-02-16]; i.e. <code>&lt;system_error&gt;</code>)
<ul>
<li>with <a href="http://wg21.cmeerw.net/lwg/issue805">LWG 805</a>: <code>posix_error::posix_errno</code> concerns (since b550[2014-11-04]; i.e. <code>errc</code>)</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2242.pdf">N2242</a>: Proposed Wording for Variadic Templates (Revision 2) (since b251[2011-10-08])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2244.html">N2244</a>: Wording for <code>decay</code>, <code>make_pair</code> and <code>make_tuple</code> (since b206[2011-05-03])</li>
<li>features from <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2246.html">N2246</a>: 2 of the least crazy ideas for the standard library in C++0x (i.e. <code>next</code>/<code>prev</code>/<code>is_sorted_until</code>/<code>is_heap_until</code>)
<ul>
<li><code>next</code>/<code>prev</code> (since b375[2013-01-22])</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2249.html">N2249</a>: New Character Types in C++, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2283.html">library part reworded</a> (since b253[2011-10-18])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2255.html">N2255</a>: Minor Modifications to the type traits Wording Revision 2, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2283.html">reworded</a> (since b206[2011-05-03])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2258.pdf">N2258</a>: Templates Aliases (since b433[2013-08-01])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2259.html">N2259</a>: Specify header dependency for <code>&lt;iostream&gt;</code> (since b338[2012-09-13]; see also <a href="http://wg21.cmeerw.net/lwg/issue343">LWG 343</a>)</li>
<li>features(e.g. <code>alignof</code>) from <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2341.pdf">N2341</a>: Adding Alignment Support to the C++ Programming Language / Wording
<ul>
<li><code>std::aligned_storage</code> used instead of <code>std::tr1::aligned_storage</code> since b206[2011-05-03]</li>
<li>other features except <code>std::aligned_union</code> used since b315[2012-06-08]</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2342.htm">N2342</a>: POD's Revisited; Resolving Core Issue 568 (Revision 5) (since b206[2011-05-03])
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue543">CWG 543</a>: Value initialization and default constructors</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue568">CWG 568</a>: Definition of POD is too strict</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2343.pdf">N2343</a>: Decltype (revision 7) (since b206[2011-05-03])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2346.htm">N2346</a>: Defaulted and Deleted Functions (since b207[2011-05-05])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf">N2347</a>: Strongly Typed Enums (revision 3), <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2370.html">with modification</a> (since b261[2011-11-19])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2348.pdf">N2348</a>: Wording for <code>std::numeric_limits&lt;T&gt;::lowest()</code> (since b242[2011-09-16])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2349.pdf">N2349</a>: Constant Expressions in the Standard Library — Revision 2, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2370.html">with modification</a> (since b260[2011-11-12])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf">N2350</a>: Container <code>insert</code>/<code>erase</code> and iterator constness (Revision 1) (since b531[2014-08-31])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2351.htm">N2351</a>: Improving <code>shared_ptr</code> for C++0x, Revision 2 (i.e. <code>make_shared</code> etc; since b529[2014-08-24])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2431.pdf">N2431</a>: A name for the null pointer: <code>nullptr</code> (revision 4) (since b206[2011-05-03]; compatible layer introduced since b204[2011-04-26])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2437.pdf">N2437</a>: Explicit Conversion Operator Draft Working Paper (revision 3) (since b260[2011-11-15])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2439.htm">N2439</a>: Extending move semantics to <code>*this</code> (revised wording) (since b591[2015-04-11])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2442.htm">N2442</a>: Raw and Unicode String Literals; Unified Proposal (Rev. 2)
<ul>
<li>unicode string literals used since b253[2011-10-18]</li>
<li>raw string literals used since b431[2013-07-23]</li>
<li>other features used since b434[2013-08-04]</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2530.html">N2530</a>: Making It Easier to Use <code>std::type_info</code> as an Index in an Associative Container (since b468[2014-01-20]; i.e. <code>type_info::hash_code</code>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2535.htm">N2535</a>: Namespace Association (&quot;<code>inline namespace</code>&quot;) (since b427[2013-07-11])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2540.htm">N2540</a>: Inheriting Constructors (revision 5) (since b538[2014-09-24])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2541.htm">N2541</a>: New Function Declarator Syntax Wording (since b207[2011-05-05])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2543.htm">N2543</a>: STL singly linked lists (revision 3) (since b218[2011-06-04]; i.e. <code>&lt;forward_list&gt;</code>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2544.pdf">N2544</a>: Unrestricted Unions (Revision 2) (since b569[2015-01-29])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2546.pdf">N2546</a>: Removal of <code>auto</code> as a storage-class specifier (since b206[2011-05-03])
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue629">CWG 629</a>: <code>auto</code> parsing ambiguity</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2559.htm">N2559</a>: Nesting Exception Objects (Revision 1) (since b477[2014-02-19])
<ul>
<li>with <a href="http://wg21.cmeerw.net/lwg/issue819">LWG 819</a>: <code>rethrow_if_nested</code></li>
<li>with <a href="http://wg21.cmeerw.net/lwg/issue1136">LWG 1136</a>: Incomplete specification of <code>nested_exception::rethrow_nested()</code></li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2634.html">N2634</a>: Solving the SFINAE problem for expressions (since b591[2015-04-10])
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue339">CWG 339</a>: Overload resolution in operand of <code>sizeof</code> in constant expression</li>
</ul>
</li>
<li><a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2008/n2657.htm">N2657</a>: Local and Unnamed Types as Template Arguments (since b206[2011-05-03])
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue488">CWG 488</a>: Local types, overload resolution, and template argument deduction</li>
<li>with <a href="http://wg21.cmeerw.net/cwg/issue765">CWG 765</a> above</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2659.htm">N2659</a>: Thread-Local Storage (since b425[2013-07-08])
<ul>
<li>with <a href="http://wg21.cmeerw.net/cwg/issue810">CWG 810</a>: Block-scope <code>thread_local</code> variables should be implicitly <code>static</code> (since b425[2013-07-08])</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2672.htm">N2672</a>: Initializer List proposed wording (since b297[2012-03-27])
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue1030">CWG 1030</a>: Evaluation order in initializer-lists used in aggregate initialization (since b297[2012-03-27]; see also <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2239.html">N2239</a>)</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2680.pdf">N2680</a>: Proposed Wording for Placement Insert (Revision 1) (since b286[2012-02-19])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2709.html">N2709</a>: Packaging Tasks for Asynchronous Execution (since b520[2014-07-23]; i.e. <code>packaged_task</code>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2756.htm">N2756</a>: Non-static data member initializers (since b360[2013-04-29])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2764.pdf">N2764</a>: Forward declaration of enumerations (rev. 3) (since b658[2015-12-08])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>: Fixing a Safety Problem with Rvalue References: Proposed Wording (Revision 1) (since b206[2011-05-03])
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue1138">CWG 1138</a>: Rvalue-ness check for rvalue reference binding is wrong (since b206[2011-05-03])</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf">N2927</a>: New wording for C++0x Lambdas (rev. 2) (since b212[2011-05-27])
<ul>
<li>with <a href="http://wg21.cmeerw.net/cwg/issue765">CWG 765</a> above</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2930.html">N2930</a>: Range-Based For Loop Wording (Without Concepts) (since b316[2011-06-11])</li>
<li>features from <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a>: Allocators post Removal of C++ Concepts (Rev 1)
<ul>
<li><code>std::addressof</code> used since b288[2012-02-26]
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue970">LWG 970</a>: <code>addressof</code> overload unneeded</li>
</ul>
</li>
<li><code>std::allocator_traits</code> except propagation traits used since b592[2015-04-19]</li>
<li>propagation traits in <code>std::allocator_traits</code> used since b830[2018-07-08]
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue431">LWG 431</a>: Swapping containers with unequal allocators</li>
</ul>
</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3050.html">N3050</a>: Allowing Move Constructors to Throw (Rev. 1) (since b319[2012-06-24]; i.e. <code>noexcept</code> and <code>std::move_if_noexcept</code>)
<ul>
<li>with <a href="http://wg21.cmeerw.net/lwg/issue1349">LWG 1349</a>: <code>swap</code> should not throw</li>
<li>with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3180.htm">N3180</a>: More on <code>noexcept</code> for the Strings Library (since b329[2012-08-05])</li>
<li>with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3279.pdf">N3279</a>: Conservative use of <code>noexcept</code> in the Library (since b461[2013-12-23])</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3052.html">N3052</a>: Converting Lambdas to Function Pointers (since b360[2012-12-07])</li>
<li>features except in <code>&lt;type_traits&gt;</code> from <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3053.html">N3053</a>: Defining Move Special Member Functions (since b230[2011-08-07])
<ul>
<li>with <a href="http://wg21.cmeerw.net/lwg/issue1309">LWG 1309</a>: Missing expressions for Move/CopyConstructible
<ul>
<li><a href="http://wg21.cmeerw.net/lwg/issue1283">LWG 1283</a>: MoveConstructible and MoveAssignable need clarification of moved-from state</li>
</ul>
</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3143.html">N3143</a>: Proposed wording for US 90 (since b206[2011-05-03]; i.e. <code>std::forward</code>)</li>
<li><a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2010/n3168.htm">N3168</a>: Problems with Iostreams Member Functions (Amended from US 137) (since b805[2017-09-26])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3189.htm">N3189</a>: Observers for the three <em>handler functions</em> (since b550[2014-11-04])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3272.htm">N3272</a>: Follow-up on <code>override</code> control (since b311[2011-05-25])</li>
</ul>
<h2 id="tentatively-applied"><a class="header" href="#tentatively-applied">Tentatively applied</a></h2>
<p>All adopted changes are confirmed being included in the newest working paper and would not be removed in future unless they are not in the working paper or published standard any longer.</p>
<h3 id="platform-dependent-features"><a class="header" href="#platform-dependent-features">Platform-dependent features</a></h3>
<p>Some features only are relied in platform-dependent implementation details where all of supported platforms of the project has been confirmed to support. Currently (revised b848[2018-12-24]) there are none.</p>
<h3 id="conditionally-used-features"><a class="header" href="#conditionally-used-features">Conditionally used features</a></h3>
<p>Some C++11 features are not requried to reduce compatibility impact on implementations, but can be utilized when available, i.e. used <strong>conditionally</strong> (by conditional inclusion or being transparent):</p>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2340.htm">N2340</a>: C99 Compatibility : <code>__func__</code> and predeclared identifiers (revision 2) (since b638[2015-09-24])</li>
</ul>
<p>Some post-C++11 features are used <strong>conditionally</strong>:</p>
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue616">CWG 616</a>: Definition of “indeterminate value” (since b663[2016-01-11]) (see also <a href="http://wg21.cmeerw.net/cwg/issue1213">CWG 1213</a>)
<ul>
<li>without <a href="http://wg21.cmeerw.net/cwg/issue129">CWG 129</a>: Stability of uninitialized auto variables</li>
<li>without <a href="http://wg21.cmeerw.net/cwg/issue240">CWG 240</a>: Uninitialized values and undefined behavior (see also <a href="http://wg21.cmeerw.net/cwg/issue129">CWG 129</a>)
<ul>
<li>without <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_338.htm">WG14/DR338</a></li>
</ul>
</li>
<li>without <a href="http://wg21.cmeerw.net/cwg/issue312">CWG 312</a>: “use” of invalid pointer value not defined (see also <a href="http://wg21.cmeerw.net/cwg/issue623">CWG 623</a>)</li>
<li>without <a href="http://wg21.cmeerw.net/cwg/issue623">CWG 623</a>: Use of pointers to deallocated storage (see also <a href="http://wg21.cmeerw.net/cwg/issue623">CWG 312</a>)</li>
</ul>
</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1581">CWG 1581</a>: When are <code>constexpr</code> member functions defined? (since b834[2016-08-03])</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1558">CWG 1558</a>: Unused arguments in alias template specializations (since b653[2015-11-25]; see also <a href="http://wg21.cmeerw.net/cwg/issue1430">CWG 1430</a>, <a href="http://wg21.cmeerw.net/cwg/issue1520">CWG 1520</a> and <a href="http://wg21.cmeerw.net/cwg/issue1554">CWG 1554</a>)</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue2285">LWG 2285</a>: <code>make_reverse_iterator</code> (since b595[2015-05-01])
<ul>
<li>replaced by <code>ystdex::make_reverse_iterator</code> conditionally since b833[2018-07-29]</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3421.htm">N3421</a>: Making Operator Functors <code>greater&lt;&gt;</code> (since b679[2016-03-19]; see also <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3657.htm">N3657</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3478.html">N3478</a>: Core Issue 1512: Pointer comparison vs qualification conversions (since b562[2014-12-22])
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue73">CWG 73</a>: Pointer equality</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1512">CWG 1512</a>: Pointer comparison vs qualification conversions</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3493.html">N3493</a>: Compile-time integer sequences (since b589[2015-04-03])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3652.html">N3652</a>: Relaxing constraints on <code>constexpr</code> functions/<code>constexpr</code> member functions and implicit <code>const</code> (adopted 2013-04; since b591[2015-04-15])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3655.pdf">N3655</a>: TransformationTraits Redux, v2 (since b595[2015-05-01])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3656.htm">N3656</a>: <code>make_unique</code> (Revision 1) (since b617[2015-07-23])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3657.htm">N3657</a>: Adding heterogeneous comparison lookup to associative containers (rev 4) (adopted 2013-04; rev 3 not in the list)
<ul>
<li>without <code>is_transparent</code> since b678[2016-03-17]</li>
<li>with <code>is_transparent</code> since b679[2016-03-19]</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3671.html">N3671</a>: Making non-modifying sequence operations more robust: Revision 2 (since b627[2015-08-30])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3778.html">N3778</a>: C++ Sized Deallocation (since b842[2018-10-29])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4169.html">N4169</a>: A proposal to add <code>invoke</code> function template (Revision 1) (since b617[2015-07-23])
<ul>
<li><strong>without</strong> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1065r2.html">P1065R2</a>: <code>constexpr</code> <em>INVOKE</em></li>
</ul>
</li>
<li><code>pair</code> constructors improvement in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4387.html">N4387</a>: Improving <code>pair</code> and <code>tuple</code>, revision 3 (adopted 2015-05; since b850[2019-01-14])
<ul>
<li>missed in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4528.html">N4528</a>, see <a href="https://github.com/cplusplus/draft/commit/c8347e3f3caa2ecef1b1dd869ce15b9095134a1a">this commit</a>.</li>
<li><strong>without</strong> <a href="https://wg21.cmeerw.net/lwg/issue2051">LWG 2051</a>: Explicit <code>tuple</code> constructors for more than one parameter</li>
<li><strong>without</strong> partially addressed <a href="https://wg21.cmeerw.net/lwg/issue2312">LWG 2312</a>: <code>tuple</code>'s constructor constraints need to be phrased more precisely</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2397">LWG 2397</a>: <code>map::emplace</code> and explicit <code>V</code> constructors
<ul>
<li>see also <a href="https://wg21.cmeerw.net/ewg/issue114">EWG 114</a>: N4074 Let <code>return {expr}</code> Be Explicit, Revision 2, N4131 explicit should never be implicit, N4094 Response To: Let <code>return {expr}</code> Be Explicit, N4029 Let return Be Direct and <code>explicit</code>, N3452 (unpublished) Let <code>{x,y,z}</code> =&gt; <code>explicit</code> (resolved as NAD)</li>
</ul>
</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4389.html">N4389</a>: Wording for <code>bool_constant</code>, revision 1 (since b617[2015-07-23])</li>
<li>some C11 features in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0063r3.html">P0063R3</a>: C++17 should refer to C11 instead of C99 (adopted 2016-06)
<ul>
<li><code>DBL_HAS_SUBNORM</code>, <code>FLT_HAS_SUBNORM</code> and <code>LDBL_HAS_SUBNORM</code> (since b932[2021-12-04])</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0188r1.pdf">P0188R1</a>: Wording for <code>[[fallthrough]]</code> attribute. (adopted 2016-02; since b793[2017-06-06])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0189r1.pdf">P0189R1</a>: Wording for <code>[[nodiscard]]</code> attribute. (adopted 2016-02; since b823[2018-07-26])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0212r1.pdf">P0212R1</a>: Wording for <code>[[maybe_unused]]</code> attribute. (adopted 2016-02; since b823[2018-07-26])</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0386r2.pdf">P0386R2</a>: Inline Variables (adopted 2016-06; since b831[2018-07-13])</li>
<li>part (with only the signature available in C++11) of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0674r1.html">P0674R1</a>: Extending <code>make_shared</code> to Support Arrays (adopted 2017-07; since b849[2018-12-30])
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2070">LWG 2070</a>: <code>allocate_shared</code> should use <code>allocator_traits::construct</code></li>
</ul>
</li>
</ul>
<h3 id="feature-testing"><a class="header" href="#feature-testing">Feature testing</a></h3>
<p>Following Feature Testing study group (SD-6 recommendations approved by SG 10) documents after <a href="http://wg21.cmeerw.net/ewg/issue22">EWG 22</a> have been reviewed, with some of them applied or updated:</p>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4200.htm">N4200</a>: Feature-testing recommendations for C++ (since b591[2015-04-15]; i.e. <code>__has_cpp_attribute</code>, etc; see subsequent <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4440.html">N4440</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4440.html">N4440</a>: Feature-testing recommendations for C++ (superseded)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4535.html">N4535</a>: Feature-testing preprocessor predicates for C++17 (i.e. <code>__has_include</code> and <code>__has_cpp_attribute</code>, see below)
<ul>
<li>for <code>__has_include</code>, see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0061r1.html">P0061R1</a> below</li>
<li><code>__has_cpp_attribute</code> adopted, as <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4200.htm">N4200</a> above
<ul>
<li>this is now in the <a href="http://eel.is/c++draft/cpp.cond#nt:has-attribute-expression">working draft</a>, though not in the list of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/">official page</a> as of b831[2018-07-13]</li>
<li>adopted by CWG motion 15 in editor's report <a href="https://github.com/cplusplus/draft/blob/master/papers/n4764.md">N4764</a></li>
<li>see <a href="http://www.open-std.org/pipermail/features/2014-March/000163.html">discussion here</a> for motivation</li>
</ul>
</li>
<li>see also <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0941r1.html">P0941R1</a></li>
</ul>
</li>
<li><a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0096r1.html">P0096R1</a>: Feature-testing recommendations for C++ (since b679[2016-03-20]; see subsequent <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0941r0.html">P0941R0</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0941r2.html">P0941R2</a>: Integrating feature-test macros into the C++ WD (rev. 2) (since b831[2018-07-12])</li>
</ul>
<p>Following documents override feature testing paper which is incorporated into the standard draft as normative features:</p>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0061r1.html">P0061R1</a>: <code>__has_include</code> for C++17 (adopted 2015-10; since b831[2018-07-12])</li>
</ul>
<p>Some additional feature testing support are also <strong>conditionally</strong> reviewd. Some are already extensions of Clang++ and other implementations for several revisions. The identifiers with <code>__has_</code> in following list are being used and considered for conditional inclusion:</p>
<ul>
<li><code>__has_attribute</code> since b628[2015-09-01], after in macro detection candidate list since b492[2014-04-10]</li>
<li><code>__has_builtin</code> since b535[2014-09-14]</li>
<li><code>__has_extension</code> and <code>__has_feature</code> since b484[2013-03-09]</li>
</ul>
<h2 id="tentatively-not-applied"><a class="header" href="#tentatively-not-applied">Tentatively not applied</a></h2>
<h3 id="used-deprecations"><a class="header" href="#used-deprecations">Used deprecations</a></h3>
<p>There are no features eventually removed in future versions of ISO C++ are yet to be resolved currently.</p>
<h3 id="workarounds"><a class="header" href="#workarounds">Workarounds</a></h3>
<p>Several acknowledged but not adopted (by the draft) issues (revised b834[2018-07-31]) are assumed not effect user code with workarounds provided by implementations, including:</p>
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2472">LWG 2472</a>: Heterogeneous comparisons in the standard library can result in ambiguities
<ul>
<li>no effect on YStandardEx replacement as there is no <code>std::rel_ops</code>-like operators in namespace <code>ystdex</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2858">LWG 2858</a>: LWG 2472: actually an incompatibility with C++03 (see <a href="https://wg21.cmeerw.net/lwg/issue280">LWG 280</a>)
<ul>
<li>no effect on <code>ystdex::reversed_iterator</code></li>
</ul>
</li>
</ul>
<h3 id="primarily-replaceable"><a class="header" href="#primarily-replaceable">Primarily replaceable</a></h3>
<p>The following features are not relied on, but confirmed still being compatible, with further rules to incooperate:</p>
<ul>
<li>part of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0551r3.pdf">P0551R3</a>: Thou Shalt Not Specialize <code>std</code> Function Templates! (adopted 2018-03)
<ul>
<li>though not relied on, any of the entities overloadable with standard components as the subset of the <em>direct replacements</em> specified in following clauses conform to the definition of the term <em>customization point</em> specified here</li>
<li><em>designated customization point</em> is extended to any direct replacments implicitly (i.e. a direct replacement is also implied to be customized by user code if it comforms to a designated customization point specified here), or explicitly following the designation otherwise specified by the interface documentation and with further rules to be intercooperated</li>
</ul>
</li>
</ul>
<p>The following changes about standard library are not depended on, but were considered some replacements have been used as forcing the requirements for implementations other than using of YStandardEx replacements:</p>
<ul>
<li>part of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4258.pdf">N4258</a>: Cleaning up noexcept in the Library (Rev 3) (adopted 2014-11)
<ul>
<li>only for part of <code>noexcept</code> which is <strong>not</strong> exclusively covered by the applying specified below, as <code>noexcept</code> can be added in user-code by introducing new classes meets the changes here like direct replacements (e.g. inheriting the base containers) when direct replacements is <strong>not</strong> yet provided by YStandardEx</li>
</ul>
</li>
</ul>
<h3 id="replaced-directly"><a class="header" href="#replaced-directly">Replaced directly</a></h3>
<p>These post-C++11 library features are <strong>not</strong> depended on <strong>currently</strong> (revised b865[2018-08-23]) but direct replacements (to be used <strong>conditionally</strong> once the draft standard is approved) are provided in YBase:</p>
<ul>
<li>parts of <a href="https://wg21.cmeerw.net/lwg/issue1234">LWG 1234</a>: &quot;Do the right thing&quot; and <code>NULL</code>
<ul>
<li>replaced by <code>ystdex::basic_string</code></li>
<li>see also dedicated <code>ystdex::list</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2108">LWG 2108</a>: No way to identify allocator types that always compare equal
<ul>
<li>with part of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4258.pdf">N4258</a>: Cleaning-up <code>noexcept</code> in the Library (Rev 3)</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2467">LWG 2467</a>: <code>is_always_equal</code> has slightly inconsistent default</li>
<li><code>std::allocator_tratits::is_always_equal</code> is provided as member of <code>ystdex::allocator_traits</code>; see also dedicated <code>ystdex::map</code> for one of the drop-in replacements</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2188">LWG 2188</a>: Reverse iterator does not fully support targets that overload <code>operator&amp;</code>
<ul>
<li>replaced by <code>ystdex::reverse_iterator</code></li>
<li>adopted by LWG motion 3 in editor's report <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3938.html">N3938</a> with editorial fix</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2268">LWG 2268</a>: Setting a default argument in the declaration of a member function assign of <code>std::basic_string</code>
<ul>
<li>replaced by <code>ystdex::basic_string</code></li>
</ul>
</li>
<li>parts of <a href="https://wg21.cmeerw.net/lwg/issue2193">LWG 2193</a>: Default constructors for standard library containers are explicit
<ul>
<li>replaced by <code>ystdex::basic_string</code></li>
<li>see also dedicated <code>ystdex::map</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2247">LWG 2247</a>: Type traits and <code>std::nullptr_t</code>
<ul>
<li>replaced by <code>ystdex::is_null_pointer</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2296">LWG 2296</a>: <code>std::addressof</code> should be <code>constexpr</code>
<ul>
<li>replaced by <code>ystdex::addressof</code> <strong>with compatibility excptions</strong>
<ul>
<li>implemented in a best effort way: <code>constepxr</code> works with most usual but not all cases like C++17 due to compatibility limitations where no <code>__builtin_addressof</code> is supported by the implementation</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2598">LWG 2598</a>: <code>addressof</code> works on temporaries</li>
</ul>
</li>
<li>adopted by part of LWG motion 16 in editor's report <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4583.html">N4583</a></li>
</ul>
</li>
<li>part of <a href="https://wg21.cmeerw.net/lwg/issue2455">LWG 2455</a>: Allocator default construction should be allowed to throw
<ul>
<li>replaced by <code>ystdex::basic_string</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2579">LWG 2579</a>: Inconsistency wrt Allocators in <code>basic_string</code> assignment vs. <code>basic_string::assign</code>
<ul>
<li>replaced by <code>ystdex::basic_string</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2583">LWG 2583</a>: There is no way to supply an allocator for <code>basic_string(str, pos)</code>
<ul>
<li>replaced by <code>ystdex::basic_string</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2778">LWG 2778</a>: <code>basic_string_view</code> is missing constexpr
<ul>
<li>replaced by <code>ystdex::basic_string_view</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2788">LWG 2788</a>: <code>basic_string</code> range mutators unintentionally require a default constructible allocator
<ul>
<li>replaced by <code>ystdex::basic_string</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2812">LWG 2812</a>: Range access is available with <code>&lt;string_view&gt;</code>
<ul>
<li>replaced by <code>&quot;string_view.hpp&quot;</code></li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3911.pdf">N3911</a>: TransformationTrait Alias <code>void_t</code>
<ul>
<li>replaced by <code>void_t</code> in namespace <code>ystdex::cpp2017</code>, with workaround for <a href="http://wg21.cmeerw.net/cwg/issue1558">CWG 1558</a></li>
<li>see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3843.pdf">N3843</a> for motivation</li>
</ul>
</li>
<li>parts of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4258.pdf">N4258</a> (adopted 2014-11)
<ul>
<li>replaced by <code>ystdex::allocator_traits::is_always_equal</code>; see <a href="https://wg21.cmeerw.net/lwg/issue2108">LWG 2108</a></li>
<li>replaced by <code>ystdex::basic_string</code></li>
<li>see also dedicated <code>ystdex::map</code></li>
<li>see also <a href="https://wg21.cmeerw.net/lwg/issue2455">LWG 2455</a> of change on <code>std::vector</code> (<strong>not replaced</strong>)</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4277.html">N4277</a>: TriviallyCopyable <code>reference_wrapper</code> (Revision 1)
<ul>
<li>with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0357r2.html">P0357R2</a>: <code>reference_wrapper</code> for incomplete types</li>
<li>replaced by <code>ystdex::lref</code></li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4280.pdf">N4280</a>: Non-member <code>size()</code> and more (Revision 2) (adopted 2014-11)
<ul>
<li>replaced by <code>size</code>, <code>empty</code> and <code>data</code> in namespace <code>ystdex::cpp2017</code> conforming to designated customization point specified by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0551r3.pdf">P0551R3</a>, also <code>ystdex::range_size</code> with addtional interface for <code>std::initializer_list</code></li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4436.pdf">N4436</a>: Proposing Standard Library Support for the C++ Detection Idiom
<ul>
<li>partially replaced by <code>is_detected</code>, <code>detected_t</code>, <code>detected_or</code>, <code>detected_or_t</code>, <code>is_detected_exact</code> and <code>is_detected_convertile</code> in namespace <code>ystdex</code></li>
</ul>
</li>
<li><code>std::experimental::fundamentals_v2::observer_ptr</code> in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4562.html#memory.observer.ptr">N4562</a>
<ul>
<li>replaced feature based on <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4282.pdf">N4282</a>: A Proposal for the World's Dumbest Smart Pointer, v4</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0007r1.html">P0007R1</a>: Constant View: A proposal for a <code>std::as_const</code> helper function template (adopted 2015-11)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0013r1.html">P0013R1</a>: Logical Operator Type Traits (revision 1) (adopted 2015-10)
<ul>
<li>replaced by <code>conjunction</code>, <code>disjunction</code> and <code>negation</code> in namespace <code>ystdex</code>, based on <code>and_</code>, <code>or_</code> and <code>not_</code> (see dedicated replacements below)</li>
</ul>
</li>
<li>parts of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0031r0.html">P0031R0</a>: A Proposal to Add Constexpr Modifiers to <code>reverse_iterator</code>, <code>move_iterator</code>, <code>array</code> and Range Access
<ul>
<li>partially replaced by <code>reverse_iterator</code>, <code>begin</code>, <code>cbegin</code>, <code>end</code>, <code>cend</code>, <code>rbegin</code>, <code>crbegin</code>, <code>rend</code> and <code>crend</code> in namespace <code>ystdex</code></li>
<li>adopted by part of LWG motion 16 in edtitor report <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4583.html">N4583</a></li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r3.html">P0091R3</a>: Template argument deduction for class templates (Rev. 6) (adopted 2016-06)</li>
<li>interface in headers <code>&lt;optional&gt;</code>, <code>&lt;string_view&gt;</code> and <code>&lt;memory_resource&gt;</code> in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0220r1.html">P0220R1</a>: Adopt Library Fundamentals V1 TS Components for C++17 (R1)
<ul>
<li><code>&lt;optional&gt;</code> replaced by <code>&lt;ystdex/optional.hpp&gt;</code>
<ul>
<li><code>std::bad_optional_access</code> replaced by <code>ystdex::bad_optional_access</code></li>
<li><code>std::optional</code> replaced by <code>ystdex::cpp2017::optional</code></li>
</ul>
</li>
<li><code>&lt;string_view&gt;</code> replaced by <code>&lt;ystdex/string_view.hpp&gt;</code>
<ul>
<li><code>std::basic_string_view</code> replaced by <code>ystdex::cpp2017::basic_string_view</code></li>
<li><code>std::string_view</code> replaced by <code>ystdex::cpp2017::string_view</code></li>
<li><code>std::wstring_view</code> replaced by <code>ystdex::cpp2017::wstring_view</code></li>
<li><code>std::u16string_view</code> replaced by <code>ystdex::cpp2017::u16string_view</code></li>
<li><code>std::u32string_view</code> replaced by <code>ystdex::cpp2017::u32string_view</code></li>
</ul>
</li>
<li><code>&lt;memory_resource&gt;</code> replaced by <code>&lt;ystdex/memory_resource.h&gt;</code>
<ul>
<li><code>std::pmr::memory_resource</code> replaced by <code>ystdex::pmr::cpp2017::memory_resource</code></li>
<li><code>std::pmr::polymorphic_allocator</code> replaced by <code>ystdex::pmr::cpp2017::polymorphic_allocator</code></li>
<li><code>std::pmr::new_delete_resource</code> replaced by <code>ystdex::pmr::cpp2017::new_delete_resource</code></li>
<li><code>std::pmr::null_memory_resource</code> replaced by <code>ystdex::pmr::cpp2017::null_memory_resource</code></li>
<li><code>std::pmr::set_default_resource</code> replaced by <code>ystdex::pmr::cpp2017::set_default_resource</code></li>
<li><code>std::pmr::get_defualt_resource</code> replaced by <code>ystdex::pmr::cpp2017::get_defualt_resource</code></li>
<li><code>std::pmr::pool_options</code> replaced by <code>ystdex::pmr::pool_options</code></li>
<li><code>std::pmr::cpp2017::synchronized_pool_resource</code> replaced by <code>ystdex::pmr::cpp2017::synchronized_pool_resource</code></li>
<li><code>std::pmr::unsynchronized_pool_resource</code> replaced by <code>ystdex::pmr::cpp2017::unsynchronized_pool_resource</code></li>
<li><code>std::pmr::monotonic_buffer_resource</code> replaced by <code>ystdex::pmr::cpp2017::monotonic_buffer_resource</code></li>
</ul>
</li>
<li><code>std::apply</code> in <code>&lt;tuple&gt;</code> replaced by <code>ystdex::apply</code>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3915.pdf">N3915</a>: <code>apply()</code> call a function with arguments from a tuple (V3) (adopted 2014-02)</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2418">LWG 2418</a>: [fund.ts] <code>apply</code> does not work with member pointers</li>
</ul>
</li>
<li>partially adopted by LWG motion 6 in editor's report <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4583.html">N4583</a>
<ul>
<li><code>&lt;optional&gt;</code>, <code>&lt;string_view&gt;</code>, <code>&lt;memory_resource&gt;</code> and <tuple> in parts of LWG motion 6: <a href="http://wg21.link/p0220r1">P0220R1</a> &quot;Adopt library fundamentals v1 TS components for C++17&quot;) (incompletely applied from <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4562.html">N4562</a>)</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2283">LWG 2283</a>: [fund.ts] <code>optional</code> declares and then does not define an <code>operator&lt;() </code> (this is actually targetting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3691.pdf">the standard draft</a>, not <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4023.html#optional.comp_with_t">the library fundmental draft</a>)</li>
<li>with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4078.html">N4078</a>: Fixes for <code>optional</code> objects (adopted 2014-06)</li>
</ul>
</li>
<li>with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0254r2.pdf">P0254R2</a>: Integrating <code>std::string_view</code> and <code>std::string</code> (adopted 2016-06, by LWG motion 14 in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4603.html">N4603</a>)
<ul>
<li>replaced by <code>ystdex::basic_string</code> and <code>ystdex::basic_string_view</code></li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2742">LWG 2742</a>: Inconsistent string interface taking <code>string_view</code></li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2758">LWG 2758</a>: <code>std::string{}.assign(&quot;ABCDE&quot;, 0, 1)</code> is ambiguous
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2757">LWG 2757</a>: <code>std::string{}.insert(3, &quot;ABCDE&quot;, 0, 1)</code> is ambiguous</li>
</ul>
</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2771">LWG 2771</a>: Broken Effects of some <code>basic_string::compare</code> functions in terms of <code>basic_string_view</code> (see <a href="https://wg21.cmeerw.net/lwg/issue2758">LWG 2758</a>)</li>
</ul>
</li>
<li>with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0337r0.html">P0337R0</a>: Delete <code>operator=</code> for <code>polymorphic_allocator</code> (adopted by LWG motion 26 in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4603.html">N4603</a>)</li>
<li>with changes on <code>pmr::memory_resource</code> in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0619r4.html">P0619R4</a></li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2724">LWG 2724</a>: The <code>protected virtual</code> member functions of <code>memory_resource</code> should be <code>private</code></li>
<li>conditionally with <a href="https://wg21.cmeerw.net/lwg/issue2740">LWG 2740</a>: <code>constexpr optional&lt;T&gt;::operator-&gt;</code>
<ul>
<li>only with <code>constexpr addressof</code> (i.e. since C++17 or with some extensions)</li>
</ul>
</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2756">LWG 2756</a>: C++ WP <code>optional&lt;T&gt;</code> should '<code>forward</code>' <code>T</code>'s implicit conversions</li>
<li><strong>without</strong> <a href="https://wg21.cmeerw.net/lwg/issue2825">LWG 2825</a>: <a href="https://wg21.cmeerw.net/lwg/issue2756">LWG 2756</a> breaks class template argument deduction for optional, as the resolution need <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0091r4.html">deduction guides</a> unsupported here yet</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2842">LWG 2806</a>: Base class of <code>bad_optional_access</code></li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2842">LWG 2842</a>: <code>in_place_t</code> check for <code>optional::optional(U&amp;&amp;)</code> should decay <code>U</code></li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2843">LWG 2843</a>: Unclear behavior of <code>std::pmr::memory_resource::do_allocate()</code></li>
<li>with part (for <code>optional</code>) of <a href="https://wg21.cmeerw.net/lwg/issue2857">LWG 2857</a>: <code>{variant,optional,any}::emplace</code> should return the constructed value
<ul>
<li>partially replaced by <code>ystdex::any</code></li>
</ul>
</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2900">LWG 2900</a>: The copy and move constructors of <code>optional</code> are not <code>constexpr</code></li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2961">LWG 2961</a>: Bad postcondition for <code>set_default_resource</code> (similart to <a href="https://wg21.cmeerw.net/lwg/issue2522">LWG 2522</a> targetting Library Fundamentals V2)</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2969">LWG 2969</a>: <code>polymorphic_allocator::construct()</code> shouldn't pass <code>resource()</code></li>
<li>with parts (concerned with <code>polymorphic_allocator</code>) of <a href="https://wg21.cmeerw.net/lwg/issue2975">LWG 2975</a>: Missing case for pair construction in scoped and polymorphic allocators</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue3000">LWG 3000</a>: <code>monotonic_memory_resource::do_is_equal</code> uses <code>dynamic_cast</code> unnecessarily</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue3036">LWG 3036</a>: <code>polymorphic_allocator::destroy</code> is extraneous</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue3037">LWG 3037</a>: <code>polymorphic_allocator</code> and incomplete types</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue3038">LWG 3038</a>: <code>polymorphic_allocator::allocate</code> should not allow integer overflow to create vulnerabilities</li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue3113">LWG 3113</a>: <code>polymorphic_allocator::construct()</code> should more closely match <code>scoped_allocator_adaptor::construct()</code></li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0185r1.html">P0185R1</a> Adding [<code>nothrow</code>-]<code>swappable</code> traits, revision 3 (adopted 2016-02)
<ul>
<li>replaced by <code>is_swappable_with</code>, <code>is_swappable</code>, <code>is_nothrow_swappable_with</code> and <code>is_nothrow_swappable</code> in namespace <code>ystdex</code>, and <code>swap</code> in namespace <code>ystdex_swap</code> (see also <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0879r0.html">P0879R0</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2456">LWG 2456</a>: Incorrect exception specifications for '<code>swap</code>' throughout library</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2554">LWG 2554</a>: Swapping multidimensional arrays is never <code>noexcept</code></li>
<li>see also <a href="https://wg21.cmeerw.net/lwg/issue2766">LWG 2766</a></li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0209r2.pdf">P0209R2</a> <code>make_from_tuple</code>: <code>apply</code> for construction (adopted 2016-06, by LWG motion 23 in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4603.html">N4603</a>)
<ul>
<li>replaced by <code>ystdex::make_from_tuple</code></li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0298r3.pdf">P0298R3</a>: A byte type definition
<ul>
<li>replaced by <code>ystdex::byte</code>, except when the core language support unavailable before C++17, where the name is provided as an alias of <code>unsigned char</code></li>
<li>see also <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0583r0.pdf">P0583R0</a>.</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0550r2.pdf">P0550R2</a>: Transformation Trait <code>remove_cvref</code>
<ul>
<li>replaced by <code>ystdex::remove_cvref</code></li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0604r0.html">P0604R0</a>: Resolving GB 55, US 84, US 85, US 86 (adopted 2017-03)
<ul>
<li>partially replaced by <code>invoke_result</code>, <code>invoke_result_t</code>, <code>is_invocable</code>, <code>is_invocable_r</code>, <code>is_nothrow_invocable</code> and <code>is_nothrow_invocable_r</code> in namespace <code>ystdex::cpp2017</code></li>
<li>revised previously-adopted <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0077r2.html">P0077R2</a>: <code>is_callable</code>, the missing <em><code>INVOKE</code></em> related trait (adopted 2016-02)</li>
<li>GB 55, US 84, US 85, US 86 accepted with modifications in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4664.pdf">N4664</a></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2017">LWG 2017</a>: <code>std::reference_wrapper</code> makes incorrect usage of <code>std::result_of</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2021">LWG 2021</a>: Further incorrect usages of <code>result_of</code></li>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2219">LWG 2219</a>: <em><code>INVOKE</code></em>-ing a pointer to member with a reference_wrapper as the object expression</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2767">LWG 2767</a>: <code>not_fn</code> call_wrapper can form invalid types</li>
</ul>
</li>
<li>all new function templates in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0591r4.pdf">P0591R4</a>: Utility functions to implement uses-allocator construction (adopted 2018-11)
<ul>
<li><code>std::uses_allocator_construction_args</code> replaced by <code>ystdex::uses_allocator_construction_args</code></li>
<li><code>std::make_obj_using_allocator</code> replaced by <code>ystdex::make_obj_using_allocator</code></li>
<li><code>std::uninitialized_construct_using_allocator</code> replaced by <code>ystdex::uninitialized_construct_using_allocator</code></li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0607r0.html">P0607R0</a>: Inline Variables for the Standard Library
<ul>
<li>depends on <a href="http://wg21.cmeerw.net/cwg/issue1713">CWG 1713</a>), the &quot;minimalistic suggestion&quot; and &quot;additional suggestion&quot; in paper are fully (both) taken in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf">N4659</a>, which is not explicitly indicated by the editor's report <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4661.html">N4661</a></li>
<li>partially replaced by <code>ystdex::nullopt</code></li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0619r4.html">P0619R4</a>: Reviewing Deprecated Facilities of C++17 for C++20
<ul>
<li><code>std::reference_wrapper</code> partially replaced by <code>ystdex::lref</code></li>
<li><code>std::iterator</code> is not used (see also <a href="https://wg21.cmeerw.net/lwg/issue2438">LWG 2438</a>)</li>
<li>changes on <code>std::pmr::memory_resource</code> is implemented for <code>ystdex::pmr::memory_resource</code></li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0653r2.html">P0653R2</a>: Utility to convert a pointer to a raw pointer (adopted 2017-11)
<ul>
<li><code>std::to_address</code> is replaced by <code>ystdex::to_address</code></li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0879r0.html">P0879R0</a>: Constexpr for <code>swap</code> and <code>swap</code> related functions
<ul>
<li>partially replaced by <code>swap</code> in namespace <code>ystdex_swap</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2800">LWG 2800</a>: <code>constexpr</code> <code>swap</code></li>
<li>this is now in the <a href="https://raw.githubusercontent.com/cplusplus/draft/master/papers/n4762.pdf">working draft</a>, though not in the list of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/">official page</a> as of b834[2018-08-03]</li>
<li>adopted by LWG motion 21 in editor's report <a href="https://github.com/cplusplus/draft/blob/master/papers/n4764.md">N4764</a></li>
</ul>
</li>
</ul>
<p>Some applied resolution also works on replacements, listed here for exposition-only use:</p>
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue280">LWG 280</a>: Comparison of <code>reverse_iterator</code> to <code>const reverse_iterator</code>
<ul>
<li>partially replaced by <code>ystdex::reverse_iterator</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue386">LWG 386</a>: Reverse iterator's <code>operator[]</code> has impossible return type
<ul>
<li>replaced by <code>ystdex::reverse_iterator::operator[]</code></li>
</ul>
</li>
</ul>
<h3 id="replaced-alternatively"><a class="header" href="#replaced-alternatively">Replaced alternatively</a></h3>
<p>These features were once adopted by the working paper but later removed away, and further actions different to the committee are considered by this project for practical reasons (e.g. compatibility and availability in lack of other features):</p>
<ul>
<li>parts of <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0032r3.pdf">P0032R3</a>: Homogeneous interface for <code>variant</code>, <code>any</code> and <code>optional</code> (Revision 3) (adopted 2016-06)
<ul>
<li>see national body comment CH 3 relavent to parts of <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0032r3.pdf">P0032R3</a> in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0488r0.pdf">P0488R0</a>: WG21 Working Paper, NB Comments, ISO/IEC CD 14882</li>
<li>see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0504r0.html">P0504R0</a>: Revisiting in-place tag types for <code>any</code>/<code>optional</code>/<code>variant</code></li>
<li>removed by <a href="https://github.com/cplusplus/draft/commit/d2d23690a253b91fb7ccb1631581bd9c8f2937d2">this commit</a></li>
<li>this is not always taken in the direct replacements in <code>namespace ystdex::cpp2017</code> to avoid impaction from lack of varaible template support</li>
</ul>
</li>
</ul>
<h3 id="replaced-dedicately"><a class="header" href="#replaced-dedicately">Replaced dedicately</a></h3>
<p>There are several core language issues are resolved by YDefinition core language compatiblitiy features <strong>conditioanlly</strong>, even though they may be still not adopted or even without a concrete proposed resolution currently (revised b835[2018-08-14]):</p>
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue2097">CWG 2097</a>: Lambdas and <code>noreturn</code> attribute</li>
</ul>
<p>There are several YBase features which can <strong>currently</strong> (revised b831[2018-07-11]) be used as replacement for similar post-C++11 library features. See also <a href="Features.zh-CN.html">Features(zh-CN)</a>.</p>
<ul>
<li>
<p><code>ystdex::and_</code>, <code>ystdex::or_</code> and <code>ystdex::not_</code> are provided to replace logical operation traits introduced in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0013r1.html">P0013R1</a></p>
<ul>
<li>currently aliases of them are also direct replacements in namespace <code>cpp2017</code></li>
</ul>
</li>
<li>
<p><code>ystdex::lref</code> is provided as a replacement for <code>std::reference_wrapper</code> with less verbosity</p>
<ul>
<li>supports <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4277.html">N4277</a>: TriviallyCopyable <code>reference_wrapper</code> (Revision 1)</li>
<li>otherwise mostly same to <code>boost::reference_wrapper</code> besides its name and <code>constexpr</code> requirements (needing core language support)
<ul>
<li>no deprecated members of <code>std::reference_wrapper</code>, see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0619r4.html">P0619R4</a>: Reviewing Deprecated Facilities of C++17 for C++20</li>
<li>supports incomplete value type, see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0357r2.html">P0357R2</a></li>
<li>not same type to any instance of <code>std::reference_wrapper</code> so not treated specially by <code>std::bind</code> and other <code>std</code> API</li>
</ul>
</li>
<li>with part of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0604r0.html">P0604R0</a></li>
<li>with part of <a href="https://wg21.cmeerw.net/lwg/issue2993">LWG 2993</a></li>
</ul>
</li>
<li>
<p><code>ystdex::unwrap_reference</code>, <code>ystdex::unwrap_reference_t</code>, <code>ystdex::unwrap_ref_decay</code> and <code>ystdex::unwrap_ref_decay_t</code> are provided with extensions for <code>ystdex::lref</code>, as replacement for the following C++20 features</p>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0318r1.pdf">P0318R1</a>: <code>unwrap_ref_decay</code> and <code>unwrap_reference</code> (adopted 2018-11)
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue3202">LWG 3202</a>: P0318R1 was supposed to be revised	</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>ystdex::any</code> is provided as a replacement for <code>std::any</code> with richer features and greater availability</p>
<ul>
<li>already with following C++17 <code>std::any</code> features
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2769">LWG 2769</a>
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2768">LWG 2768</a></li>
</ul>
</li>
<li>parts of <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0032r3.pdf">P0032R3</a>
<ul>
<li>with part of <a href="https://wg21.cmeerw.net/lwg/issue2857">LWG 2857</a></li>
</ul>
</li>
<li>NOTE: <a href="https://wg21.cmeerw.net/lwg/issue2509">LWG 2509</a> is superseded by the resolution and mostly not applicable because of the support of non <code>CopyConstructible</code> types (see below)</li>
<li>NOTE: <a href="https://wg21.cmeerw.net/lwg/issue2754">LWG 2754</a> is not applicable because the exact same reason above</li>
</ul>
</li>
<li>supports non <code>CopyConstructible</code> types (if a <code>ystdex::any</code> object holding an object of such type is eventually copied, exception would be thrown</li>
<li>with underlying interface for custom holders and handlers (for <code>ystdex::any_iterator</code>, etc)</li>
<li>supports constructor overload with minimal construction overhead for the empty object with <code>ystdex::default_init_t</code> parameter (at the cost of not supporting <code>constepxr</code> as the default constructor)</li>
<li>supports unsafe cast operations and more extensions to bypass checks with narrow contracts</li>
<li>early available before several standard proposals, including the <code>any</code> class itself and members like <code>emplace</code> (see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0032r0.pdf">P0032R0</a>)
<ul>
<li>actually being first to replace <code>boost::any</code> before <code>std::any</code> was proposed as a post-C++11 feature by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3390.html">N3390</a>: <em>Any</em> Library Proposal (Revision 1)</li>
<li>see also the original proposal <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1939.html">N1939</a>: <em>Any</em> Library Proposal for TR2</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>ystdex::function</code> is provided as a replacement for <code>std::function</code> with richer features</p>
<ul>
<li>with <a href="https://wg21.cmeerw.net/lwg/issue2062">LWG 2062</a> not depending on C++17</li>
<li>with allocator support in construction like the feature removed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0302r1.html">P0302R1</a></li>
</ul>
</li>
<li>
<p><code>ystdex::list</code> is proveded as a replacement for <code>std::list</code> with enhanced features</p>
<ul>
<li>(since C++11) with the part of <a href="https://wg21.cmeerw.net/lwg/issue1234">LWG 1234</a>: &quot;Do the right thing&quot; and <code>NULL</code></li>
<li>(since C++17) with the part of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4510.html">N4510</a>: Minimal incomplete type support for standard containers, revision 4</li>
<li>(since C++20) with the part of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0084r2.pdf">P0084R2</a>: Emplace Return Type (Revision 2) (adopted 2016-06)</li>
<li>with the part of <a href="https://wg21.cmeerw.net/lwg/issue2839">LWG 2839</a>: Self-move-assignment of library types, again</li>
</ul>
</li>
<li>
<p><code>ystdex::map</code> is provided as a replacement for <code>std::map</code> provided (other containers TBD) including follwing enhancement (full ISO C++17 features support):</p>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3657.htm">N3657</a></li>
<li>part of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4258.pdf">N4258</a> (adopted 2014-11)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4279.html">N4279</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0083r3.pdf">P0083R3</a></li>
<li>parts of <a href="http://wg21.cmeerw.net/lwg/issue2005">LWG 2005</a>
<ul>
<li>with <a href="http://wg21.cmeerw.net/lwg/issue2571">LWG 2571</a></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2059">LWG 2059</a></li>
<li>part of <a href="https://wg21.cmeerw.net/lwg/issue2354">LWG 2354</a></li>
<li>incomplete key and mapped types support which is not supported by C++17 (like <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4510.html">N4510</a>) yet (so it is not in <code>namespace ystdex::cpp2017</code>; although lisbstdc++ can support it)</li>
<li>part of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0458r2.html">P0458R2</a></li>
</ul>
</li>
</ul>
<h3 id="neutral-of-existence"><a class="header" href="#neutral-of-existence">Neutral of existence</a></h3>
<p>These post-C++03 (adopted, any proposed or any not proposed but theorotically allowed having well-defined behavior) resolutions or features (with diagnostic suggestions) are <strong>not</strong> depended on <strong>currently</strong> (revised b928[2021-10-22]) but confirmed still being compatible (however, user code can still be affected; some resolutions may have been applied to similar other interface of YBase, see sections above):</p>
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue446">CWG 446</a>: Does an lvalue-to-rvalue conversion on the &quot;<code>?</code>&quot; operator produce a temporary?
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue86">CWG 86</a>: Lifetime of temporaries in query expressions</li>
</ul>
</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue462">CWG 462</a>: Lifetime of temporaries bound to comma expressions</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue468">CWG 468</a>: Allow <code>::template</code> outside of templates</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue475">CWG 475</a>: When is <code>std::uncaught_exception()</code> <code>true</code>? (take 2)</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue515">CWG 515</a>: Non-dependent references to base class members (see also <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=21008">GCC PR 21008</a>)</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue569">CWG 569</a>: Spurious semicolons at namespace scope should be allowed</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue573">CWG 573</a>: Conversions between function pointers and <code>void*</code> (see also <a href="http://wg21.cmeerw.net/cwg/issue195">CWG 195</a>/<a href="http://wg21.cmeerw.net/cwg/issue1120">CWG 1120</a>)</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue760">CWG 760</a>: <code>this</code> inside a nested class of a non-static member function</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue903">CWG 903</a>: Value-dependent integral null pointer constants
<ul>
<li>NOTE: This is actually adopted after C++11 despite the compatibility clause is agianst to C++03.</li>
</ul>
</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1120">CWG 1120</a>: <code>reinterpret_cast</code> and <code>void*</code> (depends on <a href="http://wg21.cmeerw.net/cwg/issue573">CWG 573</a>)</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1164">CWG 1164</a>: Partial ordering of <code>f(T&amp;)</code> and <code>f(T&amp;&amp;)</code></li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1213">CWG 1213</a>: Array subscripting and xvalues (see also <a href="http://wg21.cmeerw.net/cwg/issue616">CWG 616</a>)</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1227">CWG 1227</a>: Mixing immediate and non-immediate contexts in deduction failure</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1255">CWG 1255</a>: Definition problems with <code>constexpr</code> functions</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1301">CWG 1301</a>: Value initialization of union
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue1324">CWG 1324</a>: Value initialization and defaulted constructors</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1368">CWG 1368</a>: Value initialization and defaulted constructors (part 2)</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1310">CWG 1310</a>: What is an “acceptable lookup result?”</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1399">CWG 1399</a>: Missing non-deduced context following a function parameter pack
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue1388">CWG 1388</a>: Deduction with multiple function parameter packs</li>
</ul>
</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1402">CWG 1402</a>: Move functions too often deleted
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue1491">CWG 1491</a>: Move construction and rvalue reference members</li>
</ul>
</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1412">CWG 1412</a>: Problems in specifying pointer conversions</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1579">CWG 1579</a>: Return by converting move constructor</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1591">CWG 1591</a>: Deducing array bound and element type from initializer list</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1626">CWG 1626</a>: <code>constexpr</code> member functions in <code>brace-or-equal-initializer</code>s</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1665">CWG 1665</a>: Declaration matching in explicit instantiations</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1693">CWG 1693</a>: Superfluous semicolons in class definitions (depends on <a href="http://wg21.cmeerw.net/cwg/issue569">CWG 569</a>)</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1713">CWG 1713</a>: Linkage of variable template specializations</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1875">CWG 1875</a>: Reordering declarations in class scope</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1895">CWG 1895</a>: Deleted conversions in conditional operator operands
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue1932">CWG 1932</a>: Bit-field results of conditional operators</li>
</ul>
</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1952">CWG 1952</a>: Constant expressions and library undefined behavior</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1980">CWG 1980</a>: Equivalent but not functionally-equivalent redeclarations</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue2137">CWG 2137</a>: List-initialization from object of same type</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue2248">CWG 2248</a>: Problems with sized <code>delete</code></li>
<li><a href="https://wg21.cmeerw.net/cwg/issue2267">CWG 2267</a>: Copy-initialization of temporary in reference direct-initialization</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue2022">CWG 2278</a>: Copy elision in constant expressions reconsidered</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue2313">CWG 2313</a>: Redeclaration of structured binding reference variables</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue281">LWG 281</a>: <code>std::min()</code> and <code>max()</code> requirements overly restrictive</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue283">LWG 283</a>: <code>std::replace()</code> requirement incorrect/insufficient</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue387">LWG 387</a>: <code>std::complex</code> over-encapsulated</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue402">LWG 402</a>: wrong new expression in <code>[some_]allocator::construct</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue455">LWG 455</a>: <code>cerr::tie()</code> and <code>wcerr::tie()</code> are overspecified</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue497">LWG 497</a>: meaning of <code>numeric_limits::traps</code> for floating point types</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue531">LWG 531</a>: array forms of unformatted input functions (i.e. for <code>istream::get</code>)</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue543">LWG 543</a>: <code>valarray</code> slice default constructor</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue551">LWG 551</a>: <code>&lt;ccomplex&gt;</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue565">LWG 565</a>: <code>xsputn</code> inefficient</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue566">LWG 566</a>: array forms of unformatted input function undefined for zero-element arrays (i.e. for <code>istream::get</code>)</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue576">LWG 576</a>: <code>find_first_of</code> is overconstrained</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue578">LWG 578</a>: purpose of hint to <code>allocator::allocate()</code></li>
<li><a href="http://wg21.cmeerw.net/lwg/issue586">LWG 586</a>: string inserter not a formatted function</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue593">LWG 593</a>: <code>__STDC_CONSTANT_MACROS</code></li>
<li><a href="http://wg21.cmeerw.net/lwg/issue619">LWG 619</a>: Longjmp wording problem</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue643">LWG 643</a>: Impossible &quot;as if&quot; clauses</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue646">LWG 646</a>: <code>const</code> incorrect <code>match_result</code> members</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue659">LWG 659</a>: <code>istreambuf_iterator</code> should have an <code>operator-&gt;()</code></li>
<li><a href="http://wg21.cmeerw.net/lwg/issue776">LWG 776</a>: Undescribed assign function of <code>std::array</code> (i.e. <code>array::fill</code>)</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue779">LWG 779</a>: Resolution of <a href="http://wg21.cmeerw.net/lwg/issue283">#283</a> incomplete</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue787">LWG 787</a>: complexity of <code>binary_search</code></li>
<li><a href="http://wg21.cmeerw.net/lwg/issue807">LWG 807</a>: <code>tuple</code> construction should not fail unless its element's construction fails</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue844">LWG 844</a>: <code>complex</code> <code>pow</code> return type is ambiguous</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue848">LWG 848</a>: Missing std::hash specializations for <code>std::bitset</code>/<code>std::vector&lt;bool&gt;</code></li>
<li><a href="http://wg21.cmeerw.net/lwg/issue850">LWG 850</a>: Should <code>shrink_to_fit</code> apply to <code>std::deque</code>? (i.e. <code>deque::shrink_to_fit</code>)</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue852">LWG 852</a>: unordered containers <code>begin(n)</code> mistakenly <code>const</code></li>
<li><a href="http://wg21.cmeerw.net/lwg/issue900">LWG 900</a>: Stream move-assignment</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue1004">LWG 1004</a>: Clarify &quot;throws an exception&quot;
<ul>
<li>see national body comment UK 179 in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2837.pdf">N2837</a>: C++0X, CD 1, National Body Comments</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue1012">LWG 1012</a>: <code>reverse_iterator</code> default ctor should value initialize (adopted by LWG motion 1 in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3001.html">N3001</a>)</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue1071">LWG 1071</a>: <code>is_bind_expression</code> should derive from <code>integral_constant&lt;bool&gt;</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue1334">LWG 1334</a>: Insert iterators are broken for some proxy containers compared to C++03</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue1399">LWG 1399</a>: <code>function</code> does not need an explicit default constructor</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue1402">LWG 1402</a>: <code>nullptr</code> constructors for smart pointers should be <code>constexpr</code></li>
<li><a href="http://wg21.cmeerw.net/lwg/issue2005">LWG 2005</a>: <code>unordered_map::insert(T&amp;&amp;)</code> protection should apply to <code>map</code> too
<ul>
<li>partially replaced by <code>ystdex::map</code></li>
<li>with <a href="http://wg21.cmeerw.net/lwg/issue2571">LWG 2571</a>: §[map.modifiers]/2 imposes nonsensical requirement on <code>insert(InputIterator, InputIterator)</code>
<ul>
<li>replaced by <code>ystdex::map</code></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2059">LWG 2059</a>: C++0x ambiguity problem with <code>map::erase</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2103">LWG 2103</a>: <code>std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::propagate_on_container_move_assignment</code> (see also <a href="https://wg21.cmeerw.net/lwg/issue2108">LWG 2108</a>)</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue2104">LWG 2104</a>: <code>unique_lock</code> move-assignment should not be <code>noexcept</code></li>
<li><a href="http://wg21.cmeerw.net/lwg/issue2112">LWG 2112</a>: User-defined classes that cannot be derived from (i.e. <code>is_final</code>)</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue2135">LWG 2135</a>: Unclear requirement for exceptions thrown in <code>condition_variable::wait()</code></li>
<li><a href="http://wg21.cmeerw.net/lwg/issue2247">LWG 2247</a>: Type traits and <code>std::nullptr_t</code> (i.e. <code>is_null_pointer</code>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2321">LWG 2321</a>: Moving containers should (usually) be required to preserve iterators
<ul>
<li>replaced by <code>ystdex::map</code> and some other containers in YBase.YStandardEx which support the resolution</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2354">LWG 2354</a>: Unnecessary copying when inserting into maps with braced-init syntax</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2360">LWG 2360</a>: <code>reverse_iterator::operator*()</code> is unimplementable (see also <a href="https://wg21.cmeerw.net/lwg/issue2204">LWG 2204</a>)</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue2362">LWG 2362</a>: unique, associative <code>emplace()</code> should not move/copy the mapped_type constructor arguments when no insertion happens (see also <a href="http://wg21.cmeerw.net/lwg/issue2006">LWG 2006</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2393">LWG 2393</a>: <code>std::function</code>'s <code>Callable</code> definition is broken</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2408">LWG 2408</a>: SFINAE-friendly <code>common_type</code>/<code>iterator_traits</code> is missing in C++14</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2437">LWG 2437</a>: <code>iterator_traits::reference</code> can and can't be <code>void</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2438">LWG 2438</a>: <code>std::iterator</code> inheritance shouldn't be mandated</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue2442">LWG 2442</a>: <code>call_once()</code> shouldn't <code>DECAY_COPY()</code></li>
<li><a href="http://wg21.cmeerw.net/lwg/issue2466">LWG 2466</a>: <code>allocator_traits::max_size()</code> default behavior is incorrect</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2470">LWG 2470</a>: Allocator's <code>destroy</code> function should be allowed to fail to instantiate (split from <a href="https://wg21.cmeerw.net/lwg/issue2447">LWG 2447</a>)</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2483">LWG 2483</a>: <code>throw_with_nested()</code> should use <code>is_final</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2485">LWG 2485</a>: <code>get()</code> should be overloaded for <code>const tuple&amp;&amp;</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2509">LWG 2509</a>: [fund.ts.v2] <code>any_cast</code> doesn't work with rvalue reference targets and cannot move with a value target
<ul>
<li>NOTE: The proposed resolution is targeting the working paper of the TS. It is not applied to <code>std::any</code> in ISO C++17 and it is still not in post-C++17 working draft <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4778.pdf">N4778</a>, and it is overriden by the resolution of <a href="https://wg21.cmeerw.net/lwg/issue2769">LWG 2769</a> partially.</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2547">LWG 2547</a>: Container requirements (and other library text) should say &quot;strict total order&quot;, not just &quot;total order&quot;</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2549">LWG 2549</a>: Tuple EXPLICIT constructor templates that take tuple parameters end up taking references to temporaries and will create dangling references
<ul>
<li>see also <a href="https://wg21.cmeerw.net/lwg/issue2312">LWG 2312</a></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2567">LWG 2567</a>: Specification of logical operator traits uses <code>BaseCharacteristic</code>, which is defined only for <code>UnaryTypeTrait</code>s and <code>BinaryTypeTraits</code>
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2568">LWG 2568</a>: [fund.ts.v2] Specification of logical operator traits uses <code>BaseCharacteristic</code>, which is defined only for <code>UnaryTypeTraits</code> and <code>BinaryTypeTraits</code></li>
</ul>
</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue2577">LWG 2577</a>: <code>{shared,unique}_lock</code> should use <code>std::addressof</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2591">LWG 2591</a>: <code>std::function</code>'s member template <code>target()</code> should not lead to undefined behaviour</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2729">LWG 2729</a>: Missing SFINAE on <code>std::pair::operator=</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2754">LWG 2754</a>: The <code>in_place</code> constructors and emplace functions added by <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0032r3.pdf">P0032R3</a> don't require <code>CopyConstructible</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2766">LWG 2766</a>: Swapping non-swappable types</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2769">LWG 2769</a>: Redundant <code>const</code> in the return type of <code>any_cast(const any&amp;)</code>
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2768">LWG 2768</a>: <code>any_cast</code> and move semantics</li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2781">LWG 2781</a>: Contradictory requirements for <code>std::function</code> and <code>std::reference_wrapper</code>
<ul>
<li>replaced by <code>ystdex::function</code> with the resolution</li>
<li>see also <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66284">GCC PR66284</a></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2794">LWG 2794</a>: Missing requirements for allocator pointers</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2857">LWG 2857</a>: {<code>variant</code>,<code>optional</code>,<code>any</code>}<code>::emplace</code> should return the constructed value
<ul>
<li>partially replaced by <code>ystdex::any</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue2993">LWG 2993</a>: <code>reference_wrapper&lt;T&gt;</code> conversion from <code>T&amp;&amp;</code>
<ul>
<li>partially replaced by <code>ystdex::lref</code></li>
</ul>
</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue3017">LWG 3017</a>: <code>list</code> <code>splice</code> functions should use <code>addressof</code></li>
<li><a href="https://wg21.cmeerw.net/lwg/issue3087">LWG 3087</a>: One final <code>&amp;x</code> in §[list.ops]</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1981.html">N1981</a>: Uniform Use of <code>std::string</code> Revision 1</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1990.htm">N1990</a>: Proposed Text for <code>minmax</code> (N1840) (i.e. <code>minmax</code> and <code>minmax_element</code> in <code>&lt;algorithm&gt;</code>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1991.htm">N1991</a>: Proposed Text for <code>defaultfloat</code> (N1842) (i.e. <code>defaultfloat</code> in <code>&lt;ios&gt;</code>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2007.html">N2007</a>: Proposed Library Additions for Code Conversion</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2111.pdf">N2111</a>: Random Number Generation in C++0X: A Comprehensive Proposal, version 4
<ul>
<li>with <a href="http://wg21.cmeerw.net/lwg/issue609">LWG 609</a>: missing <code>static const</code></li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2253.html">N2253</a>: Extending <code>sizeof</code> to apply to non-static data members without an object (revision 1)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2292.html">N2292</a>: Standard Library Applications for Deleted Functions</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2321.html">N2321</a>: Enhancing the <code>time_get</code> facet for POSIX® compatibility, Revision 2</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2353.html">N2353</a>: A Specification for <code>vector&lt;bool&gt;</code></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2547.htm">N2547</a>: Allow atomics use in signal handlers</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2554.pdf">N2554</a>: The Scoped Allocator Model (Rev 2)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2760.htm">N2760</a>: Input/Output Library Thread Safety</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2765.pdf">N2765</a>: User-defined Literals (aka. Extensible Literals (revision 5))</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2782.htm">N2782</a>: C++ Data-Dependency Ordering: Function Annotation (i.e. <code>[[carries_dependency]]</code>)</li>
<li>N3026
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue408">CWG 408</a>: <code>sizeof</code> applied to unknown-bound array <code>static</code> data member of template</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue490">CWG 490</a>: Name lookup in <code>friend</code> declarations</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue722">CWG 722</a>: Can <code>nullptr</code> be passed to an ellipsis?</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue734">CWG 734</a>: Are unique addresses required for namespace-scope variables?</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue935">CWG 935</a>: Missing overloads for character types for user-defined literals</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1000">CWG 1000</a>: Mistaking member <code>typedef</code>s for constructors</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3059.pdf">N3059</a>: Proposal to simplify <code>pair</code> (rev 5.2) (i.e. <code>piecewise_construct_t</code>, etc.)
<ul>
<li><a href="http://wg21.cmeerw.net/lwg/issue1321">LWG 1321</a>: <code>scoped_allocator_adaptor</code> <code>construct</code> and <code>destroy</code> don't use <code>allocator_traits</code></li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3282.pdf">N3282</a>: Resolution for core issues <a href="http://wg21.cmeerw.net/cwg/issue1207">1207</a> and [1017](](http://wg21.cmeerw.net/cwg/issue1017)
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue945">CWG 945</a>: Use of <code>this</code> in a late-specified return type</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1017">CWG 1017</a>: Member access transformation in unevaluated operands (see also <a href="http://wg21.cmeerw.net/cwg/issue1005">CWG 1005</a>; note <a href="http://wg21.cmeerw.net/cwg/issue1005">CWG 515</a> is still effective)</li>
<li><a href="http://wg21.cmeerw.net/cwg/issue1207">CWG 1207</a>: Type of class member in <code>trailing-return-type</code> (see also <a href="http://wg21.cmeerw.net/cwg/issue945">CWG 945</a>)
<ul>
<li>BLOCKED by <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=52869">GCC PR 52869 (NEW)</a>, even though Clang++ works</li>
</ul>
</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3664.html">N3664</a>: Clarifying Memory Allocation (adopted 2013-04)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3843.pdf">N3843</a>: A SFINAE-Friendly <code>std::common_type</code></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4081.html">N4081</a>: Working Draft, C++ Extensions for Library Fundamentals (see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html">N4480</a>)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4279.html">N4279</a>: Improved insertion interface for unique-key maps (Revision 2.3) (adopted 2014-11)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4510.html">N4510</a>: Minimal incomplete type support for standard containers, revision 4 (adopted 2015-05; however, <strong>similar requirements for associative containers (not proposed yet) were required when replacments were not used</strong>, see <a href="Development.zh-CN.html">here (zh-CN)</a>)
<ul>
<li>partially replaced by <code>ystdex::map</code></li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0083r3.pdf">P0083R3</a>: Splicing Maps and Sets (Revision 5)
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue839">LWG 839</a>: Maps and sets missing splice operation</li>
<li><a href="https://wg21.cmeerw.net/lwg/issue1041">LWG 1041</a>: Add associative/unordered container functions that allow to extract elements</li>
<li>partially replaced by <code>ystdex::map</code></li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0136r1.html">P0136R1</a>: Rewording inheriting constructors (<a href="https://wg21.cmeerw.net/cwg/issue1941">core issue 1941</a> et al) (adopted 2015-10)
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue1573">CWG 1573</a>: Inherited constructor characteristics</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1645">CWG 1645</a>: Identical inheriting constructors via default arguments</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1715">CWG 1715</a>: Access and inherited constructor templates</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1736">CWG 1736</a>: Inheriting constructor templates in a local class</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1903">CWG 1903</a>: What declarations are introduced by a non-member <code>using-declaration</code>?</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1941">CWG 1941</a>: SFINAE and inherited constructor default arguments</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1959">CWG 1959</a>: Inadvertently inherited copy constructor</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1991">CWG 1991</a>: Inheriting constructors vs default arguments</li>
</ul>
</li>
<li>following resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0165r3.html">P0165R3</a>: C++ Standard Library Issues to be moved in Issaquah (adopted 2016-10)
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2062">LWG 2062</a>: Effect contradictions w/o no-throw guarantee of <code>std::function</code> swaps
<ul>
<li>replaced by <code>ystdex::function</code> since (revised b848[2018-12-24])</li>
</ul>
</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0409r2.html">P0409R2</a>: Allow lambda capture <code>[=, this]</code> (adopted 2017-07)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0458r2.html">P0458R2</a>: Checking for Existence of an Element in Associative Containers (adopted 2018-06)
<ul>
<li>partially replaced by <code>ystdex::map</code></li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0588r1.html">P0588R1</a>: Simplifying implicit lambda capture (adopted 2017-11)
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue1913">CWG 1913</a>: <code>decltype((x))</code> in <code>lambda-expression</code>s</li>
<li><a href="https://wg21.cmeerw.net/cwg/issue1632">CWG 1632</a>: Lambda capture in member initializers</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0600r1.pdf">P0600R1</a>: <code>[[nodiscard]]</code> in the Library, Rev1 (adopted 2017-11)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0616r0.pdf">P0616R0</a>: de-pessimize legacy <code>&lt;numeric&gt;</code> algorithms with <code>std::move</code> (adopted 2017-11)
<ul>
<li><a href="https://wg21.cmeerw.net/lwg/issue2055">LWG 2055</a>: <code>std::move</code> in <code>std::accumulate</code> and other algorithms</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0641r2.html">P0641R2</a>: Resolving Core Issue #1331 (<code>const</code> mismatch with defaulted copy constructor) (adopted 2017-11)
<ul>
<li><a href="https://wg21.cmeerw.net/cwg/issue1331">CWG 1331</a>: <code>const</code> mismatch with defaulted copy constructor
<ul>
<li>see also <a href="https://wg21.cmeerw.net/cwg/issue1426">CWG 1426</a>: Allowing additional parameter types in defaulted functions</li>
</ul>
</li>
</ul>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0935r0.html">P0935R0</a>: Eradicating unnecessarily explicit default constructors from the standard library (adopted 2018-06)</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1227r2.html">P1227R2</a>: Signed <code>ssize()</code> functions, unsigned <code>size()</code> functions (Revision 2) (adopted 2019-03)</li>
</ul>
<h3 id="avoided"><a class="header" href="#avoided">Avoided</a></h3>
<p>These already adopted (by the standard or the working paper) post-C++11 resolutions (which may need no modification on a previous conforming C++ implementation) are <strong>not</strong> depended on <strong>currently</strong> (revised b803[2017-09-08]) but confirmed still being compatible, and also <strong>would not be relied on in future</strong> based on the fact of reducing expresiveness in the language and lacking of portable extensions to prevent underming of code quality based on current status:</p>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r3.pdf">P0145R3</a>: Refining Expression Evaluation Order for Idiomatic C++ (adopted 2016-06)</li>
</ul>
<h1 id="list-of-reported-issues"><a class="header" href="#list-of-reported-issues">List of reported issues</a></h1>
<p>There are some issues related reported, or originally found and forwarded by author of this project. Some issues are related to the to language or enviornment specifications. See <a href="ReportedIssues.en-US.html">reported issues</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h1>
<p>There are some issues related reported, or originally found and forwarded by author of this project. Some issues might block the project in some sense. To review them conveniently, reported issues are collect in this document.</p>
<p>Unless otherwise specified, notations are same to those in <a href="StandardUsing.en-US.html">StandardUsing</a>.</p>
<h1 id="list-of-reported-issues-1"><a class="header" href="#list-of-reported-issues-1">List of reported issues</a></h1>
<p>Issues not rejected or withdrawn are collected and listed here (revised b840[2018-10-07]).</p>
<h2 id="specifications"><a class="header" href="#specifications">Specifications</a></h2>
<p>Some issues are related to the to language or enviornment specifications.</p>
<p>The entries may duplicate with above.</p>
<h3 id="isoiec-14882-isoiec-jtc1-sc22wg21-issue-list"><a class="header" href="#isoiec-14882-isoiec-jtc1-sc22wg21-issue-list">ISO/IEC 14882 (ISO/IEC JTC1 SC22/WG21 issue list)</a></h3>
<ul>
<li><a href="http://wg21.cmeerw.net/cwg/issue1949">CWG 1949</a>: “sequenced after” instead of “sequenced before” (resolved at <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4567.pdf">N4567</a>, see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4566.html">N4566</a>)
<ul>
<li>Issue delegated in <a href="https://github.com/cplusplus/draft/issues/61">GitHub issue 61</a>.</li>
</ul>
</li>
<li><a href="http://wg21.cmeerw.net/lwg/issue2240">LWG 2240</a>: Probable misuse of term &quot;function scope&quot; in [thread.condition] (resolved)
<ul>
<li>Original thread posted in <a href="https://groups.google.com/a/isocpp.org/forum/#!topic/std-discussion/JpQVT-pwP9E">std-discussion</a>.</li>
<li>Issue delegated in <a href="https://github.com/cplusplus/draft/issues/57">GitHub issue 57</a>.</li>
</ul>
</li>
</ul>
<h2 id="implementations-of-standards-or-specifications"><a class="header" href="#implementations-of-standards-or-specifications">Implementations of standards or specifications</a></h2>
<p>Some issues are related to the to implementations of language or enviornment specifications.</p>
<h3 id="gnu-c-bugzilla"><a class="header" href="#gnu-c-bugzilla">GNU C++ (<a href="https://gcc.gnu.org/bugzilla/">Bugzilla</a>)</a></h3>
<ul>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53872">PR 53872</a>: [C++11] ADL bug in <code>std::thread</code> (RESOLVED FIXED 4.7.2)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53873">PR 53873</a>: [C++11] strange error message for template overloading (RESOLVED DUPLICATE of <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53862">bug 53862</a>)
<ul>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53862">PR 53862</a>[4.6/4.7 regression] [C++11] sorry, unimplemented: use of 'type_pack_expansion' in template (RESOLVED FIXED 4.7.1)</li>
</ul>
</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=54216">PR 54216</a>: Missing diagnostic for ill-formed anonymous enum declarations (RESOLVED FIXED 4.9.0)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=55053">PR 55053</a>: <code>std::is_explicitly_convertible</code> should be removed (RESOLVED WORKSFORME 4.8.0)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=56699">PR 56699</a>: [4.8/4.9 regression] Failed for sizeof (non-static member) in lambda expression (RESOLVED FIXED mainline/4.8.1)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57183">PR 57183</a>: [C++11] <code>auto</code> and -Wunused-variable (RESOLVED FIXED 4.8.1)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57444">PR 57444</a>: [4.8/4.9 Regression] ICE in instantiate_type for invalid use of member with <em>using-declaration</em> (RESOLVED DUPLICATE of <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58457">bug 58457</a>)
<ul>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58457">PR 58457</a>: [4.8/4.9 Regression] ICE when placement <code>new</code> operator is used with using keyword and custom constructor (RESOLVED FIXED 4.8.2/4.9.0)</li>
</ul>
</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58395">PR 58395</a>: Undefined behavior vs. exception (RESOLVED WONTFIX)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=59682">PR 59682</a>: Invalid syntax accepted: new-placement without <em>expression-list</em> (RESOLVED FIXED 6.0)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=59931">PR 59931</a>: Wrong wording of diagnostic about imaginary &quot;member function type&quot;</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=60709">PR 60709</a>: [C++11]ICE when using a <em>braced-init-list</em> as function argument to initialize a reference to array (RESOLVED FIXED 4.8.3)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61019">PR 61019</a>: ICE: incomplete type of class template as <em>pseudo-destructor-name</em> (RESOLVED FIXED 6.0)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63400">PR 63400</a>: [C++11]precision of <code>std::chrono::high_resolution_clock</code> (UNCONFIRMED)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65343">PR 65343</a>: unexpected exception thrown during destruction of static object in debug mode
<ul>
<li>Since some version of Windows 10, the crash dialog would not show, made it less annoying.</li>
</ul>
</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65748">PR 65748</a>: [C++11][C++14]Invalid copy elision on operand of <em>throw-exception</em> (RESOLVED DUPLICATE of <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57533">bug 57533</a>)
<ul>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57533">PR 57533</a>: When throwing local variable, it's being move-constructed even if not going out of scope. (NEW)</li>
<li>This misfeature is carefully avoided in YSLib source.</li>
</ul>
</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65890">PR 65890</a>: [C++03]<code>sizeof(qualified-id)</code> accepted when the operand denotes a non-static member (RESOLVED INVALID)
<ul>
<li>This does not effect YSLib since C++11 is the baseline.</li>
</ul>
</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67238">PR 67238</a>: [C++11][C++14]cc1plus crash for nested <code>decltype</code> expression in parameter pack in trailing return type when '-g' enabled (RESOLVED FIXED 6.0)
<ul>
<li>This was worked arounded in YSLib source, before 6.0 is actually depended on.</li>
</ul>
</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67795">PR 67795</a>: Wrong code generated for conditional expression with cast (NEW)
<ul>
<li>This still blocks some code.</li>
</ul>
</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=70480">PR 70480</a>: Reduce RTTI code bloat for specified types (NEW)
<ul>
<li>For DS platform, YSLib uses <code>ystdex::type_id</code> instead <code>typeid</code> to worked around.</li>
</ul>
</li>
<li><a href="https://bitbucket.org/FrankHB/yslib/issues/30/b699-mingw32-some-error-constants">YSLib issue 30</a> 
<ul>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=71444">PR 71444</a>: Error constants for MinGW-w64 (RESOLVED FIXED 5.5, 6.4 and 7.1)</li>
<li>This was worked around in YSLib source and fixed since G++ 7.1.</li>
</ul>
</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86734">PR 86734</a>: [DR 2188] <code>reverse_iterator::operator-&gt;</code> does not support overloaded <code>operator&amp;</code> (RESOLVED FIXED 7.4 8.3)
<ul>
<li>See upstream <a href="https://wg21.cmeerw.net/lwg/issue2188">LWG 2188</a>.</li>
<li>This is conditionally avoided by replacement <code>ystdex::reverse_iterator</code>.</li>
</ul>
</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=90966">PR 90966</a>: [9/10 Regression] ICE in tsubst_copy, at cp/pt.c:16155 (RESOLVED FIXED 9.3 and 10)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=91127">PR 91127</a>: Incorrect checking of nonnull attribute with argument to a constructor of class with a virtual base (NEW)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=91480">PR 91480</a>: Nonconforming definitions of standard library feature-test macros (NEW)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=91531">PR 91531</a>: <code>_Rb_tree</code>'s copy assignment should respect to POCCA regardless of <code>is_always_equal</code> (NEW)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=91541">PR 91541</a>: [C++17] Exception specification of <code>operator=</code> of node-based containers may be broken (RESOLVED WONTFIX)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=91620">PR 91620</a>: <code>std::[forward_]list::remove_if/unique</code> should respect to <a href="https://wg21.cmeerw.net/lwg/issue526">DR 526</a> (ASSIGNED)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=93470">PR 93470</a>: [C++2a] [9 Regression] [C++2a] <code>std::reference_wrapper</code> to function type is broken with Clang (RESOLVED FIXED 9.3)</li>
<li><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=94602">PR 94602</a>: wrong semantic check to prvalue as decltype operand (UNCONFIRMED)</li>
</ul>
<h3 id="llvmclang-bugzilla"><a class="header" href="#llvmclang-bugzilla">LLVM/Clang (<a href="https://llvm.org/bugs/">Bugzilla</a>)</a></h3>
<ul>
<li><a href="https://llvm.org/bugs/show_bug.cgi?id=25306">PR 25306</a>: <code>__attribute__((returns_nonnull))</code> does not work for <code>std::add_pointer_t&lt;T&gt;</code> (NEW)</li>
<li><a href="https://llvm.org/bugs/show_bug.cgi?id=27504">PR 27504</a>: Inherited constructor with dependent base class introduced by a <em>typedef-name</em> may not work (NEW)</li>
<li><a href="https://llvm.org/bugs/show_bug.cgi?id=27443">PR 27443</a>: [CWG 734] Nonconforming aliasing of block scope objects (RESOLVED DUPLICATE of <a href="https://llvm.org/bugs/show_bug.cgi?id=18538">bug 18538</a>)
<ul>
<li><a href="https://llvm.org/bugs/show_bug.cgi?id=18538">PR 18538</a>: non-conforming optimization <code>-fmerge-all-constants</code> is enabled by default</li>
<li>Note they are not identical. PR 27443 is for ISO C++ and PR 18538 is for ISO C.</li>
</ul>
</li>
<li><a href="https://bugs.llvm.org/show_bug.cgi?id=43275">PR 43275</a>: Pure attribute and C++ exceptions (NEW)</li>
<li><a href="https://bugs.llvm.org/show_bug.cgi?id=45542">PR 45542</a>: wrong semantic check to prvalue as decltype operand (NEW)</li>
</ul>
<h3 id="microsoft-visual-c"><a class="header" href="#microsoft-visual-c">Microsoft Visual C++</a></h3>
<p>New issues are now reported to <a href="https://developercommunity.visualstudio.com/">Microsoft Visual Studio Developer Community</a>.</p>
<p>As [Microsoft Connect](<a href="https://connect.microsoft.com/">Microsoft Connect</a>) is down now, any status would not be updated. Note some posts have been inaccessible even before the service stopped.</p>
<ul>
<li><a href="https://connect.microsoft.com/VisualStudio/feedback/details/1641428">Microsoft Connect issue 1641428</a>: Wrong Win32 error to <code>errno</code> mapping (ACTIVE)
<ul>
<li>YSLib code does not rely on Universal source, instead implements the functionality spearatedly, so it has no effect.</li>
<li>This seems to be fixed before Microsoft Connect closed.</li>
</ul>
</li>
<li><a href="https://bitbucket.org/FrankHB/yslib/issues/33">YSLib issue 33</a>
<ul>
<li><a href="https://connect.microsoft.com/VisualStudio/feedback/details/2913382">Microsoft Connect issue 2913382</a>: Parameter parsing bug (ACTIVE)</li>
<li><a href="https://developercommunity.visualstudio.com/content/problem/431539/vc-cannot-parse-function-pointer-parameter-with-de.html">problem 431539</a>: VC++ cannot parse function pointer parameter with default argument '{}' (Under Consideration)</li>
</ul>
</li>
<li><a href="https://bitbucket.org/FrankHB/yslib/issues/34">YSLib issue 34</a>: [Win32] std::unique_ptr::operator-&gt; not conforming in Microsoft VC++ 2015
<ul>
<li><a href="https://connect.microsoft.com/VisualStudio/feedback/details/2918170">Microsoft Connect issue 2918170</a>: <code>std::unique_ptr::operator-&gt;</code> not conforming (FIXED accroding to <a href="https://blogs.msdn.microsoft.com/vcblog/2016/10/11/c1417-features-and-stl-fixes-in-vs-15-preview-5/">here</a>)</li>
</ul>
</li>
<li><a href="https://developercommunity.visualstudio.com/content/problem/417142/lwg-2070p0674r1-stdallocate-shared-is-not-conformi.html">problem 417142</a>: [LWG 2070][P0674R1] <code>std::allocate_shared</code> is not conforming (Under Investigation)</li>
<li><a href="https://bitbucket.org/FrankHB/yslib/issues/35">YSLib issue 35</a>: [Win32] Microsoft VC++ 2017 failed to evaluate the dependent noexcept expression inside noexcept-specifier
<ul>
<li><a href="https://developercommunity.visualstudio.com/content/problem/431598/vc-fails-to-compile-the-noexcept-expression-inside.html">problem 431598</a>: VC++ fails to compile the noexcept expression inside noexcept-specifier with a template-parameter instantiated from an explicit destruct call (Closed - Fixed)(Fixed In: Visual Studio 2019 version 16.1)(Fixed In: Visual Studio 2019 version 16.1 Preview 1)</li>
</ul>
</li>
<li><a href="https://bitbucket.org/FrankHB/yslib/issues/36">YSLib issue 36</a>: [Win32] Microsoft VC++ 2017 failed to initialize with string arrays with a constexpr u8 string literal
<ul>
<li><a href="https://developercommunity.visualstudio.com/content/problem/431628/vc-fails-to-initialize-with-string-arrays-with-a-c.html">problem 431628</a>: VC++ fails to initialize with string arrays with a constexpr u8 string literal (Closed - Fixed)(Fixed In: Visual Studio 2019 version 16.0)(Fixed In: Visual Studio 2019 version 16.0 Preview 5)</li>
</ul>
</li>
<li><a href="https://bitbucket.org/FrankHB/yslib/issues/37">YSLib issue 37</a>: [Win32] Microsoft VC++ 2017 internal compiler error when building SHBuild
<ul>
<li><a href="https://developercommunity.visualstudio.com/content/problem/431665/vc-2017-internal-error-for-overloaded-qualified-fu.html">problem 431665</a>: VC++ 2017 internal error for overloaded qualified function template function call in the function default argument (Closed - Fixed)(Fixed In: Visual Studio 2019 version 16.1)(Fixed In: Visual Studio 2019 version 16.0)</li>
</ul>
</li>
<li><a href="https://bitbucket.org/FrankHB/yslib/issues/38">YSLib issue 38</a>: [Win32] Microsoft VC++ 2017 failed to select expected std::swap specialization
<ul>
<li><a href="https://developercommunity.visualstudio.com/content/problem/431904/vc-2017-stdswap-is-not-conforming.html">problem 431904</a> (Closed - Fixed)(Fixed In: Visual Studio 2019 version 16.1)(Fixed In: Visual Studio 2019 version 16.1 Preview 2)(Fixed In: Visual Studio 2019 version 16.1 Preview 1)</li>
</ul>
</li>
<li><a href="https://bitbucket.org/FrankHB/yslib/issues/39">YSLib issue 39</a>: [Win32] Microsoft VC++ 2017 rejects dependent noexcept-specifier in template partial specializations 
<ul>
<li><a href="https://developercommunity.visualstudio.com/content/problem/441268/vc-2017-rejects-dependent-noexcept-specifier-in-te.html">problem 441268</a> (Under Consideration)</li>
</ul>
</li>
</ul>
<h2 id="other-projects"><a class="header" href="#other-projects">Other projects</a></h2>
<p>As complement, some issues are related to other tools used by the project or referenced in documentation of this project, which may loosely concern with issues listed above.</p>
<h3 id="drmemory"><a class="header" href="#drmemory">DrMemory</a></h3>
<ul>
<li><a href="https://github.com/DynamoRIO/drmemory/issues/1826">issue 1826</a>: Crash in Win10 TH2 (Closed <a href="https://github.com/DynamoRIO/drmemory/commit/446007ec2c76fbab9220850b38aac48c538eee18">FIXED</a>)</li>
</ul>
<h3 id="devkitpro"><a class="header" href="#devkitpro">devkitPro</a></h3>
<h4 id="libfat"><a class="header" href="#libfat">libfat</a></h4>
<ul>
<li><a href="https://github.com/devkitPro/libfat/pull/1">pull request 1</a>: Removed redundant check (Merged)</li>
<li><a href="https://github.com/devkitPro/libfat/issues/2">issue 2</a>: Wrong root sectors count determined for FAT12 and FAT16? (Open)</li>
<li><a href="https://github.com/devkitPro/libfat/issues/3">issue 3</a>: Redundant function calls (Open)</li>
<li><a href="https://github.com/devkitPro/libfat/issues/4">issue 4</a>: <code>_FAT_directory_entryFromPosition</code> issues (Open)</li>
<li><a href="https://github.com/devkitPro/libfat/issues/5">issue 5</a>: Redundant call of <code>_FAT_directory_getRootEntry</code> for &quot;<code>/</code>&quot; (Open)</li>
<li><a href="https://github.com/devkitPro/libfat/issues/6">issue 6</a>: <code>ENOTDIR</code> vs <code>ENOENT</code> for invalid path prefix (Open)</li>
<li><a href="https://github.com/devkitPro/libfat/issues/7">issue 7</a>: Pathname with or without trailing slashes for directories (Open)</li>
<li><a href="https://github.com/devkitPro/libfat/issues/10">issue 10</a>: Setting <code>errno</code> when removing a non-empty directory (Open)</li>
</ul>
<h4 id="libnds"><a class="header" href="#libnds">libnds</a></h4>
<ul>
<li><a href="https://github.com/devkitPro/libnds/issues/3">issue 3</a>: Compiler warnings (Closed)</li>
<li><a href="https://github.com/devkitPro/libnds/issues/4">issue 4</a>: About <code>std::chrono</code> clocks (Closed)</li>
<li><a href="https://github.com/devkitPro/libnds/pull/30">pull request 30</a>: Removed redundant code. (Merged)</li>
<li><a href="https://github.com/devkitPro/libnds/pull/33">pull request 33</a>: Fixed redundant qualifier (Merged)</li>
</ul>
<h4 id="newlib"><a class="header" href="#newlib">newlib</a></h4>
<ul>
<li><a href="https://github.com/devkitPro/newlib/issues/5">issue 5</a>: Nonconforming return type of <code>ftell</code> (Closed FIXED)</li>
</ul>
<h3 id="klisp"><a class="header" href="#klisp">Klisp</a></h3>
<ul>
<li><a href="https://bitbucket.org/AndresNavarro/klisp/issues/12/a-problem-of-proper-tail-call">issue 12</a>: A problem of proper tail call (NEW)</li>
</ul>
<h1 id="resolved-implementation-issues"><a class="header" href="#resolved-implementation-issues">Resolved implementation issues</a></h1>
<p>Some issues were tagged BLOCKED status previously. Issues known resolved and confirmed to work would be put in this chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general"><a class="header" href="#general">General</a></h1>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>This document describes a set of rules for creating and maintaining documentations or some other kinds of materials, which is not project-specific. This document is also self-conforming to these rules.</p>
<h2 id="notation-1"><a class="header" href="#notation-1">Notation</a></h2>
<p>Specific formats may be used. The visual output may depend on the method of rendering.</p>
<p>Texts intended to be handled differently (for example, portions of program source code) may be in <code>some specific format</code>. Other texts are considered normal.</p>
<p><a href="https://en.wikipedia.org/wiki/Hyperlink">Hyperlinks</a> may be used in normal texts pointing to external references, local pages, or anchors in specific documents.</p>
<p>Normal text empasized in general are in <strong>the specific format</strong>, usually (visually) bold.</p>
<p>Local terms in the normal text are emphasized at first appearence in <em>the specific format</em>, usually (visually) italic.</p>
<p>For terms used globally in this document and any other derivations, see below.</p>
<h2 id="terms-and-definitions"><a class="header" href="#terms-and-definitions">Terms and definitions</a></h2>
<h3 id="resources"><a class="header" href="#resources">Resources</a></h3>
<p>Contents of materials are split as <em>resources</em> (e.g. <a href="http://en.wikipedia.org/wiki/Computer_file"><em>files</em></a>) in possibly nested <em>namespaces</em> (e.g. <a href="http://en.wikipedia.org/wiki/Directory_%28computing%29"><em>directories</em></a>). A namespace is also considered as a resource for convenience.</p>
<h3 id="paths-and-identifiers"><a class="header" href="#paths-and-identifiers">Paths and identifiers</a></h3>
<p>A <em>path</em> is used to identifying or locating a resource, which can be in various forms (e.g. filesystem <a href="http://en.wikipedia.org/wiki/Path_%28computing%29"><em>path</em></a> or <a href="http://en.wikipedia.org/wiki/Uniform_resource_locator"><em>URL</em></a>).</p>
<p>A path may have several <em>components</em> denoting different <em>levels</em> of namespace or the last level non-namespace resource.</p>
<p>An <em>empty path</em> is a path without any components.</p>
<p>A path with more than one components shall have syntactic <em>separators</em> (e.g. a slash(<code>/</code>) or whitespace) to split different components.</p>
<p>An <em>identifier</em> is a path with exactly one components without any separators, which can be used to differentiate resources in the same namespace or to collectively name some sets of resources in various namespaces.</p>
<p>A resource may be denoted with not necessarily the unique identifier or path. However, all resources this document discussed below are named.</p>
<h2 id="languages"><a class="header" href="#languages">Languages</a></h2>
<p>Rules of natural languages are specified in this subclause. They have effects on normal texts.</p>
<p>Normal text of noun phrases may have embedded translations for different natural languages or more detailed descriptions following its first occurence, in parentheses (<code>(</code> and <code>)</code>).</p>
<p>Different <a href="https://en.wikipedia.org/wiki/Letter_case">letter cases</a> (if appropriate) may be used for sentences, acronyms and words in the titles of clauses.</p>
<h3 id="editions-in-languages"><a class="header" href="#editions-in-languages">Editions in languages</a></h3>
<p>A set of documentation may be in one (natural) language. The <a href="http://en.wikipedia.org/wiki/IETF_language_tag">IETF language tag</a> with at least one subtag and an additional prefix dot(<code>.</code>) shall be placed in the end of identifier of the resource before the dot and the extension name (if any). Otherwise the documentation shall be in multiple languages or without text contents (e.g. containing only ideographic images), and no language code shall be in the identifier of the resource.</p>
<p>When the additional dot and tag is removed, all different resource with same names shall refer to the same set of contents only in different languages, or at least one of them shall be <em>incomplete</em> which means to be <em>completed</em> as in former case. The resource is one <em>edition</em> in the specific language of the documentation.</p>
<p>Unless explicitly specified, when the meaning is in conflict for multiple editions in different languages, the complete one shall be valid over others. If there is not only one complete edition, the validity is specified in following order:</p>
<ul>
<li><code>en-US</code></li>
<li><code>en</code></li>
<li><code>zh-CN</code></li>
<li><code>zh</code></li>
</ul>
<p><strong>NOTE</strong> The form of these literals conforms to the recommendation of <a href="https://en.wikipedia.org/wiki/IETF_language_tag">IETF language tag</a>, specifically, the &quot;language&quot; and &quot;region&quot; syntax elements in <a href="https://www.rfc-editor.org/rfc/rfc5646.html">RFC 5646</a>.</p>
<p>If no one edition in above languages is complete, the documentation is defective.</p>
<p>A language tag may be used to annotate one or more words in text. An annotation of such use is a <em>language tag annotation</em>, which consists of a tag combined with one pair of enclosing parentheses (namely, <code>(</code> and <code>)</code>).</p>
<p>Hyperlinks in pages should preferrably link to localized contents corresponding to the language or one of the major languages used in the page (if any) when suitable. If contents of the linked target is in other languages (esp. when there are more than one semantically identical editions in multiple languages), at least one language tag for majority of the contents should be noted subsequent to the hyperlink; otherwise, the tag should be omitted.</p>
<p>For compatibility of client programs, each link of <a href="https://en.wikipedia.org/wiki/URI">URI</a> should be encoded in form of normalized <a href="https://tools.ietf.org/html/rfc3986#section-2.1">Percent-Encoding in RFC 3986</a>.</p>
<p>Additionally, several hyperlinks are normalized with the same form for a specific language. Currently the rule consists of following cases:</p>
<ul>
<li>For <a href="https://zh.wikipedia.org/zh-cn">Chinese Wikipedia(zh-CN)</a>, the link shall following the rule in <a href="https://zh.wikipedia.org/zh-cn/Help:%E4%B8%AD%E6%96%87%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%E7%9A%84%E7%B9%81%E7%AE%80%E3%80%81%E5%9C%B0%E5%8C%BA%E8%AF%8D%E5%A4%84%E7%90%86">the section in the language conversion help page(zh-CN)</a>, with small letter &quot;cn&quot; in the link.</li>
</ul>
<h3 id="in-english"><a class="header" href="#in-english">In English</a></h3>
<p>Stylistic usage of letter cases shall be respected in the following precedence:</p>
<ol>
<li>All uppercase should not be used normally.</li>
<li>Acronyms and other proper noun (pharses) shall be in the appropriate styles.</li>
<li>The title case style shall be used for page or document titles.</li>
<li>Either the title case or the sentence case shall be used in the titles in a page. This shall be consistent within a document.</li>
<li>Either the title case or the sentence case shall be used in the detailed descriptions for acronyms in parentheses. This may vary in the same page.</li>
<li>Detailed descriptions for acronyms in parentheses may use title case or sentence case.</li>
<li>All lowercase style shall be used for words in the embedded translations or detailed descriptions in parentheses in other cases.</li>
<li>Sentence case should be used otherwise.</li>
</ol>
<p>English wording documentation is intended to be conforming to <a href="http://std.dkuug.dk/jtc1/sc22/wg9/isodir3.pdf">the ISO/IEC directive, part 3</a>.</p>
<p><strong>NOTE</strong> The use of modal verbs is distinct with <a href="http://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a>.</p>
<p>For wording referenced from RFC documents, RFC 2119 is preferred, but not necessary with the case clarification (i.e. <a href="https://tools.ietf.org/html/rfc8174">RFC 8174</a>) for documents published earlier than RFC 8174 due to compatibility issues.</p>
<p>The following grammartical forms of English (with <code>en</code> or <code>en-US</code> tags) are considered idiomatic and application of such forms may be preferred:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Answer_ellipsis">answer ellipsis</a> to elide the subject in the summary of commit messages where a question for the topic of the log message is assumed</li>
<li><a href="http://en.wikipedia.org/wiki/English_passive_voice#Additional_passive_constructions">bare passive clause</a> omitting the auxiliary verb for short descriptive notes (e.g. commit messages in repositories and assertions messages in programs)</li>
<li><a href="https://en.wikipedia.org/wiki/Null-subject_language#The_imperative_form">null subject</a> and <a href="https://en.wikipedia.org/wiki/Pro-drop_language#English">pronoun dropping</a> in imperative forms</li>
<li><a href="https://en.wikipedia.org/wiki/Zero-marking_in_English#Zero_article">zero article</a> for singular form of a countable noun denoting a specialized term being referenced, usually used in a terse-style title or in a list term (like this line)</li>
</ul>
<p><strong>Informative notes:</strong> The tense and mood used in the logs in version control systems are <a href="https://stackoverflow.com/questions/3580013/should-i-use-past-or-present-tense-in-git-commit-messages">opinion-based</a>. However, the implied rules are choosed here to avoid imperative forms by default, because:</p>
<ul>
<li>First, it should be respected same in all information processing system: to make sure who are the messages in the logs serve to.
<ul>
<li>Version control systems are capable for reading and writing operations on the version history, with asymmetric operational frequency in general.
<ul>
<li>For most stakeholders to a repository in most cases, read-only accesses of the version history are more frequent compared to changing opertions.</li>
<li>This is also consistent with the idiom pattern used in programming: do not abuse imperative updates with side effects.</li>
</ul>
</li>
<li>For most users, commit logs are <a href="https://stackoverflow.com/a/8059167/2307646">entries of journal</a> of the version history.
<ul>
<li>They do not and should not care about imperative changes in the logical perspective.</li>
</ul>
</li>
</ul>
</li>
<li>Unconstrained changes in the version history as effectful operations can make messes easily.
<ul>
<li>They are usually only well-behaved enough within some local context (e.g. in a single branch of a reliable instance of the version history).</li>
<li>They often make troubles in other cases (e.g. when stripped as patches possibly reordered).</li>
</ul>
</li>
<li>Messages in the logs may be cooperated with other instances of version history.
<ul>
<li>No imperative mood can essentially assume the changes described will always be applied in the exactly same way.</li>
<li>As mentioned above, out-of-order changes make messes. If the messages are precise, they also make messes like other changed contents.</li>
</ul>
</li>
<li>In general, messages in the logs work for distributed repositories.
<ul>
<li>There is simply no standpoint for the global view of the universe of the version history by default.</li>
<li>Messages should be ready to be audited by random accesses, besides being applied subsequently in some replays.</li>
<li>These facts further undermines the necessity of imperative changes.</li>
</ul>
</li>
</ul>
<h1 id="format-specific-rules"><a class="header" href="#format-specific-rules">Format-specific rules</a></h1>
<h2 id="text-files"><a class="header" href="#text-files">Text files</a></h2>
<p>Unless otherwise specified, all text files should be encoded as UTF-8 with <a href="http://en.wikipedia.org/wiki/Byte_order_mark">BOM</a> enabled.</p>
<p>Any use of encoding which may not be converted verbatim and losslessly in binary form to UTF-8 shall be explicit specified in documantation.</p>
<p>BOM should be omitted for text files dedicated to tools without capability of properly handling it. Otherwise, BOM shall be used as possible when it can clarify the encoding being used.</p>
<p>Unless definitely intended and explictly specified in documentation, newlines shall be consistent. Default use of newline is <a href="http://en.wikipedia.org/wiki/CRLF">CR+LF</a>.</p>
<p>Two subsequent newlines indicate an <a href="http://en.wikipedia.org/wiki/End-of-file">EOF</a> logically. Subsequent newlines out of verbatim quoted text (including source code) should only be used at EOF.</p>
<p>There are also some default rules on typography implemented by ordinary characters in plain texts:</p>
<ul>
<li>No <a href="http://en.wikipedia.org/wiki/Space_characters#Spaces_in_Unicode">space characters</a> should be at <a href="http://en.wikipedia.org/wiki/End-of-line">EOL</a>.</li>
<li>For text other than verbatim quoted, no more than one <a href="https://en.wikipedia.org/wiki/Whitespace_character">whitespace characters</a> should be used to represent a single indent, except there are preferred combination in the language.
<ul>
<li><strong>Rationale</strong> By default, no more than one whitespaces should be used to represent an indent, because there should be no chance to insert a character in the middle of an indent.</li>
<li><strong>NOTE</strong> An example of preferred exceptional case is that the hanging indent (in the first line of a paragraph) in east Asian languages where dedicated combination of <a href="https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms">fullwidth</a> whitespaces are preferred. Typically, the sequence consists of 2 <a href="https://en.wikipedia.org/wiki/Whitespace_character#Unicode">ideographic space (U+3000)</a>.</li>
<li><strong>NOTE</strong> To keep the semantics rules clear, when possible (in horizontal texts and out of the context of making tables) and no other forms are more preferred by the rules of the language, use <a href="http://en.wikipedia.org/wiki/Tab_key#Tab_characters">horizontal tab character(U+0009)</a> instead of <a href="http://en.wikipedia.org/wiki/Space_%28punctuation%29">other spaces (i.e. U+0020)</a> to indent.</li>
</ul>
</li>
<li>For Western languages, except at the first of line, each word which consists of <a href="http://en.wikipedia.org/wiki/Alphanumeric">alphanumeric</a> characters should be seperated by a single space character (U+0020) with other words.</li>
<li>Space characters (U+0020) should be used for alignment when portability is required.
<ul>
<li><strong>Rationale</strong> This makes the visal effect easy to predicate in the usual settings with monospaced fonts in contexts like source code of programs.</li>
<li><strong>NOTE</strong> Other spaces like <a href="https://en.wikipedia.org/wiki/Non-breaking_space">non-breaking space (U+00A0)</a> may be better in specific uses, but not portable as U+0020.</li>
</ul>
</li>
</ul>
<h2 id="markdown"><a class="header" href="#markdown"><a href="http://en.wikipedia.org/wiki/Markdown">Markdown</a></a></h2>
<p>Names of markdown files should be with <code>.md</code> extension.</p>
<h3 id="dialects"><a class="header" href="#dialects">Dialects</a></h3>
<p>Unless explicitly specified elsewhere, only common dialects are to be used. Currently this should be <a href="https://help.github.com/articles/github-flavored-markdown">GFM (GitHub Flavored Markdown)</a>.</p>
<p><strong>NOTE</strong> This is not <a href="https://docs.gitlab.com/ee/user/markdown.html">GLFM (GitLab Flavored Markdown)</a>, which also abbreviated as GFM formerly.</p>
<p>And if the content may be presented on <a href="https://bitbucket.org">Bitbucket</a> wiki, stricter rules applies, notably:</p>
<ul>
<li>There is currently <a href="https://jira.atlassian.com/browse/BCLOUD-6930">no inline HTML support</a>.</li>
<li>There is currently <a href="https://jira.atlassian.com/browse/BCLOUD-8276">no anchor support</a>.</li>
</ul>
<p><strong>NOTE</strong> This repository is not intended deployed in Bitbucket wiki now. The stricter rules on Bitbucket wiki above are not applicable here.</p>
<h3 id="syntactic-restrictions"><a class="header" href="#syntactic-restrictions">Syntactic restrictions</a></h3>
<p>As text files, markdown files shall obey the same rules above. The indentation rule is necessary to avoid some compatibility issues, e.g. <a href="https://bitbucket.org/site/master/issue/7748/markdown-nested-lists-not-working-bb-8925">this</a>.</p>
<p>As specified, reserved characters defined by RFC 3986 should be percentage-encoded. Notably, the parentheses(<code>()</code>) in hyperlinks shall be encoded to make it more fault-tolerent for some editors.</p>
<p>Headers should be prefixed by <code>#</code>s.</p>
<p>There should be no redundant characters allowed between the annotated words and annotation (esp. whitespace characters), even there are whitespaces in the words. The annotation in this rule includes any language tag annotation defined in previous subclause.</p>
<p><strong>Rational</strong> This is for the sake of compact annotation representations.</p>
<p><strong>NOTE</strong> The whitespace rules in the language annotation is also applicable. Instead, it is also allowed to use word combination (instead of the annotation) when gramatically correct, so this rule does not apply.</p>
<h1 id="cross-references"><a class="header" href="#cross-references">Cross references</a></h1>
<p>This document is used by the YSLib project. It may be also referenced by other repositories.</p>
<p><strong>Except for the following list, do not edit unless ultimately necessary.</strong></p>
<p>Known refereced by:</p>
<ul>
<li><a href="https://github.com/FrankHB/pl-docs">Programming Language Documentations</a> by FrankHB</li>
</ul>
<h1 id="annex-informative"><a class="header" href="#annex-informative">Annex (Informative)</a></h1>
<h2 id="alternaive-imcompatible-rules"><a class="header" href="#alternaive-imcompatible-rules">Alternaive imcompatible rules</a></h2>
<p>Usually there the rules of documentation here are compatible to other rules in various specifications. However, some of the well-known rules are considered overspecified (albeit not rigouous) and with insufficient quality in specification. Thus, these rules are <em>deliberately</em> kept incompatible, and never accepted here:</p>
<ul>
<li>The specification may be too vague by missing separating the comformance rules and the suggestions, so it is difficult to manually verify the conformance just by the specification text.
<ul>
<li>Some confusions may be from the lack of rules on the modal verbs.</li>
<li>Some rules may be underspecified for external resources. For example, the claim of &quot;be a valid Markdown file&quot; is unclear without further notes, because there is no unique standard to determine the definition of &quot;valid&quot;, since there are multiple dialects of the Markdown language and no flavor is definitely more representative than others.</li>
</ul>
</li>
<li>The rules of mandated letter cases (in particular, capitalization) may be too restrictive.
<ul>
<li>This may be generally too subjective. It can be good to sticking to a well-name for to ease for use cases for technical merits (like for machine verication), but the fixed spelling on cases may be overspecified.
<ul>
<li>The exception is when the name is standardized and machine-oriented by default.</li>
<li>As a notable instance, <a href="https://www.rfc-editor.org/rfc/rfc5646.html">RFC 5646</a> recommends but does not mandate the capitalization for the codes from <a href="https://en.wikipedia.org/wiki/ISO_639-1">ISO 639-1</a> and <a href="https://en.wikipedia.org/wiki/ISO_3166-1">ISO 3166-1</a>, while the preferred capitalization diverges in the 2 standards.</li>
</ul>
</li>
<li>On the other hand, mandotory like &quot;README&quot; instead of &quot;Readme&quot; is too restrictve. It will be problatic to be transferred between case-insensitive enviornments and case-sensitive environments (e.g. names in filesystems), where one environment may allow entries of <code>README</code> and <code>Readme</code> coexisting but another may not.
<ul>
<li>When techically feasible to having different cases coexisting, &quot;README&quot; and &quot;Readme&quot; are symmentric, i.e. no one is definitely more preferred than the other for machines. It is then not intuitive to reason why &quot;README&quot; must be preferred to &quot;Readme&quot; instead of the exact opposite in the specification, in particular with the fact that such entry is mainly created for human readers but not machines.</li>
<li>Instead, keeping one overridable as well as a recommended default form (which does not necessarily to be all capitalized) of spelling is better for both portability and other needs.</li>
<li>Further, names like &quot;README.md&quot; are less consistent to &quot;README.MD&quot;. The latter is at least required in some ancient systems not support the small case, hence even more preferred for portability (in extreme cases).</li>
</ul>
</li>
</ul>
</li>
<li>Prioritizing non-regional subtags for languages should not be recommended normally, because this is less accurate, and the confusion may even be offensive to specific culture, since there can be lack of consensus that one subtag can override another without changing the meaning of the text (which is not the case of the relationship between tags and subtags).</li>
<li>Validation of hyperlinks should be acknowledged not always possible when the linked resource is out of the control (i.e. external) in a document.
<ul>
<li>Anyway, there is no persistency guarantee for most hyperlinks in the Web.</li>
<li>Mandating the state of the referenced resource of hyperlinks unconditionally will make any verification result one-time, because the exteranl links may be broken immediately after the verification. Then the conformance is non-deterministic.</li>
<li>Such mandatory is applicable only for hyperlinks provable to be persistent. But this is infeasible with automatic methods at least for external links on the Web, because the test of persistency may be unreliable until the link is broken.</li>
<li>So, unless external links are not allowed (which seems an overkill), rules having impractical assumptions of the validation process should be in the specification.</li>
</ul>
</li>
</ul>
<p>An example of most bullets above can be found in the <a href="https://github.com/RichardLitt/standard-readme/blob/master/spec.md">specification</a> of <a href="https://github.com/RichardLitt/standard-readme">standard-readme</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
