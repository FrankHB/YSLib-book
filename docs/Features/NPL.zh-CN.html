<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>NPL - The YSLib Book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Book tranplanted from YSLib BitBucket wiki.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The YSLib Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="概述"><a class="header" href="#概述">概述</a></h1>
<p>　　NPL 是 YSLib 提供的语言集合，它在语言规范层次上被设计为可扩展的。</p>
<p>　　通过<em>派生(derive)</em> 现有的语言（ NPL 的<em>方言(dialect)</em> ），避免完全重新设计新的语言，来满足需要一些新语言的场合下的需求。被派生的语言是 NPL 的<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">抽象语言实现</a>。翻译或执行 NPL 或 NPL 抽象语言实现的程序是 NPL （方言）的<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">具体语言实现</a>。具有具体语言实现的方言仍可以派生新的语言作为<a href="https://en.wikipedia.org/wiki/Domain-specific_language">领域特定语言</a>。</p>
<p>　　派生领域特定语言的一个其它的例子是 <a href="https://en.wikipedia.org/wiki/XML">XML</a> 。</p>
<h2 id="语法和语义"><a class="header" href="#语法和语义">语法和语义</a></h2>
<p>　　NPL 的<a href="#%E8%AF%AD%E6%B3%95">语法</a>基于形式文法上可递归构造的<strong>表达式</strong>。</p>
<p>　　在操作语义（基于<a href="#%E9%A1%B9%E9%87%8D%E5%86%99%E7%B3%BB%E7%BB%9F">项重写系统</a>）的<a href="#%E8%A7%84%E7%BA%A6%E8%A7%84%E5%88%99%E5%92%8C%E6%B1%82%E5%80%BC">意义</a>上，其中的子表达式又称为<strong>项</strong>。</p>
<p>　　非正式地，NPL 使用类似 <a href="https://zh.wikipedia.org/wiki/S-%E8%A1%A8%E8%BE%BE%E5%BC%8F">S-表达式</a>的基本语法，但不使用二元有序对（和终止符号）而直接支持列表；即表达式直接以是否为括号作为边界，分为<a href="#%E5%88%97%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">列表表达式</a>和非列表表达式。</p>
<p>　　正式语法中，作为子表达式的项可以是列表或非列表项的<a href="#%E5%A4%8D%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F">复合表达式</a>规约列表项中的一部分代替有序对的地位，以要求任意项可被无歧义地进行从左到右的语法分析。</p>
<p>　　NPL 只要求小括号作为列表表达式的边界。其它替代的括号由<a href="#%E7%95%A5%E7%A7%B0">派生实现</a>约定。对于适用于多个 NPL 实现的可移植代码，避免使用其它语言中习惯作为代替括号边界的字符表示替代的括号以外的含义，特别地，[ISO C++] 文法 <code>balanced-token</code> 中的边界字符 <code>()[]{}</code> 。</p>
<p>　　NPL 对标识符的限制较为宽松。[ISO C] 和 [ISO C++] 的所有标识符都是 NPL 标识符。但派生实现可加以限制。</p>
<p>　　NPL 不提供专用的注释语法。以特定形式的项（如表示字符串的字面量）替代注释是预期的惯用法(idiom) 。这不妨碍派生语言可能添加预处理器扩展特性。</p>
<p>　　NPL 提供了一些通用的概念和<a href="#npl-%E5%85%AC%E5%85%B1%E8%AF%AD%E4%B9%89">公共规则</a>，但不构成<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">具体语言实现</a>的完整语义规则。语义规则由派生实现补充完整。</p>
<p><strong>注释</strong></p>
<p>　　排除注释及<a href="#%E4%B8%AD%E7%BC%80%E8%AF%AD%E6%B3%95">中缀标点 <code>;</code> 和 <code>,</code></a> ，NPL 的语法和 <a href="https://en.wikipedia.org/wiki/Scheme_%28programming_language%29">Scheme 语言</a>或<a href="https://web.cs.wpi.edu/~jshutt/kernel.html">Kernel 语言</a>的语法近似。不过，NPL 不支持构造循环引用，也不提供相关语法。详见以下<a href="#%E8%AF%AD%E6%B3%95">语法</a>中的讨论。</p>
<h2 id="需求概述"><a class="header" href="#需求概述">需求概述</a></h2>
<p>　　设计满足的需求描述参见<a href="https://github.com/FrankHB/pl-docs/blob/master/en-US/calling-for-language-features.md">这里(en-US)</a> 。</p>
<p>　　需求来源：</p>
<ul>
<li>出发点：构建一个可用计算机实现的语言。</li>
<li>基本目的：在以标准 C++ 环境（ [ISO C++] 定义的<em>宿主实现(hosted implementation)</em> ）的程序框架中嵌入配置和脚本操作。</li>
<li>扩展目的：渐进地向独立的计算机系统演进，探究能适用于各个领域并以计算机实现的<em>通用目的语言(general-purpose language)</em> 。</li>
</ul>
<p>　　本文档描述基于此出发点的 <strong>NPL(Name Protocoling Language)</strong> （一个替代的递归缩写是“NPL's not a Programming Language”，因其不仅适合作为 PL 的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>特性及其参照实现。</p>
<p>　　和大部分其它设计不同，为了确保一定程度的适应通用目的的性质，它们被设计整体首要考虑。这样的设计的语言是（自设计(by desing) 用于）满足通用目的的语言(general-purposed language) 。</p>
<h2 id="其它设计和实现参考"><a class="header" href="#其它设计和实现参考">其它设计和实现参考</a></h2>
<p>　　NPL 是独立设计的语言，但它和 [R<sup>n</sup>RK] 定义的 <a href="https://web.cs.wpi.edu/~jshutt/kernel.html">Kernel 语言</a>有许多核心设计的相似之处，尽管设计的一些基本特征（如<a href="#%E8%B5%84%E6%BA%90%E5%8F%AF%E7%94%A8%E6%80%A7%E5%9F%BA%E6%9C%AC%E7%BA%A6%E5%AE%9A">资源可用性基本约定</a>）以及<a href="#%E9%A2%86%E5%9F%9F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">基本哲学</a>相当不同。</p>
<p>　　NPL 的<a href="#npla1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80">主要实现</a>的核心部分实质上支持了 Kernel 的<a href="#%E6%A8%A1%E5%9E%8B">形式模型</a>—— vau 演算(vau calculi) 。</p>
<p><strong>注释</strong> 另见<a href="#%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E6%96%B9%E6%B3%95">操作语义</a>。</p>
<p>　　具体的 NPL 语言在这些模型的基础上提供。</p>
<p>　　<a href="#%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0">NPL 的命名</a>即体现了 vau 演算和传统 <a href="#%CE%BB-%E5%AE%8C%E5%A4%87%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AF%B9%E5%BA%94%E8%AF%AD%E6%B3%95">λ 演算</a>为模型的语言的核心差异：</p>
<p>　　强调允许在<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>中指定求值上下文的<em>显式求值(explicit evaluation)</em>（而非 Lisp 方言中以 <code>quote</code> 为代表的显式干预默认的隐式求值）的风格以及<a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a><a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>前后的不同，特别地，关注在语言中直接表达的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">名称</a>和<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>后指称的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">实体</a>的不同。</p>
<p>　　更进一步地，NPL 普遍地支持区分<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">一等引用</a>和被引用的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等实体</a>并具有更精确的资源控制机制，这是与 Kernel 的主要设计上的差异。</p>
<p>　　关于 vau 演算的形式模型和其它相关内容，详见 [Shu10] 。特别地，vau 演算提供了 <a href="https://en.wikipedia.org/wiki/Fexpr">fexpr</a> 类似的抽象。</p>
<p><strong>注释</strong> 另见<a href="#npla1-%E8%A7%84%E8%8C%83%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值算法设计的实例</a>。</p>
<p>　　关于一些其它支持 fexpr 特性的语言设计，参见：</p>
<ul>
<li><a href="https://software-lab.de/doc/faq.html#lambda">PicoLisp</a></li>
<li><a href="http://www.newlisp.org/downloads/newlisp_manual.html#define-macro">newLISP</a></li>
</ul>
<p>　　和 Kernel 以及本设计不同，这两个例子的设计使用<a href="#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">动态作用域</a>；在主要的特性中存在一些关键的不同而在形式模型的适用性上有显著的区别。</p>
<p><strong>注释</strong></p>
<p>　　NPL 和历史上同名的 <a href="https://en.wikipedia.org/wiki/John_Darlington">John Darlington</a> 的 <a href="https://en.wikipedia.org/wiki/NPL_(programming_language)">NPL (New Programming Language)</a> 没有直接渊源；特别地，后者的多个等式的函数定义语法和高阶类型没有被内建支持，而<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态类型</a>和纯函数式限制被避免。</p>
<p>　　Kernel 语言的原始参照实现是 SINK 依赖 MzScheme version 103 的解释器实现，和 [R<sup>n</sup>RK] 有一定差异。例如，字面量 <code>#ignore</code> 和 <code>#inert</code> 用 <code>%ignore</code> 和 <code>%inert</code> 代替。</p>
<p>　　<em><a href="https://web.archive.org/web/20210301121505/http://klisp.org/">klisp</a></em> 是 Kernel 语言的一个更完善的实现。</p>
<p>　　有些特性（如复数支持）都没有在这两个中实现提供，而仅在 [R<sup>n</sup>RK] 中指定。</p>
<h2 id="实现"><a class="header" href="#实现">实现</a></h2>
<p>　　在 YFramework/NPL 提供一些参考<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">具体语言实现</a>。当前 YFramework 主要使用<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">抽象语言实现</a> <a href="#npla">NPLA</a> 的具体<em>派生(derived)</em> 的实现 <a href="#npla1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80">NPLA1</a> ，在这个基础上用于不同的目的，如<a href="../Tutorial/Configuration.zh-CN.html">程序配置</a>、<a href="../Tutorial/GUI.zh-CN.html">动态加载的 GUI</a> 等。</p>
<p>　　NPLA 提供了比大多数现有的程序设计语言更强大的一般抽象。这集中体现在：</p>
<ul>
<li>和 NPL 的原始设计一致，不提供也不要求区分实现的阶段(phase) 。</li>
<li>支持<a href="#npla-%E7%8E%AF%E5%A2%83">一等环境</a>不修改现有语言的<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>即可实现共享类似语法的新语言。</li>
<li>允许以一般手段表达求值和未求值表达式的差异。</li>
</ul>
<p>　　这意味着 NPLA 是本质上动态的语言，但和一般语言不同，用户可以很大程度上动态地替换现有语言实现，包括在运行时替换一个解释实现为一个或多个优化编译器。这也意味着语言设计上既不需要区分解释实现和编译实现（本质上不对立），也不需要区分动态和静态（因为随时能从基础语言上构造出静态子集）。</p>
<p>　　这样的特性设计在绝大多数语言中不存在并且几乎无法支持。已知唯一的例外是 <a href="http://web.cs.wpi.edu/~jshutt/kernel.html">Kernel</a> ，在这些特性上有极大的相似，尽管实际上基本特性是<strong>独立设计的</strong>，并且在基本<a href="#%E9%A2%86%E5%9F%9F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">设计哲学</a>上有极大不同（ NPL 和 [R<sup>n</sup>RK] 中明确的 guidelines有很大不同且基本不兼容）。不过，考察设计的完整性，NPL 的派生语言也从中借鉴了一些重要的设计：</p>
<ul>
<li><a href="http://lambda-the-ultimate.org/node/4093"><code>$vau</code></a> 、<em>合并子(combiner)</em> /<em>应用子(applicative)</em> /<em>操作子(operative)</em> 等术语。</li>
<li>在<a href="#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>中支持模式匹配的<a href="#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">形式参数树</a>。</li>
<li>一些以合并子形式提供的操作。
<ul>
<li>一般的作为接口提供的合并子在 NPL 中仍称为函数；合并子是作为表达式的函数的特定的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>。
<ul>
<li><strong>注释</strong> 在 Scheme 中，合并子中的应用子对应<a href="#%E8%BF%87%E7%A8%8B">过程</a>。</li>
</ul>
</li>
<li>相似的操作主要体现在<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">名称</a>和<a href="../Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">语义</a>上。因为一些基本设计的差异，不保证完全兼容。</li>
<li>相似操作的实现不尽相同，但其中不通过<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>的直接的实现（称为<em>派生(derivation)</em> ）有一部分几乎完全相同。</li>
<li>使用 <code>$</code> 作为一些<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">标识符</a>（如 <code>$lambda</code> ）的前缀是独立设计的巧合；现在含义已和 Kernel 一致，表示 <em>special form</em> 。</li>
</ul>
</li>
</ul>
<p>　　一些值得注意的和类似语言的主要设计差异（原理详见开发文档）：</p>
<ul>
<li>NPL 和 Kernel 类似，强调<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>，但含义有所不同。此处的“对象”和 [ISO C] 及 [ISO C++] 中的定义类似，具有比 Kernel 更严格的含义。
<ul>
<li>和 Kernel 合并子及 Scheme 过程类似，NPLA 默认使用<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值传递</a>参数和结果；但与之不同，不隐式对实际参数<a href="#%E5%AF%B9%E8%B1%A1%E5%88%AB%E5%90%8D">别名</a>，不<a href="#%E5%85%B1%E4%BA%AB%E5%BC%95%E7%94%A8">共享</a>对象。</li>
</ul>
</li>
<li>NPLA 和<a href="#%E7%95%A5%E7%A7%B0">派生实现</a>的语法和整体的求值类似 Scheme 和 Kernel 大多数基于 S-表达式的 <a href="https://en.wikipedia.org/wiki/Lisp_%28programming_language%29">Lisp</a> 方言，但有一些显著的区别。
<ul>
<li>和 Scheme 不同，而和 Kernel 一致，NPLA 避免顶层(top-level) 和局部的上下文的差异。</li>
<li>NPLA1 明确区分约定包括列表项的求值规则。和传统习惯不同，NPLA1 中括号明确不需要表示应用的含义，这可以减少一些场合（如命令行）需要输入的过多的连续括号。</li>
<li>和 [R<sup>n</sup>RS] 定义的 Scheme 以及 [R<sup>n</sup>RK] 定义的 Kernel 一致，不支持某些 Lisp 方言的方括号 <code>[]</code> 替代圆括号 <code>()</code> 的语法。</li>
<li>不提供注释语法。</li>
<li>语言实现中<a href="#%E4%B8%AD%E7%BC%80%E8%AF%AD%E6%B3%95">内置预处理处理中缀 <code>;</code> 和 <code>,</code></a> ，作为前缀合并子 <code>$sequence</code> 和 <code>list</code> 的语法糖。两者的含义和 Kernel 中的相同（类似 Scheme 的 <code>begin</code> 和 <code>list</code> ）。</li>
</ul>
</li>
<li>和 Kernel 相似而和 Scheme 不同，使用操作子及一等环境和 <code>eval</code> 代替 Scheme 的<a href="https://en.wikipedia.org/wiki/Hygienic_macro">卫生宏(hygienic macro)(en-US)</a> 及宏展开的作用。
<ul>
<li>和 Kernel 类似，鼓励使用直接求值风格而不是<a href="#%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%A3%8E%E6%A0%BC">引用(quote)</a> 。</li>
<li>不过 NPLA 也提供了 <code>$quote</code> 的派生而非如 Kernel 一样完全避免。</li>
</ul>
</li>
<li>和 Kernel 不同，NPL 明确支持资源抽象，<strong>不保证支持</strong><a href="#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>，而 NPLA 明确<strong>不支持</strong>循环引用。</li>
<li>NPLA 明确支持基于 [ISO C++] 实现的对象模型和<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>，且明确<strong>不要求</strong>支持全局 <a href="https://zh.wikipedia.org/zh-cn/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_%28%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8%29">GC</a> 。
<ul>
<li>从在互操作的目的出发，和 C++ 具有相似性和相容性。
<ul>
<li>支持基于 <a href="https://eel.is/c++draft/intro.abstract">C++ 抽象机语义</a>的更一般的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>（除原生 <code>volatile</code> 外）和一等状态(first-class states)  。</li>
<li>和 [ISO C++] 类似，在<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>中保留特定的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未定义行为</a>，而不要求实现避免。</li>
<li>暂时不直接支持<a href="#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">多线程环境</a>，但可以在不同<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">宿主语言</a>线程上同时使用不同的实现的实例。</li>
<li>函数默认使用不隐式别名的按值调用和返回传递复制或转移值，和 C++ 对应上下文的复制初始化(copy initialization) 语义一致。（不过求值为操作子的 NPL 函数在 C++ 没有直接的对应。）</li>
</ul>
</li>
<li>在 vau 演算的论文 ([Shu10]) 中，提及不支持全局 GC 有较大的管理开销(admistrative cost) 但没有详细讨论和<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言特性</a>的联系。</li>
</ul>
</li>
<li>即便不支持全局 GC ，当前实现仍然<strong>明确支持</strong> <a href="#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C-ptc">PTC(proper tail call)</a> 。
<ul>
<li>PTC 基于语言规则而不是<a href="#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">实现行为</a>定义，详见 <a href="https://www.researchgate.net/profile/William_Clinger/publication/2728133_Proper_Tail_Recursion_and_Space_Efficiency/links/02e7e53624927461c8000000/Proper-Tail-Recursion-and-Space-Efficiency.pdf">proper tail recursion</a> ，这里和 Kernel 提供的保证含义一致。</li>
<li>没有在其它语言发现这种不支持全局 GC 和支持类似 C++ 副作用的情形下的 PTC 支持的先例。</li>
</ul>
</li>
<li>和 Kernel 不同，NPLA 不完全强制对象类型的<a href="#%E5%B0%81%E8%A3%85">封装</a>；且基于支持互操作的考虑，支持<a href="#%E7%B1%BB%E5%9E%8B%E5%85%A8%E9%9B%86">开放</a>的<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">类型系统</a>，而不要求覆盖所有值（即要求对象类型分区(partition) ）。</li>
<li>对机器数（不论是整数还是浮点数）的操作被剥离了，当前不被支持，需要用户代码添加个别操作。</li>
<li>NPLA 的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">规约</a>框架和 vau 演算的<a href="#%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E6%96%B9%E6%B3%95">操作语义</a>几乎完全一致，不过实际上（因为先前语言设计上的不确定）显著地保留了更多的可扩展和可修改性。</li>
</ul>
<h2 id="当前具体实现"><a class="header" href="#当前具体实现">当前具体实现</a></h2>
<p>　　当前派生实现的 <a href="#npla1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80">NPLA1</a> 由 YFramework 提供 <a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 。其中包括 <a href="https://zh.wikipedia.org/wiki/%E8%AF%BB%E5%8F%96%EF%B9%A3%E6%B1%82%E5%80%BC%EF%B9%A3%E8%BE%93%E5%87%BA%E5%BE%AA%E7%8E%AF">REPL (read-eval-print loop)</a> 的解释实现。外部文件的形式的 NPLA1 脚本可被基于这些 API 实现的 <a href="../Tools/SHBuild.zh-CN.html">stage 1 SHBuild</a> 调用并用于 YFramework 的构建。</p>
<p>　　由 <a href="../Run.zh-CN.html#%E5%A4%96%E9%83%A8%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F">YFramework 对外部文本编码的约定</a>，NPLA1 实现加载的文件流的剩余内容的编码视为 UTF-8 ；同时支持 CR+LF 或 LF 为换行符。</p>
<p><strong>注释</strong> 这些实现基于 YSLib API 提供互操作支持。</p>
<h1 id="绪论"><a class="header" href="#绪论">绪论</a></h1>
<h2 id="正式引用"><a class="header" href="#正式引用">正式引用</a></h2>
<p>　　仅在此给出本文档中的外部引用的名称。其它引用文献的内容详见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<!-- markdownlint-capture -->
<!-- markdownlint-disable MD049 -->
<ul>
<li>[ISO C] <a href="https://www.iso.org/standard/74528.html">ISO/IEC 9899</a></li>
<li>[ISO C++] <a href="https://www.iso.org/standard/79358.html">ISO/IEC 14882</a>
<ul>
<li>[ISO C++11] <a href="https://www.iso.org/standard/50372.html">ISO/IEC 14882:2011</a></li>
<li>[ISO C++14] <a href="https://www.iso.org/standard/64029.html">ISO/IEC 14882:2014</a></li>
<li>[ISO C++17] <a href="https://www.iso.org/standard/68564.html">ISO/IEC 14882:2017</a></li>
<li>[ISO C++20] <a href="https://www.iso.org/standard/79358.html">ISO/IEC 14882:2020</a></li>
<li>[WG21] (ISO/IEC JTC1/SC22/WG21) <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers">C++ Standards Committee Papers</a>
<ul>
<li>[WG21 P0135R1] Richard Smith, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0135r1.html">Wording for guaranteed copy elision through simplified value categories</a>, 2016-06-20.</li>
</ul>
</li>
</ul>
</li>
<li>[R<sup>n</sup>RK] <a href="https://web.cs.wpi.edu/~jshutt/kernel.html">Revised Report on the Kernel Programming Language</a>
<ul>
<li>[Shu09] John N. Shutt, <a href="ftp://ftp.cs.wpi.edu/pub/techreports/pdf/05-07.pdf">Revised<sup>-1</sup> Report on the Kernel Programming Language</a>, Technical report WPI-CS-TR-05-07, Worcester Polytechnic Institute, Worcester, MA, March 2005, amended 29 October 2009.</li>
<li><strong>注释</strong> 当前 [R<sup>n</sup>RK] 只有 <tt>n = -1</tt> 的版本。引用确切版本时，同 [Shu10] 中的用法，使用 [Shu09] 标记；但引用时一般同样不涉及其版本差异。</li>
</ul>
</li>
<li>[Shu10] John N. Shutt, <a href="https://web.wpi.edu/Pubs/ETD/Available/etd-090110-124904/unrestricted/jshutt.pdf">Fexprs as the basis of Lisp function application; or, <code>$vau</code>: the ultimate abstraction</a>, Ph.D. Dissertation, WPI CS Department, 2010.</li>
<li>[R<sup>n</sup>RS] <a href="http://www.scheme-reports.org/">Revised Report on the Algorithmic Language Scheme</a>
<ul>
<li>[R<sup>5</sup>RS] <a href="https://schemers.org/Documents/Standards/R5RS/r5rs.pdf">Revised<sup>5</sup> Report on the Algorithmic Language Scheme</a></li>
<li>[R<sup>6</sup>RS] <a href="http://www.r6rs.org/final/r6rs.pdf">Revised<sup>6</sup> Report on the Algorithmic Language Scheme</a></li>
<li>[R<sup>6</sup>RS-Rationale] <a href="http://www.r6rs.org/final/r6rs-rationale.pdf">Revised<sup>6</sup> Report on the Algorithmic Language Scheme -Rationale-</a></li>
<li>[R<sup>7</sup>RS] <a href="https://small.r7rs.org/attachment/r7rs.pdf">Revised<sup>7</sup> Report on the Algorithmic Language Scheme</a></li>
</ul>
</li>
<li>[Fl91] Matthias Felleisen, <a href="https://www.ccs.neu.edu/racket/pubs/scp91-felleisen.ps.gz">On the Expressive Power of Programming Languages</a>, <em>Science of Computer Programming</em> <a href="https://www.sciencedirect.com/journal/science-of-computer-programming/vol/17/issue/1">Volume 17, Issues 1–3</a>, December 1991, pp. 35–75.</li>
<li>[EGAL] James Noble, Andrew P. Black, Kim B. Bruce, Michael Homer and Mark S. Miller, <a href="http://web.cecs.pdx.edu/~black/publications/egal.pdf">The Left Hand of Equals</a>, Onward! 2016: <em>Proceedings of the 2016 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software</em>, October 2016, pp. 224–237.</li>
<li>[So90] Harald Søndergaard and Peter Sestoft, <a href="http://www.itu.dk/people/sestoft/papers/SondergaardSestoft1990.pdf">Referential transparency, definiteness and unfoldability</a>, <a href="https://link.springer.com/journal/236"><em>Acta Informatica</em></a> 27, 1990, pp. 505–517.</li>
<li>[Rust] <a href="https://doc.rust-lang.org/reference/index.html">The Rust Reference</a>
<ul>
<li>不定期更新。</li>
</ul>
</li>
<li>[Fi94] Andrzej Filinski, <a href="https://dl.acm.org/doi/pdf/10.1145/174675.178047">Representing Monads</a>, POPL '94: <em>Proceedings of the 21st ACM SIGPLAN-SIGACT symposium on Principles of programming languages</em>, February 1994, pp. 446–457.</li>
<li>[Hi90] Robert Hieb, R. Kent Dybvig and Carl Bruggema, <a href="https://legacy.cs.indiana.edu/~dyb/pubs/stack.pdf">Representing Control in the Presence of First-Class Continuation</a>, <em>ACM SIGPLAN Notices</em>, Volume 25, Issue 6, Jun. 1990, pp. 66–77.</li>
<li>[Racket] <a href="https://docs.racket-lang.org/">Racket Documentation</a>
<ul>
<li>不定期更新。</li>
</ul>
</li>
<li>[Chu41] Alonzo Church, <a href="https://compcalc.github.io/public/church/church_calculi_1941.pdf"><em>The Calculi of Lambda-Conversion</em></a>, Annals of Mathematics Studies, Princeton: Princeton University Press, 1941.</li>
<li>[Bare84] Hendrik Pieter Barendregt, <a href="https://philpapers.org/rec/BARTLC"><em>The Lambda Calculus: Its Syntax and Semantics</em></a> [<em>Studies in Logic and the Foundations of Mathematics</em> 103], Revised Edition, Amsterdam: North Holland, 1984.</li>
<li>[Cl98] William D. Clinger, <a href="https://www.researchgate.net/profile/William_Clinger/publication/2728133_Proper_Tail_Recursion_and_Space_Efficiency/links/02e7e53624927461c8000000/Proper-Tail-Recursion-and-Space-Efficiency.pdf">Proper Tail Recursion and Space Efficiency</a></li>
<li>[IEC 60559] <a href="https://www.iso.org/standard/80985.html">ISO/IEC 60559</a></li>
<li>[ECMAScript] <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-262/">ECMA-262</a>
<ul>
<li>[ECMAScript 2019] <a href="https://262.ecma-international.org/10.0/">ECMA-262 10.0</a></li>
</ul>
</li>
</ul>
<!-- markdownlint-restore -->
<h2 id="领域设计原则"><a class="header" href="#领域设计原则">领域设计原则</a></h2>
<p>　　本节描述被本文档中的一些原理讨论引用的的公共依据。</p>
<p>　　原则指关于设计和实现的哲学，同时作为一般规则约束设计和实现的工程阶段。</p>
<p>　　关于需求特别是通用目的语言的讨论，参见<a href="https://github.com/FrankHB/pl-docs/blob/master/en-US/calling-for-language-features.md#module">需求概要(en-US)</a> 。</p>
<h3 id="本体论"><a class="header" href="#本体论">本体论</a></h3>
<p>　　为使论述有效，约定<em>本体论(ontology)</em> 规则。</p>
<p>　　基本的本体论规则是约束逻辑系统构造的公理。</p>
<h4 id="正规性"><a class="header" href="#正规性">正规性</a></h4>
<p>　　有效的陈述（如需求描述）应保证操作上可预期结果。</p>
<p>　　在此意义下，缺乏约束性的规则不可预期的风险是代价。</p>
<p>　　推论：规则应适当约定适用范围，以避免外延不清。</p>
<h4 id="存在性"><a class="header" href="#存在性">存在性</a></h4>
<p>　　语义的存在体现本质。</p>
<p>　　仅仅应用语法规则，即限定为<em>语法的文法(syntactic grammar)</em> 的形式系统归纳的设计，不被视为表示任何<a href="#%E6%AD%A3%E8%A7%84%E6%80%A7">有效</a>的含义。</p>
<h4 id="名实问题"><a class="header" href="#名实问题">名实问题</a></h4>
<p>　　名义概念的内涵和外延应被足够显式指定，避免指涉上的歧义，允许构造<a href="#%E6%AD%A3%E8%A7%84%E6%80%A7">有效的陈述</a>。</p>
<h4 id="不可分的同一性"><a class="header" href="#不可分的同一性">不可分的同一性</a></h4>
<p>　　<a href="https://plato.stanford.edu/entries/identity-indiscernible/">不可分的同一性(the identity of indiscernibles) (en-US)</a> 比较陈述的客体之间是否相同而不需要被重复地处理。</p>
<h3 id="价值观"><a class="header" href="#价值观">价值观</a></h3>
<p>　　价值观是关于价值判断的规则，其输出为二元的值，决定是否接受决策。</p>
<p>　　作为应对普遍需求场景的不同解决方案选型时的价值判断的抽象归纳，价值观被作为比较是否采用设计相关决策的全局依据。</p>
<p>　　以下陈述形式表达价值优先的选项，同时作为公理。</p>
<p><strong>注释</strong> 相同推理结果仍然可能不唯一，这来自于自然语言描述的输入的不精确性。</p>
<h4 id="变化的自由"><a class="header" href="#变化的自由">变化的自由</a></h4>
<p>　　在明确需求的前提下，尽可能保证对现状按需进行改变的可行性和便利性。</p>
<p>　　适用于一般需求。</p>
<p>　　对计算机软件或其它可编程的实体：尽可能避免不必要地损失可修改性，便于保障按需引入或除去<a href="../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">接口</a>及其实现的自由。</p>
<p><strong>原理</strong></p>
<p>　　一般地，需求可能随着不可控的外部条件变化。假设已明确的需求不变只能适合相当有限的情形。积极应对变化能提供价值。</p>
<h4 id="避免不必要付出的代价"><a class="header" href="#避免不必要付出的代价">避免不必要付出的代价</a></h4>
<p>　　尽可能消除对满足需求无意义的代价，减少影响需求实现的整体成本。</p>
<p>　　适用于一般需求中设计决策的比较。</p>
<p>　　对计算机软件或其它可编程的实体：不为不需要的<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">特性</a>付出代价。</p>
<p><strong>注释</strong></p>
<p>　　一个类似的表述：</p>
<blockquote>
<p>Efficiency has been a major design goal for C++ from the beginning, also the principle of “zero overhead” for any feature that is not used in a program. It has been a guiding principle from the earliest days of C++ that “you don’t pay for what you don’t use”.</p>
</blockquote>
<p>　　— <a href="https://www.iso.org/standard/43351.html">ISO/IEC TR 18015</a></p>
<h4 id="最小接口原则"><a class="header" href="#最小接口原则">最小接口原则</a></h4>
<p>　　在满足需求的前提下，尽可能使用符合倾向减小实现需求代价的单一良基关系下具有极小元的接口设计。</p>
<p><strong>注释</strong> 减小实现需求的代价，如减小设计工作量。</p>
<p>　　这是一条模式规则，依赖具体情形何者符合良基关系的极小元这条非模式规则作为输入。</p>
<p>　　实际使用时，非模式规则可以直接指定为二元关系的子集，或者一种良序的度量。</p>
<p><strong>注释</strong> 例如，“公开函数声明数”“模块数”。</p>
<p>　　这个输入也可能直接对应符合需求集合的某种最小功能集合而不需要附加度量，如表示某种设计的裁剪。</p>
<p>　　注意规则指定的基数是对实现需求有意义的代价，因此不涵盖<a href="#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>。</p>
<p>　　在确定的范围内尽可能少地提供必须的接口，避免不必要的假设影响接口适应需求的能力，同时减少实现需求的各个阶段的复杂性。</p>
<p>　　适用于一般需求的实现，特别地，强调“通用”目的时。</p>
<p>　　对需要在计算机上实现的人工语言设计：设计语言不应该进行功能的堆砌，而应该尽可能减少弱点和限制，使剩下的功能显得必要。</p>
<blockquote>
<p>Programming languages should be designed not by piling feature on top of feature, but by removing the weaknesses and restrictions that make additional features appear necessary.</p>
</blockquote>
<p>　　— [R<sup>n</sup>RS] &amp; [R<sup>n</sup>RK]</p>
<p><strong>注释</strong></p>
<p>　　其它各个领域中的实质等价一些表述包括：</p>
<ul>
<li>用于安全系统设计的<a href="#%E6%9C%80%E5%B0%8F%E7%89%B9%E6%9D%83%E5%8E%9F%E5%88%99">最小特权原则</a>。</li>
<li>用于自然科学理论设计的<a href="https://zh.wikipedia.org/zh-cn/%E5%A5%A5%E5%8D%A1%E5%A7%86%E5%89%83%E5%88%80">奥卡姆剃刀(Occam’s Razor)</a> 原理，避免不必要的假设引入诉诸无知(argument from ignorance) 谬误。</li>
</ul>
<h4 id="关注点分离原则"><a class="header" href="#关注点分离原则">关注点分离原则</a></h4>
<p>　　<a href="https://zh.wikipedia.org/zh-cn/%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB">关注点分离(separation of concerns, SoC)</a> 原则 ：局部设计的内容应和需求的陈述或其它隐含的设计前提分别一一对应。</p>
<p>　　适用于一般需求的实现，特别是其中依赖认识论观点的过程。</p>
<p><strong>原理</strong></p>
<p>　　这条规则利用需求和设计内容陈述中概念外延普遍蕴含的<em>局域性(locality)</em> ，提供给定代价下更多的可行性或求解给定问题时使用较小的代价，用于：</p>
<ul>
<li>应对不可控复杂条件下使问题可解。</li>
<li>局部可复用现有解的子集。</li>
</ul>
<p>　　此外，尽管并非总是必要，应用知识内容的简单假设、<a href="#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>和本原则可在认识论上导出还原论。</p>
<h3 id="形而上学"><a class="header" href="#形而上学">形而上学</a></h3>
<p>　　根据作为需求的<a href="#%E4%BB%B7%E5%80%BC%E8%A7%82">价值观</a>，归纳适用于通用目的语言应有的构成及其性质（形而上学(metaphysics) ）的设计规则，包括三条价值判断实现公理：</p>
<ul>
<li>设计应尽可能满足<a href="#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>。</li>
<li>设计应尽可能满足<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>。</li>
<li>设计的正确性应优先于简单性。</li>
</ul>
<p>　　具备这些性质的设计可视为由<a href="#%E4%BB%B7%E5%80%BC%E8%A7%82">价值判断</a>蕴含，预设前提为真的设计<a href="#%E6%96%B9%E6%B3%95%E8%AE%BA">方法论</a>的实现。</p>
<p><strong>注释</strong></p>
<p>　　注意和 <a href="https://en.wikipedia.org/wiki/Worse_is_better">worse is better</a> 或 <a href="https://en.wikipedia.org/wiki/Worse_is_better#The_MIT_approach">the MIT approach</a> 不同，设计的性质并非完全并列。特别地，<a href="#%E5%AE%8C%E6%95%B4%E6%80%A7">完整性</a>和<a href="#%E4%B8%80%E8%87%B4%E6%80%A7">一致性</a>都被作为正确性的一部分考虑。</p>
<p>　　因为<a href="#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>，具体需求以及判断正确性和简单性的确切依据都可能会随着项目的进展而变化。</p>
<h4 id="正确性"><a class="header" href="#正确性">正确性</a></h4>
<p>　　设计应正确地反映需求，不在需求的基础上新增作为实现细节以外的不确定性。</p>
<p>　　无法确保满足这种<em>正确性(correctness)</em> 要求时，不应继续设计。</p>
<p>　　正确性包含<em>可行性(feasibility)</em> 。</p>
<p>　　若无法满足正确性，则需求输入存在问题。</p>
<p>　　正确性不包含但应逻辑蕴含设计的一些其它性质。若无法实现，则具体性质的定义存在问题。</p>
<p>　　保持正确性作为设计评价的首要依据以使决策简单，同时能符合<a href="#%E4%BB%B7%E5%80%BC%E8%A7%82">价值判断</a>。</p>
<h5 id="完整性"><a class="header" href="#完整性">完整性</a></h5>
<p>　　正确性应蕴含<em>完整性(completeness)</em> ，即确保没有需求被遗漏。</p>
<p>　　推论：设计应包含完整的需求响应。</p>
<p><strong>原理</strong></p>
<p>　　对通用编程语言的一个完整性要求是支持<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算</a>上的<em>可表达性(expresiveness)</em> 。</p>
<p>　　这种性质被称为<em>可有效计算性(effective computability)</em> ，或 <em>Turing 完备性(Turing completeness)</em> 。在可物理实现的计算普遍遵循 <a href="https://zh.wikipedia.org/zh-cn/%E9%82%B1%E5%A5%87%EF%BC%8D%E5%9B%BE%E7%81%B5%E8%AE%BA%E9%A2%98">Church–Turing 论题(Church–Turing thesis)</a> 的情形下，这同时是<em>可计算性(computability)</em> 。以上性质一般不加分辨。</p>
<p>　　具体的语言中允许的表达的可计算性是<em>表达能力(expressive power)</em> 。另见 [Fl91] 。</p>
<p>　　特定的场合要求更弱的性质。例如，类型检查等情形需要<em>全(total)</em> 计算而确保实现总是<a href="#%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%BA%A6%E5%AE%9A">可终止</a>。这种要求在完整的实现中可通过附加的设施（用户提供的标注或证明）保证，而不应通过系统设计的规则静态地排除，否则实现是不完整的。仅在作为领域特定语言时，通过从需求中排除可计算性，静态规则作为优化是被允许的。</p>
<h5 id="一致性"><a class="header" href="#一致性">一致性</a></h5>
<p>　　正确性应蕴含一致性，即内部的逻辑无矛盾性。</p>
<p>　　推论：设计应保证一致性。</p>
<h4 id="简单性"><a class="header" href="#简单性">简单性</a></h4>
<p>　　在满足正确性的前提下，接口设计应尽可能满足简单性(simplicity)，即尽可能少地具有可被继续简化的内容。</p>
<p>　　接口设计的简单性优先于实现的简单性。</p>
<h4 id="可修改性"><a class="header" href="#可修改性">可修改性</a></h4>
<p>　　<em>可修改性(modifiablity)</em> ：在满足需求的前提下，修改应尽可能少地有碍于其它的接口。</p>
<p>　　这是<a href="#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>的推论。</p>
<h4 id="避免抽象泄漏"><a class="header" href="#避免抽象泄漏">避免抽象泄漏</a></h4>
<p>　　<em>泄漏的抽象(leaky abstraction)</em> 指抽象的底层复杂性没有被抽象合理地<a href="#%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F">隐藏</a>，而在一定程度上构成了利用抽象时的不必要的依赖。</p>
<p>　　这种<em>抽象泄漏(abstraction leak)</em> 的结果直接和<a href="#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>、<a href="#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99">关注点分离原则</a>和<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>冲突。</p>
<p>　　同时，抽象的有效性被削弱，泄漏构成的不被预期的依赖难以满足<a href="#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>；只要有避免抽象泄漏的方法，就不满足<a href="#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>。</p>
<p>　　因此，只要可能，避免抽象泄漏。</p>
<p><strong>注释</strong> 在信息安全意义上，抽象泄漏还可能提供难以抵御的附加的攻击信道。</p>
<h4 id="关注资源限制"><a class="header" href="#关注资源限制">关注资源限制</a></h4>
<p>　　为了可实现性，<em>宿主(host)</em> 系统对总的资源（典型地，运行程序需要的存储）有<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定</a>的上限。</p>
<p>　　除此之外，接口抽象不附加接口语义要求以外的限制。</p>
<p>　　这个原则同时利于满足<a href="#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>和<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>。而不遵循这个原则的设计在接口描述上违反<a href="#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>。</p>
<p>　　在允许实现的前提下，附加具体<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">特性</a>上的使用限制（如 [ISO C] ）可放宽对实现的要求；但无原则地随意选取此处的限制不足以直接证明具体的限制的有效性，而依赖实际实现的情况才能判断，造成<a href="#%E9%81%BF%E5%85%8D%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F">抽象泄漏</a>。</p>
<p><strong>注释</strong> 实例：<a href="https://software-lab.de/doc/faq.html#lambda">PicoLisp</a> 使用符合此原则的设计。</p>
<h4 id="开放性"><a class="header" href="#开放性">开放性</a></h4>
<p>　　<em>开放性(openness)</em> ：除非另行指定，不假定实体不存在。</p>
<p>　　这个原则主要用于建模(modeling) 的依据。对一般的模型，这个原则称为<a href="https://zh.wikipedia.org/zh-cn/%E5%BC%80%E6%94%BE%E4%B8%96%E7%95%8C%E5%81%87%E5%AE%9A">开放世界假定(open-world assumption)</a>。</p>
<p>　　与之相对，<a href="https://zh.wikipedia.org/zh-cn/%E5%B0%81%E9%97%AD%E4%B8%96%E7%95%8C%E5%81%87%E5%AE%9A">封闭世界假定(closed-world assumption)</a> 需要提前设置一个<em>全集(universe)</em> 以保持至少在逻辑的意义上<a href="#%E6%AD%A3%E8%A7%84%E6%80%A7">合规</a>。</p>
<p>　　开放世界的元素的全集是模型的结构化规则推断得到的，而非名义上的定义决定。这同时称为模型的语言的<em>论域(universe of disclosure)</em> 。</p>
<p><strong>原理</strong></p>
<p>　　封闭世界假定表面上可能简化实现，但在一般的模型中是不必要的，因为保持问题合规性的论域应已由清晰的需求描述规范，不应为此阻碍实现<a href="#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>。</p>
<p>　　使用封闭世界假定的一个主要实用意义是使模型在有限的信息下能推理出逻辑上更强的结论。在重视结论的知识系统中，这通常是一种优化；但在重视<a href="#%E5%AE%8C%E6%95%B4%E6%80%A7">表达能力</a>（而通过其它方式辅助求解问题）的通用模型中，这种前提是一种直接的限制。同时，封闭世界假定的优化不保证对所有输入有效，对否定输入还可能导出一些矛盾。</p>
<p><strong>注释</strong></p>
<p>　　开放世界包含的元素的外延及其语言的论域伴随随<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>的修改而改变。</p>
<p>　　开放世界不限制论域中的某个子集是封闭的。例如，论域中可能存在某个子集的所有元素通过一定方式被枚举。</p>
<h3 id="结构和依赖原则"><a class="header" href="#结构和依赖原则">结构和依赖原则</a></h3>
<h4 id="接口设计和实现分离"><a class="header" href="#接口设计和实现分离">接口设计和实现分离</a></h4>
<p>　　语言设计独立于<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言实现</a>。</p>
<p>　　这是同时应用<a href="#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>和<a href="#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99">关注点分离原则</a>的推论。</p>
<p>　　这种分离允许<a href="#%E9%81%BF%E5%85%8D%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F">避免抽象泄露</a>。</p>
<p>　　典型地，使用提供接口抽象层作为必要构造的架构方法，即分层设计。</p>
<h4 id="最小特权原则"><a class="header" href="#最小特权原则">最小特权原则</a></h4>
<p>　　<a href="https://zh.wikipedia.org/zh-cn/%E6%9C%80%E5%B0%8F%E6%9D%83%E9%99%90%E5%8E%9F%E5%88%99">最小特权原则(principle of least privilege, PoLA)</a> ：除非有必要，接口抽象不提供满足需求以外的其它信息和资源。</p>
<p>　　这是<a href="#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>在限制适用领域前提下的等价表述之一，用于避免不必要的访问路径引入额外的安全(safety) 风险，更容易满足（针对恶意使用风险的）安全性(security) 和可信性保证相关的需求。</p>
<p>　　实质上提供例外的必要性之一是接口正确性：不附加不存在于需求以外的安全设计；根据<a href="#%E5%8F%AF%E4%BF%AE%E6%94%B9%E6%80%A7">可修改性</a>，这应是实现细节。</p>
<h4 id="最小依赖原则"><a class="header" href="#最小依赖原则">最小依赖原则</a></h4>
<p>　　最小依赖原则(principle of least dependencies) ：除非有必要，接口实现仅使用必要的依赖。</p>
<p>　　这是<a href="#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>的推论之一，其非模式规则的输入为：</p>
<ul>
<li>已知必要的依赖较已知必要的依赖和不必要的依赖的并集要求较小的使用和维护成本。</li>
<li>这里的使用包括演绎抽象自身的推理(reasoning) 。依赖较少时，推理时需要搜索的解空间也越小。</li>
</ul>
<h5 id="单一模块依赖倒置原则"><a class="header" href="#单一模块依赖倒置原则">单一模块依赖倒置原则</a></h5>
<p>　　依赖倒置原则(dependence inversion principle) 在单一模块下包含以下含义：</p>
<ul>
<li>抽象（的接口）不应该依赖（实现）细节。</li>
<li>（实现）细节应依赖抽象（的接口）。</li>
</ul>
<p>　　这是最小依赖原则应用在不同抽象的<a href="#%E6%A8%A1%E5%9D%97%E5%8C%96">模块化设计</a>中使用以下公设的推论：</p>
<p>　　抽象是细节包含的子集，依赖抽象的接口较依赖实现细节具有更少的依赖。</p>
<h4 id="可复用性"><a class="header" href="#可复用性">可复用性</a></h4>
<p>　　设计应具有<em>可复用性(reusability)</em> ：高层抽象设计的实现应包括复用此设计的实现的设计。</p>
<p>　　这是<a href="#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>的推论之一，其非模式规则的输入为以下公设：</p>
<p>　　一般地，高层抽象设计和复用此设计的实现较单一的高层设计的实现更复杂。</p>
<p>　　此前提条件由对需求工作量可行性分析中的度量验证总是成立。</p>
<p>　　推论：除非必要，不分离抽象设计的实现和复用此设计的实现的设计，避免复杂性。</p>
<p>　　全局意义上的不分离设计不违反<a href="#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99">关注点分离原则</a>。</p>
<p><strong>注释</strong></p>
<p>　　典型实例：语言是一种高层抽象设计，语言的<em>库(library)</em> 是一种复用语言的设计。因此，语言实现应包括库设计。</p>
<p>　　另一个实例是<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>设计复用<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>的<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>。</p>
<h4 id="可组合性"><a class="header" href="#可组合性">可组合性</a></h4>
<p>　　<em>组合(composition)</em> 是一种特定形式的涉及多个实体的复用，允许复用时不修改被复用的其它实体。</p>
<p>　　<em>可组合(composability)</em> 原则：接口的设计应允许不同设计之间的组合满足这些设计响应以外的需求。</p>
<p>　　这是<a href="#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>的推论之一，其非模式规则的输入为以下过程推断得到的引理。</p>
<p>　　公设：一般地，在存在充足基础解决方案的情形下，组合现有解决方案的设计较重新给出不依赖这些解决方案的设计的解节约成本。</p>
<p>　　应用<a href="#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>，得到引理：</p>
<p>　　一般地，在存在充足基础解决方案和满足需求限制的情形下，组合现有解决方案的设计优于重新设计。</p>
<p>　　即提升可组合性可减少实现被<a href="#%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7">复用</a>的设计的成本。</p>
<h3 id="接口设计性质和原则"><a class="header" href="#接口设计性质和原则">接口设计性质和原则</a></h3>
<h4 id="统一性"><a class="header" href="#统一性">统一性</a></h4>
<p>　　接口的设计应具有<em>统一性(uniformity)</em> ：尽可能避免特例。</p>
<p>　　这是要求<a href="#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>的推论之一，以<a href="#%E4%B8%80%E8%87%B4%E6%80%A7">一致性</a>作为非模式规则输入。</p>
<p>　　无限制的特例要求指定更多的附加规则避免潜在的违反一致性的风险，而违反这个要求。</p>
<p>　　因为不需要特设只有对象语言中可用的规则，<a href="#%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7">复用元语言规则</a>有利于实现统一性。</p>
<p>　　以统一的方式复用元语言和对象语言公共设施在<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">语法</a>设计上称为<em>光滑性(smoothness)</em> ，而这可推广到<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">语义</a>上（另见<a href="#%E6%AD%A3%E4%BA%A4%E6%80%A7">正交性</a>），以避免对<em>抽象能力(power of abstraction)</em> 的限制([Shu10] §1.1.2) 。</p>
<p><strong>原理</strong></p>
<p>　　在语言设计上，这类似 [R<sup>n</sup>RK] 的设计原则 G1 ：</p>
<ul>
<li>G1a 对象状态(object status) ：语言操作<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>。</li>
<li>G1b 可扩展性(extensibility) ：用户定义的设施能重现内建<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">特性</a>的<em>能力(capability)</em> 。</li>
</ul>
<p>　　以上原则在 NPL 中略有变化。</p>
<p>　　同 [R<sup>n</sup>RK] ，被 G1b 重现能力的特性是内建的(built-in) 。这不同于如 [R<sup>n</sup>RK] G2 指定的基本的(primitive) 特性。</p>
<p>　　[R<sup>n</sup>RK] 的基本特性指不要求作为派生的(derived) ，即以<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>程序实现的特性。而内建特性适合整个<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规范</a>的接口设计约定，不论其实现是否被派生。不被要求重现的部分是实现细节。</p>
<p>　　但是，因为基本特性不要求能通过对象语言特性的组合实现，在不考虑派生特性的可实现性时，G1b 不会限定基本特性的能力。</p>
<p>　　整体上的 G1b 在和<a href="#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>冲突时不被要求。这也避免了 [R<sup>n</sup>RK] §0.1.1 指出的“妥协”。</p>
<p>　　因为语言规范不依赖使用<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>表达，G1b 仅表示用户使用语言的扩展，不表示语言自身的可扩展性；后者通过<a href="#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">满足需求的能力</a>和强调支持<a href="#%E5%BC%80%E6%94%BE%E6%80%A7">开放性</a>体现。</p>
<p>　　仅通过<a href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>实现的这种原则在 NPL 的设计中不被视为必要。但偏离这个原则的设计一般同样是不必要的。</p>
<p><strong>注释</strong></p>
<p>　　关于 G1a 的改变，详见<a href="#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">一等实体和一等对象</a>。</p>
<h4 id="适用性"><a class="header" href="#适用性">适用性</a></h4>
<p>　　设计应提供<em>适用性(usability)</em> ：合乎预期满足的问题领域的<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">特性</a>。</p>
<p>　　对通用目的的领域，应进行权衡。</p>
<p><strong>注释</strong></p>
<p>　　这个原则存在以下的侧重不同使用方式或场景的具体表述。</p>
<p>　　结合用户的经验，这个规则的变体是之一<a href="#%E6%9C%80%E5%B0%8F%E6%83%8A%E5%A5%87%E5%8E%9F%E5%88%99">最小惊奇原则</a>，强调降低接口的学习和适应成本。</p>
<h5 id="易预测性"><a class="header" href="#易预测性">易预测性</a></h5>
<p>　　设计应符合<em>易预测性(predictability)</em> ：允许但难以偶然实现的危险操作。</p>
<p>　　同 [R<sup>n</sup>RK] 的设计原则 G3 。</p>
<p>　　这里的危险的操作指引起较大代价的不预期或无法预期结果的操作。</p>
<p>　　这是<a href="#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>和<a href="#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>的推论，包含两方面：</p>
<ul>
<li>避免危险操作的风险是<a href="#%E6%AD%A3%E8%A7%84%E6%80%A7">正规性</a>和<a href="#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>的推论。</li>
<li>不直接禁止危险的操作以满足上述的允许变化的要求。</li>
</ul>
<p>　　避免危险的操作在许多上下文中可减少程序中易错(error-prone) 的实现的风险。</p>
<h5 id="可用性"><a class="header" href="#可用性">可用性</a></h5>
<p>　　一旦提供<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">特性</a>，应提供<em>可用性(availablity)</em> ：保证一定程度的典型场景下能被使用。</p>
<p>　　绝大多数情形都不能使用的特性是对接口设计的一种浪费，很难符合也通常不符合<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>。</p>
<p>　　可用性的概念有时也指抽象和实体具有的符合这个原则的属性。</p>
<h4 id="最小惊奇原则"><a class="header" href="#最小惊奇原则">最小惊奇原则</a></h4>
<p>　　最小惊奇原则(principle of least astonishment)：在保持合理性的前提下，若能评估目标用户的接受能力，避免违反其直觉的设计。</p>
<p>　　其中，合理性至少应蕴含<a href="#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>，一般也蕴含<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>和<a href="#%E9%80%82%E7%94%A8%E6%80%A7">适用性</a>同时不违反其它原则（特别应注意尽量保持<a href="#%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7">可复用性</a>和<a href="#%E5%8F%AF%E7%BB%84%E5%90%88%E6%80%A7">可组合性</a>）。</p>
<p>　　这个原则主要适用于人机交互接口的设计，但也适用于一般的 <a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 。</p>
<p>　　推论：<a href="https://zh.wikipedia.org/zh-cn/%E7%BA%A6%E5%AE%9A%E4%BC%98%E4%BA%8E%E9%85%8D%E7%BD%AE">约定优于配置(convention over configuration)</a> ：约定接口的合理的默认<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">行为</a>，而不是隐藏其行为而提供配置另行实现。</p>
<h4 id="正交性"><a class="header" href="#正交性">正交性</a></h4>
<p>　　在满足<a href="#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>的前提下，接口的设计应具有<em>正交性(orthogonality)</em> ：根据需求适当分解为<a href="#%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7">排除冗余和重复</a>且<a href="#%E5%8F%AF%E7%BB%84%E5%90%88%E6%80%A7">能合理组合</a>的部分。</p>
<p>　　这是<a href="#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>和<a href="#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99">关注点分离原则</a>在接口设计上的应用。</p>
<p>　　一般地，正交的设计使相同目的可使用更精简的接口组合方式实现。这也使接口具有更强的<a href="#%E7%BB%9F%E4%B8%80%E6%80%A7">抽象能力</a>。</p>
<h3 id="方法论"><a class="header" href="#方法论">方法论</a></h3>
<p>　　<em>方法论(methodology)</em> 是严格独立<a href="#%E4%BB%B7%E5%80%BC%E8%A7%82">价值判断</a>的规则，是关于<a href="#%E4%BB%B7%E5%80%BC%E8%A7%82">价值判断</a>结果参数化的判断规则。</p>
<p>　　不同的价值判断的结果作为方法论输入，决定是否适用此方法。</p>
<p>　　其它方法详见以下各节。</p>
<p><strong>注释</strong></p>
<p>　　一些规则因其主要表述包含价值判断而不在此归纳为方法论，尽管其中一些表述中的前提可以被参数化（如<a href="#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">奥卡姆剃刀</a>的“如无必要”的具体必要条件）。</p>
<h4 id="避免不成熟的优化"><a class="header" href="#避免不成熟的优化">避免不成熟的优化</a></h4>
<blockquote>
<p>Premature optimization is the root of all evil (or at least most of it) in programming.</p>
</blockquote>
<!-- markdownlint-disable-next-line MD049 -->
<p>　　— <em>The Art of Computer Programming</em></p>
<p>　　原始含义适合计算机程序设计中以效率为目标的决策。</p>
<p>　　扩展的外延适用于一般需求，要求：</p>
<ul>
<li>适时收缩理论长度以照顾可操作性。
<ul>
<li>注意断言一个优化过早自身可能就是一个过早的优化。</li>
</ul>
</li>
<li>主动适应需求变更。
<ul>
<li>不同时明确全部的具体需求，只限定需求范围：能使用计算机实现部分语义的任务。</li>
</ul>
</li>
</ul>
<h4 id="封装"><a class="header" href="#封装">封装</a></h4>
<p>　　<em>封装(encapsulation)</em> 是接口设计的合理性准则。</p>
<p>　　封装是<a href="#%E4%B8%8D%E5%8F%AF%E5%88%86%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">不可分的同一性</a>的一种实现方式：封装提供的接口以下的所有实现在接口从使用者的角度都是不可分的。</p>
<p><strong>注释</strong> 若存在使用者可感知的<a href="#%E9%81%BF%E5%85%8D%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F">抽象泄漏</a>，这种实现可能失效。</p>
<p>　　以接口的预设风格的价值判断为输入，封装性要求接口满足以下<em>多态性(polymorhism)</em> ：</p>
<p>　　给定接口的替代接口，则替代接口应能代替原接口，当且仅当不引起非预期的可观察的差异。</p>
<p>　　在语言设计中，去除风格参数化的这条原则被作为 <a href="https://zh.wikipedia.org/zh-cn/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99">LSP(Liskov Substitution Principle)</a> 。</p>
<p>　　参数化风格限定并非任意符合 LSP 的接口设计都符合封装性要求。这便于从不期望的设计中剔除不符合其它原则的设计。</p>
<p><strong>注释</strong></p>
<p>　　一些程序设计语言中的封装提供符合 LSP 的<a href="https://zh.wikipedia.org/zh-cn/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">面向对象</a>风格的设施。这些设施把数据和代码组合在一起提供，但仅仅组合并不体现封装性。因此，同时具有<a href="#%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F">信息隐藏</a>的<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">特性</a>，如 [ISO C++] 的类成员的访问控制的机制，被认为是典型的封装。</p>
<p>　　即便如此，封装在严格意义上和信息隐藏是相互独立的。即便语言不提供信息隐藏而仅仅指定违反封装性不关心实现细节的假设的操作<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">未定义</a>，也不失去封装性。事实上，[ISO C++] 中，使用 <code>reinterpre_cast</code> 无视类的访问控制就是这种例子。</p>
<p>　　另一方面，LSP 事实上关于<a href="#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>，不限于以类作为类型的基于类的面向对象风格，实际外延更广。</p>
<h4 id="信息隐藏"><a class="header" href="#信息隐藏">信息隐藏</a></h4>
<p>　　<a href="https://zh.wikipedia.org/zh-cn/%E8%B3%87%E8%A8%8A%E9%9A%B1%E8%97%8F_%28%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8%29">信息隐藏(information hiding)</a> 保持不需要公开的信息不被公开，以使设计符合<a href="#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>并支持<a href="#%E9%81%BF%E5%85%8D%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F">避免抽象泄漏</a>。</p>
<p>　　适用于接口及其实现。</p>
<p>　　信息隐藏以是否需要公开信息的<a href="#%E4%BB%B7%E5%80%BC%E8%A7%82">价值判断</a>（特别地，关于如何符合最小接口原则）的结果参数化。</p>
<p><strong>注释</strong></p>
<p>　　<a href="#%E5%B0%81%E8%A3%85">封装</a>的接口通常有助于实现信息隐藏。直接限定避免接口规格具有过多的信息，是另一种直接的实现方式。</p>
<p>　　例如，基于类的<a href="https://zh.wikipedia.org/zh-cn/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">面向对象</a>通过对<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">名称</a>组成的表达式限制对类成员的外部访问，隐藏了类成员的信息，同时提供<a href="#%E5%B0%81%E8%A3%85">封装性</a>。</p>
<p>　　其它方式可直接不在外部提供任何访问被封装实体的名称，如 [R<sup>n</sup>RK] 的封装类型(encapsulate type) 和 <a href="https://github.com/tc39/proposal-class-fields/blob/main/PRIVATE_SYNTAX_FAQ.md#how-can-you-model-encapsulation-using-weakmaps">[ECMAScript] 通过 <code>WeakMap</code> 实现的封装</a>。这些封装也同时实现了被封装实体的信息隐藏。</p>
<p>　　即便如此，如关于封装的讨论指出的，封装不一定需要实现信息隐藏。更一般地，信息隐藏的目的也不一定是提供封装。例如，系统的安全性可能直接在需求上要求隐藏特定信息，不论这种信息是否关于某种接口的实现。</p>
<h4 id="模块化"><a class="header" href="#模块化">模块化</a></h4>
<p>　　接口和实现的设计应具有足够的模块化(modularity) ：被划分为若干保持联系的组件即<em>模块(module)</em> ，至少满足<a href="#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>和<a href="#%E5%8F%AF%E7%BB%84%E5%90%88%E6%80%A7">可组合性</a>，并强调实现<a href="#%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7">可复用性</a>。</p>
<p>　　模块化设计通常有利于使设计具有<a href="#%E6%AD%A3%E4%BA%A4%E6%80%A7">正交性</a>，但模块化相对可复用性，更侧重可组合性。</p>
<p>　　参数化的输入是需被评估模块化程度的结构设计（包括模块的<em>粒度(granularity)</em> 和组成部分的依赖关系）相对给定需求的实现质量的价值判断。</p>
<h3 id="其它推论和比较"><a class="header" href="#其它推论和比较">其它推论和比较</a></h3>
<p>　　从对<a href="#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>的强调可知，较<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>优先考虑<em>通用性(generality)</em> 。</p>
<p>　　这和 [R<sup>n</sup>RK] 中讨论的设计哲学虽然相当不同，但仍允许和 Kernel 具有相似的特性。</p>
<p>　　作为典型的 NPL 的一个<a href="#%E7%95%A5%E7%A7%B0">派生实现</a>，<a href="#npla1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80">NPLA1</a> 具有以下和 Kernel 相似的核心设计：</p>
<ul>
<li>相似的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>算法（差异详见 <a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">NPLA1 求值算法</a>）。</li>
<li><a href="#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">环境</a>可作为<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>。</li>
<li>支持 <a href="#vau-%E6%8A%BD%E8%B1%A1">vau 抽象</a>，且使用<a href="#%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83%E6%8F%90%E4%BE%9B%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">词法作用域</a>。</li>
<li>强调支持<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>中的<a href="#%E5%85%B6%E5%AE%83%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8F%82%E8%80%83">显式求值风格</a>及<a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>求值前后的不同。</li>
<li>强调直接求值而非传统 LISP 方言的 <a href="#%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%A3%8E%E6%A0%BC"><code>quote</code></a> 。</li>
</ul>
<h1 id="规格说明"><a class="header" href="#规格说明">规格说明</a></h1>
<p>　　在<a href="#%E9%99%84%E5%BD%95">附录</a>之前的以下章节给出 NPL 的正式规格说明的公共部分，即<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规范</a>。</p>
<p>　　本文档仅提供部分<a href="#%E7%95%A5%E7%A7%B0">派生实现</a>的规格说明。关于其它具体规格说明，详见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p>　　在不和其它<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>冲突时，派生实现可能补充或覆盖更确切范围中生效的定义和具体语言规则。</p>
<h2 id="略称"><a class="header" href="#略称">略称</a></h2>
<p>　　仅在不致混淆时使用。</p>
<ul>
<li>实现(implementation) ：<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言实现</a>。</li>
<li>环境(environment) ：<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">实现环境</a>。
<ul>
<li>外部环境：（当前描述的系统边界的）外部的实现环境。</li>
</ul>
</li>
<li>派生实现(derived implementation) ：<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">派生语言实现</a>。</li>
</ul>
<h2 id="补充领域定义"><a class="header" href="#补充领域定义">补充领域定义</a></h2>
<p>　　以下术语的定义参见<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">计算机体系结构</a>。</p>
<ul>
<li>指令</li>
<li>指令集</li>
<li>ISA</li>
</ul>
<h1 id="整体设计"><a class="header" href="#整体设计">整体设计</a></h1>
<p>　　一些<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>可能显式地由<a href="#%E7%95%A5%E7%A7%B0">派生实现</a>指定，或补充具体规则。</p>
<p><strong>注释</strong></p>
<p>　　具体讨论设计策略另见需求描述文档。</p>
<p>　　另见<a href="#%E9%A2%86%E5%9F%9F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">设计原则</a>的讨论；对本章内容的描述的理解应符合其中的原则。</p>
<h2 id="模型"><a class="header" href="#模型">模型</a></h2>
<p>　　可用计算机实现的语言首先是<em>计算的模型(model of computation)</em> ，或者<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算模型</a>，对<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算</a>进行建模得到。</p>
<p>　　与之相关地，为计算机系统建模作为<em>计算机的模型(model of computer)</em> ，需对有限计算资源的现实进行适应。</p>
<p>　　这些模型可使用<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">形式方法</a>建立，即<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">形式模型</a>。</p>
<p>　　被计算机实现的语言应同时具有这两方面的特征。</p>
<p>　　作为实用的语言，语言还应强调提供<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">可编程性</a>以允许用户利用；这样的语言称为<em>编程语言(programming language)</em> 。</p>
<p>　　本设计尝试在语言的原生设计中应对现有语言缺乏模型问题以避免这些妥协带来的消极影响，同时取得比非模型方法更强的可用性。</p>
<p>　　这种可用性至少体现在语义的精确性可通过模型直接决定；仅为精确性，不需要另行补充模型设计（尽管现有模型可能仍然是不完全形式化的）。</p>
<p><strong>原理</strong></p>
<p>　　以无限的计算资源为前提，理想的模型无法被物理地完全实现，无法直接作为计算机实现的语言的模型。</p>
<p>　　同时，这些模型仅适合对计算建模，并没有强调允许可编程性的实现；扩充可编程设计而保持模型自身的主要性质相当困难。</p>
<p>　　因此，基于计算的模型适配编程语言的设计必然需要妥协：对这些模型的裁剪和补充能提供若干编程语言的模型，但这无可避免地显著地复杂化模型自身，且不利用用户使用简单有效的规则实现通用目的上的可编程性。</p>
<p>　　事实上，使用严格形式化的模型描述编程语言的<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">行为</a>较编程语言自身的发展更落后：</p>
<ul>
<li>大部分编程语言并没有使用模型支持它们的设计。</li>
<li>现实的实用语言，特别地，包括所有主流的<em>工业语言(industrial language)</em> ，几乎都没有在<a href="../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">语言规范</a>中给出完整的模型。</li>
<li>通常的实用语言只形式化基本的<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">语法</a>上的规则，无法指导用户精确理解程序的含义。</li>
</ul>
<p>　　这些落后集中体现在的<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">语义</a>模型的缺失，使对编程语言语义的判断取决于规格说明中模型外规则的理解。</p>
<p>　　后验(postpone) 的语义模型可以使用不同<a href="#%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E6%96%B9%E6%B3%95">形式语义方法</a>设计，但和语言规范差异的一些本应避免的附加工作，并且通常难以完整地作为标准规格的描述。</p>
<p><strong>注释</strong></p>
<p>　　Turing 机、<a href="https://zh.wikipedia.org/zh-cn/%CE%9B%E6%BC%94%E7%AE%97">无类型 λ 演算(untyped lambda calculus)</a> 等早期计算模型不考虑有限计算资源限制。</p>
<h3 id="计算复杂度约定"><a class="header" href="#计算复杂度约定">计算复杂度约定</a></h3>
<p>　　特定的算法过程具有<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算复杂度</a>要求。除非另行指定：</p>
<ul>
<li>这些复杂度是任意避免符合<a href="#%E9%94%99%E8%AF%AF">错误条件</a>的方式调用时求值蕴含的<em>渐进(asymptotic)</em> 时间复杂度。</li>
<li>若指定边界，明确的输入规模以<em>哑变量(dummy)</em> <tt>n</tt> 表示。</li>
<li>指定复杂度的计算保证可<em>终止(terminate)</em> 。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　算法过程也适用<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>上的操作。</p>
<h3 id="资源可用性基本约定"><a class="header" href="#资源可用性基本约定">资源可用性基本约定</a></h3>
<p>　　在<a href="#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机</a>的配置中，任意通过<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80"><em>元语言(metalanguage)</em></a> 语法描述的资源总是可用的。</p>
<p>　　为避免对具体资源的总量和实现细节做出假设，除此之外，本设计只要求模型蕴含<a href="#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权</a>语义（即便不严格形式化——注意作为元语言的描述模型使用的形式语言仍然可能是实现细节）。</p>
<p>　　具体计算机系统的实现中，保证基本可用的资源被直接映射到程序执行(execution) 的环境中。尽管和适配的软件环境相关，这最终由硬件实现物理地保证。</p>
<p><strong>原理</strong></p>
<p>　　在严格的<a href="#%E5%85%B3%E6%B3%A8%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6">资源限制要求</a>下，<a href="#%E6%A8%A1%E5%9E%8B">模型</a>不能隐藏预设的无限资源的前提。</p>
<p>　　因此，有必要做出基本的<a href="#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>约定以允许表达明确的要求以避免不可实现。</p>
<h2 id="适用领域"><a class="header" href="#适用领域">适用领域</a></h2>
<p>　　为尽可能解决<a href="#%E6%A8%A1%E5%9E%8B">模型</a>相关的问题，优先以<a href="#%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0">通用目的</a>而不是<em>领域特定(domain-specific)</em> 语言作为评估<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言特性</a>设计的参考原则。</p>
<p>　　领域特定语言的特性应能合理地从支持通用目的的特性中<a href="../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">派生</a>，且不影响实际的可用性。</p>
<h2 id="形式语义方法"><a class="header" href="#形式语义方法">形式语义方法</a></h2>
<p>　　<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">形式语义</a>方法是建立<a href="#%E6%A8%A1%E5%9E%8B">语义模型</a>的形式方法。</p>
<p>　　形式语义方法主要有<em>公理语义(axiomatic semantics)</em> 、<em>指称语义(denotational semantic)</em> 和<em>操作语义(operational semantics)</em> 。</p>
<p>　　操作语义可分为在模型中指定具体<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">规约</a>步骤状态的<em>结构化操作语义(structural operational semantics)</em>（或<em>小步(small-step)</em> 语义），及仅指定规约的输入和输出的<em>自然语义(natural semantics)</em>（或<em>大步(big-step)</em> 语义）。</p>
<p><strong>注释</strong> <a href="#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机</a>和<a href="#%E9%A1%B9%E9%87%8D%E5%86%99%E7%B3%BB%E7%BB%9F">演算</a>是使用操作语义的模型的两类例子，虽然后者也可以对<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>以外的表示建模而实现其它的语义方法。</p>
<p>　　非确定语义：经验语义，不需要使用自然语言解释的部分。</p>
<p>　　本文档不直接给出形式语义。<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>确定的经验语义可在一定条件下转写为上述形式语义方法表达的形式。</p>
<h2 id="程序实现"><a class="header" href="#程序实现">程序实现</a></h2>
<p>　　<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">程序</a>是语言的具体派生。实现程序即在语言的基础上指定具体派生规则。</p>
<p>　　<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言实现</a>外的程序是<em>用户程序(user program)</em> 。</p>
<p>　　以程序或另行指定的其它形式实现的可复用程序被归类为<a href="#%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7">库</a>。</p>
<p><strong>注释</strong> 一般地，不论是语言实现还是用户程序，都可能使用库。</p>
<p>　　除非另行指定，一个程序支持多个库的实例，之间不共享内部的状态。</p>
<p>　　语言特性包含不依赖库的<em>核心语言特性(core language feature)</em> 和<em>库特性(library feature)</em> 。</p>
<h2 id="规范模型"><a class="header" href="#规范模型">规范模型</a></h2>
<p>　　NPL 是抽象的语言，没有<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">具体语言实现</a>，但一些直接影响实现表现形式的规则被本节限定。</p>
<p>　　NPL 的实现可进行<em>抽象解释(abstraction interpret)</em> ，其目标不一定是<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">程序</a>。</p>
<p>　　任一 NPL 实现（和派生实现）的<a href="../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">符合性</a>由以下 NPL 符合性规则定义：文档指定的满足对实现的<a href="../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">要求</a>的<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>子集，包括本节、<a href="#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95">基本文法</a>、<a href="#npl-%E5%85%AC%E5%85%B1%E8%AF%AD%E4%B9%89">语义</a>和其它派生实现定义的规则。</p>
<p>　　这类规则总是包含对应语言的<a href="#npl-%E5%85%AC%E5%85%B1%E8%AF%AD%E4%B9%89">语义的 NPL 公共子集</a>，且蕴含<a href="#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">实现行为</a>的要求。</p>
<p>　　<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>约定的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定</a>的程序或实现的属性及实现行为在符合性要求上等价。满足这类规则的前提下，实现选取特定的未指定的属性及对<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定行为</a>的特定实现的选择不影响实现的符合性。</p>
<p><strong>原理</strong></p>
<p>　　基于抽象机可直接定义最小的符合性要求，如 <a href="https://eel.is/c++draft/intro.abstract#6">C++ 的规则</a>。</p>
<p>　　NPL 没有直接在此定义同等具体的规则，而以一般的要求取代。这允许派生实现对不同的具体规则<a href="#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">进行补充和调整</a>。特别地，这允许<a href="#%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E6%96%B9%E6%B3%95">不同的方式</a>提供语义规则。</p>
<p>　　蕴含实现行为的要求的一个主要例子是关于<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">状态</a>的规则。除了允许由实现定义和派生实现指定的不同，这实质上提供和上述具体规则等价的默认情形，而简化派生实现需要的对语言规则的补充和调整。</p>
<h3 id="实现的执行阶段"><a class="header" href="#实现的执行阶段">实现的执行阶段</a></h3>
<p>　　一个 NPL 的完整实现应保证行为能符合以下的<em>执行阶段(phase of execution)</em> ：</p>
<ul>
<li><em>分析(analysis)</em> 阶段：处理代码，取得适当的 <a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">IR</a> 。</li>
<li><em>（目标）代码生成(target code generation)</em> ：以 IR 作为输入，生成可被其它阶段执行的代码，即<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">目标代码(target code)</a> 。
<ul>
<li><strong>注释</strong> 一般意义的代码生成可以有多个子阶段，包括多种内部 IR 的翻译，直至得到<em>最终目标代码(final target code)</em> 作为输出。</li>
</ul>
</li>
<li>运行：运行生成的最终目标代码。
<ul>
<li><strong>注释</strong> 最终目标代码的形式视不同而定，可能有附加的封装格式。例如<a href="../Terminology.zh-CN.html">编译器</a>的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">目标代码(object code)</a> 经<em>链接(linking)</em> 为可<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">执行</a>的<em>映像(image)</em> ，被<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">加载</a>后形式才能运行。</li>
</ul>
</li>
</ul>
<p>　　其中分析阶段是任意实现必要的，依次包含：</p>
<ul>
<li>词法分析(lexical analysis) ：必要时转换字符编码；<em>转义(escape)</em> 并提取记号。</li>
<li>语法分析(syntactic analysis) ：语法检查（检验语法<a href="#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>）并尝试匹配记号和语法规则中的<a href="#%E8%AF%AD%E6%B3%95">语法元素</a>。</li>
<li>语义分析(semantic analysis) ：语义检查（检验语义正确性）并实现其它语义规则。</li>
</ul>
<p>　　以上的具体阶段不要求和实际实现中的一一对应，但应保证顺序一致。</p>
<p>　　运行之前的阶段总称为<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80"><em>翻译(translation)</em></a> ，包含各个<em>翻译阶段(phase of translation)</em> 。</p>
<p>　　对有<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">宿主语言</a>支持的<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">嵌入实现</a>或目标不是程序的情况，代码生成及之后的阶段不是必须的。</p>
<p>　　宿主语言实现可提供作为<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">客户语言</a>的 NPL 的<em>本机(native)</em> 实现。</p>
<p>　　宿主语言实现提供 NPL 实现环境，同时对 NPL 环境的操作可影响 NPL 程序，这些情形都是<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元编程</a>，NPL 在此同时是<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>。</p>
<p>　　嵌入实现的宿主语言可直接运行语义分析的结果（中间表示）。</p>
<p>　　在语义不变的前提下，允许实现一次或多次翻译部分代码产生部分中间结果并复用。</p>
<p>　　<em>运行时(runtime)</em> 程序实现运行阶段。</p>
<p>　　其它可能的阶段由派生实现定义，但应满足所有阶段具有确定的全序关系，且不改变上述指定的阶段的顺序。符合这些条件的附加阶段称为扩展阶段。</p>
<p><strong>注释</strong></p>
<p>　　字符编码是被翻译的源中的二进制表示相关的模式。</p>
<h3 id="并发实现"><a class="header" href="#并发实现">并发实现</a></h3>
<p>　　一个实现可能具有计算模型意义上的<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">并发</a>属性，即<em>并发实现(concurrent implementation)</em> 。</p>
<p>　　一个实现中顺序执行以上执行阶段的一组<a href="../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">状态</a>称为一个<em>执行线程(thread of execution)</em> ，简称<em>线程(thread)</em> 。</p>
<p>　　一个实现在整个执行过程中可以有一个或多个线程被执行。是否支持多线程执行（多线程翻译和/或多线程运行）由派生实现定义。</p>
<p>　　若实现支持多线程执行，则执行阶段的状态区分不同的并发执行线程，此时具体的状态构成由实现定义。</p>
<h3 id="阶段不变量约束"><a class="header" href="#阶段不变量约束">阶段不变量约束</a></h3>
<p>　　若某些状态在某个执行阶段 k 被唯一确定为不可变状态，且在之后的状态下是<em>不变量(invariant)</em> ，则此状态称为满足 k 阶段不变量约束的。</p>
<h2 id="正确性-1"><a class="header" href="#正确性-1">正确性</a></h2>
<p>　　<em>正确性(correctness)</em> 规则约束被执行的程序，包含语法正确性和语义正确性。</p>
<p>　　当正确性规则被发现违反时，实现进入异常执行状态。</p>
<p>　　<a href="#%E7%BF%BB%E8%AF%91%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%A7%84%E5%88%99">翻译时正确性规则</a>以外的异常执行条件和状态由派生实现定义。</p>
<h3 id="翻译时正确性规则"><a class="header" href="#翻译时正确性规则">翻译时正确性规则</a></h3>
<p>　　翻译时的异常状态要求给出用于区分正常状态特定的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">行为</a>作为<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">诊断</a>，包括<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">诊断消息</a>和其它派生实现定义的<a href="#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">实现行为</a>。</p>
<p>　　语法正确性规则是翻译时正确性规则。</p>
<p>　　部分形式上的正确性规则在翻译时确保。</p>
<p>　　允许翻译时确保的形式上正确的程序是<em>合式的(well-formed)</em> ；反之<em>不合式(ill-formed)</em> 。</p>
<p>　　合式的程序符合语法和语义的正确性的规则。</p>
<p>　　其中，实现被要求确保通过翻译的程序符合语法规则和翻译时确保的<em>可诊断(diagnosable)</em> 语义规则。</p>
<p>　　不合式的程序不保证被完整地翻译，应在运行前终止执行阶段。</p>
<h3 id="错误"><a class="header" href="#错误">错误</a></h3>
<p>　　<em>错误(error)</em> 是不满足预期的正确性或其它派生实现定义的不变性质时的特定诊断。</p>
<p>　　非正确性或不满足这些不变性的条件是<em>错误条件(error condition)</em> 。</p>
<p>　　满足错误条件时，实现可<em>引起(signal)</em> 错误。</p>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RS] 中的某些版本指定错误可以不诊断不同，引起错误蕴含诊断。</p>
<h2 id="实现行为"><a class="header" href="#实现行为">实现行为</a></h2>
<p>　　实现的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">行为</a>由具有存在非特定空间上限的存储的<em>抽象机(abstract machine)</em> 描述。这种描述对应的语言的语义是<em>抽象机语义(abstract machine semantics)</em> 。</p>
<p>　　若语言规则明确特定的行为可被忽略，则被忽略之后的实现行为与之前在语言规则中视为等价。翻译的实现可选取这些等价行为中的任一具体行为。</p>
<p>　　<a href="#%E7%95%A5%E7%A7%B0">派生实现</a>可通过<a href="#%E8%A7%84%E8%8C%83%E6%A8%A1%E5%9E%8B">显式的未指定规则</a>定义附加的等价性。</p>
<p>　　不论程序是否满足<a href="#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性规则</a>，实现对程序的执行都可能存在<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未定义行为</a>，此时实现的行为不需要满足正确性规则指定的行为要求。</p>
<p>　　特定的语言规则引入未定义行为。程序的执行在适用这些规则指定的条件时，引起未定义行为。</p>
<p>　　特定的语言规则排除未定义行为的引入，以满足一定的<a href="#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>。这不排除程序的执行可能因同时使用的其它语言规则引起的未定义行为。</p>
<p><strong>注释</strong></p>
<p>　　抽象机语义是一种<a href="#%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E6%96%B9%E6%B3%95">操作语义</a>。</p>
<p>　　抽象机语义也可非形式地定义语言的正式的(normative) 语义和行为要求，例如 <a href="https://eel.is/c++draft/intro.abstract">C++ 抽象机</a> 。</p>
<h2 id="简单实现模型约定"><a class="header" href="#简单实现模型约定">简单实现模型约定</a></h2>
<h3 id="嵌入宿主语言实现"><a class="header" href="#嵌入宿主语言实现">嵌入宿主语言实现</a></h3>
<p>　　一个派生实现使用外部语言 L 简单实现模型 NPL-EMA ，若满足：</p>
<ul>
<li>以 L 为宿主语言的嵌入实现，不包含<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">扩展执行阶段</a>。</li>
<li>单一实现不保证提供<a href="#%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0">多线程执行</a>的支持，但对资源的使用进行适当的分组，以允许多个实现同时在宿主中多线程执行。</li>
</ul>
<p>　　宿主语言提供的实现环境称为宿主实现环境，简称<em>宿主环境(host environment)</em> 。</p>
<p><strong>注释</strong></p>
<p>　　若支持多线程执行，需要附加的显式同步。</p>
<p>　　这种实现可能提供宿主语言的多线程环境中对应的线程实体，其中包含需要的被隔离的资源。</p>
<p>　　其它语言的实现也可能提供类似的设计，例如 <a href="https://v8.github.io/api/head/classv8_1_1Isolate.html">V8 的 <code>v8::Isolate</code></a> 。</p>
<p>　　另见<a href="../Terminology.zh-CN.html#%E5%85%BC%E5%AE%B9%E6%80%A7%E5%92%8C%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7">可移植</a>和<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>意义上的<a href="../Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">宿主环境</a>。</p>
<h1 id="基本文法"><a class="header" href="#基本文法">基本文法</a></h1>
<p>　　本章约定基本的 NPL <a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">文法</a>规则中，包括语法及对应的基础词法。对应的语义<a href="#npl-%E5%85%AC%E5%85%B1%E8%AF%AD%E4%B9%89">在下文列出</a>。</p>
<p>　　多态文法规则：<a href="#%E7%95%A5%E7%A7%B0">派生实现</a>可完全不提供本章明确定义的词法和语法构造的支持，仅当提供同构的替代文法且符合语义规则。</p>
<p>　　本章定义的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>的正式文法以 <a href="https://zh.wikipedia.org/zh-cn/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F">BNF（Backus–Naur Form ，Backus–Naur 形式）</a>作为元语法形式地描述，且在与对象语言之间无歧义时不在终结符(terminal) 边界使用引号（即 <code>"</code> 和 <code>'</code> ）。</p>
<p><strong>注释</strong></p>
<p>　　因为这种 BNF 使用符合 <a href="https://github.com/highlightjs/highlight.js/blob/main/src/languages/bnf.js"><code>highlight.js</code> 支持的语法</a>，在 Markdown 源代码中直接使用<a href="https://github.com/highlightjs/highlight.js/blob/main/SUPPORTED_LANGUAGES.md">支持的语言别名 <code>bnf</code> 标记</a>。</p>
<h2 id="基本文法概念"><a class="header" href="#基本文法概念">基本文法概念</a></h2>
<ul>
<li>字符(character) ：组成语言代码的最小实体。</li>
<li>基本翻译单元(basic transation unit) ：作为<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">翻译</a>输入的任意连续字符的有限序列（可以是空序列）。</li>
<li>翻译单元(translation unit) ：基本翻译单元的集合，之间满足由派生实现定义的规则。</li>
</ul>
<p>　　<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">程序</a>以翻译单元或具体操作指定的以翻译单元进行<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">翻译</a>得到的其它变换形式表示。</p>
<h2 id="字符集和字符串"><a class="header" href="#字符集和字符串">字符集和字符串</a></h2>
<ul>
<li>字符集(character set) ：对一个实现而言不变的字符的有限集合。</li>
<li>基本字符集(basic character set) ：实现环境必须支持的字符集。具体由派生实现定义。</li>
<li>字符串(character string) ：字符集上的序列。</li>
</ul>
<p>　　除非另行指定，关于字符集定义的其它概念同 [ISO C++11] 对 character 和 character set 的有关定义。</p>
<p><strong>注释</strong></p>
<p>　　<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">字符编码</a>基于字符集定义。</p>
<p>　　一般地，一个翻译单元只具有同一个字符编码。</p>
<h2 id="词法规则"><a class="header" href="#词法规则">词法规则</a></h2>
<p>　　<em>词法规则(lexical rules)</em> 约定在字符基础上的最小一级的可组合为<a href="#%E8%AF%AD%E6%B3%95">语法</a>元素单位直接关联的文法规则。</p>
<p>　　约定<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>语法 <code>&lt;x&gt;</code> 表示词法元素 <code>x</code> ，<code>::=</code> 表示定义，<code>|</code> 表示析取。</p>
<h3 id="基本词法构造"><a class="header" href="#基本词法构造">基本词法构造</a></h3>
<p>　　文法：</p>
<pre><code class="language-bnf">&lt;token&gt; ::= &lt;literal&gt; | &lt;$punctuator&gt; | &lt;$identifier&gt;
</code></pre>
<ul>
<li>分隔符(delimiter) ：代码中标记特定字符序列模式的字符序列。</li>
<li>词素(lexeme) ：代码中以分隔符确定边界的字符序列。</li>
<li>记号(token) ：词素的顶级分类。</li>
</ul>
<p>　　属于记号的语法元素可以是以下的词法分类：</p>
<ul>
<li>字面量(literal) ：一种记号，参见<a href="#%E5%AD%97%E9%9D%A2%E9%87%8F">以下描述</a>。</li>
<li>标点(punctuator) ：由派生实现定义的特定字符序列的集合，可具有一定语义功能。</li>
<li>标识符(identifier) ：除字面量和标点以外的记号</li>
</ul>
<p>　　代码中邻接的分隔符和非分隔符不构成一个词素。</p>
<p>　　不在记号内包含的空白符是分隔符，而不是词素。</p>
<p>　　标点是分隔符，也是词素。</p>
<p>　　超过一个字符的标点可能在匹配字符序列确定是否构成词素时具有词法歧义。此时，应指定消歧义规则确保存在唯一可接受的匹配方式，或引起词法<a href="#%E9%94%99%E8%AF%AF">错误</a>终止翻译。</p>
<p>　　除非派生实现指定，字面量以外的记号不包含分隔符。</p>
<p>　　记号是可能附带附加<a href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90">词法分析</a>信息的词素。词法分析后得到的记号可以用词素映射到词法分类的有序对表示，但 NPL 不要求在此阶段保持分类也不限定表示的构造。</p>
<p>　　可以保证 [ISO C++11] 的 identifier 的定义，或在上述标识符中插入字符 <code>$</code> 构造得到的标识符属于 NPL 标识符。</p>
<p>　　派生实现可定义其它能构成标识符的词素。</p>
<p><strong>注释</strong></p>
<p>　　NPL 不指定超过一个字符的分隔符，因此默认没有词法歧义。派生实现可指定这些规则。</p>
<p>　　NPL 是<em>自由形式(free form)</em> 的语言，空白符原则上不构成字面量以外的词素和语义。</p>
<h3 id="转义序列和字符序列"><a class="header" href="#转义序列和字符序列">转义序列和字符序列</a></h3>
<p>　　文法：</p>
<pre><code class="language-bnf">&lt;char-escape-content-seq&gt; ::= &lt;$single-escape-char&gt; | &lt;$escape-prefix-char&gt;&lt;$escape-content-seq&gt;
&lt;char-seq&gt; ::= &lt;$literal-char&gt; | &lt;char-escape-seq&gt;
</code></pre>
<p>　　包含 <code>&lt;char-escape-seq&gt;</code> 的 <code>&lt;char-seq&gt;</code> 包括：</p>
<ul>
<li><code>\'</code></li>
<li><code>\"</code></li>
<li><code>\\</code></li>
<li><code>\a</code></li>
<li><code>\b</code></li>
<li><code>\f</code></li>
<li><code>\n</code></li>
<li><code>\r</code></li>
<li><code>\t</code></li>
<li><code>\v</code></li>
</ul>
<p>　　<code>&lt;char-seq&gt;</code> 的含义同 [ISO C++] 的对应转义序列。</p>
<p><strong>注释</strong> 这是 [ISO C++] 的 <code>&lt;simple-escape-sequence&gt;</code> 词法分类中除了 <code>"\?"</code> 的情形，也是 [R<sup>6</sup>RS] 在 <code>&lt;string element&gt;</code> 中支持的字面情形。</p>
<h3 id="字面量"><a class="header" href="#字面量">字面量</a></h3>
<p>　　文法：</p>
<pre><code class="language-bnf">&lt;literal-content&gt; ::= &lt;char-seq&gt; | &lt;literal-char-seq&gt;&lt;literal-data&gt;
&lt;code-literal&gt; ::= '&lt;literal-content&gt;'
&lt;data-literal&gt; ::= "&lt;literal-content&gt;"
&lt;string-literal&gt; ::= &lt;code-literal&gt; | &lt;data-literal&gt;
&lt;literal&gt; ::= &lt;string-literal&gt; | &lt;$derived-impldef-literal&gt;
</code></pre>
<ul>
<li>代码字面量(code literal) ：以 ' 作为起始和结束字符的记号。</li>
<li>数据字面量(data literal) ：以 " 作为起始和结束字符的记号。</li>
<li>字符串字面量(string literal) ：代码字面量或数据字面量。</li>
<li>扩展字面量(extended literal) ：由派生实现定义的非代码字面量或数据字面量的记号。</li>
<li>字面量(literal) ：代码字面量、数据字面量、字符串字面量或扩展字面量。</li>
</ul>
<p>　　派生实现定义的解释可排除代码字面量作为字符串字面量。</p>
<p><strong>原理</strong></p>
<p>　　传统的字面量一般是<a href="#%E8%8C%83%E5%BC%8F">自求值项</a>，这包括一般的字符串字面量。</p>
<p>　　代码字面量可提供非自求值项的处理方式。</p>
<h3 id="分隔符"><a class="header" href="#分隔符">分隔符</a></h3>
<p>　　以下单字符标点是 NPL 图形分隔符：</p>
<ul>
<li><code>(</code></li>
<li><code>)</code></li>
<li><code>,</code></li>
<li><code>;</code></li>
</ul>
<p>　　以下单字符标点是 NPL 分隔符：</p>
<ul>
<li>NPL 图形分隔符</li>
<li>空白符（字符串 " \n\r\t\v" 中的字符之一）</li>
</ul>
<p><strong>注释</strong></p>
<p>　　空白符同 [ISO C++] <code>std::isspace</code> 在 C 区域下的定义，不含<code>空字符(null character)</code> 。</p>
<p><strong>原理</strong></p>
<p>　　NPL 图形分隔符可不和其它字符组合而作为单独的记号。因此，这不包含构成字面量的字符 <code>'</code> 和字符 <code>"</code> 。</p>
<p>　　NPL 分隔符用于一般分隔记号（而不是识别<a href="#%E5%AD%97%E9%9D%A2%E9%87%8F">字面量</a>）的外部描述，也没有显式地包含这些字符，但词法分析仍应把按字面量规则把这些字符作为必要时区分不同记号的边界。</p>
<h3 id="词法分析"><a class="header" href="#词法分析">词法分析</a></h3>
<p>　　<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">词法分析</a>输入<a href="#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95%E6%A6%82%E5%BF%B5">翻译单元</a>，输出记号序列。</p>
<p>　　以下规则（按优先顺序）定义了词法分析转换输入为输出的步骤：</p>
<ul>
<li>反斜杠转义：连续两个反斜杠被替换为一个反斜杠。</li>
<li>引号转义：反斜杠之后紧接单引号或双引号时，反斜杠会被删除。</li>
<li>断行连接：反斜杠之后紧接换行符的双字符序列视为续行符，被删除使分隔的行组成逻辑行。</li>
<li>字面量：未被转义的单引号或双引号后进入字面量解析状态，无视以下规则，直接逐字节输出原始输入，直至遇到对应的另一个引号。</li>
<li>窄字符空白符替换：单字节空格、水平/垂直制表符、换行符被替换为单一空格；回车符会被忽略。</li>
<li>原始输出：其它字符序列逐字节输出。</li>
</ul>
<p>　　不对空字符特殊处理。</p>
<p><strong>注释</strong></p>
<p>　　因为不一定是 <a href="#%E5%88%86%E9%9A%94%E7%AC%A6">NPL 分隔符</a>，转义字符不总是分隔标识符。</p>
<h2 id="语法"><a class="header" href="#语法">语法</a></h2>
<p>　　本节指定 NPL 作为对象语言的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">语法</a>。</p>
<p>　　约定<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>语法 <code>&lt;x&gt;</code> 表示语法元素 <code>x</code> ，<code>::=</code> 表示定义，<code>|</code> 表示析取。</p>
<p>　　程序被作为<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言实现</a>组成部分的<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">语法分析</a>程序<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">规约</a>，结果能确定其和一定的语法元素匹配。</p>
<p>　　规约时应进行语法规则的检查。</p>
<p><strong>原理</strong></p>
<p>　　NPL 的基本语法更接近原始的 S-表达式，有利于简化<a href="#%E5%90%8C%E5%83%8F%E6%80%A7">同像性</a>的使用和实现。这也避免一些微妙的特性冲突和对特性的演化的的阻碍。一些 <a href="http://xahlee.info/UnixResource_dir/writ/lisp_problems.html">Lisp 方言用户存在类似的看法并认为这些设计是主要的缺陷之一</a>。</p>
<p>　　不过，<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">词素</a>中的构造不在此考虑（不限制具体的风格），例如派生实现可指定支持有 <code>#</code> 前缀的类似 Scheme 风格的词素表示字面量。构造词素也需要词素的具体表示，如字符串，才可能实现。因为词素的表示以及构造过程在此不透明，原则上不影响同像性。</p>
<h3 id="基本语法构造"><a class="header" href="#基本语法构造">基本语法构造</a></h3>
<p>　　NPL 的基本语法单元是可递归构造的<a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>，或派生实现指定的其它语法构造。</p>
<p>　　构成基本语法单元的规则参见<a href="#%E8%AF%8D%E6%B3%95%E8%A7%84%E5%88%99">词法规则</a>。</p>
<p>　　<a href="#%E7%BF%BB%E8%AF%91%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%A7%84%E5%88%99">合式</a>的<a href="#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95%E6%A6%82%E5%BF%B5">基本翻译单元</a>应是一个或多个基本语法单元。</p>
<h3 id="表达式"><a class="header" href="#表达式">表达式</a></h3>
<p>　　文法：</p>
<pre><code class="language-bnf">&lt;expression&gt; ::= &lt;atom-expression&gt; | &lt;composite-expression&gt; | &lt;list-expression&gt;
</code></pre>
<p>　　<em>表达式(expression)</em> 是受表达式语法约束的记号序列，可以是：</p>
<ul>
<li><em><a href="#%E5%8E%9F%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F">原子表达式(atom expression)</a></em></li>
<li><em><a href="#%E5%A4%8D%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F">复合表达式(composite expression)</a></em></li>
<li><em><a href="#%E5%88%97%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">列表表达式(list expression)</a></em></li>
</ul>
<p>　　构成表达式的表达式是被构成的表达式的<em>子表达式(subexpression)</em> 。</p>
<h4 id="原子表达式"><a class="header" href="#原子表达式">原子表达式</a></h4>
<p>　　文法：</p>
<pre><code class="language-bnf">&lt;atom-expression&gt; ::= &lt;token&gt;
</code></pre>
<p>　　原子表达式不能被表示为其它表达式的语法构成形式的复合。</p>
<h4 id="复合表达式"><a class="header" href="#复合表达式">复合表达式</a></h4>
<p>　　文法：</p>
<pre><code class="language-bnf">&lt;composite-expression&gt; ::= &lt;token-expression&gt; | &lt;expression-token&gt;
</code></pre>
<p>　　复合表达式是原子表达式和表达式的复合，即语法意义上的直接<em>并置连接(juxtaposition)</em> ，不在被复合的表达式之间存在其它记号。</p>
<p>　　同一个表达式可能被按原子表达式出现的位置以不同的方式规约为复合表达式。允许的规约复合表达式的方式由派生实现定义。</p>
<h4 id="列表表达式"><a class="header" href="#列表表达式">列表表达式</a></h4>
<p>　　文法：</p>
<pre><code class="language-bnf">&lt;separators&gt; ::= &lt;separator&gt; | &lt;separator&gt;&lt;separators&gt;
&lt;expressions&gt; ::= | &lt;expression&gt; | &lt;expression&gt;&lt;separators&gt;&lt;expressions&gt;
&lt;list-expression&gt; ::= &lt;left-list-bound&gt;&lt;expressions&gt;&lt;right-list-bound&gt;
&lt;left-list-bound&gt; ::= ( | &lt;extended-left-list-bound&gt;
&lt;right-list-bound&gt; ::= ) | &lt;extended-right-list-bound&gt;
</code></pre>
<p>　　其中，<code>&lt;separator&gt;</code> 是 <a href="#%E5%88%86%E9%9A%94%E7%AC%A6">NPL 分隔符</a>。</p>
<p>　　列表表达式是在其他表达式的序列（可能为空）左右附加一组 <code>&lt;left-list-bound&gt;</code> 和 <code>&lt;right-list-bound&gt;</code> 作为边界构成的表达式。</p>
<p>　　<code>&lt;left-list-bound&gt;</code> 和 <code>&lt;right-list-bound&gt;</code> 是不同的标点。</p>
<p>　　边界为 <code>(</code> 和 <code>)</code> 的表达式是基本列表表达式。其它可能的边界由派生实现定义，构成扩展列表表达式。</p>
<p><strong>注释</strong></p>
<p>　　对 <code>&lt;list-expression&gt;</code> 的定义，以<a href="#npl-%E5%85%AC%E5%85%B1%E8%AF%AD%E4%B9%89">形式语义使用的元语言</a> 中的元语法符号 <code>*</code> 扩展元语法，可以简记作 <code>&lt;list-expression&gt; ::= &lt;left-list-bound&gt; &lt;expression&gt;* &lt;right-list-bound&gt;</code> 。</p>
<p>　　<a href="#%E5%88%97%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">列表表达式</a>的边界是 <a href="#%E5%88%86%E9%9A%94%E7%AC%A6">NPL 图形分隔符</a>。</p>
<h3 id="名称"><a class="header" href="#名称">名称</a></h3>
<p>　　NPL 的<em>名称(name)</em> 是符合语法规则约束的若干<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">记号</a>的集合。</p>
<p>　　存在非空的名称集合可被作为<a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>。</p>
<p><strong>原理</strong></p>
<p>　　<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">名称</a>的集合是<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">广义实体</a>和<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">实体</a>的差集。</p>
<p>　　语言规则对语言可表达的名称添加要求，以使语言的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源代码</a>能够直接使用名称。</p>
<p>　　名称在源代码形式之外也可广泛存在，且能通过不唯一的方式构造。因此，语言规则允许不和源代码形式一一对应的名称。</p>
<p><strong>注释</strong></p>
<p>　　构成名称的集合的表现形式不唯一。</p>
<p>　　特定的名称可能为空集。</p>
<p>　　约束通常包含顺序，即其中的记号构成确定顺序的序列。</p>
<p>　　记号或记号集合经<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">编码</a>，一般可实现为可表达的字符串。</p>
<h3 id="语法形式"><a class="header" href="#语法形式">语法形式</a></h3>
<p>　　<em>语法形式(syntactic form)</em> 是词法上满足特定<a href="../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">形式</a>的语法构造。</p>
<p>　　除非派生实现另行指定，语法形式总是表达式。</p>
<h3 id="语句"><a class="header" href="#语句">语句</a></h3>
<p>　　以派生实现定义的标点结尾的表达式称为<em>语句(statement)</em> 。</p>
<p>　　语句语法的<em>分组(grouping)</em> 规则以及是否隐式地作为列表表达式<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>由派生实现定义。</p>
<h3 id="简单文法约定"><a class="header" href="#简单文法约定">简单文法约定</a></h3>
<p>　　一个派生实现使用简单文法 NPL-GA ，若满足：</p>
<ul>
<li>翻译单元同<a href="#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95%E6%A6%82%E5%BF%B5">基本翻译单元</a>。</li>
<li>只支持左原子表达式构成<a href="#%E5%A4%8D%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F">复合表达式</a>。</li>
<li>只支持基本<a href="#%E5%88%97%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">列表表达式</a>。</li>
<li>标点为单个<a href="#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95%E6%A6%82%E5%BF%B5">字符</a>。</li>
<li>若支持语句，总是 NPL-GA <a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　NPL-GA 允许一些典型的<em>分析器(parser)</em> 简化设计作为实现。</p>
<p>　　在<a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>的形式文法仅作为语法规则，使用<a href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90">词法分析</a>的结果提供作为<em>语法类别(syntactic category)</em> 的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">词素</a>的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">串</a>作为输入的情况下，NPL-GA 支持 LL(1) 文法分析，即使用 NPL-GA 语法。</p>
<p>　　若延迟<a href="#%E5%A4%8D%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F">复合表达式</a>和<a href="#%E5%88%97%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">列表表达式</a>中的选择到分析器外（之后可能由语义处理），检查语法的判定程序可进一步简化，仅判断记号 <code>(</code> 和 <code>)</code> 的匹配。</p>
<p>　　若词法分析处理直接对 <code>(</code> 和 <code>)</code> 和进行<em>记号化(tokenize)</em> 标记，则 NPL-GA 分析器不需要支持其它判定。这样的分析器实现的 NPL-GA 子集等效 LL(0) 文法。但由于 NPL-GA 不限定语法元素具体数量，等效 LL(0) 分析器当且仅当输入的串终止时接受输入，因此是<em>平凡的(trivial)</em> ，通常不具有实际意义，因为：</p>
<ul>
<li>形式上这里只有算法步骤的多少的差异，而几乎所有实现的语言都不把它作为<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>。</li>
<li>即便需要统计串的长度，也应可以在之前（词法分析）计算，使用语法分析完成这个任务在此是低效的。</li>
</ul>
<p>　　反之，在分析 NPL-GA 语法前扩展其它语法<em>预处理(preprocessing)</em> 规则可以支持更多的文法扩展。这样的文法扩展可接受扩展的非 NPL-GA 文法，但仍允许保持语法分析器的实现使用 NPL-GA 语法。</p>
<h1 id="npl-公共语义"><a class="header" href="#npl-公共语义">NPL 公共语义</a></h1>
<p>　　NPL 的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">语义规则</a>构成<a href="https://en.wikipedia.org/wiki/Formal_system#Deductive_system"><em>演绎系统(deductive system)</em> (en-US)</a> ，通过对<a href="#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95%E6%A6%82%E5%BF%B5">翻译单元</a>中的<a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>表达。</p>
<p>　　除非<a href="#%E7%95%A5%E7%A7%B0">派生实现</a>另行指定，仅使用表达式指定关于<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>中的计算的语义。</p>
<p>　　基本语义规则要求：</p>
<ul>
<li>所有不需要<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">诊断消息</a>的规则由派生实现定义。</li>
<li>本章内的规则应不引入<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未定义行为</a>。</li>
</ul>
<p>　　NPL 允许程序具有语义等价的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定行为</a>。派生实现可能通过约定和限制其具体选项的选取以指定更具体的<a href="#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">实现行为</a>。</p>
<p>　　本章内的语言语义基于一种<a href="https://zh.wikipedia.org/zh-cn/%E6%89%A9%E5%B1%95%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F">EBNF（扩展 BNF ）</a> 的方言，其中：</p>
<ul>
<li>规则定义符号(defining symbol) 为 <code>::=</code> 。</li>
<li>除非元素的含义和用法被单独另行指定，作为文法类的元素使用 <code>&lt;</code> 和 <code>&gt;</code> 作为分隔符。
<ul>
<li><strong>注释</strong> 这和 BNF 相同，但和常见 EBNF 可能不同。</li>
</ul>
</li>
<li>在和对象语言之间没有歧义的情形时：
<ul>
<li>使用 <code>*</code> 作为修饰前一个元素的 <a href="https://zh.wikipedia.org/zh-cn/%E5%85%8B%E8%8E%B1%E5%B0%BC%E6%98%9F%E5%8F%B7">Kleene 星号</a>，表示之前修饰的项可出现 0 次或多次。</li>
<li>使用 <code>(</code> 和 <code>)</code> 组合之间的元素。</li>
</ul>
</li>
<li>若对象语言直接出现元语言的元符号(metasymbol) 而出现歧义，需要用一对 <code>"</code> 或 <code>'</code> 标记。
<ul>
<li><strong>注释</strong> 此时和非原始版本的 BNF 以及常见 EBNF 可能相同。</li>
</ul>
</li>
</ul>
<p><strong>原理</strong></p>
<p>　　<a href="https://www.cl.cam.ac.uk/~mgk25/iso-14977.pdf">ISO/IEC 14977:1996</a>正式定义了最常见的方言，但这一标准没有简化业已分歧的元语法方言，以至于<a href="https://www.grammarware.net/text/2012/bnf-was-here.pdf">仅在 ISO 的不同编程语言标准中，就存在多种记法并用</a>。</p>
<p>　　BNF 作为元语法形式地描述适用描述形式语言的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">串</a>的<a href="#%E6%BC%94%E7%BB%8E%E8%A7%84%E5%88%99">重写系统</a>，而非对描述语义更灵活的<a href="#%E9%A1%B9%E9%87%8D%E5%86%99%E7%B3%BB%E7%BB%9F">项重写系统</a>。</p>
<p>　　在语法之外，元素之间的空白符通常不是重要的。因此，可直接省略元语言分隔符 <code>&lt;</code> 和 <code>&gt;</code> 。这也是大多数 EBNF 的典型用法（即便描述的是语法）。描述语义的例子如 [Shu10] ，其中使用特定的字体支持元语言中出现的元素。</p>
<p>　　然而，为便于在代码中表示而不依赖特设的字体，此处仍然使用 <code>&lt;</code> 和 <code>&gt;</code> ，除非元素的含义和用法被单独另行指定。</p>
<p><strong>注释</strong></p>
<p>　　因为这种 EBNF 使用不符合 <a href="https://github.com/highlightjs/highlight.js/blob/main/src/languages/ebnf.js"><code>highlight.js</code> 支持的语法</a>，在 Markdown 源代码中不使用<a href="https://github.com/highlightjs/highlight.js/blob/main/SUPPORTED_LANGUAGES.md">支持的语言别名 <code>ebnf</code> 标记</a>，而记作自定义语言标记 <code>xbnf</code> 。</p>
<p>　　ISO EBNF 被 <code>highlight.js</code> 的 <code>ebnf</code> 语法定义支持。</p>
<p>　　[Shu10] 也使用 <code>::=</code> 作为规则定义符号。</p>
<h2 id="基本语义概念"><a class="header" href="#基本语义概念">基本语义概念</a></h2>
<ul>
<li>区域(region) ：和特定位置代码关联的有限<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">实体</a>集合。</li>
<li>范围(range) ：一个连续区间。
<ul>
<li>此处“连续”的概念由派生实现定义，默认参照数学的形式定义。</li>
</ul>
</li>
<li>声明(declaration) ：引入单一<a href="#%E5%90%8D%E7%A7%B0">名称</a>的表达式。</li>
<li>声明区域(declarative region) ：对某一个声明及其引入的名称，通过<a href="#%E5%A3%B0%E6%98%8E%E5%8C%BA%E5%9F%9F%E7%BA%A6%E5%AE%9A">声明区域规则</a>决定的范围。</li>
<li>有效名称(valid name) ：可以唯一确定<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">指称</a>的实体的名称。</li>
<li>有效命名实体(valid named entity) ：有效名称指称的实体。</li>
<li>名称隐藏(name hiding) ：若同一个名称在同一个位置属于超过一个声明区域，则应能通过<a href="#%E5%8F%AF%E8%A7%81%E5%90%8D%E7%A7%B0">名称隐藏规则</a>确定唯一有效的声明以指定有效名称和对应的有效命名实体，此时有效名称隐藏其它声明区域声明的名称，有效命名实体隐藏可以使用被隐藏名称指称的实体。</li>
<li>作用域(scope) ：声明区域的子集，满足其中指定的名称是有效名称。</li>
<li>生存期(lifetime) ：逻辑上关于实体的<a href="#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>的连续区间的抽象，是一个闭集。</li>
<li>属性(property) ：实体表现的性质。</li>
<li>同一性(identity) ：实体上的一种<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">等价关系</a>，允许实体具有标识不相等特定的属性。
<ul>
<li><strong>注释</strong> 特定属性的例子如占据存储。</li>
</ul>
</li>
<li>对象(object) ：可确定同一性的实体。</li>
<li>值(value) ：表达式关联的<a href="../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">不可变状态</a>。
　　* 作为实体，对象总是关联值作为它的内容，称为<em>对象的值(value of object)</em> 。</li>
<li>未指定值(unspecified value) ：<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定</a>的值。</li>
<li>修改(modification) ：使<a href="../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">状态</a>被<a href="../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">改变</a>的操作。</li>
<li>作用(effect) ：语言支持的一定上下文内的表达式规约蕴含的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">计算作用</a>。</li>
<li>副作用(side effect) ：对表达式的值以外的表示的改变的作用。</li>
<li>幂等性(idempotence) ：重复后即不改变状态的性质。</li>
<li>项(term) ：特定的演绎系统中处理的对象，是带有基本递归构造的元素，可对应语法中的表达式。
<ul>
<li><strong>注释</strong> 这样的演绎系统主要是<a href="#%E9%A1%B9%E9%87%8D%E5%86%99%E7%B3%BB%E7%BB%9F">项重写系统</a>。</li>
</ul>
</li>
<li>子项(subterm) ：具有递归形式构造的文法描述的参与构成项的项。</li>
<li>变量(variable) ：通过声明显式引入或通过演绎系统规则隐式引入的以名称指称的实体。</li>
<li>绑定(binding) ：引入变量的操作或结果，其中后者是变量的名称和引入的被变量表示的实体构成的有序对。</li>
<li>约束变量(bound variable) ：子项中出现的名称被绑定的变量，即其指称可能依赖具体上下文的变量。
<ul>
<li>同名的约束变量的整体重命名替换不保证不改变指称进而可能影响语义。</li>
</ul>
</li>
<li>自由变量(free variable) ：子项中出现的非约束变量。</li>
<li>组合子(combinator) ：不是变量也不含相对任何项的自由变量作为子项的项。</li>
<li>常量(constant) ：满足某种不变量的约束以和不可变状态关联的实体。具体由派生实现定义。
<ul>
<li><strong>注释</strong> 不和变量对立：蕴含不可变状态的变量可能是常量。</li>
</ul>
</li>
<li>转换(conversion) ：根据基于特定等价性（假设）前提的两个项之间的自反的演绎。</li>
<li>规约(reduction) ：两个项之间的、<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">实例</a>是某个转换的子集的满足反自反的演绎。</li>
<li>抽象求值(abstract evaluation) ：对表达式的不取得作用的规约。</li>
<li>具体求值(concrete evaluation) ：对表达式的取得作用的规约。</li>
<li>求值(evaluation) ：抽象求值或具体求值。
<ul>
<li><strong>注释</strong> 即对表达式的规约。</li>
</ul>
</li>
<li>求值结果(evaluation result) ：作用的子集，是求值得到的用于替换被求值的表达式作为它的值的实体，或其它由派生实现定义的实体。
<ul>
<li>不和其它结果混淆时，简称<em>结果(result)</em> 。</li>
<li>求值中取得求值结果中的表达式的值的过程称为<em>值计算(value computation)</em> 。</li>
<li>值计算包含确定用于替换的实体以及替换的过程，两者之间具有因果性。</li>
</ul>
</li>
<li>值对象(value object) ：表示值的对象。
<ul>
<li><strong>注释</strong> 值对象是可作为值使用的对象，例如作为求值结果的一部分。和值不同，值对象不一定是不可变状态。</li>
</ul>
</li>
<li>控制状态(control state) ：实现中决定求值的状态。
<ul>
<li>程序表现的控制状态通称<em>控制(control)</em> 。</li>
<li>特定控制状态的改变使不同的实体被求值，这对应控制<em>转移(transfer)</em> 。</li>
<li><em>调度(schedule)</em> 特定可能改变控制作用的实体可决定如何转移控制状态。
<ul>
<li><strong>注释</strong> 这可能实现<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">并发的</a>计算。</li>
</ul>
</li>
<li>除非派生实现另行指定，控制状态是<a href="#%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0">区分多线程执行中不同线程的状态</a>。</li>
</ul>
</li>
<li>控制作用(control effect) ：引起控制状态改变的作用。
<ul>
<li>在 NPL 中，控制作用是在对象或派生实现定义的实体上引起改变的副作用。</li>
</ul>
</li>
<li>相等关系(equality relationship) ：定义在值的集合上的等价关系。</li>
<li>布尔值(boolean value)：逻辑真或逻辑假。</li>
<li>谓词(predicate) ：若具有结果，则结果是布尔值的实体。</li>
<li>数据结构(data structure) ：<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">数据</a>的构造性表示。</li>
<li>一等实体(first-class entity) ：语言表达的允许支持足够特性的子集的实体，其中特性支持包括：
<ul>
<li>可作为语言中的有效命名实体。</li>
<li>可作为语言中的值在<a href="#%CE%BB-%E5%AE%8C%E5%A4%87%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AF%B9%E5%BA%94%E8%AF%AD%E6%B3%95">特定的对象语言构造</a>中使用。</li>
<li>可表达数据结构。</li>
<li>满足以上支持的值域中没有任意特设的限制。</li>
<li><strong>注释</strong> 使用的判定准则和 [R<sup>n</sup>RK] Appendix B 的 first-class object 的约定实质上一致。</li>
</ul>
</li>
<li>一等对象(first-class object) ：可确定同一性的一等实体。</li>
<li>访问(access) ：从实体上取得状态或修改实体。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　一些设计中，值对象是专用于<a href="https://en.wikipedia.org/wiki/Value_object">表示（不可变的）值的对象(en-US)</a> 。本设计不使用这个定义，因为：</p>
<ul>
<li>值对象作为对象，蕴含<a href="#%E8%A1%A8%E7%A4%BA">表示</a>的目的，在语言设计而非实现的上下文中不是值的等义词。</li>
<li>以实现角度考察值对象提供值的表示时，不关心它<a href="#%E5%8F%AF%E5%8F%98%E7%8A%B6%E6%80%81%E5%92%8C%E6%99%AE%E9%81%8D%E6%80%A7">是否可作为一等对象</a>而要求<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">不可变</a>可允许其上的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>替换表示具有其它的值。</li>
<li>作为对象的值，它可能因为<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>等目的在外部被直接作为其它语言实现中可作为（允许可变的）一等对象的实体。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　在实现执行的上下文，生存期概念兼容 <a href="https://www.iso.org/standard/63598.html">ISO/IEC 2382</a> 的 lifetime 定义：</p>
<blockquote>
<p>portion of the execution duration during which a language construct exists</p>
</blockquote>
<p>　　定义绑定的有序对作为抽象表示，不需要被对象语言支持。对象语言可支持其它具体的有序对数据结构。</p>
<p>　　典型地，作用包括计算得到的值、引起的副作用以及其它可由区域和变化的状态二元组描述的实体。</p>
<p>　　一等对象同时是对象。</p>
<p>　　为满足可在表达式中通过求值被使用，一等实体总是能关联表达求值结果的值，称为实体的值。</p>
<h3 id="表示"><a class="header" href="#表示">表示</a></h3>
<p>　　<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">表示</a>用于表现演绎实例、具体实现及其中一部分实体的状态。</p>
<p><strong>注释</strong> 其中的一部分实体可以是某个值。</p>
<p>　　因为保证同一性，对象的值作为<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可变状态</a>的表示时，即对象存储的值。</p>
<p><strong>注释</strong> 变量不一定是可变状态的表示。</p>
<p>　　<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">外部表示</a>和<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">内部表示</a>是相对的。不同<a href="#%E7%95%A5%E7%A7%B0">外部环境</a>可以有不同的外部表示，这些外部表示相对其它外部环境而言可以不是外部表示。</p>
<p>　　外部表示可能被<em>读取(read)</em> 处理为内部表示。内部表示可能被<em>写入(write)</em> 处理为外部表示。</p>
<p>　　读取和写入操作的副作用分别是<em>输入(input)</em> 和<em>输出(output)</em> 。</p>
<p>　　外部表示为元素序列时，读取和写入是非特定格式数据和元素序列之间的转换，若不含其它<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>，其操作是进行<em>反序列化(deserialize)</em> 和<em>序列化(serialize)</em> 。</p>
<p>　　内部表示为对象时，读取和写入包含对象和非特定格式数据之间的转换，其操作是进行<em>列集(marshall)</em> 和<em>散集(unmarshall)</em> 。</p>
<p>　　除非另行指定，不要求对象语言提供内部表示到外部表示的转换。</p>
<p>　　<a href="#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95">文法</a>约定基准的表示作为<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">翻译</a>的输入。这种表示是翻译所在外部环境的外部表示，即<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源代码</a>；翻译结果是对象语言代码，简称<em>对象代码(object code)</em> ，可以是另外的外部表示。</p>
<p>　　<a href="#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95%E6%A6%82%E5%BF%B5">翻译单元</a>是这里被翻译的外部表示。</p>
<p>　　由<a href="#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95">基本文法</a>，空白符和参与的表示，不一一对应。为便于输出标准化，NPL 约定以下<em>规范(canonical)</em> 外部表示：</p>
<!-- markdownlint-disable-next-line MD038 -->
<ul>
<li>对列表，输出的表示是以 <code>(</code> 和 <code>)</code> 作为边界，元素以单个 <code> </code> 为分隔符的序列，其中的元素在括号中被递归地嵌套表示。</li>
<li>对非列表的存在唯一的对应词法形式（如字面量）的值，输出这个值的词法形式。</li>
<li>其它值的外部表示<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定</a>。
<ul>
<li><strong>注释</strong> 值自身可能<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定</a>。<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">未指定值</a>通常蕴含未指定的外部表示，但不绝对。</li>
</ul>
</li>
</ul>
<p>　　谓词在模型中表示为数学关系、映射或单值函数；在对象语言中可有不同的表示，如<a href="#%E5%87%BD%E6%95%B0">函数</a>。</p>
<p>　　其它外部表示和内部表示的外延由派生实现定义。</p>
<h4 id="同像性"><a class="header" href="#同像性">同像性</a></h4>
<p>　　外部表示和内部表示可能部分共享相同的规则。这些表示是<em>同像的(homoiconic)</em> 。语言支持同像的表示及其有关特性的性质是<a href="https://zh.wikipedia.org/zh-cn/%E5%90%8C%E5%83%8F%E6%80%A7"><em>同像性(homoiconicity)</em></a> 。</p>
<p>　　典型地，同像性允许复用代码和数据之间的表示。特别地，同像性允许对象语言中的代码作为数据(code as data) ，而不需要显式地处理为和代码不同的数据结构，显著简化<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元编程</a>的接口复杂性。</p>
<p>　　除非另行指定，NPL 和派生实现不限制语言中任何不同表示之间可能具有的同像性。</p>
<p><strong>原理</strong></p>
<p>　　<a href="https://zh.wikipedia.org/zh-cn/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84">存储程序的体系结构</a>自然而普遍地依赖代码和数据具有相同的表示，以便有效地把存储的数据直接作为代码提供给控制部件。</p>
<p>　　存储程序型计算机因此能自然地支持<a href="https://zh.wikipedia.org/zh-cn/%E8%87%AA%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81">自修改代码</a>。在更高层次的抽象中，高级语言可能改变这些性质的可用性，使其符合<a href="#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>，符合安全设计的需要。</p>
<p>　　但是，自修改程序在一些情形下仍然必要。为了<a href="#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">通用目的</a>，这些设计应符合<a href="#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测性</a>，而非完全禁止。</p>
<p>　　通过语言规则指定的同像性不具有体系结构设计时依赖的具体数据表示容易引起非预期操作的风险，有必要作为公开特性。</p>
<p>　　不需对代码和数据分别提供不同的特性有利于语言设计和使用的<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>。</p>
<p>　　这同时使对象语言不需要提供特设的对自身的<em>反射(reflection)</em> 特性，因为潜在可被反射的对象伴随一般的元编程无处不在而可被随时引入或排除，直至另行指定的规则限制这种能力。</p>
<p>　　这也是使对象语言的设计符合<a href="#%E7%BB%9F%E4%B8%80%E6%80%A7">光滑性</a>的主要机制。</p>
<p><strong>注释</strong></p>
<p>　　自修改程序在一般意义下对运行时生成代码的 JIT(just-in-time) <a href="../Terminology.zh-CN.html">编译器</a> 是必要的。这有助于提升程序运行时性能。</p>
<p>　　另行指定的规则包含显式的涉及表示的转换规则，例如<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">语法分析等阶段</a>可能转换外部表示为不同的（不确定种类的）内部表示，这些表示不保证其中的组成在变换前后一一对应。但是，NPL 规则没有明确指定破坏可能具有对应的规则，因此不同内部表示之间的非同像性仅在派生实现中可能指定。</p>
<h3 id="演绎规则"><a class="header" href="#演绎规则">演绎规则</a></h3>
<p>　　演绎系统具有的演绎规则决定演绎推理(deductive reasoning) 的输出。</p>
<p>　　指定转换输入和输出之间的关系的演绎规则是转换规则。</p>
<p>　　两两可转换的对象的传递闭包构成<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">等价类</a>，称为可转换等价类。除非另行指定，以下只讨论具有单一可转换等价类的转换规则演绎系统，即（抽象）<em>重写系统(rewriting system)</em> 。</p>
<p>　　对象之间的转换保持某种<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">等价关系</a>的等价<em>变换(transformation)</em> 。对象之间的规约是其中的子集，即以存在等价关系的一个对象替代另一个对象的有向转换。</p>
<p>　　若两个对象具有规约到相同结果的变换，这两个对象<em>可连接的(joinable)</em> 。</p>
<p>　　若任意两个对象等价蕴含对象可连接，则此重写系统具有 <em>Church–Rosser 属性(Church–Rosser property)</em> 。</p>
<p>　　若可从任意一个对象规约到的任意两个对象可连接，则重写系统具有<em>汇聚性(confluence)</em> 。</p>
<p>　　若可从任意一个对象的一步规约到的任意两个对象可连接，则重写系统具有<em>局部汇聚性(local confluence)</em> ，或称为<em>弱汇聚性(weak confluence)</em> 。</p>
<p>　　若可从一个对象规约到的任意两个对象可连接，则此对象具有汇聚性。</p>
<p>　　若可从一个对象的一步规约到的任意两个对象可连接，则此对象具有局部汇聚性，或称为弱汇聚性。</p>
<p>　　规约中可包括涉及<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">实现环境</a>的交互。</p>
<p>　　若规约用于求值，汇聚性限定为：满足任意以此规则变换前和变换后的项被分别规约时，两者的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>相等。</p>
<h3 id="项重写系统"><a class="header" href="#项重写系统">项重写系统</a></h3>
<p>　　作为<a href="#%E6%BC%94%E7%BB%8E%E8%A7%84%E5%88%99">重写系统</a>的实例，一个<a href="https://en.wikipedia.org/wiki/Rewriting#Term_rewriting_systems"><em>项重写系统(term rewriting system)</em></a> 包含以下组成：</p>
<ul>
<li>语法元素(syntactic element) 的集合。
<ul>
<li>项及其子项是语法元素的非空的串。</li>
</ul>
</li>
<li>辅助语义函数(auxiliary semantic function) 的集合。
<ul>
<li>可通过语义变量(semantic variable) 指称其中的元素。</li>
</ul>
</li>
<li><em>重写规则(rewrite rule)</em> 的集合。
<ul>
<li>重写规则指定<em>重写(rewrite)</em> ：接收项输入并产生作为重写的输入的项，和被重写的项之间满足某种<a href="../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">等价关系</a>即<em>重写关系(rewrite relation)</em> 。</li>
<li>重写规则集合以包含语法元素和语义变量的重写关系在<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>中表达为<em>模式(scheme)</em> 。</li>
</ul>
</li>
</ul>
<p>　　语法上蕴含<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">自由变量</a>的项是<em>开项(open term)</em> 。<em>闭项(closed term)</em> 是开项在项上的补集。</p>
<p>　　为表达计算，限制特定的重写关系使之不满足自反性，得到<em>规约关系(reduction relation)</em> ，即指定<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">规约</a>。对应地，双向的重写规则限制为其子集的单向的<em>规约规则(reduction rule)</em> 。经限制的系统是<em>项规约系统(term reduction system)</em> 。</p>
<p>　　规约关系视为表达计算查询(computational query) 的项和答案(answer) 的项之间的映射。此时，项规约系统被作为一种<a href="#%E6%A8%A1%E5%9E%8B">计算模型</a>。</p>
<ul>
<li><strong>注释</strong> 为表达计算的答案的确定性，需要确保规约可能取得<a href="#%E8%8C%83%E5%BC%8F">范式</a>。</li>
</ul>
<p>　　一般地，项规约系统关联的结构总称为演算(calculus) 。</p>
<p>　　对每个演算，存在和项对应的<em>上下文(context)</em> 。元语言中，一般的上下文以语义变量 <code>C</code> 表示，形式化为具有元变量(meta variable) □ 的以下构造：</p>
<pre><code class="language-xbnf">C ::= □ | ...
</code></pre>
<p>　　其中 <code>...</code> 是演算支持的项的语法中替换<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">子项</a>得到的对应构造。</p>
<p><strong>注释</strong> 例如，对作为对象语言的 λ 演算，语义变量 <code>x</code> 表示约束变量，其上下文为：`C ::= □ | (CT) | (TC) | (λx.C) 。这里的记法基本同 [Shu10] 。</p>
<p>　　一般的项记作语义变量 <code>T</code> ，则 <code>C[T]</code> 表示上下文 <code>C</code> 中作为元变量通过语法代换(syntactic replacement) 为项 <code>T</code> 的结果，它是一个项。</p>
<p>　　作为对象语言的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">变量</a>的项可依赖不同的上下文指称不同的实体。</p>
<p>　　一个变量 <code>x</code> 被上下文 <code>C</code> <em>捕获(capture)</em> ，若对任意 <code>x</code> 是其<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">自由变量</a>的项 <code>T</code> ，<code>T</code> 中自由出现的 <code>x</code> 在 <code>C[T]</code> 中是<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">约束变量</a>。</p>
<p><strong>注释</strong> <code>C</code> 中仍可因自由出现的 <code>x</code> 而使 <code>x</code> 是 <code>C[T]</code> 中的自由变量。</p>
<h3 id="状态和行为"><a class="header" href="#状态和行为">状态和行为</a></h3>
<p>　　状态不变蕴含语言规则中或可选地由实现定义的<a href="../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">等价关系</a>决定。</p>
<p>　　除非派生实现另行指定，约定：</p>
<ul>
<li><a href="#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">实现行为</a>总是可使用状态进行描述。</li>
<li>存在<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>为<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">可观察行为</a>的必要条件。</li>
<li>在实现外部<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>某个状态的操作（输入/输出操作）是副作用。</li>
</ul>
<p>　　若存在状态等价性以外描述的行为描述，由派生实现指定。</p>
<p>　　可观察行为如有其它外延，由派生实现指定；否则存在副作用是存在可观察行为的充分条件。</p>
<p>　　实现应满足实现行为和语义蕴含的可观察行为等价。除派生实现指定的更特定的具体行为等价性外，其余的行为等价性<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定</a>。</p>
<p>　　实现可支持实体具有对外部不引起可观察行为差异的<em>隐藏状态(hidden state)</em> 。</p>
<p>　　隐藏状态和程序约定的一些状态作为<em>管理状态(administrative state)</em> ，以隐藏局部的状态变化对程序中其它状态的影响。</p>
<p>　　非管理状态是<em>数据状态(data state)</em> 。</p>
<p><strong>原理</strong></p>
<p>　　形式上，可观察的性质影响特定的项的<em>操作等价性(operational equivalence)</em> ：替换操作等价的项得到的两个规约在可观察性质上是等价的，即两个规约的结果相等（对应行为不可分辨）。因此，可观察的性质可形式化为作为这些等价规约的结果的参数。</p>
<p>　　最简单的做法，如 [Shu10] §8.3.2 把具有可观察性质的项处理为常量语法域(syntactic domain) ，不需要附加定义相等性或影响其它规约规则。</p>
<p>　　对语义蕴含的可观察行为等价的要求指定了允许实现进行<em>语义保持变换(semantic preserving transformation)</em> 不能修改可观察性质的内涵，进而明确了实现对程序的可优化的界限。</p>
<p>　　数据状态和管理状态的分类类似 [R<sup>n</sup>RK] 中改变对象的性质上对状态的划分，但不仅仅应用在关于改变对象的判断上。</p>
<p>　　改变对象意义上和 [R<sup>n</sup>RK] 对应的具体实例是<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">实体的不可变性</a>。</p>
<p><strong>注释</strong></p>
<p>　　关于实体的状态，参见<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">实体的等价性</a>。</p>
<p>　　不严格要求实现行为和<a href="#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机语义</a>蕴含的所有推论一致。</p>
<p>　　NPL 派生实现不保证是纯函数式语言，其中的<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算</a>允许描述状态的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">改变</a>。表达式的求值的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>和 [ISO C] 以及 [ISO C++] 类似。不同的是，本文档的定义明确指定<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制作用</a>的更一般外延：改变<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制状态</a>，即便这些状态并非从属<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等实体</a>。特别地，最简单的条件分支也明确具有副作用。</p>
<h3 id="作用使用原则"><a class="header" href="#作用使用原则">作用使用原则</a></h3>
<p>　　派生实现可定义其它的作用。</p>
<p>　　在推理<a href="#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">实现行为</a>时，副作用应仅在必要时引入。</p>
<p>　　作用具有<em>种类(kind)</em> 。<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值计算</a>是作用的种类。</p>
<p>　　<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>中，对象的改变是一种作用的种类。</p>
<p>　　是否存在副作用是互斥的，即一种作用不可能同时是副作用和不是副作用。其它作用的种类可能相交，即可能同属不同的作用。</p>
<p>　　派生实现可定义其它作用的种类。</p>
<p>　　求值可引起副作用的<em>起始(initiation)</em> 。副作用的存在（如改变状态）可继续保持到求值结束后，并可影响<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>。</p>
<p>　　副作用的<em>完成(completed)</em> 即副作用的存在的终止（如改变状态完成）。</p>
<p>　　引起作用的求值<em>蕴含(imply)</em> 求值关联的作用，以及其中蕴含的副作用的起始决定的其它作用。派生实现可定义特定的求值使之蕴含的其它的作用。</p>
<p>　　作用之间可存在<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">等价关系</a>。等价的作用相互替换不影响可观察行为。</p>
<p><strong>原理</strong></p>
<p>　　允许派生实现定义不同的作用以维护<a href="#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>。</p>
<p>　　不同<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>对<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">行为</a>的影响可能依赖作用之间的顺序。</p>
<p>　　因此，副作用应仅在必要时引入，不能在推理行为时无中生有(out of thin air) ，除非证明引入的副作用不蕴含<a href="#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">被许可的等价的实现行为</a>以外的其它行为。通常需明确区分是否依赖副作用以避免非预期的行为。这有助于保持<a href="#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测性</a>和<a href="#%E5%8F%AF%E7%BB%84%E5%90%88%E6%80%A7">可组合性</a>。</p>
<p>　　NPL 及其派生实现中的作用可描述一般的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">计算作用</a>，不限定作用的种类的外延。</p>
<p>　　明确副作用的起始是必要的，因为语言至少需要支持允许无法反馈外部状态完成改变的副作用，即 I/O 操作，此时副作用的存在应被允许保持到求值结束后，否则求值无法终止而被<em>阻塞(blocked)</em> 。</p>
<p>　　副作用的完成是和起始相对的概念，在讨论有关<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">顺序</a>时可能实用。</p>
<p><strong>注释</strong></p>
<p>　　派生实现可定义的其它的作用可能是副作用。</p>
<p>　　副作用的起始在 [ISO C++] 的关于求值（引起的作用）的规则中同样被明确。</p>
<h2 id="实体语义"><a class="header" href="#实体语义">实体语义</a></h2>
<p>　　实体是语言中主要表达的目标。</p>
<p>　　本节提供和实体相关的公共定义和语义规则，并归纳关于<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等实体</a>和<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>的性质。</p>
<p>　　除非另行指定，语言中不引入<a href="#%E5%AE%9E%E4%BD%93%E8%AF%AD%E4%B9%89">非一等实体</a>。仅在特定局部上下文中操作非一等实体。</p>
<p><strong>原理</strong></p>
<p>　　限制非一等实体出现的规则有助于<a href="#%E7%BB%9F%E4%B8%80%E6%80%A7">统一性</a>。</p>
<p><strong>注释</strong></p>
<p>　　根据<a href="#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">一等实体和一等对象</a>，<a href="#%E7%BB%9F%E4%B8%80%E6%80%A7">规则 G1a</a> 是限制非一等实体的规则的推论。</p>
<p>　　一等实体的<em>一等(first-class)</em> 性质体现在语言支持的操作限制足够小，使之实例的全集可以涵盖任意<a href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">求值上下文</a>中。</p>
<p>　　一个一等性质的反例是 [ISO C] 的数组类型的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>无法作为函数的形式参数。推论：[ISO C] 的数组对象不是一等对象。</p>
<h3 id="实体的等价性"><a class="header" href="#实体的等价性">实体的等价性</a></h3>
<p>　　<em>等价谓词(equivalence predicate)</em> 是判断<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">等价关系</a>的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">谓词</a>。</p>
<p>　　等价谓词可定义一些<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">等价类</a>划分。</p>
<p>　　语言提供等价谓词判断两个项之间是否满足等价关系，满足判断等价关系的需要。</p>
<p>　　作用于<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">实体的值</a>的等价谓词（若存在）定义实体的<em>相等(equality)</em> 关系。</p>
<p><strong>注释</strong> 这类似一般的值的集合上可能存在的相等关系。</p>
<p>　　决定相等关系的谓词是相等谓词，可判断实体和实体的值<em>相等(equal)</em> 。</p>
<p>　　除非另行指定，默认实体上的具体等价关系是<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">实体的同一性</a>。</p>
<p>　　对象语言不要求提供默认的具体等价关系，即任意两个实体不一定可以比较等价。</p>
<p>　　已知可比较等价的任意实体之间的等价关系也不具有唯一性。</p>
<p>　　一般地，设计等价谓词需注意避免一些现实的使用困难，如<a href="https://www.craigstuntz.com/posts/2020-03-09-equality-is-hard.html">关于相等性的困难</a>。</p>
<p>　　为使等价关系在实体全集上<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">良定义</a>，等价谓词可能在特定情形弱化为同一性。</p>
<p>　　一般地，弱化应具有可用性理由，这可能和既有等价谓词和等价关系的蕴含的设计相关。</p>
<p><strong>原理</strong></p>
<p>　　等价谓词在避免依赖良序(well-ordering) 和良基(well-founded) 的理论中满足最小依赖原则，尽管其实现仍可能依赖序关系。</p>
<p>　　等价谓词的用途和上下文相关。</p>
<p>　　<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>在作为等价关系蕴含实体上的任何其它等价关系。被蕴含的等价关系可具有更多的限制条件。</p>
<p>　　实体的同一性是普遍的，但不是普适的，它仍不足以在所有上下文中都被关注。</p>
<p>　　同时，同一性无法保证在对象语言的所有实体上被实现；否则，会引起根本上显著的问题，限制<a href="#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">语言的可扩展性</a>，而和<a href="#%E5%BD%A2%E8%80%8C%E4%B8%8A%E5%AD%A6">通用目的语言的一般属性</a>冲突：</p>
<ul>
<li>这类普遍同一性的具体判断依赖<a href="https://zh.wikipedia.org/zh-cn/%E5%A4%96%E5%BB%B6%E6%80%A7">外延性</a>，实质上是语言要求的相等性。
<ul>
<li>这要求任意具体的实现通过已知的、有限的方式构造，直接破坏<a href="#%E5%B0%81%E8%A3%85">封装性</a>。
<ul>
<li>特别地，在<a href="#%E5%87%BD%E6%95%B0">函数</a>等实体上的定义体现<a href="https://ncatlab.org/nlab/show/function+extensionality">函数外延性(function existionality)</a> ，非常依赖具体实体的构造。</li>
</ul>
</li>
<li>即便不考虑实现细节，如 λ 演算这样较为简单（但足够有<a href="#%E5%AE%8C%E6%95%B4%E6%80%A7">表达能力</a>)）的形式系统，一般的外延性即是<a href="https://zh.wikipedia.org/zh-cn/%E6%B1%BA%E5%AE%9A%E6%80%A7%E5%95%8F%E9%A1%8C">不可判定的</a>。
<ul>
<li><strong>注释</strong> 这种不可判定使某些具体编码具有不唯一的表示，如 <a href="https://en.wikipedia.org/wiki/Church_encoding#Use">Church 数(en-US)</a> 。</li>
</ul>
</li>
<li>尽管有的系统如<a href="https://zh.wikipedia.org/zh-cn/%E5%85%AC%E7%90%86%E5%8C%96%E9%9B%86%E5%90%88%E8%AE%BA">公理化集合论</a>通过<a href="#%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E6%96%B9%E6%B3%95">公理语义</a>（具体地，<a href="https://zh.wikipedia.org/zh-cn/%E5%A4%96%E5%BB%B6%E5%85%AC%E7%90%86">外延公理</a>）可以确切定义外延性，这同样依赖破坏封装的具体实现。</li>
<li>即便非通用目的语言也可能类似地因为外延性上的不可判定等问题，<a href="https://github.com/coq/coq/wiki/extensional_equality">存在充分理由拒绝默认提供函数外延性的等价谓词</a>。</li>
</ul>
</li>
<li>进一步，为满足<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>和<a href="#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>，这自然地要求任意具体的实现是对象语言的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源代码</a>中可表达，而破坏语言的可扩展性。
<ul>
<li><strong>注释</strong> 例如，语言中不能引入隐藏具体实现细节的<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>。</li>
<li><strong>注释</strong> 作为反例，λ 演算中的对象都被 λ 项编码。但这引起的限制在通用目的语言中无法接受。
<ul>
<li>例如，<a href="https://zh.wikipedia.org/zh-cn/%E9%82%B1%E5%A5%87%E6%95%B0">原生的算术</a>在<a href="https://en.wikipedia.org/wiki/Church_encoding#Use">算法复杂度意义上即是低效</a>的，而通过机器数等方式的实现在复杂度和常数上都更高效。但后者的实现依赖外部系统，不能表达为 λ 项。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　决定普适的等价谓词中蕴含的统一的等价关系是不可能的，因此语言中应允许共存多个等价谓词。具体等价谓词的设计可由派生实现及语言的用户提供。</p>
<p>　　等价谓词设计中弱化等价性的一个例子是 [R<sup>6</sup>RS] 的<a href="http://www.r6rs.org/r6rs-editors/2005-August/000840.html">记录(record) 对象的相等性</a>。</p>
<p><strong>注释</strong></p>
<p>　　<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">实体的同一性</a>是实体上的<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可用于定义状态不变</a>的等价关系的例子。它蕴含了实体没有被替换为不同的实体的判断，满足保持这种判断的<a href="#%E9%98%B6%E6%AE%B5%E4%B8%8D%E5%8F%98%E9%87%8F%E7%BA%A6%E6%9D%9F">不变量</a>。</p>
<p>　　关于实体的关联的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>是相对同一性更弱的等价关系。因为<a href="#%E4%B8%8D%E5%8F%AF%E5%88%86%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">不可分的同一性</a>，同一实体蕴含其值相等。</p>
<p>　　一些情况部分值的集合不满足数学意义上的等价（如浮点数的 <a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">NaN</a> ），但在此忽略这种可被单独扩展的情况。</p>
<p>　　以下不同准则的操作是相等关系的实例（参见 [EGAL] ）：</p>
<ul>
<li><em>抽象相等(abstract equality)</em></li>
<li><em><a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>相等(reference equality)</em></li>
<li>EGAL ([EGAL])</li>
</ul>
<h4 id="实体的同一性"><a class="header" href="#实体的同一性">实体的同一性</a></h4>
<p>　　<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>是实体上的等价关系的一个主要实例。</p>
<p>　　同一性决定的等价类之间的实体相同，即其整体和任意的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">属性</a>在任意上下文中等价。</p>
<p>　　相同的实体在语言中不需要被区分，可直接替换而不影响程序的语义和行为。后者蕴含<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为等价</a>。</p>
<p>　　实体的同一性可体现在以下隐含的默认规则：</p>
<ul>
<li>不同上下文的实体默认相互独立而不保证能被视为相同（在任意上下文中等价）。</li>
<li>通过语言构造引入的超过一个实体，默认为不相同的实体。</li>
<li>除非另行指定，表示具有同一性的实体的语言构造和其它实体不被要求<a href="#%E5%85%B1%E4%BA%AB%E5%BC%95%E7%94%A8">共享</a>指称相同的具有同一性的实体。</li>
</ul>
<p>　　语言在<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等实体</a>上提供的同一性的<a href="#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">具体判断依据</a>和具体语言支持的特性相关。</p>
<p><strong>原理</strong></p>
<p>　　同一性决定任意两个实体可在语言中不依赖具体操作的行为被直接区分，即满足 Leibneiz 法则(Leibneiz's law) ，或称为<a href="#%E4%B8%8D%E5%8F%AF%E5%88%86%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">不可分的同一性</a>。</p>
<p>　　基于这个性质，可在实体上定义和 [So90] 相容的更强的（不依赖语言设计中不存在副作用的）<em>引用透明性(referential transparency)</em> 。</p>
<p>　　同一性的引入默认是名义的，即断言具有同一性的实体和其它实体上的行为相互独立，而不需要附加证明。这种假设避免了一般地证明任意实体具有同一性的困难。</p>
<p>　　若不依赖直接在实体上标记等价类等依赖名义同一性假设的方法，证明一个实体具有同一性而非已知的其它实体，需证明任意的其它允许在程序中构造的实体和这个实体上的任意作用的可观察行为无关。在不限定具体的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">计算作用</a>属于会影响可观察行为的计算作用的确切集合时，这是计算上不可能的。因此，支持这类证明会有效地限制语言在支持不同的计算作用种类上的<a href="#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">可扩展性</a>。</p>
<p>　　反之，从不同的对象上取消同一性（而允许实现共享资源等目的）一般是容易的：只要证明不存在影响可观察行为的计算作用即可。这种证明可以由程序名义地表达，例如标记某个实体上只涉及纯计算而没有副作用。</p>
<p>　　另一方面，这也提示纯计算在各种计算作用中具有的特殊性不足以使其作为唯一的可扩展配置的起点。</p>
<p>　　最平凡的起点应是没有任何计算作用的空计算。这无法表达计算，而必须要求扩展才具有实用性。而<a href="#%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0">通用目的语言</a>需要支持一般的计算作用，这同时包含支持纯计算。</p>
<p>　　从一般的计算作用排除副作用而得到纯计算，只需要添加可被系统证明的假设，这种机制可以嵌入到系统的规约规则中；而以支持纯计算的系统扩展表达一般的计算，需要引入不足以被对象语言求值规则描述其语义的间接表示（即需要被规约以外的规则翻译），并暴露更多和表达一般计算的目的无关的实现细节。</p>
<p><strong>注释</strong></p>
<p>　　按不可分的同一性，实体的属性在形式逻辑中通过量化的谓词判断而实现。</p>
<p>　　和不可分的同一性相对，存在同一性的不可分性(the indiscernibility of identicals) 。两者可被二阶语言形式地描述。</p>
<p>　　对象语言可提供同一性的相关操作，如：</p>
<ul>
<li>[ISO C] 的非空对象指针的比较操作比较指向的相同类型对象的同一性。</li>
<li>[R<sup>n</sup>RS] 和 [R<sup>n</sup>RK] 的 <code>eq?</code> 过程/应用子比较两个<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>的同一性。</li>
</ul>
<h4 id="实体的不可变性"><a class="header" href="#实体的不可变性">实体的不可变性</a></h4>
<p>　　<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">通过特定的等价关系可定义</a>具体的<a href="../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">不可变状态</a>的集合。</p>
<p>　　这些集合可用于定义以这些状态为值的实体的<em>不可变性(immutability)</em> ，进而定义不保持可变性的<a href="../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">改变</a>操作和具体的其中可能影响<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">修改</a>操作。</p>
<p>　　通过限定不同的修改操作，定义不同的<em>可修改性(modifiability)</em> 和对立的<em>不可修改性(nonmodifiability)</em> 。</p>
<p>　　通过明确不可修改性拒绝支持修改操作（例如通过通过实体的<a href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>拒绝特定的修改操作），或通过不提供修改操作，语义规则保证实体不被修改操作改变状态。</p>
<p><strong>注释</strong> 例如，关于 [ISO C++] 的非类且非数组类型的<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>不可修改，尽管要求非纯右值的语义规则可被视为是一种类型检查。</p>
<p>　　（不依赖和影响<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">实体同一性</a>的）同一个实体上的修改操作是改变操作。只有具有<a href="../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">可变状态</a>的实体可能支持这些操作。</p>
<p>　　不论是否能区分同一性，实体可能关联不排除影响<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>的可变状态。</p>
<p>　　一般地，一个实体不一定保证可区分是否具有不可变性以及具有何种不可变性（也蕴含一般不可区分可修改性），因为不可变性依赖实体的<a href="#%E8%A1%A8%E7%A4%BA">表示</a>进行约定。</p>
<p>　　改变操作可能继续保持实体不变。</p>
<p>　　潜在引起实体的一些内部状态的变化的操作可不被视为影响不可变性而不被视为实体的（整体意义上的）改变操作。这种实体具有<em>内部可变性(interior mutability)</em> 。</p>
<p>　　可引起实体变化的状态按设计上是否<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">隐藏局部变化</a>分为两类：</p>
<ul>
<li><em>可变管理状态(mutable administrative state)</em>
<ul>
<li>可变管理状态的改变作为<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">管理状态</a>的改变，不被视为对象（整体）改变的对象内部状态的改变。</li>
</ul>
</li>
<li><em>可变数据状态(mutable data state)</em>
<ul>
<li>可变数据状态的改变是对象的改变。</li>
</ul>
</li>
</ul>
<p>　　<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">隐藏状态</a>在可变性的意义上视为可变管理状态。</p>
<p>　　推论：</p>
<ul>
<li>引起实体内的可变管理状态的改变的操作不一定是改变对象的操作。</li>
<li>引起实体内的隐藏的可变状态的改变的操作不一定是修改操作。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　基于等价关系而不是预设具体表示之间的相等定义可变性，避免抽象的目的（如<a href="#%E5%B0%81%E8%A3%85">封装性</a>）<a href="#%E9%81%BF%E5%85%8D%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F">依赖特定相等关系的实现细节</a>，支持<a href="#%E5%BC%80%E6%94%BE%E6%80%A7">开放世界假定</a>。</p>
<p>　　这种设计的一类典型反例是在预设排除副作用的<a href="#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯的</a>的设计为基础进行扩展定义改变操作，包括：</p>
<ul>
<li>默认使用不可变<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">数据结构</a>，并在此基础上扩展出可变的数据结构（如 [Rust] ）。</li>
<li>默认支持保证排除副作用的<a href="#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>，仅在有限的上下文中通过特定构造模拟支持非纯求值（如 Haskell 等纯函数式语言）。</li>
</ul>
<p>　　一般地，这类策略对<a href="#%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0">通用目的语言</a>是过度设计，因为这实质上要求所有不存在改变操作的实体操作都完全排除副作用，不支持指定不同类别或层次保留不同改变操作并划分不同等价类的可能性，而限制表达的能力或增加实现相同抽象的复杂性。</p>
<p>　　关联可变状态的实体通常是对象，因为支持区分<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">同一性</a>而能支持发生在不同实体上的作用引起独立的状态的改变而分别影响可观察行为，但这并非绝对。只要允许构造出按等价关系判断具有不相同状态，非对象实体仍可支持内部可变性等不能排除影响可观察行为的性质。这不通过需要区分同一性的状态改变。</p>
<p>　　不区分同一性允许实现任选其中的实例代替其它实例。因此，在抽象机语义上依赖这些实体的不同等价状态表现的所有<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">良定义行为</a>都应被允许，即未指定行为。</p>
<p>　　内部可变性同 [Rust] 的 <code>RefCell&lt;T&gt;</code> 等使用的模式以及 [ISO C++] 的 <code>mutable</code> ，允许对象具有可变管理状态，而不影响依赖可变或可修改的对象整体意义上的类型检查。</p>
<p>　　和 [Rust] 不同而和 [ISO C++] 更加类似，这里的内部可变性仅限关于对象不可变性，和对象是否被<a href="#%E5%AF%B9%E8%B1%A1%E5%88%AB%E5%90%8D">别名</a>正交（一些实例分析参见<a href="https://stackoverflow.com/questions/63487359">这里</a>）。</p>
<p>　　但是，和 [Rust] 及 [ISO C++] 都不同，这里不要求不可变性通过<a href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>强制。</p>
<p><strong>注释</strong></p>
<p>　　可变和不可变的状态的区分类似 [R<sup>n</sup>RK] 。</p>
<p>　　其它语言也遵循类似的设计。作为非对象实体的可变性的一个例子，<a href="https://eel.is/c++draft/dcl.ref#4">C++ 引用是否要求存储未指定</a>，尽管占用存储这一状态并非是语言支持的可变状态。这一规则直接允许 C++ 实现不需要依赖 <a href="https://eel.is/c++draft/intro.abstract#footnote-6">as-if 规则</a>即可选取占用和不占用存储的方式实现引用的实例（乃至在运行时改变选取策略），即便是否占用存储可能对应 C++ 程序的不同的可观察行为。</p>
<p>　　改变或修改实体后，实体可能不变，即仍然具有和之前等价的状态。例如：</p>
<ul>
<li>改变操作使用等价的状态替换先前的状态。</li>
<li>连续的改变操作使回复原始的状态，则这些改变操作的组合的作用不改变实体。</li>
</ul>
<p>　　按<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">定义</a>，蕴含引起表达式的值以外的改变的操作的作用是副作用。这里的改变是名义的，允许改变前后的状态等价。</p>
<p>　　支持不同等价的不可变性的一个用例是，有序的数据结构中的键需要保持的（通过序关系定义的）等价关系和键的可修改性是两种不同的等价关系。作为它的一个具体的反例，C++ 标准库要求关联容器的键具有 <code>const</code> 修饰，没有区分两种等价性，导致无法修改等价的键（除非具有 mutable 数据成员），而引起一些不必要的复杂。</p>
<h3 id="实体的副本"><a class="header" href="#实体的副本">实体的副本</a></h3>
<p>　　在已知的实体以外，实体，作为其<em>副本(copy)</em> ，满足：</p>
<ul>
<li>实体和实体的副本满足某种<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">等价</a>，至少蕴含<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">实体的值</a>之间满足<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">不可变性</a>。</li>
<li>若一个实体是对象，它的副本和它不<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一</a>。</li>
</ul>
<p>　　除非另行指定，若实体的副本无法被创建，引起创建副本的操作<a href="#%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　若实体的副本可被创建，它可能通过：</p>
<ul>
<li><em>复制(copy)</em> 实体：创建副本后，保持原实体的值<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">不变</a>。</li>
<li><em>转移(move)</em> 实体：创建副本后，原实体被转移而具有<em>有效但未指定(valid but unspecified)</em> 的状态；若可能取得实体的值，其值<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定</a>。
<ul>
<li><strong>原理</strong> 要求有效，隐含其<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>时具有<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">良定义行为</a>。</li>
<li><strong>注释</strong> 参见<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">未指定状态</a>。</li>
<li><strong>注释</strong> 这类似 [ISO C++] <a href="https://eel.is/c++draft/lib.types.movedfrom">[lib.types.movedfrom]</a> 。</li>
</ul>
</li>
<li><em>析构性转移(destructively move)</em> 实体：创建副本后，原实体的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>结束，不再可<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>。</li>
<li>其它派生实现指定的创建实体副本的不同方式。</li>
</ul>
<h3 id="实体数据结构"><a class="header" href="#实体数据结构">实体数据结构</a></h3>
<p>　　实体的集合上可定义关联关系：集合的包含关系或其它实现定义的<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">严格偏序关系</a>。被关联的实体称为<em>子实体(subentity)</em> 。</p>
<p>　　子实体可以是作为<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">数据结构</a>的一部分。这种数据结构可以是一般的<em>图(graph)</em> 。</p>
<p>　　数据结构也可在对象语言中通过实体包含关系以外的途径定义。</p>
<p><strong>注释</strong></p>
<p>　　例如，限定包含关系构成的图中的<a href="#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权关系</a>附加限制，详见<a href="#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">自引用数据结构和循环引用</a>。</p>
<h3 id="续延"><a class="header" href="#续延">续延</a></h3>
<p>　　<em>续延(continuation)</em> 是特定<a href="#%E4%B8%8A%E4%B8%8B%E6%96%87">上下文</a>中描述未来的<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算</a>的实体。</p>
<p>　　续延描述的计算可能在尚未发生的后继的规约中实现，在此之前可能被<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">调度</a>，其中可指定不同的计算内容。上下文可决定这些计算中可变的参数化部分。</p>
<p>　　计算可通过切换续延蕴含<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制状态</a>改变而具有<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制作用</a>。</p>
<p>　　当前规约的上下文中对应的续延是<em>当前续延(current continuation)</em> 。</p>
<p>　　按对控制的限制，续延可分为<em>无界续延(undelimited continuation)</em> 和<em>有界续延(delimited continuation)</em> 等不同形式。</p>
<p>　　续延蕴含<em>子续延(child continuation)</em> 作为最后的一系列子计算。</p>
<p>　　形式上，若续延表示为一个计算步骤的序列，子续延的表示是续延的表示的后缀。</p>
<p>　　推论：无界续延的子续延是无界续延；有界续延的子续延是有界续延。</p>
<p><strong>注释</strong></p>
<p>　　续延可由符合<a href="#%E9%A1%B9%E9%87%8D%E5%86%99%E7%B3%BB%E7%BB%9F">项规约系统</a>的<a href="#%E8%A7%84%E7%BA%A6%E8%A7%84%E5%88%99%E5%92%8C%E6%B1%82%E5%80%BC">规约步骤</a>的集合或未指定的其它形式的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">表示</a>。</p>
<p>　　不同形式的续延的调用都能具有类似的控制作用，但<a href="#%E5%AE%8C%E6%95%B4%E6%80%A7">表达能力</a>不尽相同。</p>
<p>　　有界续延可从无界续延或有界续延通过添加续延的<em>界限(delimiter)</em> （或称为<em>提示(prompt)</em> ）派生。派生的结果是原续延的一部分，表达原续延对应的计算的<em>子计算(subcomputation)</em> ，又称<em>部分续延(partial continuation)</em> 。</p>
<p>　　在仅使用<em>局部变换(local transformation)</em> 即 Felleisen <em>宏表达(macro-expressible)</em> ([Fl91]) 的意义上，[Fi94] 指出：</p>
<ul>
<li>有界续延和可变状态（存储）可实现无界续延。</li>
<li>嵌入在语言中的任意表达<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">计算作用</a>的<em>单子(monad)</em> 的构造可用有界续延实现。</li>
</ul>
<h3 id="一等实体和一等对象"><a class="header" href="#一等实体和一等对象">一等实体和一等对象</a></h3>
<p>　　NPL 区分两类不同的一等实体：只关心关联（作为对象时）的值的，和同时关心作为对象的<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">其它属性</a>的一等对象。</p>
<p>　　其中，后者允许更多的操作，且允许作为前者使用，反之无法直接保证：一等对象总是一等实体，一等实体不保证可作为一等对象使用。</p>
<p>　　逻辑上，一等实体可以关联其它对象（作为一等对象时关联可以是存储）。关联的对象的（表达式相关的）值是一等实体关联的值，可对应一等对象存储值。关联的值或存储的值是一等实体或一等对象的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">属性</a>。</p>
<p>　　除非派生实现指定，NPL 的一等实体都是一等对象。</p>
<p>　　结合<a href="#%E5%AE%9E%E4%BD%93%E8%AF%AD%E4%B9%89">实体语义</a>相关规则，存在推论：除非另行指定，语言中不引入非一等对象。</p>
<p><strong>原理</strong></p>
<p>　　一等对象的值是一等对象的属性。</p>
<p>　　一些设计中，显式地不区分对象和值，因为这些设计中不支持普遍的一等对象。在这些设计中，一等实体被称为一等对象。因为不保证提供其它属性，一等对象的值和一等对象也不再被区分。这有助于<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>，但阻碍<a href="#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">实体语义的可扩展性</a>，直接无法从语言设计中允许在一等实体中区分一等对象。因此，NPL 不使用这种设计。</p>
<p><strong>注释</strong></p>
<p>　　派生实现可以定义非一等对象的其它一等实体。</p>
<p>　　除非派生实现指定，非一等对象也不是一等实体。</p>
<p>　　显式地不区分对象和值如 [R<sup>n</sup>RS] 。这些设计中，<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值对象</a>若被使用，仍被作为实现细节；且因为互操作和允许支持副作用，值对象并非全部一等对象的内部表示。</p>
<h4 id="一等对象的同一性"><a class="header" href="#一等对象的同一性">一等对象的同一性</a></h4>
<p>　　一等对象通过保证具有<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>强调不相同的对象总是存在至少一种<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">总是不相同的属性</a>。</p>
<p>　　一般地，语言规则选取其中一种属性作为名义(nominal) 同一性属性。</p>
<p>　　一等对象具有名义同一性，定义为可比较名义同一性属性<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">相等</a>；名义同一性的相等即名义同一性属性相等。</p>
<p>　　名义同一性在名义上标识相同的对象，区分不相同的对象，即便后者可能仍然在行为上完全符合同一性的要求。</p>
<p>　　形式上，一等对象是名义同一性属性和它作为一等实体的关联的对象作为非对象（无视同一性）的其它属性集合（如<a href="#%E8%A1%A8%E7%A4%BA">存储的值</a>）的二元组。</p>
<p>　　为简化设计，NPL 约定以下默认规则：</p>
<ul>
<li>除非另行指定，名义同一性属性指定为对象在<a href="#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机语义</a>下的存储位置。
<ul>
<li>对象占据存储位置起始的若干存储。</li>
<li>存储位置的<a href="#%E8%A1%A8%E7%A4%BA">表示</a>未指定；派生实现可指定具体的表示。</li>
</ul>
</li>
<li>在语言规则中，一等对象满足<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">实体的同一性</a>的默认规则。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　由语言特性而非<a href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>提供表达同一性的支持是必要的，这体现在通过在<a href="#%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0">通用目的语言</a>中省略同一性的表达再由实现或用户程序引入的做法一般是不可行的：</p>
<ul>
<li>由 <a href="https://zh.wikipedia.org/zh-cn/%E8%8E%B1%E6%96%AF%E5%AE%9A%E7%90%86">Rice 定理</a>，非平凡(non-trivial) 的程序语义性质无法被<a href="#%E5%AE%8C%E6%95%B4%E6%80%A7">可计算地</a>实现，而确定程序中任意对象的同一性蕴含判定“和特定程序行为一致”这种非平凡语义性质，无法被通过证明程序行为的等价或其中的<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">实体在任意上下文上的等价</a>任意地引入，因此若无法确定用户程序不需要任意的同一性（这是一种平凡情形），指定“不需要引入同一性”总是只能在特定的程序上由语言设计者或用户具体地决定。</li>
<li>作为通用目的语言若需要描述能适应语言自身实现问题的特性，总是依赖具体语言的逻辑上的<a href="https://zh.wikipedia.org/zh-cn/%E9%9D%9E%E7%9B%B4%E8%B0%93%E6%80%A7">直谓(predicative) 的</a>规则（如资源抽象），除非语言规则是空集（这是一种平凡情形），这不可能完全由用户程序提供。</li>
</ul>
<p>　　语言的设计中显式区分一等实体和一等对象的支持而非只直接支持一等对象仍然是必要的，主要原因是：</p>
<ul>
<li>一等实体的具体表现形式通常是实现细节而要求不被依赖，为了支持前者不被显式表达，满足<a href="#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99">关注点分离原则</a>。</li>
<li>一等实体的普遍支持允许以<a href="#%E7%BB%9F%E4%B8%80%E6%80%A7">统一</a>的方式抽象<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可变状态</a>，且扩展使便于满足<a href="#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>。</li>
</ul>
<h4 id="可变状态和普遍性"><a class="header" href="#可变状态和普遍性">可变状态和普遍性</a></h4>
<p>　　NPL 对一等实体提供普遍的支持。</p>
<p>　　除非另行指定，NPL 不限制一等实体上可能具有的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>，包括<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>。</p>
<p><strong>原理</strong></p>
<p>　　一等实体的普遍支持体现在：</p>
<ul>
<li>在一般的一等实体上引入可变状态，实质上提供了<em>一等副作用(first-class side effect)</em> ，而不把<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">可修改性</a>限于特定的数据结构（如<a href="#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">求值环境</a>）。</li>
<li>允许以一致的方式和实现的外部环境进行<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>，特别地，允许物理上提供状态抽象的设备实体的状态直接映射为一等对象。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　特别地，一等对象默认支持可变状态。</p>
<p>　　派生实现可附加规则改变本节中对一等对象的默认要求，提供不同的保证或性质，包括<a href="#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>上的其它一等实体上的不同作用。</p>
<h3 id="同一性关联扩展性质"><a class="header" href="#同一性关联扩展性质">同一性关联扩展性质</a></h3>
<p>　　NPL 中，对象的同一性关联的属性包括明确开始和终止的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>。</p>
<p>　　推论：对象是表示能明确生存期开始和终止的实体。</p>
<p>　　一等对象之间总是能准确地判断影响程序语义的<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">同一性</a>：仅当能证明不改变<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>时，两个一等对象的同一性可能未指定。</p>
<p><strong>原理</strong></p>
<p>　　通过一等对象关联同一性，允许语言提供依赖同一性差异的特性。</p>
<p><strong>注释</strong></p>
<p>　　同一性在这个意义上不是对象自身确定的性质（而是对象和解释对象表示的可能由外部提供的实现的共同确保的性质），不是应被隐藏的内部实现，因此 [EGAL] 中有关自我诊断(autognosis) 的结论不适用；而代理(proxy) 仍然可通过语言提供适当的隐藏同一性的手段可靠地实现。</p>
<h4 id="一等状态"><a class="header" href="#一等状态">一等状态</a></h4>
<p>　　确保区分同一性的<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">状态</a>是<em>一等状态(first-class state)</em> 。</p>
<p>　　一等对象能直接表示一等状态。</p>
<p>　　一等状态是否通过其它特性派生是未指定的。</p>
<p><strong>原理</strong></p>
<p>　　一等对象相对一等实体的附加规则限制集中体现在允许一等对象映射到的支持上。</p>
<p>　　注意并非所有一等对象都需要支持一等状态；否则几乎总是会<a href="#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">付出本不必要的代价</a>也难以避免违反<a href="#%E9%80%82%E7%94%A8%E6%80%A7">适用性</a>；因此有必要区分一等状态的对象和非一等状态的对象。</p>
<p>　　这种区分实质上更普遍地对具体的计算操作也存在意义，自然地引入了类似 [ISO C++] 的<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">值类别</a>；最简单的设计如区分<em>左值(lvalue)</em> 和<em>右值(rvalue)</em> 分别关联是否需要支持一等状态的对象。</p>
<p>　　为支持一等状态，有必要支持判断两个对象的同一性，确保<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">修改</a>某个对象的操作不会关联到任意其它对象，以允许特定对象关联特定的一等状态。</p>
<p>　　为允许一等状态和<a href="#%E7%95%A5%E7%A7%B0">外部环境</a>的<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>，不能总是假定只有一类总是可被程序局部预知的<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">修改操作</a>（典型地，定义为“设置<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>”操作，如 [R<sup>n</sup>RK] §3.1 ）影响状态，而应允许和特定对象关联的求值时的不透明的副作用。</p>
<p>　　若不考虑互操作，则一等对象用有限的不同<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">等价谓词</a>]即能提供区分同一性的操作；否则，等价谓词的设计即便保持<a href="#%E6%AD%A3%E4%BA%A4%E6%80%A7">正交</a>，也需区分不同的一等对象对各种<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>的不同支持情况。</p>
<p>　　避免指定一等对象的可派生方式有助于<a href="#%E7%BB%9F%E4%B8%80%E6%80%A7">统一性</a>。</p>
<p>　　基于 [Fi94] ，结合可变状态能被表达为单子（如<a href="https://www.pauldownen.com/publications/delimited-control-effects.pdf">这里</a>）的事实，<a href="#%E7%BB%AD%E5%BB%B6">有界续延</a>可实现状态。</p>
<p>　　相对地，基于 [Fl91] ，<a href="#%E7%BB%AD%E5%BB%B6">无界续延</a>和<a href="#%E5%BC%82%E5%B8%B8">异常</a>不能实现一般意义的可变状态，参见<a href="https://www.researchgate.net/profile/Hayo-Thielecke/publication/2487383_Contrasting_Exceptions_and_Continuations/links/53e12dba0cf2235f352738e5/Contrasting-Exceptions-and-Continuations.pdf">这里</a>的推论 5.13 。</p>
<p>　　因为同一性可以在引入状态时被编码而在之后不需改变，使用有界续延等非一等的状态可支持实现状态的同一性。因此，在此不对是否基本要求作出限定。</p>
<p>　　但是，使用有界续延实现状态仅仅是实现细节，且通常具有一些非预期的实现性质：</p>
<ul>
<li>这在控制状态和支持一等状态的实现之间建立的不对等（地位不同，相互之间交换后不等效）的偶然耦合；这种耦合不存在简化实现等益处而具有必要性。
<ul>
<li><strong>注释</strong> 例如，一等状态可能直接使用对应的<em>寄存器(register)</em> 实现。实现控制状态则通常需要更复杂的实现。</li>
<li>尽管理论可行，没有必要只是用其中一种作为另一种的实现的基础实现。
<ul>
<li>在现有实现普遍提供状态的原生支持（存储器）的常见情况下，单独通过其它方式编码状态反而会付出本不必要的代价。</li>
</ul>
</li>
</ul>
</li>
<li>这实质要求实现同一性无界续延具有区分同一性的能力（相当于 [ISO C++] 的左值），而引起不正交的内部设计。</li>
</ul>
<p>　　为满足非常规的实现环境或更优先的原则（如<a href="#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>和<a href="#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>），派生实现仍可使用有界续延派生一等状态，同时提供访问更基本的不依赖可变状态的接口，以使上述影响不再是非预期的。</p>
<p>　　<a href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>仍不被禁止使用这种方式自行提供类似的实现，以确保<a href="#%E7%BB%9F%E4%B8%80%E6%80%A7">不约定一等状态作为基本的内建特性时</a>，语言的设计不违反 <a href="#%E7%BB%9F%E4%B8%80%E6%80%A7">G1b</a> 。</p>
<p><strong>注释</strong></p>
<p>　　实现在一般实体上支持的<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">隐藏状态</a>不被程序可编程地指定，不是一等状态。</p>
<p>　　允许和特定对象关联的求值时的不透明的副作用的一个实例是 [ISO C] 和 [ISO C++] 的 <code>volatile</code> 类型对象。</p>
<h4 id="一等作用"><a class="header" href="#一等作用">一等作用</a></h4>
<p>　　语言可指定特定的求值自动创建对象。</p>
<p>　　基于此规则可在传递时附加不同的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>，即实现可随一等对象传递的<em>一等作用(first-class effect)</em> 。</p>
<p><strong>原理</strong></p>
<p>　　典型地，<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值传递</a>时，被传递后的对象和<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">实际参数</a>表示的对象具有不同的同一性，即按值传递时创建<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">新的对象</a>。</p>
<p>　　基于被创建的<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">副本</a>的<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">不变性</a>，这里的一等作用可包括用于维护对象的<a href="../Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">不变性</a>的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>，<a href="#%E5%8F%AF%E5%8F%98%E7%8A%B6%E6%80%81%E5%92%8C%E6%99%AE%E9%81%8D%E6%80%A7">包括可能的副作用</a>，作为<a href="https://zh.wikipedia.org/zh-cn/%E5%A5%91%E7%BA%A6%E5%BC%8F%E8%AE%BE%E8%AE%A1">契约式编程(programming by contract)</a> 的基础实现方式。</p>
<p>　　这种不变性可包括对象的生存期。通过限制特定表达式求值的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用域</a>内销毁对象以确保对象生存期有限，即基于作用域的对象管理(scope-based object management) 。</p>
<p>　　基于作用域的对象管理可直接对应有限资源的普遍性质，使一等对象作为资源的抽象，确保资源的创建和销毁的副作用符合资源操作的语义，同时避免隐式的泄漏。</p>
<p>　　配合<a href="#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">一等状态</a>，对象语言中的一等对象允许直接表示超过程序运行时自身的生存期的状态。这允许不在程序运行时持久储存的数据能直接被一等对象进行操作，而不需要依赖外部系统的约定并减少冗余操作（例如，从外部持久的“文件”上打开“流”以及其上的持久化操作），更符合<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>。</p>
<p><strong>注释</strong></p>
<p>　　这里的资源抽象的惯用法在 C++ 中称为 RAII(resource aquisition is initialization) 。</p>
<h4 id="所有权抽象"><a class="header" href="#所有权抽象">所有权抽象</a></h4>
<p>　　配合<a href="#%E4%B8%80%E7%AD%89%E4%BD%9C%E7%94%A8">一等作用</a>，实体的<em>所有权(ownership)</em> 自然地适用对抽象为对象的资源进行约束。</p>
<p>　　使用对象代表资源，则<em>所有者(owner)</em> 约束被其所有的其它对象的创建和销毁的时机。被所有的对象的生存期是所有者的生存期的并集的子集，且：</p>
<ul>
<li>被所有的对象的生存期的起始不<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序</a>所有者的生存期起始。</li>
<li>被所有的对象的生存期的终止不<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">后序</a>所有者的生存期终止。</li>
</ul>
<p>　　NPL 的设计避免要求对象语言隐含单一的<em>根(root)</em> 所有者作为其它资源的所有者。</p>
<p><strong>原理</strong></p>
<p>　　避免单一所有者适应抽象不同系统的需要，并满足<a href="#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>：</p>
<ul>
<li>当不需要这样的所有者时，保持设计的<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>，同时满足<a href="#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>和<a href="#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>。</li>
<li>当需要这样的所有者时，仍然允许实现或派生实现引入。</li>
</ul>
<p>　　注意<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">规约</a>允许蕴含<a href="#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>的所有者用于提供规约时不在对象语言中可抽象为一等对象访问的资源，这样的所有者不需要是全局的；若实现为在不同规约实例乃至全局共享的资源，也不应在对象语言被依赖。</p>
<p>　　只要程序没有明确要求所有者，单一的全局所有者违反<a href="#%E6%9C%80%E5%B0%8F%E4%BE%9D%E8%B5%96%E5%8E%9F%E5%88%99">最小依赖原则</a>，且不支持不清楚所有者状态时对特定对象之间进行所有权的局部推理(local reasoning) ：</p>
<ul>
<li>这种情形若不配合原始的明确目的（而间接明确资源的所有者）的设计说明，人类读者直接阅读实现理解和验证其正确性是困难的，即损失了可读性。
<ul>
<li>一种解决方式是读者自行模拟运行程序再从中推理出可简化的资源所有关系，这首先相当于要求读者模拟非确定性垃圾回收(GC, garbage collection) 的运行机制。这通常是困难的工作。</li>
</ul>
</li>
<li>而机器通常更无法推理这些问题，因为设计和抽象的目的一般不是以机器可读的方式编码的。
<ul>
<li>GC 可以回收资源，但无法准确统计哪些回收是必要的，也无法准确追溯原始实现并推理出应当在何种情况下静态地插入释放资源的操作，因为 GC 自始至终缺乏“允许任意延迟释放操作”以外的程序变换的<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">保持语义不变</a>的证明所需的程序元信息（包括目的）。</li>
</ul>
</li>
</ul>
<p>　　为满足<a href="#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>，当需要表达局部所有权关系时，使用单一的全局所有者使用户无法直接在对象内嵌(embedding) 这种关系而需另行编码所有权信息，这存在以下问题：</p>
<ul>
<li>使整体设计直接违反<a href="#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>。</li>
<li>要求局部所有权以和全局默认机制的不一致的方式表达，损失<a href="#%E7%BB%9F%E4%B8%80%E6%80%A7">统一性</a>并放弃<a href="#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99">局域性</a>而在满足需求时造成接口<a href="#%E9%81%BF%E5%85%8D%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F">抽象泄漏</a>。</li>
</ul>
<p>　　此外，即便使用时不要求区分对象的局部所有权关系，全局的分配释放机制也比局部的机制有更大的实现复杂性和约束。为实现对内部有限的资源的有效管理，局部所有权在实现中仍是必要的。</p>
<p>　　在使用全局所有者如全局的垃圾回收的实现中，这种必要性被隐藏在全局所有者内部实现，语言的整体设计不会更<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单</a>。</p>
<p>　　使用全局所有者的资源管理假定启发式(heuristic) 策略以节约现实中无法接受的非预期性开销。这仍无法保证总是对不同的场景同样有效，以至于默认存在以下问题：</p>
<ul>
<li>设计至少违反变化的自由和<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>之一。</li>
<li>在不引入支持用户配置策略的扩充设计时，违反变化的自由总是无法避免的。</li>
<li>若引入其它设计支持用户配置策略，简单性违反难以避免，且实际基本上没有被避免。</li>
<li>即便能通过扩充设计避免违反简单性，也不能避免<a href="#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">不必要付出的代价</a>。</li>
<li>不论是否引入扩充设计，都会使资源管理的一般开销更难以估计，而使设计整体的可用性评估更困难，容易使用户决策和避免不必要付出的代价冲突。</li>
</ul>
<h3 id="一等引用"><a class="header" href="#一等引用">一等引用</a></h3>
<p>　　NPL 的一等对象即对象自身，不要求区分引用和<em>被引用对象(referent)</em> 的普遍概念。</p>
<p>　　反之，通过使引用和其它一些非引用的对象同为<a href="#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">一等对象</a>，NPL 支持作为一等对象的<em>一等引用(first-class reference)</em> 。</p>
<p>　　一等引用支持一等对象作为被引用对象。除非另行指定，若实现允许<a href="#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>作为被引用对象，可作为被引用对象的非一等对象由实现定义。</p>
<p>　　特定的操作可能预期非引用，或总是隐含通过引用<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>被引用对象，这不改变引用被作为一等对象使用的普遍支持。</p>
<p>　　一等引用的<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">相等关系</a>定义为被引用对象的<a href="#%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">名义同一性相等</a>。</p>
<p>　　一等对象的使用仍然可以通过要求引用访问以避免在任意上下文中需要不同的对象副本。但这并不应排除其它形式的一等对象操作。</p>
<p><strong>原理</strong></p>
<p>　　尽管满足 [R<sup>n</sup>RK] Appendix B 的准则(criteria) ，一等对象和 [R<sup>n</sup>RK] 及 Java 等语言要求的设计不同。</p>
<p>　　注意有引用的语言的语义中不能排除被引用对象，否则无法确定引用对象的值的表达式的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>（例如来自对象<a href="#%E8%A1%A8%E7%A4%BA">存储的值</a>）以表达<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算</a>；相反，无视引用而直接对值操作仍然能实现一些足够有意义的程序。</p>
<p>　　因此，若存在引用，无法忽略非引用（即便非引用不能在对象语言被直接使用）。</p>
<p>　　另一方面，引用可以由不指定为引用的一般对象上添加语义规则区分，而作为一般的对象的特例。</p>
<p>　　要求语言操作的一等对象总是关联到引用的设计实质上使对象语言的一等对象都是引用。但这不表示引用是自然的一等实体，因为引用的作用仅是操作被引用对象，不要求引用自身能被作为一等对象。</p>
<p>　　一等引用的相等性定义允许在相等的引用上推理<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">引用透明性</a>。</p>
<p>　　考虑此设计决策时关注的有以下几节中的依据。其它依据参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h4 id="共享引用"><a class="header" href="#共享引用">共享引用</a></h4>
<p>　　共享引用是共享资源的引用。共享的资源（通常是存储空间）自身具有同一性，以<em>位置(location)</em> 标记。共享不同位置（即作为不同一等对象的）的引用可能引用同一个被引用对象。</p>
<p><strong>原理</strong></p>
<p>　　合理的共享引用可以节约实现占用的资源，提供更好的性能。但共享引用的实现仍可能有附加的开销，因此并不能保证使用共享引用一定能提供更好的性能。通常这种情形至少包括一些典型的对资源独占一次使用（具有独占所有权(unique ownership) ）的情况。</p>
<p>　　更重要地，并非任意引用的共享都不改变程序的语义和行为，不合理的使用可能造成非预期的作用。</p>
<p>　　任意地引入共享引用而使用户不便预测其作用破坏<a href="#%E9%80%82%E7%94%A8%E6%80%A7">适用性</a>：</p>
<ul>
<li>这包含直接破坏<a href="#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测性</a>，并在需要排除共享的场景中缺乏<a href="#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>。</li>
<li>特别地，这和具有副作用的<em>非确定性(non-deterministic)</em> 编程冲突。</li>
<li>典型的<a href="#%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0">多线程并发执行</a>若需对象上的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>，需要保护和排除不必要的共享，确保独占<a href="#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权</a>以避免<em>竞争条件(race condition)</em> 。</li>
<li>也有其它的一些类似的容易被忽略的<a href="https://okmij.org/ftp/continuations/map-story.html">非确定性地破坏假设的场景</a>。</li>
<li>另见共享改变。</li>
</ul>
<p>　　区分是否需要表达共享的情形一般不能由语言实现预知。和<a href="#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">使用全局所有者的问题</a>类似，使对象默认共享的设计若需避免违反<a href="#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>，在此相对不默认共享引用的设计违反<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>。</p>
<p>　　默认共享引用可能是隐式的，即语言的实现不通过程序<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">代码</a>中的显式标注的操作而引入共享的引用，且往往无法保证通过一等对象上的操作避免被引用的对象被其它一等对象引用——无法使用对象语言的操作排除共享引用（即便是新创建的对象也没有保证，尽管实现上不必要）。</p>
<p>　　在要求一等对象都是引用的设计中，一般地，只有不要求名义同一性的非对象的实体才能安全地共享引用，但在非对象实体上的类似引用的机制并没有保证通过一等引用提供为语言特性。</p>
<p>　　其它情形中，允许引用之间的隐式的共享使<a href="#%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">不相同的对象</a>可能共享状态而破坏<a href="#%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">同一性的行为保证</a>：程序无法可靠地避免共享状态导致的对<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>的影响，此时共享状态的改变非预期地影响其它对象，其行为不具有<a href="#%E4%B8%80%E8%87%B4%E6%80%A7">一致性</a>。</p>
<p>　　为了排除破坏同一性和适用性的问题，语言的设计需要限制引起问题的操作的可用性（例如，[R<sup>n</sup>RK] 和 [R<sup>n</sup>RS] 不提供使用一等引用的改变操作以保证变化能通过程序<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源代码</a>中有限的语法上下文被推理），但这样的策略限制设计的<a href="#%E5%85%B6%E5%AE%83%E6%8E%A8%E8%AE%BA%E5%92%8C%E6%AF%94%E8%BE%83">通用性</a>。</p>
<p>　　因为共享引用的影响的普遍性，不提供可避免隐式共享引用的设计的造成的缺陷也是普遍的。</p>
<p>　　由于显式的引用可以由用户控制在局部使用，更容易推理其影响，可避免类似的缺陷。</p>
<p>　　关于共享改变和程序无法可靠地避免共享状态导致的对可观察行为的影响，参见参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>注释</strong></p>
<p>　　一些语言的设计指定或隐含的规则在程序代码操作的一等对象上普遍地引入隐式共享的引用，如：</p>
<p>　　[R<sup>n</sup>RK] 中的引用和被引用对象明确地分离，且 <code>$define!</code> 和 <code>set-car!</code> 等<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">改变操作</a>要求设置对象引用的其它对象为特定的<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>确定的被引用对象，无法排除被设置的引用被共享；这实质要求所有可能包含其它引用的可被改变的对象中的引用都需要能构成隐式的共享。</p>
<p>　　[R<sup>n</sup>RS] 明确指出特定的空对象的唯一性（即便因为不保证具有位置，不一定保证以位置决定的<a href="#%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">名义同一性</a>），蕴含这些对象上总是可构造或超过一个引用必须构造隐式的共享引用；其它变量引用(variable reference) 未指定排除隐式的共享。</p>
<h5 id="对象别名"><a class="header" href="#对象别名">对象别名</a></h5>
<p>　　除非在语言规则中添加复杂的约束（如通过<a href="#%E7%B1%BB%E5%9E%8B">类型</a>的机制）以证明特定上下文可避免共享引用，无法避免引用引入不必要的对象<em>别名(aliasing)</em> 。</p>
<p>　　若公开这样的性质作为接口约束，违反<a href="#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>。</p>
<p>　　隐式的共享使涉及<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">修改</a>的操作的特性更难设计，参见共享改变。</p>
<p>　　关于共享改变，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　对象别名一旦引入，通常难以在所有被别名的对象生存期结束前消除。</p>
<p>　　证明对象不被别名是困难的，因为这逻辑上要求在局部知悉所有被别名的对象的存在性，而不具有<a href="#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99">局域性</a>。</p>
<h3 id="自引用数据结构和循环引用"><a class="header" href="#自引用数据结构和循环引用">自引用数据结构和循环引用</a></h3>
<p>　　特定的数据结构在逻辑上要求内部具有相互指涉的引用，即<em>自引用(self-referencing)</em> 。</p>
<p>　　自引用可实现为一等对象集合内的<em>循环引用(cyclic reference)</em> ，即允许对象属于有限次迭代访问被引用对象的操作的传递闭包（非空的<em>链(chain)</em> ，称为引用对象链）的构造。</p>
<p>　　NPL 的不保证支持这种方式实现自引用。</p>
<p><strong>原理</strong></p>
<p>　　NPL 的设计不保证支持通过循环引用实现自引用，以避免一些固有缺陷。即便派生语言允许提供扩展支持，但本节讨论的原理仍然适用。</p>
<p>　　避免自引用的构造使实体构成的数据结构由一般的<a href="#%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">图</a>退化为（可共享节点的）树形数据结构，即 DAG（Directed Acyclic Graph ，有向无环图）。</p>
<p>　　这样的设计在实现上避免外部所有者（如<a href="#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">全局 GC</a> ）。</p>
<p>　　避免一般的循环引用的普遍理由是：<a href="https://zh.wikipedia.org/zh-cn/%E9%9D%9E%E7%9B%B4%E8%B0%93%E6%80%A7"><em>非直谓性(impredicativity)</em></a> 并非是抽象上必要的普遍特性。一般的循环引用在抽象上即应通过特殊进行归纳，这并非<a href="#%E9%81%BF%E5%85%8D%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F">泄漏抽象</a>。</p>
<p>　　反之，需求决定的抽象上不必要的情形下，假定循环引用的存在反而妨碍抽象的构造，可能避免某些有用的普遍性质（例如，保证程序可终止；另见<a href="#%E8%8C%83%E5%BC%8F">强规范化性质</a>），而违反<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>、<a href="#%E7%BB%9F%E4%B8%80%E6%80%A7">统一性</a>和<a href="#%E9%80%82%E7%94%A8%E6%80%A7">适用性</a>，并引起若干具体设计问题。</p>
<p>　　关于通过任意对象支持循环引用的问题，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h4 id="一般引用数据结构的一般实现"><a class="header" href="#一般引用数据结构的一般实现">一般引用数据结构的一般实现</a></h4>
<p>　　通过一些替代原语，在不支持循环引用的情形仍可支持自引用数据结构。</p>
<p>　　语言可以提供在不支持一般的循环引用的对象构造中保存无所有权的一等实体引用其它实体，构造出不蕴含所有权的仅以特定对象构成的循环引用，而在外部引入对象作为所有这些构成引用的对象的所有者的机制。</p>
<p>　　在这个基础上，一般的自引用或循环引用需要的附加指涉仍然可通过添加不蕴含所有权语义的引用解决。这些引用是<em>弱引用(weak reference)</em> ，区分于具有所有权的引用是<em>强引用(strong reference)</em> 。</p>
<p>　　强引用总是可转换为弱引用使用。弱引用通过<em>解析(resolve)</em> 取得强引用。解析可能失败，以允许弱引用指涉已经不存在的对象，而避免影响对象<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>和所有权关系。</p>
<p>　　若支持这种受限形式的循环引用，具体特性由派生实现定义。</p>
<p><strong>原理</strong></p>
<p>　　没有理由表明通过任意对象支持循环引用是自引用数据结构的唯一实现方式，不论使用自引用数据结构的普遍程度。</p>
<p>　　自引用数据结构可通过在更高的抽象层次上编码，转换为由用户（而不是语言实现）指定明确的外部所有者的形式消除上述所有问题，同时对外部保证同等的功能<a href="#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>。</p>
<p>　　使用受限的循环引用同时避免带有所有权的循环引用也是 C 和 C++ 等语言惯用的实现图(graph) 的数据结构的合理方式。</p>
<h3 id="实体类型"><a class="header" href="#实体类型">实体类型</a></h3>
<p>　　NPL 不要求预设具体的实体及对象类型的设计，因此不要求用户使用语言体现整体上的<a href="#%E7%BB%9F%E4%B8%80%E6%80%A7">可扩展性</a>。</p>
<p>　　特别地，NPL 不要求表达式具有预设的不同<a href="#%E7%B1%BB%E5%9E%8B">类型</a>。</p>
<p><strong>原理</strong></p>
<p>　　放弃对预设类型的要求允许由派生实现指定类型的外延而满足<a href="#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>。</p>
<p>　　除不必涉及<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>外，[R<sup>n</sup>RK] 中定义的封装的(encapsulated) 类型的概念及类型<a href="#%E5%B0%81%E8%A3%85">封装性</a>（ [R<sup>n</sup>RK] 原则 G4 ）仍然适用，且一般仍然需要满足；差异是派生实现因为扩展不满足的情形也不影响此实现的<a href="#%E8%A7%84%E8%8C%83%E6%A8%A1%E5%9E%8B">一致性</a>（尽管使用扩展的程序可能不可移植）。</p>
<p>　　尽管<a href="#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">值类别</a>可抽象为特殊的类型，表达式中的对象的类型和值类别的规则应分别讨论，因为两者正交：两者的<a href="#%E7%B1%BB%E5%9E%8B">确定</a>和<a href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">检查</a>机制都相互独立。</p>
<h2 id="名称规则"><a class="header" href="#名称规则">名称规则</a></h2>
<p>　　<a href="#%E5%90%8D%E7%A7%B0">名称</a>和能标识特定含义、符合<a href="#%E8%AF%8D%E6%B3%95%E8%A7%84%E5%88%99">名称词法约束</a>的表达式一一对应。</p>
<p>　　具体的外延由派生实现定义。</p>
<p>　　表示名称的表达式不同于名称，但在无歧义时，语言中可直接以名称代指表达式和对应的词法元素。</p>
<p>　　<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>中对名称的处理应满足本节的要求。</p>
<p><strong>原理</strong></p>
<p>　　名称规则约定通过程序<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源代码</a>确定的静态的语法性质。</p>
<p>　　部分规则中的概念定义和约定仅为便于描述这些性质。和这些约定对应的结构不一定需要在求值算法的实现中出现。</p>
<h3 id="声明区域约定"><a class="header" href="#声明区域约定">声明区域约定</a></h3>
<p>　　对引入名称 <code>n</code> 的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">声明</a> <code>D</code> ，对应的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">声明区域</a>始于紧接 <code>n</code> 的位置，终于满足以下条件的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">记号</a><code>)</code>（若存在）或<a href="#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95%E6%A6%82%E5%BF%B5">翻译单元</a>末尾（不存在满足条件的记号 <code>)</code> ）：</p>
<ul>
<li>记号 <code>)</code> 和与之匹配的记号 <code>(</code> 构成的表达式包含 <code>D</code> 。</li>
<li>此记号之前不存在满足上一个条件的其它的记号 <code>)</code> 。</li>
</ul>
<h3 id="可见名称"><a class="header" href="#可见名称">可见名称</a></h3>
<p>　　名称隐藏规则：若<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">声明</a> <code>D</code> 是表达式 <code>E</code> 的子集，且不存在 <code>D</code> 的子集声明同一个名称，则 <code>D</code> 声明了<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">有效名称</a>，隐藏了 <code>E</code> 中其它同名的名称。</p>
<p>　　在<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">声明区域</a>中，没有被隐藏的名称是<em>可见(visible)</em> 的。有效名称实质蕴含可见名称。</p>
<h3 id="名称解析"><a class="header" href="#名称解析">名称解析</a></h3>
<p>　　<em>名称解析(name resoultion)</em> 是通过名称确定名称指定的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">实体</a>的操作。</p>
<p>　　不保证名称解析总是成功。</p>
<p>　　除非另行指定，成功的名称解析没有<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>。</p>
<p>　　除非另行指定，直接作为求值算法步骤的不成功的名称解析<a href="#%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　一般地，名称解析包括<em>名称验证(name verification)</em> 和<em>名称查找(name lookup)</em> 两个阶段。</p>
<p>　　名称验证确定名称是<a href="#%E5%8F%AF%E8%A7%81%E5%90%8D%E7%A7%B0">可见名称</a>，同时可能排除部分无效名称。</p>
<p>　　名称查找进一步确定名称唯一指称的实体的（蕴含确定名称有效），仅在名称验证成功后进行。</p>
<p>　　不同名称经过名称查找的结果可能等效。等效的有效名称视为<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一的</a>，规则由派生实现定义。</p>
<p>　　名称解析从保存名称的目标中查找名称。若查找失败，解析可继续从替代的其它目标中进行。这种机制称为<em>重定向(redirection)</em> 。重定向后的解析可继续包含名称验证和名称查找的步骤。</p>
<p>　　以上约定以外的具体规则以及失败的行为由派生实现定义。</p>
<h3 id="命名空间"><a class="header" href="#命名空间">命名空间</a></h3>
<p>　　<em>命名空间(namespace)</em> 是<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">实体</a>。命名空间可以由名称指称。</p>
<p>　　是否实现命名空间为程序中可由用户指定可变的实体及<a href="#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">求值环境</a>，由派生实现定义。</p>
<h4 id="命名空间指称"><a class="header" href="#命名空间指称">命名空间指称</a></h4>
<p>　　总是没有名称<em>指称(denotation)</em> 的命名空间是<em>匿名命名空间(anonymous namespace)</em> 。</p>
<p>　　没有有效名称指称的命名空间是<em>未命名命名空间(unnamed namespace)</em> 。</p>
<p>　　NPL 定义一个抽象的匿名命名空间，称为<em>根命名空间(root namespace)</em> 。未命名命名空间的支持由派生实现定义。</p>
<p>　　NPL 约定一个在实现中的有效名称总是指称一个命名空间。有效名称指称的命名空间的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>和<a href="#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">有效名称的同一性</a>对应。</p>
<p><strong>注释</strong></p>
<p>　　匿名命名空间和未命名命名空间不同。前者可能是一个系统的默认约定，一般整体唯一存在（如<em>全局(global)</em> 命名空间）；后者只是对某些接口隐藏，可以有多个。</p>
<h4 id="命名空间成员"><a class="header" href="#命名空间成员">命名空间成员</a></h4>
<p>　　除了用于指称的名称外，一个命名空间可以和若干其它名称关联。</p>
<p>　　通过派生实现定义的对命名空间的操作可以取得的名称是这个命名空间的<em>成员(member)</em> 。</p>
<p>　　若无歧义，命名空间的成员指称的实体也称为这个命名空间的成员。</p>
<p>　　命名空间直接包含成员，称为直接成员。</p>
<p>　　除了根命名空间和其它派生实现定义外，命名空间可以作为另一个命名空间的成员，此时命名空间内的成员（若存在）是包含其的命名空间的间接成员。</p>
<p>　　命名空间对成员的直接包含和间接包含总称为包含，是反自反的、反对称的、传递的二元关系。</p>
<h4 id="简单名称和限定名称"><a class="header" href="#简单名称和限定名称">简单名称和限定名称</a></h4>
<p>　　命名空间的直接<a href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%88%90%E5%91%98">成员</a>的标识符在这个命名空间中是有效名称，称为<em>简单名称(simple name)</em> 。</p>
<p>　　命名空间及其成员按包含关系依次枚举标识符组成的序列是一个名称，称为在这个命名空间中的<em>限定名称(qualified name)</em> 。</p>
<p>　　<a href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%8C%87%E7%A7%B0">根命名空间</a>的限定名称称为<em>全限定名称(fully qualified name)</em> 。</p>
<p>　　限定名称的语法由派生实现定义。</p>
<p><strong>注释</strong></p>
<p>　　限定名称的语法的一个实例是标识符之间作为逻辑上的<a href="#%E5%88%86%E9%9A%94%E7%AC%A6">分隔符</a>的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">记号</a>。</p>
<h2 id="规约规则和求值"><a class="header" href="#规约规则和求值">规约规则和求值</a></h2>
<p>　　对象语言的<a href="#%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E6%96%B9%E6%B3%95">操作语义</a>可通过作为计算模型的<a href="#%E9%A1%B9%E9%87%8D%E5%86%99%E7%B3%BB%E7%BB%9F">项规约系统的规约规则</a>中由规约规则描述的规约<em>步骤(step)</em> 指定。</p>
<p>　　除非派生实现另行指定，规约蕴含 NPL 程序的执行，可完全表示程序执行的语义。</p>
<p>　　推论：NPL 规约规则形式地蕴含 NPL 语义规则。</p>
<p>　　为表达明确的目的，<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言规则</a>也可约定<a href="#%E5%8F%AF%E9%80%89%E6%B1%82%E5%80%BC%E8%A7%84%E5%88%99">其它更抽象形式的求值规则</a>，以蕴含这些规约规则，而不是直接描述规约规则的形式语义。</p>
<p>　　描述 NPL 对象语言的操作语义也可被视为<a href="#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">特定的对象语言</a>，其规约可以视为求值。但除非另行指定，以下表达式仅指对象语言的表达式，其求值仅指关于对象语言中表达式的求值，而非一般的规约。</p>
<p>　　规约规则可要求被规约的项符合一定的结构（如具有特定类型的值）作为前提，否则规约出错，程序执行中止。</p>
<p>　　根据规约规则描述的行为是否对应对象语言中的求值，规约分为两类：表达式的<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值规约</a>和<a href="#%E7%AE%A1%E7%90%86%E8%A7%84%E7%BA%A6">管理规约</a>。</p>
<h3 id="求值规约"><a class="header" href="#求值规约">求值规约</a></h3>
<p>　　一个规约可以描述表达式的求值。直接表达一个表达式求值的规约是一个求值规约。</p>
<p>　　以<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项重写系统</a>描述，求值规约的输入是作为表达式的<a href="#%E8%A1%A8%E7%A4%BA">表示</a>的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>，称为<em>待求值项(evaluating term)</em> 。</p>
<p>　　待求值项经求值规约取得<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>。</p>
<p>　　除非另行指定，求值结果是通过<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值计算</a>取得的值。</p>
<p><strong>原理</strong> 求值结果也可能是<a href="#%E5%BC%82%E5%B8%B8">异常</a>退出的等其它作用对应的实体。这些求值结果可能需要派生实现定义的不同规则的处理。</p>
<p>　　以下项称为<em>被规约项(reduced term)</em> ：</p>
<ul>
<li>待求值项。
<ul>
<li><strong>注释</strong> 因为可附加等价<a href="#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">空求值</a>的恒等规约，不需要区分项是否已被规约。即使表达式从未被求值，其表示也可视为待求值项。</li>
</ul>
</li>
<li>规约步骤的<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">中间表示</a>中完全依赖求值规约的输入的子集的项。</li>
<li>表示<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>的项。</li>
</ul>
<p>　　求值规约规则构成对象语言的<em>求值算法(evaluaton algorithm)</em> 。</p>
<p>　　求值算法的输入是被求值的表达式和支持<a href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">上下文相关求值</a>中的上下文。</p>
<p>　　求值的基本操作以满足特定规则的<em>替换(substituion)</em> 规则或其组合表示。</p>
<p>　　除非另行指定，以下讨论的排除求值副作用的重写系统具有<a href="#%E6%BC%94%E7%BB%8E%E8%A7%84%E5%88%99">汇聚性</a>。</p>
<p>　　这保证求值满足值替换规则：表达式的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值计算</a>通过已知的<a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F">子表达式</a>的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>替换决定。</p>
<p>　　除非派生实现另行指定，子表达式的值仅由求值得到。</p>
<p><strong>注释</strong> 此时<a href="#%E9%80%92%E5%BD%92%E8%95%B4%E5%90%AB%E8%A7%84%E5%88%99">递归蕴含规则</a>中的求值依赖规则是这个规则的推论。</p>
<h3 id="管理规约"><a class="header" href="#管理规约">管理规约</a></h3>
<p>　　求值规约以外的规约称为<em>管理(administrative)</em> 规约。</p>
<p>　　管理规约可以是一个不完整的求值规约，或者和求值规约的步骤没有交集。</p>
<p>　　管理规约可使用对象语言不可见和不可直接操作的非<a href="#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">一等状态</a>的<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">管理状态</a>。</p>
<p>　　表示非<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>的项的规约总是管理规约。</p>
<p>　　<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">抽象求值</a>中不在对象语言<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>中可表达的中间规约是管理规约实现。</p>
<p><strong>注释</strong></p>
<p>　　管理规约描述语言的表达式以外的<a href="#%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E6%96%B9%E6%B3%95">操作语义</a>。</p>
<p>　　实现也可使用的管理规约描述特定于实现的（而在对象语言中未指定的）语义性质。</p>
<h3 id="规约顺序"><a class="header" href="#规约顺序">规约顺序</a></h3>
<p>　　<em>先序(sequenced before)</em> 关系是两个规约之间存在的一种<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">严格偏序关系</a>，对实现中规约之间的<em>顺序(order)</em> 提供约束。</p>
<p>　　<em>后序(sequenced after)</em> 是先序的逆关系。</p>
<p>　　<em>非决定性有序(indeterminately sequenced)</em> 是先序或后序的并集。</p>
<p>　　<em>无序(unsequenced)</em> 是非决定性有序在求值二元关系全集上的补集。</p>
<p>　　规约规则的顺序直接适用于求值，其顺序为<em>求值顺序(evaluation order)</em> 。</p>
<p>　　规约规则的顺序也适用在能以其形式描述相对顺序的<em>事件(event)</em> 上。<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">程序</a>中蕴含的这些事件称为<em>规约事件(reduction event)</em> ，包括：</p>
<ul>
<li>求值。</li>
<li>对象的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>的起始或终止。</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>的<a href="#%E4%BD%9C%E7%94%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99">起始</a>和<a href="#%E4%BD%9C%E7%94%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99">完成</a>。</li>
<li>不涉及副作用的完成<a href="#%E4%BD%9C%E7%94%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99">在求值结束后存在</a>时，某个<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">计算作用</a>的存在。</li>
<li>派生实现定义的其它事件。</li>
</ul>
<p>　　一些事件的顺序是通过推理具有<em>因果性(causality)</em> 的<em>依赖(dependency)</em> 关系决定的，包括：</p>
<ul>
<li>规约中<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值计算</a>依赖规约的输入，即被求值的表达式和其它可能影响规约的状态。</li>
<li>被副作用的起始决定的其它作用依赖这个副作用。</li>
<li>从一个实体上确定作为值的属性的<em>读(read)</em> 依赖这个属性。</li>
<li>在一个实体上可以作为值保留的属性的<em>写(write)</em> 被这个属性依赖。</li>
<li>由派生实现定义的其它情形。</li>
</ul>
<p><strong>注释</strong> 外部<a href="#%E8%A1%A8%E7%A4%BA">表示</a>作为实体的读取和写入是这里的属性的特例。</p>
<p>　　为了确定相关的值，依赖关系可直接替换为后序关系。</p>
<p>　　由二元关系的一般性质（特别地，偏序关系的传递性），可推导其它一些事件之间的确定顺序，如同一个实体属性上的读依赖（已知的）决定了这个属性的先前的写。</p>
<p>　　作为先序和后序的扩展，规约事件可符合<em>在先发生(happens before)</em> 和<em>在后发生(happens after)</em> 的严格偏序关系，满足：</p>
<ul>
<li>对同一个<a href="#%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0">执行线程</a>中的事件，在先发生和在后发生分别同先序和后序。</li>
<li>组合在先发生或在后发生的关系的不存在<em>环(cycle)</em> 。</li>
<li>派生实现定义的其它要求。</li>
</ul>
<p>　　NPL 约定以下非决定性规约规则：除因果性和二元关系的一般性质的推论外，任意项之间的规约之间无序。</p>
<p>　　应用在求值顺序上，有以下推论（非决定性求值规则）：除因果性和二元关系的一般性质的推论外，任意表达式的求值之间无序。</p>
<p><strong>原理</strong></p>
<p>　　在先发生和在后发生可描述系统中的<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">并发的</a>事件。<a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/Time-Clocks-and-the-Ordering-of-Events-in-a-Distributed-System.pdf">原始定义</a>包括对<em>时钟(clock)</em> 的抽象，但此处不要求指定。</p>
<p>　　[ISO C++] 和 [Rust] 等使用类似的方式描述并发的求值的支持。这些设计中，不同执行线程中具有特定的操作定义具体的顺序关系。其中具体规则的设计可能不同而不保证完全一一对应。</p>
<p>　　因<a href="#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">可扩展</a>和<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a> NPL 不在此明确指定此类具体操作，而由派生实现定义。</p>
<p>　　及非决定性规约规则允许在语言中表达<a href="#%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0">并发实现</a>。</p>
<p><strong>注释</strong></p>
<p>　　读和写作为影响可观察行为的事件结果，具有因果性。此外，也可以抽象为计算作用并由程序操作；这里不做要求。</p>
<h3 id="求值性质"><a class="header" href="#求值性质">求值性质</a></h3>
<p>　　两个具体求值等价，当且仅当两者的作用相等。</p>
<p>　　两个求值等价，当且仅当作为具体求值时等价，或其中每个求值的变换实质蕴含另一个。</p>
<p>　　没有<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>的求值是<em>纯的(pure)</em> 。</p>
<p><strong>注释</strong> 推论：纯求值仅有<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值计算</a>或抽象求值。</p>
<p>　　值为被求值的表达式自身的具体求值或不包含变换为存在不等价求值的表达式的抽象求值为<em>恒等(identity)</em> 求值。</p>
<p>　　恒等的纯求值是<em>空求值(empty evaluation)</em> 。</p>
<p>　　作用是空集的表达式求值是<em>空作用求值(null effect evaluation)</em> 。</p>
<p><strong>注释</strong> 推论：空作用求值是空求值。</p>
<p>　　<a href="#%E8%AF%AD%E6%B3%95%E5%BD%A2%E5%BC%8F">语法形式</a>固定且求值总是空求值的表达式是<em>空表达式(empty expression)</em> ，这仅由派生实现可选提供。</p>
<h3 id="范式"><a class="header" href="#范式">范式</a></h3>
<p>　　<em>规范化形式(normalized form)</em> ，或简称<em>范式(normal form)</em> ，是由派生实现定义的<a href="#%E8%A1%A8%E7%A4%BA">表示</a>，被一组<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">规约</a>规则确定，满足：</p>
<ul>
<li>通过有限的规约步骤后得到。</li>
<li>按规约规则，规范形式上不存在不<a href="#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">和空求值等价</a>的进一步规约。</li>
</ul>
<p>　　在具有 <a href="#%E6%BC%94%E7%BB%8E%E8%A7%84%E5%88%99">Church–Rosser 属性的重写系统</a>中，一个对象若具有范式则唯一。</p>
<p>　　表达式在得到规范形式后规约终止，且蕴含求值终止。</p>
<p>　　得到范式的规约步骤称为<em>规范化(normalization)</em> 。</p>
<p>　　若表达式规约总是能得到规范形式（求值总是能在有限规约步骤后终止），则具有<em>强规范化(strong normalization)</em> 性质。</p>
<p>　　实现应避免引起对象语言的语义表达以外的无法保证强规范化性质的操作（如直接无条件的递归规约调用）。</p>
<p>　　除非派生实现另行指定，不保证强规范化性质。</p>
<p>　　保证得到范式的规约是规范化规约。</p>
<p>　　<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">具体求值</a>得到的范式若可作为表达式，其<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>是和被求值的项等价的表达式的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>，即仅允许<a href="#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">恒等求值</a>而仍是范式；这样的项称为<em>自求值项(self-evaluating term)</em> 。</p>
<p>　　作为表达式的自求值项是<em>自求值表达式(self-evaluating expression)</em> 。</p>
<p>　　重复求值直至取得自求值项的求值结果是<em>最终求值结果(final evaluation result)</em> 。</p>
<p><strong>注释</strong></p>
<p>　　推论：最终求值结果上可能的求值是<a href="#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>。因此，取得最终求值结果后，即排除具有<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>的继续求值。</p>
<h3 id="规范化中间表示"><a class="header" href="#规范化中间表示">规范化中间表示</a></h3>
<p>　　第一个<a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F">子表达式</a>（头表达式）是<a href="#%E8%8C%83%E5%BC%8F">范式</a>的表达式是 HNF（Head Normal Form ，头范式）。</p>
<p>　　头表达式是可直接求值为范式的表达式是 WHNF（Weak HNF，弱头范式）。</p>
<p><strong>注释</strong> 约定求值到 WHNF 提供保证<a href="#%E8%8C%83%E5%BC%8F">强规范化性质</a>的一般手段，可用于<a href="#%E4%B8%A5%E6%A0%BC%E6%80%A7">非严格求值</a>。</p>
<p>　　WHNF 的头表达式是<em>操作符(operator)</em> ，存在对应 HNF 的头表达式的<a href="#%E8%8C%83%E5%BC%8F">最终求值结果</a>。</p>
<p><strong>注释</strong> 详见<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>。</p>
<p>　　WHNF 中除了操作符以外的子表达式是<em>操作数(operand)</em> 。</p>
<p>　　操作数以具有限定顺序或不限定顺序的数据结构表示。</p>
<p>　　按操作数的数据结构对应有<em>操作数列表(operand list)</em> 和<em>操作数树(operand tree)</em> 。其中操作数树是有限的树形数据结构的 <a href="#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">DAG</a> ，其具体构造和表示由派生实现定义。</p>
<p><strong>注释</strong> 操作数树和 [R<sup>n</sup>RK] 类似。语言可能进一步约定有序的数据结构表示操作数的组成部分之间在求值上不等价。</p>
<p>　　这种能以操作符和操作数的组合表达的计算形式是<em>操作(operation)</em> 。</p>
<p>　　操作的<em>结果(result)</em> 是表达规约步骤得到的范式；操作的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>是取得对应结果的规约步骤的作用。</p>
<p><strong>注释</strong> <a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>中可蕴含操作的结果，也可<a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%9D%A1%E4%BB%B6">具有其它作用</a>。若操作的结果存在，则同时是这个合并子的<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">调用</a>的结果，即<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>。</p>
<p>　　若操作的结果不依赖<a href="#%E7%AE%A1%E7%90%86%E8%A7%84%E7%BA%A6">管理规约</a>，操作的结果和作用即这种可求值为 WHNF 表达式的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>和作用。</p>
<p><strong>注释</strong> 另见<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>。</p>
<p>　　关于 DAG ，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h3 id="组合求值"><a class="header" href="#组合求值">组合求值</a></h3>
<p>　　表达式和<a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F">子表达式</a>之间的求值需满足一定约束。</p>
<h4 id="递归蕴含规则"><a class="header" href="#递归蕴含规则">递归蕴含规则</a></h4>
<p>　　表达式和子表达式之间的求值满足以下递归蕴含规则：</p>
<ul>
<li>求值依赖规则：除非另行指定，表达式被求值实质蕴含子表达式被求值。</li>
<li>顺序依赖规则：求值子表达式的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值计算</a><a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序</a>所在的表达式的值计算。</li>
<li>平凡求值规则：指定一个表达式是<a href="#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>或<a href="#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">空求值</a>对应实质蕴含其子表达式的求值被指定为纯求值或空求值。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　一般地，一些<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">求值策略</a>可以不遵循求值依赖规则。</p>
<p>　　顺序依赖规则是<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">因果性</a>的具体表现之一。对不被求值的表达式，此规则不生效。构造不同的表达式进行计算可实现和直接违反此规则等效的作用，但因为是不同的表达式，实际上不违反此规则。</p>
<p>　　附加的顺序依赖规则可由特定的实体构成的表达式的求值隐含指定。相同的表达式可能在不同上下文中使用不同的规则。</p>
<h4 id="严格性"><a class="header" href="#严格性">严格性</a></h4>
<p>　　若表达式的任意子表达式的求值总是<a href="#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">非空求值</a>且<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序</a>表达式求值，则这个表达式的求值是<em>严格的(strict)</em> ；反之，求值是<em>非严格的(non-strict)</em> 。</p>
<p>　　推论：严格求值满足<a href="#%E9%80%92%E5%BD%92%E8%95%B4%E5%90%AB%E8%A7%84%E5%88%99">顺序依赖规则</a>。</p>
<p>　　非严格求值在规约时可保留未引起作用（通常即未被求值）的部分子表达式，允许实现根据先序的求值作用确定的选择性求值，即包括未指定是否作为<a href="#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">空求值</a>的子表达式求值，如分支判断或短路求值。</p>
<p><strong>注释</strong> 例如：ISO C++ 的条件表达式存在可能未被求值的<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>，属于非严格求值；<code>++</code> 表达式不作为<em>完全表达式(full expression)</em> 时，副作用可超出此表达式的求值（不满足顺序依赖规则），也是非严格求值。</p>
<p>　　表达式经过<em>严格性分析(strictness analysis)</em> 确定是否严格求值，通过<em>严格性分析器(strictness analyzer)</em> 在<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">语义分析</a>时实现。</p>
<p>　　<em>中间值(thunk)</em> 是保留不直接实现<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">具体求值</a>的部分子表达式的特定的数据结构。</p>
<p><strong>注释</strong> 例如，通过保留中间值待延迟求值，可实现子表达式值的<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按需传递</a>。</p>
<h4 id="顺序求值"><a class="header" href="#顺序求值">顺序求值</a></h4>
<p>　　明确的词法顺序可为同一个表达式的若干子表达式提供一致的有序<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">求值策略</a>：从左到右或从右到左。为一致性，不需要考虑其它特定顺序作为一般规则。</p>
<p>　　递归文法表示的表达式和子表达式之间存在相对内外顺序：子表达式在表达式的内部。此求值顺序可对应表达式树的遍历顺序。</p>
<h4 id="替换策略"><a class="header" href="#替换策略">替换策略</a></h4>
<p>　　对应项的规约规则的表达式的重写规则由派生实现定义，典型的可选项包括：</p>
<ul>
<li>名称替换：保证替换前后项对应的<a href="#%E5%90%8D%E7%A7%B0">名称</a>不变。</li>
<li>实体替换：保证替换前后项关联的实体不变。</li>
<li>值替换：保证替换前后项关联的表达式的值满足实现定义的相等关系。这包括以下不同的变体：
<ul>
<li>值副本替换：保证替换前后项关联的表达式的值满足值替换的关系，且以实现定义的方式引用不同的<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">实体的副本</a>。</li>
<li><a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>替换：保证替换前后项关联的表达式的值满足值替换的关系，且以实现定义的方式引用同一实体。</li>
</ul>
</li>
</ul>
<h4 id="求值策略"><a class="header" href="#求值策略">求值策略</a></h4>
<p>　　组合严格、顺序求值和替换策略可得到不同性质的求值策略。</p>
<p>　　除非派生实现约定，表达式求值策略可以随具体<a href="#%E8%AF%AD%E6%B3%95%E5%BD%A2%E5%BC%8F">语法形式</a>不同而不同。</p>
<p>　　典型性质组合如下：</p>
<ul>
<li>严格求值：
<ul>
<li>应用序(applicative order) ：以<em>最左最内(leftmost innermost)</em> 优先的顺序求值。
<ul>
<li>最左的顺序仅在操作数是<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">有序数据结构</a>时有意义；不考虑操作数内部构造时，仅表示操作数作为子表达式总是被求值，和严格求值等价。</li>
</ul>
</li>
<li>按值传递(pass by value) ：使用值替换的严格求值。
<ul>
<li>按值的副本传递(pass by value copy) ：创建<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">值的副本</a>进行替换的严格求值。</li>
<li>按<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>传递(pass by reference) ：使用引用替换的严格求值。</li>
</ul>
</li>
<li>共享对象传递(pass by shared object) ：使用的共享机制以及对象和值或引用的关系由派生实现定义。</li>
<li>部分求值(partial evaluation) ：允许求值分为多个<em>阶段(phase)</em> 分别进行。</li>
</ul>
</li>
<li>非严格求值：
<ul>
<li>正规序(normal order) ：以<em>最左最外(leftmost outmost)</em> 优先的顺序求值。
<ul>
<li>最左的顺序的意义同应用序。</li>
</ul>
</li>
<li>按名传递(pass by name) ：使用名称替换且保持作为名称的表达式最后被替换的求值。</li>
<li>按需传递(pass by need) ：按名传递但允许合并作用相同的表达式。</li>
</ul>
</li>
<li><a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">非决定性</a>求值：
<ul>
<li>完全归约(full reduction) ：替换不受到作用之间的依赖的限制。</li>
<li>按预期传递(pass by future) ：并发的按名传递，在需要使用参数的值时同步。</li>
<li>乐观求值(optimistic evaluation) ：部分子表达式在未指定时机部分求值的按需求值，若超出约定时限则放弃并回退到按需求值。</li>
</ul>
</li>
</ul>
<h3 id="可选求值规则"><a class="header" href="#可选求值规则">可选求值规则</a></h3>
<p>　　应满足的本节上述约定的最小求值规则和语义外的具体求值的规则和语义由派生实现定义。</p>
<p>　　派生实现的求值可满足以下节指定语义，此时应满足其中约定的规则。</p>
<p>　　若可选求值规则逻辑上蕴含规约规则，则被蕴含的规约规则的直接表述可在语言规则中被省略。</p>
<h3 id="上下文相关求值"><a class="header" href="#上下文相关求值">上下文相关求值</a></h3>
<p>　　在被求值的表达式以外，对应的规约规则在实现此规约的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>中可能是<a href="../Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">上下文</a>相关的，这种附加依赖的上下文为<em>求值上下文(evaluation context)</em> 。</p>
<p>　　求值上下文被作为元语言实现对象求值规则时的输入，可指定项所在的位置等不被被规约的项必然蕴含的附加信息。</p>
<p>　　由派生实现定义的特定求值上下文称为<em>尾上下文(tail context)</em> 。以尾上下文求值可提供附加的保证。</p>
<p>　　作为<a href="#%E9%A1%B9%E9%87%8D%E5%86%99%E7%B3%BB%E7%BB%9F">项重写系统的上下文</a>的实例，元语言中，一般的求值上下文 <code>C</code> 形式化为具有占位符 <code>[]</code> 和可选前缀 <code>v</code> 及可选后缀 <code>e</code> 的递归组合的串：</p>
<pre><code class="language-xbnf">C ::= [] | Ce | vC
</code></pre>
<p>　　其中 <code>e</code> 是被求值表达式，<code>v</code> 是作为<a href="#%E8%8C%83%E5%BC%8F">范式</a>的值。</p>
<p>　　除非另行指定，NPL 对象语言的<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>使用的求值上下文总是<a href="#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">求值环境</a>。</p>
<p><strong>原理</strong></p>
<p>　　通过附加适当的求值规则保证对象语言中的表达式总是可唯一地被分解为这种表示，抽象的求值上下文可直接实现对象语言的求值。但语义描述和实现的基准都以<a href="#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机</a>替代，因为：</p>
<ul>
<li>抽象机语义允许不依赖<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源程序</a>的<a href="#%E8%A1%A8%E7%A4%BA">表示</a>和构造（如特定的表达式的文法）。</li>
<li>这种分解一般要求遍历对象语言的源程序而难以具有较好的可实现性质，如<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算复杂度</a>。</li>
<li>为满足良好的可实现性质，需描述实现中可能具有的离散状态与只和其中个别状态关联的局部的求值规则时，这种分解通常会渐进演化为某种抽象机的表示。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　使用求值环境作为默认的上下文确保一般的求值总是能支持变量的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">绑定</a>。</p>
<p>　　对象语言的实现同时能够支持其它上下文，即使它不在求值算法中出现。这样的上下文可能被求值上下文蕴含而可被推理确定。</p>
<h2 id="λ-完备语义和对应语法"><a class="header" href="#λ-完备语义和对应语法">λ 完备语义和对应语法</a></h2>
<p>　　作为通用语言，求值规则表达的系统可具有和<a href="#%E6%A8%A1%E5%9E%8B">无类型 λ 演算</a>对应的形式和计算能力。</p>
<p>　　基于此语义的派生实现应允许以下几种互不相交的表达式集合：</p>
<ul>
<li><a href="#%E5%90%8D%E7%A7%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">名称表达式</a></li>
<li><a href="#%E5%87%BD%E6%95%B0">匿名函数</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数应用</a></li>
</ul>
<p>　　NPL 不要求以上表达式中函数以外的表达式求值的<a href="#%E8%8C%83%E5%BC%8F">强规范化</a>。</p>
<p><strong>注释</strong></p>
<p>　　无类型 λ 演算保证名称表达式（变量）和函数（ λ 抽象）的规约的强规范化，但不保证函数应用规约的强规范化。</p>
<p>　　扩展的 λ 演算（如<a href="https://zh.wikipedia.org/zh-cn/%E7%AE%80%E5%8D%95%E7%B1%BB%E5%9E%8B%CE%BB%E6%BC%94%E7%AE%97">简单类型 λ 演算</a>）可保证规约函数应用的强规范化。</p>
<h3 id="名称表达式"><a class="header" href="#名称表达式">名称表达式</a></h3>
<p>　　<em>名称表达式(name expression)</em> 是表示变量的 λ 项。</p>
<p>　　<a href="#%E5%8E%9F%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F">原子表达式</a>的由派生实现定义的非空子集是名称表达式。其它作为名称表达式的表达式<a href="#%E8%AF%AD%E6%B3%95%E5%BD%A2%E5%BC%8F">语法形式</a>由派生实现定义。</p>
<p>　　名称表达式不被进一步规约；其求值是<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">值替换规则</a>的平凡形式。</p>
<h3 id="函数"><a class="header" href="#函数">函数</a></h3>
<p>　　<em>函数(function)</em> 是一种参与特定规约规则的实体，也可以指求值为函数实体的表达式。</p>
<p>　　一般地，函数表达式在 <a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">WHNF</a> 下作为<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作符</a>被求值，其<a href="#%E8%8C%83%E5%BC%8F">最终求值结果</a>为函数实体，或函数对象（若函数在语言中允许作为对象）。</p>
<p>　　NPL 中，作为<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>的函数表达式的最终求值结果是<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>。</p>
<p>　　一个函数表达式是以下两种表达式之一：</p>
<ul>
<li>保持<a href="#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">等价地</a>求值到其它函数表达式上的<a href="#%E5%90%8D%E7%A7%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">名称表达式</a>，称为<em>具名函数表达式(named function expression)</em> ，简称<em>具名函数(named function)</em> 。</li>
<li>满足本节以下规则的由派生实现定义的<em>匿名函数表达式(anonymous function expression)</em> ，简称<em>匿名函数(anonymous function)</em> 。</li>
</ul>
<p>　　函数应确定替换重写规则<a href="#%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5">被替换的目标</a>，即<em>函数体(function body)</em> 。</p>
<p>　　除非派生实现另行指定，函数不需要被进一步规约，此时其求值是<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">值替换规则</a>的平凡形式。</p>
<p>　　在<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">类型系统</a>中，函数可被指派<em>函数类型(function type)</em> 。函数类型能蕴含<a href="#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">参数</a>和结果的<a href="#%E7%B1%BB%E5%9E%8B">类型</a>。</p>
<p><strong>注释</strong> 例如，在简单类型 λ 演算中，函数类型是<a href="#%E7%B1%BB%E5%9E%8B">类型构造器</a> <code>→</code> 组合输入（参数）和结果（输出）类型的<a href="#%E7%B1%BB%E5%9E%8B">复合类型</a>。</p>
<h4 id="函数内部的变量"><a class="header" href="#函数内部的变量">函数内部的变量</a></h4>
<p>　　匿名函数可以显式指定（<em>绑定(bind)</em> ）包含若干变量使之成为<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">约束变量</a>的语法构造。</p>
<p>　　通过创建函数时的显式的语法构造引入的这种变量称为函数的<em>形式参数(formal parameter, parameter)</em> 。</p>
<p>　　除绑定外，匿名函数蕴含<a href="#%E9%A1%B9%E9%87%8D%E5%86%99%E7%B3%BB%E7%BB%9F">上下文</a>可以<a href="#%E9%A1%B9%E9%87%8D%E5%86%99%E7%B3%BB%E7%BB%9F">捕获</a>若干在函数体以外的同名的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">自由变量</a>。</p>
<p>　　通过绑定或捕获引入的变量允许在函数体中允许使用。</p>
<p>　　使用<a href="#%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83%E6%8F%90%E4%BE%9B%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">词法作用域</a>时，若匿名函数所在<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用域</a>的存在同名的<a href="#%E5%90%8D%E7%A7%B0">名称</a>，则被捕获的名称被<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">隐藏</a>。形式参数隐藏被捕获的<a href="#npla-%E7%8E%AF%E5%A2%83">变量名</a>。</p>
<p>　　派生实现的语义规则应满足和 λ 演算的语义的 α-转换(alpha-conversion) 规则不矛盾。</p>
<p><strong>注释</strong> <a href="#vau-%E6%8A%BD%E8%B1%A1">Vau 演算</a>在没有限定<a href="#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">环境</a>时不考虑一般意义上的自由变量。</p>
<p>　　函数应用的求值决定被绑定的变量和函数体内的变量之间的关系，参见<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>。此时，<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">求值策略</a>蕴含的<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">替换策略</a>蕴含被绑定的变量和函数体内的变量之间的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>。</p>
<p>　　类似地，在被捕获的变量到函数体内捕获的变量之间，也有和替换策略一一对应的不同捕获策略。</p>
<p>　　除非另行指定，变量被<em>按引用捕获(captured by reference)</em> 而非<em>按值的副本捕获(captured by value copy)</em> ，即通过捕获引入的变量是被捕获变量的引用而不是副本。</p>
<p><strong>原理</strong></p>
<p>　　捕获为引用而不是副本，保持被捕获的变量和函数体内同名变量的同一性，在实体是对象时不影响可观察行为。若这些捕获未被使用，可被实现直接移除。</p>
<h4 id="过程"><a class="header" href="#过程">过程</a></h4>
<p>　　<em>过程(procedure)</em> 是操作符<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">具现</a>的<em>可调用(callable)</em> 的实体，决定特定的可提供求值的作用（包括决定求值结果）的<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算</a>。</p>
<p>　　函数表达式的<a href="#%E8%8C%83%E5%BC%8F">最终求值结果</a>由过程实体的作用中的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">结果</a>决定，以派生实现定义的方式关联。</p>
<p>　　通过函数表达式可指定可选的<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">实际参数</a>，发生过程<em>调用(call)</em> 。过程的调用蕴含计算。</p>
<p>　　过程中和过程外的计算的组合满足<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">因果性</a>：</p>
<ul>
<li>以求值描述的过程中的作用整体非<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">后序</a>于引起过程中作用的外部环境的计算。</li>
<li>以求值描述的过程中的任意作用非后序于取得对应结果的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值计算</a>，即结果是决定值的作用的<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">依赖</a>。</li>
</ul>
<p>　　<em>主调函数(caller function)</em> 等<em>调用者(caller)</em> 或其它引起过程中的计算的实体<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">转移</a>计算蕴含的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制</a>到过程中的计算而使之<em>进入(enter)</em> 到<em>被调用者(callee)</em> 的过程。</p>
<p>　　过程可能被限制只有<em>一次(one-shot)</em> 调用有效；其它过程是<em>多次(multi-shot)</em> 的。</p>
<p>　　多次过程调用时控制可能通过调用被再次转移，即<em>嵌套调用(nested call)</em> 。</p>
<p>　　一些被多次调用的过程可能被多次进入，即<em>重入(reenter)</em> 。</p>
<p>　　一个调用中的重入相同或不同过程的次数称为调用的<em>深度(depth)</em> 。</p>
<p>　　推论：嵌套调用是深度大于 1 的调用。</p>
<p>　　通过嵌套调用直接（总是以自身作为调用者）或间接（通过其它调用者转移控制）的重入是<em>递归调用(recursive call)</em> 。</p>
<p>　　过程可以<em>返回(return)</em> 取得计算的值并可同时改变<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制状态</a>，影响之后的计算。</p>
<p><strong>原理</strong></p>
<p>　　一次过程，特别是在其内部涉及和<a href="#%E7%BB%AD%E5%BB%B6">续延</a>或<a href="#%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83%E6%8F%90%E4%BE%9B%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">闭包</a>的实现交互时，相对多次过程可能具有因其对持有资源的要求较宽松，而具有较小的性能开销。</p>
<p><strong>注释</strong></p>
<p>　　对象语言中的过程在描述操作语义的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>中可表示为函数，其应用可对应对象语言中过程的隐式调用。</p>
<p>　　违反一次过程调用有效地约束的程序典型地<a href="#%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　注意过程不一定可作为可被对象语言直接表达的<em>一等(first-class)</em> 函数，但同时在元语言中仍然可能可行。如<a href="#%E7%BB%AD%E5%BB%B6">无界续延</a>，因为可能不符合<a href="#%E5%87%BD%E6%95%B0">函数的类型要求</a>，详见<a href="#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延的捕获和调用</a>中的原理。</p>
<p>　　一次重入的过程调用分配的资源对应一个<a href="#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">活动记录帧</a>。</p>
<h4 id="过程调用的计算顺序"><a class="header" href="#过程调用的计算顺序">过程调用的计算顺序</a></h4>
<p>　　按计算的顺序约束和默认返回控制的方式，可能有不同的形式。</p>
<p>　　<em>例程(routine)</em> 的求值不<em>交叉(interleave)</em> ，即例程中的计算和例程外的计算<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">非决定性有序</a>。</p>
<p><strong>注释</strong> 典型地，例程中的计算通过例程作为函数实体创建时的函数体确定。</p>
<p>　　作为不同的例程，不考虑例程中的计算的<a href="#%E7%BB%AD%E5%BB%B6">续延</a>被保存时：</p>
<ul>
<li><em>子例程(subroutine)</em> 在返回一次后不<a href="#%E8%BF%87%E7%A8%8B">重入</a>。</li>
<li><em>协程(coroutine)</em> 则可能被多次重入并引起多次返回。</li>
</ul>
<p>　　和子例程的<a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%9D%A1%E4%BB%B6">正常控制</a>不同，即便其中的计算不涉及显式地改变控制状态，协程可能蕴含控制从协程中的计算到协程外的计算的<a href="#%E8%BF%87%E7%A8%8B">转移</a>：</p>
<ul>
<li>引起多次返回对应改变<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制作用</a>。</li>
<li>转移控制后，函数体中的计算被<em>暂停(suspended)</em> 。</li>
<li>重入的协程可<em>恢复(resume)</em> 被暂停的计算。
<ul>
<li>不排除可被重入的协程作为函数实体，是<em>可恢复函数(resumable function)</em> 。</li>
</ul>
</li>
<li>可被暂停和恢复的计算是<em>异步的(asynchrnous)</em> 。这和正常控制的<em>同步的(synchronous)</em> 的计算相对。</li>
</ul>
<p>　　一般的续延支持返回多次并可能支持和调用者并发的计算，包括异步的计算；而协程蕴含的控制作用的改变对应不同续延的替换，也能实现类似的支持。</p>
<p>　　语言的语法可显式指定例程创建协程，也可以当前的控制状态创建和现有的例程没有直接对应的协程。后者类似<a href="#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延捕获</a>。</p>
<p>　　NPL 支持函数求值得到过程。对象语言中的过程可能支持使用这些形式的一种或多种，具体形式由派生实现指定。</p>
<p>　　协程可能限制转移向下一步骤的计算转移的方向，即调用者和被调用者被通过创建其的语法构造确定，而不能在之后改变。</p>
<p>　　根据是否只提供一种不区分转移方向的原语，协程分为<em>对称(symmetric)</em> 和<em>非对称(asymmetric)</em> 协程：</p>
<ul>
<li>对称协程转移控制到另一个协程，不需要单独区分不同的操作。
<ul>
<li>转移控制的源和目标之间没有<a href="#%E8%BF%87%E7%A8%8B">调用者</a>和<a href="#%E8%BF%87%E7%A8%8B">被调用者</a>的相对关系。</li>
</ul>
</li>
<li>非对称协程对控制的转移分为<em>调用(invoke)</em> 和<em>出让(yield)</em> 操作，其中：
<ul>
<li>调用操作从调用者转移控制到被调用者，恢复之前保存的上下文（若有）或创建时的初始上下文。</li>
<li>出让操作暂停和保存当前上下文并返回（转移）控制到它的调用者。
<ul>
<li>一般地，转移控制的具体时机未指定，可蕴含（对应续延的）<a href="#%E7%BB%AD%E5%BB%B6">调度</a>和<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">并发</a>执行。</li>
</ul>
</li>
</ul>
</li>
<li>一些协程称为<em>半(semi)</em> 异步协程（半协程），以体现实现异步计算的控制转移形势受限的非典型性。对应地，没有此类限制的协程被称为<em>全(full)</em> 异步协程（全协程）。
<ul>
<li>通常半协程指对控制的转移（相对传统的例程调用）受限，不能仅通过调用而需要单独的出让操作实现计算的暂停。这是非对称协程的同义词。</li>
<li>但半协程也可能指特指暂停在特定上下文受限的协程实现。</li>
<li><strong>注释</strong> 另见<a href="http://www.lua.org/pil/9.1.html">这里</a>的说明。</li>
</ul>
</li>
</ul>
<p>　　根据是否协程持有<a href="#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">活动记录帧</a>，协程分为<em>有栈(stackful)</em> 和<em>无栈(stackless)</em> 的。</p>
<ul>
<li>两者提供不同的资源<a href="#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权</a>，而可能影响使用这些特性的程序中的资源的<a href="#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>。</li>
<li>特别地，无栈协程不保证活动记录的可用性，无法直接支持创建的协程作为一等对象使用。</li>
</ul>
<p>　　因为具有类似的改变控制的能力，有栈的、可作为<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>的<em>全协程(full coroutine)</em> 可替代<a href="#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">一等续延</a>。</p>
<p><strong>原理</strong></p>
<p>　　协程可视为是在计算上<a href="#%E5%AE%8C%E6%95%B4%E6%80%A7">可表达性</a>等价的<a href="#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">一次续延</a>：</p>
<ul>
<li>参见<a href="http://www.cs.tufts.edu/comp/250RTS/archive/roberto-ierusalimschy/revisiting-coroutines.pdf">这里</a>。</li>
<li>其中，对称协程类似一次<a href="#%E7%BB%AD%E5%BB%B6">无界续延</a>，非对称协程类似一次<a href="#%E7%BB%AD%E5%BB%B6">有界续延</a>。
<ul>
<li>对称协程可通过非对称协程补充操作实现。
<ul>
<li><strong>注释</strong> 一个这种设计的例子参见 <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0913r0.html">[WG21 P0913R0]</a> 。</li>
</ul>
</li>
<li>类似地，有界续延可<a href="#%E7%BB%AD%E5%BB%B6">通过添加显式的界限实现无界续延</a>。</li>
<li>但是，这种功能相似不表示一一对应。
<ul>
<li><strong>注释</strong> 参见以下关于出让操作使用续延实现的讨论。</li>
</ul>
</li>
</ul>
</li>
<li>在核心语言支持<em>存储(store)</em> 即<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">可修改</a>的<a href="#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">一等状态</a>的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>的前提下，非对称协程和对称协程在可表达性上等价。
<ul>
<li>有界续延可不依赖其它副作用表达状态，但<a href="#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">无界续延无法表达</a>。</li>
</ul>
</li>
<li>一等续延和协程在一定条件下可互相实现。
<ul>
<li>对称协程可实现一次续延。
<ul>
<li><strong>注释</strong> 另见<a href="http://www.inf.puc-rio.br/~roberto/docs/MCC15-04.pdf">这里</a>，但这个实现没有检查续延调用内部可能的非预期重入，且不满足 [Hi90] 中的 <a href="#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C-ptc">PTC 要求</a>。</li>
<li>因此，作为一等对象时，协程可作为一等续延的替代实现方式。</li>
</ul>
</li>
<li>非对称协程的出让操作可通过无界续延实现。
<ul>
<li>虽然可实现出让操作的<a href="#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延捕获</a>并非<a href="#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延调用</a>，但续延调用对控制的转移不必然蕴含区分调用和调用者。
<ul>
<li>事实上，使用 <code>call/cc</code> 捕获续延创建的是无界续延。</li>
</ul>
</li>
<li>有界续延可实现无界续延，因此出让操作也可使用有界续延实现。</li>
<li><strong>注释</strong> 另见<a href="https://cs.indiana.edu/~sabry/papers/yield.pdf">这里</a>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　典型的设计中，函数表达式默认创建例程，而协程使用特设的语法标记过程得到。特设的关键字（如 <code>yield</code> ）提供语法，对应非对称协程中的出让操作。</p>
<p><strong>注释</strong></p>
<p>　　关于过程的参数和过程调用之间的计算顺序，参见<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">求值策略</a>。</p>
<h4 id="λ-抽象"><a class="header" href="#λ-抽象">λ 抽象</a></h4>
<p>　　λ 抽象(lambda abstraction) 是 λ 演算中的基本构成之一，提供匿名函数。</p>
<p><strong>注释</strong> λ 抽象的语法包含的形式是典型的操作符。</p>
<p>　　在原始的无类型 λ 演算中，λ 抽象<a href="#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">不支持蕴含副作用</a>，子表达式求值顺序任取而不改变<a href="#%E8%8C%83%E5%BC%8F">范式</a>的存在性和值。</p>
<p>　　在使用<a href="#%CE%BB-%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">热情求值</a>的语言中，λ 抽象创建的过程是应用<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>。</p>
<h4 id="vau-抽象"><a class="header" href="#vau-抽象">vau 抽象</a></h4>
<p>　　Vau 抽象(vau abstraction) 是 vau 演算 ([Shu10]) 中的基本构成之一。</p>
<p>　　Vau 抽象创建的过程是操作<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>。</p>
<p><strong>注释</strong> 使用 vau 抽象可实现引入 λ 抽象的操作符，如 [R<sup>n</sup>RK] 提供的 <code>$vau</code> 操作合并子。</p>
<h3 id="函数合并"><a class="header" href="#函数合并">函数合并</a></h3>
<p>　　具有操作符和操作数的项的组合可被特定的方式进行规约。这种组合是<em>函数合并(function combination)</em> ，包含：</p>
<ul>
<li>具有至少一个约定位置的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">子项</a> <code>E1</code> 的<a href="#%E5%A4%8D%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F">复合表达式</a> <code>E</code> ，当且仅当 <code>E1</code> 是被求值作为<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作符</a>的函数时，<code>E</code> 是<em>函数合并表达式(function combination expression)</em> 。</li>
<li>其它具有操作符和操作数的项是非表达式形式的函数合并。以下操作符和操作数记作 <code>E1</code> 和 <code>E2</code> 。</li>
</ul>
<p>　　以下规则中，非表达式形式的函数合并也可被视为表达式求值。</p>
<p>　　求值函数合并时，子项 <code>E1</code> 总是被求值。</p>
<p>　　除 <code>E1</code> 外表达式的剩余子项 <code>E2</code> 是<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>，在 E 被求值时以操作数决定的值等效<em>替换(substitute)</em> 函数的<a href="#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">形式参数</a>。</p>
<p>　　替换形式参数的值是<em>实际参数(actual argument, argument)</em> 。</p>
<p>　　函数合并的求值是<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">值替换规则</a>的非平凡形式。</p>
<p>　　若替换操作数 <code>E2</code> 在合并中被求值，函数合并 E 是函数应用表达式，简称<em>函数应用(function application)</em> 。</p>
<p>　　若操作符是 λ 抽象，<code>E2</code> 视为一个整体，则函数应用替换规则对应 λ 演算的 β-规约(beta-reduction) 规则。</p>
<p>　　其它函数合并使用的替换规则由派生实现指定。</p>
<p>　　派生实现应指定函数合并<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">规约</a>的结果是<a href="#%E8%8C%83%E5%BC%8F">规范形式</a>，它对应的值是函数合并的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>替换被求值的表达式的实体，称为<em>函数值(function value)</em> 。</p>
<p>　　函数应用匹配实际参数和对应的引入形式参数的构造。匹配可能失败。确定匹配参数成功的条件是等价关系，称为参数匹配一致性，由参数匹配的等价关系指定。</p>
<p>　　匹配成功的每个实际参数和被匹配的目标（可能是形式参数）具有一对一或多对一的对应关系。</p>
<p>　　伴随参数匹配，实现可引入其它必要的操作（如为匹配分配资源和确定上述对应关系）。这些操作可具有和确定参数对应关系的匹配之间<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">非决定性有序</a>的副作用。</p>
<p>　　仅当上述必要操作及所有实际参数的匹配成功，替换 <code>E1</code> 决定的某个关联表达式中和形式参数结构一致的子表达式为实际参数。替换参数的结构一致性是等价关系。</p>
<p>　　表达式相等蕴含参数匹配一致性和替换结构一致性。实现可分别定义其它规则扩充这些等价关系的外延。</p>
<p>　　替换参数的值蕴含对实际参数的计算的依赖，即参数若被求值，其<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值计算</a><a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序</a>函数应用的求值；但其它求值顺序没有保证。</p>
<p><strong>注释</strong></p>
<p>　　一般地，根据 <code>E1</code> 的值，操作数或操作数的值计算的结果被作为实际参数。</p>
<p>　　<a href="#%E8%BF%87%E7%A8%8B">过程</a>及其调用在其操作语义的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>中通常表达为函数及函数合并。</p>
<p>　　若过程的结果被忽略，则通常表达为<a href="#%E7%B1%BB%E5%9E%8B">单元类型</a>的值。</p>
<p>　　此外，一些语言中忽略过程的结果是<a href="#%E7%B1%BB%E5%9E%8B">空类型</a>，以检查错误的使用。NPL 不要求语言具有<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态类型</a>规则，也不要求这些检查。</p>
<h4 id="函数调用"><a class="header" href="#函数调用">函数调用</a></h4>
<p>　　求值函数合并包含子表达式的求值：总是求值操作符，并可能求值操作数。若这些求值都没有退出，则发生函数<em>调用(call)</em> ，函数是<em>被调函数(called function)</em> 。</p>
<p>　　若被调函数存在形式参数，函数调用首先以操作数的直接子表达式作为实际参数，匹配实际参数和形式参数。</p>
<p>　　若实际参数匹配的目标可指定一个变量，则伴随参数匹配的操作包括以特定规则<a href="#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">绑定</a>的形式参数。</p>
<p>　　绑定的实际参数和对应的形式参数作为不同的实体时，作为伴随参数匹配的必要操作的一部分，发生<em>参数传递(parameter passing)</em> 。参数传递使形式参数具有作为实际参数值的副本。参数传递可能使和实际参数相关的资源被复制或转移。</p>
<p>　　实现在函数合并的求值中应提供函数调用的支持。</p>
<p>　　函数调用确定副作用的边界：保证参数表达式在函数应用被求值之前被求值。</p>
<p>　　在控制<a href="#%E8%BF%87%E7%A8%8B">返回</a>时，函数调用内部确定的值最终替换被求值的函数合并而作为函数值，即为<em>返回值(return value)</em> 。</p>
<p>　　若函数是<a href="#%E8%BF%87%E7%A8%8B">过程</a>，对应的函数调用是<em>过程调用(procedure call)</em> 。</p>
<p>　　若一个函数的调用仍待返回，则该函数调用是<em>活动的(active)</em> 。</p>
<p>　　调用总是不蕴含非<a href="#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>的函数是<em>纯函数(pure function)</em> 。</p>
<p>　　函数调用的中蕴含的求值对应的<a href="#%E8%A7%84%E7%BA%A6%E8%A7%84%E5%88%99%E5%92%8C%E6%B1%82%E5%80%BC">规约步骤</a>的集合是它的<em>动态范围(dynamic extent)</em> 。</p>
<p>　　函数中被<a href="#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">捕获</a>的实体的引用和求值函数中的计算创建的对象的引用构成函数计算的结果时，引用可能<em>逃逸(escape)</em> ，即在调用的动态范围以外可访问。</p>
<p>　　派生实现可能约定附加的名义特征区分其它情形相同的调用，称为<em>调用约定(calling convention)</em> 。</p>
<p><strong>注释</strong></p>
<p>　　典型实现的函数指称过程，函数调用是过程调用。</p>
<p>　　一般地，被调用的函数及函数调用的作用的等价性通常不能被确定。</p>
<p>　　一个重要的子类是<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">不能确定具体表示</a>的情形，参见<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>。其它函数一般也有类似限制。</p>
<p>　　关于函数调用中的求值，另见函数调用的<a href="#%E7%BB%88%E6%AD%A2%E4%BF%9D%E8%AF%81">终止保证</a>。</p>
<p>　　和 [R<sup>n</sup>RS] 不同，动态范围仅对求值定义，而不是关于环境中的绑定显示<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">计算作用</a>的属性。这种属性事实上对象的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>，仅对对象而非更一般的实体有效。</p>
<p>　　<a href="#%E7%BB%AD%E5%BB%B6">续延</a>可用其动态范围表示。</p>
<p>　　本文档的动态范围的概念定义和 [R<sup>n</sup>RK] §7.1 的定义兼容，但不依赖其对续延的描述，也适用<a href="#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机语义</a>，是 [R<sup>n</sup>RK] 的一般化。</p>
<p>　　[Racket] 使用求值的规约步骤在表达式上定义动态范围。NPL 不在表达式上采用类似的定义，因为：</p>
<ul>
<li>类似 [R<sup>n</sup>RK] ，NPL 强调支持对象语言中的<a href="#%E5%85%B6%E5%AE%83%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8F%82%E8%80%83">显式求值风格</a>及表达式求值前后的不同。</li>
<li>类似 [R<sup>n</sup>RK] ，进一步地，NPL 派生语言（如 NPLA1 ）可明确支持在对象语言中指定<a href="#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">求值环境</a>而改变求值的上下文，表达式不能被预期通常以<a href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">上下文</a>无关的方式被求值。</li>
</ul>
<p>　　调用约定可提升实现细节，为<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>提供接口保证，避免非预期的不兼容实现的混合。</p>
<h4 id="合并子"><a class="header" href="#合并子">合并子</a></h4>
<p>　　除非另行指定，NPL 假定函数合并满足以下典型情形，即函数合并的<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作符</a>求值为以下类型的<em>合并子(combiner)</em> 之一：</p>
<ul>
<li>对操作数的直接<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作</a>（而不要求对操作数求值）的合并子是<em>操作合并子(operative combiner)</em> ，简称<em>操作子(operative)</em> 。</li>
<li>进行函数应用的合并子是<em>应用合并子(applicative combiner)</em> ，简称<em>应用子(applicative)</em> 。</li>
<li>由派生实现定义的<em>扩展合并子(extended combiner)</em> 。</li>
</ul>
<p>　　合并子的函数应用（依赖对操作数进行至少一次求值）是<em>合并子应用(combiner application)</em> 。</p>
<p>　　合并子应用使用<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">应用序</a>。</p>
<p>　　应用子总是对应一个<em>底层(underlying)</em> 合并子，可通过底层合并子上的一元的<em>包装(wrap)</em> 操作得到；其逆操作为<em>解包装(unwrap)</em> 。</p>
<p>　　解包装结果不是扩展合并子的合并子称为<em>真合并子(proper combiner)</em> 。</p>
<p>　　合并子上可以定义若干等价关系，这些等价关系蕴含关于函数应用替换的基本形式：</p>
<p>　　若对任意上下文，替换一个应用中的合并子为另一个不改变函数应用替换的结果，则这两个合并子等价（对应 λ 演算的 β-等价）。</p>
<p><strong>注释</strong></p>
<p>　　合并子被<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">调用</a>时通常<a href="#%E8%BF%87%E7%A8%8B">返回</a>且仅返回一次。</p>
<p><strong>注释</strong> 详见<a href="#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延的捕获和调用</a>。</p>
<p>　　由于程序可能引入未知具体表示的合并子（如从其它模块链接），以上等价可能无法判定，不要求实现提供。</p>
<p>　　因为本设计不依赖 λ 抽象的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">内部表示</a>（特别是支持<a href="#%CE%BB-%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">惰性求值</a>为目的的），不依赖 η-变换的<a href="#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>，也不要求支持更强的 βη-等价。</p>
<p>　　派生实现可按需定义较弱的<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">等价谓词</a>，保证其判定结果蕴含上述等价关系的结果。</p>
<h4 id="续延的捕获和调用"><a class="header" href="#续延的捕获和调用">续延的捕获和调用</a></h4>
<p>　　语言可提供作为<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等实体</a>的<a href="#%E7%BB%AD%E5%BB%B6">续延</a>即<em>一等续延(first-class continuation)</em> 。</p>
<p>　　续延的<em>捕获(capture)</em> <a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">具现</a><a href="#%E7%BB%AD%E5%BB%B6">当前续延</a>为对象语言中可操作的一等续延。</p>
<p>　　类似<a href="#%E8%BF%87%E7%A8%8B">过程</a>，续延可被<a href="#%E8%BF%87%E7%A8%8B">一次或多次调用</a>，称为<em>续延调用(continuation call)</em> 。</p>
<p>　　续延调用接受一个<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">实际参数</a>作为传递给后继<a href="#%E8%A7%84%E7%BA%A6%E8%A7%84%E5%88%99%E5%92%8C%E6%B1%82%E5%80%BC">规约步骤</a>使用的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>。除非另行指定，续延参数被<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值传递</a>。被调用的续延可<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>参数并执行其蕴含的其余规约步骤。</p>
<p>　　和接受实际参数对应，续延可被假定关联一个等效的<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">应用子</a>，具有一个<a href="#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">形式参数</a>，这个应用子的<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">底层合并子</a>被<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">调用</a>时<a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%9D%A1%E4%BB%B6">非正常地</a>传递它的<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>给关联的续延。</p>
<p>　　对象语言可支持符合<a href="#%E5%87%BD%E6%95%B0">函数类型要求</a>的一等续延作为函数。作为一等续延的函数可直接作为<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>构成<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>进行<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>，而实现续延调用。</p>
<p>　　除非派生实现另行指定，NPL 的一等续延不是函数。</p>
<p>　　函数应用（如<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">合并子调用</a>）可隐含（<a href="#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>的）续延调用。</p>
<p>　　续延调用的其它的具体形式由派生实现定义。</p>
<p>　　除非在捕获的续延上存在特定的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制作用</a>，合并子被调用时以当前续延<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回</a>且仅返回一次。</p>
<p>　　类似<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数应用表达式</a>，<em>续延应用(continuation application)</em> 表达式是求值时蕴含<a href="#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延调用</a>的表达式。</p>
<p><strong>原理</strong></p>
<p>　　在 Scheme 中，一等续延即过程。</p>
<p>　　在限制<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>的函数不蕴含控制作用时，类似 Scheme 等支持的无界<a href="#%E7%BB%AD%E5%BB%B6">续延</a>不是函数。一个理由不能以常规方式为无界续延指定是函数<a href="#%E7%B1%BB%E5%9E%8B">类型</a>。参见<a href="https://okmij.org/ftp/continuations/undelimited.html#introduction">这里</a>的介绍。</p>
<p>　　在 Kernel 和其它一些语言中，续延不是过程，而具有不同的<a href="#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义类型</a>。这种不同于 Scheme 的设计是有意的。</p>
<p>　　NPL 一等续延不限制是否和函数类型同一，因此无界续延仍可被视为函数（或更确切地，即程序入口作为边界的有界续延）。</p>
<p>　　类似 [R<sup>n</sup>RK] 的设计，因为一等续延的调用可引起和更常见的过程调用显著不同的控制作用，续延调用有必要和过程调用在对象语言的语法上显式区分以满足<a href="#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测性</a>，因此一等续延一般不是函数。</p>
<p>　　续延关联的等效应用子的原理同 [R<sup>n</sup>RK] §7 和 §7.2.5（应用子 <code>continuation-&gt;applicative</code>）的原理，但略有不同：</p>
<ul>
<li>作为一等对象的续延和续延的实际参数是否求值无关，因此不是合并子，<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>不需要支持续延作为函数合并被求值；但续延可通过特定的操作转换为应用子。</li>
<li>续延和操作子在被调用时都接受一个实际参数对象。
<ul>
<li>对前者，对象典型地表示计算的结果，即已被求值。</li>
<li>对后者，对象是操作数。典型地，操作子作为应用子的底层合并子，操作数已被作为应用子的实际参数被求值算法求值。</li>
<li>类似 [R<sup>n</sup>RK] 而和 [R<sup>n</sup>RS] 不同，因为<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>可接受<a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">非真列表</a>作为参数，非列表的操作数可以和非列表的续延实际参数直接对应。
<ul>
<li>因为函数合并的这种性质，续延关联的应用子的应用和续延应用存在直接的一一对应关系。</li>
</ul>
</li>
</ul>
</li>
<li>但是，为避免和<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>冲突，[R<sup>n</sup>RK] 的<em>选择器(selector)</em> 支持在此未被要求。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　类似过程，续延及其调用在其操作语义的元语言中能表示为元语言的<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数应用</a>，通常表达为<a href="#%E5%87%BD%E6%95%B0">函数</a>及<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>。</p>
<p>　　续延捕获在语法上类似函数对变量的<a href="#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">捕获</a>。被捕获的实体通常以引用保存。被捕获的实体通常是隐式的，即不在对象语言程序中出现。</p>
<p>　　在支持一等续延且捕获的续延可被复制的语言中，实现需要考虑活动记录的复制，参见 [Hi90] 。</p>
<p>　　关于控制作用，另见续延调用<a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%9D%A1%E4%BB%B6">对程序控制的改变</a>。</p>
<h4 id="活动记录"><a class="header" href="#活动记录">活动记录</a></h4>
<p>　　<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">活动的</a>合并子分配的对象称为<em>活动记录(activation record)</em> 。</p>
<p>　　<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>以活动记录引用涉及的变量。每个调用的活动记录中可保存多个变量。活动记录可能因此持有状态，即便不一定可被函数调用外的操作直接修改。</p>
<p>　　嵌套的函数调用具有多次分配的活动记录。为强调其中的对应关系，每一个调用关联其中的一个<em>帧(frame)</em> 。</p>
<p>　　在确定一次分配的一个活动记录对应一次函数调用的实现中，一个活动记录和一个活动记录的帧同义。</p>
<p>　　活动记录的集合可能构成特定的数据结构。例如限制只支持嵌套的子例程调用（而不支持一般的<a href="#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延调用</a>）时，具有后入先出(LIFO, last-in-first-out) 的栈的结构。</p>
<h3 id="λ-求值策略"><a class="header" href="#λ-求值策略">λ 求值策略</a></h3>
<p>　　在<a href="#%E5%90%8D%E7%A7%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">变量</a>绑定值后，兼容 λ 演算规约语义（特别地，β-规约）的表达式的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">具体求值</a>根据是否传递操作数对使用<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按需传递</a>的情形分为三类：</p>
<ul>
<li>（完全）<em>惰性求值(lazy evaluation)</em></li>
<li>部分惰性求值</li>
<li><em>热情求值(eager evaluation)</em></li>
</ul>
<p>　　其中，惰性求值总是使用按需传递，热情求值总是不使用按需传递，部分惰性求值不总是使用或不适用按需传递。</p>
<p>　　在保证不存在非<a href="#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>时这些求值的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">计算作用</a>没有实质差异。存在非纯求值时，使用的 λ 求值策略由派生实现定义。</p>
<p>　　<a href="#%E4%B8%A5%E6%A0%BC%E6%80%A7">非严格求值</a>严格蕴含惰性求值。两者经常但不总是一致，例如，实现可能<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">并行地</a>热情求值，并舍弃部分结果以实现非严格求值。</p>
<p>　　热情求值蕴含<a href="#%E4%B8%A5%E6%A0%BC%E6%80%A7">严格求值</a>。两者也经常但不总是一致，例如，实现可能使用应用序严格求值。但因为非严格的热情求值缺乏性能等可局部优化的实用动机，这种不一致的情况通常不作为附加的语言特性提供（而仅为简化实现默认作为全局策略使用）。</p>
<p><strong>注释</strong></p>
<p>　　由于实现可能确定特定表达式的作用对约定必须保持的<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">程序行为</a>没有影响而可能省略求值，按<a href="#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机</a>语义的严格求值在实际实现中通常是不必要的。</p>
<p>　　惰性求值可通过中间值<a href="#%E4%B8%A5%E6%A0%BC%E6%80%A7">延迟求值</a>实现。</p>
<h2 id="上下文"><a class="header" href="#上下文">上下文</a></h2>
<p>　　<em>上下文(context)</em> 是表达式关联的状态的特定集合。</p>
<p><strong>注释</strong> 这里不是<a href="../Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">自指概念</a>。</p>
<p>　　一个上下文是<em>显式的(explicit)</em> ，当且仅当它可以通过<a href="#%E5%90%8D%E7%A7%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">名称表达式</a>访问。</p>
<p>　　一个上下文是<em>隐式的(implicit)</em> ，当且仅当它不是显式的。</p>
<p>　　隐式的上下文通常是<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">管理状态</a>。</p>
<p>　　确定上下文的状态或对可变上下文的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">修改</a>是对上下文的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>。</p>
<p>　　规约规则中，以未指定子项参数化的项是一个上下文。</p>
<p>　　本节以外其它关于上下文的具体规则由派生实现定义。</p>
<p><strong>注释</strong></p>
<p>　　参数化的子项可在（<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>的）语法上被表示为一个<em>洞(hole)</em> ，详见<a href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">上下文相关求值</a>中的语法 <code>[]</code> 。</p>
<p>　　<a href="#%E8%BF%87%E7%A8%8B">过程实体</a>能影响<a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F">函数表达式</a>关联的上下文，参见<a href="#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">函数和函数应用的求值环境</a>。</p>
<h3 id="求值环境"><a class="header" href="#求值环境">求值环境</a></h3>
<p>　　<em>求值环境(evaluation environment)</em> 是在求值时可访问的隐式上下文，提供可通过<a href="#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>访问的变量的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">绑定</a>。</p>
<p>　　不和<a href="#%E7%95%A5%E7%A7%B0">实现环境</a>相混淆的情况下，求值环境简称（变量或对应的局部绑定所在的）为<em>环境(environment)</em> 。</p>
<p>　　具有<a href="#%E5%8F%AF%E8%A7%81%E5%90%8D%E7%A7%B0">可见名称</a>的绑定是<em>可见的(visible)</em> 。</p>
<p>　　环境<em>包含(contain)</em> 若干个<em>局部绑定(local binding)</em> ，即不通过其它环境即保证可见的<em>被绑定实体(bound entity)</em> 。</p>
<p>　　环境<em>展示(exhibit)</em> 可见的绑定。</p>
<p>　　一个环境是<em>空环境(empty environment)</em> ，当且仅当其中包含的局部绑定集合是空集。</p>
<p><strong>注释</strong></p>
<p>　　按绑定的定义，求值环境的局部绑定集合即变量的名称和通过声明引入的被变量表示的实体构成的映射。</p>
<p>　　可见绑定可能被通过名称解析成功访问变量。</p>
<p>　　包含和展示的定义同 [R<sup>n</sup>RK] 。除此之外，<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境对象具有直接包含的绑定的所有权</a>。</p>
<h4 id="实现环境提供的求值环境"><a class="header" href="#实现环境提供的求值环境">实现环境提供的求值环境</a></h4>
<p>　　实现环境可能在实现以外提供附加的求值环境作为任务通信的机制，如环境变量。</p>
<p>　　除非派生实现另行指定，语言支持的求值环境和这些机制蕴含的求值环境的交集为空。语言可以库的形式提供 <a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 另行支持。</p>
<h4 id="函数和函数应用的求值环境"><a class="header" href="#函数和函数应用的求值环境">函数和函数应用的求值环境</a></h4>
<p>　　在典型的对象语言中 <a href="#%CE%BB-%E6%8A%BD%E8%B1%A1">λ 抽象</a>中指定的替换构造具有<em>局部作用域(local scoping)</em> ，其中可访问 λ 抽象外部词法意义上<em>包含的(enclosing)</em> 求值环境的变量，对应求值环境为<em>局部环境(local environment)</em> 。</p>
<p>　　在基于<em>词法作用域(lexical scoping)</em> 的对象语言中，引入 λ 抽象对应的语言构造支持<a href="#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">捕获</a>引入函数时所在的作用域的环境，称为<em>静态环境(static environment)</em> 。</p>
<p>　　相对地，<em>动态作用域(dynamic scoping)</em> 根据求值时的状态指定指称。</p>
<p>　　<a href="#vau-%E6%8A%BD%E8%B1%A1">Vau 抽象</a>进一步支持在局部环境中提供访问<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数应用</a>时的求值环境，即<em>动态环境(dynamic environment)</em> 的机制。</p>
<p>　　除非另行指定，按<em>词法闭包(lexical closure)</em> 规则捕获，即只根据词法作用域确定捕获的指称；若需要支持依赖求值状态动态确定指称时，使用派生实现提供的对求值环境的操作，而不依赖动态作用域。</p>
<p>　　作为<a href="#%E8%BF%87%E7%A8%8B">过程</a>的实现，词法闭包规则捕获实体创建<em>闭包(closure)</em> 。</p>
<p>　　除非另行指定，NPL 只存在一种作用域，即所有作用域都使用相同的<a href="#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>和捕获规则。</p>
<p><strong>注释</strong></p>
<p>　　历史上，闭包首先在 <a href="https://academic.oup.com/comjnl/article-pdf/6/4/308/1067901/6-4-308.pdf">SECD 抽象机</a>中引入。术语闭包来自 λ 演算的<a href="#%E9%A1%B9%E9%87%8D%E5%86%99%E7%B3%BB%E7%BB%9F">闭项</a>。</p>
<h3 id="互操作上下文"><a class="header" href="#互操作上下文">互操作上下文</a></h3>
<p>　　用于<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>的和求值关联的隐式上下文是<em>互操作上下文(interoperation context)</em> 。</p>
<p>　　除非派生实现另行指定，语言不提供访问互操作上下文的公开接口。</p>
<p><strong>注释</strong></p>
<p>　　一个典型的实例：由 <a href="#%E8%A1%A5%E5%85%85%E9%A2%86%E5%9F%9F%E5%AE%9A%E4%B9%89">ISA</a>约定的通用架构寄存器的状态，可能需要在<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>或任务切换过程中保存和重置。</p>
<h2 id="类型"><a class="header" href="#类型">类型</a></h2>
<p>　　<em>类型(type)</em> 是上下文中和特定的实体直接关联或间接关联的元素，满足<a href="#%E9%98%B6%E6%AE%B5%E4%B8%8D%E5%8F%98%E9%87%8F%E7%BA%A6%E6%9D%9F">某个执行阶段的不变量约束</a>。</p>
<p>　　<em>类型规则(type rule)</em> 是和类型相关的对象语言的语义规则。</p>
<p>　　实体关联的类型可能被显式地指定，或通过隐式的限定规则推断确定。符合指定和限定要求的类型可有任意多个。</p>
<p>　　实体的类型是被显式指定的实体关联的类型。实体具有实体的类型以及通过其它规则限定的类型。实体是类型的<em>实例(instance)</em> 。</p>
<p>　　类型可用集合<a href="#%E8%A1%A8%E7%A4%BA">表示</a>。集合的元素是具有其表示的类型的实体。</p>
<p>　　表示类型的集合为空时，表示类型没有实例，是<em>空类型(empty type)</em> 。</p>
<p>　　推论：由集合的形式表达，空类型是唯一的。</p>
<p>　　表示类型的集合只有一个元素时，类型只有一个不可区分的实例，这样的类型是<em>单元类型(unit type)</em> 。</p>
<p>　　和表达式直接关联的类型满足起始阶段不变量约束，称为<em>静态类型(static type)</em> 。</p>
<p>　　和表达式的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>关联的类型满足<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">运行阶段</a>的不变量约束，称为<em>动态类型(dynamic type)</em> 。</p>
<p>　　其它可能存在类型或实现执行阶段的扩展由派生实现定义。</p>
<p>　　除非另行指定，对象的类型是<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">对象的值</a>的类型。</p>
<p>　　NPL 对象类型和<a href="#%E8%A1%A8%E7%A4%BA">存储的值</a>的类型之间的关联未指定。</p>
<p>　　类型在描述类型规则的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>中可作为对象。</p>
<p>　　生成对象的元语言函数是<em>类型构造器(type constructor)</em> 。类型构造器的参数是类型，的函数值是组合这些参数得到的<em>复合类型(compound type)</em> 。</p>
<h3 id="类型系统和类型机制"><a class="header" href="#类型系统和类型机制">类型系统和类型机制</a></h3>
<p>　　称为类型的具体实体和之间的关联由派生实现的<em>类型系统(type system)</em> 规则指定。</p>
<p>　　默认类型系统不附加约束，所有表达式或关联的项都<em>没有指定类型(untyped)</em> ，为退化的<em>平凡类型系统(trivial type system)</em> 或<em>单一类型系统(unityped system)</em> ，实质上是动态类型。</p>
<p>　　对类型系统的分类中，类型也指确定类型的过程称为<em>类型机制(typing discipline)</em> ，其中确定类型的过程称为<em>定型(typing)</em> 。</p>
<p>　　在静态类型之后阶段确定的类型机制是<em>动态定型(dynamic typing)</em> 。</p>
<p>　　除非另行指定，被确定的静态类型的阶段是翻译时阶段；被确定的动态类型的阶段是翻译时之后，即<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">运行时</a>。</p>
<p>　　语言可提供<a href="https://en.wikipedia.org/wiki/Typing_rule">定型规则(typing rule) (en-US)</a> ，指定<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>作为实体在特定的<a href="#%E4%B8%8A%E4%B8%8B%E6%96%87">上下文</a>（称为<em>类型环境(typing environment)</em> ）中的类型。项是类型在这个上下文中的<em>居留(inhabitant)</em> 。</p>
<p>　　类型环境确定<em>类型指派(type assignment)</em> ，即项和类型的之间的<em>定型关系(typing relation)</em> 。定型确定的这种定型关系的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">实例</a>即<em>定型判断(typing judgement)</em> 。</p>
<p>　　不违反类型系统规则下的<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">良定义的</a>程序构造是<em>良型的(well-typed)</em> 。</p>
<p>　　根据是否要求项首先都是良型的再指派语义，带有类型的形式系统可具有<a href="https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus#Intrinsic_vs._extrinsic_interpretations"><em>内在(intrinsic)</em> 和<em>外在(extrinsic)</em> 的解释</a>。</p>
<p>　　除非另行指定，NPL 使用外在的解释。</p>
<p><strong>原理</strong></p>
<p>　　默认使用外在解释的理由是：</p>
<ul>
<li>类型的外在解释允许在一个没有指定具体类型系统设计的单一类型系统为基础扩展不同的类型系统，能满足语言自身<a href="#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">可扩展</a>的需要。
<ul>
<li>扩展通用目的语言特性的顺序应是从简单到复杂的，而不是相反，因为并不存在已知的万能语言可供裁剪。</li>
<li>这也符合历史顺序：无类型 λ 演算被扩展到不同的有类型 λ 演算，而不是相反；因为有类型 λ 演算的规则明显较无类型 λ 演算多且复杂。</li>
<li>从无类型 λ 演算可以扩展到的一些特性更丰富其它系统，如 <a href="https://en.wikipedia.org/wiki/Lambda-mu_calculus">λμ 演算 (en-US)</a> 和 vau 演算，首先都是无类型的，并不存在可用的内在解释。</li>
</ul>
</li>
<li>为了描述类型规则，外在解释最终需要在整个系统中引入和对象语言不同的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>，而增加复杂性。
<ul>
<li>即便存在强调可扩展的对象语言（如 <a href="https://arxiv.org/abs/0910.2654">MLPolyR</a>），至少语言规范中定义的元语言没有被证明可以和被描述类型规则的对象语言合并。</li>
<li>即便能证明可以合并，这种方式也显著地大大增加了设计的复杂性，违反<a href="#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>。</li>
<li>根本上，这种方式损害对象语言设计的<a href="#%E7%BB%9F%E4%B8%80%E6%80%A7">光滑性</a>，很可能大大削弱对象语言的<a href="#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>。</li>
</ul>
</li>
<li>没有确切的充分依据证明引入类型系统带来的性质是通过非类型论的直接扩展演绎系统的方式不能实现或者其实现有现实困难的。
<ul>
<li>因此先验地要求类型的存在缺乏必要性。即便可实现需求，在通用目的上通常是舍近求远的过度设计。</li>
<li>即便引入类型的方式有现成的工程实践而可以提升工程效率，也可能是<a href="#%E9%81%BF%E5%85%8D%E4%B8%8D%E6%88%90%E7%86%9F%E7%9A%84%E4%BC%98%E5%8C%96">过早的优化</a>。</li>
<li>更何况现实并没有证据表明存在这样的成功实践。</li>
</ul>
</li>
<li>跳出先验地引入类型的做法，使用先验的内在解释而排除不够清晰明确的含义(meaning) 的语法的方式，在历史上存在更显著的失败。
<ul>
<li>[Chu41] §18 试图排除原始的 λ 演算（称为 λ-K-转换，在 [Bare84][Shu10] 中称为 λ<em>K</em> 演算）中无法取得<a href="#%E8%8C%83%E5%BC%8F">范式</a>的项（以使之更适用于符号逻辑的目的）：限制 λ 抽象中的约束变量是第二子项的自由变量。
<ul>
<li>非正式地，这在语法上要求每个<a href="#%E5%87%BD%E6%95%B0">函数体</a>中的每个<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">变量</a>必须是某个唯一的函数的<a href="#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">形式参数</a>，且这个函数的函数体是语法上包含这个变量的表达式，即语言在语法上禁止出现（在声明以外）未使用的形式参数。</li>
<li>限制的 λ 演算在现代（如 [Bare84][Shu10] ）称为 λ<em>I</em> 演算，不支持表达 <a href="https://zh.wikipedia.org/zh-cn/%E7%BB%84%E5%90%88%E5%AD%90%E9%80%BB%E8%BE%91">K 组合子</a>。</li>
</ul>
</li>
<li>[Bare84] §2.2 指出 λ<em>I</em> 演算具有的一些问题，如：
<ul>
<li>对应的理论 <strong>λ<em>I</em></strong> 翻译到<a href="https://zh.wikipedia.org/zh-cn/%E7%BB%84%E5%90%88%E5%AD%90%E9%80%BB%E8%BE%91">组合子逻辑</a>的理论 <strong>CL</strong> 时，项能取得<a href="#%E8%8C%83%E5%BC%8F">范式</a>的性质不被保持。</li>
<li>范式的概念过于侧重语法，所以在<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">模型</a>中不确定含义。</li>
<li>试图识别编码<a href="https://en.wikipedia.org/wiki/Partial_function">偏函数(partial function) (en-US)</a> 需要的“未定义”的项是不可能的。</li>
<li>λ<em>I</em> 演算定义的偏函数的组合对应的项不一定是 λ<em>I</em> 演算定义的被组合的偏函数的项的组合。</li>
</ul>
</li>
<li>[Bare84] §2.2 指出，这些问题都来自 [Chu41] 选择用无法取得范式的项编码“未定义”的概念。
<ul>
<li>定义可解性(solvability) ，以不可解代替不能取得范式编码“未定义”可解决这个问题。
<ul>
<li>项的可解性定义为存在有限的项序列使前者在后者顺序应用得到 <a href="https://zh.wikipedia.org/zh-cn/%E7%BB%84%E5%90%88%E5%AD%90%E9%80%BB%E8%BE%91">I 组合子</a>（即 λ<em>x</em>.<em>x</em> ）。</li>
</ul>
</li>
<li>在 λ<em>I</em> 演算中，不可解等价不能取得范式。而在 λ 演算中，不可解等价不能取得 <a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">HNF</a> 。</li>
<li>λ 演算没有 λ<em>I</em> 演算的上述问题。</li>
<li>λ<em>I</em> 表述的 Church–Turing 论题仅限于<a href="#%E7%BB%88%E6%AD%A2%E4%BF%9D%E8%AF%81">全函数</a>，而 λ 函数表述的论题能扩展到一般形式的偏函数。</li>
</ul>
</li>
<li>即便不考虑上述整体性质，尽管计算上 λ<em>I</em> 演算是 <a href="#%E5%AE%8C%E6%95%B4%E6%80%A7">Turing 完备</a>的，它不能编码<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">常量</a>函数。
<ul>
<li>因为也不包含<a href="#%E7%AE%A1%E7%90%86%E8%A7%84%E7%BA%A6">管理规约</a>规则，它实际上无法编码<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察性质的项</a>，除非平凡地指定所有项都是可观察的。</li>
</ul>
</li>
<li>以上问题一定程度上揭示了去除似乎冗余但实际在语义上可能非平凡的语法构造是<a href="#%E9%81%BF%E5%85%8D%E4%B8%8D%E6%88%90%E7%86%9F%E7%9A%84%E4%BC%98%E5%8C%96">不成熟的简化</a>，损害系统的<a href="#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>。</li>
<li>要求（可被类型检查的）类型系统直接排除不能取得范式的项，在这个意义上比 λ<em>I</em> 演算对去除特定的项的组合更彻底。
<ul>
<li>即便类型系统能引入其它语义，这以引入不能被对象语言表达的规则为代价，通常需要元语言。</li>
<li>相比之下，同样是引入对象语言表达式无法表达的语义，管理规约是对象语言规则能直接蕴含的，相对具有更小的（工作量和避免兼容问题上的）代价。</li>
</ul>
</li>
<li><strong>注释</strong> 内在解释又被称为 Church 风格的。</li>
</ul>
</li>
<li>哲学意义上，内在解释或本体论上的(ontological) 解释，相比外在解释或语义上的(semantical) 解释需要更强的假设。
<ul>
<li>本体论上的逻辑，如 <a href="https://en.wikipedia.org/wiki/Frege%E2%80%93Church_ontology">Frege-Church 本体论 (en-US)</a>，可能解决一些悖论。</li>
<li>但根本上，没有充分动机指出，不涉及<a href="#%E6%BC%94%E7%BB%8E%E8%A7%84%E5%88%99">演绎规则</a>的悖论必须在通用语言内部直接提供规则消除，而不能通过其它方式（例如，由<a href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>补充前提）解决。
<ul>
<li>指定管理规约可以编码非平凡的表达语言规则外的语义的项可以对这样的前提建模并在语言中适当编码表达。</li>
<li>编码表达这种方式是 NPL 强调 <a href="#%E8%AF%8D%E6%B3%95%E8%A7%84%E5%88%99">N(name)</a> 和其它实体分离的主要理由。</li>
</ul>
</li>
<li>本体论假设要求名称以外附加实体以使假设生效。一般地，这些假设以不同语言的陈述作为断言实现。这些陈述涉及特称对象时，在完备性上是可疑的，且容易和<a href="#%E5%BC%80%E6%94%BE%E6%80%A7">开放世界假定</a>冲突。</li>
<li>约定不涉及的语言规则的本体论假设在这些意义上也可被认为在效用上的<a href="#%E9%81%BF%E5%85%8D%E4%B8%8D%E6%88%90%E7%86%9F%E7%9A%84%E4%BC%98%E5%8C%96">不成熟的优化</a>。</li>
</ul>
</li>
</ul>
<p><strong>注释</strong></p>
<p>　　在元语言的意义上，类型系统包含语法和对应的语义，但在对象语言中，定型规则和其它推理规则（如<a href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>规则）作为语言规则是语义规则，和语法相对独立。</p>
<p>　　实体的类型可被指定为未指定类型，以明确类型的存在性，但不明确具体的类型的构造和表示。</p>
<p>　　形式地，在类型系统中，类型环境和项作为前提，通过定型规则(typing rule) 得到定型判断。定型规则在逻辑上可以是公理或定理。</p>
<p>　　在数理逻辑中，使用结构主义数学方法，集合可以作为描述类型规则的理论（句子集合）的模型，和理论支持描述的类型一一对应。</p>
<h3 id="类型等价性"><a class="header" href="#类型等价性">类型等价性</a></h3>
<p>　　通过显式指定标识（如名称）的方式定义类型的方法是<em>名义类型(nominal typing)</em> ，否则是<em>结构化类型(structrual typing)</em> 。</p>
<p>　　除非另行指定，不同的名义类型不蕴含等价关系。结构化类型之间的等价关系由实现定义。</p>
<p>　　类型的相等关系是一种类型之间的等价关系。两个类型相等，当且仅当它们的实例作为元素的两个集合对应相等。</p>
<p>　　除非另行指定，相等的类型不在语言中区分，且元语言（描述对象语言的规则）中类型作为实体的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>即类型相等性。</p>
<p>　　推论：除非另行指定，不同的类型不等价。</p>
<p>　　除非另行指定，对象语言使用类型相等性实现类型等价性。</p>
<p><strong>原理</strong></p>
<p>　　对象语言中的类型实质上是类型的一种间接的表示，作为实体仍然可以具有不同的同一性。</p>
<p>　　这避免程序可能需要枚举类型的外延（即精确实现出表示它的集合）才能确保确切表示出这个类型这样的计算上不可行的困难。</p>
<p>　　因为可支持的表示的<a href="#%E7%B1%BB%E5%9E%8B%E5%85%A8%E9%9B%86">类型全集</a>不同，类型相等是相对的，依赖类型系统的具体实现。一个类型系统可能支持无法在另一个类型系统中精确表示的类型。</p>
<p><strong>注释</strong></p>
<p>　　本节的主要例外参见<a href="#%E7%B1%BB%E5%9E%8B%E5%BA%8F">公共子类型</a>。</p>
<h3 id="类型标注"><a class="header" href="#类型标注">类型标注</a></h3>
<p>　　根据是否需要特定的文法元素指定和项关联的类型即<em>类型标注(type annotation)</em> ，对确定类型的机制可进行分类。</p>
<p>　　类型系统可使用<em>显式类型(explicit typing)</em> ，即在<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">定型</a>时要求类型标注。</p>
<p>　　不使用类型标注的方式是<em>隐式类型(implicit typing)</em> 。</p>
<p>　　在引入实体（特别地，如<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">变量</a>）时指定实体的显式类型标注称为<em>清单类型(manifest typing)</em> 。</p>
<p>　　不使用清单类型而使隐式引入的实体（如值）关联具体类型的机制称为<em>潜在类型(latent typing)</em> 。</p>
<p>　　清单类型是显式类型的实例；除此之外，显式类型还包括<em>铸型(casting)</em> ，即显式指定表达式求值的结果应具有的类型。</p>
<p>　　潜在类型是隐式类型的实例；除此之外，隐式类型还包括<em>类型推断(type interferece)</em> ，即通过隐含的上下文信息判断表达式关联的类型。</p>
<p>　　类型推断的逆过程是<em>类型擦除(type erasure)</em> 。类型擦除支持使一个<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">良型</a>的程序中的已被定型的实体表示擦除前按类型规则不允许表示的其它实体。</p>
<p>　　若类型机制可保证在某个<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">执行阶段</a>内有确定<a href="#%E8%8C%83%E5%BC%8F">强规范化性质</a>的算法确定类型，则类型机制在该阶段是<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态定型</a>。</p>
<p><strong>注释</strong> 强规范化性质的算法保证终止。</p>
<p>　　语言可能个别指定引入这些类型相关的规则，在保持逻辑相容的前提下可混合使用。</p>
<p>　　显式类型可编码接口的要求，即<em>类型签名(type signature)</em> 。</p>
<p>　　类型签名通常直接指定<a href="#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义类型</a>，但同时也可允许非特定的满足结构类型约束的类型。这些类型和类型签名<em>兼容(compatible)</em> 。</p>
<p><strong>原理</strong></p>
<p>　　历史上，表达式的类型和变量的类型在<a href="#%CE%BB-%E5%AE%8C%E5%A4%87%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AF%B9%E5%BA%94%E8%AF%AD%E6%B3%95">简单类型 λ 演算</a>中同时被引入。后者修饰 λ 抽象中的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">自由变量</a>，而前者限定剩余的所有项。</p>
<p>　　即便从<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项重写系统</a>中两者是形式上统一的，在实际语用中具有很不同的差异。这集中体现在后者是<a href="#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义的</a>，除非附加其它不同的语法设施，并不具有结构化推导的性质，原则上只适合描述接口；而前者能兼容<a href="#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">结构化类型</a>，同时适合描述接口及其实现。</p>
<p>　　作为接口的名义类型在作为自由变量以外的上下文中重新复用为不关心其类型（并消除依赖这些信息的<a href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">其它机制</a>）的其它程序构造（一般意义上的表达式），通常需要类型擦除等更复杂的机制和支持的类型系统规则，以消去不再预期和其它类型系统规则交互的类型。</p>
<p>　　和 [R<sup>n</sup>RK] 类似，NPL 不要求使用清单类型，以避免一些一般意义上的全局设计缺陷。这些缺陷包括：</p>
<ul>
<li>过于积极地（非预期地）排除危险但对程序有用的使用，而违反<a href="#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测性</a>。</li>
<li>因为移除类型标注需要上述的复杂机制和类型系统规则，具体的清单类型阻碍派生语言定义其它不容易冲突的类型标注规则而使语言具有更好的<a href="#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">可扩展性</a>。</li>
<li>因为名义类型的相关规则更容易直接拒绝一些和类型规则不兼容的程序构造而难以简单地变通，往往对程序构造的组合具有更多直接的<a href="#%E5%AE%8C%E6%95%B4%E6%80%A7">可表达性</a>限制而破坏通用计算意义上的<a href="#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>。
<ul>
<li><strong>注释</strong> 例如，许多类型系统不允许表达 <a href="https://zh.wikipedia.org/zh-cn/%E4%B8%8D%E5%8A%A8%E7%82%B9%E7%BB%84%E5%90%88%E5%AD%90#Y%E7%BB%84%E5%90%88%E5%AD%90">Y 组合子</a>的构造<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">良型</a>。</li>
</ul>
</li>
</ul>
<p>　　若有必要，派生语言仍可限定使用清单类型。一般仍然建议仅在局部引入而避免全局复杂性和因此带来的限制。</p>
<p><strong>注释</strong></p>
<p>　　类型签名来自数理逻辑术语。</p>
<h3 id="类型检查"><a class="header" href="#类型检查">类型检查</a></h3>
<p>　　<em>类型检查(typechecking)</em> 解答程序是否满足类型规则的判定性问题。</p>
<p>　　使用<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">翻译时</a>的<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">语义分析</a>或<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">运行时</a>的类型检查分别为静态类型检查和动态类型检查。</p>
<p>　　静态类型检查规则是<a href="#%E7%BF%BB%E8%AF%91%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%A7%84%E5%88%99">可诊断语义规则</a>。</p>
<p>　　语言可能个别指定引入类型检查相关的规则，在保持逻辑相容的前提下可混合使用。</p>
<p>　　类型检查失败引起的<a href="#%E9%94%99%E8%AF%AF">错误</a>称为<em>类型错误(type error)</em> 。</p>
<p><strong>注释</strong></p>
<p>　　注意静态类型检查和<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态定型</a>以及动态类型检查和<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">动态定型</a>的区别。类型检查和类型机制是不同的规则，不必然包含蕴含关系。</p>
<p>　　类型检查的一个典型的使用场景是<a href="#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">类型签名的兼容性</a>校验。</p>
<h3 id="类型全集"><a class="header" href="#类型全集">类型全集</a></h3>
<p>　　<em>类型全集(type universe)</em> 是语言规则中允许表达的类型的总称。</p>
<p><strong>注释</strong> 表达类型的规则构成的模型的语言是语言规则的子集。</p>
<p>　　NPL 避免限定类型全集。派生语言可指定不同的规则。</p>
<p>　　除非派生实现另行指定，程序的用户不能依赖语言规则的限定枚举类型全集中的所有类型。</p>
<p><strong>原理</strong></p>
<p>　　类型全集是<a href="#%E5%BC%80%E6%94%BE%E6%80%A7">论域</a>的实例。避免限定类型全集符合<a href="#%E5%BC%80%E6%94%BE%E6%80%A7">开放世界假定</a>。</p>
<h4 id="类型谓词"><a class="header" href="#类型谓词">类型谓词</a></h4>
<p>　　判断值是否满足类型<em>居留(inhabitant)</em> 的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">谓词</a>是<em>类型谓词(type predicate)</em> 。</p>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RK] 的基本类型谓词不同，类型谓词定义为只接受一个参数。</p>
<h3 id="类型序"><a class="header" href="#类型序">类型序</a></h3>
<p>　　类型之间可具有序关系。</p>
<p>　　被<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">定型</a>的类型的实体可完全地满足其它类型的约束。前者具有后者的<em>子类型(subtype)</em> 。</p>
<p>　　<em>子类型(subtyping)</em> 关系是一种<a href="https://zh.wikipedia.org/zh-cn/%E9%A2%84%E5%BA%8F%E5%85%B3%E7%B3%BB">预序(preorder) 关系</a>，即自反的、反对称的二元关系。</p>
<p>　　相等的类型符合子类型关系，是<em>平凡的(trivial)</em> 。排除平凡的子类型关系是严格子类型关系。</p>
<p>　　严格子类型是严格预序关系，即反自反、反对称的二元关系。</p>
<p>　　子类型和严格子类型对应的逆关系是<em>超类型(super typing)</em> 和<em>严格超类型(strict supertyping)</em> 关系。</p>
<p>　　多个类型可具有公共的（严格）超类型。这些类型同为一个类型的子类型而<a href="#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">等价</a>。</p>
<p>　　除非另行指定，在程序的行为不依赖其中特定的个别不相等的类型而具有差异时，具有相等超类型的等价的子类型视为相同的类型。</p>
<p>　　<a href="#%E7%B1%BB%E5%9E%8B">复合类型</a>中其中一部分的类型替换为其子类型，得到的结果和原复合类型可能有如下<a href="https://zh.wikipedia.org/zh-cn/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98#%E5%BD%A2%E5%BC%8F%E5%AE%9A%E4%B9%89">变化(variance)</a> 的对应关系之一：</p>
<ul>
<li><em>协变(covariant)</em> ：类型序被保持，即结果类型是原复合类型的子类型。</li>
<li><em>逆变(contravariant)</em> ：类型序的逆被保持，即结果类型是原复合类型的超类型。</li>
<li><em>不变(invariant)</em> ：不保持类型序，即结果类型和原复合类型之间没有确定的子类型关系。</li>
</ul>
<p>　　同时存在以下派生归类：</p>
<ul>
<li><em>互变(bivariant)</em> ：同时协变和逆变。</li>
<li><em>可变(variant)</em> ：至少协变或逆变之一。</li>
</ul>
<p>　　对接受参数类型得到结果类型的函数<a href="#%E7%B1%BB%E5%9E%8B">类型构造器</a> → ，以下关系是确定的：</p>
<ul>
<li>参数类型对函数类型逆变。</li>
<li>结果类型对函数类型协变。</li>
</ul>
<p>　　把<a href="#%E5%B0%81%E8%A3%85">LSP</a>要求子类型经替换前后保持性质的谓词视为类型构造器，则 LSP 要求的性质是协变的。</p>
<p><strong>注释</strong></p>
<p>　　关于 → 的变化关系的陈述通常直接被作为类型系统中的<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">定型规则</a>表达的公理，以和 → 既有的定型规则兼容。</p>
<p>　　一些非普遍的局部类型序的构造器，如数组的下标 <code>[]</code> ，也可对参数有确定的可变关系。</p>
<p>　　在 LSP 的<a href="https://www.cs.cmu.edu/~wing/publications/LiskovWing94.pdf">原始论文</a>提供了两个满足 LSP（文中称为子类型要求(subtype requirement) ）的在<a href="#%E8%BF%87%E7%A8%8B">过程</a>的<a href="#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">签名</a>定义子类型的方法，兼容以上传统的函数类型构造器的子类型变化关系，是 → 上的上述关系的扩展：这些定义还支持表达过程的具体前置条件(precondition) 和其中引发的<a href="#%E5%BC%82%E5%B8%B8">异常</a>。</p>
<p>　　对一般的谓词，LSP 的行为多态(behavioral polymorphism) 是不可判定的。因此，一般的 LSP 无法被<a href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>。在<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">类型系统</a>中应用 LSP 需依赖具体能表达性质的谓词，如使用的类型构造器。</p>
<h4 id="类型边界元素"><a class="header" href="#类型边界元素">类型边界元素</a></h4>
<p>　　一个类型系统可指定唯一的<a href="https://en.wikipedia.org/wiki/Bottom_type"><em>底类型(bottom type)</em> (en-US)</a> 作为其它任何不同类型的严格子类型，记作⊥。若类型全集包含空类型，则底类型是<a href="https://en.wikipedia.org/wiki/Empty_type"><em>空类型(empty type)</em> (en-US)</a> 。</p>
<p>　　一个类型系统可指定唯一的<a href="https://en.wikipedia.org/wiki/Top_type"><em>顶类型(top type)</em> (en-US)</a> 作为其它任何不同类型的严格超类型，记作⊤。这种类型即<em>通用类型(universal type)</em> 。</p>
<p>　　NPL 支持空类型作为底类型，但不要求在对象语言中支持其表示。</p>
<p>　　NPL 避免要求唯一的顶类型的存在以符合<a href="#%E5%BC%80%E6%94%BE%E6%80%A7">开放世界假设</a>。</p>
<p>　　派生语言可指定不同的规则。</p>
<p><strong>原理</strong></p>
<p>　　以空类型作为子类型在类型序的推理上是自然的。</p>
<p>　　就非特定的类型全集，通用类型的的构造和表示不唯一，因此不能直接断言其存在。</p>
<p>　　否则，假定存在这种类型，则断言不存在其超类型，这可能和其它语义规则冲突。</p>
<p>　　即使在名义上定义具体的超类型（如 Java 的 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html"><code>java.lang.Object</code></a>），也面临不能向上扩展（得到比 <code>Object</code> 更基本的类型）的问题，违反<a href="#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>和<a href="#%E5%85%B6%E5%AE%83%E6%8E%A8%E8%AE%BA%E5%92%8C%E6%AF%94%E8%BE%83">通用性</a>。</p>
<p>　　具体的顶类型在断言当前类型系统不存在公共超类型可能仍然有实用意义；此时，顶类型即<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等实体</a>构成的类型，而不需要定义具体<a href="#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义类型</a>。</p>
<h3 id="多态类型"><a class="header" href="#多态类型">多态类型</a></h3>
<p>　　特定的类型系统支持<a href="#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">类型签名</a>能对应多种不同的<a href="#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">兼容</a>类型。这样的类型是<em>多态的(polymorphic)</em> 。</p>
<p>　　一般地，类型上的<em>多态(polymorphism)</em> 有：</p>
<ul>
<li><em>特设(ad-hoc)</em> 多态：仅对项上局部的项上的类型作用使之满足上下文兼容要求的多态：
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数</a><em>重载(overload)</em> ：同一个<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">名称</a>对应的不同的函数实体，允许按<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">实际参数</a>的类型选择调用不同的函数。</li>
<li><em>强制(coercion)</em> ：求值时使值向某个上下文要求的类型的隐式转换。</li>
</ul>
</li>
<li><em>参数(parameteric)</em> 多态：接口签名指定以具体类型作为值的变量，组合为函数或者其它接口对应实体的类型。</li>
<li><a href="#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>多态：接口签名编码接受子类型关系作为兼容类型。</li>
<li><em>行(row)</em> 多态：对组成具有名称和实体对构成的元素作为<em>成员(member)</em> 的实体，兼容限定部分成员的类型。</li>
</ul>
<p>　　<em>多型(polytipic)</em> 的接口在同一个接口签名上以结构化类型的<a href="#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">隐式类型</a>构造支持不同的类型而支持多态。</p>
<p><strong>注释</strong></p>
<p>　　重载在一些语言中自动地对函数对应的具体<a href="#%E8%BF%87%E7%A8%8B">可调用实体</a>适用。</p>
<p>　　行多态以<a href="#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">结构化类型</a>约束取代通常通过<a href="#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义类型</a>指定的子类型关系。</p>
<h3 id="类型种类"><a class="header" href="#类型种类">类型种类</a></h3>
<p>　　<em>种类(kind)</em> 是<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态类型系统</a>的语法表示中具有特定类型模式(pattern) 的分类。</p>
<p>　　一定意义上，种类是类型系统的元语言中一种元静态类型。</p>
<p>　　一般地，实体类型的种类记作 <code>*</code> 。</p>
<p>　　除非另行指定，作为项的函数应具有函数类型，即符合类型种类为 <code>* → *</code> 的结果的类型，如为<a href="#%CE%BB-%E5%AE%8C%E5%A4%87%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AF%B9%E5%BA%94%E8%AF%AD%E6%B3%95">简单类型 λ 演算</a>兼容的函数类型实例。</p>
<p>　　其中，<code>→</code> 是函数类型的类型构造器。</p>
<p>　　种类作为元语言中的<a href="#%E5%A4%9A%E6%80%81%E7%B1%BB%E5%9E%8B">类型多态</a>，实现<em>种类多态(kind polymorphism)</em> ：接口签名接受类型的编码中对应位置具有不同种类的类型。</p>
<p><strong>注释</strong></p>
<p>　　在实现中，种类也被作为<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">互操作</a>的归类，如视为<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>的<a href="https://www.microsoft.com/en-us/research/uploads/prod/2020/03/kacc.pdf">调用约定</a>。</p>
<p>　　但这不足以涵盖一般的形式定义；特别地，<a href="#%E8%BF%87%E7%A8%8B">调用</a>是仅仅关于<a href="#%E8%BF%87%E7%A8%8B">过程</a>这类实体的互操作，而种类适合一般实体的静态类型。例如，在不考虑进一步地实现时，<a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/levity-pldi17.pdf">多变(levity) 多态</a>的类型不需要限定过程（函数）。</p>
<p>　　类型系统中的种类也可扩展到特定的计算作用的<em>作用系统(effect system)</em> 上以描述<a href="#%E4%BD%9C%E7%94%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99">作用的种类</a>，此处从略。</p>
<h3 id="一等类型"><a class="header" href="#一等类型">一等类型</a></h3>
<p>　　<a href="#%E5%AE%9E%E4%BD%93%E8%AF%AD%E4%B9%89">一等对象</a>的类型是<em>一等类型(first-class type)</em> 。</p>
<p>　　非一等类型的<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">居留</a>可能不在对象语言中可表达，即对象语言中无法构造这些类型的值。</p>
<p>　　非一等类型仅用于构造其它类型（可能是一等类型）和类型检查等依赖类型的推理。</p>
<p><strong>注释</strong></p>
<p>　　一个典型的非一等类型的例子是 [ISO C] 和 [ISO C++] 等语言支持的类型 <code>void</code> 。</p>
<p>　　在语义的角度上，<code>void</code> 可视为依赖<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">翻译阶段</a>把<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>时得到的对应 <code>void</code> 居留的表示替换为表示语义错误的单元类型，并在翻译结束前拒绝接受带有这种居留的程序，而这种居留在对象语言中始终不可取得。</p>
<p>　　若不限制翻译阶段，可通过在<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">传递</a>时始终限制<a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%9D%A1%E4%BB%B6">正常控制</a>的值实现类似的效果，例如不考虑类型消除时 [ISO C++] 中在复制或转移构造函数始终抛出异常的类类型。</p>
<h2 id="程序的控制执行条件"><a class="header" href="#程序的控制执行条件">程序的控制执行条件</a></h2>
<p>　　程序的执行可被<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制作用</a>影响。蕴含这些影响的条件即<em>执行条件(execution condition)</em> 。</p>
<p>　　程序的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制状态</a>决定<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>使用的<a href="#%E7%BB%AD%E5%BB%B6">续延</a>。</p>
<p><strong>注释</strong> 这和<a href="#%E8%BF%87%E7%A8%8B">过程的调用</a>类似。</p>
<p>　　更一般地，规约规则指定语言的实现决定程序行为时使用的（对程序不保证可见的）续延，这种在实现中对应的控制状态称为控制执行条件。</p>
<p>　　和控制状态不同，控制执行条件描述语言提供的不同控制机制的分类，而不被作为语言可编程的特性提供。</p>
<p>　　除非另行指定，仅由<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>中蕴含的规约规则决定的执行条件是<em>正常(normal)</em> 的。</p>
<p>　　<a href="#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">合并子调用以当前续延返回</a>是正常执行的。</p>
<p><strong>注释</strong> 这是正常控制执行条件的一个主要实例。</p>
<p>　　改变程序的正常的控制要求存在控制作用，此时，控制执行条件是<em>非正常(abnormal)</em> 的。</p>
<p>　　除非另行指定，隐含在求值算法中蕴含的规约规则确定的<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数应用</a>外的<a href="#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延调用</a>是非正常的。</p>
<p><strong>注释</strong> 这是非正常控制执行条件的一个主要实例。</p>
<p>　　具有规约语义的语言总是支持正常控制条件。NPL 中，非正常的控制条件的支持是可选的。</p>
<h3 id="异常"><a class="header" href="#异常">异常</a></h3>
<p>　　由派生实现定义的非正常的控制条件是<em>异常(exceptional)</em> 条件。</p>
<p>　　<em>异常(excpetion)</em> 是通过<em>抛出(throw)</em> 实体（称为异常实体）同时表达满足异常条件的控制作用的语言构造。</p>
<p>　　语言的实现或用户通过特定操作（如求值一个表达式）指定程序满足异常条件，使程序的控制进入<a href="#%E6%AD%A3%E7%A1%AE%E6%80%A7">异常执行状态</a>，允许程序具有正常条件下可分辨不同行为。</p>
<p>　　程序通过<em>捕获(catch)</em> 并<em>处理(handle)</em> 被抛出的实体，程序可满足不同的恢复正常执行的条件。</p>
<p>　　进入违反<a href="#%E7%BF%BB%E8%AF%91%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%A7%84%E5%88%99">翻译时正确性规则</a>的异常执行状态时，由语言实现提供的异常执行机制实现行为。</p>
<p><strong>注释</strong> 这些行为至少蕴含满足翻译时正确性规则要求的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">诊断</a>。</p>
<p>　　进入其它异常执行状态的异常条件包括所有<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">运行时</a>异常条件和直接引起程序异常的用户操作。</p>
<p>　　这些异常条件的具体行为和正常条件下的不同由派生实现指定的运行时状态或直接引起异常（改变程序的控制）或语言构造的语义决定。此时，由实现定义使用的异常执行机制。</p>
<p><strong>注释</strong> 其它异常条件的异常执行机制可能和上述相同或不同。</p>
<p>　　派生语言实现可指定以下规则：</p>
<ul>
<li>符合以上约定的判断改变（进入和退出）异常执行状态的执行机制。</li>
<li>包括抛出和捕获的语言构造和其它可选的引起改变异常条件的上下文。</li>
</ul>
<p>　　若派生实现不指定以上要求的执行机制和上下文，则不支持异常。</p>
<p>　　除非派生实现另行指定，异常的控制作用总是<em>被同步(synchronized)</em> 的，即：</p>
<ul>
<li>在初始化异常实体时，保证存在与异常条件关联且可确定单一的<a href="#%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0">执行线程</a>的状态作为引起控制状态改变即引发异常的来源。</li>
<li>异常条件的满足不依赖未和引发异常状态同步的程序中的其它的执行状态（包括其它未同步的线程的状态）。</li>
<li>确认满足异常条件和进入异常执行状态之间，上述执行线程内程序仅在引发异常的线程上的程序允许存在<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">计算作用</a>（这保证不被引起可观察行为改变的其它线程的操作中断）。</li>
</ul>
<p>　　除非派生实现另行指定，未捕获的异常总是确定性地(deterministically) 持续引发异常的执行线程中引起控制的转移：</p>
<ul>
<li>若捕获操作有效的上下文，控制转移捕获构造处理对应异常的<em>异常处理器(exception handler)</em> 。</li>
<li>否则，若在活动函数调用中，则单向地从<a href="#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">当前活动的函数</a>向其<a href="#%E8%BF%87%E7%A8%8B">主调函数</a>转移控制，使后者活动。</li>
<li>否则，若没有找到剩余的活动函数调用，则程序异常终止。</li>
</ul>
<p>　　除非派生实现另行指定，上述转移活动函数若成功（包括异常在活动的主调函数嵌套的特定语言构造中被捕获），先前不再活动的活动记录中的资源在控制成功转移后应立即被释放。</p>
<p>　　典型的设计中，求值规则使的正常状态的函数调用要求的活动记录分配和释放满足 FIFO（Last-In First-Out ，后入先出）的顺序，构成了<em>栈(stack)</em> ，活动记录是<em>栈帧(stack frame)</em> 。</p>
<p>　　除非派生实现另行指定，活动函数的转移释放资源，应保证按和创建被其所有的实体的顺序的相反顺序一致的形式释放。这种释放活动记录占用资源的机制称为<em>栈展开(stack unwinding)</em> 。</p>
<h3 id="终止保证"><a class="header" href="#终止保证">终止保证</a></h3>
<p>　　特定的求值具有（确定性地）<em>终止(termination)</em> 保证，当且仅当预期求值总是在有限计算步骤内可描述的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">计算作用</a>。</p>
<p>　　具有终止保证的求值总是取得值或通过非正常控制的计算作用退出求值。</p>
<p>　　不具有终止保证的求值可能不终止，此时它具有取得值以外的计算作用；这种计算作用是<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>。</p>
<p>　　若一个函数的调用总是具有终止保证，则此函数是<em>终止函数(terminating function)</em> 。</p>
<p>　　若一个函数的调用总是取得值，则此函数是<em>全函数(total function)</em> 。</p>
<p><strong>注释</strong> 全函数总是终止函数。</p>
<h1 id="npla"><a class="header" href="#npla">NPLA</a></h1>
<p>　　当前维护的主要派生语言为 <strong>NPLA</strong> ，是 NPL 的<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">抽象语言实现</a>和<a href="#%E7%95%A5%E7%A7%B0">派生实现</a>。</p>
<p>　　NPLA 的参照实现 <a href="#npla1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80">NPLA1</a> 是具体语言实现，约定特定于当前参照实现的附加规则和实现。</p>
<p>　　作为原型设计，NPLA 重视可扩展性。</p>
<p>　　作为 NPL 的派生实现，NPLA <a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>的设计遵循 NPL <a href="#%E8%A7%84%E8%8C%83%E6%A8%A1%E5%9E%8B">符合性规则</a>，并满足如下要求或附加限制。</p>
<p><strong>注释</strong></p>
<p>　　<a href="#npla1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80">NPLA1</a> 是 NPLA 的一个派生实现。</p>
<h2 id="npla-领域语义支持"><a class="header" href="#npla-领域语义支持">NPLA 领域语义支持</a></h2>
<ul>
<li>位(bit) ：表示二进制存储的最小单位，具有 0 和 1 两种状态。</li>
<li>字节(byte) ：<a href="#%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2">基本字符集</a>中一个字符需要的最少的存储空间，是若干位的有序集合。</li>
<li>八元组(octet) ：8 个位的有序集合。</li>
</ul>
<h2 id="npla-整体约定"><a class="header" href="#npla-整体约定">NPLA 整体约定</a></h2>
<h3 id="npla-实现环境"><a class="header" href="#npla-实现环境">NPLA 实现环境</a></h3>
<p>　　NPLA 使用<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>为 [ISO C++11]（及其之后的向前兼容的版本）的简单实现模型 <a href="#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">NPL-EMA</a> 。</p>
<p>　　以下要求和<a href="#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>一致：</p>
<ul>
<li>一<a href="#npla-%E9%A2%86%E5%9F%9F%E8%AF%AD%E4%B9%89%E6%94%AF%E6%8C%81">字节</a>占用的位（至少占用 8 个二进制位）。</li>
<li>作为事件顺序的<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">在先发生和在后发生</a>和宿主语言中的定义一致。
<ul>
<li><strong>注释</strong> 为<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>，一般应避免和之后的（受实现支持的）[ISO C++] 版本冲突。</li>
</ul>
</li>
</ul>
<p>　　NPLA 实体的<a href="#%E8%A1%A8%E7%A4%BA">内部表示</a>是宿主语言中可表达的数据结构。</p>
<p>　　NPLA 实体的<a href="#%E8%A1%A8%E7%A4%BA">外部表示</a>是宿主语言中可通过输入/输出操作处理的数据。</p>
<p>　　除非另行指定，NPLA 使用宿主语言提供的异常作为<a href="#%E5%BC%82%E5%B8%B8">异常执行机制</a>。</p>
<p>　　除非另行指定，程序不使用使宿主语言<em>区域指定的行为(locale-specific behavior)</em> 改变的特性。</p>
<p><strong>原理</strong></p>
<p>　　默认避免改变区域指定行为简化设计约定。</p>
<p><strong>注释</strong></p>
<p>　　关于类似的对宿主语言程序的要求，另见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/LanguageConvention.txt"><code>doc/LanguageConvention.txt</code></a> 。</p>
<h3 id="附加功能"><a class="header" href="#附加功能">附加功能</a></h3>
<p>　　NPLA 支持<em>数值(numerical value)</em> ，但不要求支持具体的数值计算。</p>
<p>　　NPLA 实现为派生实现提供<a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">数值类型</a>和相关的操作的基本支持。</p>
<p>　　除非另行指定，若派生实现支持数值计算，其实现兼容 <a href="#npla-%E6%95%B0%E5%AD%A6%E5%8A%9F%E8%83%BD">NPLA 数学功能</a>的实现。</p>
<h3 id="npla-词法和语法"><a class="header" href="#npla-词法和语法">NPLA 词法和语法</a></h3>
<p>　　词法分析可接受多字节文本编码的字符串形式的源代码，但不假设其编码中除 0（空字符 NUL ）以外的具体代码点被编码的数值，不<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">转换编码</a>。</p>
<p>　　使用可选的语法预处理和 <a href="#%E7%AE%80%E5%8D%95%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">NPL-GA 语法</a>。</p>
<p>　　<a href="#%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2">字符集</a>的约定同<a href="#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>。</p>
<h3 id="npla-标识符"><a class="header" href="#npla-标识符">NPLA 标识符</a></h3>
<p>　　<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">NPL 标识符</a>外的以下<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">词素</a>也是 NPLA 标识符：</p>
<ul>
<li>在构成 NPL 标识符的词素中插入有限个非 <a href="#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">NPL 分隔符</a>的字符且不构成 <a href="#npla-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F">NPLA 扩展字面量</a>的词素。</li>
<li>全由 <code>+</code> 或 <code>-</code> 构成的词素。</li>
</ul>
<h3 id="npla-扩展字面量"><a class="header" href="#npla-扩展字面量">NPLA 扩展字面量</a></h3>
<p>　　NPLA <a href="#%E5%AD%97%E9%9D%A2%E9%87%8F">扩展字面量</a>包括：</p>
<ul>
<li>以 <code>#</code> 、<code>+</code> 或 <code>-</code> 起始的但不全是 <code>+</code> 或 <code>-</code> 构成的、长度大于 1 的词素。</li>
<li>十进制数字字符起始的词素（当被支持时）。</li>
</ul>
<p>　　全由十进制数字字符的词素表示十进制<a href="#%E9%99%84%E5%8A%A0%E5%8A%9F%E8%83%BD">数值</a>。派生实现可定义其它作为数值的词素。这些词素作为字面量时，是<em>数值字面量(numerical literal)</em> 。</p>
<h3 id="npla-名称和字面量求值"><a class="header" href="#npla-名称和字面量求值">NPLA 名称和字面量求值</a></h3>
<p>　　名称仅被实现为和<a href="#%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a>的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>的一个真子集一一对应的表示（参见<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">类型映射</a>）。</p>
<p>　　除非派生实现另行指定，只有<a href="#%E5%AD%97%E9%9D%A2%E9%87%8F">代码字面量</a>不是<a href="#%E8%8C%83%E5%BC%8F">自求值表达式</a>，其余字面量都求值为<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">右值</a>。</p>
<p>　　代码字面量求值时解释为名称。</p>
<p>　　数据字面量是自求值的字符串的<a href="#%E8%A1%A8%E7%A4%BA">外部表示</a>。</p>
<p>　　数值字面量是自求值的数值的外部表示。</p>
<p>　　存在不保证先求值的<a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F">子表达式</a>的<a href="#%E8%AF%AD%E6%B3%95%E5%BD%A2%E5%BC%8F">语法形式</a>是<em>特殊形式(special form)</em> 。</p>
<p>　　特定的名称是<em>保留名称(reserved name)</em> 。</p>
<p>　　除非另行指定，在<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源代码</a>中使用保留名称作为实体的名称的程序<a href="#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">行为未定义</a>。</p>
<h3 id="npla-求值的表示"><a class="header" href="#npla-求值的表示">NPLA 求值的表示</a></h3>
<p>　　<a href="#%E8%8C%83%E5%BC%8F">规范形式</a>是特定<a href="#%E7%B1%BB%E5%9E%8B">类型</a>的 [ISO C++] 对象。</p>
<p>　　<a href="#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>失败可被忽略而不<a href="#%E8%8C%83%E5%BC%8F">终止</a>实现演绎；保证名称表达式求值的<a href="#%E8%8C%83%E5%BC%8F">强规范化</a>。</p>
<p>　　不要求提供<a href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">命名空间</a>实现的可变实体。</p>
<p>　　不保证求值都是<a href="#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>；非<a href="#npla-%E5%90%8D%E7%A7%B0%E5%92%8C%E5%AD%97%E9%9D%A2%E9%87%8F%E6%B1%82%E5%80%BC">特殊形式</a>使用<a href="#%CE%BB-%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">热情求值</a>；其它情形使用热情求值或<a href="#%CE%BB-%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">惰性求值</a>的方式由具体特殊形式约定。</p>
<p>　　对象语言的<a href="#%E5%87%BD%E6%95%B0">函数</a>默认为<a href="#%E8%BF%87%E7%A8%8B">过程</a>，过程默认实现为<a href="#%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E7%9A%84%E8%AE%A1%E7%AE%97%E9%A1%BA%E5%BA%8F">子例程</a>。过程指定的计算结果和函数表达式<a href="#%E8%8C%83%E5%BC%8F">最终求值结果</a>的<a href="#%E8%BF%87%E7%A8%8B">关联</a>是<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">过程调用</a>的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">结果</a>的恒等映射。</p>
<p><strong>注释</strong> 即过程调用的结果总是同函数值。</p>
<p>　　除非另行指定，实现<a href="#%E5%87%BD%E6%95%B0">函数</a>的宿主数据结构<a href="#npla-%E5%9F%BA%E7%A1%80%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">生存期要求</a>默认同<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>。</p>
<p>　　除非另行指定，<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值传递</a>支持<a href="#%E5%A4%8D%E5%88%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96">复制初始化</a>对象的<a href="#%E4%B8%80%E7%AD%89%E4%BD%9C%E7%94%A8">一等作用</a>。</p>
<p><strong>原理</strong></p>
<p>　　NPLA 函数不支持类似 [ISO C++] 的类型退化(decay) 。作为动态类型语言，需要被转换的值在<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作</a>内部实现，不需要在<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>上另行附加转换。</p>
<p>　　按值传递的复制初始化和宿主语言的对应语义类似。</p>
<h3 id="npla-类型系统"><a class="header" href="#npla-类型系统">NPLA 类型系统</a></h3>
<p>　　NPLA 使用<a href="#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">隐式类型</a>而非<a href="#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">显式类型</a>。</p>
<p>　　NPLA 使用<a href="#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">潜在类型</a>：<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>具有类型；不指定<a href="#%E7%B1%BB%E5%9E%8B">动态类型</a>以外的<a href="#%E7%B1%BB%E5%9E%8B">类型</a>。</p>
<p>　　<a href="#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">显式类型（如清单类型）</a>的机制可由派生实现指定可选地引入。<a href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>也可能添加类型标注和不同的<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">类型机制</a>的支持。</p>
<p>　　除非派生实现另行指定，引入的<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态类型</a>应和<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">动态类型</a>一一对应。</p>
<p>　　NPLA 使用和<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>相容的<a href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">动态类型检查</a>。除非派生实现另行指定或<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">类型映射</a>的需要，使用的类型检查规则和宿主语言一致。</p>
<p>　　宿主语言对象的值描述状态，且宿主语言要求的对 <code>volatile</code> 左值的操作属于<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>。</p>
<h2 id="npla-互操作支持"><a class="header" href="#npla-互操作支持">NPLA 互操作支持</a></h2>
<p>　　NPLA 的<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>应能提供 NPLA 及派生实现的<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">本机实现</a>。</p>
<p>　　NPLA 的派生实现提供特定的和宿主语言的<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>支持，可其中和 NPLA 提供的关于互操作的具体行为不同的部分应由实现定义。</p>
<p><strong>注释</strong> 对派生实现，NPLA 约定的具体默认互操作特性是可选的。但是，一般的约定如<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">开放类型系统</a>仍被要求。</p>
<p>　　NPLA 和派生实现可约定互操作的具体实现的要求，以确保实现的状态可预测。</p>
<p>　　本机实现可以具有 C++ 的实现兼容的二进制接口的函数提供，这些函数称为<em>本机函数(native function)</em> 。</p>
<p>　　本机实现可直接支持本机函数在实现中被调用。若被支持，具体接口由派生实现指定。</p>
<p>　　本机函数作为函数的实现，其调用的求值可具有和非本机的函数一致的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">作用</a>，但不需要具有可被对象语言表达的<a href="#%E5%87%BD%E6%95%B0">函数体</a>。</p>
<p>　　为确保函数求值的作用可能保持一致，本机函数应符合和本机函数调用时使用的规约一致的方式使用，即在宿主语言的意义上至少符合以下规约<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">调用约定</a>：</p>
<ul>
<li>被调用时的子项被作为以 <a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">WHNF</a> 形式表示的被调用的表达式使用。</li>
<li>调用后具有项被重写为必要的值以表示<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>的<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>。</li>
</ul>
<p>　　本机函数的返回值应能表达任意的非本机函数调用的返回值，即通过求值函数调用中函数体的非本机函数的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>。</p>
<p><strong>原理</strong></p>
<p>　　<a href="#npla-%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83">实体的内部表示和外部表示满足实现环境的要求</a>允许在宿主语言程序中直接实现关于<a href="#%E8%A1%A8%E7%A4%BA">表示</a>的操作，简化了互操作机制的设计和实现。</p>
<p><strong>注释</strong></p>
<p>　　宿主语言自身的调用约定（通常和实现的 <a href="#%E8%A1%A5%E5%85%85%E9%A2%86%E5%9F%9F%E5%AE%9A%E4%B9%89">ISA</a> 相关）作为 C++ 实现自身的 <a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">ABI</a> ，在此是中立的，没有提供特设的支持的要求。</p>
<p>　　另见 <a href="#npla-%E5%9F%BA%E7%A1%80%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">NPLA 基础存储和对象模型</a>。</p>
<h3 id="类型映射"><a class="header" href="#类型映射">类型映射</a></h3>
<p>　　<em>类型映射(type mapping)</em> 指定对象语言和宿主语言之间的<a href="#%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%9E%8B">实体类型</a>之间的关系，是前者中的<a href="#%E7%B1%BB%E5%9E%8B">类型</a>到后者中的类型的映射。</p>
<p>　　作为类型映射目标的宿主语言类型或其<a href="#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>称为<em>宿主类型(hosted type)</em> 。</p>
<p>　　作为宿主语言类型的宿主类型是典型的。其它宿主类型是非典型的。</p>
<p>　　具有特定<a href="#%E7%B1%BB%E5%9E%8B">动态类型</a>的对象语言的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>在宿主语言具有宿主类型，以宿主语言的值表示，称为<em>宿主值(hosted value)</em> 。</p>
<p>　　在<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>的意义上，宿主值在作为对象语言的值的<a href="#%E8%A1%A8%E7%A4%BA">表示</a>的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>中以<em>宿主对象(hosted object)</em> 的形式被保存并可在宿主语言中访问。</p>
<p>　　对象语言的值被对象语言的实体类型表示蕴含它被映射的宿主类型表示，反之亦然。</p>
<p>　　类型映射可以是非空的多对一、一对多或一一映射。</p>
<p>　　若类型映射是一一映射，其类型等价性同宿主语言的语义规则；否则，由类型的语义规则约定。</p>
<p>　　因需提供与作为宿主语言的 [ISO C++] 的互操作支持，所以明确约定实现中部分实体类型对应的 C++ 类型：</p>
<ul>
<li>用于条件判断的单一值的宿主类型是 <code>bool</code> 。</li>
<li><a href="#%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a>的宿主类型都是 <code>string</code> 类型。</li>
<li>和字符串的子集一一对应的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">词素</a>的宿主类型是能映射到 <code>string</code> 的另一种类型。</li>
</ul>
<p><strong>注释</strong> <code>string</code> 是占位符，不要求是和 <a href="https://eel.is/c++draft/string.classes#basic.string">[ISO C++] 的 <code>std::basic_string</code></a> 相关的类型。但一般地，<code>string</code> 类型应具有和 <code>std::string</code> 相近的操作以便实现对象语言语义及支持互操作。</p>
<p>　　推论：字符串和词素可直接比较相等性或排序。</p>
<p>　　<a href="#%E9%99%84%E5%8A%A0%E5%8A%9F%E8%83%BD">NPLA 数值</a>在对象语言中具有<a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">数值类型</a>，具体类型映射未指定，但在 NPLA 数学功能提供可选实现。派生实现可显式扩充或替换定义其它数值类型的类型映射。</p>
<p>　　其它宿主类型<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">由实现定义</a>。具体宿主类型参见以下各节和对象语言类型对应的描述。</p>
<p>　　宿主类型在对应的 C++ <a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 中可能以类型别名的形式引入。</p>
<p><strong>原理</strong></p>
<p>　　<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">类型系统</a>是<a href="#%E7%B1%BB%E5%9E%8B%E5%85%A8%E9%9B%86">开放</a>的，可能提供不被对象语言支持的宿主语言类型和值。</p>
<p>　　但符合已指定的类型的实体需能被视为同种类型的实体使用，即子类型。</p>
<p><strong>注释</strong></p>
<p>　　非典型的宿主类型可以是特定的宿主类型的值的子集，即便这样的类型不被宿主语言的类型系统直接表示。</p>
<p>　　不被对象语言支持的值的一个例子是实现使用的<em>中间值(thunked value)</em> 。</p>
<p>　　关于中间值、<code>string</code> 类型的具体要求、NPLA 数学功能的规格说明和由实现定义的命名空间，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h2 id="npla-未定义行为"><a class="header" href="#npla-未定义行为">NPLA 未定义行为</a></h2>
<p>　　一般地，NPLA 规则不排除<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未定义行为</a>。其中，<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>的未定义行为是非特定体系结构或其它 [ISO C++] 意义上不可预测或不可移植的行为。</p>
<p>　　除非派生实现另行指定，NPLA 约定仅有具有以下情形的程序引入未定义行为：</p>
<ul>
<li><a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>中引起宿主语言的未定义行为或不满足<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">约定的要求</a>而可能引入派生实现定义的未定义行为。
<ul>
<li><strong>注释</strong> 例如，<a href="#npla-%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE">没有被支持的并发访问</a>引起宿主语言的未定义行为。</li>
</ul>
</li>
<li><a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>无法提供资源而引起宿主语言的未定义行为（如宿主语言的实现无法提供宿主语言函数调用的自动对象隐式使用的资源）。</li>
<li>违反<a href="#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">资源所有权语义</a>约束的操作，包括但不限于：
<ul>
<li>违反<a href="#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>的操作。
<ul>
<li><strong>注释</strong> 例如，违反按<a href="#%E9%A1%B9%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象和关联对象所有权</a>的推论不能确保满足<a href="#npla-%E5%9F%BA%E7%A1%80%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">生存期要求</a>的操作。</li>
</ul>
</li>
<li>除非另行指定，构造任意的循环引用。</li>
</ul>
</li>
<li>使用特定的词法构造。</li>
</ul>
<p>　　除非派生实现另行指定，NPLA 约定：</p>
<ul>
<li>若程序的执行蕴含宿主语言中不保证排除未定义行为的操作，执行可包含宿主语言的未定义行为。</li>
<li>否则，非互操作引入的<a href="#%E7%AE%A1%E7%90%86%E8%A7%84%E7%BA%A6">管理规约</a>可能存在未定义行为，当且仅当它是<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值规约</a>的一部分且求值规约可能存在未定义行为。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　满足<a href="#%E9%94%99%E8%AF%AF">错误条件</a>的程序可能<a href="#%E9%94%99%E8%AF%AF">引起错误</a>，也可引起未定义行为而不要求引起错误。这允许减少实现的复杂性。</p>
<p>　　对宿主语言的未定义行为的单独处理允许描述互操作。</p>
<p>　　程序的执行允许宿主语言的未定义行为，同时允许形式上不可靠，但仍可通过宿主的外部环境提供附加保证的实现，而保留可实现性：</p>
<ul>
<li>典型地，宿主语言不保证调用的活动记录总是可用。
<ul>
<li>例如，[ISO C++] 指定程序在自动对象无法分配时具有未定义行为。</li>
<li>这种情形形式上无法排除，但不影响实用（否则，任意 [ISO C++] 程序都是不可移植的）。</li>
</ul>
</li>
<li>实现仍应保守使用资源，以尽可能地避免引起宿主语言的未定义行为。</li>
<li>通过宿主的外部提供附加保证的实现类似保证为<a href="#%E5%AE%8C%E6%95%B4%E6%80%A7">完整性</a>的前提下通过加入附加的限制来使设计符合要求。</li>
</ul>
<p>　　对管理规约的约定同时蕴含对 NPLA 实现的要求。这保证未定义行为不会被任意地在对象语言以外被引入。</p>
<p><strong>注释</strong></p>
<p>　　为简化互操作实现，部分 NPLA 未定义行为可能在实现中被检查以预防（尽可能避免）宿主语言的未定义行为，但这种检查不保证完全覆盖所有引起未定义行为的条件，不应预期其行为可移植。</p>
<p>　　关于构造循环引用可能引起的问题，另见<a href="#%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F">内存泄漏</a>。</p>
<h3 id="常规宿主资源分配要求"><a class="header" href="#常规宿主资源分配要求">常规宿主资源分配要求</a></h3>
<p>　　一般地，本机实现要求资源分配失败时，引起（可能派生）<code>std::bad_alloc</code> 或另行指定的宿主异常而非宿主语言的未定义行为；但因为宿主语言缺乏保证，可能并非所有宿主语言实现都能保证实现这项特性。</p>
<p>　　实际的实现中非极端条件下（如宿主调用栈接近不可用）通常可支持实现这些行为。</p>
<p>　　宿主语言实现支持时，具有可预期的失败（而 NPLA 或宿主语言的非未定义行为）的 NPLA 实现的要求称为常规宿主资源分配要求。</p>
<h3 id="嵌套调用安全"><a class="header" href="#嵌套调用安全">嵌套调用安全</a></h3>
<p>　　宿主语言的 <a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 提供<em>嵌套调用安全(nested call safety)</em> ，当且仅当：</p>
<p>　　若调用没有宿主语言无法分配资源的未定义行为，则同时避免因宿主语言的嵌套调用<a href="#%E8%BF%87%E7%A8%8B">深度</a>过大时引起的这样的未定义行为。</p>
<p>　　嵌套调用安全应包括支持可能通过对象语言构造的输入使对应宿主语言的操作中的嵌套调用不保证的情形。</p>
<p>　　对象语言的实现可假定限制避免无限创建<a href="#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">活动记录</a>即满足嵌套调用安全的要求。</p>
<p><strong>原理</strong></p>
<p>　　嵌套调用安全允许不限制嵌套深度的可靠的调用，如递归调用。</p>
<p>　　宿主语言实现在宿主语言的<a href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">尾上下文</a>可能支持<a href="#tco-%E5%AE%9E%E7%8E%B0%E7%AD%96%E7%95%A5%E6%A6%82%E8%BF%B0">宿主 TCO</a> 而使递归调用满足嵌套调用安全，但这并不是语言提供的保证，不应在可移植的实现中依赖。</p>
<p>　　[ISO C++] 并没有明确指定关于深度的限制，嵌套调用可能因资源耗尽而引起未定义行为。</p>
<p>　　严格来说，这种未指定深度是可移植性上的缺陷，因为任意小的深度的调用（甚至深度为 1 的非嵌套调用）都可引起未定义行为而不需要遵循任何 [ISO C++] 的要求，却仍然满足实现的<a href="../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">符合性</a>。</p>
<p>　　[ISO C] 也有相同的问题。</p>
<p>　　实际实现中，具体深度限制依赖实现。在宿主语言缺乏保证的状况下，添加附加假定对可实现性是必要的。</p>
<p><strong>注释</strong></p>
<p>　　对应宿主语言的操作中的嵌套调用不保证的情形的主要例子是保证<a href="#%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%AB%8B">宿主语言中立</a>。</p>
<p>　　非嵌套调用安全的情形在过程嵌套调用深度过大时，可因为宿主语言的存储资源消耗导致的宿主语言实现的未定义行为，典型地包括实现中的<em>栈溢出(stack overflow)</em> 。</p>
<p>　　不限深度的重入不一定引起无限的活动记录的创建：<a href="#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C-ptc">尾调用</a>应能保证嵌套调用安全。</p>
<h3 id="npla-并发访问"><a class="header" href="#npla-并发访问">NPLA 并发访问</a></h3>
<p>　　当前所有 NPLA 实现中都没有显式的<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">并发</a>访问控制，但可通过互操作引入。</p>
<p><strong>注释</strong></p>
<p>　　一般地，为避免并发访问引起的宿主语言的未定义行为，需要通过本机实现在外部使用不同的资源实例或附加适当的同步。</p>
<p>　　另见<a href="#%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E5%AE%89%E5%85%A8">并发访问安全</a>。</p>
<h2 id="npla-一等对象类型"><a class="header" href="#npla-一等对象类型">NPLA 一等对象类型</a></h2>
<p>　　除<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">类型映射</a>，NPLA 约定能作为一等对象的类型支持的抽象的类型，作为实现的最小要求的一部分。</p>
<p>　　以下章节扩充 NPLA 的其它类型，这些类型中的一部分可能作为一等对象。</p>
<p>　　基于<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">开放类型系统</a>，派生实现可定义其它类型，不论是否被<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>支持。</p>
<p><strong>原理</strong></p>
<p>　　这些类型在<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>等规则的描述中适用。</p>
<h3 id="有序对"><a class="header" href="#有序对">有序对</a></h3>
<p>　　两个不同对象可作为<em>元素(element)</em> 构成<em>有序对(ordered pair, pair)</em> 。</p>
<p>　　有序对的元素是<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>。</p>
<p>　　当且仅当若有序对的两个元素不同，交换元素得到的有序对和原有序对不同。</p>
<p><strong>注释</strong></p>
<p>　　一些编程语言中，构造有序对的操作称为 <code>cons</code> ，有序对又称为 cons 对。</p>
<h3 id="广义列表"><a class="header" href="#广义列表">广义列表</a></h3>
<p>　　<em>列表(list)</em> 一种<a href="#%E7%B1%BB%E5%9E%8B">类型</a>，它的对象可能具有<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>。</p>
<p>　　<em>空列表(empty list)</em> 是不含有子对象的列表。其它列表是<em>非空(nonempty)</em> 列表。</p>
<p>　　每个非空列表是一个<a href="#%E6%9C%89%E5%BA%8F%E5%AF%B9">有序对</a>对象，满足：</p>
<ul>
<li>有序对对象的第一个元素是列表的元素。</li>
<li>若有序对对象的第二个元素是有序对，则这个有序对对象的第一个元素是列表的元素；否则，最后一个不是有序对对象的子对象是列表的元素。</li>
</ul>
<p><strong>注释</strong> 推论：同一个列表的元素不是另一个元素的子对象；不同元素之间不具有所有权，生存期不相交。</p>
<p>　　从非空列表对象中取得元素<em>分解(decompose)</em> 列表对象。若经有限次分解，不再可取得列表对象的元素，则列表对象被完全分解。</p>
<p>　　完全分解的列表的最后一个元素之外的其它元素是列表的<em>前缀(prefix)</em> 元素。</p>
<p>　　对象具有前缀元素，当且仅当对象是列表且具有前缀元素。</p>
<p>　　<em>真列表(proper list)</em> 是空列表，或能经完全分解得到最后元素是空列表的列表。其它列表是<em>非真列表(improper list)</em> 。</p>
<p><strong>注释</strong> 推论：非真列表是非空列表。</p>
<p>　　<em>广义列表(generalized list)</em> 是真列表或非真列表。</p>
<p>　　广义列表的元素是<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>。广义列表对元素具有所有权。</p>
<p>　　广义列表是完全分解的元素的<em>序列(sequence)</em> 。</p>
<p>　　作为广义列表的非真列表是<em>无环的(acyclic)</em> ，不包含<em>环(cycle)</em> 。</p>
<p><strong>注释</strong> 同一般的 NPL 约定，NPLA 对象不支持<a href="#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">自引用和循环数据结构</a>。</p>
<p>　　除非另行指定，以下列表指真列表。</p>
<p>　　<em>子有序对(subpair)</em> 是一个有序对完全分解的序列中的元素的真子集构成的子对象。</p>
<p>　　<em>子列表(sublist)</em> 是一个列表中的元素的真子集构成的列表子对象。</p>
<p><strong>注释</strong></p>
<p>　　无环非真列表和真列表类似，可通过 <code>cons</code> 逐次构造。</p>
<p>　　非列表的有序对的元素可能具有自引用，而不是广义列表的元素，因此不是广义列表。NPLA 的一等对象不支持这种情形。</p>
<h3 id="符号"><a class="header" href="#符号">符号</a></h3>
<p>　　<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80"><em>符号(symbol)</em></a> 是未被求值的非<a href="#%E5%AD%97%E9%9D%A2%E9%87%8F">字面量</a><a href="#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">记号</a>的类型。</p>
<p>　　符号值可构成<a href="#%CE%BB-%E5%AE%8C%E5%A4%87%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AF%B9%E5%BA%94%E8%AF%AD%E6%B3%95">名称表达式</a>。</p>
<h2 id="存储和对象模型"><a class="header" href="#存储和对象模型">存储和对象模型</a></h2>
<p>　　NPLA 使用统一的模型对存储和<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">对象</a>进行抽象，并提供关于存储、对象和作为对象的<a href="#%E8%A1%A8%E7%A4%BA">表示</a>的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>以及<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">子项</a>的若干保证。</p>
<p>　　对象语言的存储被视为资源进行管理，称为<em>存储资源(memory resource)</em> 。</p>
<p><strong>原理</strong></p>
<p>　　语言中<a href="#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">默认不引入非一等对象</a>。因此，存储和对象模型作用到所有实体，有助于保持<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>。</p>
<p><strong>注释</strong></p>
<p>　　一等对象的使用可能受到其它规则的限制，不总是能同时通过对象语言的构造创建和访问。</p>
<p>　　NPL <a href="#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">允许派生实现引入实体的规则</a>不受限制。</p>
<h3 id="npla-基础存储模型和对象模型"><a class="header" href="#npla-基础存储模型和对象模型">NPLA 基础存储模型和对象模型</a></h3>
<p>　　因需提供<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a><a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作支持</a>，除不支持<em>静态(static)</em> 存储和没有提供支持的存储操作外，NPLA 的基础存储模型和对象模型和 [ISO C++11] 相同。</p>
<p>　　当前不支持的存储操作包括<em>分配函数(allocation function)</em> 取得的存储和<em>线程局部(thread-local)</em> 存储。</p>
<p>　　NPLA 还允许类似对象具有未指定的存储或不需要存储的实体，以使<a href="#%E5%AE%9E%E4%BD%93%E8%AF%AD%E4%B9%89">一等实体</a>可涵盖宿主语言在功能上等价的非对象类型（如 C++ 的引用）。这些实体若被支持，其存储实现和互操作接口由派生实现定义。</p>
<p>　　NPLA 中不是<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>的<a href="#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">一等实体</a>仅由派生实现定义。</p>
<p>　　保证存储性质的差异不被依赖时，不区分一等实体和一等对象的实现方式。</p>
<p>　　在此情况下对象都是<em>固定(pinned)</em> 的，即对象在<em>存储期(storage duration)</em> 内具有宿主语言意义上的确定不变的地址。派生实现可约定扩展作为例外。</p>
<p>　　推论：若一等实体不是一等对象，存储可能和一等对象的存储方式不同。派生实现可在必要时约定与其它一等实体存储的差异。</p>
<p>　　对象的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>是存储期的子集。创建对象基于已确保可访问的存储；销毁对象结束后释放存储。</p>
<p>　　NPLA <a href="#%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">支持特定的非一等对象</a>作为<a href="#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>的<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>。</p>
<p><strong>注释</strong> 和宿主语言类似。</p>
<p>　　作为一等对象相同方式传递的一等实体都视为一等对象。仅当不依赖一等对象的性质时，实现以<a href="#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>的方式实现一等实体的操作。</p>
<p><strong>原理</strong></p>
<p>　　<a href="#npla-%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83">实体的内部表示满足实现环境的要求</a>决定和 NPLA 和宿主语言之间共享一些基本的假定。</p>
<h3 id="间接值"><a class="header" href="#间接值">间接值</a></h3>
<p>　　特定的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>是<em>间接值(indirect value)</em> 。</p>
<p>　　间接值可以<em>关联(associated)</em> 一个对象。通过间接值可以间接<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>这个对象。</p>
<p>　　间接值可能是<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>或<a href="#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>。</p>
<p>　　非一等对象的间接值由实现定义，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p>　　派生实现可以定义其它间接值，称为 NPLA 扩展间接值。</p>
<p>　　一个间接值<em>有效(valid)</em> ，当且仅当存在关联的对象且访问对象不引起<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未定义行为</a>。</p>
<p>　　其它间接值是<em>无效(invalid)</em> 的。</p>
<p>　　除非另行指定，通过无效的间接值试图间接访问关联的对象不满足<a href="#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>而引起未定义行为。</p>
<p>　　有效的引用值可能被<em>无效化(invalidate)</em> 而不再有效。</p>
<p>　　派生实现可指定能使间接值无效化的操作。</p>
<p>　　因关联的对象<a href="#npla-%E5%9F%BA%E7%A1%80%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">存储期</a>结束而被无效化的间接值是<em>悬空(dangling)</em> 的。</p>
<p><strong>原理</strong></p>
<p>　　间接值可用于代替非间接值，避免求值时改变<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境</a>所有的非<a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的<a href="#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">所有权</a>。</p>
<p>　　间接值可实现和 [ISO C++] 引用类型的表达式类似的行为。</p>
<p>　　间接访问默认没有对象的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>检查，因此不是安全的。这可能被具体的间接值的规则改变。</p>
<p>　　限制具体的操作能避免或减少在可能访问间接值的操作随意引入具有潜在未定义行为风险。</p>
<p><strong>注释</strong></p>
<p>　　作为一等对象的间接值可能允许复制或转移关联的对象以恢复对应的非间接值作为一等对象直接访问。</p>
<p>　　在<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">使用约定</a>后，本节以下约定要求被 NPLA 实现支持作为一等对象的间接值。非一等对象的间接值由实现定义。派生实现可以定义其它的 NPLA 扩展间接值。</p>
<h4 id="间接值使用约定"><a class="header" href="#间接值使用约定">间接值使用约定</a></h4>
<p>　　间接值生存期规则：被规约对象中间接值的生存期被引用的环境中的对象的生存期的子集。</p>
<p>　　不满足间接值生存期规则的情形，除非提供派生实现定义的其它保证，不保证<a href="#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>。</p>
<p>　　以含间接值的项替代不含间接值的项，称为<em>引入(introduce)</em> 间接值。</p>
<p>　　包含间接值的项可被不含引用值的项替代，称为<em>消除(eliminate)</em> 间接值。</p>
<p>　　在特定的适当情形下实现应复制或转移间接值关联的对象以保证<a href="#%E9%A1%B9%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">满足生存期要求</a>，包括：</p>
<ul>
<li><a href="#%E5%B1%80%E9%83%A8%E9%97%B4%E6%8E%A5%E5%80%BC%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">局部间接值安全保证</a>描述的操作，包括<a href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>。</li>
<li>为<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>目的，实现定义的其它情形。</li>
<li>派生实现可能定义的其它情形。</li>
</ul>
<p>　　除非另行指定<a href="#%E9%94%99%E8%AF%AF">引起错误</a>，若不能满足上述适当情形条件，则<a href="#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">行为未定义</a>。</p>
<p>　　派生实现可基于本节约定其它规则。</p>
<p><strong>原理</strong></p>
<p>　　为保证间接访问关联对象的内存安全，约定间接值生存期规则。</p>
<p>　　参见局部间接值安全保证和返回值转换。</p>
<p><strong>注释</strong></p>
<p>　　如需直接<a href="#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">替换项</a>表示的值，需消除间接值。否则，没有必要提前对项进行操作以提前移除间接值。</p>
<p>　　关于实现定义和派生实现定义的其它情形，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p>　　另见被求值的<a href="#%E9%A1%B9%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">被规约项中的对象的所有权</a>。</p>
<h4 id="环境间接值"><a class="header" href="#环境间接值">环境间接值</a></h4>
<p>　　<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境引用</a>间接访问<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境对象</a>。</p>
<h4 id="引用间接值"><a class="header" href="#引用间接值">引用间接值</a></h4>
<p>　　<em>项引用(term reference)</em> 作为间接值引用一个项，访问这个以这个项作为表示的<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>作为关联对象。</p>
<p>　　项引用具有<a href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">标签</a>。</p>
<h3 id="求值和对象所有权"><a class="header" href="#求值和对象所有权">求值和对象所有权</a></h3>
<p>　　被求值的表达式的<a href="#%E8%A1%A8%E7%A4%BA">内部表示</a>中的对象具有 NPLA 对象的<a href="#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权</a>。</p>
<p>　　这些内部表示包括<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境对象</a>或<a href="#npla-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E4%B9%89">被求值的表达式中的项</a>的情形。</p>
<p>　　对象是表示它的<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">被规约项</a>的<em>项对象(term object)</em> 。</p>
<p>　　<a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">NPLA 临时对象</a>的存储未指定，但<a href="#%E9%A1%B9%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">部分临时对象被项所有</a>。</p>
<p>　　求值结束而不被使用的项的资源在求值终止时被释放，包括被项独占所有权的这些临时对象。</p>
<p>　　求值终止包括可被实现确定的<a href="#%E5%BC%82%E5%B8%B8">异常</a>退出。</p>
<p>　　对名义上被项所有的临时对象，必要时实现可分配内部存储转移项（包括在环境中分配），以满足附加要求（如<a href="#%E7%94%9F%E5%AD%98%E6%9C%9F%E9%99%84%E5%8A%A0%E7%BA%A6%E5%AE%9A">生存期附加约定</a>）。</p>
<p>　　对象的所有权随可随对象被转移，参见<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">对象的复制和转移</a>。</p>
<p>　　<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>可以是：</p>
<ul>
<li>作为<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值计算</a>的结果的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>，称为<em>结果对象(result object)</em> 。</li>
<li>传递异常的状态的实体。</li>
<li>派生实现可定义的其它实体。</li>
</ul>
<p><strong>注释</strong> 按<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值规约</a>，其它的求值结果的存在未指定，若存在则可能需要其它处理，可能依赖和处理一等对象的值不同的语义规则。</p>
<p>　　<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>时以<a href="#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">活动记录</a>保持<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的所有权。活动记录及其帧的具体结构、维护方式和生存期由派生实现定义。</p>
<p>　　除非另行指定，NPLA 只有一种<a href="#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">作用域</a>，这种作用域中的名称由<a href="#npla-%E7%8E%AF%E5%A2%83">环境</a>提供。</p>
<p>　　除非另行指定，NPLA 的活动记录不需要和<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>的结构保证直接对应关系。</p>
<p><strong>原理</strong></p>
<p>　　因为宿主语言函数调用实现（典型地，<em>调用栈(call stack)</em> 及其中的栈帧）不提供可移植的<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>，不要求实现提供活动记录之间的映射关系。</p>
<p><strong>注释</strong></p>
<p>　　临时对象的存储未指定、异常退出和所有权转移类似宿主语言。</p>
<p>　　结果对象和 [ISO C++17]（由提案 [WG21 P0135R1] 引入）中的概念对应。</p>
<p>　　另见<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境对象</a>和<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境引用</a>对其中的对象的所有权。</p>
<h4 id="项对象和关联对象所有权"><a class="header" href="#项对象和关联对象所有权">项对象和关联对象所有权</a></h4>
<p>　　仅在<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">泛左值</a>中允许引入可能访问关联对象的间接值。</p>
<p>　　推论：泛左值的项对象和它作为间接值可关联的对象（若存在）不是临时对象，被环境所有。</p>
<p>　　通常纯右值作为其它项的子项而被独占所有权，求值时可能通过<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">临时对象实质化转换</a>标识创建的<a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>。</p>
<p>　　<a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%A8%E7%A4%BA">表示临时对象的项</a>被纯右值所有，也间接被其它项所有。</p>
<p>　　特定的纯右值可能被<a href="#npla-%E7%8E%AF%E5%A2%83">环境</a>所有，但应只通过复制等方式访问其值而不依赖所有权关系。</p>
<p>　　关于实现中项的<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>和构成以及纯右值被环境所有的例子，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　基于<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>的性质，为保证<a href="#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>，避免非预期地超出存储期的间接值访问，限制引入间接值的表达式的<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">值类别</a>。</p>
<p>　　因<a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%A8%E7%A4%BA">临时对象可能具有和一等对象不同的表示</a>，在此特设规则约定。</p>
<h3 id="并发访问安全"><a class="header" href="#并发访问安全">并发访问安全</a></h3>
<p>　　蕴含按<a href="#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机语义</a>不等价副作用的并发的访问是<em>冲突的(conflict)</em> 。</p>
<p>　　不共享相同的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制状态</a>的<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">无序</a>的<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">规约事件</a>是<em>潜在并发的(potentially concurrent)</em> 。</p>
<p>　　若程序包含<a href="#%E4%BD%9C%E7%94%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99">蕴含</a>冲突的作用的潜在并发的求值，且这些求值之间没有附加的<em>数据竞争避免(data race avoidence)</em> 保证，程序的执行包含<em>数据竞争(data race)</em> ，不满足并发访问的内存安全。其中，以下机制数据竞争避免保证：</p>
<ul>
<li>所有潜在并发的求值都是宿主实现提供的<em>原子操作(atomic operation)</em> 时，避免数据竞争。</li>
<li>派生实现另行指定的数据竞争避免机制。</li>
</ul>
<p>　　并发访问相关的概念和 [ISO C++11] 相容。</p>
<h3 id="内存安全"><a class="header" href="#内存安全">内存安全</a></h3>
<p>　　（非并发）<em>内存安全(memory safety)</em> 是存储资源避免特定类型不可预测错误使用的性质。</p>
<p>　　基本的内存安全保证蕴含非<a href="#npla-%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE">并发访问</a>时不引入<a href="#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">未定义行为</a>。这至少满足：</p>
<ul>
<li>对存储的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>总是在提供存储的对象的存储期内，除非有其它另行指定的机制（如<a href="#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>的<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>）保证存储的访问不违反其它语义规则。</li>
<li>宿主环境中不访问未被初始化的值。</li>
</ul>
<p><strong>注释</strong> 实现仍可能因其它规则引起未定义行为；特别地，这包括<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>无法提供资源的未定义行为。</p>
<p>　　派生实现可能扩展内存安全，提供语言规则避免非预期的内存访问错误，提供更一般的高级<em>安全(security)</em> 保证。</p>
<p><strong>注释</strong> 例如，<em>保密性(secrecy)</em> 和<em>完整性(integrity)</em> 。</p>
<p>　　除非另行指定，派生实现不提供扩展的内存安全保证。</p>
<p>　　不满足<a href="#%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E5%AE%89%E5%85%A8">并发访问安全</a>的访问是非内存安全的。</p>
<p><strong>原理</strong></p>
<p>　　关于内存安全含义的讨论，另见<a href="https://arxiv.org/abs/1705.07354">这里</a>。</p>
<p><strong>注释</strong></p>
<p>　　用户代码应注意避免违反内存安全的访问，包括非并发的，以及并发访问的内存冲突。</p>
<h4 id="非内存安全操作"><a class="header" href="#非内存安全操作">非内存安全操作</a></h4>
<p>　　非内存安全操作是不保证内存安全的操作，在对象语言中即可能引起违反内存安全。</p>
<p>　　这些操作违反内存安全时，引起 <a href="#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">NPLA 未定义行为</a>，且可能未被实现检查而同时引起<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>的未定义行为。</p>
<p>　　对象语言中的非内存安全特性可能直接调用这些操作。NPLA 外依赖此类操作的其它操作也具有类似的性质。</p>
<p><strong>注释</strong></p>
<p>　　派生实现或<a href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>可能使用补充检查等方式避免未定义行为。</p>
<h4 id="npla-对象语言内存安全保证"><a class="header" href="#npla-对象语言内存安全保证">NPLA 对象语言内存安全保证</a></h4>
<p>　　NPLA 中，确定地引入具有<a href="#%E9%9D%9E%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">非内存安全操作</a>的对象的操作应仅只包括引入特定的<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>或其它派生实现指定类型的值的操作：</p>
<ul>
<li>调用引入不保证内存安全的间接值的 NPLA <a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 。</li>
<li>调用 NPLA 中其它取<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">对象</a>的<a href="#%E8%A1%A8%E7%A4%BA">内部表示</a>的值的间接值使之被<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">修改</a>的 API 。</li>
</ul>
<p>　　排除非内存安全操作以及非内存安全的本机实现，NPLA 实现的对象语言提供基本内存安全保证。</p>
<h4 id="npla-内存安全保证"><a class="header" href="#npla-内存安全保证">NPLA 内存安全保证</a></h4>
<p>　　满足 <a href="#npla-%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">NPLA 对象语言内存安全保证</a>同时排除引起宿主语言未定义行为的非内存安全的操作，NPLA 实现提供基本内存安全保证。</p>
<p><strong>注释</strong> 宿主语言未定义行为的非内存安全的操作如超出<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>。</p>
<p>　　除非通过接口约束另行指定，使用 NPLA 实现的派生实现应提供相同的保证。</p>
<p><strong>注释</strong> 例如，添加<a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A5">断言检查</a>可能改变<a href="#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">实现行为</a>。</p>
<h4 id="运行时内存安全检查"><a class="header" href="#运行时内存安全检查">运行时内存安全检查</a></h4>
<p>　　<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">运行时</a>检查可能帮助排查内存安全的<a href="#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">实现行为</a>。这包括蕴含运行时检查的接口约束（失败时抛出异常或断言）。</p>
<p>　　此外，实现可能提供可选的运行时检查。这些可选的检查帮助排查未定义行为，而不应被程序实现依赖。</p>
<h4 id="局部间接值安全保证"><a class="header" href="#局部间接值安全保证">局部间接值安全保证</a></h4>
<p>　　访问间接值涉及维护<a href="#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全保证</a>时，可能需要<a href="#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">提升项</a><a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">消除间接值</a>，以移除允许<a href="#%E9%9D%9E%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">非内存安全访问</a>的间接值。</p>
<p><strong>原理</strong></p>
<p>　　使用<a href="#%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5">删除策略</a>实现<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">过程调用</a>时，其中分配的<em>局部(local)</em> 资源随包含资源引用的<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>返回可能<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">逃逸</a>。一般的间接值也有类似的逃逸问题。</p>
<p>　　若其<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC">关联</a>的对象（如<a href="#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">项引用</a>关联的<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>）在调用后不再存在，则间接值不再有效，构成<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC">悬空间接值</a>。若这些间接值被<a href="#%E8%BF%87%E7%A8%8B">调用者</a>获取（如被作为<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>传递），继续<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>这个间接值关联的对象非内存安全。</p>
<p>　　为维护内存安全保证，这些情形应被避免，如通过：</p>
<ul>
<li>通过分析调用处的代码证明确保不存在这样的内存不安全访问。</li>
<li>通过间接值的消除移除这些间接值使这种悬空间接值在调用者中自始不存在。</li>
</ul>
<p>　　替代消除间接值的方式包括通过<em>逃逸分析(escape analysis)</em> 替换间接值，这也能减少间接值的访问而提供更优化的实现。例如，通过对<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境中被绑定对象的使用</a>进行逃逸分析提供优化实现。</p>
<p>　　但是，这不在 NPLA 中被要求，因为：</p>
<ul>
<li>逃逸分析需要完整的所有权信息，这需要附加的开销，否则不总是可行（例如涉及跨多个过程的调用）。</li>
<li>对删除策略，逃逸分析也没有提供不可替代的优化。</li>
</ul>
<h3 id="资源泄漏"><a class="header" href="#资源泄漏">资源泄漏</a></h3>
<p>　　<em>资源泄漏(resource leak)</em> 是不能预期地（决定性地）访问之前被分配的资源的情形。</p>
<p>　　<em>内存泄漏(memory leak)</em> 是存储资源的泄漏。</p>
<p>　　强内存泄漏状态是指存在存储无法通过任何途径访问的状态。若存在存储不被任意对象或其它另行指定的代替对象的实体（如<a href="#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>）所有权的传递闭包包含，即所有权依赖<em>不可达(unreachable)</em> ，则存在强内存泄漏。</p>
<p>　　弱内存泄漏是除了强内存泄漏以外的内存泄漏，和具体预期相关。</p>
<p><strong>原理</strong></p>
<p>　　一般意义下，[Cl98] 中定义的任一空间复杂度类都可以作为形式的预期。因为内存作为存储资源被空间复杂度类度量，满足某个空间复杂度类的无<em>空间泄漏(space leak)</em> 蕴含对应的无内存泄漏。</p>
<p>　　弱内存泄漏的预期的可实现性和实现细节相关，因此 NPLA 不指定具体预期。</p>
<h4 id="资源回收策略"><a class="header" href="#资源回收策略">资源回收策略</a></h4>
<p>　　<a href="#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">单一作用域</a>内的资源回收有<em>删除(deletion)</em> 和<em>保留(retention)</em> 的策略。</p>
<p>　　NPLA 不限定具体使用的回收策略，但要求应支持：</p>
<ul>
<li><a href="#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">释放一等对象时允许具有副作用</a>。</li>
<li>确保副作用作用时机的确定性，即除<a href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>指定外，不在<a href="#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机语义</a>中延迟副作用的起始。</li>
</ul>
<p>　　为简化语义规则同时避免限制特定的可用资源（如系统中剩余的内存）的变化被派生实现抽象为副作用，除非派生实现指定，不对内存使用保留策略，不使内存超出对象<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>。</p>
<p>　　NPLA 要求实现完全避免除用户程序显式管理资源的资源泄漏以外的强内存泄漏。</p>
<p>　　除非另行指定，NPLA 释放资源的作用顺序未指定。NPLA 不依赖释放的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>的顺序。</p>
<p>　　派生实现可以要求使用不同的规则：</p>
<ul>
<li>指定释放资源的顺序。</li>
<li>可选地支持非确定的释放资源的副作用。</li>
</ul>
<p>　　NPLA释放可能具有的副作用顺序的存储资源和其它资源共享更普遍的所有权抽象资源的<a href="#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权语义</a>上的操作：</p>
<p>　　使用删除策略时，<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">活动的过程调用</a>对其中分配的资源具有所有权。</p>
<p>　　注意多个对象构成的系统中，仅存在<a href="#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">平等的所有权</a>时的<a href="#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>造成强内存泄漏：除非即从循环引用的对象中区分出具有不同类所有权的对象子集实现所有权正规化，总是存在无法被释放资源的对象。</p>
<p>　　NPLA 不要求实现 GC 等机制避免这类循环引用。</p>
<p>　　关于循环引用避免，另见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　NPLA 不要求实现 <a href="#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">GC</a>。</p>
<p>　　未指定的资源释放的作用顺序使其中可能具有的副作用影响的可观察行为成为<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定行为</a>。</p>
<p>　　除非派生实现要求使用不同的规则支持非确定的资源的副作用，NPLA 的实现不依赖不保证确定性释放资源的副作用顺序的<em>追踪(tracing)</em> GC 。这使追踪 GC 可能被可选地添加(opted-in) 到实现支持特性中。这允许自动资源管理机制中一定程度的<a href="#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>。[ISO C++11] 起直至 [ISO C++20] ，C++ 语言规则支持类似的策略。</p>
<p>　　资源释放副作用的确定性要求和作用顺序未指定的规则不影响实现使用基于引用计数的 GC 策略。这允许实现以简单的方式以用户程序不直接可见的方式引入共享资源，在避免资源泄漏的意义上兼顾<a href="#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>和<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>。但为<a href="#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">避免单一所有者</a>，此时在对象语言应提供特性使用户程序可以创建隔离共享者的资源实体。</p>
<p>　　基于非预期的循环引用不可避免地造成实现开销而违反<a href="#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7">避免不必要付出的代价</a>（即使这种开销可能并不总是可观察）NPLA 不要求实现 GC 和对一般对象区分强弱引用等机制避免循环引用。此时，程序应自行避免所有权意义上的<a href="#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>以避免资源泄漏。</p>
<p>　　由于 GC 通常基于具有特定操作的单一资源所有权的所有者的对象池的这一实现特例，不依赖共享所有者的 GC 的设计一般也更容易满足<a href="#%E7%BB%9F%E4%B8%80%E6%80%A7">统一性</a>、<a href="#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99">最小接口原则</a>和<a href="#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99">关注点分离原则</a>。</p>
<p>　　以上规则允许程序中：</p>
<ul>
<li>不依赖释放可能具有的副作用顺序的资源。</li>
<li>使存储资源和其它资源共享基于更普遍的<a href="#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权抽象</a>的资源所有权语义的操作的<a href="#%E4%B8%80%E7%AD%89%E4%BD%9C%E7%94%A8">作用</a>，以一致的方式实现资源管理。</li>
</ul>
<p>　　关于不同的资源回收策略（其中一部分可能引起存储空间资源泄漏）的讨论，详见 [Cl98] 。</p>
<p>　　使用所有权抽象活动记录的资源能更好地满足资源管理机制和具体操作的<a href="#%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7">可复用性</a>和<a href="#%E4%BD%9C%E7%94%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99">作用使用原则</a>的要求。</p>
<h4 id="资源回收安全性"><a class="header" href="#资源回收安全性">资源回收安全性</a></h4>
<p>　　派生实现可补充定义规则在资源回收的作用上提供更强的安全保证。</p>
<p><strong>原理</strong></p>
<p>　　内存泄漏是和<a href="#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>不同的另一类非预期的问题，表明语言设计、实现或程序存在缺陷。</p>
<p>　　即便不违反内存安全保证，涉及弱化空间复杂度类预期的内存泄漏仍可损害程序的<a href="#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>而引起安全(security) 问题。</p>
<p>　　内存泄漏和违反内存安全同属违反特定的存储访问不变量的<em>错误条件(error condition)</em> ，但因为不论在语言还是程序的设计和实现中，避免的机制相当不同，在此被区分对待。</p>
<p>　　即便不扩展规则提供更强的内存安全保证，仅在资源回收的作用上避免错误条件也是有意义的。</p>
<p>　　存在其它语言使用类似的区分内存泄漏和<a href="#%E9%9D%9E%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">非内存安全</a>的设计，如 [Rust]（详见<a href="https://doc.rust-lang.org/book/second-edition/ch15-06-reference-cycles.html">相关文档</a>）。</p>
<h3 id="子对象"><a class="header" href="#子对象">子对象</a></h3>
<p>　　对象的<a href="#%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">子实体</a>是对象时，子实体是对象的<em>子对象(subobject)</em> 。</p>
<p>　　除非另行指定，子对象及其性质同宿主语言的约定：在宿主语言的表示中表现为子对象的对象语言中的对象，也是对象语言的子对象。</p>
<p>　　对象语言的其它具有子对象的情形由派生实现定义。</p>
<p>　　对象对它的子对象具有平凡的<a href="#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权</a>。</p>
<p>　　对象的子对象的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>不<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序</a>对象的生存期起始，对象的子对象的生存期结束不<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">后序</a>对象的生存期结束。</p>
<p>　　对象的子对象的生存期起始后序对象的生存期起始，对象的子对象的生存期结束先序对象的生存期结束。</p>
<p>　　除非另行指定，同一个的对象不同子对象的存储期起始、存储期结束、生存期起始、生存期结束之间分别无序。</p>
<p>　　对象对其存储期和生存期的其它约束和宿主语言相同。</p>
<p>　　对象可通过<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子对象引用</a>关联和与其生存期相关或无关的其它对象。</p>
<p>　　通过子对象访问的<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>上的<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">副作用</a>是否蕴含对象上的副作用未指定。</p>
<p>　　关于内部对象，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　子对象不一定支持<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">可修改</a>的<a href="#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">一等状态</a>。修改子对象可能导致或不导致对象或先前通过相同方式取得的子对象的<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">改变</a>。</p>
<p>　　[ISO C++] 通过类型定义具有的隐含的对象布局共享同类对象的<a href="#%E8%A1%A8%E7%A4%BA">内部表示</a>。与之不同，为简化<a href="#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>表示的项上的操作，子对象之间不一定共享表示。</p>
<p>　　特别地，通过<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E8%A1%A8%E7%A4%BA">子对象引用项</a>访问的对象的子对象之间不一定具有<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>。</p>
<p>　　关于具体表示，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>注释</strong></p>
<p>　　作为支持子对象作为内部对象的逻辑前提，NPLA 不支持<a href="#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>。</p>
<p>　　[ISO C++] 允许 <code>const</code> 成员提供不支持修改的状态。<a href="#npla-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F">NPLA 不要求类似的类型系统支持</a>，没有类似的设计。</p>
<h4 id="项的子对象"><a class="header" href="#项的子对象">项的子对象</a></h4>
<p>　　作为对象的子项是<a href="#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象</a>的子对象。</p>
<p>　　因为子项可以递归地具有子项，项对象作为<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">数据结构</a>构成<em>树(tree)</em> 。项对象是树的节点，即<em>项节点(term node)</em> 。</p>
<p>　　项节点具有如下互斥的基本分类：</p>
<ul>
<li><em>枝节点(branch node)</em> 或<em>非叶节点(non-leaf node)</em> ：具有子节点的节点。</li>
<li><em>叶节点(leaf node)</em> ：不具有子节点的节点。</li>
</ul>
<p>　　除子项外，项具有<em>值数据成员(value data member)</em> 作为其子对象。</p>
<p>　　表示项对象的<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">被规约项</a>的值数据成员提供时间复杂度为 <tt>O(1)</tt> 的操作判断：</p>
<ul>
<li>项对象是否为<a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">有序对</a>。</li>
<li>项对象是否为<a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>。</li>
<li>非有序对的项对象具有的<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>。</li>
</ul>
<p>　　值数据成员可能具有空值。</p>
<p>　　值数据成员和子项可构成<a href="#%E8%A1%A8%E7%A4%BA">对象的内部表示</a>：</p>
<ul>
<li><em>列表节点(list node)</em> 是值数据成员为空的节点，表示真列表。</li>
<li><em>空节点(empty node)</em> 同时是叶节点和列表节点，表示<a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">空列表</a>。</li>
<li>实现可定义其它的节点作为其它的内部表示。</li>
</ul>
<p>　　若项存在其它子对象，作为对象内部表示的具体规则由实现定义。</p>
<p>　　满足以下条件的替换变换替代项或其子对象，称为项的<em>提升(lifting)</em> ：被提升的项（源）是提升后得到的项（目标）的一个直接、间接子项或项的子对象变换得到的项。</p>
<p>　　提升可能包含附加检查，检查失败时可能<a href="#%E9%94%99%E8%AF%AF">引起错误</a>而不实际进行提升。</p>
<p>　　除非另行指定，提升项<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">修改</a>被替换的对象。</p>
<p><strong>原理</strong></p>
<p>　　项的子对象确定的表示可能被具体的<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>依赖。</p>
<p>　　项的提升可以视为作为语法变换的消去 <a href="#%CE%BB-%E5%AE%8C%E5%A4%87%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AF%B9%E5%BA%94%E8%AF%AD%E6%B3%95">λ 抽象</a>的 <a href="https://en.wikipedia.org/wiki/Lambda_lifting">lambda 提升 (en-US)</a> 的一般化，但此处和 λ 抽象没有直接关联。</p>
<p>　　项的提升的变换可以是恒等变换，即直接以子对象作为替换的来源。其它变换如创建<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>和取间接值关联的对象，对应的提升<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">引入和消除间接值</a>。</p>
<p>　　项的提升的检查可包括为满足接口行为的<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">语义检查</a>和实现为预防<a href="#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">宿主语言的未定义行为</a>的附加检查。</p>
<p>　　被提升的项往往被<a href="#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">转移</a>，因此一般地，需要在宿主语言中<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">可修改</a>。若被提升的项表示对象语言的值，一般也需要在对象语言中可修改。</p>
<h3 id="对象属性"><a class="header" href="#对象属性">对象属性</a></h3>
<p>　　除以上性质外，对象可关联其它元数据以指定对象的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">属性</a>。</p>
<p>　　和属性对应的可组成对象的表示的非一等实体统称为<em>标签(tag)</em> 。</p>
<p>　　对象具有的标签决定以下<a href="#%E6%AD%A3%E4%BA%A4%E6%80%A7">正交</a>的性质：</p>
<ul>
<li>唯一(unique) 引用：指定<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">对象的值</a>关联到自身以外的不被其它对象<a href="#%E5%AF%B9%E8%B1%A1%E5%88%AB%E5%90%8D">别名</a>的对象。
<ul>
<li>以唯一引用关联的对象进行<a href="#%E5%A4%8D%E5%88%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96">复制初始化</a>时，不需要保留关联的对象的值。</li>
</ul>
</li>
<li>不可修改(nonmodifying) ：指定对象的值保持不变。
<ul>
<li>若操作需要修改此对象，则<a href="#%E9%94%99%E8%AF%AF">引起错误</a>。</li>
</ul>
</li>
<li>临时(temporary) 对象：指定对象的值被临时使用。</li>
</ul>
<p>　　唯一引用和不可修改是<a href="#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>的属性。对象语言中，引用值以外的对象是否具有这些属性未指定。为<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>目的可能具有实现定义的更强的假设。派生实现也可定义更强的假设。</p>
<p>　　临时对象属性类似唯一引用，但限定的可以是对象自身而非关联的其它对象，即引用值自身和<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>可以分别具有临时对象属性。但除了引用值属性外，临时对象属性仅限在<a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>上出现。</p>
<p><strong>注释</strong></p>
<p>　　不可修改的对象类似 [ISO C++] 的 <code>const</code> 类型的对象。[ISO C++] 的非类和非数组类型的对象不具有 <code>const</code> 修饰。</p>
<p>　　对象的标签不在大多数对象中可见。另见<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用值的属性</a>。</p>
<h2 id="npla-环境"><a class="header" href="#npla-环境">NPLA 环境</a></h2>
<p>　　<a href="#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">求值环境</a>维护<a href="#%E5%90%8D%E7%A7%B0">名称</a>和作用域。</p>
<p>　　<em>变量名(variable name)</em> 即<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">变量</a>的<a href="#%E5%90%8D%E7%A7%B0">名称</a>。</p>
<p>　　除非另行指定，环境维护的名称都是变量名。</p>
<p>　　NPLA 的求值环境可以是：</p>
<ul>
<li><em>一等环境(first-class environment)</em> ，即作为对象语言中的<a href="#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">一等对象</a>的环境。</li>
<li>作为 NPLA <a href="#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>的<em>环境记录(environment record)</em> 。</li>
</ul>
<p>　　环境可引用若干个关联的其它环境为<em>父环境(parent environment)</em> ，用于<a href="#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">重定向</a>。</p>
<p>　　除非派生实现另行指定：</p>
<ul>
<li>环境可引用有限多个父环境，其数量的上限未指定。</li>
<li>父环境在创建时指定，作为<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">实体</a>，之后<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">不可变</a>。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　如<a href="#%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0">需求</a>中指出的，本设计<a href="https://github.com/FrankHB/pl-docs/blob/master/en-US/calling-for-language-features.md#namespace-separation">避免命名空间隔离</a>，因此只有一种被环境支持且被<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>统一处理的名称。</p>
<p>　　若派生实现需要，可修改环境的内部表示和求值算法的<a href="#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>步骤以对不同的名称添加支持。相反，在已有多种名称的设计中还原为一种设计是更复杂和不可行的。因此，在本设计中不预设多种名称。</p>
<h3 id="环境对象"><a class="header" href="#环境对象">环境对象</a></h3>
<p>　　环境作为可保持<a href="../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">可变状态</a>的对象，是<em>环境对象(environment object)</em> 。</p>
<p>　　环境对象包含变量名到表示<a href="#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">被绑定实体</a>的映射，称为<em>名称绑定映射(name binding map)</em> ，实现<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">变量绑定</a>。</p>
<p>　　被绑定实体是对象时，称为<em>被绑定对象(bound object)</em> 。NPLA 环境对象中的被绑定实体包含一等对象，因此被绑定实体总是被绑定对象。</p>
<p>　　环境对象对其中的<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">名称绑定映射</a>具有独占的<a href="#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权</a>。名称绑定映射对其中的对象可具有独占或共享的所有权。因此，环境对象可对包括被绑定实体的名称绑定映射中的对象具有独占或共享的所有权。</p>
<p>　　环境记录之间共享所有权，以<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境引用</a>访问。</p>
<p>　　环境对象是<a href="#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>时查找名称的<a href="#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">目标</a>。</p>
<p>　　父环境可共享环境记录。通过共享环境记录实现重定向的环境表示是<em>链接的(linked)</em> 而非<em>平坦的(flat)</em> 。</p>
<p><strong>原理</strong></p>
<p>　　仅在可证明符合语义要求等价时，使用平坦的环境表示。</p>
<p>　　对支持一等对象语义的设计，因为明确要求区分<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>，对象的<a href="#%E8%A1%A8%E7%A4%BA">存储</a>不能被任意地复制。</p>
<p>　　一般地，仅在可证明父环境对应的环境记录在对象语言和实现内部都不被共享访问（不具有<a href="#%E5%85%B1%E4%BA%AB%E5%BC%95%E7%94%A8">共享引用</a>且不被<a href="#%E5%AF%B9%E8%B1%A1%E5%88%AB%E5%90%8D">别名</a>），且不存在任意派生实现定义的对释放顺序引起的可观察行为差异时，才能唯一具有这个父环境的环境为平坦的表示而<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">保持语义不变</a>。</p>
<p><strong>注释</strong></p>
<p>　　变量名通过以和字符串一一对应的值表示，没有直接的值的限制，可能为空串。</p>
<p>　　若环境记录直接持有<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>，则这些对象是环境记录的<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>。</p>
<h3 id="环境引用"><a class="header" href="#环境引用">环境引用</a></h3>
<p>　　环境引用是对象语言中访问环境记录的<a href="#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">一等对象</a>。</p>
<p><strong>注释</strong> 环境引用不是<a href="#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>。后者关联的被引用对象是一等对象。</p>
<p>　　环境引用共享环境对象的<a href="#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权</a>。</p>
<p>　　根据所有权管理机制的不同，环境引用包括<a href="#%E4%B8%80%E8%88%AC%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%80%E8%88%AC%E5%AE%9E%E7%8E%B0">环境强引用</a>和<a href="#%E4%B8%80%E8%88%AC%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%80%E8%88%AC%E5%AE%9E%E7%8E%B0">环境弱引用</a>。</p>
<p>　　<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境强引用</a>可能共享环境对象的所有权，对<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境对象的名称绑定映射</a>持有的项具有间接的所有权。</p>
<p>　　作为<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>，环境引用可被复制或转移。</p>
<p>　　复制或转移环境引用不引起被引用的环境对象被复制。因此，<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值传递</a>环境引用不引起其中所有的对象被复制。另见<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>。</p>
<p><strong>原理</strong></p>
<p>　　区分环境对象和环境引用在纯函数式语言不是必要的，因为不需要关心<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境中的子对象</a>的复制影响<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>。</p>
<p>　　否则，为支持影响可观察行为的环境的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">修改</a>，非环境记录的环境引用是必要的。</p>
<p>　　环境引用也是一种较简单且一般普遍高效的父环境的实现表示，可直接实现<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">链接的</a>环境而不需要证明和实现特设的其它内部表示能和<a href="#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA">抽象机</a>意义上链接的环境保持语义等价。</p>
<p>　　<a href="#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延捕获</a>若复制续延，可能引起关联的环境的复制，影响可观察行为并引起不必要的实现开销。为此，区分环境引用是必要的。</p>
<p>　　以环境引用作为一等对象使访问<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>等环境记录的子对象时需要间接访问，在环境实际不需要被复制的大部分其它场景引起开销。这种开销是可接受的，因为：</p>
<ul>
<li>考虑到一等环境的普遍性，有必要有效支持对象语言中创建环境临时对象（而不仅仅是环境对象的<a href="#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>）的使用使之避免复制。</li>
<li>实现可能提供附加的证明以在优化的<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">翻译</a>过程中替换环境引用为环境记录或其它不需要间接访问的中间表示，以消除这些开销。</li>
</ul>
<p>　　不论这样的证明是否存在，环境强引用和弱引用仍在对象语言中区分，以明确接口上的<a href="#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权语义</a>。</p>
<p>　　引入环境弱引用作为一般的引用机制，且仅在必要时使用环境强引用，以避免过于容易<a href="#%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5">引入循环引用引起强内存泄漏</a>，符合<a href="#%E9%80%82%E7%94%A8%E6%80%A7">适用性</a>。</p>
<h3 id="当前环境"><a class="header" href="#当前环境">当前环境</a></h3>
<p>　　NPLA 对象语言中，表达式的求值隐含对应一个环境对象作为<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>需要的<a href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">上下文</a>输入，称为<em>当前环境(current environment)</em> 。</p>
<h2 id="npla-表达式语义"><a class="header" href="#npla-表达式语义">NPLA 表达式语义</a></h2>
<p>　　本节约定对象语言中的表达式相关的语义规则，特别是<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值规则</a>。</p>
<p>　　<a href="#%E5%88%97%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">列表表达式</a>作为<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>是<a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">列表</a>。</p>
<h3 id="值类别"><a class="header" href="#值类别">值类别</a></h3>
<p>　　<a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>归类为具有以下基本的<em>值类别(value category)</em> 之一：</p>
<ul>
<li><em>泛左值(glvalue)</em> ：求值用于决定被表示的对象的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>的表达式。</li>
<li><em>纯右值(prvalue)</em> ：求值不用于决定对象同一性（而仅用于<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a><a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>或计算对象中<a href="#%E8%A1%A8%E7%A4%BA">存储的值</a>）的表达式。</li>
</ul>
<p>　　一个泛左值可能被标记为<em>消亡值(xvalue)</em> ，以提供基于不同的所有权的行为。</p>
<p>　　纯右值蕴含对象在<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>的意义上不被共享，类似不被别名的引用的<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>不被<a href="#%E5%AF%B9%E8%B1%A1%E5%88%AB%E5%90%8D">共享</a>。</p>
<p>　　<em>左值(lvalue)</em> 是除了消亡值外的泛左值。</p>
<p>　　<em>右值(rvalue)</em> 是消亡值或纯右值。</p>
<p>　　基本的值类别、消亡值、左值和右值都是值类别。</p>
<p>　　求值涉及表达式的值类别仅在必要时约定。</p>
<p>　　表达式的值类别是上下文相关的，相同表达式构造在不同的上下文可能具有不同的值类别。</p>
<p>　　NPLA 表达式允许在源语言语法之外的形式被间接构造，这些表达式同样具有值类别。</p>
<p>　　<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值规约</a>可能重写一个表达式为具有不同值类别的为被规约项。即便不能被对象语言表达，只要不和其它语义规则冲突，它们在此被视为其它形式的表达式的表示，即<a href="#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象</a>也对应地具有值类别。</p>
<p>　　一般地，NPLA 的表达式不限定从<a href="#%E8%A1%A8%E7%A4%BA">源代码</a>的<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">翻译</a>确定，且一个表达式的求值结果不排除继续构成表达式而被求值，因此表达式的值也普遍具有值类别。</p>
<p>　　除非另行指定，若一个 NPLA 表达式没有指定未被求值，则其值类别是其<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>的值类别。</p>
<p><strong>原理</strong></p>
<p>　　值类别根据是否只关心表达式关联的（对象的或非对象的）值，在需要对象时提供区分<a href="#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">两类一等实体</a>的机制，同时避免在仅需要表达式关联的值时引入不必要的其它对象。</p>
<p><strong>注释</strong></p>
<p>　　对象语言表达式的值类别和 [ISO C++17]（由提案 [WG21 P0135R1] 引入的特性）类似。</p>
<p>　　值类别在 [ISO C++] 中实质上是一种<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态类型</a>系统。在 NPLA 中以更灵活的可在<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">运行时</a>访问的元数据代替，仍能体现类似的上下文相关性。</p>
<p>　　除了标记消亡值，附加其它元数据也允许区分不同的所有权行为。</p>
<p>　　NPLA 值类别和 [ISO C++] 也有显著的不同，体现在如下扩展：源语言语法外的<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">被规约项</a>的项对象视为 NPLA 表达式，也具有值类别。</p>
<p>　　因此，作为<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>的表达式的值也普遍具有值类别。若存在<a href="#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">结果对象</a>，可直接<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B">通过其类型确定</a>。</p>
<p>　　作为静态语言，[ISO C++] 缺乏允许在运行时确定的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>特性，这些不同不在 [ISO C++] 中可用，可以被视为保守的扩展。</p>
<h4 id="类型系统和值类别"><a class="header" href="#类型系统和值类别">类型系统和值类别</a></h4>
<p>　　NPLA 中，值类别作为<a href="#%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%9E%8B">实体类型</a>，被作为一种内建的<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">类型系统</a>。</p>
<p><strong>注释</strong></p>
<p>　　这和 [ISO C++] 不同。[ISO C++] 的“类型”的定义排除值类别，尽管值类别具有类型论意义上所有可作为类型讨论的对象的性质。</p>
<p>　　另见<a href="#%E5%BC%95%E7%94%A8%E5%80%BC">引用类型</a>。</p>
<h3 id="初始化"><a class="header" href="#初始化">初始化</a></h3>
<p>　　对象被创建后可通过<em>初始化(initialization)</em> 决定其值，并可能存在其它<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>。被决定的值是<em>初始值(initial value)</em> 。</p>
<p>　　决定初始化这些作用的表达式是初始化的<em>初值符(initializer)</em> 。</p>
<p>　　初值符的求值可能有<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>，其求值结果指定特定被初始化的对象的初始值。</p>
<p>　　初始化包括<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>的初始化和作为函数值的<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>对象的初始化。</p>
<p>　　初始化被绑定对象可能以<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">修改操作</a>的形式体现，此时修改绑定具有副作用。若这样的副作用存在，每个被初始化的值<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">后序</a>于对应初始的计算。</p>
<p><strong>注释</strong></p>
<p>　　初值符的求值的副作用不属于初始化，其求值结果和对象的初始值不一定相同。</p>
<p>　　和宿主语言不同，初始化不是独立的依赖特定语法上下文的概念，但此处语义上的作用类似。</p>
<p>　　对象的初始化一般可蕴含<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的初始化。</p>
<h4 id="复制初始化和直接初始化"><a class="header" href="#复制初始化和直接初始化">复制初始化和直接初始化</a></h4>
<p>　　初始化包括<em>直接初始化(direct initialization)</em> 和<em>复制初始化(copy initialization)</em> 。</p>
<p>　　函数可能接受<a href="#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>参数和返回值，是对函数的形式参数或函数值的复制初始化；其它初始化是直接初始化。</p>
<p>　　复制初始化形式参数和函数值时，函数参数或返回值作为初值符。</p>
<p><strong>注释</strong></p>
<p>　　区分两者和宿主语言类似。</p>
<h4 id="函数参数和函数值传递"><a class="header" href="#函数参数和函数值传递">函数参数和函数值传递</a></h4>
<p>　　部分函数可保证<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">被初始化的对象副本</a>中的值和初值符的值及元数据一致。</p>
<p>　　这样的参数或返回值的初始化的求值称为<em>转发(forwarding)</em> 。</p>
<p>　　转发也包括只部分保留上述部分元数据的情形。</p>
<p>　　在允许保留元数据不变的上下文，转发在<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>中可直接通过<a href="#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">转移项</a>实现。</p>
<p>　　转发保持引入这些初始化的表达式（通常是被求值取得函数值的函数表达式）时，其求值结果（函数值）的<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">值类别</a>和初值符保持一致。</p>
<p><strong>注释</strong></p>
<p>　　这里的元数据的一个例子是<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用值的属性</a>。</p>
<p>　　转发类似宿主语言的<em>完美转发(perfect forwarding)</em> 。</p>
<p>　　另见<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">函数值传递</a>。</p>
<h4 id="对象的复制和转移"><a class="header" href="#对象的复制和转移">对象的复制和转移</a></h4>
<p>　　可使用初值符为参数进行复制或转移操作以<a href="#%E5%A4%8D%E5%88%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96">复制初始化</a>对象，创建<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">对象的副本</a>。</p>
<p><strong>注释</strong> 这类似宿主语言中的类类型的值。其它情形另见<a href="#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4">复制消除</a>。</p>
<p>　　对象的复制和转移不改变被转移后的<a href="#%E7%B1%BB%E5%9E%8B">类型</a>。</p>
<p>　　对象的复制和转移对应蕴含其子对象被复制和转移。在<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>的意义上，若项<a href="#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">具有子对象的独占所有权</a>，这些子对象的复制构造函数和转移构造函数被对应调用。特别地，这里的子对象包括<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主值</a>。</p>
<p>　　可使用转移操作时，不对作为对象的<a href="#%E8%A1%A8%E7%A4%BA">表示</a>的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>进行复制，因此不要求其中的子对象可复制，而避免<a href="#%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p><strong>注释</strong> 这类似 [ISO C++11] 起选择类的转移构造函数代替复制构造函数。</p>
<p>　　和 [ISO C++11] 起不同，上述可使用转移操作的条件和语法上下文无关：引起选择转移操作的条件由对初值符的谓词而非类似宿主语言的构造函数判断（详见<a href="#%E9%BB%98%E8%AE%A4%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2%E7%BA%A6%E5%AE%9A">默认值类别转换约定</a>）。</p>
<p><strong>注释</strong> 同宿主语言。</p>
<p>　　除非另行指定，需要创建实体的副本时：</p>
<ul>
<li>若对象满足<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%AF%E8%BD%AC%E7%A7%BB%E6%9D%A1%E4%BB%B6">可转移条件</a>，则转移而不是复制。</li>
<li>其它情形实体被复制。</li>
</ul>
<p><strong>注释</strong> 一个主要的实例是<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值的副本传递</a>。</p>
<h4 id="项的转移"><a class="header" href="#项的转移">项的转移</a></h4>
<p>　　一定条件下，作为对象的<a href="#%E8%A1%A8%E7%A4%BA">表示</a>的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>可被整体转移，而避免其中包含的对象的初始化在对象语言中具有可见的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>。</p>
<p>　　在<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>的意义上，因作为对象的表示的项的转移，项及其子对象的转移构造函数会被调用，但项的<a href="#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">值数据成员</a>中的<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>的转移构造函数不会被调用。</p>
<p><strong>注释</strong> 这一般要求实现使用某种<a href="#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">类型擦除</a>使子对象类型的转移构造函数的调用不蕴含宿主类型的转移构造函数的调用。</p>
<p>　　项的转移是<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">析构性转移</a>。</p>
<p>　　一般地，当对象需要被转移且没有约定<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">转移后要求类型不变</a>时，项的整体转移可代替<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">对象的转移</a>，避免初始化新的<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主对象</a>，称为宿主对象转移消除。</p>
<p><strong>注释</strong> 若需调用<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>的转移构造函数，需明确避免在代替对象的转移的上下文中进行操作。派生实现可提供这些操作。</p>
<p>　　<a href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87">返回值转换上下文</a>的转移蕴含宿主对象转移消除。</p>
<p>　　若被<a href="#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4">复制消除</a>的对象来自不同的项，则复制消除蕴含宿主对象转移消除。这包括所有对象转移的返回值转换上下文的情形。</p>
<h3 id="引用值"><a class="header" href="#引用值">引用值</a></h3>
<p>　　在对象语言中，<em>引用值(reference value)</em> 是作为<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>，可保存在一等对象中。这样的一等对象是<em>引用对象(reference object)</em> 。</p>
<p>　　引用值和引用对象的值具有<em>引用类型(reference type)</em> 。</p>
<p>　　在特定上下文中，引用和其它<a href="#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">一等对象</a>的值的相同具有不同的语义，主要体现在引用值被按值直接初始化传递和<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按引用传递</a>时。</p>
<p><strong>注释</strong> 差异和 [ISO C++] 中使用对象类型和引用类型作为参数类似。</p>
<p>　　NPLA 引用值总是假定和<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>关联。</p>
<p><strong>注释</strong> 和宿主类型类似，引用类型没有空值。</p>
<p>　　仅当以下情形中，NPLA 引用值的被引用对象是非<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">一等对象</a>：</p>
<ul>
<li>作为<a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　由于<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>的<a href="#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象</a><a href="#%E9%A1%B9%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">被环境所有</a>，为允许<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">规约求值</a>其中的<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>，需要不被环境所有的（其它不同的）<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">被规约项</a>作为<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">表示</a>的<a href="#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象</a>作为中间值。</p>
<p>　　这种中间值通过间接引用作为<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>使用，也是<a href="#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">一种间接值</a>，即引用值。</p>
<h4 id="子对象引用"><a class="header" href="#子对象引用">子对象引用</a></h4>
<p>　　特定的引用值是<em>子对象引用(subobject reference)</em> ，其被引用对象是被另一个对象所有的、作为这个对象的<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的一等对象。</p>
<p>　　子对象引用对特定操作可表现和其它一等对象不同的行为。</p>
<p>　　以下引用是子对象引用：</p>
<ul>
<li><em>子有序对引用(subpair reference)</em> 是<a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">子有序对</a>作为被引用对象的引用。</li>
<li><em>子列表引用(sublist reference)</em> 是<a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">子列表</a>作为被引用对象的引用。</li>
</ul>
<p>　　语言可能引入其它的子对象引用。</p>
<h4 id="引用值的有效性"><a class="header" href="#引用值的有效性">引用值的有效性</a></h4>
<p>　　<a href="#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">作为</a>一种<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>，引用值有效当且仅当访问被引用对象不引起未定义行为。</p>
<p>　　以下约定要求被 NPLA 实现支持的有效的引用值总是无条件地允许访问对象。</p>
<p>　　有效的引用值应通过特定的构造方式引入，包括：</p>
<ul>
<li>在对象语言通过被引用对象初始化引用值。</li>
<li><a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>引入的保证不引起未定义行为的引用值。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　一些对象语言的操作可能引起引用值无效。例如，<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">改变</a>被引用对象可以使已被初始化的有效的引用值成为<em>悬空引用(dangling reference)</em> 。</p>
<h4 id="多重引用"><a class="header" href="#多重引用">多重引用</a></h4>
<p>　　被引用对象也可以是引用值。</p>
<p>　　被引用对象不是引用值的引用值是<em>完全折叠(fully collapsed)</em> 的。</p>
<p>　　除非另行指定，<em>未折叠的(uncollapsed)</em> 引用值指未完全折叠的引用值。</p>
<p><strong>注释</strong></p>
<p>　　这和宿主语言不同。</p>
<h4 id="引用值的属性"><a class="header" href="#引用值的属性">引用值的属性</a></h4>
<p>　　引用值可以具有和作为引用值<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">表示</a>的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>保存的<a href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">属性</a>相互独立的属性，保存其作为一等对象的状态。</p>
<p>　　属性不可分割：一个引用值明确具有或者不具有一种属性。</p>
<p>　　和<a href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">对象属性</a>对应，NPLA 指定的引用属性可以是：</p>
<ul>
<li>唯一引用。</li>
<li>不可修改引用。</li>
<li><a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>引用。</li>
</ul>
<p>　　引用值属性指定通过引用对<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的访问假定允许具有的性质，即便被引用对象自身没有具有这些属性。</p>
<p>　　特定的操作使用引用值作为操作数，根据不同的属性决定行为，包括在违反属性引入的假定时<a href="#%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　在本节要求以外，除非派生实现另行指定，违反这些假定不引起 <a href="#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">NPLA 未定义行为</a>。</p>
<p>　　具体的引用属性满足以下语义规则：</p>
<ul>
<li>唯一引用允许通过引用值访问被引用对象时，对象可被假定不被其它引用而仅通过这个途径访问，即便实际存在其它途径的引用时可能引起不同的行为；在假定的基础上程序具有何种可能的行为是未指定的。</li>
<li>唯一引用可被假定不被共享，被引用对象不被<a href="#%E5%AF%B9%E8%B1%A1%E5%88%AB%E5%90%8D">别名</a>。</li>
<li>通过不可修改引用的左值的对象访问不包含<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">修改</a>。否则，若没有引起错误，程序<a href="#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">行为未定义</a>；但除非另行指定，不引起<a href="#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">宿主语言的未定义行为</a>。</li>
<li>具有临时对象引用属性的引用值是临时对象的引用值，其被引用对象是临时对象。</li>
</ul>
<p><strong>原理</strong> 宿主语言的互操作不被总是要求保证对象语言程序的可移植性，但不应引起实现自身的行为无法预测。</p>
<p>　　对引用值的操作<em>传播(propagate)</em> 特定的引用属性，当且仅当：</p>
<p>　　若操作数是具有特定引用属性的引用值，且结果是引用值时，结果具有和操作数相同的特定属性。</p>
<p><strong>注释</strong></p>
<p>　　引用值属性和对象属性相互独立，类似 [ISO C] 和 [ISO C++] 在指针和引用等复合类型的 <code>const</code> 等限定独立于指向的对象或被引用对象上的类型不同。通过 <code>const</code> 等属性可以在指针或引用类型上单独限制类型，而不影响对应的被间接访问的对象。</p>
<p>　　唯一引用蕴含的假定类似 [ISO C] 约定的 <code>restrict</code> 关键字，但程序违反假定的约束时不引起未定义行为。</p>
<p>　　和 [ISO C++] 核心语言（但不是 <a href="https://eel.is/c++draft/res.on.arguments">[res.on.arguments]</a> 中的标准库绑定到右值引用实际参数的约定）的右值引用类似，唯一引用不总是表示被引用对象不被共享。</p>
<p>　　接受唯一引用的操作可能只假定被引用对象的<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>不被共享，也可能完全不进行假定，这依赖具体操作的语义。若需要和具体操作无关的无条件非共享假定，使用<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>而非作为左值的唯一引用。</p>
<p>　　和宿主语言的 <code>const</code> 限定类型类似，不可修改引用仅针对特定左值的访问；通过共享的其它未被限定的引用仍可修改对象。</p>
<p>　　违反不可修改引用引入的假定的错误可能通过<a href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>或其它方式引起。</p>
<p>　　临时对象引用类似 [ISO C++] 的<em>转发引用(forwarding reference)</em> 中保留在表达式声明中的类型信息。</p>
<p>　　因为 NPLA 不支持声明元数据，这些信息保存在对象的<a href="#%E8%A1%A8%E7%A4%BA">表示</a>中，且在初始化时被引用值保存；也因此<a href="#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">这些元数据可跟随一等对象传递</a>。对临时对象，<a href="#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">绑定操作</a>可确保<a href="#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">元数据被添加</a>。</p>
<p>　　这也和宿主语言不同。在宿主语言中：</p>
<ul>
<li>无论是标记消亡值的右值引用类型还是标记是否可转发的引用的转发引用推断的类型信息（左值引用或右值引用）都是静态的。</li>
<li>并且，转发的类型信息只在函数模板的局部有效，而不存在对应的跨过程传递机制。</li>
</ul>
<h4 id="引用值的消除"><a class="header" href="#引用值的消除">引用值的消除</a></h4>
<p>　　作为<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>，引用值可被<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">消除</a>，即被其<a href="#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">（可能多重）引用</a>关联的被引用对象替代。</p>
<p>　　<a href="#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">未折叠的引用值</a>消除一次引用值，结果仍是引用值。</p>
<p>　　消除<a href="#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">完全折叠的引用值</a>的结果总是<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">右值</a>。</p>
<p>　　推论：因为引用值不<a href="#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>自身，除非引用值<a href="#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">已完全折叠</a>，继续消除引用值得到的值和引用值是不同的值。</p>
<p><strong>原理</strong></p>
<p>　　特定的引用值消除可蕴含对不可修改的<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">传播</a>的要求。这和 [ISO C++] 初始化引用时遵循的 <code>const</code> 安全性，属于类型安全性的一种。</p>
<p>　　但是，消除引用不一定总是预期这种性质，特别当折叠不被预期时。</p>
<p>　　例如，[ISO C++] 内建指针的不同级 <code>const</code> 不会被隐式转换直接折叠合并。消除间接的指针值不是隐式的（而依赖内建一元 <code>*</code> 操作符），这是因为指针作为类型构造器自身的类型安全需要；是否消除 <code>const</code> 限定符仍然需要基于其它理由考虑。</p>
<p>　　而当被引用对象实现子对象时，修饰被指向的类型的 <code>const</code> 不会自动传播到子对象的类型中，此时可有 <code>std::experimental::propagate_const</code> 可选引入这种性质。</p>
<p>　　对具有非间接访问的子对象的类型，这相当于 [ISO C++] 的 <code>mutable</code> 修饰符，可实现<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">内部可变性</a>。而允许子对象以外直接不传播不可变性，是一种结构性的平凡的扩展：这允许把被引用对象直接视为一种子对象的实现，而非要求引入新的<a href="#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义类型</a>。</p>
<p>　　在 NPLA 这样没有要求显式类型编码是否可变的语言中，首先要求总是具有不可修改的传播性质会显著增加规则形式上的复杂性。若具体操作需要传播不可修改性，仍可进一步约定。</p>
<p><strong>注释</strong></p>
<p>　　典型地，消除引用值包括：</p>
<ul>
<li>当<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">引用值提升转换</a>的操作数是引用值时，消除被提升的引用值。</li>
<li>当<a href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">引用折叠</a>的操作数是引用值时，消除被折叠的引用值。</li>
</ul>
<p>　　和引用折叠不同，引用值提升转换不满足对不可修改引用属性的传播性质。</p>
<h4 id="引用折叠"><a class="header" href="#引用折叠">引用折叠</a></h4>
<p>　　和 [ISO C++] 类似，引用值在 NPLA 中默认不被继续引用，使用引用初始化引用会引用到<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>上，即<em>引用折叠(reference collapse)</em> 。</p>
<p>　　引用值被折叠后结果和原引用值不同，当且仅当原引用值是<a href="#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">未折叠的引用值</a>。</p>
<p>　　和 [ISO C++] 不同，NPLA 不限制派生实现利用未折叠的引用值。</p>
<p><strong>注释</strong> 特定的操作可能区分未折叠的引用值。</p>
<p>　　引用折叠的结果是不可修改引用，若引用值和作为引用值的被引用对象之一是不可修改引用。</p>
<p>　　引用折叠的结果满足不可修改<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用属性的传播性质</a>。推论：</p>
<ul>
<li>引用折叠的结果是<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">唯一引用</a>，当且仅当引用值和作为引用值的被引用对象都是唯一引用。</li>
<li>引用折叠的结果是<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">临时对象引用</a>，当且仅当被引用对象是临时对象引用。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　内部表示可支持间接的引用，以允许在对象语言中实现<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">一等引用</a>。</p>
<p>　　引用折叠对不可修改的传播性质的要求和 [ISO C++] 的引用折叠对 <code>const</code> 限定符的处理类似。</p>
<p>　　引用折叠对唯一引用的要求和 [ISO C++] 的右值引用仅通过被折叠的引用都是右值引用类型折叠类似。注意 [ISO C++] 右值引用推断仅用于推断转发引用(forwarding reference) 参数，而非直接声明特定的右值引用类型。</p>
<p>　　和唯一引用不同，临时对象相对唯一引用更接近 [ISO C++] 的声明的右值引用类型信息（而非推断值类别时使用的消亡值表达式的右值引用类型），一般不预期被折叠。</p>
<p><strong>注释</strong></p>
<p>　　未折叠的引用值被折叠时，用于初始化的被引用对象可能仍然是未折叠的引用值。</p>
<h4 id="对象的可转移条件"><a class="header" href="#对象的可转移条件">对象的可转移条件</a></h4>
<p>　　根据项是否具有特定元数据的引用值可判断使用复制代替<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">对象转移的条件</a>。</p>
<p>　　对象的<em>可转移(movable)</em> 条件的判断基于首先基于<a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B">值的类型</a>：</p>
<ul>
<li>非引用值（纯右值）总是可转移的。</li>
<li>否则，对象是引用值。可转移由<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用值的属性</a>决定：当引用值是唯一引用且非不可修改，引用值是可转移引用，对应的被引用对象是可转移的。</li>
</ul>
<h4 id="引用值的表示"><a class="header" href="#引用值的表示">引用值的表示</a></h4>
<p>　　作为引用值的<a href="#%E8%A1%A8%E7%A4%BA">表示</a>，<em>引用项(reference term)</em> 是包含<a href="#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">项引用</a>的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>。</p>
<p>　　引用项中的项引用对象引用一个（其它的）项，即<em>被引用项(referenced term)</em> ，用于在必要时引入可被引用的一个项而不在 TermNode 中直接储存这个项的值。</p>
<p>　　被引用项表示引用项作为引用值对应的<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>。</p>
<p>　　引用项在作为<a href="#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象</a>外，<a href="#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">保存标签</a>作为<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用值的属性</a>的<a href="#%E8%A1%A8%E7%A4%BA">表示</a>。</p>
<p>　　<a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>可作为引用值的被引用对象。</p>
<p>　　与此不同，非临时对象的引用值可作为一等对象而总是需要区分作为不同对象的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>。</p>
<p>　　带有<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">临时对象属性</a>的引用值可在特定的操作中被视为和临时对象引用近似的引用值。</p>
<p>　　子对象引用的表示是<em>子对象引用项(subojbect reference term)</em> ，和本节中的其它引用类型的表示兼容，但不完全相同。</p>
<p>　　关于引用项的构成，另见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　因为<a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象不是一等对象</a>，临时对象的引用值可代替关联的被引用对象使之作为一等对象被访问。</p>
<p>　　为在对象语言中区分引用值和非引用值的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>是必要的，引用项这样的特设表示是必要的。</p>
<p>　　非引用项的表示则是针对临时对象的一种优化，因为使<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>总是在作为引用值的表示而：</p>
<ul>
<li>相比通常的间接值，避免间接<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>关联的<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的开销。</li>
<li>避免<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7">悬空引用</a>。</li>
</ul>
<p>　　带有临时对象属性的引用值和临时对象的引用值不同，参见<a href="#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">绑定临时对象属性</a>。</p>
<h4 id="引用值的子类型"><a class="header" href="#引用值的子类型">引用值的子类型</a></h4>
<p>　　根据表示和属性，引用类型具有如下<a href="#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>：</p>
<ul>
<li><em>左值引用(lvalue reference)</em> ：以引用项表示的非<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">唯一引用</a>。</li>
<li><em>右值引用(rvalue reference)</em> ：以引用项表示的唯一引用。</li>
</ul>
<p>　　引用值是否作为<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>使用取决于上下文。除非另行指定，引用值都是左值。</p>
<p><strong>注释</strong> 在要求右值的上下文发生<a href="#%E9%BB%98%E8%AE%A4%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2%E7%BA%A6%E5%AE%9A">左值到右值转换</a>。</p>
<p>　　引入不同的引用子类型后，NPLA 一等对象的值的类型和<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">值类别</a>存在以下一一对应关系：</p>
<ul>
<li>若类型是左值引用，则对应的值类别是左值。</li>
<li>若类型是右值引用，则对应的值类别是消亡值。</li>
<li>否则，对应的值类别是右值。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　左值引用和左值引用与宿主语言中的对象类型的左值引用与右值引用分别类似。</p>
<p><strong>注释</strong></p>
<p>　　在要求右值的上下文，作为左值的引用值发生<a href="#%E9%BB%98%E8%AE%A4%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2%E7%BA%A6%E5%AE%9A">左值到右值转换</a>。</p>
<h4 id="不安全引用值"><a class="header" href="#不安全引用值">不安全引用值</a></h4>
<p>　　特定的引用值是<em>不安全引用值(unsafe reference value)</em> ，可能和常规的其它引用值具有不同的内部表示。</p>
<p>　　若实现支持不安全引用值，和其它引用值的行为不同由实现定义。</p>
<p>　　派生实现可能添加更多对不安全引用值的假设。</p>
<p><strong>原理</strong></p>
<p>　　不安全引用值可能放弃常规的引用具有元数据而能被更高效地访问。</p>
<h3 id="值类别转换"><a class="header" href="#值类别转换">值类别转换</a></h3>
<p>　　具有特定值类别的表达式可转换为不同值类别的表达式：</p>
<ul>
<li>除非另行指定，泛左值总是允许作为纯右值使用。从泛左值取对应右值的操作称为<em>左值到右值转换(lvalue-to-rvalue conversion)</em> 。</li>
<li>从纯右值<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a>可被对象语言作为<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>使用的<a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的引用值作为<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">消亡值</a>，称为<em>临时对象实质化转换(temporary materialization conversion)</em> 。</li>
</ul>
<p>　　左值到右值转换没有<a href="#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">副作用</a>。临时对象实质化转换没有副作用，当且仅当其中初始化临时对象时没有副作用。</p>
<p>　　临时对象实质化转换中，纯右值被<em>实质化(materialized)</em> 。</p>
<p>　　在求值子表达式时，按表达式具有的语义，必要时（如按<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%80%BC%E7%B1%BB%E5%88%AB">相关规则</a>判断上下文的值类别）进行值类别转换。</p>
<p>　　NPLA 还提供可能使结果具有不同的值类别的<em>引用值提升转换(reference value lifting conversion)</em> 。以下规则确定引用值提升转换的结果：</p>
<ul>
<li>若操作数是引用值，则结果是操作数的<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>。</li>
<li>否则，结果是操作数。</li>
</ul>
<p>　　引用值提升转换蕴含引用<a href="#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">提升</a>，即使用被引用对象替换操作数。</p>
<p><strong>原理</strong></p>
<p>　　为支持<a href="#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>作为一等对象（特别是<a href="#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">未折叠的引用值</a>），NPLA 提供比左值到右值转换更精细的引用值提升转换。</p>
<p>　　值类别转换在特定求值中适用，因此不影响构造性的规则。</p>
<p>　　特别地，列表左值（列表的引用值）不能代替列表，因此以空列表的引用作为最后一个元素的嵌套有序对是<a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">非真列表</a>。这和 [R<sup>7</sup>RS] 约定空列表总是同一对象不同。</p>
<p>　　这种设计使语言规则更容易在局部一致，同时显著减少实现（对象内部表示）的复杂性，并有助于提升实现性能的可预测性。</p>
<p><strong>注释</strong></p>
<p>　　不同值类别表达式的转换和宿主语言中的部分标准转换类似。</p>
<p>　　根据引用值的性质，易知左值到右值转换的规约是引用值提升转换的规约的传递闭包，即：</p>
<ul>
<li>若操作数是<a href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">已完全折叠的引用值</a>，则引用值提升转换等价左值到右值转换。</li>
<li>否则，有限次的引用值提升转换等价左值到右值转换。</li>
</ul>
<p>　　引用值提升转换不<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">传播引用值的属性</a>，参见<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%B6%88%E9%99%A4">引用值的消除</a>。</p>
<p>　　引用值提升转换不传播不可修改属性，类似 [ISO C++] 非引用值的转换在结果中不保留源操作数中的 <code>const</code> 类型。</p>
<p>　　临时对象实质化可实现为空操作，因为项在先前（如<a href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>蕴含的<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">引用值提升转换</a>对<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E8%A1%A8%E7%A4%BA">引用项</a>的<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">提升操作</a>的实现中）已被创建。</p>
<p>　　互操作可能引入不以项表达的右值而需要首先创建项。</p>
<h4 id="默认值类别转换约定"><a class="header" href="#默认值类别转换约定">默认值类别转换约定</a></h4>
<p>　　除非另行指定：</p>
<ul>
<li>作为<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作符</a>的<a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>没有值类别转换。</li>
<li>作为<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>的表达式仅在必要时进行一次左值到右值转换。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　类似宿主语言规则，并非所有上下文都需要转换。类似地，宿主语言的操作符（括<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>的第一个子表达式）可直接使用左值而不需要转换。但和宿主语言不同，因为<a href="#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">多重引用</a>，不确定次数的连续的转换结果不同。因此除了上下文要求，有必要约定默认仅转换一次，而非确保转换结果到右值。</p>
<p>　　必要时，具体<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作</a>仍可指定不同的规则。</p>
<p>　　值类别和左值到右值转换在一些上下文的行为类似箱和自动拆箱，约定存在默认转换并不利于维护<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>：</p>
<ul>
<li>特别地，和宿主语言不同，函数不包含充分的信息（参数类型）推断是否接受左值操作数，因此在不提供针对函数的<em>重载(overloading)</em> 一般机制的前提下，<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>不能预知输入的操作数是否是左值，通常需分别支持左值和右值的操作数。</li>
<li>即便提供重载，仍然较单一的值类别更复杂。</li>
</ul>
<p>　　但 NPLA 的设计中，值类别转换已被通过<a href="#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确</a>反映需求的<a href="#%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">存储和对象模型</a>的设计隐含在项的内部性质中，因此不是可选的。</p>
<p>　　由<a href="#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性的优先规则</a>，<a href="#%E5%AE%8C%E6%95%B4%E6%80%A7">完整性</a>应先于简单性被满足。</p>
<p>　　而考虑<a href="#%E7%BB%9F%E4%B8%80%E6%80%A7">统一性</a>，对存储和对象模型的设计，用户自行的实现仍要求这些设施（尽管更困难）。</p>
<p>　　关于箱和自动装箱，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h4 id="返回值转换"><a class="header" href="#返回值转换">返回值转换</a></h4>
<p>　　<em>返回值转换(return value conversion)</em> 是一次引用值提升转换和可选的一次临时对象实质化转换的顺序复合。</p>
<p>　　返回值转换用于在对象语言中确定函数调用的<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>可包含<a href="#%E5%87%BD%E6%95%B0">函数体</a>的求值结果到返回值的转换。</p>
<p>　　引用值作为间接值，适用<a href="#%E5%B1%80%E9%83%A8%E9%97%B4%E6%8E%A5%E5%80%BC%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">局部间接值安全保证</a>。在<a href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87">返回值转换上下文</a>中确定函数返回值的<a href="#%E5%AE%9E%E8%B4%A8%E5%8C%96%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87">实质化转换上下文</a>的部分操作<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%B6%88%E9%99%A4">消除引用值</a>，即返回值转换，是这种情形的主要实例。</p>
<p>　　这可约束作为间接值的<a href="#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">完全折叠的引用值</a>不<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">逃逸</a>（因此<a href="#%E5%B1%80%E9%83%A8%E9%97%B4%E6%8E%A5%E5%80%BC%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">访问被引用对象的值可不超出指向对象的存储期</a>），而保证只考虑项可能是引用值时的内存安全。</p>
<p>　　除非证明不需要<a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>，返回值转换中初始化临时对象作为返回值的<a href="#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象</a>，否则临时对象被<a href="#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4">复制消除</a>。是否存在复制消除是未指定行为。</p>
<p>　　不论是否存在返回值转换，返回值的项对象来自返回的<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">右值</a>关联的<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">临时对象实质化转换</a>。这可能在返回值转换蕴含的<a href="#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">项提升</a>操作或之前的<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值规约</a>中蕴含。</p>
<p><strong>注释</strong></p>
<p>　　返回值转换不保证<a href="#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">未折叠的引用值</a>在消除引用值后的结果不逃逸。</p>
<p>　　为确保内存安全，程序仍需要保证被引用的对象的间接引用的对象生存期结束后，不能访问间接引用的对象。</p>
<p>　　其它间接值的内存安全需要另行保证。</p>
<p>　　是否需要返回值转换由实质化转换上下文中的被调用的函数而非上下文是否需要使用右值决定，无关被转换的表达式是否是左值，因此返回值转换不是<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">左值到右值转换</a>。</p>
<p>　　当前未实现是否需要临时对象的证明。</p>
<p>　　另见<a href="#%E9%A1%B9%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象和关联对象所有权</a>和<a href="#%E5%B1%80%E9%83%A8%E9%97%B4%E6%8E%A5%E5%80%BC%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">局部间接值安全保证</a>。</p>
<h3 id="临时对象"><a class="header" href="#临时对象">临时对象</a></h3>
<p>　　特定的 <a href="#npla-%E5%9F%BA%E7%A1%80%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">NPLA 非一等对象</a>是<em>临时对象(temporary object)</em> 。</p>
<p>　　NPLA 允许（但不要求对象语言支持）一等对象构成的表达式通过特定的求值，在中间结果中蕴含这种非一等对象。</p>
<p><strong>注释</strong> 这样的非一等对象不在源语言中可见，一般仅用于<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>。</p>
<p>　　临时对象的<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>不是临时对象。</p>
<p>　　NPLA 对象语言在特定的上下文引入其它临时对象，包括：</p>
<ul>
<li><a href="#%E5%AE%9E%E8%B4%A8%E5%8C%96%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87">实质化转换上下文</a>。</li>
<li><a href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87">返回值转换上下文</a>。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　为简化规约和互操作机制的设计，和 [ISO C++17] 不同，引入临时对象不包括延迟初始化或异常对象的创建。</p>
<p>　　关于临时对象的子对象的规则，参见<a href="#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">绑定临时对象</a>中的原理。</p>
<p><strong>注释</strong></p>
<p>　　关于临时对象的存储和所有权，参见<a href="#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">求值和对象所有权</a>。</p>
<p>　　关于临时对象的表示，参见<a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%A8%E7%A4%BA">临时对象的表示</a>。</p>
<p>　　关于避免特定相关对象的<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a>的要求，参见<a href="#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4">复制消除</a>。</p>
<p>　　引入临时对象的一些上下文的和宿主语言类似。</p>
<h4 id="实质化转换上下文"><a class="header" href="#实质化转换上下文">实质化转换上下文</a></h4>
<p>　　可具有（但不保证具有）<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">临时对象实质化转换</a>的上下文包括：</p>
<ul>
<li>使用纯右值初始化被绑定为<a href="#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>的变量（如函数的引用类型的<a href="#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">形式参数</a>）。</li>
<li>求值<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>以初始化<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　一般地，被绑定为引用值的变量在<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">活动调用</a>关联的环境分配临时对象。此时，对象被调用表达式的项独占所有权，同时被绑定的环境独占资源所有权，并实现<a href="#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4">复制消除</a>。</p>
<p>　　在不具有转换时，优化的实现可能消除函数调用（内联(inline) 展开）而不分配关联的环境，把临时对象分配到其它环境或者语言不保证可见的存储（如 CPU 寄存器）中，并同时实现复制消除。</p>
<p>　　临时对象实质化转换引入临时对象的规则和 [ISO C++17] 不同：</p>
<ul>
<li>不论表达式是否作为子表达式使其值被使用（未使用的情形对应 [ISO C++] 中的 discarded-value expression ），都允许存在临时对象。</li>
<li>要求复制消除而避免特定对象的<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a>。</li>
</ul>
<h4 id="返回值转换上下文"><a class="header" href="#返回值转换上下文">返回值转换上下文</a></h4>
<p>　　<a href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>可引入实质化的临时对象，其中<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%AF%E8%BD%AC%E7%A7%BB%E6%9D%A1%E4%BB%B6">可能转移求值</a>的中间结果；否则，对象被复制。</p>
<p>　　此处被转移对象符合<a href="#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">求值和对象所有权</a>规则中的临时对象的定义，但除非另行指定，被转移的对象不在对象语言中可被访问。</p>
<p>　　仅在对象被复制且复制具有副作用时，返回值转换具有等价复制的副作用。</p>
<h4 id="复制消除"><a class="header" href="#复制消除">复制消除</a></h4>
<p>　　NPLA 要求特定上下文中的<em>复制消除(copy elision)</em> ，排除复制或转移操作且保证被消除操作的源和目的对象的<a href="#%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">同一性</a>。</p>
<p>　　复制消除仅在以下转换上下文中被要求，即直接使用被转换的源表达式中的对象作为实质化的对象而不初始化新的临时对象：</p>
<ul>
<li><a href="#%E5%AE%9E%E8%B4%A8%E5%8C%96%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87">实质化转换上下文</a>。</li>
<li>引起对象转移至<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>的<a href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87">返回值转换上下文</a>。</li>
</ul>
<p>　　非<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>函数的函数体内指定的返回值不属于上述的确定返回值的上下文，但也不要求被复制消除。</p>
<p>　　实现仍可根据<a href="#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>来判断是否在允许消除对象复制的上下文中，而进行复制消除。</p>
<p>　　复制消除不在被初始化对象以外引入新的对象语言可见的对象。</p>
<p><strong>原理</strong></p>
<p>　　为维护语言规则的<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>和使用这些规则的程序的行为的<a href="#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测性</a>，NPLA 的复制消除限于临时对象的消除。</p>
<p>　　在完成实质化转换前的不完整的<a href="#%E8%A7%84%E7%BA%A6%E8%A7%84%E5%88%99%E5%92%8C%E6%B1%82%E5%80%BC">求值规约</a>中的临时对象在逻辑上不需要作为<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>存在，但纯右值作为对象<a href="#%E8%A1%A8%E7%A4%BA">表示</a>中的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">子项</a>，随纯右值在宿主语言中作为对象存在，以允许互操作。</p>
<p>　　复制消除的目的 [ISO C++17] 类似。同时，提供语言支持也允许更简单地实现 C++ 互操作性。</p>
<p>　　和 [ISO C++17] 不同的一些要求可简化语言规则和实现，例如：</p>
<ul>
<li>不区分求值结果是否被作为<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>或求值是否为常量表达式。</li>
<li>非<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>函数的规则不要求 <code>return</code> 语句中的特定的表达式，而不需要依赖特定上下文的语法性质。</li>
<li>同时，NPLA 不限制对象的类型（[ISO C++17] 则要求特定的 C++ 类类型）。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　在实现中，被转换的源表达式中的对象是<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">待求值项</a>的<a href="#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象</a>。</p>
<p>　　当前未实现按当前环境判断是否在允许消除对象复制的上下文中进行复制消除。</p>
<h4 id="生存期扩展"><a class="header" href="#生存期扩展">生存期扩展</a></h4>
<p>　　在使用<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>初始化<a href="#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>时，<em>扩展(extend)</em> 源表达式的<a href="#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">项对象</a>的<a href="#%E7%94%9F%E5%AD%98%E6%9C%9F%E9%99%84%E5%8A%A0%E7%BA%A6%E5%AE%9A">生存期</a>使之比其它规则决定的生存期延长。</p>
<p>　　这和初始化非引用值类似，但实现需区分是否初始化的是延长生存期的临时对象，以确保之后能区分引用值初始化时是否<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按引用传递</a>。</p>
<h4 id="绑定临时对象属性"><a class="header" href="#绑定临时对象属性">绑定临时对象属性</a></h4>
<p>　　若<a href="#%E5%AE%9E%E8%B4%A8%E5%8C%96%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87">实质化转换上下文</a>支持<a href="#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">绑定临时对象</a>，按引用绑定（即绑定初始化使用<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按引用传递</a>）的<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>是<a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>。</p>
<p>　　引入引用值的形式参数需要满足的要求由引入绑定的操作或派生实现指定。</p>
<p><strong>原理</strong></p>
<p>　　绑定临时对象时指定临时对象属性允许区分<a href="#%E7%94%9F%E5%AD%98%E6%9C%9F%E6%89%A9%E5%B1%95">通过引用绑定延长生存期的临时对象</a>和非引用绑定的对象。</p>
<p>　　一般地，表达式中的<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>（非引用值）被绑定为临时对象，即被绑定的对象在初始化后具有<a href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">临时对象属性</a>。</p>
<p>　　这对应宿主语言中的转发引用参数（如 <code>std::forward</code> ）中的情形：</p>
<ul>
<li>若模板参数 <code>P</code> 对应转发引用函数参数 <code>P&amp;&amp;</code> ，其中 <code>P</code> 是对象或对象的右值引用类型，保留从实际参数<em>推导(deduce)</em> 得到的但不是实际参数类型的信息。</li>
<li>没有绑定临时对象属性的对象则同一般的非引用类型的对象类型参数（非转发引用）。</li>
</ul>
<p>　　<code>P</code> 在宿主语言中通过值类别推断，但不表示值类别。</p>
<p>　　类似宿主语言，这种操作数表达式的值类别以外的形式是一种<a href="#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">类型推断</a>。因为推断规则和宿主语言的<em>类型推导(type deducing)</em> 相似，这种上下文可支持类似宿主语言的参数转发。但和宿主语言的 <code>std::forward</code> 不同，此处推断的右值除了是<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">消亡值</a>外，也可以是<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>。</p>
<p>　　临时对象属性在绑定特定形式的参数时具有和 <code>P</code> 编码的附加信息类似的作用：</p>
<ul>
<li>不具有临时对象属性的引用值作为<a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>，在初始化临时对象的引用时被视为<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>（不影响其余属性）。</li>
<li>其它表达式的推断结果是右值。</li>
</ul>
<p>　　带有临时对象属性的引用值和临时对象的引用值不同。特别地，作为引用属性值的临时对象属性允许在<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">运行时</a>作为对象的元数据<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>以及跟随对象被跨过程传递，这无法被宿主语言支持，因为 <code>P</code> 表示的<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态类型</a>信息不在函数外可用，仅在模板的类型参数 <code>P</code> 中而不在运行时可访问的元数据中（事实上，也不在对象的动态类型中）保留。关于其应用，参见<a href="#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">进一步讨论</a>。</p>
<p><strong>注释</strong></p>
<p>　　因为宿主语言的引用折叠，以上 <code>P</code> 和 <code>P&amp;&amp;</code> 一致。</p>
<p>　　被绑定的这些对象可作为临时对象引用关联的<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>。</p>
<p>　　另见<a href="#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">绑定操作</a>。</p>
<h4 id="临时对象的表示"><a class="header" href="#临时对象的表示">临时对象的表示</a></h4>
<p>　　作为一等对象的临时对象和其它一等对象表示方式一致。</p>
<p>　　非一等对象临时对象包括：</p>
<ul>
<li>所有权可<a href="#%E9%A1%B9%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">被项独占</a>而不能作为一等对象访问的对象。</li>
<li>具有<a href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">临时对象标签</a>的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>作为内部表示的对象。</li>
</ul>
<p>　　对临时标签对象决定的非一等对象，去除临时对象标签后，应具有一等对象表示。</p>
<p>　　在<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E8%A1%A8%E7%A4%BA">项引用</a>以外的临时对象标签仅在<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>上存在。</p>
<p>　　关于一等对象表示，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　至少在逻辑上，临时对象作为对象语言中不可见的对象和一等对象相同的宿主类型（即项）作为内部表示。因此，区分其内部表示并非通过宿主语言中的类型，而需通过运行时性质确定。</p>
<p>　　一些表示可能仅出现在临时对象中，而不是合法的一等对象表示。实现可据此进行一定运行时检查，以排除<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>或者错误实现中的误用。</p>
<p>　　对临时对象标签决定的非一等对象和一等对象表现之间的要求简化实现的一些操作，使<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">实质化</a>不需依赖另行分配的资源。</p>
<p>　　临时对象的子对象不是临时对象，简化对临时对象的一些操作，也减少可能使临时对象标签扩散（到非预期的上下文影响一等对象表示）而误用。</p>
<p>　　关于被绑定对象的规则，参见<a href="#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">绑定临时对象</a>中的原理。限制标签的使用范围以使之不和其它表示冲突。</p>
<p>　　关于实现中项的<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>和简化实现的例子，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>注释</strong></p>
<p>　　直接构成项的非一等对象可以是通过<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源代码</a>中的<a href="#%E8%A1%A8%E7%A4%BA">外部表示</a>经<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">翻译</a>变换得到的具有内部表示的数据结构的非一等对象，参见上述实现中项的<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>。</p>
<h3 id="表达式的类型"><a class="header" href="#表达式的类型">表达式的类型</a></h3>
<p>　　NPLA 的<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">类型系统</a>使用<a href="#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">隐式类型</a>；默认使用<a href="#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">潜在类型</a>，保证<a href="#npla-%E6%95%B4%E4%BD%93%E7%BA%A6%E5%AE%9A">表达式的值具有类型</a>。</p>
<p>　　NPLA 表达式的<a href="#%E7%B1%BB%E5%9E%8B">类型</a>是表达式<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>的类型。</p>
<p>　　<a href="#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">空求值</a>的求值结果要求未求值的<a href="#%E7%BF%BB%E8%AF%91%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%A7%84%E5%88%99">合式的</a>表达式应具有和<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">语法分析</a>的实现的输出兼容的类型。</p>
<p>　　实现对特定的上下文的表达式可使用<a href="#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">类型推断</a>。由此确定的类型类似宿主语言的表达式的类型。</p>
<p>　　表达式具有<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">值类别</a>。值类别的指派规则作为<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">定型规则</a>是<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%80%BC%E7%B1%BB%E5%88%AB">类型系统的一部分</a>。但除非另行指定，值类别和 NPLA 及派生语言规则中描述的表达式的类型<a href="#%E6%AD%A3%E4%BA%A4%E6%80%A7">正交</a>。</p>
<p>　　关于语法分析的实现和其中处理的类型，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>注释</strong></p>
<p>　　类型系统和 Scheme 及 Kernel 语言类似；除了表达式具有值类别这点和 Scheme 和 Kernel 不同而类似宿主语言。</p>
<p>　　表达式的类型和 [R<sup>7</sup>RS] 的 expression type 无关，后者是<a href="#%E8%AF%AD%E6%B3%95%E5%BD%A2%E5%BC%8F">语法形式</a>的约定（在 [R<sup>5</sup>RS] 和 [R<sup>7</sup>RS] 中称为 form ）；因为存在<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>作为<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>的类型，不需要这种约定。</p>
<p>　　NPLA 中值类别和表达式的类型正交，这类似宿主语言。这简化了相关<a href="#%E7%B1%BB%E5%9E%8B">类型规则</a>的描述。</p>
<h2 id="生存期附加约定"><a class="header" href="#生存期附加约定">生存期附加约定</a></h2>
<p>　　和宿主语言不同，NPLA 子表达式的求值顺序可被不同的函数（特别允许显式指定对特定<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>求值的<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">操作子</a>）中的求值调整，不需要特别约定。</p>
<p>　　NPLA 不存在宿主语言意义上的<a href="#%E4%B8%A5%E6%A0%BC%E6%80%A7">完全表达式</a>，但在按宿主语言规则判断生存期时，使用<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>的<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">函数合并</a>视同宿主语言的完全表达式，其本机函数调用不引起函数内创建的对象的生存期被延长。</p>
<p>　　<a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的<a href="#npla-%E5%9F%BA%E7%A1%80%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">生存期</a>同时约束隐含的隐式宿主函数调用（如复制构造）。</p>
<p>　　为保证求值表达式取得的临时对象的<a href="#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>，函数合并同时满足以下规则：</p>
<ul>
<li><a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作符</a>和未被求值的操作数的直接或间接子表达式关联的对象以及求值操作数的子表达式引入的临时对象的生存期结束的作用应不<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">后序</a>于<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">活动调用</a>结束。</li>
<li>生存期起始和结束的顺序被确定(determined) 时，和对应所在的表达求值之间的<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序</a>关系同构；否则，其顺序满足<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">非决定性有序</a>关系。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　生存期的顺序约束确保引入临时对象时，其生存期不会任意地被<a href="#%E7%94%9F%E5%AD%98%E6%9C%9F%E6%89%A9%E5%B1%95">扩展</a>而超过<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>的求值。</p>
<p>　　具体操作可在以上约束下指定被求值的操作数可能引入的临时对象的生存期。</p>
<h2 id="尾上下文约定"><a class="header" href="#尾上下文约定">尾上下文约定</a></h2>
<p>　　NPLA 表达式<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值规约</a>中最后一个规约步骤中的上下文是<a href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">尾上下文</a>。</p>
<p>　　尾上下文在 NPLA 中可满足一些附加的性质。</p>
<h3 id="真尾规约"><a class="header" href="#真尾规约">真尾规约</a></h3>
<p>　　尾上下文涉及的存储在特定情况下满足调用消耗的空间有上界（即空间复杂度 <tt>O(1)</tt> ）。</p>
<p>　　满足这种情况下的规约称为<em>真尾规约(proper tail reduction)</em> 。</p>
<h3 id="尾调用和-ptc"><a class="header" href="#尾调用和-ptc">尾调用和 PTC</a></h3>
<p>　　在尾上下文规约的<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">调用</a>是<em>尾调用(tail call)</em> 。</p>
<p>　　以<a href="#%E7%9C%9F%E5%B0%BE%E8%A7%84%E7%BA%A6">真尾规约</a>的实现尾调用允许具有不限定数量的(unbounded) <a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">活动调用</a>，称为 PTC（proper tail call ，真尾调用）。</p>
<p>　　PTC 占用<a href="#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">活动记录</a>满足真尾规约的上界的要求。</p>
<p>　　当宿主语言提供函数调用支持 PTC 时，可直接使用宿主语言的 PTC 调用，否则，需要使用其它替代实现机制确保 PTC 。</p>
<p>　　非对象语言的调用的上下文中，若被调用时间接使用，也仍需要保证 PTC 。</p>
<p>　　PTC 确保仅有一个<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">活动</a>的调用。不满足 PTC 的情形下，语言没有提供用户访问非<a href="#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">活动记录帧</a>资源的手段，因此可以认为是资源泄漏。但为简化语义规则，NPLA <a href="#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">不要求避免相关的弱内存泄漏</a>。</p>
<p>　　NPLA 不添加保证活动记录帧中保存引用，销毁活动记录的帧可能影响环境中的变量生存期而改变语义。</p>
<p><strong>注释</strong> NPL 不保证一般对象存在<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>。</p>
<p>　　因此，除非依赖本节中以下的规则，NPLA 不保证提供 PTC 支持；实现更一般的 PTC 依赖派生实现定义的附加规则。</p>
<p>　　除非另行指定，NPLA 要求至少在被<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>中蕴含的<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数应用</a>的求值支持 PTC 。</p>
<p>　　为满足 PTC ，在<a href="#%E7%94%9F%E5%AD%98%E6%9C%9F%E9%99%84%E5%8A%A0%E7%BA%A6%E5%AE%9A">生存期附加约定</a>的基础上，尾上下文内可以确定并调整对象生存期结束时机：</p>
<ul>
<li>作为<a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>及其参数可以<a href="#%E7%94%9F%E5%AD%98%E6%9C%9F%E6%89%A9%E5%B1%95">延长生存期</a>至多到尾上下文结束。</li>
<li>被证明不再需要之后引用的对象，或未被绑定到活动记录上的项中的对象，可以缩短生存期。</li>
<li>被延长生存期的对象生存期起始和结束的相对顺序保持不变。</li>
<li>被缩短生存期的不同对象生存期结束的相对顺序保持不变。</li>
</ul>
<p>　　推论：被缩短生存期和延长生存期的对象的生存期结束的相对顺序保持不变。这由没有被调整生存期的对象与被调整生存期对象之间的生存期结束的<a href="#%E5%B0%BE%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BA%A6%E5%AE%9A">顺序关系</a>的传递性保证。</p>
<p>　　延长临时对象生存期和宿主语言中允许扩展非完全表达式内的临时对象的效果类似，但条件不同。</p>
<p><strong>原理</strong></p>
<p>　　要求 PTC 主要用例是支持 <a href="#ptr">PTR</a> 。相对 PTR ，PTC 更具有一般性，也适合对象语言<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>以外的普遍性质。</p>
<p><strong>注释</strong></p>
<p>　　以上规则中被调整生存期的对象一般仅是参数和函数体内创建的对象。因此，不保证理论上允许的尾上下文的都满足 PTC 。一个例子是合并子中可以保存<a href="#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">动态环境</a>，这个环境可能被递归的调用引用，而无法提前释放。</p>
<p>　　理论上 PTC 不要求延长生存期，仅要求特定情形下缩短生存期，且其它情形被释放的对象生存期不延长到尾上下文外。</p>
<p>　　允许延长生存期是<a href="#%E7%94%9F%E5%AD%98%E6%9C%9F%E9%99%84%E5%8A%A0%E7%BA%A6%E5%AE%9A">生存期附加约定</a>的结果。</p>
<h3 id="ptr"><a class="header" href="#ptr">PTR</a></h3>
<p>　　PTC 的活动记录性质也在一般的递归规约时体现，被称为 PTR（proper tail recursion ，真尾递归）。</p>
<p>　　和 PTC 不同，PTR 要求的递归规约不一定是对象语言中的调用，以 PTR 描述时仅强调递归，不考虑尾上下文的适用性。</p>
<p>　　通过特定的保持语义等价的变换，对象语言可要求尾上下文作用于函数调用以外的上下文中（例如非<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>的语法上下文）使用真尾规约实现。</p>
<p>　　除非派生实现另行指定，NPLA 对象语言不指定使函数调用以外的上下文作为尾上下文的要求；函数调用以外的尾上下文规约的仅可能用于实现的元语言中的<a href="#%E7%AE%A1%E7%90%86%E8%A7%84%E7%BA%A6">管理规约</a>；非管理规约的真尾规约都用于尾调用。</p>
<p>　　此时，PTR 等价被递归调用的 PTC 。但由于支持 PTC 在非递归规约情形时也影响语言实现的一般构造，所以描述要求时一般不以 PTR 代替 PTC 或真尾规约。</p>
<p>　　关于 PTR 在 Scheme 为基础的形式模型，参见 [Cl98] 。</p>
<p>　　PTR 的一个更激进的实现优化方式是 evlis tail recursion ，参见以下文献和参考资料：</p>
<ul>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.83.8567&amp;rep=rep1&amp;type=pdf">Continuation-Based Program Transformation Strategies</a></li>
<li>[Cl98]</li>
<li><a href="https://www.akalin.com/evlis-tail-recursion">Evlis tail recursion</a></li>
</ul>
<p>　　因为 NPLA 使用<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">链接的环境</a>，不支持实现其中更激进的 safe-for-space 保证。</p>
<p><strong>原理</strong></p>
<p>　　支持 PTR 使<a href="#%E8%BF%87%E7%A8%8B">重入</a>的函数调用保持较小的空间开销。这允许使用递归的函数调用代替尾上下文中特设的<em>循环(loop)</em> 和迭代语法实现等效的算法功能，满足<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>和<a href="#%E5%85%B6%E5%AE%83%E6%8E%A8%E8%AE%BA%E5%92%8C%E6%AF%94%E8%BE%83">通用性</a>。</p>
<p>　　与<a href="#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">控制状态和支持一等状态的实现之间具有的偶然耦合</a>不同，使用支持 PTR 的递归函数调用代替循环的耦合可以是足够必要的：它排除了特设的循环语法的需要，同时也能满足实现自身的<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>，也因此可能更高效。</p>
<p>　　为支持<a href="#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">一等对象</a>，可被共享的环境一般不支持<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">平坦的表示</a>。</p>
<p>　　不具有 safe-for-space 保证时，实现对程序的闭包变换(closure conversion) 可能创建多余的<a href="#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>且无法被运行时有效地分辨，而造成<a href="#%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F">资源泄漏</a>。通过明确支持这类保证的变换（如<a href="http://flint.cs.yale.edu/flint/publications/escc.pdf">这里描述的设计</a> ）可避免变换引起资源泄漏。</p>
<p>　　只要捕获自由变量的<a href="#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">静态环境</a>可被程序在创建函数时明确指定，safe-for-space 保证就不是必须的：避免在<a href="#%E7%94%9F%E5%AD%98%E6%9C%9F%E6%89%A9%E5%B1%95">语义规则约定</a>之外的生存期延长和资源泄漏是<a href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>的责任；NPLA 程序可精确控制对象生存期，同时应当避免<a href="#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">循环引用</a>。</p>
<p>　　对 safe-for-space 保证的证明（如 [Cl98] 和 <a href="https://zoep.github.io/icfp2019.pdf">Closure Conversion Is Safe for Space</a> ），隐含要求和上述一等对象支持冲突的条件：环境中引用的对象总是可被复制的没有可观察行为的值。这实质上要求支持<a href="#%E5%85%B1%E4%BA%AB%E5%BC%95%E7%94%A8">共享引用</a>乃至可能要求一等对象都是<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>。</p>
<p>　　因为使用链接的环境的要求，一般情形<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">不支持</a>对 safe-for-space 的变换。</p>
<p>　　即便允许类似的变换，这也仅保证不存在<a href="#%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F">不可达</a>，仍然不保证资源被及时回收——<a href="#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">全局机制</a>可能具有不确定的延迟而造成的实时资源泄漏。</p>
<h3 id="tco"><a class="header" href="#tco">TCO</a></h3>
<p>　　TCO（Tail Call Optimization ，尾调用优化）是在以尾上下文规约时，允许减少修改规约状态的优化。</p>
<p>　　一般地，TCO 可重新排列规约过程中的被语义允许调整的副作用和其它不影响可观察行为的<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">状态</a>的调用，减小空间开销。</p>
<p>　　TCO 的这种性质可以在宿主语言不支持 <a href="#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C-ptc">PTC</a> 时用于实现<a href="#%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%AB%8B">对象语言的 PTC</a> 。</p>
<p><strong>注释</strong></p>
<p>　　关于 TCO 和 PTC 的差异，另见<a href="https://groups.google.com/d/msg/comp.lang.lisp/AezzhxTliME/2Zsq7HUn_ssJ">这里</a>。</p>
<h4 id="宿主语言中立"><a class="header" href="#宿主语言中立">宿主语言中立</a></h4>
<p>　　C++ 不要求实现支持 PTC ，也不保证支持 TCO 。因此，对象语言的 PTC 要求显式的 TCO 实现。</p>
<p>　　为可移植地支持 TCO ，NPLA 不依赖宿主语言中不可移植的<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>的活动记录（通常是体系结构相关的栈）。</p>
<p><strong>注释</strong></p>
<p>　　尾调用可避免尾上下文中非<a href="#%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8%E5%AE%89%E5%85%A8">嵌套调用安全</a>的情形的<a href="#%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8%E5%AE%89%E5%85%A8">宿主语言实现的未定义行为</a>，但不保证非尾上下文中具有类似的性质。</p>
<h4 id="tco-实现策略概述"><a class="header" href="#tco-实现策略概述">TCO 实现策略概述</a></h4>
<p>　　TCO 包括以下形式：</p>
<ul>
<li>静态 TCO ：实现时替换宿主语言中不保证满足 PTC 的构造为满足 PTC 的构造。</li>
<li>动态 TCO ：运行时调整直接或间接表示对象语言构造的数据结构和状态，使状态占用的空间复杂度满足 PTC 要求。</li>
</ul>
<p>　　静态 TCO 也适合非对象语言的调用的<a href="#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C-ptc">上下文</a>。</p>
<p>　　不依赖宿主语言特性的静态 TCO 包括以下形式：</p>
<ul>
<li>替换宿主语言实现中的不保证满足 PTC 的递归调用为满足 PTC 的结构（如循环结构），包括直接编码和自动的变换(transformation) ，称为宿主(host) TCO 。</li>
<li>替换不满足 PTC 的对象语言原语为满足 PTC 的表达形式，称为目标(target) TCO 。</li>
</ul>
<p>　　不依赖宿主语言特性的动态 TCO 包括以下形式：</p>
<ul>
<li>通过合并不同<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">活动调用</a>中活动记录占用的冗余状态，减少宿主语言的活动调用同时占用的总空间，称为 TCM（Tail Call Merging ，尾调用合并）。</li>
<li>引入具有便于操作<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制作用</a>的构造，同时作为一些其它优化的基础，以消除部分活动记录状态的分配，称为 TCE（Tail Call Elimination ，尾调用消除）。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　本节的内容不影响对象语言的语义，但可能影响<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>的接口兼容性和实现质量。</p>
<p>　　关于对实现的具体影响，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h2 id="npla-数学功能"><a class="header" href="#npla-数学功能">NPLA 数学功能</a></h2>
<p>　　NPLA 数学功能（模块 NPLAMath ）提供数学功能和相关支持。</p>
<p>　　关于 NPLA 数学功能的规格说明的其它部分，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h3 id="数值类型"><a class="header" href="#数值类型">数值类型</a></h3>
<p>　　<a href="#%E9%99%84%E5%8A%A0%E5%8A%9F%E8%83%BD">NPLA 数值</a>是 NPLA 对数学意义上的<em>数(number)</em> 的建模。</p>
<p>　　被建模的数是 NPLA 数值的<em>真值(true value)</em> 。</p>
<p>　　NPLA 数值的集合到真值的集合的映射是满射；除此之外，也存在不被 NPLA 数值建模的数，这些数可能被 NPLAMath 未来的版本支持作为真值。</p>
<p>　　除非另行指定，NPLA 数值的行为由对应的真值的数学含义决定。</p>
<p>　　基于宿主语言的类型系统，NPLA 支持以下按数值范围从小到大排列的本机整数和浮点数作为<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>：</p>
<ul>
<li><code>signed char</code></li>
<li><code>unsigned char</code></li>
<li><code>signed short</code></li>
<li><code>unsigned short</code></li>
<li><code>int</code></li>
<li><code>unsigned</code></li>
<li><code>long</code></li>
<li><code>unsigned long</code></li>
<li><code>long long</code></li>
<li><code>unsigned long long</code></li>
<li><code>float</code></li>
<li><code>double</code></li>
<li><code>long double</code></li>
</ul>
<p>　　文法表示：</p>
<p>　　支持的数值类型以 <code>&lt;number&gt;</code> 表示，具有以下表示数值的<a href="#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>：</p>
<ul>
<li><code>&lt;complex&gt;</code> ：复数。</li>
<li><code>&lt;real&gt;</code> ：实数。</li>
<li><code>&lt;rational&gt;</code> ：有理数。</li>
<li><code>&lt;integer&gt;</code> ：整数。</li>
</ul>
<p>　　其子类型由数学定义蕴含，即以上类型中，后者依次是前者的子类型。</p>
<p>　　当前所有数值都是 <code>&lt;real&gt;</code> ，因此暂时没有针对 <code>&lt;number&gt;</code> 值是否属于 <code>&lt;real&gt;</code> 和 <code>&lt;complex&gt;</code> 的类型检查。</p>
<p>　　和数学意义上的实数不同，<code>&lt;real&gt;</code> 也包含以下可带符号(sign) 的<em>特殊值(special value)</em> ：</p>
<ul>
<li>无限大值。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/NaN">NaN(not a number)</a> 值。</li>
</ul>
<p>　　对应地，<code>&lt;complex&gt;</code> 也包含实部和/或虚部是上述特殊值的特殊值。</p>
<p><strong>注释</strong> 当前所有复数都是实数，因此虚部总是 0 。</p>
<p>　　根据数值是否完全保留真值在数学上的唯一性即<em>精确性(exactness)</em> ，数值分为<em>精确数(exact number)</em> 和<em>不精确数(inexact number)</em> 。</p>
<p>　　精确数和对应的真值总是相等；不精确数和真值不严格相等。</p>
<p>　　有限的不精确数的偏离程度可通过实数描述，即（绝对）<em>误差(error)</em> 。精确数的误差恒等于 0 。</p>
<p>　　除非另行指定，特定不精确数的具体的误差是未指定的。</p>
<p>　　数值的绝对<em>精度(precision)</em> 是其内部表示蕴含的误差的上界的倒数。对确定使用进位制的表示，精度也指精确表示的数值位数。</p>
<p>　　数值的<em>任意精度(arbitrary precision)</em> 指除<a href="#%E8%B5%84%E6%BA%90%E5%8F%AF%E7%94%A8%E6%80%A7%E5%9F%BA%E6%9C%AC%E7%BA%A6%E5%AE%9A">实现环境的可用资源（一般即存储空间）限制</a>外，不限制精度。</p>
<p><strong>注释</strong> 为支持更多数学上有意义的真值，未来可能引入其它类型来表示任意精度的整数、有理数及数学意义上的扩展（如复数和四元数）。</p>
<p>　　数值的内部表示中能以实数描述的度量应至少具有整数数量级精度，即误差不大于 1 。</p>
<p>　　精确数和不精确数在数值上可能相等，而<a href="#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">类型不同</a>。</p>
<p>　　宿主类型中的本机整数和浮点类型是数值类型的子类型，分别称为 fixnum 和 flonum 。这些类型在项的内部表示预期直接占据本机存储而不需要动态分配。</p>
<p>　　Fixnum 总是精确数；flonum 总是不精确数。</p>
<p><strong>注释</strong> 当前实现中，所有数值是 fixnum 或 flonum 之一。两者分别是宿主的整数类型（排除字符和 <code>bool</code> 类型）以及浮点数类型。</p>
<p>　　Flonum 支持带符号的无限大值以及 NaN 值作为特殊值。其它值都是有限值。特殊值可能具有不唯一的内部表示，但和有限值的表示都不同。</p>
<p>　　Flonum 中可存在小的非零数，可能和其它数值不同的内部表示而更容易在计算中损失精度，即非规格化(denormalized) 数值。</p>
<p>　　整数值的数值具有整数类型。这包括所有的 fixnum ，以及 flonum 中是整数的数值。这不和宿主类型直接对应。</p>
<p><strong>注释</strong> 一个 flonum 是整数，当且仅当它的值取整后结果和原值相等。这里的取整使用可使用任意的舍入。[R<sup>7</sup>RS] 对不精确数有类似的定义（仅使用 round ）。</p>
<p>　　对 fixnum ，<code>+0</code> 和 <code>-0</code> 是相等的数值。Flonum 不同符号的零值在值的表示中可以不同，但在数学意义上相等，表示同一个数。实现中的其它和具体表示无关的<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">等价谓词</a>是否表现这种不同是未指定的。</p>
<p><strong>注释</strong></p>
<p>　　NPLA 的不同的<a href="#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义</a>数值类型的集合到宿主类型的集合的<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">类型映射</a>是满射，即本节指定的宿主类型总是关联至少一个能表示它的值的 NPLA 数值类型。</p>
<p>　　同时，NPLA 数值类型可以映射到其它类型，特别地，NPLA 整数的类型映射目标是宿主语言整数类型和包含整数值的非典型<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>的并。所以，NPLA 数值整体的类型映射不构成简单的一对多或多对多关系。</p>
<p>　　特殊值同 ISO/IEC 10967–1 (LIA–1) 定义，引用 [IEC 60559] (IEEE-754) 的具体值，仅适用于浮点数。</p>
<p>　　无限大值在数学上属于<em>超实数(hyperreal number)</em> ，在浮点数实现中属于<em>扩展实数(extended real number)</em> 。</p>
<p>　　无限大值的符号在数学意义上是必要的，因此也被要求区分。</p>
<p>　　精确性、fixnum 和 flonum 等区分同 [R<sup>6</sup>RS] ，但具体实现要求不尽相同。</p>
<p>　　NaN 不是数学意义上的数，表示特定的没有数学定义的计算结果。NaN 和任何数值比较总是不相等。</p>
<p>　　NPLA 的宿主语言支持的 NaN 值带有符号。不是所有实现都区分符号，如 [ECMAScript] 。</p>
<p>　　整数精度外的数量级精度仅在确定使用的进位制底数时和绝对精度可比较，因此常用于描述特定实现的内部表示（例如，[ISO C] 定义的浮点数精度即有效数字的位数）。但是，不比较具体大小时，有限的数量级精度和绝对精度性质可以一致，这种上下文可不区分两者。</p>
<p>　　大多数不精确数的浮点表示的高效实现使用底数 2 。</p>
<p>　　参照 [IEC 60559] ，浮点格式的无限大值和有限数值是浮点数；NaN 不是浮点数。两者统称为<em>浮点数据(floating-point datum)</em> 。</p>
<p>　　宿主类型中实现为 [IEC 60559] 的<em>非规格化(denormalized)</em> 浮点数是具有不唯一的内部表示的小的非零数值。使用 IEEE-754 2008 以来的定义，这些数是<em>非规格(subnormal)</em> 数。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，本文档没有指定可选的模块，也没有指定精确的 ±∞ 值。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，不精确数不指定边界和<em>主值(primary value)</em> ，NaN 值被显式提供而不是唯一的 <code>#undefined</code> 值，非规格数不作为 <code>#undefined</code> 。这同时不要求在任意的操作中检查 <code>#undefined</code> 值并<a href="#%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　尽管容易损失精度，区分不同的非规格数的数值仍然有意义。同时，也避免和 NaN 用以表示数学上未定义操作的结果（如 0 除以 0 ）引起混淆。</p>
<p>　　数值相等和一般对象相等可使用不同的等价谓词。和一般对象比较不同，数值相等比较可对参数要求数值类型，否则引起错误。两者比较结果可能也不总是相同。如 Scheme 的 <code>=</code> 和 <code>eqv?</code> 以及 Kernel 的 <code>=?</code> 和 <code>equal?</code> 。</p>
<h3 id="数值操作约定"><a class="header" href="#数值操作约定">数值操作约定</a></h3>
<p>　　在对象语言中，数值操作是可使用数值作为算法输入的值的操作。NPLA1 提供本机 API 支持这些操作的实现。</p>
<p>　　数值操作数和非数值操作数分别是具有和不具有数值类型的操作数。</p>
<p>　　数值操作蕴含对应的数值计算，接受至少一个数值或非数值操作数，预期得到<a href="#%E8%BF%87%E7%A8%8B">计算结果</a>。</p>
<p><strong>注释</strong> 非预期情形可<a href="#%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　其中，计算结果依赖影响计算结果的操作数，并依赖至少一个数值操作数。</p>
<p>　　除非另行指定：</p>
<ul>
<li>在数学上有意义的前提下，数值操作同时支持以上尽可能多的数值类型的操作数。</li>
<li>数值操作对预期的数值操作数进行<a href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>，失败时出错。</li>
<li>数值操作不区分数值操作数中对应的真值相等的精确数或不精确数。</li>
<li>可假定数值操作数和计算过程中不出现 <a href="https://en.wikipedia.org/wiki/NaN#Signaling_NaN">SNaN(signaling NaN) (en-US)</a> 值。</li>
<li>若作为操作数的精确数决定计算结果在数学上未定义，则引起错误。</li>
<li>不精确数计算中的舍入方式未指定。</li>
<li>若计算结果是数值，则：
<ul>
<li>若被计算结果依赖的任一操作数中具有 NaN 值，则依赖这个操作数的数值操作结果也是 NaN 值。</li>
<li>输出的类型的值域能表示操作结果；除操作的语义和本节的其它规则蕴含外，具体类型未指定。</li>
<li>若作为操作数的精确数决定的计算结果是不精确数表示的有限数值，则这个不精确数应是所有相同内部表示的数值中和结果的真值误差最小的数值。</li>
<li>对数学上封闭的计算，结果具有不超过所有数值操作数范围的数值类型。</li>
<li>除非不能在结果类型中表示计算结果的范围：
<ul>
<li>若数值操作的所有数值操作数都是精确数，结果不是不精确数。</li>
<li>数值操作的实现不损失按数学定义得到的中间结果的<a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">精度</a>；结果的<a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">误差</a>仅来自其依赖的数值操作数引入的累积误差。</li>
</ul>
</li>
<li>若计算结果是不精确数，则：
<ul>
<li>若计算结果是小于最小可唯一表示的 <code>&lt;real&gt;</code> 值，则对应的数值操作结果是不精确数 0 。</li>
<li>计算结果中真值等于 0 的数值以及 NaN 值的符号是未指定的。</li>
<li>若计算结果中无限大数值不能通过数学上有意义的方式确定符号，则对应的数值操作结果是无限大值或 NaN 之一，具体选择未指定。</li>
</ul>
</li>
<li>数值的宿主类型未指定。</li>
</ul>
</li>
</ul>
<p><strong>原理</strong></p>
<p>　　因为典型的高效实现实现依赖<a href="#%E7%95%A5%E7%A7%B0">外部环境</a>对浮点数的支持，设计策略以保持<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>的便利性相关。</p>
<ul>
<li>NPLAMath 实现不访问 SNaN 值，也不需要访问宿主语言的浮点环境，但不假设总是使用默认浮点环境。
<ul>
<li>这不阻止和使用 SNaN 的<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>的程序链接和调用，这有助于保持互操作性。</li>
<li>NPLAMath 实现不保证检查访问浮点环境的副作用是否存在。若互操作需要改变浮点环境，应避免破坏实现的假设。</li>
</ul>
</li>
<li>不依赖零值的符号、NaN 的符号以及 SNaN 的处理和许多<a href="#%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0">宿主实现</a>的默认情形一致而能简化一般的实现，如：
<ul>
<li><a href="https://gcc.gnu.org/wiki/FloatingPointMath">GCC</a> 。</li>
<li><a href="https://docs.microsoft.com/cpp/build/reference/fp-specify-floating-point-behavior">Microsoft VC++</a> 。</li>
<li>不要求使用 GCC 时启用 <code>-ffloat-store</code> 。Microsoft VC++ 默认的 <code>/fp:precise</code> 的类似语义也不被依赖。</li>
</ul>
</li>
</ul>
<p><strong>注释</strong></p>
<p>　　数值操作可能允许非数值的操作数，这些操作数也可被计算结果依赖。</p>
<p>　　因为 <a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">flonum</a> 能表示所有实数数值范围，所以实数范围以内的操作不会引入操作数以外的其它 flonum 类型。</p>
<p>　　数值操作抛出异常的要求不一定在每一个实现数值操作的 <a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 中蕴含，因为这些 API 不一定是数值操作的完整实现。</p>
<p>　　抛出异常和<a href="#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>的异常和浮点异常没有直接关联。</p>
<p>　　若数值操作指定非数值计算结果（如<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">布尔值</a>）或者不能表示的 NaN 值的计算结果，则即使依赖 NaN 数值操作数，也不是 NaN 值。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，数值操作不支持不同的全局模式。</p>
<p>　　特定情形下，精确数可能替换计算结果中的不精确数：</p>
<ul>
<li>当按数学定义能被精确表示时，计算结果可以是符合要求的任意一个类型的精确数。</li>
<li>否则，当实现能证明不精确数值足够小到不足以影响结果的表示，且存在真值相等的可用的精确数时，可使用这个精确数代替不精确数。</li>
<li>当前实现没有这类证明机制。</li>
</ul>
<p>　　IEEE-754 使用<em>渐进下溢(gradual underflow)</em> ，使零值和相邻的非零浮点数的真值之差不会显著大于其它两个浮点数真值的差，而使小的非零浮点数之间的差不等于零。这体现了支持<a href="#%E6%95%B0%E5%80%BC%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">非规格化数</a>的实际作用。但一般数值计算仍需要累积误差。</p>
<p>　　虽然可能影响结果，浮点数实现的内部状态（如舍入模式）的访问不被直接支持。</p>
<p>　　浮点数 0 和 0 之差的符号可能取决于舍入模式。数值操作一般不保证结果 0 的符号，但以依赖<a href="#%E6%95%B0%E5%80%BC%E8%A1%A8%E7%A4%BA">表示的形式</a>仍可确定符号。</p>
<p>　　除满足必要的精度要求的前提外，互操作以外目的的数值的宿主类型的具体选择在维持计算正确性的意义上通常不重要，因此默认不要求指定。</p>
<p>　　对特殊值，因为 [R<sup>n</sup>RS] 只要求 <code>.0</code> 后缀的特殊值字面量，需保持兼容时，程序可只使用这些形式的字面量。为此，实现可使用带有 <code>.0</code> 后缀特殊值的数值字面量的对应的宿主类型，以减少潜在的可移植问题。</p>
<p>　　关于派生实现支持的数值字面量，参见 <a href="#npla1-%E6%95%B0%E5%80%BC%E5%AD%97%E9%9D%A2%E9%87%8F">NPLA1 数值字面量</a>。</p>
<h3 id="数值表示"><a class="header" href="#数值表示">数值表示</a></h3>
<p>　　支持解析的数值以字符串作为外部表示。作为字面量时，构成<a href="#npla-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F">数值字面量的词法</a>。</p>
<p>　　数值的外部表示和内部表示应支持<em>往返(round-trip)</em> 转换，即转换的内部或者外部表示输出可被输入接受。</p>
<p>　　往返转换中，精确数转换保持任意（无限）精度；不精确数经有限次转换不继续损失精度。</p>
<p><strong>注释</strong> 即便损失精度，也应总是满足结果至少不低于<a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">整数精度</a>。</p>
<p>　　支持的外部表示和对应的含义具体包括：</p>
<ul>
<li>数值的外部表示中起始的一个 <code>+</code> 或 <code>-</code> 字符指定符号。
<ul>
<li>这可能是可选的。若符合规则的数值字面量没有指定符号，则隐含为 <code>+</code> 。</li>
<li><strong>注释</strong> 不精确数可能在内部表示支持不同符号的<a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">零值</a>。</li>
</ul>
</li>
<li>以下优先匹配较长的模式。</li>
<li>匹配<a href="https://zh.wikipedia.org/zh-cn/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a> <code>(+|-)?[0-9]+</code> ：十进制整数值。
<ul>
<li>不论符号，当前精确数数值字面量默认都具有<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a> <code>int</code> ，除非其绝对值太大而无法被表示，使用其它类型代替。</li>
<li>除非精确数字面量的数值超过所有 <a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">fixnum</a> 的可表示范围，都具有 fixnum 值。</li>
<li>除非精确数字面量的数值超过所有支持的精确数的可表示范围，都是精确数。</li>
<li><strong>注释</strong> 当前精确数的表示范围是 fixnum 中宿主类型的值域的并集，因此超过 fixnum 可表示范围的数值不是精确数。</li>
</ul>
</li>
<li>匹配正则表达式 <code>(+|-)?[0-9]+\.[0-9]*</code> 或 <code>(+|-)?[0-9]+(\.[0-9]*)?(E|e|S|s|F|f|D|d|L|l)(+|-)?[0-9]+</code> ：十进制不精确数数值。
<ul>
<li>不精确数数值字面量的解析使用未指定的浮点数舍入模式，其<a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">误差</a>不大于最后一个在规格化范围内表示的十进制小数位为 1 时的绝对值的真值大小。</li>
<li>解析不精确数外部表示得到的真值和内部表示可具有误差。
<ul>
<li><strong>注释</strong> 误差和具体宿主语言支持相关，通常以任意可能符合宿主语言要求的舍入模式下的最大值计。</li>
</ul>
</li>
<li>第一种形式是直接记法。</li>
<li>第二种形式是<a href="https://zh.wikipedia.org/zh-cn/%E7%A7%91%E5%AD%A6%E8%AE%B0%E6%95%B0%E6%B3%95">科学记数法(scientific notation)</a> ，在指示指数的指数字母前后匹配的数字序列分别是有效数字(significand) 和指数(exponent) 。
<ul>
<li>指数字母表示作为 <a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">flonum</a> 的不同精度：
<ul>
<li><code>E</code> 或 <code>e</code> ：默认精度。</li>
<li><code>S</code> 或 <code>s</code> ：短(short) 精度。</li>
<li><code>F</code> 或 <code>f</code> ：单精度(float) 。</li>
<li><code>D</code> 或 <code>D</code> ：双精度(double) 。</li>
<li><code>L</code> 或 <code>l</code> ：长精度(long) 。</li>
<li>同组的字母含义等价。以上精度中，默认精度不低于双精度，其它精度依次不低于之前的一个。</li>
</ul>
</li>
<li>精度可影响内部存储的宿主类型。</li>
</ul>
</li>
<li>若字面量指定的数值小于或大于使用的类型的数值表示范围，则值为对应类型具有相同符号的零值或<a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">无限大值</a>。</li>
</ul>
</li>
<li>匹配正则表达式 <code>(+|-)(inf|nan)\.(0|f|t)</code> ：带符号的 flonum 特殊值。
<ul>
<li>其中，<code>inf</code> 指定无限大值，<code>nan</code> 指定 NaN 值。</li>
<li>后缀指定精度：
<ul>
<li><code>0</code> ：默认精度。</li>
<li><code>f</code> ：单精度。</li>
<li><code>t</code> ：扩展(extended) 精度。</li>
<li>以上精度中，默认精度不低于双精度，扩展精度不低于默认精度。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　除非派生实现另行指定，以上要求外的数值的子类型和内部表示未指定。</p>
<p><strong>原理</strong></p>
<p>　　浮点数解析存在不同精度的算法。</p>
<p>　　若以二进制浮点数和经过舍入的十进制表示相互转换不损失精度为前提，宿主语言的 <a href="http://eel.is/c++draft/numeric.limits"><code>std::numeric_limits</code></a> 的 <a href="http://eel.is/c++draft/numeric.limits.members#14"><code>max_digits10</code></a> 位十进制数字足够表示。</p>
<p>　　（对 [IEC 60559] 的二进制浮点数情形的证明参见<a href="https://www.itu.dk/~sestoft/bachelor/IEEE754_article.pdf">这里</a>的 Theorem 15 。）</p>
<p>　　但是，对任意有效输入的结果误差都不大于 1 <a href="https://zh.wikipedia.org/zh-cn/%E6%9C%80%E5%90%8E%E4%B8%80%E4%BD%8D%E4%B8%8A%E7%9A%84%E5%8D%95%E4%BD%8D%E5%80%BC">ULP(unit in the last place)</a> 的不经舍入的值完全精确值(full precision) 的精确解析算法，对实现的要求较高，且性能可能明显较低，故不作要求。</p>
<p>　　（对 [IEC 60559] 的二进制浮点数的情形，需要数十倍的中间存储，参见<a href="https://stackoverflow.com/questions/554063/62542806">这里</a>。）</p>
<p>　　和宿主语言的 <code>std::strtod</code> 不同，允许使用宿主语言中的任意浮点数舍入模式，而不要求不同浮点数舍入模式下的结果一致性。</p>
<p>　　浮点数精度的 <code>float</code> 和 <code>double</code> 在典型实现中的内部表示格式同 [IEC 60559] 的二进制的单精度和双精度浮点数。</p>
<p><strong>注释</strong></p>
<p>　　串模式 <code>(+|-)</code> 表示带有可选前缀符号（仅限一个），影响值的数值。</p>
<p>　　同 klisp 而不同于 [R<sup>n</sup>RS] 的字面量词法，小数点不能出现在词素中符号以外的第一个字符；但 klisp 的 <code>string-&gt;number</code> 没有这个限制。</p>
<p>　　同 [R<sup>n</sup>RS] 而不同于 klisp（两者包括字面量词法和 <code>string-&gt;number</code> ），小数点允许出现在词素的结尾。</p>
<p>　　当前不精确数数值都具有宿主类型 <code>double</code> 。即便 <code>long double</code> 可能具有更大的数值范围，也不能通过解析数值表示直接取得。</p>
<p>　　类似地，[Racket] 默认不启用 <a href="https://docs.racket-lang.org/reference/extflonums.html">extflonum</a>。关于数值操作也类似，参见<a href="#%E6%95%B0%E5%80%BC%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">数值操作约定</a>。</p>
<p>　　当前允许在<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主值</a>不能完全存储不精确数的字面量数字时，解析十进制不精确数字面量存储的值可能和字面量的数值的真值之间具有超过 1ULP 的误差。这可能影响和精确数之间的比较。</p>
<p>　　当前实现使用四舍五入。</p>
<p>　　关于宿主语言中 <a href="http://www.eel.is/c++draft/cstdlib.syn#lib:strtod"><code>std::strtod</code></a>（同 [ISO C] 标准库的 <code>strtod</code> ）舍入要求的一些问题，参见：</p>
<ul>
<li><a href="https://www.exploringbinary.com/incorrectly-rounded-conversions-in-gcc-and-glibc/">Incorrectly Rounded Conversions in GCC and GLIBC</a></li>
<li><a href="https://www.sourceware.org/bugzilla/show_bug.cgi?id=3479">Incorrect rounding in <code>strtod()</code></a></li>
</ul>
<p>　　数值字面量的词法同 [R<sup>n</sup>RS] 的一个子集。</p>
<p>　　[R<sup>n</sup>RS] 指出实现可能允许用户修改不同的默认精度。这指出精度不是固定的，但不是实现要求。
　　[R<sup>n</sup>RK] 的有限数的对应子集接近 [R<sup>n</sup>RS] 的设计，但没有明确指定字面量词法规则。其中对精度的表述略有不同：</p>
<ul>
<li>没有指定大写字母。</li>
<li>指定 <code>s</code> 、<code>f</code> 、<code>d</code> 和 <code>l</code> 的精度递增，没有显式允许不同的精度映射到相同的内部格式。</li>
<li>没有显式允许用户指定的默认精度。</li>
</ul>
<p>　　但是，SINK 和 klisp 实际上都不符合前两点，而更符合 Scheme 的实现。[R<sup>n</sup>RK] 在此可能不完善或表述有误。</p>
<p>　　当前 klisp 的实现不允许 <code>E</code> 和 <code>e</code> 之前没有小数点，且在存在 <code>E</code> 或 <code>e</code> 时省略之后的指数的任意部分，和 SINK 以及 [R<sup>n</sup>RS] 都不同。本设计遵循后者。</p>
<p>　　当前 NPLAMath 精度对应的宿主类型指派如下：</p>
<ul>
<li>非特殊值：
<ul>
<li><code>e</code> ：同 <code>d</code> 。</li>
<li><code>s</code> ：同 <code>f</code> 。</li>
<li><code>f</code> ：<code>float</code> 。</li>
<li><code>d</code> ：<code>double</code> 。</li>
<li><code>l</code> ：<code>long double</code> 。</li>
</ul>
</li>
<li>特殊值：
<ul>
<li><code>0</code> ：<code>double</code> 。</li>
<li><code>f</code> ：<code>float</code> 。</li>
<li><code>t</code> ：<code>long double</code> 。</li>
</ul>
</li>
</ul>
<p>　　指定特殊值的精度的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">词素</a>语法兼容 [Racket] 。</p>
<h1 id="npla1-核心语言"><a class="header" href="#npla1-核心语言">NPLA1 核心语言</a></h1>
<p>　　NPL 是独立设计的，但其派生语言和其它一些语言有类似之处；这些语言和 NPL 方言之间并不具有派生关系。但为简化描述，部分地引用这些现有<a href="../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">语言规范</a>中的描述，仅强调其中的不同。</p>
<p>　　NPLA1 符合 NPL 和 NPLA 的语言规则，其<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">实现环境</a>还应提供本章起的其它程序接口。</p>
<p>　　互操作中的一些接口处理的值可约定<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>。但这些类型不一定在<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">对象语言</a>层次上稳定，可能在之后的版本变化。稳定性由具体实现提供的附加规则（若存在）保证。</p>
<p>　　NPLA1 和 Kernel 语言（即 [R<sup>n</sup>RK] ）的特性设计（如 <a href="#vau-%E6%8A%BD%E8%B1%A1">vau</a>和作为<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>的环境表达<a href="#%E8%BF%87%E7%A8%8B">过程抽象</a>）有很多类似之处，因此许多概念是通用的；但从<a href="#%E9%A2%86%E5%9F%9F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">设计哲学</a>到本章介绍的各个细节（如<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">默认求值规则</a>）都存在深刻的差异。</p>
<p>　　部分名称指定的操作和 [R<sup>n</sup>RS] 或 <a href="http://klisp.org/docs/index.html">klisp</a> 指定的类似。</p>
<p>　　以下章节主要介绍和 Kernel 约定不同的设计。各节的通用约定不再在之后的各个接口单独说明。</p>
<h2 id="npla1-对象语言约定"><a class="header" href="#npla1-对象语言约定">NPLA1 对象语言约定</a></h2>
<p>　　NPLA1 仅使用<a href="#npla-%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83">宿主语言</a>的<a href="#%E7%B1%BB%E5%9E%8B">类型</a>和<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>作为在对象语言可表达的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">状态</a>。</p>
<p>　　在 <a href="#npla">NPLA</a> 的基础上，NPLA1 要求对象语言支持以一等对象作为表达式并被<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>。</p>
<p>　　<a href="#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">类型等价性</a>基于<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">类型映射</a>及其实现，由 [ISO C++] 的语义规则定义。</p>
<p>　　值等价性由<a href="#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>的 <code>==</code> 表达式的结果定义。</p>
<p>　　除非另行指定，所有类型的<a href="#%E8%A1%A8%E7%A4%BA">外部表示</a>都是允许从作为内部表示的<a href="#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">项节点</a>确定的同<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>的空字符结尾的字符串（即 [ISO C++] 的 <a href="https://eel.is/c++draft/defns.ntcts">NTCTS</a> ）。</p>
<p>　　关于作为表达式的求值和类型映射的实现，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h3 id="标识符附加规则"><a class="header" href="#标识符附加规则">标识符附加规则</a></h3>
<p>　　当前仅支持<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">标识符</a>作为<a href="#%E5%90%8D%E7%A7%B0">名称</a>。</p>
<p>　　部分名称是<a href="#npla-%E5%90%8D%E7%A7%B0%E5%92%8C%E5%AD%97%E9%9D%A2%E9%87%8F%E6%B1%82%E5%80%BC">保留名称</a>：含有 <code>$$</code> 的名称保留给宿主交互使用；含有 <code>__</code> 的名称保留给 NPLA1 实现。</p>
<p>　　在 <a href="#npla-%E6%95%B4%E4%BD%93%E7%BA%A6%E5%AE%9A">NPLA 规则</a>的基础上，在<a href="#%E8%A1%A8%E7%A4%BA">内部表示</a>中显式使用保留给实现的标识符的程序<a href="#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">行为未定义</a>。</p>
<p><strong>注释</strong> 这包含在源代码以外的中间表示使用的情形，但不包含作为用户输入的数据。</p>
<h2 id="npla1-互操作约定"><a class="header" href="#npla1-互操作约定">NPLA1 互操作约定</a></h2>
<p>　　基本规则参见 <a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">NPLA 互操作支持</a>。</p>
<p>　　非 NPLA1 实现提供的类型的宿主 <code>==</code> 操作不要求支持<a href="#%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8%E5%AE%89%E5%85%A8">嵌套调用安全</a>。</p>
<p>　　作为 NPLA1 嵌套调用安全的约定的扩展，若存在 == 操作不支持嵌套调用安全的类型，具体类型由派生实现的定义。</p>
<p>　　对象语言操作和互操作不修改对象语言中已经可见的<a href="#npla-%E7%8E%AF%E5%A2%83">一等环境</a>的<a href="#npla-%E7%8E%AF%E5%A2%83">父环境</a>。</p>
<p><strong>原理</strong></p>
<p>　　NPLA1 中提供的类型仍需要支持嵌套调用安全，以满足嵌套调用安全的约定中的要求。</p>
<p>　　关于 NPLA1 嵌套调用安全的具体约定和其它实现原理，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p>　　避免修改已在对象语言可访问的一定对象的父环境符合同 [R<sup>n</sup>RK] 的环境<a href="#%E5%B0%81%E8%A3%85">封装性</a>对对象语言的要求。这允许实现假定仅在有限的上下文中父环境可修改，而减少优化实现的难度。</p>
<h2 id="npla1-程序实现"><a class="header" href="#npla1-程序实现">NPLA1 程序实现</a></h2>
<p>　　本章指定 NPLA1 对象语言的<a href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">核心语言特性</a>。包含<a href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">库特性</a>的其它设计参见 <a href="#npla1-%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83">NPLA1 参照实现环境</a>。</p>
<p><strong>原理</strong></p>
<p>　　一般的语言能支持不同实现形式的库，包括<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源程序</a>和其它无法判断是否和特定源程序关联的翻译后的程序。</p>
<p>　　复用这些程序时，可能需要根据不同的形式而分别处理：源代码被读取和<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>而加载，而其它格式的翻译形式可能直接映射存储后经特定的检查即被加载。</p>
<p>　　但是在可复用的意义上，这些不同的形式是一致的，都视为库。</p>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RK] 不同，库不限定其实现形式。[R<sup>n</sup>RK] 指定的库实质上是可使用对象语言派生实现的库。</p>
<p>　　典型的静态语言不保证程序执行时能对源程序进行翻译，因此加载程序的限制通常更大，可能无法处理源程序形式的库而首先需要分离翻译为其它格式。NPL 一般不具有这个限制。</p>
<p>　　关于对象语言的<a href="#%E7%95%A5%E7%A7%B0">派生实现</a>，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h3 id="npla1-程序外部环境"><a class="header" href="#npla1-程序外部环境">NPLA1 程序外部环境</a></h3>
<p>　　基于 <a href="#npla-%E6%95%B4%E4%BD%93%E7%BA%A6%E5%AE%9A">NPLA 整体约定</a>，由 <a href="#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">NPL-EMA</a> ，NPLA 的实现不假定存在多线程执行环境。</p>
<p>　　但是，宿主语言可支持多线程环境执行，<a href="#npla-%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE">可引起宿主语言的未定义行为</a>。</p>
<p>　　作为 NPLA 的派生，NPLA1 对象语言程序也具有相同的性质，除非另行指定需要和<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">外部环境</a>交互的特定操作，不需要假定 NPLA1 引入存在多线程执行环境。</p>
<h3 id="附加元数据"><a class="header" href="#附加元数据">附加元数据</a></h3>
<p>　　NPLA1 实现可提供和<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">实现环境</a>或具体 NPLA 对象关联的附加的资源，用于提供程序运行时可得到的附加信息，如源代码位置。</p>
<p>　　是否存在这些<em>附加元数据(extra metadata)</em> 和附加元数据的具体内容可影响特定的行为。</p>
<p><strong>注释</strong> 如符合<a href="#%E8%AF%8A%E6%96%AD">诊断</a>中要求的实现的具体行为。</p>
<p>　　这些影响是未指定的，但除 NPLA1 程序直接依赖具体数据而进行的操作外，不应影响程序的其它语义（例如，引起程序终止）。</p>
<h3 id="npla1-扩展支持"><a class="header" href="#npla1-扩展支持">NPLA1 扩展支持</a></h3>
<p>　　本章中除<a href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>的限制外，不支持的特性可能会在之后的实现中扩展并支持。</p>
<h3 id="npla1-未定义行为"><a class="header" href="#npla1-未定义行为">NPLA1 未定义行为</a></h3>
<p>　　NPLA1 对象语言程序中的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未定义行为</a>包括 <a href="#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">NPLA 未定义行为</a>和以下扩展 NPLA 未定义行为：</p>
<ul>
<li>特定情形下<a href="#npla1-%E7%8E%AF%E5%A2%83">访问被修改的环境中绑定的对象</a>。</li>
<li>特定情形下违反对环境的使用要求。
<ul>
<li><strong>注释</strong> 参见<a href="#%E7%8E%AF%E5%A2%83%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7">环境的稳定性</a>。</li>
</ul>
</li>
<li>特定情形下违反对外部实现环境假定的使用要求。
<ul>
<li><strong>注释</strong> 参见<a href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%8A%A0%E8%BD%BD">模块的初始化和加载</a>。注意虽然可能通过环境实现，但这在接口的意义上独立于环境的稳定性。</li>
</ul>
</li>
<li>NPLA1 库约定的未定义行为。
<ul>
<li><strong>注释</strong> 有些未定义行为不需要被显式约定，例如不支持的并发访问<a href="#npla1-%E7%A8%8B%E5%BA%8F%E5%A4%96%E9%83%A8%E7%8E%AF%E5%A2%83">可引起宿主语言的未定义行为</a>，属于 NPLA 未定义行为。</li>
</ul>
</li>
</ul>
<p>　　派生语言可约定其它未定义行为。</p>
<p><strong>原理</strong></p>
<p>　　扩展 NPLA 未定义行为可提供更严格的要求使实现更简化。</p>
<p>　　关于环境的一些未定义行为可视为违反<a href="#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>，而不需要单独实现。</p>
<h2 id="接口文法约定"><a class="header" href="#接口文法约定">接口文法约定</a></h2>
<p>　　为描述对象语言规则和程序接口，本节约定<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">文法</a>形式。</p>
<p><strong>注释</strong> 这仅用于描述接口，不依赖 NPL 语言的<a href="#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95">基本文法</a>。</p>
<p>　　元语言文法：</p>
<pre><code class="language-xbnf">&lt;left-constraint-bound&gt; ::= &lt;
&lt;right-constraint-bound&gt; ::= &gt;
&lt;constraint&gt; ::= &lt;left-constraint-bound&gt;&lt;constraint-name&gt;&lt;right-constraint-bound&gt;
&lt;prefix&gt; ::= .
&lt;suffix&gt; ::= ? | ...
&lt;trailing-constraint&gt; ::= &lt;constraint&gt; | &lt;constraint&gt;&lt;suffix&gt; | &lt;prefix&gt;&lt;trailing-constraint&gt;
&lt;sequence&gt; ::= &lt;constraint&gt;*&lt;trailing-constraint&gt;
&lt;left-sequence-bound&gt; ::= (
&lt;right-sequence-bound&gt; ::= )
&lt;form&gt; := &lt;sequence&gt; | &lt;left-sequence-bound&gt;&lt;sequence&gt;&lt;right-sequence-bound&gt;
</code></pre>
<p>　　规约操作中<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>的约束通过具有同类<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">名称</a>（即 <code>&lt;constraint-name&gt;</code> 元素）的前后以 <code>&lt;</code> 和 <code>&gt;</code> 作为边界的文法元素表示，即 <code>&lt;constraint&gt;</code> 文法元素。</p>
<p>　　为区分同类约束的不同项，约束的名称后（在 <code>&gt;</code> 之前）的可带有以 1 起始的正整数序数。除非另行指定，这些序数仅用于区分不同的同类约束项，无其它附加含义。</p>
<p>　　本节描述的项是被用于<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>（参见<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值算法</a>）的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>或它们的直接文法组合。前者应能涵盖<a href="#%E5%8E%9F%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F">原子表达式</a>、其<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>以及预期在对象语言中实现<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">对象语言求值算法</a>所需的 <a href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">NPLA1 用户程序</a>构造。</p>
<p>　　库可参照本节的方式约定通过项的文法，以支持仅在特定库使用的操作数。</p>
<p>　　除非另行指定，本节的对应要求同时适用于本节中和这些库中引入的项。</p>
<h3 id="元文法基本约定"><a class="header" href="#元文法基本约定">元文法基本约定</a></h3>
<p>　　描述接口的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">元语言</a>的文法具有以下含义：</p>
<ul>
<li>表达操作的文法是 <code>&lt;sequence&gt;</code> ，表示匹配项的文法元素 <code>&lt;constraint&gt;</code> 或 <code>&lt;trailing-constraint&gt;</code> 的序列。</li>
<li>当 <code>&lt;sequence&gt;</code> 不存在具有非空 <code>&lt;prefix&gt;</code> 的 <code>&lt;trailing-constraint&gt;</code> 时，序列是<a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>。</li>
<li><code>.</code> 仅在序列的最后一个文法元素中出现，表示后继的项和可选的文法元素后缀是有序对的最后一个元素。</li>
<li>文法元素后缀的含义如下：
<ul>
<li><code>...</code> ：Kleene 星号，重复之前修饰的 <code>&lt;constraint&gt;</code> 0 次或多次。</li>
<li><code>+</code> ：重复之前修饰的 <code>&lt;constraint&gt;</code> 1 次或多次。</li>
<li><code>?</code> ：重复之前修饰的 <code>&lt;constraint&gt;</code> 0 次或 1 次。</li>
</ul>
</li>
</ul>
<p><strong>注释</strong></p>
<p><code>...</code> 一般在结尾出现，表示元素构成列表。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，不使用 <code>.</code> 分隔有序对，不使用元素名称的复数表示列表。</p>
<h3 id="实体元素文法约定"><a class="header" href="#实体元素文法约定">实体元素文法约定</a></h3>
<p>　　指定具名的<a href="#%E5%87%BD%E6%95%B0">函数</a>的文法中，第一项以<a href="#%E7%AC%A6%E5%8F%B7">符号值</a>的形式在所在的环境中提供，指定求值结果指称为<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>的函数的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">名称</a>；其后指定的文法中不同的元素对应合并子的<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>或其被作为调用时的<a href="#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">形式参数树</a>的子项。</p>
<p>　　除非另行指定，在操作数可能是左值时，仅当对应以 <a href="#%E5%85%83%E6%96%87%E6%B3%95%E5%9F%BA%E6%9C%AC%E7%BA%A6%E5%AE%9A"><code>...</code> 或 <code>?</code> 形式</a>中最后的一项（若存在）时，支持匹配作为<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的有序对的非<a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">前缀元素</a>不是空列表的<a href="#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>的情形。</p>
<p>　　名义不同的约束可能蕴含相同的<a href="#%E9%94%99%E8%AF%AF%E6%A3%80%E6%9F%A5">检查</a>。</p>
<p>　　除非另行指定，应用子的操作数的约束也适用其<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">底层合并子</a>。</p>
<p><strong>注释</strong> 这意味着意味着按求值算法，被求值的应用子的<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>对象不能是<a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">非真列表</a>。特别地，<code>...</code> 形式的结尾序列一般被要求是真列表，除非是其底层操作子被求值且具有存在 <code>.</code> 前缀的最后一个文法元素。</p>
<p>　　文法形式上，使用本节约定指定<a href="#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">应用子的操作数</a>时，指定表达式形式的求值结果。</p>
<p><strong>注释</strong> 这和 [R<sup>n</sup>RK] 和 [Shu10] 中的斜体标识符的标记不同，但含义（表示语义变量(semantic variable) ）和效果实质相同。</p>
<p>　　操作数可能是左值或右值，按具体操作的需要，在必要时可被转换。</p>
<p>　　除可能具有的<a href="#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>关系，本节约定的不同类型的操作数构成的集合之间不相交。一般规则参见<a href="#%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB">类型分类</a>。</p>
<p>　　根据是否可作为操作子中指定不被求值的函数参数，本节的操作数及其<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">子项</a>分为<a href="#%E6%9C%AA%E6%B1%82%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">未求值的操作数</a>和<a href="#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">求值得到的操作数</a>。</p>
<p><strong>原理</strong></p>
<p>　　约束可用于区分特定的含义，但不直接指定和具体的<a href="#%E9%94%99%E8%AF%AF%E6%A3%80%E6%9F%A5">检查</a>对应，以便被实现优化，例如合并名义不同的检查。</p>
<p>　　文法形势的匹配应避免歧义。</p>
<p><strong>注释</strong></p>
<p>　　对非<a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">前缀元素</a>的支持和<a href="#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">绑定匹配</a>规则对应。其中：</p>
<ul>
<li>仅<a href="#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">结尾序列</a>支持匹配以空列表以外的值的引用值作为非前缀元素的<a href="#%E6%9C%89%E5%BA%8F%E5%AF%B9">有序对</a>操作数左值的被引用对象中的非前缀元素<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>。</li>
<li>非结尾序列的元素因计算前缀元素数而被要求在同一个对象的前缀元素中。</li>
<li>作为操作数被绑定时，若元素是引用值：
<ul>
<li>它不被<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%B6%88%E9%99%A4">消除</a>。</li>
<li>它的被引用对象中的元素（若存在）不被视为初始化<a href="#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>中的其它<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>的子对象。</li>
</ul>
</li>
<li>若有序对操作数的非前缀元素是空列表的引用值，则有序对操作数构成列表。
<ul>
<li>有序对操作数的非前缀元素不会匹配<a href="#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">形式参数树</a>中的<a href="#%E7%AC%A6%E5%8F%B7">符号值</a>而被绑定到变量。</li>
</ul>
</li>
<li>关于操作数匹配的规则避免匹配操作数序列时对文法元素的对应关系可能具有歧义。</li>
</ul>
<h4 id="未求值的操作数"><a class="header" href="#未求值的操作数">未求值的操作数</a></h4>
<p>　　未求值的操作数的文法约定如下：</p>
<ul>
<li><code>&lt;symbol&gt;</code> ：<a href="#%E7%AC%A6%E5%8F%B7">符号</a>。
<ul>
<li><strong>注释</strong> 内部使用和 <a href="#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;string&gt;</code></a>一一对应的表示，不提供符号和外部表示的其它映射关系。</li>
</ul>
</li>
<li><code>&lt;symbols&gt;</code> ：元素为 <code>&lt;symbol&gt;</code> 的列表，形式为 <code>(&lt;symbol&gt;...)</code> 。</li>
<li><code>&lt;eformal&gt;</code> ：表示可选提供的环境名称的 <code>&lt;symbol&gt;</code> 或 <a href="#npla1-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F"><code>#ignore</code></a> ，或这些值的引用值。
<ul>
<li><strong>注释</strong> 通常为动态环境。</li>
</ul>
</li>
<li><code>&lt;expression&gt;</code> ：待求值的表达式。
<ul>
<li><strong>注释</strong> 这是 <a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F">NPL 语法</a>的直接实现。作为右值，它是词法元素的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>，或这些元素的<a href="#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>。</li>
</ul>
</li>
<li><code>&lt;expressions&gt;</code> ：形式为 <code>&lt;expression&gt;...</code> 的待求值形式。
<ul>
<li>求值时，<code>&lt;expressions&gt;</code> 被作为单一表达式（即视为求值 <code>(&lt;expression&gt;...)</code> ）。</li>
</ul>
</li>
<li><code>&lt;binding&gt;</code> ：绑定列表的元素，形式为 <code>&lt;symbol&gt; &lt;body&gt;</code> ，用于指定被求值的表达式和绑定参数的符号值。
<ul>
<li>和 Kernel 不同，<code>&lt;symbol&gt;</code> 后不要求是整个 <code>&lt;expression&gt;</code> 。</li>
</ul>
</li>
<li><code>&lt;binding&gt;</code> 绑定列表，形式为 <code>&lt;symbol&gt; &lt;expressions&gt;</code> ，用于指定被求值的表达式和绑定参数的符号值。</li>
<li><code>&lt;bindings&gt;</code> ：绑定列表，即元素为 <code>&lt;binding&gt;</code> 的列表，形式为 <code>(&lt;binding&gt;...)</code> 。</li>
<li><code>&lt;body&gt;</code>： 出现在元素的结尾 <code>&lt;expressions&gt;</code> 形式。
<ul>
<li><strong>注释</strong> 一般用于<a href="#%E5%87%BD%E6%95%B0">函数体</a>等替换求值的目标。</li>
</ul>
</li>
<li><code>&lt;expression-sequence&gt;</code> ：同 <code>&lt;expression&gt;...</code> 但蕴含顺序求值其中的子项。
<ul>
<li>求值 <code>&lt;expression-sequence&gt;</code> 的结果是求值其最后一个子表达式（若存在）的结果，或当不存在子表达式时为<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">未指定值</a>。</li>
</ul>
</li>
<li><code>&lt;consequent&gt;</code> ：同 <code>&lt;expression&gt;</code> ，仅用于 <a href="#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;test&gt;</code></a> 求值结果经<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">左值到右值转换</a>不为 <code>#f</code> 时。</li>
<li><code>&lt;alternative&gt;</code> ：同 <code>&lt;expression&gt;</code> ，仅用于 <code>&lt;test&gt;</code> 求值结果经左值到右值转换为 <code>#f</code> 时。</li>
<li><code>&lt;ptree&gt;</code> ：形式参数树，是包含符号值或 <code>#ignore</code> 及其它形式参数树构成的 <a href="#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">DAG</a> 的表达式。
<ul>
<li>语法要求由上下文无关文法描述：<code>&lt;ptree&gt; ::= &lt;symbol&gt; | #ignore | () | (&lt;ptree&gt;...)</code> 。</li>
</ul>
</li>
<li><code>&lt;definiend&gt;</code> ：被绑定项的目标的 <code>&lt;ptree&gt;</code> 。
<ul>
<li>引入绑定时，蕴含按<a href="#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">绑定规则</a>附加 <code>&lt;ptree&gt;</code> 以外的<a href="#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">绑定匹配</a>等语义检查。</li>
</ul>
</li>
<li><code>&lt;formals&gt;</code> ：作为形式参数的 <code>&lt;ptree&gt;</code> 。同 <code>&lt;definiend&gt;</code> 但允许<a href="#%E7%95%A5%E7%A7%B0">派生实现</a>定义更多检查。</li>
<li><code>&lt;clauses&gt;</code> ：元素为条件分支的列表，形式为 <code>(&lt;test&gt; &lt;body&gt;)...</code> 。</li>
<li><code>&lt;variable&gt;</code> ：<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">变量</a>。用于表示被<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">声明</a>的名称。
<ul>
<li>同 <code>&lt;symbol&gt;</code> ，其中的处理与作为非列表的 <code>&lt;formals&gt;</code> 相同。</li>
</ul>
</li>
</ul>
<p>　　关于 <code>eval</code> ，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　以 <code>&lt;expressions&gt;</code> 代替 <code>&lt;expression&gt;</code> 可避免语法中要求过多的括号及 <code>eval</code> 等求值形式中显式构造列表的需要。</p>
<p>　　因为 <code>&lt;body&gt;</code> 存在元素的结尾，明确元素中的其它词法元素后即可自然确定边界。</p>
<p>　　<code>&lt;body&gt;</code> 可以是多个表达式的词法组合，允许具体使用时不需要附加括号即可实现整体求值。</p>
<p>　　特别地，作为其它 <code>&lt;body&gt;</code> 嵌套的 <code>&lt;body&gt;</code> 实例在这种情况下，可以更有效地减少嵌套一层以上的括号。</p>
<p>　　<code>&lt;body&gt;</code> 整体求值的一个必要条件：构成 <code>&lt;body&gt;</code> 的表达式不被以其它方式分别求值，如蕴含<a href="#%E6%96%87%E6%B3%95%E5%85%83%E7%B4%A0%E8%A1%A5%E5%85%85%E7%BA%A6%E5%AE%9A">顺序求值</a>。</p>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RK] 不同，<code>&lt;body&gt;</code> 可以是多个表达式的词法组合。</p>
<p>　　尽管 <code>&lt;body&gt;</code> 不保证可直接构成一个表达式（而是构成某个表达式的所在元素中的多个子表达式），一般仍被作为一个整体求值。</p>
<p>　　被整体求值时，这些表达式被视为某个假想的表达式，这个表达式包含被整体求值的表达式作为子表达式。</p>
<p>　　若 <code>&lt;body&gt;</code> 存在超过一个子表达式，按求值算法的 <a href="#npla1-%E8%A7%84%E8%8C%83%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">NPLA1 规范求值算法步骤</a>，表达式分别作为合并子和之后的参数。</p>
<p>　　若 <code>&lt;body&gt;</code> 不存在子表达式，则结果是 <code>()</code> 而不是 <code>#inert</code> 。这和 [R<sup>n</sup>RK] 的经重定义而隐含 <code>$sequence</code> 的 <code>$vau</code> 以及 <code>$let</code> 等合并子不同，但和 <code>eval</code> 仍然相同。</p>
<h4 id="求值得到的操作数"><a class="header" href="#求值得到的操作数">求值得到的操作数</a></h4>
<p>　　求值得到的操作数的文法约定如下：</p>
<ul>
<li><code>&lt;object&gt;</code> ：一般对象，包括引用对象的<a href="#npla1-%E5%BC%95%E7%94%A8">引用值</a>。</li>
<li><code>&lt;reference&gt;</code> ：对象引用值。</li>
<li><code>&lt;pair&gt;</code> ：<a href="#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">有序对</a>。
<ul>
<li><strong>注释</strong> 可构成<a href="#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表或非真列表</a>。</li>
</ul>
</li>
<li><code>&lt;list&gt;</code> ：<a href="#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">列表</a>：空列表或第二个元素为空列表的有序对。</li>
<li><code>&lt;lists&gt;</code> ：元素都是列表的列表。</li>
<li><code>&lt;boolean&gt;</code> ：<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">布尔值</a>，值为 <code>#t</code> 或 <code>#f</code> 的集合。
<ul>
<li>是<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">类型映射</a>指定的用于条件判断的单一值的类型。</li>
<li>推论：<code>&lt;boolean&gt;</code> 对应的宿主类型是 <code>bool</code> 。</li>
</ul>
</li>
<li><code>&lt;test&gt;</code> ：类似 <code>&lt;object&gt;</code> ，通常预期为 <code>&lt;boolean&gt;</code> ，作为条件。
<ul>
<li>当<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>非 <code>#f</code> 时条件成立。</li>
<li><strong>原理</strong> 和 Scheme 类似但和 Kernel 不同，非 <code>#t</code> 的值在决定分支时视同 <code>#f</code> ，以允许在 <code>&lt;boolean&gt;</code> 外自然扩展的逻辑代数操作。</li>
<li><strong>原理</strong> 和 Common Lisp 不同，不使用空列表（或符号值 <code>nil</code> ）代替 <code>#f</code> ，以避免需要特设的规则以特定的其它类型的值（如 Common Lisp 的符号值 <code>t</code> ）表示逻辑真（这在逻辑非操作中不可避免）。</li>
</ul>
</li>
<li><code>&lt;combiner&gt;</code> ：<a href="#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>。</li>
<li><code>&lt;applicative&gt;</code> ：<a href="#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">应用子</a>。</li>
<li><code>&lt;operative&gt;</code> ：<a href="#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">操作子</a>。</li>
<li><code>&lt;predicate&gt;</code> ：<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">谓词</a>，是应用操作数的求值结果的值为 <code>&lt;test&gt;</code> 的 <code>&lt;applicative&gt;</code> 。
<ul>
<li><strong>注释</strong> 通常实现结果是 <code>&lt;boolean&gt;</code> 的<a href="#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>。</li>
</ul>
</li>
<li><code>&lt;environment&gt;</code> ：<a href="#npla-%E7%8E%AF%E5%A2%83">一等环境</a>。</li>
<li><code>&lt;parent&gt;</code> ：指定环境的<a href="#npla-%E7%8E%AF%E5%A2%83">父环境</a>的值，包括：
<ul>
<li>环境引用值：<code>&lt;environment&gt;</code> 或以 <code>&lt;environment&gt;</code> 值作为被引用对象的 <code>&lt;reference&gt;</code> 。</li>
<li>元素为环境引用值的 <code>&lt;list&gt;</code> 。</li>
<li><a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>是元素为环境引用值的 <code>&lt;list&gt;</code> 的 <code>&lt;reference&gt;</code> 。</li>
</ul>
</li>
<li><code>&lt;string&gt;</code> ：字符串。
<ul>
<li>字符串是包括<a href="#npla-%E5%90%8D%E7%A7%B0%E5%92%8C%E5%AD%97%E9%9D%A2%E9%87%8F%E6%B1%82%E5%80%BC">数据字面量</a>作为表示的值的类型。</li>
<li>字符串的内部表示在具体实现中保持一致。除非另行指定，使用 <a href="https://www.iso.org/standard/76835.html">ISO/IEC 10646</a> 定义的 UCS 的 UTF-8 编码，其值不包含空字符（编码数值为 0 的 UCS 代码点）。</li>
<li>关于当前实现，另见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</li>
<li><strong>注释</strong> 为<a href="#npla1-%E4%BA%92%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">互操作</a>的兼容性，一般建议实现使用兼容 [ISO C++] 中定义的 <a href="https://eel.is/c++draft/multibyte.strings#2">NTMBS(null-terminated multibyte string)</a> 的方式表达。</li>
</ul>
</li>
<li>此外，支持的数值操作数参见 <a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">NPLA 数值类型</a>。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　<code>&lt;object&gt;</code> 等求值得到的操作数不保证是语法意义上连续的词法组合，不能由多个表达式构成，因此即便出现在元素末尾，也不能如 <code>&lt;body&gt;</code> 一样减少括号。</p>
<p>　　<code>&lt;object&gt;</code> 作为<a href="#%E7%B1%BB%E5%9E%8B%E5%85%A8%E9%9B%86">类型全集</a>，其元素可被断言在<a href="#%E5%BC%80%E6%94%BE%E6%80%A7">论域</a>内，即任何其它类型都是 <code>&lt;object&gt;</code> 的<a href="#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>。<a href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>可对此进行验证。</p>
<p>　　和 [R<sup>n</sup>RK] 的理由不同，允许布尔代数以外扩展的比较判断在此不认为是易错的，而是有意的设计(by design) 。这避免预设地假定类型的名义语用作用（“角色(role) ” ），也避免限制语言和派生语言的类型全集的设计。</p>
<p><strong>注释</strong></p>
<p>　　空列表构成的<a href="#%E7%B1%BB%E5%9E%8B">单元类型</a>是真列表的子类型，而不是有序对的子类型。</p>
<p>　　非空真列表是有序对的子类型。</p>
<h4 id="文法元素补充约定"><a class="header" href="#文法元素补充约定">文法元素补充约定</a></h4>
<ul>
<li>除非另行指定，以 <code>&lt;symbols&gt;</code> 指定的值被作为 <code>&lt;definiend&gt;</code> 或 <code>&lt;formals&gt;</code> 使用时不引起错误。
<ul>
<li><strong>注释</strong> <code>&lt;symbols&gt;</code> 在被其它上下文使用时仍可能引起错误。</li>
</ul>
</li>
<li><code>&lt;symbols&gt;</code> 形式的符号列表在绑定<a href="#npla-%E7%8E%AF%E5%A2%83">变量名</a>时支持引用标记字符 <a href="#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6"><code>&amp;</code> 和 <code>%</code></a>。符号作为被绑定的初值符时，移除符号中发现的这些引用标记字符。</li>
<li><code>&lt;definiend&gt;</code> 和 <code>&lt;formals&gt;</code> 不要求重复符号值检查。另见<a href="#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">绑定操作</a>。</li>
<li>使用 <code>&lt;formals&gt;</code> 的情形包括合并子基本操作和可通过这些操作派生的操作在对应位置的操作数。
<ul>
<li><strong>原理</strong> [R<sup>n</sup>RK] 和 [Shu10] 都没有显式区分 <code>&lt;definiend&gt;</code> 和 <code>&lt;formals&gt;</code> ，两者在上下文中实质可互换，差别仅在 [R<sup>n</sup>RS] 中的 define 形式中定义的位置可具有和 <code>&lt;formals&gt;</code> 不兼容的扩展形式。</li>
<li><strong>注释</strong> 这实质等价使用 [Shu09] 中的记法，即 <code>&lt;formals&gt;</code> 用于除和 [Shu09] 的 <code>$define!</code> 类似外的所有操作（包括 <code>$set!</code> 和 <code>$let</code> 等，而不论是否对应 <code>&lt;body&gt;</code> ）。这些上下文中总是隐含了上述的可派生实现的要求。</li>
</ul>
</li>
<li><code>&lt;body&gt;</code> 不蕴含顺序求值子项。
<ul>
<li><strong>原理</strong> 这也允许 <code>&lt;body&gt;</code> 中的表达式被<a href="#%E6%9C%AA%E6%B1%82%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">整体求值</a>。</li>
</ul>
</li>
</ul>
<p>　　关于合并子基本操作，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　和传统 Lisp 方言（包括 [R<sup>n</sup>RS] 和 [R<sup>n</sup>RK] ）的函数体不同，<code>&lt;body&gt;</code> 的各个表达式之间不蕴含顺序求值。</p>
<p>　　因此，和 [R<sup>n</sup>RK] 不同，<code>$vau</code> 不需要在基本操作之后再次派生。这使操作的功能更加正交。</p>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RK] 不同，<code>&lt;symbols&gt;</code> 、<code>&lt;definiend&gt;</code> 和 <code>&lt;formals&gt;</code> 具有一些附加的约定支持；<code>&lt;body&gt;</code> 不蕴含顺序求值子项；NPLA1 的符号可通过<a href="#npla-%E5%90%8D%E7%A7%B0%E5%92%8C%E5%AD%97%E9%9D%A2%E9%87%8F%E6%B1%82%E5%80%BC">代码字面量求值</a>得到。</p>
<h2 id="npla1-对象语言语法"><a class="header" href="#npla1-对象语言语法">NPLA1 对象语言语法</a></h2>
<p>　　基于 NPLA 基本语法约定参见 <a href="#npla-%E6%95%B4%E4%BD%93%E7%BA%A6%E5%AE%9A">NPLA 整体约定</a>。</p>
<p>　　NPLA1 表达式符合 <a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F">NPL 表达式语法</a>。</p>
<p><strong>注释</strong></p>
<p>　　<a href="#%E7%AE%80%E5%8D%95%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">NPL-GA</a>包含的<a href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90">转义规则</a>中包含 <code>&lt;char-escape-seq&gt;</code> 的 <code>&lt;char-seq&gt;</code> 要求类似 [R<sup>6</sup>RS] 在字符串中的元素；其中仅有 \ 和 " 被 [R<sup>5</sup>RS] 直接支持，而 [R<sup>7</sup>RS] 不支持 \v 。</p>
<p>　　后者支持的其它转义字符序列词法可被派生实现以 <code>&lt;$literal-char&gt;</code> 的形式另行指定（其中 [R<sup>7</sup>RS] 可涵盖对应 <code>&lt;char-escape-seq&gt;</code> 的功能）。</p>
<h3 id="npla1-字面量"><a class="header" href="#npla1-字面量">NPLA1 字面量</a></h3>
<p>　　基于 <a href="#npla-%E8%AF%8D%E6%B3%95%E5%92%8C%E8%AF%AD%E6%B3%95">NPLA 词法规则</a>，本节指定<a href="#%E5%AD%97%E9%9D%A2%E9%87%8F">字面量</a>的词素集合。</p>
<p>　　派生实现可指定不同的字面量，但不应和已指定词法构造的记号冲突，包括本节指定的字面量。</p>
<p>　　NPLA1 字面量都是<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>，但总是允许<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">实质化转换</a>为消亡值并引入允许<a href="#npla1-%E4%BA%92%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">互操作</a>的<a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>。</p>
<p><strong>注释</strong> 这和宿主语言的字符串字面量是左值不同。当前 NPLA1 对象语言不提供能引起互操作差异的接口（字符串字面量不被修改），以后可能改变。</p>
<h4 id="字符串字面量"><a class="header" href="#字符串字面量">字符串字面量</a></h4>
<p>　　字符串字面量的类型为 <a href="#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;string&gt;</code></a>。</p>
<h4 id="npla1-数值字面量"><a class="header" href="#npla1-数值字面量">NPLA1 数值字面量</a></h4>
<p>　　基于 <a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">NPLA 数值类型</a>和<a href="#npla-%E5%90%8D%E7%A7%B0%E5%92%8C%E5%AD%97%E9%9D%A2%E9%87%8F%E6%B1%82%E5%80%BC">数值字面量</a>，NPLA1 数值字面量的类型为 <code>&lt;number&gt;</code> 。</p>
<p>　　除非另行指定，数值的具体宿主类型未指定。</p>
<p><strong>注释</strong> 部分数值可指定具体的<a href="#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>。</p>
<p>　　NPLA1 支持 <code>&lt;integer&gt;</code> 类型的精确数数值字面量和 <a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">flonum</a> 不精确数数值字面量。</p>
<p>　　支持的字面量包括词素符合 NPLAMath <a href="#%E6%95%B0%E5%80%BC%E8%A1%A8%E7%A4%BA">数值表示</a>的字面量。</p>
<p>　　派生实现可定义其它数值字面量。</p>
<p><strong>注释</strong></p>
<p>　　以上字面量包含十进制数值的字面量。其它字面量是 <a href="#npla-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F">NPLA 扩展字面量</a>。</p>
<p>　　无限大值和 NaN 值同 <a href="https://docs.racket-lang.org/reference/numbers.html">[Racket] 的字面量词法</a>，除这些类型总是启用，且使用明确属于 flonum 且对应明确宿主类型的 long double 代替不被作为一般 flonum 的 extflonum 。</p>
<p>　　<a href="https://srfi.schemers.org/srfi-73/srfi-73.html">[SRFI-73]（已撤消）</a>提出扩展 [R<sup>5</sup>RS] 的带有 <code>#e</code> 或 <code>#i</code> 前缀的精确数和不精确数无限大值字面量，其中<a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">前缀及精确数的支持</a>和 [R<sup>n</sup>RK] 类似。NPLA1 不支持无限大值精确数。</p>
<p>　　关于无限大值的在 [R<sup>n</sup>RS] 的一些实现情形，另见<a href="https://people.csail.mit.edu/jaffer/III/RAWI">这里</a>。</p>
<h4 id="npla1-扩展字面量"><a class="header" href="#npla1-扩展字面量">NPLA1 扩展字面量</a></h4>
<p>　　NPLA1 支持 <a href="#npla-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F">NPLA 扩展字面量</a>作为部分数值字面量。</p>
<p>　　NPLA1 还支持以下以 <code>#</code> 起始的扩展字面量：</p>
<ul>
<li><code>#t</code> ：<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">布尔值</a>逻辑真，类型为 <code>&lt;boolean&gt;</code> 。</li>
<li><code>#f</code> ：布尔值逻辑假，<code>&lt;boolean&gt;</code> 。</li>
<li><code>#true</code> ：同 <code>#t</code> 。</li>
<li><code>#false</code> ：同 <code>#f</code> 。</li>
<li><code>#inert</code> ：类似 Kernel 的 <code>#inert</code> 字面量，</li>
<li><code>#ignore</code> ：类似 Kernel 的 <code>#ignore</code> 字面量。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　<code>#inert</code> 和 <code>#ignore</code> 类似 [R<sup>n</sup>RK] 。</p>
<p>　　从表达上，<code>#inert</code> 和 <code>#ignore</code> 仍都可以被视为特定<a href="#%E7%B1%BB%E5%9E%8B">单元类型</a>的值：等价的类型判断谓词可以直接使用值的相等关系确定。</p>
<p>　　和 [R<sup>n</sup>RS] 及 klisp 不同，不需要因兼容性支持扩展字面量中不同的大小写变体，特别是 [R<sup>6</sup>RS] 的 <code>#T</code> 和 <code>#F</code> 。</p>
<p>　　和 [R<sup>n</sup>RS] 类似而和 [R<sup>n</sup>RK] 不同，NPLA1 表达<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">结果</a>结果通常不依赖 <code>#inert</code> ，而直接使用<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">未指定值</a>。这避免用户必须引入 <code>#inert</code> 等具体的值实现相同隐式效果而违反<a href="#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99">关注点分离原则</a>。</p>
<p>　　尽管在接口意义上通常是不必要的，若有需要（如派生结果等效 <code>#inert</code> 的操作），<code>#inert</code> 的值仍可被显式使用。</p>
<p><strong>注释</strong></p>
<p>　　[R<sup>5</sup>RS] 和 [R<sup>n</sup>RK] 指定 <code>#t</code> 和 <code>#f</code> 。[R<sup>7</sup>RS] 指定同义的 <code>#true</code> 和 <code>#false</code>（参见 <a href="https://small.r7rs.org/ticket/219/">R<sup>7</sup>RS ticket 219</a> ）。</p>
<p>　　后者被认为可提供若干可读性，但<a href="https://small.r7rs.org/ticket/526/">具有冗余</a>。本文档中，以下不使用 <code>#true</code> 和 <code>#false</code> 替代 <code>#t</code> 和 <code>#f</code> 。</p>
<p>　　派生实现可扩展支持，提供非 <code>&lt;boolean&gt;</code> 类型的布尔值，使用与这些字面量不同的对应表示。</p>
<h3 id="npla1-函数合并"><a class="header" href="#npla1-函数合并">NPLA1 函数合并</a></h3>
<p>　　以下使用 <a href="#%E5%85%83%E6%96%87%E6%B3%95%E5%9F%BA%E6%9C%AC%E7%BA%A6%E5%AE%9A"><code>...</code></a>作为函数的操作数时，可支持没有操作数的<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>。此情形下应用表达式仍需要前缀 <code>()</code> ，但不在以下规约文法中显式地表示。</p>
<p><strong>注释</strong></p>
<p>　　和 Scheme 及 Kernel 不同，求值算法决定求值为<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并表达式</a>的语法表达不需要括号，且具有不同的<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6%E6%B1%82%E5%80%BC">函数合并形式</a>。</p>
<h2 id="对象语言内存安全保证"><a class="header" href="#对象语言内存安全保证">对象语言内存安全保证</a></h2>
<p>　　对象语言可能提供关于<a href="#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>的检查。</p>
<p>　　除非另行指定，假定实现进行<a href="#npla1-%E4%BA%92%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">互操作</a>无法保证内存安全。</p>
<h3 id="对象语言基本内存安全保证"><a class="header" href="#对象语言基本内存安全保证">对象语言基本内存安全保证</a></h3>
<p>　　对象语言提供关于内存安全的基本保证：不存在违反内存安全相关的要求以外的未定义行为（包括<a href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>等）、不存在不保证内存安全的互操作且不存在<a href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E9%97%B4%E6%8E%A5%E5%80%BC%E8%AE%BF%E9%97%AE">不安全间接值访问</a>时，对象语言的程序执行保证内存安全。</p>
<p>　　<a href="#%E9%9D%9E%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">非内存安全操作</a>在对象语言中以不安全间接值访问的一部分情形体现。</p>
<h3 id="不安全操作"><a class="header" href="#不安全操作">不安全操作</a></h3>
<p>　　<em>不安全(unsafe)</em> 操作是可能在程序的执行中引入<a href="#npla1-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">未定义行为</a>的<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作</a>。</p>
<p>　　这里的未定义行为包含在操作中直接引入的未定义行为，以及因为操作被执行而使程序在之后无法确保排除的未定义行为。</p>
<p>　　不安全操作是实现可选提供的。</p>
<p>　　当前对象语言不支持<a href="#npla-%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE">并发访问</a>对象。数据竞争仅可由和宿主语言的互操作引入。</p>
<h3 id="不安全间接值访问"><a class="header" href="#不安全间接值访问">不安全间接值访问</a></h3>
<p>　　对象语言的不安全<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值访问</a>包括：</p>
<ul>
<li>通过<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC">无效的间接值</a>的间接访问。</li>
<li>通过<a href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E5%BC%95%E7%94%A8%E5%80%BC">不安全引用值</a>的间接访问。</li>
<li>通过可能由实现定义的其它不安全间接值访问。</li>
</ul>
<h4 id="无效的环境引用"><a class="header" href="#无效的环境引用">无效的环境引用</a></h4>
<p>　　环境对象被销毁导致<a href="#%E7%8E%AF%E5%A2%83%E9%97%B4%E6%8E%A5%E5%80%BC">作为间接值的环境引用</a>被<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC">无效化</a>。</p>
<p><strong>注释</strong></p>
<p>　　另见<a href="#%E7%8E%AF%E5%A2%83%E7%94%9F%E5%AD%98%E6%9C%9F">环境生存期</a>。</p>
<h4 id="无效的引用值"><a class="header" href="#无效的引用值">无效的引用值</a></h4>
<p>　　<a href="#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">作为间接值的引用值</a>是间接值的实例，因此无效的间接值包含无效的<a href="#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>，通过无效间接值访问包括无效的引用值的访问。</p>
<p>　　对象语言不提供<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7">悬空引用</a>以外构造无效引用值的操作。</p>
<p>　　对象语言中可引入悬空引用的情形包括：</p>
<ul>
<li>调用可能返回引用值的合并子，且没有另行保存函数体求值所在的<a href="#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>，<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>对应的对象不在生存期内：
<ul>
<li>绑定到形式参数的<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">右值</a>保存在过程调用的<a href="#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">局部环境</a>中，退出<a href="#%E5%87%BD%E6%95%B0">函数体</a>的求值，局部环境被释放后，返回的其引用是悬空引用。</li>
<li>实现等效上述情形的派生操作的使用，如：
<ul>
<li><a href="#%E6%9C%AA%E6%B1%82%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">绑定列表</a><a href="#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">传递引用</a>且<a href="#npla1-%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">传递的引用值被求值</a>使用。</li>
<li>间接保留引用值可能提供变量绑定，这些绑定的目标对象可能依赖环境（如合并子的<a href="#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">静态环境</a>），被销毁时访问被依赖的环境（如合并子调用求值函数体）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　关于间接保留引用值和互操作可能引入悬空引用的情形，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>注释</strong></p>
<p>　　另见<a href="#npla1-%E5%BC%95%E7%94%A8">对象语言的引用值</a>。</p>
<h4 id="其它无效的间接值"><a class="header" href="#其它无效的间接值">其它无效的间接值</a></h4>
<p>　　使用其它不保证内存安全的操作可引入<a href="#%E9%A1%B9%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">不具有内存安全保证的间接值</a>访问实体。</p>
<p>　　这些间接值可能因为和<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7">悬空引用</a>相同的情形<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC">无效化</a>。</p>
<h3 id="保留间接值"><a class="header" href="#保留间接值">保留间接值</a></h3>
<p>　　对象的（直接或间接）<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>是间接值时，对象包含间接值。</p>
<p>　　<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>对象为间接值或使之包含间接值时，对象保留间接值。</p>
<p>　　被保留的间接值是对应的通过修改得到或包含的间接值。</p>
<p>　　本节中的概念对应适用于具体的间接值，如被保留的引用值和函数<a href="#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E7%9B%AE%E6%A0%87">在结果中保留引用值</a>。</p>
<h4 id="被保留的引用值的目标"><a class="header" href="#被保留的引用值的目标">被保留的引用值的目标</a></h4>
<p>　　<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>返回（在对象语言中允许出现的，下同）间接值或包含间接值的对象时，在<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>中保留间接值。</p>
<p>　　函数调用修改环境使<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境对象</a>保留间接值（绑定间接值或包含间接值作为子对象的对象作为<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>）时，在环境中保留间接值。</p>
<p>　　函数调用修改<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>或其子对象，使之保留间接值时，在对象中保留间接值。</p>
<p>　　在函数值中保留间接值、在环境中保留间接值、在对象中保留间接值的函数保留间接值。</p>
<p>　　被保留的间接值被函数调用的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>蕴含时，函数在结果中保留间接值。</p>
<p><strong>注释</strong></p>
<p>　　函数调用的<a href="#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">求值结果</a>排除<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>即函数值。</p>
<p>　　在结果中保留间接值包含以下情形：</p>
<ul>
<li>在函数值中保留间接值。</li>
<li>在环境中保留间接值，环境是函数值或其子对象。</li>
<li>在对象中保留间接值，对象是函数值的子对象。</li>
</ul>
<h4 id="被保留的引用值的来源"><a class="header" href="#被保留的引用值的来源">被保留的引用值的来源</a></h4>
<p>　　函数返回包含间接值的对象由参数的值决定时，保留参数中的间接值。</p>
<p>　　按被保留的间接值的来源，这分为以下两个子类：</p>
<ul>
<li>直接保留间接值：接受间接值参数。</li>
<li>间接保留间接值：接受的参数或参数在特定环境中被求值得到的结果决定是否直接保留间接值。
<ul>
<li><strong>注释</strong> 如合并子或构成<a href="#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">形式参数树</a>的可能带有<a href="#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">引用标记字符</a>的<a href="#%E7%AC%A6%E5%8F%B7">符号值</a>。</li>
</ul>
</li>
</ul>
<h4 id="保留间接值的操作"><a class="header" href="#保留间接值的操作">保留间接值的操作</a></h4>
<p>　　操作可保留间接值：</p>
<ul>
<li>使用函数调用实现的操作可通过<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>保留间接值。</li>
<li>其它实现方式可等效地保留间接值。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　在结果中保留间接值的操作不区分被保留的间接值的来源和目标。但多数情形下，这通过函数值保留参数中的间接值蕴含。</p>
<h4 id="保留间接值和内存安全"><a class="header" href="#保留间接值和内存安全">保留间接值和内存安全</a></h4>
<p>　　保留间接值操作的内存安全的一个必要条件是所有被保留的间接值在之后的使用中都满足内存安全。</p>
<p>　　保留间接值在操作后可能因<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值无效</a>（如<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7">悬空引用</a>），无法继续保证内存安全。</p>
<p>　　在环境中保留间接值时，应保证环境具有足够的生存期，以避免间接值依赖无效的环境引用导致访问环境中对象的未定义行为。</p>
<h3 id="对象语言接口的安全保证机制"><a class="header" href="#对象语言接口的安全保证机制">对象语言接口的安全保证机制</a></h3>
<p>　　对象语言接口的安全保证机制提供不同接口的分类，通过允许区分是否具有内存安全保证的接口帮助程序利用<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">对象语言基本内存安全保证</a>。</p>
<p>　　通过避免或限制使用<a href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">不安全操作</a>，实现上述安全保证。</p>
<p>　　因为允许引入 <a href="#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">NPLA 未定义行为</a>，无法提供安全证明的<a href="#npla1-%E4%BA%92%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">互操作</a>应视为不安全操作。</p>
<p>　　基于<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值算法</a>的安全保证的非形式的证明框架概述如下：</p>
<ul>
<li>任意步骤中，访问间接值指定的目标对象是安全的，仅当间接值是安全的。</li>
<li><a href="#%E7%AC%A6%E5%8F%B7">符号值</a>的求值是安全的，仅当引用的环境是安全的。</li>
<li>合并子调用的求值是安全的，仅当合并子、操作数及调用的操作是安全的。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　满足安全保证的推理如下：</p>
<ul>
<li>因为 NPLA 实现的非互操作引入的、非求值规约的<a href="#%E7%AE%A1%E7%90%86%E8%A7%84%E7%BA%A6">管理规约</a>不存在未定义行为，以上求值算法中的步骤中通过排除不安全的实体能保证规约中不存在未定义行为。</li>
<li>因为<a href="#%E8%A7%84%E7%BA%A6%E8%A7%84%E5%88%99%E5%92%8C%E6%B1%82%E5%80%BC">规约决定程序执行的语义</a>，在求值中排除不安全的实体可以保证不存在未定义行为，而满足安全保证。</li>
</ul>
<h4 id="安全性附加证明"><a class="header" href="#安全性附加证明">安全性附加证明</a></h4>
<p>　　一些不安全操作是否蕴含未定义行为可能依赖具体调用使用的操作数。</p>
<p>　　若能证明特定的前提保证任意的调用实例中的操作数满足附加的安全假设，则这些不安全操作的调用仍可保证安全。</p>
<p>　　排除不确保安全性假设的互操作时，NPLA1 提供附加调用安全：若不存在<a href="#%E9%9A%90%E8%97%8F%E7%8E%AF%E5%A2%83">隐藏环境</a>中绑定的可修改对象的引用，则仅因可能违反<a href="#%E8%A2%AB%E7%BB%91%E5%AE%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%80%BC%E5%92%8C%E5%8F%AF%E8%A7%82%E5%AF%9F%E8%A1%8C%E4%B8%BA">值稳定性</a>的不安全操作的调用是安全的。</p>
<p>　　派生实现可对特定调用附加使用限制以便提供证明，或定义其它的调用并提供更强的保证。</p>
<h2 id="诊断"><a class="header" href="#诊断">诊断</a></h2>
<p>　　NPLA1 的特定<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值步骤</a>可引起<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">诊断</a>。</p>
<p>　　引起诊断时<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>被终止，或在失败可被恢复时以其它派生实现定义的方式继续求值。</p>
<p>　　其它引起诊断的条件可被派生实现补充指定。</p>
<p><strong>注释</strong> 注意<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未定义行为</a>取消对诊断的要求。</p>
<p>　　本节以外的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">诊断消息</a>的其它形式未指定。</p>
<p><strong>注释</strong></p>
<p>　　引起诊断的求值包括：</p>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">抽象求值</a>的失败。
<ul>
<li>例如，REPL(read-eval-print loop) 中进行的翻译。</li>
</ul>
</li>
<li>在<a href="#npla1-%E7%8E%AF%E5%A2%83">环境</a>中访问指定名称的对象失败时。</li>
<li>特定的函数应用。</li>
</ul>
<p>　　其它求值条件详见具体操作的规定。</p>
<h3 id="npla1-错误"><a class="header" href="#npla1-错误">NPLA1 错误</a></h3>
<p>　　NPLA1 中的<a href="#%E9%94%99%E8%AF%AF">错误</a>是按接口的约定不符合预期的<a href="#%E5%BC%82%E5%B8%B8">正常条件</a>（如<a href="#%E9%94%99%E8%AF%AF%E6%A3%80%E6%9F%A5">不被正常处理的操作数类型</a>）引起的诊断。</p>
<p>　　求值特定的表达式可<a href="#%E9%94%99%E8%AF%AF">引起错误</a>，包括：</p>
<ul>
<li>违反<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值算法</a>步骤中的要求而直接引起的<em>语法错误(syntax error)</em> 。</li>
<li>其它情形引起的<em>语义错误(semantic error)</em> 。</li>
</ul>
<p>　　以<a href="#%E6%8E%A5%E5%8F%A3%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">接口文法约定</a>的形式约定的<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作</a>中，除<a href="#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>外，<a href="#%E7%BB%91%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96">绑定初始化</a>之前的<a href="#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">参数绑定</a>失败是语法错误。</p>
<p>　　语法错误包含两类：</p>
<ul>
<li>总是依赖程序运行时确定的值不满足特定操作的要求引起动态语法错误。</li>
<li>其它语法错误违反<a href="#%E6%AD%A3%E7%A1%AE%E6%80%A7">语法正确性</a>要求，是静态语法错误。</li>
</ul>
<p>　　类似地，语义错误包含两类：</p>
<ul>
<li>总是依赖程序运行时确定的值不满足特定操作的要求引起动态语义错误。</li>
<li>其它语义错误违反<a href="#%E6%AD%A3%E7%A1%AE%E6%80%A7">语义正确性</a>要求，是静态语义错误。</li>
</ul>
<p>　　静态语法错误可能通过语法分析从源代码决定。</p>
<p>　　引起动态语法错误或动态语义错误依赖的值是合并子的具体实际参数的值，以及派生实现可选指定的其它的值。</p>
<p>　　引起动态语法错误或动态语义错误的情形包括求值特定的函数应用，由具体操作指定。</p>
<p>　　程序可通过<em>引发(raise)</em> 一个<em>错误对象(error object)</em> 指定引起诊断。</p>
<p>　　除非另行指定，NPLA1 的错误对象不需要是 NPLA1 支持的<a href="#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">对象</a>，而可以仅在<a href="#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>中可见。</p>
<p>　　因果性引起的错误可构成错误之间具有依赖关系。</p>
<p>　　错误对象的其它具体形式由派生实现指定。</p>
<h3 id="npla1-异常"><a class="header" href="#npla1-异常">NPLA1 异常</a></h3>
<p>　　NPLA1 的当前诊断使用的<a href="#%E5%BC%82%E5%B8%B8">异常</a>执行机制由宿主语言支持，通过宿主语言中的异常类型区分不同的异常条件。</p>
<p>　　NPLA1 约定的所有要求引起异常的诊断情形都是错误。</p>
<p><strong>注释</strong> 用户操作引起异常不一定是错误。</p>
<p>　　不引起未定义行为的翻译失败应<a href="#%E5%BC%82%E5%B8%B8">抛出异常</a>。</p>
<p>　　<a href="#npla1-%E9%94%99%E8%AF%AF">引发错误对象</a>可能通过抛出异常实现。此时，被抛出的宿主语言异常对象是错误对象。被抛出的异常类型可具有被显式指定的 <code>public</code> 基类，这些基类应无歧义以允许宿主语言捕获。</p>
<p>　　若存在<a href="#npla1-%E9%94%99%E8%AF%AF">依赖错误</a>且引发被依赖的错误对象使用抛出异常实现，使用宿主语言标准库的<em>嵌套异常(nested error)</em> 机制实现依赖错误。</p>
<p>　　当前没有提供相关操作，但抛出的宿主异常在具有<a href="#%E8%A1%A8%E7%A4%BA">表示</a>的意义上是 NPLA1 的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>。</p>
<p>　　关于抛出异常的<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>，参见项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h3 id="运行时错误条件"><a class="header" href="#运行时错误条件">运行时错误条件</a></h3>
<p>　　除非另行指定，实现应对以下全局的<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">运行时</a><a href="#%E9%94%99%E8%AF%AF">错误条件</a>按要求引起诊断。</p>
<p>　　当实现无法提供需要的资源，<em>资源耗尽(resource exhaustion)</em> 。此时，引发特定的关于资源耗尽的错误对象。</p>
<p>　　除非另行指定，上述表示资源耗尽的错误对象满足宿主语言的以下类型的异常对象：</p>
<ul>
<li>宿主资源耗尽时，异常类型满足<a href="#%E5%B8%B8%E8%A7%84%E5%AE%BF%E4%B8%BB%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E8%A6%81%E6%B1%82">常规宿主资源分配要求</a>的类型。</li>
<li>否则，同<a href="#npla1-%E5%BC%82%E5%B8%B8">异常</a>。</li>
</ul>
<p><strong>注释</strong> [ISO C++] 的本机实现宿主资源耗尽时，一般抛出派生 <code>std::bad_alloc</code> 的异常对象。这不包括<a href="#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">本机实现无法提供资源的未定义行为</a>。</p>
<h3 id="错误检查"><a class="header" href="#错误检查">错误检查</a></h3>
<p>　　<em>检查(check)</em> 是限定成功的操作应满足的（必要非充分）条件引起诊断的操作。检查失败时要求引起诊断。</p>
<p>　　<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">良定义的</a>检查应具有<a href="#%E8%8C%83%E5%BC%8F">强规范化性质</a>，以保证有限数量的检查总在有限的计算步骤内终止。在进行检查的<a href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">上下文</a>，实现假定检查良定义。</p>
<p><strong>注释</strong> 实现不需在此之前对检查的这个性质附加检查。</p>
<p>　　检查条件限定检查的通过或失败。除非另行指定，通过的检查没有<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>，失败时总是具有作用。</p>
<p><strong>注释</strong> 检查失败通常可引起<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>。</p>
<p>　　NPLA1 要求在特定上下文进行<a href="#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>。派生实现可定义其它检查。</p>
<p>　　函数操作的语义可单独指定检查，具体形式由具体操作指定。</p>
<h4 id="npla1-类型检查"><a class="header" href="#npla1-类型检查">NPLA1 类型检查</a></h4>
<p>　　基于<a href="#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义类型</a>，对象语言实现应具有语义规则指定的<a href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>，以确保程序的执行符合操作的必要前置条件。</p>
<p>　　操作的语义可要求以下的类型检查：</p>
<ul>
<li>对<a href="#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">求值得到的操作数</a>，按<a href="#%E6%8E%A5%E5%8F%A3%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">文法约定</a>的约束进行类型检查。</li>
<li>根据特定对象状态，指定<a href="#%E7%B1%BB%E5%9E%8B">动态类型</a>的检查。
<ul>
<li><strong>注释</strong> 可通过类型检查规则明确要求对象具有特定的属性，例如<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">可修改</a>。</li>
</ul>
</li>
</ul>
<p>　　实现可能添加其它不违反语义要求的类型检查。</p>
<p>　　基于<a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B">表达式的类型</a>，对应对象语言表达式的表示实体的元素可指定操作数上明确的类型要求。</p>
<p>　　部分实体从属于其它实体类型而构成<a href="#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>关系；部分的规约操作取得求值结果保证结果中的值可能具有的特定类型集合，这些类型也一并在以下描述中给出；其它情形不指定类型。</p>
<p>　　规约预期符合约束。若违反由项的表示的对象的动态类型不匹配导致，则求值失败；否则，行为未指定。</p>
<p>　　类型检查的完成应<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序</a>依赖被检查特定类型的值的访问。</p>
<p>　　除非另行指定，类型检查和程序中的其它作用（包括不同的其它类型检查）的顺序未指定。</p>
<p>　　<a href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型错误</a>引发错误对象。</p>
<p>　　若<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">合并子调用</a>不接受<a href="#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">非真列表</a>参数构成<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>，检查参数是<a href="#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>，即<em>参数列表(parameter list)</em> 。对参数列表的类型检查的完成应先序于其中任意子表达式的求值。</p>
<p><strong>原理</strong></p>
<p>　　类型检查有助于维护程序的正确性，并及早发现编程错误。</p>
<p>　　但是，类型检查自身存在开销；在一个阶段中集中检查类型的限制不是必要的。特别地，<a href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">静态类型检查</a>不被要求。</p>
<p>　　这些设计同时确保程序容易在程序在实现的不同<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">执行阶段</a>重现相同的检查逻辑乃至直接复用其实现。</p>
<p>　　为减小开销等目的，实现可能合并不同类型检查，而不改变程序的<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>。</p>
<p>　　对子表达式的求值需<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>子表达式。因此，对参数列表的检查蕴含顺序要求。</p>
<p><strong>注释</strong></p>
<p>　　一个值可被多次针对不同的对象进行类型检查。</p>
<p>　　不同的类型检查中，对特定类型的值的访问之间没有必然的隐含联系。</p>
<h2 id="npla1-外部表示"><a class="header" href="#npla1-外部表示">NPLA1 外部表示</a></h2>
<p>　　<a href="#%E8%A1%A8%E7%A4%BA">外部表示</a>若被确定，由实现和派生实现定义。</p>
<p>　　NPLA1 不要求对象和其它实体存在外部表示，也不要求外部表示唯一。</p>
<p><strong>注释</strong></p>
<p>　　对外部表示的存在性要求和 [R<sup>n</sup>RK] 不同。</p>
<p>　　NPLA1 当前直接使用其它已被指定的表示规则，如<a href="#npla1-%E4%BA%92%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">互操作</a>隐含的宿主语言对象表示。</p>
<p>　　NPLA1 当前不提供可移植的互操作接口（包括一些基本 I/O 操作），也不约定其涉及的外部表示形式。</p>
<h2 id="表达式语义"><a class="header" href="#表达式语义">表达式语义</a></h2>
<p>　　表达式具有和<a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F">语法构造</a>不直接相关的且可能<a href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">上下文相关</a>的语义。</p>
<p>　　部分语义不需要通过<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>体现。</p>
<h3 id="npla1-规范求值算法"><a class="header" href="#npla1-规范求值算法">NPLA1 规范求值算法</a></h3>
<p>　　以<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">被求值的表达式</a>和所在的环境作为参数，NPLA1 使用以下<em>规范(canonical)</em> 求值算法取得表达式的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>：</p>
<ol>
<li><a href="#%E8%8C%83%E5%BC%8F">自求值</a>：若被求值的表达式不是<a href="#%E7%AC%A6%E5%8F%B7">符号值</a>且不是<a href="#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">有序对</a>，则求值结果是自身。</li>
<li><a href="#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>：若被求值的表达式是一个符号值，则被视为<a href="#npla-%E7%8E%AF%E5%A2%83">变量名</a>，求值结果是它在<a href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">上下文</a>（当前环境确定的<a href="#%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83%E6%8F%90%E4%BE%9B%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">词法作用域</a>）中变量绑定确定的对象的经<a href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">引用折叠</a>的<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B">左值引用</a>。</li>
<li>否则：
<strong>注释</strong> 被求值的表达式是有序对。
<ol>
<li>若被求值的表达式是具有一个<a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">元素</a>（<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">子表达式</a>）的<a href="#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">列表</a>，则求值结果是这个子表达式的求值结果。否则，继续以下求值步骤。
<strong>注释</strong> 被求值的表达式是具有不少于一个元素的列表或非真列表。</li>
<li>若被求值的表达式第一个子表达式是空列表，则移除，并继续以下求值。
<strong>注释</strong> 起始空列表的语法用于继续求值可能不提供<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">实际参数</a>的<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>。具有实际参数的函数合并不一定需要起始空列表。</li>
<li>对第一个子表达式求值。</li>
<li>以第一个子表达式的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值计算</a>的求值结果作为<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作符</a>，以其余子表达式作为操作数，求值<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">合并</a>。</li>
</ol>
</li>
</ol>
<p>　　有序对以外的表达式被求值时：</p>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">标识符</a>的值是构成标识符的符号值。</li>
<li><a href="#%E5%AD%97%E9%9D%A2%E9%87%8F">代码字面量</a>的值是去除其边界的 <code>'</code> 的标识符构成的符号值。
<strong>注释</strong> 代码字面量可表达直接作为标识符时不能作为符号值的词素的转义，例如 <code>''</code> 是一个空的符号值；而 <code>'#ignore'</code> 和 <code>42</code> 这样的形式允许其中的表达作为变量名，而不是字面量。</li>
<li><code>#t</code> 和 <code>#f</code> 求值为自身，是<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">布尔值</a>。</li>
<li><code>#ignore</code> 和 <code>#inert</code> 求值为自身，具有和其它值不同的<a href="#%E7%B1%BB%E5%9E%8B">单元类型</a>。</li>
<li>数值字面量求值为<em>数值(numerical value)</em> 。</li>
</ul>
<p>　　<a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">非空列表</a>和代码字面量以外的对象作为表达式，都是<a href="#%E8%8C%83%E5%BC%8F">自求值表达式</a>。</p>
<p><strong>原理</strong></p>
<p>　　NPLA1 规范<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>和 [R<sup>n</sup>RK] 中定义的 Kernel 求值算法（以及 [Shu10] 中定义的 <a href="#%E5%85%B6%E5%AE%83%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8F%82%E8%80%83">vau 演算</a>）类似，差异为：</p>
<ul>
<li>求值算法不直接约定取得 <a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">WHNF</a> 以外的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">子项</a>是否被求值，而由被调用的第一个子项决定。</li>
<li><a href="#%E8%AE%B0%E5%8F%B7%E6%B1%82%E5%80%BC">对符号值的求值</a>包含对<a href="#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>的区分。</li>
<li>要求一个子项的列表总是使用其列表元素求值。</li>
</ul>
<p>　　最后一个差异在对象语言中是实质性的，它决定<a href="#%E5%88%97%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">列表表达式</a>和其中的<a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F">子表达式</a>的求值总是等价。</p>
<p>　　求值算法保持<a href="#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>。</p>
<p>　　NPLA1 翻译单元中，未求值的表达式满足以下性质：</p>
<ul>
<li>作为<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">记号</a>的标识符是<a href="#%E7%AC%A6%E5%8F%B7">符号</a>类型的值。</li>
<li><a href="#%E5%88%97%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">列表表达式</a>中若不含有<a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F">子表达式</a>，则这个表达式是<a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">空列表</a>；否则，是非空的<a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>，子表达式是它的<a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">元素</a>。</li>
</ul>
<p>　　NPLA1 规范求值算法和 [R<sup>n</sup>RK] 的求值算法具有近似的简单性。</p>
<p>　　因为 NPLA1 <a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">不支持存在环的非真列表</a>，<a href="#%E6%9C%89%E5%BA%8F%E5%AF%B9">cons 对</a>的描述被对应替换。</p>
<p>　　求值算法使用的环境同 [R<sup>n</sup>RK] 。</p>
<p>　　同 [R<sup>n</sup>RK] ，而非 [R<sup>n</sup>RS] ，NPLA1 规范求值算法避免对<em>顶层(top-level)</em> 的特殊引用，以避免<a href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">上下文相关性</a>的不同规则带来的复杂性和限制。</p>
<p>　　使用顶层的不同求值规则的限制可能简化一些编译实现需要的假设。但这泄漏了抽象，且在实际使用中<a href="https://gist.github.com/samth/3083053">引起大量问题</a>。</p>
<p>　　特别地，不同的顶层的特设规则相对更动态，反映<a href="https://calculist.blogspot.com/2009/01/fexprs-in-scheme.html">一些用户对 fexpr 的期望</a>，但在此这已被 vau 抽象替代。因此，使用不同的顶层求值规则以提供更强的动态性是多余的。</p>
<p>　　另一方面，当前环境一般允许被<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">具现</a>为<a href="#npla-%E7%8E%AF%E5%A2%83">一等环境</a>在程序中可编程地访问而代表求值算法使用的上下文。为不同的上下文特设不同的顶层求值规则也是多余的。</p>
<p>　　关于实现，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p>　　以下各节补充描述 NPLA1 规范求值算法的局部性质。</p>
<p><strong>注释</strong></p>
<p>　　关于 WHNF 求值在 Kernel 中的描述，参见 [R<sup>n</sup>RK] 关于 <code>unwrap</code> 的 Rationale 的描述。</p>
<p>　　语法分析器的实现应使结果取得和这些性质兼容的中间表示。</p>
<h4 id="函数合并求值"><a class="header" href="#函数合并求值">函数合并求值</a></h4>
<p>　　求值算法向函数合并传递当前环境作为<a href="#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">函数合并的动态环境</a>。</p>
<p>　　为支持没有操作数的函数应用，需约定其它表达式表达求值为<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并的应用表达式</a>：</p>
<ul>
<li>当<a href="#%E5%A4%8D%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F">复合表达式</a>的第一个子表达式是空列表（<code>()</code>）时，求值为一个函数合并。
<ul>
<li><strong>注释</strong> 对没有操作数的情形，这是唯一被直接支持函数应用的语法</li>
</ul>
</li>
<li>否则，求值的作用同移除第一个子项 <code>()</code> 后的剩余形式。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　关于区分函数类型的替代设计（使用 <code>$</code> 作为第一个<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">子项</a>）的一个例子，参见<a href="https://eighty-twenty.org/2011/09/29/fexprs-remain-inscrutable#comment-422279775">这里</a>。</p>
<p>　　基于其中类似的对语义的影响（区分函数合并是否针对一个操作子）上的理由，这不被使用。</p>
<p>　　与此不同，尽管在对象语言中接受 <code>()</code> 的使用也需要求值算法的显式支持，这在目的上是纯语法意义上的——仅在无法避免语法歧义时，才必须使用。</p>
<p>　　只要能确定求值算法使用的环境，就能静态地区分复合表达式是否是函数合并。此时，其中的第一个子表达式是否显式为 <code>()</code> 不影响关于语义的推理。使用不同的内部中间表示可完全消除是否使用 <code>()</code> 的函数合并的差异；或者，也可以约定在代码中默认使用第一个子项是 <code>()</code> 的表达式作为函数合并的规范形式，而把第一个子项不是 <code>()</code> 的形式视为隐含 <code>()</code> 的语法糖。</p>
<p>　　因此，相对使用 <code>$</code> 而言，使用 <code>()</code> 的设计具有更少的缺陷（尽管需要更多的字符）。</p>
<h4 id="空列表求值"><a class="header" href="#空列表求值">空列表求值</a></h4>
<p>　　空列表 <code>()</code> 作为表达式是自求值表达式，而不是没有函数的空过程调用。</p>
<p><strong>原理</strong></p>
<p>　　关于 <code>()</code> 的求值规则避免这种简洁有用的语法导致<a href="#npla1-%E9%94%99%E8%AF%AF">语法错误</a>。</p>
<p><strong>注释</strong></p>
<p>　　这和 [R<sup>n</sup>RS] 不同而同 [R<sup>n</sup>RK] 。在前者构造空列表需要 <code>'()</code> 。</p>
<p>　　和 Kernel 不同的函数合并求值规则使这个设计和函数求值字面上没有直接的关联，避免了 Kernel 中为什么 <code>()</code> 不是词法上类似的如 <code>(f x)</code> 这样的表达式的特例的问题。</p>
<p>　　注意以 <code>()</code> 作为前缀并不要求要求特定函数的子类型而可能破坏子类型<a href="#%E5%B0%81%E8%A3%85">封装性</a>的假设。</p>
<h4 id="记号求值"><a class="header" href="#记号求值">记号求值</a></h4>
<p>　　具有不同大小写字符的标识符不同。</p>
<p>　　可使用（能在求值时作为名称的）<a href="#npla-%E5%90%8D%E7%A7%B0%E5%92%8C%E5%AD%97%E9%9D%A2%E9%87%8F%E6%B1%82%E5%80%BC">代码字面量</a>即 '' 分隔）表达没有分隔符时被解释为字面量或其它值的符号值。</p>
<p>　　<a href="#npla-%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B">符号值</a>作为<a href="#%E5%90%8D%E7%A7%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">名称表达式</a>，经<a href="#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>求值，访问当前环境中的<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>。</p>
<p>　　其中，若被绑定对象是<a href="#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>，结果是<a href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">被折叠一次</a>的引用值；否则，结果是被绑定对象作为<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的引用值。</p>
<p>　　求值的结果是确保为<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>引用值。</p>
<p>　　结果不继续特别处理。引用值在此作为<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>，作为表达式时<a href="#%E9%BB%98%E8%AE%A4%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2%E7%BA%A6%E5%AE%9A">不发生左值到右值转换</a>。</p>
<p><strong>注释</strong></p>
<p>　　标识符大小写敏感的设计和 [R<sup>5</sup>RS] 及 klisp 不同，而和 [R<sup>6</sup>RS] 相同。和 [R<sup>7</sup>RS] 的默认行为相同，但不提供切换大小写不敏感的方法。</p>
<p>　　代码字面量和 klisp 使用 <code>||</code> 作为分隔符的语法不同，但作用类似。</p>
<p>　　和 klisp 不同，NPLA1 允许使用 <code>.</code> 作为<a href="#npla-%E7%8E%AF%E5%A2%83">变量名</a>，但在特定的上下文不被求值时符号值 <code>.</code> 可被特别处理，如<a href="#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">绑定匹配</a>时忽略以 <code>.</code> 为符号值的绑定。</p>
<p>　　和 klisp 不同，NPLA1 允许使用 <code>++</code> 等全以 <code>+</code> 或 <code>-</code> 组成的字符序列构成标识符。</p>
<p>　　以 <code>#</code> 、<code>+</code> 或 <code>-</code> 起始的不能构成标识符的词素是 <a href="#npla-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F">NPLA 扩展字面量</a>。</p>
<h3 id="对象语言求值算法"><a class="header" href="#对象语言求值算法">对象语言求值算法</a></h3>
<p>　　除非另行指定，NPLA1 对象语言的求值总是使用 <a href="#npla1-%E8%A7%84%E8%8C%83%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">NPLA1 规范求值算法</a>。</p>
<p>　　在输入求值算法接受的语法形式之前，求值使用基于<a href="#%E4%B8%AD%E7%BC%80%E8%AF%AD%E6%B3%95">中缀语法</a>识别的分隔符进行处理。</p>
<p>　　由此引起的其它语法差异参见<a href="#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>。</p>
<h4 id="中缀语法"><a class="header" href="#中缀语法">中缀语法</a></h4>
<p>　　NPLA1 提供符合特定谓词指定的过滤条件的中缀分隔项替换为特定<a href="#%E5%90%8D%E7%A7%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">名称表达式</a>指定的前缀操作形式的列表。</p>
<p>　　这些中缀变换作为预处理操作，可识别和接受 <a href="#%E8%AF%AD%E5%8F%A5">NPL-GA 语法</a>外的记号，即转换扩展的 <a href="#%E7%AE%80%E5%8D%95%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">NPL-GA 文法</a>输入为严格的 NPL-GA 语法要求的源语言。</p>
<p>　　中缀变换递归替换构成表达式的形如 <code>&lt;expression&gt; (&lt;infix&gt; &lt;expression&gt;)*</code> 的记号序列为 <code>&lt;transformed-infix&gt; &lt;expression&gt;+</code> 形式的记号序列。</p>
<p>　　其中，被支持的中缀记号 <code>&lt;infix&gt;</code> 是 <code>;</code> 或 <code>,</code> ，而 <code>&lt;transformed-infix&gt;</code> 是语法不可见的中缀变换函数。</p>
<p>　　其中，分隔符 <code>,</code> 优先组合。</p>
<p>　　分隔符对应的 <code>&lt;transformed-infix&gt;</code> 分别表示对被分隔的序列参数进行有序和无序列表求值（替换后合并子功能对应<a href="#npla1-%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83">参照实现环境</a>中函数 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$sequence</code></a> 和 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>list%</code></a> 求值后的合并子）。</p>
<p>　　对分隔符的处理使用和组合顺序相反的两遍分别对 <code>;</code> 和 <code>,</code> 遍历替换。</p>
<p>　　变换的不同 <code>&lt;expression&gt;</code> 的实例以相同的词法顺序在变换后的结果中被保存。</p>
<h4 id="求值算法实现风格"><a class="header" href="#求值算法实现风格">求值算法实现风格</a></h4>
<p><strong>原理</strong></p>
<p>　　和 Scheme 不同而和 Kernel 类似，求值通常使用显式的风格（详见 [Shu10] ）而不是依赖 <code>quote</code> 的隐式风格；这和不需要括号的语法特性无关。</p>
<h3 id="值类别和类型"><a class="header" href="#值类别和类型">值类别和类型</a></h3>
<p>　　基本内容参见 <a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">NPLA 值类别</a>和<a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B">表达式的类型</a>。</p>
<p>　　特定的表达式维护<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">可修改性</a>。</p>
<p><strong>注释</strong> 这类似宿主语言的 <code>const</code> 类型限定，但只适合<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>且仅使用<a href="#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">隐式类型</a>。</p>
<p>　　特定的操作集合可约定关于确定结果值类别和类型的具体规则，如<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E7%BA%A6%E5%AE%9A">子对象访问约定</a>。</p>
<h3 id="绑定操作"><a class="header" href="#绑定操作">绑定操作</a></h3>
<p>　　绑定操作决定<a href="#%E7%AC%A6%E5%8F%B7">符号值</a>或具有符号值的数据结构与项的对应关系，并<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a><a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>而引入<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">变量</a>。</p>
<p>　　作为<a href="#%E5%87%BD%E6%95%B0">函数语法</a>的推广，两者分别由绑定操作使用<a href="#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">形式参数</a>和<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数</a>指定。</p>
<p>　　操作数的<a href="#%E8%A1%A8%E7%A4%BA">表示</a>具有树的构造，即<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数树</a>。</p>
<p>　　为决定形式参数对应的操作数，形式参数和操作数树或它们的<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的结构被比较，即绑定<em>匹配(match)</em> 。匹配操作数树的形式参数对应也可具有树的构造，即<em>形式参数树(formal parameter tree)</em> 。</p>
<p>　　被匹配的操作数是操作数树作为<a href="#%E6%9C%89%E5%BA%8F%E5%AF%B9">有序对</a>的<a href="#%E6%9C%89%E5%BA%8F%E5%AF%B9">元素</a>。类似地，形式参数是形式参数树作为有序对的元素。</p>
<p>　　绑定操作初始化对应的变量的名称和值分别由形式参数树和操作数树决定。</p>
<p>　　NPLA1 形式参数树具有特定的语法规则：树的叶节点为<a href="#%E7%AC%A6%E5%8F%B7">符号值</a>、符号的<a href="#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>或其它形式参数树构成的 <a href="#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">DAG</a> 。若构造的形式参数树不符合语法规则，<a href="#%E9%94%99%E8%AF%AF">引起错误</a>，不进行绑定。</p>
<p>　　成功的匹配决定形式参数对应的操作数或其<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">子项</a>，作为其<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">实际参数</a>。这种对应关系是单射但不一定是满射，即匹配成功后，每个参数总存在对应的操作数或其子项，而操作数和子项允许不对应形式参数而被忽略。</p>
<p>　　被绑定的项的操作数中的元素对应是<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">项</a>中的元素。</p>
<p>　　形式参数树中的引用值可能被间接访问其<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>一次，其余元素在匹配时被<a href="#%E9%BB%98%E8%AE%A4%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2%E7%BA%A6%E5%AE%9A">视为右值</a>。</p>
<p>　　绑定操作符合以下节的绑定规则。</p>
<p><strong>原理</strong></p>
<p>　　被绑定的参数可作为函数的形式参数。绑定操作对形式参数的处理也可以作为其它初始化变量的语法构造的基础。</p>
<p>　　作为推广，绑定操作也可以引入函数的形式参数以外的变量。</p>
<p><strong>注释</strong></p>
<p>　　形式参数树的节点可以是符号的引用值，但不支持<a href="#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">多重引用</a>。</p>
<p>　　关于对形式参数树的具体的语法要求，另见 <a href="#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0"><code>&lt;ptree&gt;</code> 的定义</a>。</p>
<p>　　因为 NPLA1 支持的<a href="#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>都具有<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>的形式，操作数或其子项总能直接被作为函数的实际参数。</p>
<p>　　DAG 要求和 Kernel 类似。</p>
<p>　　和 Kernel 不同，操作数树同时支持作为<a href="#%E5%BC%95%E7%94%A8%E5%80%BC">引用</a>的<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>和非引用的<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">右值</a>，在实现上需要解析引用。</p>
<h4 id="绑定初始化"><a class="header" href="#绑定初始化">绑定初始化</a></h4>
<p>　　绑定的对象节点的值和子节点元素被<a href="#%E5%A4%8D%E5%88%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96">复制初始化</a>。</p>
<p>　　绑定前不对形式参数或实际参数中的元素求值。</p>
<p>　　除非另行指定，不同变量的绑定初始化之间<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">非决定性有序</a>。</p>
<p>　　绑定初始化不<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>形式参数，但可能因<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化转移初值符而修改操作数</a>。</p>
<p><strong>注释</strong></p>
<p>　　初始化元素类似宿主语言的参数传递中可发生初始化。</p>
<p>　　若形式参数或实际参数可能由求值得到，需在匹配前另行处理。</p>
<p>　　由<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">非决定性规约规则</a>，一般地，变量仅通过初值的求值决定的<a href="#%E9%80%92%E5%BD%92%E8%95%B4%E5%90%AB%E8%A7%84%E5%88%99">依赖关系</a>及<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>决定之间初始化的相对顺序。</p>
<p>　　因为绑定的初始化不负责实际参数的求值，一般地，即使初值符位于相邻的语法构造，也不保证隐含顺序；这和宿主语言不同。</p>
<p>　　初始化的顺序规则和宿主语言初始化不同的函数参数类似。</p>
<h4 id="绑定临时对象"><a class="header" href="#绑定临时对象">绑定临时对象</a></h4>
<p>　　被绑定的<a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>不具有<a href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">临时对象属性</a>。</p>
<p><strong>原理</strong></p>
<p>　　因为<a href="#%E8%AE%B0%E5%8F%B7%E6%B1%82%E5%80%BC">记号求值</a>保证求值<a href="#%E7%AC%A6%E5%8F%B7">符号值</a>是左值，被绑定的对象<a href="#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>最终得到的引用值不包含<a href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">唯一引用属性</a>。</p>
<p>　　这不清除绑定临时对象引入到表示被绑定对象的项或引用值中的<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">其它属性</a>，因此其它属性可跟随一等对象<a href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">被跨过程传递</a>（若不经过<a href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>或其它操作）。</p>
<p>　　同<a href="#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">绑定临时对象属性</a>的讨论，被传递的属性类似宿主语言的指定转发引用参数类型，以下记作 <code>P</code> 。</p>
<p>　　特别地，被传递的属性包含临时对象属性。这对应宿主语言中 <code>P</code> 是左值引用。</p>
<p>　　<a href="#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">跨过程传递并不被宿主语言支持</a>。因此，一般仅限为了实现类似宿主语言的根据值类别和类型转发参数的<em>转发上下文(forwarding context)</em> 中使用。</p>
<p>　　通过从传递的属性中提取的<a href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">标签</a>访问引用<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用值的属性</a>代替保存<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境引用</a>并以其它底层的方式查询作为<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的被绑定对象的元数据能以更低的开销实现一些常见的相同的目的，如判断被引用对象是否表示可被转移的资源。</p>
<p>　　另见<a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%A8%E7%A4%BA">临时对象的表示</a>、<a href="#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">非递归绑定</a>和<a href="#%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">递归绑定</a>。</p>
<p><strong>注释</strong></p>
<p>　　使用<a href="#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">引用标记字符</a>可保留来自引用值实际参数的作为引用值属性的临时对象属性。</p>
<p>　　使用引用标记字符 <code>&amp;</code> 可启用转发推断值类别。</p>
<h4 id="绑定匹配"><a class="header" href="#绑定匹配">绑定匹配</a></h4>
<p>　　绑定匹配以一个形式参数树和操作数树作为输入，比较两者的结构并尝试关联形式参数树中的子项到操作数蕴含的对象，以<a href="#%E7%BB%91%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96">创建变量绑定</a>。</p>
<p>　　若绑定匹配成功，则可能进行以符号值为名称的对应变量的<a href="#%E7%BB%91%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96">绑定初始化</a>；否则，绑定匹配失败，引起错误。</p>
<p>　　绑定匹配确定每一个符号值的过程<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序</a>这个符号值确定的变量的绑定初始化。</p>
<p>　　绑定匹配不<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>形式参数，在匹配成功进行绑定初始化前不修改操作数。</p>
<p>　　匹配使用如下算法搜索形式参数树和操作数的对应位置：</p>
<ul>
<li>初始化输入的形式参数树为当前形式参数，函数合并构成的操作数树作为当前操作数。</li>
<li>对每一对当前形式参数和当前操作数，比较两者（除非另行指定，操作数的值是引用值的，视为匹配<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>，下同）：
<ul>
<li>若两者都是有序对，则：
<ul>
<li>若形式参数有序对元素的结尾元素不是符号也不是有序对，则参数匹配失败。</li>
<li>若形式参数是列表，且元素的结尾元素是以 <code>.</code> 起始的符号值，则存在<em>省略(ellipsis)</em> ；保存移除	<code>.</code> 的符号值，并从子项中移除结尾元素，继续进行比较。</li>
<li>若形式参数和操作数的（直接）<a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">前缀元素</a>数相等，或存在省略时移除结尾元素后的形式参数前缀元素数不大于操作数子节点的元素数，则：
<ul>
<li><strong>注释</strong> 直接比较前缀元素数，不计算有序对的非前缀元素是引用值且其被引用对象是非空列表时具有的元素数。</li>
<li>忽略形式参数中的省略的元素，以深度优先搜索从左到右逐一递归匹配两者的元素。</li>
<li>若存在省略的元素，若保存移除 <code>.</code> 的符号值非空，以移除 <code>.</code> 的符号值作为形式参数，匹配操作数构成的<em>结尾序列(trailing sequence)</em> 。</li>
<li>否则，若形式参数是非列表的有序对（最后的元素非空），匹配结尾序列。
<ul>
<li><strong>注释</strong> 结尾序列支持匹配有序对操作数的非前缀元素。这个元素可能是引用值，它的被引用对象被作为操作数继续匹配并进行<a href="#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">非递归绑定</a>。</li>
</ul>
</li>
<li>否则，若所在的形式参数列表的结尾元素是 <code>.</code> ，参数匹配成功，忽略结尾序列，不绑定对象。</li>
<li>否则，没有其余元素需要匹配，参数匹配成功。
<ul>
<li><strong>注释</strong> 先前对形式参数和操作数的节点数判断同时确保结尾序列为空。</li>
</ul>
</li>
<li>匹配结尾序列的规则参见非递归绑定。
<ul>
<li><strong>注释</strong> 结尾序列预期匹配的操作数是空列表或有序对。对操作数是列表的情形，结尾序列是<em>结尾列表(trailing list)</em> 。</li>
</ul>
</li>
</ul>
</li>
<li>否则，若不存在省略，列表的元素数不相等，参数匹配失败。</li>
<li>否则，操作数的子节点不足，参数匹配失败。</li>
</ul>
</li>
<li>若形式参数是空列表，则：
<ul>
<li>若实际参数不是空列表，则参数匹配失败。</li>
<li>否则，参数匹配成功。</li>
</ul>
</li>
<li>若形式参数是引用值且没有因为本条匹配规则递归进入匹配，则以其被绑定对象代替当前形式参数递归匹配。</li>
<li>若形式参数不是符号，则参数匹配失败。</li>
<li>若形式参数不是 <code>#ignore</code> ，则尝试绑定操作数到以符号值确定的名称的形式参数。
<ul>
<li>若符号值以一个<a href="#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6"><em>引用标记字符</em></a>起始，则被绑定的<a href="#npla-%E7%8E%AF%E5%A2%83">变量名</a>中去除此前缀。</li>
<li>若去除前缀得到的符号为空，则忽略操作数，不绑定对象。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　绑定匹配时不检查重复的符号值。若形式参数树中出现重复的符号值，可被多次匹配成功。这可导致之后的绑定初始化中，只有其中某个未指定的绑定生效，其它绑定被覆盖。</p>
<p><strong>原理</strong></p>
<p>　　虽然可能匹配被引用对象，操作数匹配不蕴含时引用值不被<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%B6%88%E9%99%A4">消除</a>。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，明确直接比较前缀元素数，因为：</p>
<ul>
<li>这允许在元素数不同时给出更具有针对性的诊断，避免误用。</li>
<li>这能避免匹配在任何情形都总是顺序地依赖每一个操作数的值，允许<a href="#%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0">并发实现</a>。</li>
</ul>
<p>　　实现使用的表示允许访问元素数具有 <tt>O(1)</tt> 的时间复杂度，而访问前缀元素数具有 <tt>O(n)</tt> 时间复杂度。但限制不访引用值时，不会有较大的附加开销。</p>
<p><strong>注释</strong></p>
<p>　　函数合并构成的操作数树包括作为合并子的第一个子项和作为操作数的之后余下的子项。</p>
<p>　　数据结构和匹配算法类似 Kernel 中用于 <code>$define!</code> 和 <code>$vau</code> 等<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">操作子</a>的递归的匹配机制，但有以下不同（另见 <a href="#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">NPLA1 合并子</a>）：</p>
<ul>
<li>不支持 <a href="#%E6%9C%89%E5%BA%8F%E5%AF%B9">cons 对</a>的中缀 <code>.</code> ，但支持形式参数树中的列表最后以带省略的符号值匹配多个列表项的参数，绑定结尾序列。</li>
<li>对参数子项的符号值中可选的 <code>.</code> 起始以及之后可选的前缀作为标记字符作为引用标记进行处理。</li>
<li>不提供转义，若符号值去除可选的前缀及标记字符 <code>.</code> 后为空则忽略绑定。</li>
<li>若参数子项<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按引用传递</a>则间接访问并绑定<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>。</li>
<li>只支持<a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">无环列表</a>，且不检查（因为 API 已经保证只支持真列表）。</li>
<li>列表外的 <code>.</code> 起始的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0">词素</a>当前视为普通的符号，但此行为可能会在未来改变）。</li>
</ul>
<p>　　被忽略的绑定不保存绑定的对象。</p>
<p>　　不在列表内最后位置的带有前缀 <code>.</code> 的形式参数绑定的是普通的变量，不忽略绑定。</p>
<p>　　和 Kernel 不同，不检查重复符号值，且绑定匹配<a href="#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">对特定模式的形式参数进行不同的处理</a>。</p>
<p>　　其它一些不支持 cons 对的语言，如 [ECMAScript 2019] 的 <code>rest</code> 参数支持类似结尾列表的效果。</p>
<p>　　绑定匹配和创建绑定的初始化之间的顺序约定是必要的，因为这里约定的是一般的规约规则而非求值规则，<a href="#%E9%80%92%E5%BD%92%E8%95%B4%E5%90%AB%E8%A7%84%E5%88%99">递归蕴含规则</a>等求值的默认规则不适用。</p>
<p>　　绑定匹配允许<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">并行化</a>。</p>
<h4 id="引用标记字符"><a class="header" href="#引用标记字符">引用标记字符</a></h4>
<p>　　应用在形式参数树叶节点符号值的前缀 <code>%</code> 、<code>&amp;</code> 或 <code>@</code> 为标记字符表示名称绑定的可按需引入引用，称为引用<em>标记字符(sigil)</em> 。</p>
<p>　　绑定引用时，可使用引用推断规则：</p>
<ul>
<li>引用值<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值的副本传递</a>给形式参数，非引用值<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按引用传递</a>给<a href="#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">形式参数</a>。</li>
<li>否则，操作数按值的副本传递给形式参数。</li>
</ul>
<p>　　标记字符引起的绑定的差异为：</p>
<ul>
<li>不存在标记字符时，对操作数<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值的副本</a>绑定，实际参数的<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">值的副本</a>传递给对应的形式参数。
<ul>
<li>若实际参数是<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">泛左值</a>，则实际参数上首先隐含<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">左值到右值转换</a>。</li>
</ul>
</li>
<li>存在标记字符 <code>%</code> 或 <code>&amp;</code> 时，按上述的引用推断规则直接绑定或转发操作数。
<ul>
<li>当实际参数是引用值时，在<a href="#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">可能对其它属性进行的处理</a>后，隐含一次<a href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">引用折叠</a>。</li>
</ul>
</li>
<li>存在标记字符 <code>@</code> 时，绑定以实际参数作为<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的引用值，不论操作数的类型和值类别。
<ul>
<li>初始化引用值时，没有<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%B6%88%E9%99%A4">引用值的消除</a>。</li>
</ul>
</li>
</ul>
<p><strong>注释</strong></p>
<p>　　除<a href="#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">复制消除</a>转移有序对操作数的子对象外，绑定时不修改被绑定操作数。</p>
<p>　　支持修改操作数的绑定的其它标记字符可能在未来支持。</p>
<h4 id="非递归绑定"><a class="header" href="#非递归绑定">非递归绑定</a></h4>
<p>　　非递归绑定在一次匹配之后创建对应的变量绑定。</p>
<p>　　合并使用或不使用<a href="#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">引用标记字符</a>的情形，非<a href="#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">结尾序列</a>的单一参数对象的<a href="#%E7%BB%91%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96">绑定初始化</a>包含以下过程：</p>
<ul>
<li>若不存在标记字符 <code>@</code> ，则：
<ul>
<li>若操作数为<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%AF%E8%BD%AC%E7%A7%BB%E6%9D%A1%E4%BB%B6">可转移的</a>对象的引用值，则被绑定对象是按以下规则初始化的蕴含隐含的<a href="#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">引用折叠</a>的引用值：
<ul>
<li>存在标记字符时，使用<a href="#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">引用推断规则</a>，被绑定对象是操作数直接初始化的引用值，其属性由操作数的（引用值）的属性决定：
<ul>
<li>当存在标记字符 <code>&amp;</code> 、绑定非结尾序列且作为操作数的引用值的属性包含<a href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">唯一引用属性</a>时，其中包含绑定<a href="#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象属性</a>。
<ul>
<li><strong>注释</strong> 使用 <code>%</code> 可避免操作数中的唯一引用属性在被绑定对象中蕴含<a href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">临时对象属性</a>。</li>
</ul>
</li>
<li>否则，被绑定对象的属性和作为操作数的引用值的属性相同。</li>
</ul>
</li>
<li>否则，被绑定对象是操作数<a href="#%E5%A4%8D%E5%88%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96">复制初始化</a>（复制或转移）的值。</li>
</ul>
</li>
<li>否则，若<a href="#%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">操作数属性</a>指定可修改的临时值或有标记字符 <code>%</code> 时的临时值，操作数是可转移的非引用值，被绑定的对象是临时对象。</li>
<li>否则，当存在标记字符 <code>&amp;</code> 时，被绑定对象是操作数的引用值，其属性是操作数属性和<a href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">操作数项的属性</a>的并，但总是排除绑定临时对象属性。
<ul>
<li><strong>注释</strong> 此处的被绑定对象可在<a href="#%E8%AE%B0%E5%8F%B7%E6%B1%82%E5%80%BC">作为符号求值</a>时被折叠并在结果中<a href="#npla1-%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">进一步去除</a>可能具有的<a href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">唯一引用属性</a>。</li>
</ul>
</li>
<li>否则，被绑定对象是复制自操作数的值。</li>
</ul>
</li>
<li>否则，被绑定对象的是操作数的引用值：
<ul>
<li>绑定操作数的引用时，要求引用的是列表中的项，否则引起错误。</li>
<li>被绑定的对象应是不唯一的值（直接绑定操作数右值以外的值），被绑定对象是操作数的引用值。</li>
</ul>
</li>
</ul>
<p>　　绑定结尾序列包含以下情形：</p>
<ul>
<li>若不存在标记字符 <code>@</code> ，则：
<ul>
<li>若操作数为可转移的对象的引用值，按非结尾序列的规则绑定操作数。</li>
<li>否则，若操作数属性指定可修改的临时值或有标记字符 <code>%</code> 时的临时值，按非结尾序列的规则绑定操作数。</li>
<li>否则，创建新的有序对，在其中以相应的标记字符（若存在）绑定各个元素子对象。</li>
</ul>
</li>
<li>否则，创建新的有序对，在其中以标记字符 <code>@</code> 绑定各个元素子对象。</li>
</ul>
<p>　　绑定结尾序列创建新的有序对并绑定元素子对象时，作为列表<a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">完全分解</a>得到的每个元素组合的列表，满足：</p>
<ul>
<li>若操作数是临时对象，则操作数子项在绑定元素子对象时被<a href="#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4">复制消除</a>。</li>
<li>组合的列表是非真列表，当且仅当操作数是非真列表。</li>
<li>子对象的元素是对应的操作数以对应的引用标记字符（若存在）绑定单一参数得到的值。
<ul>
<li><strong>注释</strong> 若不存在引用标记字符，元素被对应复制初始化。</li>
</ul>
</li>
<li>若操作数是非真列表：
<ul>
<li><strong>注释</strong> 此时需初始化组合中的非列表结尾元素。</li>
<li>当不存在标记字符或存在标记字符 <code>%</code> 时，组合的最后一个元素是操作数中的最后一个元素的副本。</li>
<li>否则，组合中的最后一个元素是新创建的<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子对象引用</a>。
<ul>
<li>其被引用对象的表示中没有子项。</li>
</ul>
</li>
</ul>
</li>
<li>创建的有序对初始化完成后，参与初始化被绑定对象：
<ul>
<li>若存在标记字符 <code>&amp;</code> ，则创建子对象引用作为被绑定对象，其被引用对象是创建的有序对。
<ul>
<li>被创建的子对象引用的被引用对象的表示应避免复制初始化任何操作数一等对象。</li>
</ul>
</li>
<li>否则，创建的有序对直接被作为被绑定对象。
<ul>
<li>若存在标记字符，同时视为<a href="#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">绑定临时对象</a>，设置其表示的<a href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">临时对象标签</a>使之具有临时对象属性。</li>
</ul>
</li>
</ul>
</li>
<li>被绑定对象的元素总是不具有临时对象属性。
<ul>
<li><strong>原理</strong> 这使实现能<a href="#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">避免临时对象的子对象具有临时对象属性</a>。</li>
</ul>
</li>
</ul>
<p>　　绑定临时对象外的引用临时对象视为对被引用对象的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>。</p>
<p><strong>注释</strong> 这意味着除绑定临时对象外，若绑定操作数的初始化的引用值时实际引用临时对象，则<a href="#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">因超出生存期的对象访问，行为未定义</a>。</p>
<p>　　仅在绑定临时对象且操作数可转移或使用标记字符 <code>%</code> 时使用复制消除。</p>
<p><strong>原理</strong></p>
<p>　　绑定的默认行为对引用值特殊处理，是为了满足 <a href="#%E7%BB%9F%E4%B8%80%E6%80%A7">G1b</a> ，而不是像某些语言（如 [ISO C] 和 [Rust] ）仅通过内建的机制提供特定的<em>左值上下文(lvalue context)</em> 。</p>
<p>　　绑定的默认行为不使用<a href="#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">析构性转移</a>的操作（类似 [Rust] 的设计），原因是考虑到绑定的副作用影响操作数（即便因为对象被销毁而不一定是修改操作）和破坏<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">幂等性</a>（特别是指定<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">过程调用</a>的形式参数时）违反<a href="#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测性原则</a>。</p>
<p>　　为允许调用<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主对象</a>的<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">转移构造函数</a>，限制复制消除。初始化引用之外的参数创建也不是 [ISO C++17] 约定要求消除复制的上下文。</p>
<p>　　作为操作数的引用值中的唯一引用在使用 <code>&amp;</code> 引用标记字符时可同时蕴含<a href="#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">绑定临时对象属性</a>，这使绑定为变量的消亡值可能以名称表达式求值结果（不会是消亡值）的引用值访问时，能和其它引用值区分。提供这种设计的理由是：</p>
<ul>
<li>以下两种涉及<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">消亡值</a>的资源访问可被统一：
<ul>
<li>直接访问消亡值表达式。
<ul>
<li>消亡值表示即将被转移的资源。</li>
</ul>
</li>
<li>以消亡值初始化一个带有 <code>&amp;</code> 引用标记字符的非结尾序列变量，并以这个变量的名称作为表达式进行访问。
<ul>
<li>这通常需要使变量指称消亡值引用的资源，而不仅仅是表示即将被转移的消亡值自身。</li>
<li>具有临时对象属性的引用值通过右值初始化，相当于宿主语言中的右值引用，典型地表示能被转移的资源（而不一定需要立刻被转移）。</li>
<li>初始化变量同时转移资源，相当于宿主语言中复制初始化时调用转移构造函数转移操作数的资源到变量（对象或绑定到临时对象的引用），使之表示转移后的资源。</li>
</ul>
</li>
<li>尽管值类别可能不同，这两种表达式都可以表示蕴含被转移的资源的对象。</li>
</ul>
</li>
<li>直接求值名称表达式往往比其它替代方式更直接高效，但结果总是<a href="#%E8%AE%B0%E5%8F%B7%E6%B1%82%E5%80%BC">左值</a>而不具有<a href="#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">唯一引用属性</a>，而使用临时对象属性允许在求值的结果中被保留。
<ul>
<li><a href="#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">项引用</a>（而不是<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">临时对象引用</a>）中的临时对象属性不影响值类别。</li>
<li>类似地，在宿主语言中，和值类别不同的状态以右值引用类型声明的形式编码在类型系统中。
<ul>
<li>引用值中的临时对象属性接近宿主语言中<a href="#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">转发引用</a>蕴含的静态类型。</li>
</ul>
</li>
<li>但和宿主语言不同，临时对象属性能随初始化后的引用值跨过程传递，而无需多次转发并在每次推导引用类型。</li>
</ul>
</li>
<li>基于上述规则，对象语言中特定的转发操作处理可统一的方式处理两种表达式以转移资源。这种设计能简化一般的使用。
<ul>
<li>引用值支持临时对象属性对有效的转发对象应用子的实现是必要的。
<ul>
<li>通过对象属性，转发对象操作可避免总是从实际的操作数提取值类别的需要，允许作为应用子而非<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">操作子</a>。</li>
<li>若不使用临时对象属性，则需要其它方式编码和值类别不同的状态以和消亡值区分，例如宿主语言的静态类型信息。
<ul>
<li>这会增加语言规则的复杂性。</li>
</ul>
</li>
</ul>
</li>
<li>需要转发资源时，一般只需要使用转发对象操作；其它情形可安全忽略引用值中的临时对象属性。</li>
<li>类似地，在宿主语言中，编码在类型系统中的状态在特定上下文中用于实现<a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%80%BC%E4%BC%A0%E9%80%92">完美转发</a>。
<ul>
<li>宿主语言中，右值引用类型的变量作为左值（而不是消亡值）被访问，在大多数操作中没有和其它左值区分的意义。</li>
<li>在 <code>std::forward</code> 这样需要区分引用类型的转发操作（实例是一个函数，而不是宏）中，右值引用类型在局部是有意义的。</li>
<li>但是这仍然存在限制：因为没有跨过程传递的状态支持，明确具体类型还是需要程序显式指定 <code>std::forward</code> 的类型参数（或者宏），而不是 C++ 函数（应用子）的方式实现。</li>
</ul>
</li>
</ul>
</li>
<li>消亡值应和<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>在初始化其它变量时转移资源的作用一致，对应唯一引用属性和临时对象属性的相似处理。
<ul>
<li>通过唯一引用属性仍可区分一个具有临时对象属性的引用值以消亡值还是纯右值初始化。</li>
</ul>
</li>
<li>可使用 <code>&amp;</code> 以外的引用标记字符避免这里的行为而被初始化的被绑定对象（引用值）中引入非预期的临时对象属性。</li>
</ul>
<p>　　绑定结尾序列和非结尾序列的非递归绑定规则略有不同。</p>
<ul>
<li>特别地，除非被绑定对象是引用值，引用标记字符（不论是否存在）同时被作用到作为一等对象的元素上。这是因为：
<ul>
<li>此时，需要把操作数作为一等对象进行分解，使用引用标记字符或者不使用引用标记字符不破坏其它语义规则。</li>
<li>和非引用结尾序列相比，这使有序对的两个元素在初始化时的规则不同，但这具有合理性，因为：
<ul>
<li>有序对作为（非真）列表时，结尾元素和其它元素的地位不是相同的。</li>
<li>有序对的元素在 NPLA 对象表示中即已不对称，地位不可交换。</li>
<li>这种设计简化了一些重要的派生实现。</li>
</ul>
</li>
</ul>
</li>
<li>蕴含绑定<a href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">临时对象属性</a>的规则不适用绑定结尾序列中的元素，因为：
<ul>
<li>结尾序列的元素不具有名称，而不是通过绑定创建的能作为名称访问表达式的变量。访问元素需通过其它方式（如对象语言中的<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E7%BA%A6%E5%AE%9A">子对象访问操作</a>），方法和结果不唯一（如可能具有不同的值类别，可能即时转移资源等），不具有和消亡值的统一性。</li>
<li>引入附加的临时对象属性容易引起非预期的转移。除子对象访问时可能发生的直接转移（通常较明确），随引用值跨过程传递的临时对象属性在之后可能继续引起其它转移。因为首先通过子对象而非名称表达式访问，这种转移的存在性在创建变量绑定的位置通常不显然而无法预知，容易误用。</li>
<li>一旦不需要附加的临时对象属性，去除属性而得到引用值通常是较为困难的，需要对象语言提供特设的操作或绑定新的对象（尽管引入临时对象属性可能同样困难）。</li>
</ul>
</li>
</ul>
<p><strong>注释</strong></p>
<p>　　引用折叠的结果满足<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">不可修改引用属性的传播性质</a>。其它情形应满足 <a href="#npla1-%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">NPLA1 引用值使用约定</a>。因此，仅有使用标记字符 <code>%</code> 进行消除引用时，被消除的引用值的不可修改属性被忽略。</p>
<p>　　绑定临时对象外不和 [ISO C++] 一样可能延长右值类类型<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的生存期。</p>
<p>　　具有引用标记字符的形式参数支持引入引用值并支持绑定引入<a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的实际参数。</p>
<h4 id="递归绑定"><a class="header" href="#递归绑定">递归绑定</a></h4>
<p>　　形式参数树子项和操作数树的子项成功<a href="#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">匹配</a>后绑定子项。</p>
<p>　　递归的<a href="#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">绑定匹配</a>对应递归的绑定创建，允许以操作数树的子项对应初始化形式参数树的各个子项。</p>
<p><strong>注释</strong> 和形式参数树中的<a href="#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">结尾列表</a>的符号值被视为整体不同，递归绑定可包含项和其子项的多次递归的匹配。</p>
<p>　　绑定算法应确定和当前处理的操作数树的属性，即<em>操作数属性(operand property)</em> 。其中蕴含的表示操作数的项对应的<a href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">标签</a>，称为<em>操作数标签(operand tags)</em> 。</p>
<p>　　操作数属性和形式参数的引用标记字符结合决定是否<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按引用传递</a>初始化，并判断<a href="#%E7%BB%91%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96">绑定初始化</a>时是否允许转移。</p>
<p>　　绑定匹配递归处理子项时，应确定子项的操作数标签，以指定子项可能具有的上下文相关的差异。</p>
<p>　　绑定初始时，操作数应为<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>。此时，以临时对象标签作为初始操作数标签。</p>
<p><strong>注释</strong> 这指定指定操作数是可被唯一使用的临时值。与此不同，若项表示作为<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>，应<a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%A8%E7%A4%BA">不具有临时对象标签</a>。</p>
<p>　　一个项的子项的操作数标签由这个项的操作数标签（处理子项时，代表先前确定的所在的项的标签；以下称为当前操作数标签）和本节中以下约定的子项继承规则决定：</p>
<ul>
<li>若操作数子项不是引用值，则子项的操作数标签和当前操作数标签相同。</li>
<li>否则，匹配的子项是这个引用值的<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>，子项的操作数标签以操作数子项中的<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用值的属性</a>和当前操作数标签按以下引用项继承约束限定：
<ul>
<li>子项的操作数标签不包含<a href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">临时对象标签</a>。
<ul>
<li><strong>原理</strong> 这使实现能避免临时对象的子对象具有<a href="#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象标签</a>。</li>
</ul>
</li>
<li>子项的操作数标签是否包含<a href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">唯一引用标签</a>同引用值的属性。</li>
<li>子项的操作数标签是否包含其它标签同对应的当前操作数标签。</li>
<li>在以上基础上，引用值的属性向子项的操作数标签对应的属性<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">传播</a>：若前者包含不可修改属性，后者应包含不可修改标签。</li>
</ul>
</li>
</ul>
<p>　　绑定需转移子项（包括<a href="#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">绑定子项的复制消除</a>）时，使用<a href="#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">项的转移</a>。</p>
<p>　　绑定临时对象属性标签可影响<a href="#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">参数转发</a>。若需按类似宿主语言的成员表达式的值类别而不是成员是否为非左值引用进行转发，需确保被转发的值不是带有临时对象标签的引用值。</p>
<p>　　操作数标签中：</p>
<ul>
<li>唯一引用标签由所在的项单独决定。</li>
<li>临时对象标签仅在递归绑定时所在的所有列表项都是非引用值时包含。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用值的不可修改属性</a>标记不可修改项而避免非临时对象的转移。这和宿主语言中的非 <code>mutable</code> 类数据成员访问操作符决定 <code>const</code> 限定符的规则类似。</p>
<p>　　子项标签继承规则保证使用 <code>&amp;</code> 或 <code>%</code> <a href="#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">标记字符</a>时，值类别的决定规则和宿主语言的成员访问操作符类似：</p>
<ul>
<li>列表左值中的元素总是被绑定为<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>。</li>
<li>列表右值的元素按元素是否为引用被绑定左值或<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">消亡值</a>。</li>
<li>特别地，<a href="#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">项引用</a>的临时对象标签不被继承到作为子项的被引用对象，因为即便被引用的列表对象是一个临时对象，它的元素不被作为纯右值匹配。这和宿主语言中成员访问操作符访问的右值是消亡值而不是纯右值类似。</li>
</ul>
<p>　　使用对象语言，若需判断列表左值中的元素是否为引用值，可直接绑定列表操作数为引用并按需转换为消亡值再递归绑定列表元素。</p>
<h3 id="绑定构造"><a class="header" href="#绑定构造">绑定构造</a></h3>
<p>　　部分<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>的求值包含<a href="#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">形式参数树</a>，通过<a href="#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">绑定规则</a>在<a href="#npla1-%E7%8E%AF%E5%A2%83">环境</a>中引入绑定，其调用指定<a href="#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">绑定操作</a>。具有这样的语法构造的表达式是<em>绑定构造(binding construct)</em> 。</p>
<p>　　一些绑定构造使用 <a href="#%E6%9C%AA%E6%B1%82%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;binding&gt;</code></a>提供在一个表达式多次出现的形式参数树和操作数树。</p>
<p><strong>注释</strong></p>
<p>　　绑定在<a href="#%E7%AC%A6%E5%8F%B7">符号值</a>上的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>引入<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">变量</a>。</p>
<p>　　按<a href="#%E7%BB%91%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96">绑定初始化</a>的约定，<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作数树</a>的子节点初始化被绑定的形式参数树的对应子节点。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，各种绑定构造可使用 <a href="#%E6%9C%AA%E6%B1%82%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;body&gt;</code></a> 提供操作数。</p>
<p>　　对绑定项的处理和 [R<sup>n</sup>RK] 的其它不同参见<a href="#%E6%96%87%E6%B3%95%E5%85%83%E7%B4%A0%E8%A1%A5%E5%85%85%E7%BA%A6%E5%AE%9A">文法元素补充约定</a>。</p>
<p>　　另见<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a>。</p>
<h4 id="强递归绑定"><a class="header" href="#强递归绑定">强递归绑定</a></h4>
<p>　　除类似 Kernel 的常规绑定外，NPLA1 的部分绑定构造支持延迟附加的绑定的形式。</p>
<p>　　强递归绑定支持若同时绑定的递归<a href="#%E7%AC%A6%E5%8F%B7">符号值</a>构成<a href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>，则递归绑定的值都是未指定的内部表示而不<a href="#npla1-%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　强递归绑定是对象语言的绑定构造实现的附加机制，形式参数树的递归匹配仍使用<a href="#%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">递归绑定</a>。</p>
<h4 id="参数转发"><a class="header" href="#参数转发">参数转发</a></h4>
<p>　　绑定构造可支持<em>参数转发(argument forwarding)</em> ，根据实际参数确定形式参数中是否为引用值，保留<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB%E5%92%8C%E7%B1%BB%E5%9E%8B">值类别和可修改性</a>。</p>
<p><strong>注释</strong> 类似<a href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">宿主语言中的转发引用</a>参数。</p>
<h4 id="作用顺序"><a class="header" href="#作用顺序">作用顺序</a></h4>
<p>　　绑定构造引起的绑定初始化的作用<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">顺序</a>满足<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a>的约定。</p>
<p>　　若其中存在<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>，其顺序还满足：</p>
<ul>
<li>若存在同一形式参数树子节点的不同绑定的操作，则这些操作的副作用之间<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">非决定性有序</a>。</li>
<li>不同<a href="#%E7%AC%A6%E5%8F%B7">符号值</a>的形式参数树子节点的绑定操作的副作用之间<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">无序</a>。</li>
<li>形式参数树的子节点上的绑定操作的副作用<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序</a>所在的节点上的绑定操作的其它副作用。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　这些规则允许<a href="../Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">并行的</a>深度优先遍历的绑定实现。深度优先遍历使任一时刻成功完成绑定的对象集中，相对其它策略其状态更<a href="#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测</a>。</p>
<h2 id="对象语义"><a class="header" href="#对象语义">对象语义</a></h2>
<p>　　关于对象的存储，基本内容参见 <a href="#%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">NPLA 存储和对象模型</a>。</p>
<p>　　另见<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">对象语言内存安全保证</a>。</p>
<h3 id="npla1-对象同一性"><a class="header" href="#npla1-对象同一性">NPLA1 对象同一性</a></h3>
<p>　　NPLA1 的对象是<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>。由定义，NPLA1 的对象默认确保<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>。</p>
<p>　　例外参见 <a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">NPLA1 子对象</a>。</p>
<p>　　对象的<a href="#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>通常不保证其作为<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>和其它对象都不同一，包括<a href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">唯一引用</a>的情形。但除非另行指定，作为函数实际参数的对象若是<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B">右值引用</a>，则实现可假定被引用对象唯一。</p>
<p><strong>注释</strong></p>
<p>　　关于右值引用的保证类似 [ISO C++] <a href="https://eel.is/c++draft/res.on.arguments">[res.on.arguments]</a> 。注意这在对象语言而非宿主语言中适用。</p>
<h3 id="npla1-子对象"><a class="header" href="#npla1-子对象">NPLA1 子对象</a></h3>
<p>　　基本内容参见 <a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1">NPLA 子对象</a>。</p>
<p>　　子对象可具有引用值，即<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子对象引用</a>。</p>
<p>　　子对象引用访问的被引用对象不保证具有同一性。</p>
<p><strong>原理</strong></p>
<p>　　和<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>不同，通过相同方式构造的子对象引用访问的被引用对象<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1">未指定是否为同一对象</a>。</p>
<p>　　这允许实现使用和宿主语言不同的方式创建<a href="#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1">非一等对象</a>作为子对象的<a href="#%E8%A1%A8%E7%A4%BA">表示</a>。</p>
<p><strong>注释</strong></p>
<p>　　和宿主语言不同，NPLA1 对象语言不直接提供访问子对象的内建语法。</p>
<h4 id="子对象访问约定"><a class="header" href="#子对象访问约定">子对象访问约定</a></h4>
<p>　　作为<a href="#npla1-%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">使用名称表达式访问对象</a>的推广，特定操作可使用非环境的其它对象显式地访问其子对象。</p>
<p>　　除非另行指定，这些<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">访问</a>操作以本节约定的规则确定结果的<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB%E5%92%8C%E7%B1%BB%E5%9E%8B">值类别和类型</a>。</p>
<p>　　若指称非环境对象的<a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a> <code>E1</code> 是访问操作的（被求值的）实际参数，子对象来自这个参数指定的对象；否则，子对象来自 <code>E1</code> 引用的<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境对象</a>中的<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>。</p>
<p>　　具体的访问操作确定具体的被访问的子对象。</p>
<p>　　访问操作中：</p>
<ul>
<li>若指定结果是引用值，或指定<a href="#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E7%9B%AE%E6%A0%87">（在结果中）保留引用值</a>且被访问的对象实际存在可被保留的引用值，则结果是被访问的子对象的可能经<a href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">引用折叠</a>的引用值。</li>
<li>否则，结果是被访问的被访问的子对象<a href="#%E5%A4%8D%E5%88%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96">复制初始化</a>的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">值</a>。
<ul>
<li>此时，按<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%AF%E8%BD%AC%E7%A7%BB%E6%9D%A1%E4%BB%B6">对象的可转移条件</a>判断复制或转移。</li>
</ul>
</li>
</ul>
<p>　　访问操作的<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">结果</a>的<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B">值的类型和值类别满足一一对应</a>，且结果经值类别转换后和被访问的子对象的类型相同。访问操作中没有明确指定的结果的值类别以此通过结果的类型推断。</p>
<p>　　若通过以上约定，仍没有明确结果的值类别，则按以下默认规则确定：</p>
<ul>
<li>若被访问的子对象是引用值，则结果是<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">泛左值</a>。</li>
<li>否则，若 <code>E1</code> 是<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>，则结果是左值。</li>
<li>否则，结果是<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">右值</a>。</li>
</ul>
<p>　　结果是具有被访问的子对象类型对应的值，它的更具体的值类别通过上述等价关系按结果的类型对应确定。</p>
<p>　　<code>E1</code> 或被访问的子对象的<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">传播</a>引用值的<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%B6%88%E9%99%A4">不可修改属性</a>。</p>
<p>　　被访问的子对象访问若具有影响值类别或被传播以外的其它属性被保留，对应在结果中出现。</p>
<p>　　<em>成员访问(member access)</em> 操作访问称为对象的<em>成员(member)</em> 的子对象，满足本节的约定。</p>
<p>　　具体操作可具有其它改变结果的值类别和类型的约定而实际使用不同的规则。</p>
<p><strong>原理</strong></p>
<p>　　确定结果的值类别和类型的方式类似按宿主语言的成员访问确定对表达式 <code>E1.E2</code> 的值类别和类型。<code>E1</code> 不一定是左值。</p>
<p>　　NPLA1 没有形如 <code>E1.E2</code> 的特设对象访问表达式语法，而以具体的访问操作代替，因此可具有近似但不同的规则。</p>
<p>　　特别地，除非 <code>E1</code> 引用环境，在 <code>E1.E2</code> 中显式指定被访问的子对象的表达式 <code>E2</code> 在访问操作中一般并不存在。代替这里的 <code>E2</code> 的是由具体访问操作指定被访问的子对象，其类型直接代替 <code>E2</code> 的类型。</p>
<p>　　其中，按有序对访问列表的最后一个元素时，被访问的子对象不是引用值，即视为<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>。这里不蕴含<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值</a>，不会有<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">值类别转换</a>。</p>
<p>　　通过被访问的子对象的类型和 <code>E1</code> 的值类别确定结果的值类别的默认规则类似 C++ 成员访问表达式 <code>E1.E2</code> 确定值类别的规则，但略有不同：</p>
<ul>
<li>因为不保证存在名称表达式 <code>E2</code> ，不需要<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值算法</a>使用类似 C++ 的 <code>unqualified-id</code> 一致的方式使结果总是左值。</li>
<li>被访问的对象是右值引用值时，结果是右值引用值（即<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">消亡值</a>），而不一定是左值。</li>
<li>和 C++ 不同，NPLA 消亡值总是右值引用类型，NPLA 纯右值也此类似 C++ 纯右值实质化转换初始化的消亡值，因此逻辑上需要 C++ 消亡值的情形和此处的 NPLA 右值近似。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　初始化非引用值的复制初始化（包括以下的替换消亡值为右值）可能通过<a href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>实现。</p>
<p>　　在对象表示上，传播<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">引用值的不可修改属性</a>决定 <code>E1</code> 指定的被访问对象或被访问的子对象若具有<a href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">不可修改属性</a>，结果也具有不可修改属性。</p>
<p>　　典型地，被保留的其它属性包括<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">临时对象引用</a>。临时对象引用可被继续绑定而可实现<a href="#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">按需转发</a>被引用对象。</p>
<p>　　按默认规则访问相当于这些规则确定的值类似 C++ 表达式 <code>std::forward&lt;decltype(E1.E2)&gt;(E1.E2)</code> 的值。</p>
<p>　　具体操作可具有其它改变结果的值类别和类型的约定而实际使用不同的规则。</p>
<p>　　例如，推断结果的值类别的规则中的左值和消亡值可被替换为右值，则近似 C++ 表达式 <code>std::forward&lt;std::remove_cvref_t&lt;decltype(E1.E2)&gt;&gt;(E1.E2)</code> 。</p>
<p>　　传播引用值属性和宿主语言及<a href="#%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">递归绑定</a>规则类似。</p>
<p>　　关于子对象的修改，参见<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">对象的修改和改变</a>。</p>
<h3 id="对象的修改和改变"><a class="header" href="#对象的修改和改变">对象的修改和改变</a></h3>
<p>　　对象作为实体可修改和改变，可具有<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">可变数据状态</a>及<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">可变管理状态</a>。</p>
<p>　　<a href="#npla-%E6%95%B4%E4%BD%93%E7%BA%A6%E5%AE%9A">NPLA 约定</a>的<a href="#%E8%A1%A8%E7%A4%BA">表示</a>同<a href="#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>的对象，其修改也同这些对象的修改。</p>
<p>　　<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">隐藏状态</a>在针对对象语言的的讨论中被排除。除非另行指定（由具体操作的语义蕴含），所有可变状态都不属于这些被排除的状态。</p>
<p>　　改变对象可引起<a href="#%E7%BF%BB%E8%AF%91%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%A7%84%E5%88%99">诊断</a>：</p>
<ul>
<li>对明确不可变的对象进行改变的操作<a href="#npla1-%E9%94%99%E8%AF%AF">引起错误</a>。</li>
<li>具体操作的语义中，所有操作都允许的不要求诊断错误的<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">改变操作</a>隐式地指定可变管理状态的改变。</li>
</ul>
<p>　　以下状态是可变管理状态：</p>
<ul>
<li>环境中的被绑定对象。</li>
</ul>
<p>　　除非另行指定，其余可变状态都是可变数据状态。</p>
<p>　　类似宿主语言（如关于 <code>const</code> 限定符的语义），生存期开始前或结束后的（可能并未完成构造的）对象中的子对象的修改不是对象的修改；对应地，此处的子对象的变化也不是对象的改变操作。</p>
<p>　　改变上述的被排除的状态的修改操作不被视为对象语言中的对象的改变操作。</p>
<p>　　对包含所有权的子对象的修改是对所在对象的修改。</p>
<p>　　除非另行指定，NPLA1 不限制任意对象不可修改。</p>
<p>　　等价关系和限制不可修改性的方法的方式不唯一，因此不可修改性也不唯一。</p>
<p>　　因为<a href="#npla1-%E5%A4%96%E9%83%A8%E8%A1%A8%E7%A4%BA">外部表示不唯一</a>，不需要基于此定义一种正规的关于外部表示的等价判断形式。</p>
<p>　　对象的不保证<a href="#npla1-%E5%AF%B9%E8%B1%A1%E5%90%8C%E4%B8%80%E6%80%A7">同一性</a>的<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的修改和改变不保证蕴含对对象的修改和改变。</p>
<p><strong>原理</strong></p>
<p>　　<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">开放类型映射</a>不保证非特定对象之间的不可修改性具有唯一的定义。</p>
<p>　　对象的修改和改变作用在确定的对象上。</p>
<p>　　若不同的对象之间不具有同一性，则作用之间无关。因此，修改和改变作为副作用，<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1">不保证在不同一的对象之间共享</a>。</p>
<p><strong>注释</strong></p>
<p>　　所有对对象的状态的约定针对同一个对象。</p>
<p>　　对象的子对象作为可变管理状态，使不可变对象具有允许这些状态改变的<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">内部可变性</a>而和对象的可变性不同。</p>
<p>　　对诊断的要求类似 [R<sup>n</sup>RK] 。</p>
<p>　　环境中的被绑定对象在仅讨论不可变性的意义外仍是数据对象。</p>
<p>　　引起对象内的可变管理状态的改变而不改变对象的操作在宿主语言<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">可通过类的 <code>mutable</code> 数据成员实现</a>，但 NPLA1 不提供特性使任意的<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的可修改性的限制如宿主语言的 <code>const</code> 限定符自动传播（而一般需要使用<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E7%BA%A6%E5%AE%9A">成员访问操作</a>），因此也不需要提供对应的类型检查修改机制。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，NPLA1 支持直接修改对象，而不只是通过指定子对象关联的被引用对象的<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">改变操作</a>。</p>
<p>　　<a href="#%E5%86%BB%E7%BB%93">冻结</a>操作是使环境对象上具有类似宿主语言的 <code>const</code> 传播约束的操作；和宿主语言不同，这不是静态类型系统约束。</p>
<h4 id="赋值"><a class="header" href="#赋值">赋值</a></h4>
<p>　　NPLA1 的<em>赋值(assignment)</em> 操作专指以引用值操作数指定对象且不引起同一性改变的<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">对象修改</a>。</p>
<p>　　被修改的对象由赋值操作的目的操作数决定，可能是操作数对象或其引用的对象。赋值操作后，被修改对象的值来自源操作数。</p>
<p>　　操作数和源操作数相同的赋值是<em>自赋值(self assignment)</em> 。</p>
<p>　　除非另行指定，赋值操作不保留源操作数的<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB%E5%92%8C%E7%B1%BB%E5%9E%8B">值类别</a>和可修改性。</p>
<p>　　赋值可引起源操作数<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">对象的复制或转移</a>，分别称为<em>复制赋值(copy assignment)</em> 和<em>转移赋值(move assignment)</em> 。</p>
<p>　　复制赋值时不会<a href="#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4">复制消除</a>对象。若被赋值的源操作数的值在复制出错，目的操作数引用的对象不被修改。</p>
<p>　　通过对象的<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象引用</a>修改对象的子对象不保证作用在对象上。</p>
<p><strong>原理</strong></p>
<p>　　赋值不引起同一性改变的保证和区分复制赋值和转移赋值类似宿主语言。</p>
<p>　　宿主语言中，通过源操作数的<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态类型</a>（左值或右值引用类型）明确区分两者，但 NPLA 不要求类型系统（尽管支持类似作用的<a href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">元数据</a>），两者区分实际依赖具体行为。</p>
<p>　　子对象引用不一定保证引用完整对象，而修改的副作用可能需要完整对象的信息：</p>
<ul>
<li>例如，修改作为列表的子对象的有序对时需要维护保持子对象关系的内部状态，而子有序对引用若不提供所在的列表的引用，则无法实现维护状态。</li>
<li>为维持子对象引用实现的<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>，不对这类情形进行一般要求。</li>
<li>特定操作可以提供更强的保证以允许满足<a href="#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　赋值操作可能伴随赋值以外的其它副作用，如<a href="#%E8%BD%AC%E7%A7%BB%E5%AF%BC%E8%87%B4%E7%9A%84%E4%BF%AE%E6%94%B9">转移导致的修改</a>。</p>
<p>　　特定的赋值操作可能不支持自赋值，指定自赋值具有<a href="#npla1-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">未定义行为</a>或引起错误。</p>
<p>　　注意避免使用引用值作为操作数的自赋值引起<a href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>：此时除非另行指定，引起 <a href="#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">NPLA 未定义行为</a>。</p>
<p>　　不引起同一性改变的保证和 Kernel 的赋值操作包含以特定对象进行替换（可使用<a href="#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">项的转移</a>实现）而使对象被修改的情形不同。</p>
<p>　　赋值不保证子对象的同一性不被改变；子对象的引用仍可能被赋值<a href="#%E6%97%A0%E6%95%88%E5%8C%96">无效化</a>。</p>
<h4 id="转移导致的修改"><a class="header" href="#转移导致的修改">转移导致的修改</a></h4>
<p>　　转移可导致被转移对象的外部可见的修改。</p>
<p>　　转移不需要是直接显式求值特定的函数调用的副作用。</p>
<p><strong>注释</strong> 例如，使用<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">唯一引用</a>初始化对象，可<a href="#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">转移</a>表示<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的项。</p>
<p>　　和<a href="#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>不同，当前实现不直接通过初始化<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">转移</a><a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主对象</a>。</p>
<p>　　被转移的对象在转移后具有<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">有效但未指定</a>的状态。</p>
<p><strong>注释</strong></p>
<p>　　当前实现中，当项被转移后，表示的值为 <code>()</code> 。这和<a href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>等引入<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">实质化临时对象</a>时可能具有的转移的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>（仅在互操作时可见）不保证相同。</p>
<p>　　作为<a href="#%E8%B5%8B%E5%80%BC">赋值规则</a>的推论，通过转移对象的<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象引用</a>修改对象的子对象不保证作用在对象上。但和其它修改不同，这同时被转移对象后的状态的规则覆盖。</p>
<h3 id="驻留"><a class="header" href="#驻留">驻留</a></h3>
<p>　　出现在表达式中多个位置的值在实现中可共享一个对象作为内部表示。这个对象被<em>驻留(intern)</em> 。</p>
<p>　　当前实现不使用对象驻留，以简化<a href="#%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">存储对象的互操作</a>。</p>
<p><strong>原理</strong></p>
<p>　　因为<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>允许通过引用值被直接<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>，驻留对象创建的共享可能影响<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>。</p>
<p>　　因此兼容 NPLA1 语义的驻留要求排除<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">可修改的操作</a>，且被驻留的值对应的对象的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>不被外部依赖。</p>
<p><strong>注释</strong></p>
<p>　　驻留的对象在实现上共享存储，但仍区分同一性。</p>
<p>　　一般地，驻留仅适合不可变对象，或改变后提供不同副本区分同一性的可变对象。</p>
<p>　　[R<sup>n</sup>RS] 等不可变的符号可被驻留，但没有特别要求。</p>
<p>　　[R<sup>7</sup>RS] 明确要求空列表的唯一性。和驻留一致，这可实现为全局共享对象。</p>
<h3 id="无效化"><a class="header" href="#无效化">无效化</a></h3>
<p>　　若对象的<a href="#npla1-%E5%BC%95%E7%94%A8">引用值保持有效</a>，则指称的左值的对象<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>不变。</p>
<p>　　作为<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>的派生实现，对象语言中的引用值的<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC">无效化</a>包括以下情形：</p>
<ul>
<li>被引用的对象存储期已结束（此时引用值是<a href="#%E6%97%A0%E6%95%88%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC">悬空引用</a>）。</li>
<li>对象被除通过<a href="#%E9%87%8D%E7%BB%91%E5%AE%9A">重绑定</a>、<a href="#%E8%B5%8B%E5%80%BC">赋值</a>和另行指定的情形以外的方式<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>，而引起对象同一性的改变。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　对项的重绑定或赋值仍可能因为对子项的修改蕴含被替换的对象的销毁，引起<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1">生存期结束</a>，而使其表示的对象的引用值无效化。</p>
<h3 id="类型分类"><a class="header" href="#类型分类">类型分类</a></h3>
<p>　　NPLA1 不要求支持任意<a href="#%E7%B1%BB%E5%9E%8B">类型的集合表示</a>不相交，即<em>分区(partition)</em> 。</p>
<p>　　但除非另行指定，基于<a href="#%E5%AE%9E%E4%BD%93%E5%85%83%E7%B4%A0%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">实体元素文法</a>引入的类型仍被分区。</p>
<p><strong>原理</strong></p>
<p>　　不要求分区这避免全局地假定<a href="#%E7%B1%BB%E5%9E%8B%E5%85%A8%E9%9B%86">类型全集</a>的具体表示，并支持开放的<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">类型映射</a>。</p>
<p>　　NPLA1 的<a href="#%E7%B1%BB%E5%9E%8B%E8%B0%93%E8%AF%8D">类型谓词</a>是一元谓词，<a href="#%E7%B1%BB%E5%9E%8B%E8%B0%93%E8%AF%8D">只接受一个参数</a>，以强调语言提供的接口的<a href="#%E6%AD%A3%E4%BA%A4%E6%80%A7">正交性</a>。</p>
<p><strong>注释</strong></p>
<p>　　通过指定<a href="#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型关系</a>可使两个<a href="#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义类型</a>作为集合相交。</p>
<p>　　列表类型只包括<a href="#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>。</p>
<p>　　不要求分区、类型判断谓词、列表类型的设计都和 Kernel 不同。</p>
<h2 id="npla1-对象语言数据结构"><a class="header" href="#npla1-对象语言数据结构">NPLA1 对象语言数据结构</a></h2>
<p>　　本节指定在 NPLA1 允许以<a href="#%E5%AE%9E%E4%BD%93%E8%AF%AD%E4%B9%89">一等实体</a>被使用的基本元素。</p>
<p>　　<a href="#npla-%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B">NPLA 一等对象</a>是 NPLA1 一等对象。</p>
<p><strong>注释</strong></p>
<p>　　部分设计原则和规则和 Kernel 不同。</p>
<p>　　另见<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E4%B9%89">对象语义</a>。</p>
<h3 id="npla1-引用"><a class="header" href="#npla1-引用">NPLA1 引用</a></h3>
<p>　　NPLA1 基于 NPLA <a href="#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC">项引用</a>支持实体的<a href="#%E5%BC%95%E7%94%A8%E5%80%BC">引用</a>。</p>
<p>　　NPLA1 语义中对<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">广义实体</a>的构成依赖的使用也被称为引用，这不限被对象语言中的引用值表达。另见<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境引用</a>。</p>
<p>　　NPLA1 <a href="#npla1-%E7%8E%AF%E5%A2%83">明确允许不通过对象的引用保存对象</a>，但是也允许使用对象引用；即对象和对象的引用都可作为<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">一等对象</a>。</p>
<p>　　这也允许子对象直接被所在的对象蕴含。</p>
<p>　　<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>都通过<a href="#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>表示。另见<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">一等引用</a>、<a href="#%E8%A1%A8%E7%A4%BA">表示</a>和<a href="#%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">存储和对象模型</a>。</p>
<p>　　引用值在创建时即引用在生存期内的对象。</p>
<p><strong>注释</strong></p>
<p>　　引用和 Kernel 及 Scheme 的引用类似。</p>
<p>　　明确允许不通过对象的引用保存对象和 Kernel 不同详见<a href="#%E5%AE%9E%E4%BD%93%E8%AF%AD%E4%B9%89">实体语义</a>。</p>
<h4 id="npla1-引用值使用约定"><a class="header" href="#npla1-引用值使用约定">NPLA1 引用值使用约定</a></h4>
<p>　　除非另行指定：</p>
<ul>
<li>不在求值引入右值引用。</li>
<li>引用值的<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始值</a>经过不超过一次<a href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">引用折叠</a>。</li>
<li>为在表达式的求值结果中取得折叠的引用值：
<ul>
<li>当<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>是<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>时，引用值被<a href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">折叠一次</a>。</li>
<li>否则，引用值通过蕴含一次<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">引用值提升转换</a>的方式被<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%B6%88%E9%99%A4">消除</a>一次。</li>
</ul>
</li>
<li>违反<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">不可修改引用</a>引入的假定的修改操作引起<a href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型错误</a>。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　按 <a href="#npla1-%E8%A7%84%E8%8C%83%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">NPLA1 规范求值算法</a>，隐含<a href="#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>直接求值名称表达式的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>是左值。这和宿主语言求值的 <code>unqualified-id</code> 在除了<em>枚举器(enumerator)</em> 外的大多数情形中类似。</p>
<p>　　在此，这被约定为默认情形。其它情形需要附加的规则指定。</p>
<p>　　特定的显式指定环境和名称表达式的操作访问环境中的被绑定对象，其求值结果可以是<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>或<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">消亡值</a>。这和宿主语言的涉及成员访问的表达式（形如 <code>E1.E2</code> 或 <code>E1-&gt;E2</code> ）类似。环境相当于宿主语言中形如 <code>E1</code> 的对象表达式。</p>
<p>　　因为类型系统的不同，类比成员访问的表达式时，忽略 C++ 的位域(bit-field) 、静态成员、成员函数和枚举器的访问规则。</p>
<p>　　此处 <code>E1</code> 总是被视为左值，所以类似宿主语言的规则，结果的值类别由环境中的对象类型确定：当且仅当对象是左值时，结果是左值；否则是消亡值。</p>
<p>　　因为 NPLA 的左值和消亡值是<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B">引用值</a>，存在推论：</p>
<ul>
<li>当且仅当对象是左值时，显式指定环境的成员访问的结果是<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B">左值引用</a>。</li>
<li>否则，结果是<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B">右值引用</a>（<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">唯一引用</a>）。</li>
</ul>
<p>　　访问不作为被绑定对象的子对象时，通常并非如宿主语言为支持推断参数类型的方式使用引用折叠，构造折叠的引用值默认不直接使用<a href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">引用折叠的规则</a>（除临时对象标签外同 [ISO C++] ），而直接由被引用对象确定。</p>
<p>　　对访问列表中的子项构成的子对象引用，这也和宿主语言的涉及成员访问的表达式类似，除以下不同：</p>
<ul>
<li>元素是引用值时允许结果是唯一引用（而不是宿主语言的左值）。
<ul>
<li>这是因为在此唯一引用指定的是结果的值的类型，而非类似宿主语言声明的右值引用类型。</li>
</ul>
</li>
<li>元素是临时对象的引用值时，允许引用值上的<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">临时对象属性</a>在访问中被区分（类似宿主语言以成员访问表达式作为 <code>decltype</code> 的操作数的结果）。</li>
</ul>
<p>　　访问被绑定对象使用引用值也满足<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">不可修改引用属性的传播性质</a>，避免被绑定对象被任意非预期地修改。</p>
<p>　　其它情形是否需要满足不可修改引用属性的传播性质和具体操作相关，因此不明确要求。</p>
<p>　　对违反不可修改引用引入的假定的修改操作要求错误<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">避免隐式的 NPLA 未定义行为</a>，因此引入类型错误作为<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">违反引用值的属性引入的错误</a>。</p>
<p><strong>注释</strong></p>
<p>　　<a href="#npla1-%E4%BA%92%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">互操作</a>可能引入右值引用。</p>
<p>　　访问子对象的具体规则参见<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E7%BA%A6%E5%AE%9A">子对象访问约定</a>。</p>
<p>　　作为列表或者环境中绑定对象的一部分，引用值可能通过<a href="#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6">求值算法</a>或对象语言提供的操作访问。这同时确定值类别。</p>
<p>　　蕴含一次引用值提升转换的方式包括<a href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>。</p>
<h4 id="循环引用"><a class="header" href="#循环引用">循环引用</a></h4>
<p>　　除非另行指定（如<a href="#%E5%BC%BA%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">强递归绑定</a>），对象中的循环引用引起 <a href="#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">NPLA 未定义行为</a>。</p>
<p><strong>原理</strong></p>
<p>　　循环引用破坏一些实现的假设而引起非预期的访问。</p>
<p>　　不显式访问环境的操作也可能引入循环引用（而引起未定义行为），例如 <a href="#npla1-%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83">NPLA1 参照实现环境</a> 下：</p>
<pre><code class="language-npla1">$def! l ();
$def! l list% l;
</code></pre>
<p>　　典型实现中，具有所有权的循环引用可引起<a href="#%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F">资源泄漏</a>；无条件遍历访问循环引用<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的求值不具有<a href="#%E7%BB%88%E6%AD%A2%E4%BF%9D%E8%AF%81">终止保证</a>。</p>
<p>　　例如 NPLA1 参照实现环境下求值以下表达式：</p>
<pre><code class="language-npla1">$let ((nenv () make-environment)) $set! nenv self nenv
</code></pre>
<p>　　可引起被捕获的环境中存储的对象无法释放。</p>
<p>　　能同时保证避免资源泄漏的实现引起一般意义上更根本的设计限制，因此不被使用。详见<a href="#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">自引用数据结构和循环引用</a>。</p>
<p>　　此外，为了避免 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$lambda</code></a> 等引起不经意的循环引用误用，根据<a href="#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测性原则</a>，这些<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>的<a href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0">构造器</a>默认不使用<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">强引用</a>作为静态环境。</p>
<p>　　若需保持静态环境的所有权，使用显式指定静态环境的构造器（如 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$lambda/e</code></a> ）和 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>lock-current-environment</code></a> 等。</p>
<p>　　否则，容易引起循环引用，如以下表达式：</p>
<pre><code class="language-npla1">$def! f $lambda ()
</code></pre>
<p>　　会相当于当前设计的：</p>
<pre><code class="language-npla1">$def! f $lambda/e (() lock-current-environment)
</code></pre>
<p>　　此处锁定的<a href="#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>的强引用被作为闭包的一部分绑定到当前环境中，引起循环引用。</p>
<p>　　而求值当前设计中等价的：</p>
<pre><code class="language-npla1">$def! f $lambda/e (() get-current-environment)
</code></pre>
<p>　　不引起未定义行为。</p>
<h4 id="自引用数据结构"><a class="header" href="#自引用数据结构">自引用数据结构</a></h4>
<p>　　因为不支持<a href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>，不支持引用自身的<a href="#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">自引用数据结构</a>。</p>
<p><strong>注释</strong> 另见<a href="#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">列表</a>。</p>
<h3 id="npla1-环境"><a class="header" href="#npla1-环境">NPLA1 环境</a></h3>
<p>　　NPLA1 支持<a href="#npla-%E7%8E%AF%E5%A2%83">一等环境</a>。</p>
<p>　　<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">环境对象</a>也可能是语言中显式约定的和<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境引用</a>不同的非一等对象。</p>
<p>　　NPLA1 的环境关连的<a href="#npla-%E7%8E%AF%E5%A2%83">父环境</a>的<a href="#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">重定向</a>使用 DFS（Depth-First Search ，深度优先搜索）遍历目标。</p>
<p>　　环境中的一等对象是环境对象的<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>。子对象是环境对象，即<em>环境子对象(environment subobject)</em> 。</p>
<p>　　语言实现可提供不是一等环境的环境对象，即<em>非一等环境(non-first-class environment)</em> 。</p>
<p><strong>注释</strong></p>
<p>　　除了支持非一等对象的环境，和 Kernel 类似。</p>
<h4 id="隐藏环境"><a class="header" href="#隐藏环境">隐藏环境</a></h4>
<p>　　总是不能被对象语言以一等对象访问的环境是<em>隐藏环境(hidden environment)</em> 。</p>
<p><strong>注释</strong> 推论：非一等环境是隐藏环境。</p>
<p>　　一般地，隐藏环境是某一个（非隐藏的）一等环境的直接或间接父环境（而能通过求值等间接操作被访问）。</p>
<h4 id="新环境"><a class="header" href="#新环境">新环境</a></h4>
<p>　　<em>新(fresh)</em> 环境是新创建的环境。</p>
<p>　　新环境和先前的其它的（特别地，包括<a href="#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>）不共享相同环境对象。</p>
<p>　　除非另行指定，新环境是<a href="#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">空环境</a>。</p>
<p>　　创建新环境的一个例子是 <a href="#vau-%E6%8A%BD%E8%B1%A1">vau 抽象</a>实现<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">过程调用</a>。</p>
<h4 id="环境的稳定性"><a class="header" href="#环境的稳定性">环境的稳定性</a></h4>
<p>　　环境在特定情形保证<em>稳定性(stability)</em> ：一个环境是<em>稳定的(stable)</em> ，仅当总是可假定绑定维持一定意义的等价性，而可确保访问其中同名实体的<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为等价</a>。</p>
<p>　　违反关于环境的稳定性的要求的程序具有<a href="#npla1-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">扩展 NPLA 未定义行为</a>。</p>
<p>　　当前要求确保的稳定性包括：</p>
<ul>
<li><a href="#%E9%9A%90%E8%97%8F%E7%8E%AF%E5%A2%83">隐藏环境</a>的<a href="#%E9%87%8D%E7%BB%91%E5%AE%9A">绑定有效稳定性</a>和<a href="#%E8%A2%AB%E7%BB%91%E5%AE%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%80%BC%E5%92%8C%E5%8F%AF%E8%A7%82%E5%AF%9F%E8%A1%8C%E4%B8%BA">值稳定性</a>。</li>
<li>从构造时即明确要求的一等环境的稳定性，包括<a href="#%E6%A8%A1%E5%9D%97%E7%A8%B3%E5%AE%9A%E6%80%A7">模块稳定性</a>和可能由派生实现定义的其它稳定性。</li>
</ul>
<p>　　环境中的绑定的对象可以在引入后通过<a href="#npla1-%E5%BC%95%E7%94%A8">对象的引用</a>被修改(#对象的修改和改变)。</p>
<p><strong>原理</strong></p>
<p>　　一般地，环境的稳定性要求构造环境时不能依赖非特定的动态环境（作为被<a href="#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>访问的父环境），因为这些环境的绑定可能具有在构造环境之后确定的绑定，而不能确保环境中的名称具有可预知的含义。</p>
<p>　　环境的稳定性简化分析程序的推理过程，也在许多上下文中允许程序更易被优化。</p>
<p>　　从稳定的环境多次访问对象的计算作用是幂等的。这允许合并多次访问为一次而不改变程序的行为，允许具有较小的实现开销。</p>
<p>　　环境的稳定性不易被可靠地判定甚至不可能被判定（例如，一个无法检查但可信的来源提供的环境），因此语言规则在此不要求进行检查。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，<a href="#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">环境基本操作</a>和<a href="#%E5%90%88%E5%B9%B6%E5%AD%90%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">合并子基本操作</a>及基于这些操作的一些<a href="#%E5%9F%BA%E7%A1%80%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">派生操作</a>的<a href="#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">操作数树</a>构造时不检查其中的非列表项是否都为<a href="#%E7%AC%A6%E5%8F%B7">符号</a>或 <a href="#npla1-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F"><code>#ignore</code></a>（而延迟到匹配时检查）；匹配时不检查符号重复；若形式参数中的符号重复，则绑定的目标未指定。</p>
<p>　　此外，NPLA1 提供单独的递归绑定符号的机制，且明确支持<a href="#%E5%BC%BA%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">在操作数中同时递归绑定之前未被绑定的多个符号</a>。</p>
<p>　　要求隐藏环境稳定允许实现共享隐藏环境作为父环境而提供<a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">标准环境</a>。</p>
<p><strong>注释</strong></p>
<p>　　[R<sup>n</sup>RK] 的 <code>make-kernel-standard-environment</code> 若通过共享基础环境作为隐藏的父环境实现，也具有这里的稳定性。</p>
<p>　　但是，[R<sup>n</sup>RK] 不提供<a href="#npla1-%E5%AF%B9%E8%B1%A1%E5%90%8C%E4%B8%80%E6%80%A7">同一性保证</a>，也没有通过对象的引用<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a><a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的操作，因此不需要支持<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">不可修改引用</a>即可保证值稳定性。</p>
<p>　　环境对象符合默认的等价比较规则以及绑定的对象可通过引用被修改和 [R<sup>n</sup>RK] 不同。</p>
<p>　　关于要求的环境稳定性，存在推论：稳定环境中的同名<a href="#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">被绑定实体</a>可证明排除通过对象的引用<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">使其改变的副作用（如被修改）</a>或总是具有<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">同一性</a>。</p>
<h4 id="环境生存期"><a class="header" href="#环境生存期">环境生存期</a></h4>
<p>　　对象语言的实现提供给<a href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>使用的<a href="#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">初始环境</a>的环境对象及其中的子对象满足：</p>
<ul>
<li>其创建<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">先序于</a>用户程序的对象的创建。</li>
<li>除非提供为不满足<a href="#%E7%8E%AF%E5%A2%83%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7">环境的稳定性</a>的环境中的被绑定对象，其销毁后序于用户程序的对象的销毁。</li>
</ul>
<p>　　程序引用环境中的名称时，应确保环境在生存期内。</p>
<p><strong>注释</strong></p>
<p>　　环境中不满足稳定性的被绑定对象可能被修改且具有外部可见的<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>。若这个对象是一个环境的唯一强引用，则对应的环境对象在替换为其它值时被销毁。</p>
<p>　　特别地，应注意使用函数时引入父环境的生存期。</p>
<p>　　另见<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">对象语言内存安全保证</a>。</p>
<h4 id="环境中的绑定"><a class="header" href="#环境中的绑定">环境中的绑定</a></h4>
<p>　　环境中的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">绑定</a>的抽象不依赖对象语言中表达的引用的概念，允许直接关联一个没有引用的值。</p>
<p>　　环境中的<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">绑定对被绑定的对象具有所有权</a>。除在环境中绑定中间值的<a href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">不安全操作</a>，这种直接所有权是独占的。</p>
<p>　　绑定的<a href="#npla-%E7%8E%AF%E5%A2%83">变量名</a>是<a href="#%E7%AC%A6%E5%8F%B7">符号值</a>构成的<a href="#%CE%BB-%E5%AE%8C%E5%A4%87%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AF%B9%E5%BA%94%E8%AF%AD%E6%B3%95">名称表达式</a>，<a href="#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">解析</a>的结果总是<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">左值</a>。</p>
<p><strong>注释</strong></p>
<p>　　环境中的绑定不依赖引用以及绑定所有权和 Kernel 的设计不同。</p>
<p>　　另见<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">一等引用</a>和<a href="#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>。</p>
<h4 id="重绑定"><a class="header" href="#重绑定">重绑定</a></h4>
<p>　　环境中允许变量以相同的名称被重新绑定，即<em>重绑定(rebinding)</em> 。</p>
<p><strong>注释</strong> 和 Scheme 类似。</p>
<p>　　<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>的<a href="#npla1-%E5%BC%95%E7%94%A8">引用</a>不因其引用的对象被重绑定操作替换值而被无效化。</p>
<p>　　重绑定替换被绑定对象的值，不改变对象的<a href="#npla1-%E5%AF%B9%E8%B1%A1%E5%90%8C%E4%B8%80%E6%80%A7">同一性</a>。若其中存在<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>，则子对象被销毁，任何子对象的引用值被<a href="#%E6%97%A0%E6%95%88%E5%8C%96">无效化</a>。</p>
<p>　　特别地，若继续访问已被<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值</a>指称的引用值引用的对象，则超出生存期访问而引起 <a href="#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">NPLA 未定义行为</a>。</p>
<p>　　任意<a href="#%E9%9A%90%E8%97%8F%E7%8E%AF%E5%A2%83">隐藏环境</a> <tt>e</tt> 应满足以下绑定有效稳定性：通过引用值间接访问 <tt>e</tt> 中绑定的对象时绑定保持有效（蕴含不被移除或重绑定），保持被绑定对象的生存期和 <tt>e</tt> 对其<a href="#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1">所有权</a>。</p>
<p>　　这避免因为上述访问违反<a href="#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>而引起 NPLA 未定义行为。</p>
<p>　　关于无效化，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h4 id="被绑定对象的值和可观察行为"><a class="header" href="#被绑定对象的值和可观察行为">被绑定对象的值和可观察行为</a></h4>
<p>　　任意<a href="#%E9%9A%90%E8%97%8F%E7%8E%AF%E5%A2%83">隐藏环境</a>的 <tt>e</tt> 的任意<a href="#npla1-%E5%AF%B9%E8%B1%A1%E5%90%8C%E4%B8%80%E6%80%A7">同一</a>被绑定对象 <tt>o</tt> 应满足以下的<em>值稳定性(value stability)</em> ：若 <tt>o</tt> 上发生<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">使其改变的副作用（如被修改）</a>，则之后在以 <tt>e</tt> 或任意以 <tt>e</tt> 作为直接或间接父环境的环境中直接以<a href="#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>或 <tt>o</tt> 的引用值访问 <tt>o</tt> 时，<tt>o</tt> 的值和发生作用前的 <tt>o</tt> 的值在影响<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>的意义上等价。</p>
<p>　　若不满足值稳定性，访问副作用发生后的对象引起<a href="#npla1-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">扩展 NPLA 未定义行为</a>。</p>
<p>　　以下情形使对象<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">改变</a>的副作用不受值稳定性要求的约束：</p>
<ul>
<li>对象通过合并子调用的返回值或其中的<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子对象引用</a>指定（不论合并子是否是隐藏环境中的<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>）。</li>
<li>对象间接访问具有<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">内部可变性</a>的对象的<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">可变管理状态</a>。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　通过限制<a href="#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a><a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">不可修改</a>可以维护<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的值稳定性。</p>
<p>　　对象<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">间接访问具有内部可变性的对象的可变管理状态</a>的一类典型实例是一等环境中的绑定中的子对象（即便这个一等环境对象是隐藏环境中的子对象）。</p>
<h4 id="冻结"><a class="header" href="#冻结">冻结</a></h4>
<p>　　环境可进行<em>冻结(freeze)</em> 。<em>冻结的(frozen)</em> 环境中取得的绑定和引用值<a href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">不可修改</a>。</p>
<p>　　特定的环境<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>要求环境不在冻结状态以确保不变量，要求<a href="#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>。检查失败则<a href="#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">引起类型错误</a>。</p>
<p>　　冻结一个已被冻结的环境没有作用。</p>
<p><strong>注释</strong> 冻结环境是<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">幂等</a>操作。</p>
<p>　　NPLA1 <a href="#%E9%9A%90%E8%97%8F%E7%8E%AF%E5%A2%83">隐藏环境</a>是冻结的。</p>
<p>　　当前 NPLA1 对象语言不提供在已有环境撤销冻结或在冻结的环境中添加、移除绑定或<a href="#%E9%87%8D%E7%BB%91%E5%AE%9A">重绑定</a>的方法。</p>
<p>　　若程序中使用其它方法（附加初始化或提供本机实现操作）撤销冻结或在冻结的环境中添加、移除绑定或重绑定而使对象语言安全性保证失效，这种方法应由派生实现定义，否则程序<a href="#npla1-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">行为未定义</a>。</p>
<p>　　关于对象语言安全性保证，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　环境的冻结操作类似 [ECMAScript] 的对象的冻结操作。类似地，冻结环境不会冻结其中的变量绑定中可能存在的<a href="#npla1-%E7%8E%AF%E5%A2%83">环境子对象</a>。</p>
<h3 id="npla1-广义列表"><a class="header" href="#npla1-广义列表">NPLA1 广义列表</a></h3>
<p>　　NPLA1 的<a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">广义列表</a>是<a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>或者无环的<a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">非真列表</a>，其<a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">元素</a>不构成<a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">环</a>。</p>
<p>　　列表的<a href="#npla1-%E5%BC%95%E7%94%A8">引用</a>构成其它对象时，也不构成<a href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">环</a>。</p>
<p><strong>原理</strong> 排除环使处理列表的操作不需要考虑一些复杂的<a href="#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">自引用</a>情形。</p>
<p>　　<a href="#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>的<a href="#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">形式参数树</a>是可能是<a href="#%E7%AC%A6%E5%8F%B7">符号</a>或真列表。</p>
<p><strong>注释</strong> 形式参数树可作为表达式直接在<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源程序</a>中表达。</p>
<p>　　通常意义的列表即<a href="#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>。</p>
<p>　　除非另行指定，NPLA1 列表类型指<a href="#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">真列表</a>。非真列表的类型是<a href="#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">有序对</a>。</p>
<p><strong>原理</strong></p>
<p>　　和 Scheme 及 Kernel 不同，NPLA 支持的列表都是真列表。另见<a href="#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">关于自引用数据结构和循环引用的分析</a>。</p>
<p>　　列表的这些特性确保基于列表的数据结构在对象语言逻辑上的简单性。也因此 NPLA1 对应的操作中，没有对环存在性的检查。</p>
<p>　　没有环的结构能保证所有权语义能按需嵌入(embed) 到列表中，即列表可保证表示为同构的具有对节点所有权的嵌套 <a href="#%E6%9C%89%E5%BA%8F%E5%AF%B9">cons 对</a>。</p>
<p>　　因为类似的理由，在语言特性中<a href="http://xahlee.info/UnixResource_dir/writ/lisp_problems.html">原生支持 cons 对被有的 Lisp 用户认为是传统 Lisp 设计的主要问题之一</a>。由于 cons 对只是一般的列表的实现细节，对 cons 对的依赖造成<a href="#%E9%81%BF%E5%85%8D%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F">抽象泄漏</a>；为了支持接近一般列表的抽象，必须引入真列表。也因此 NPLA 避免直接依赖 cons 对的缺陷，尽管同时仍然提供<a href="#%E6%9C%89%E5%BA%8F%E5%AF%B9">有序对</a>且 NPLA 列表仍通过有序对定义，更一般情形可以避免对列表的依赖，如部分<a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">库函数</a>可直接支持抽象列表。</p>
<h4 id="有序对的子对象和子对象引用"><a class="header" href="#有序对的子对象和子对象引用">有序对的子对象和子对象引用</a></h4>
<p>　　有序对的元素是有序对的<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>，有序对对作为元素的表示具有所有权。同一个有序对的元素节点之间没有所有权关系。</p>
<p>　　部分操作可能修改有序对的子对象。</p>
<p>　　除非另行指定，有序对的子对象被转移，使用<a href="#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">项的转移</a>。被转移的子对象在被转移后不在被转移的有序对中存在。</p>
<p>　　<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子有序对引用</a>可被<a href="#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>引入。</p>
<p>　　关于子对象被修改和转移，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　有序对的子对象是表示它的项的<a href="#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">子项和值数据成员</a>对应表示的对象。</p>
<p>　　对象被转移后通常其子对象不需要再被访问，此时保持子对象的<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">同一性</a>和转移前的状态一一对应缺乏意义。作为<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">析构性转移</a>，使用项的转移可以复用已使用类型擦除或其它的间接存储方式持有的子对象，减小不必要的开销。</p>
<p>　　作为默认规则，明确要求项的转移，而不是未指定是否使用项的转移，以满足语言规则自身的<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>和<a href="#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测性</a>。这类似 [WG21 P0135R1] 引入强制复制消除(madatory copy elision) 对 [ISO C++] 的规则起到简化作用。不同的是，因为没有<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">静态类型</a>的限制，子对象的类型能在程序运行时改变，而不需要引入静态分析开销，这同时使实现也更简单。</p>
<p><strong>注释</strong></p>
<p>　　<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子有序对引用</a>和<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子列表引用</a>是<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子对象引用</a>。</p>
<p>　　当前有序对引用总是引用至少一个有序对的元素。</p>
<p>　　由绑定使用引用标记字符的<a href="#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">非递归绑定</a>的规则，绑定列表的子对象引用不直接共享操作数有序对对象，而共享元素是原容器元素的（<a href="#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">经折叠的</a>）引用值的有序对，是子有序对引用。</p>
<p>　　这类似宿主语言的容器对象一般不能转换为共享容器部分元素的 C++ 对象引用。</p>
<h3 id="npla1-合并子"><a class="header" href="#npla1-合并子">NPLA1 合并子</a></h3>
<p>　　除非另行指定（如<a href="#%E5%BC%BA%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">强递归绑定</a>），对象语言中的所有合并子都是<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">真合并子</a>。</p>
<p>　　NPLA1 对象语言不提供其它合并子的普遍操作。</p>
<p><strong>注释</strong> 但<a href="#npla1-%E4%BA%92%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">互操作</a>意义上的 NPLA1 API 可支持其它合并子。</p>
<p>　　合并子和操作数组合构成的<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>是一个 NPLA1 对象，称为<em>函数合并对象(function combination object)</em> 。</p>
<p><strong>注释</strong> <a href="#npla1-%E8%A7%84%E8%8C%83%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值算法</a>可接受的函数合并对象是<a href="#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">有序对</a>。<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并表达式</a>作为函数合并对象是<a href="#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">列表</a>。</p>
<p>　　NPLA1 的合并子使用<em>包装数(wrapping count)</em> 存储可能需要求值操作数的次数。</p>
<p>　　在不出错时行为和不使用包装数而直接使用嵌套子对象实现的行为完全一致，但在到达实现支持的最大包装数时继续包装即<em>包装数溢出(wrapping count overflow)</em> ，行为可能不相同：</p>
<p>　　若某个操作使合并子超出上限，则符合<a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF%E6%9D%A1%E4%BB%B6">非宿主资源耗尽的错误条件</a>。</p>
<p>　　实现支持的最大包装数应满足：若发生包装数溢出，则直接创建和包装数相同个数的合并子符合<a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF%E6%9D%A1%E4%BB%B6">宿主资源耗尽的错误条件</a>。</p>
<p><strong>原理</strong></p>
<p>　　为<a href="#%E5%8F%AF%E4%BF%AE%E6%94%B9%E6%80%A7">可修改性</a>，允许非真合并子。这可在互操作中表示类似合并子但在语言中不可见的非一等对象。</p>
<p>　　为维护语言规则的<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a>，合并子默认是真合并子。</p>
<p>　　NPLA1 对象语言不提供其它合并子的普遍操作，这不保证完全满足类似 <a href="#%E7%BB%9F%E4%B8%80%E6%80%A7">G1b</a> 的原则。</p>
<p>　　尽管<a href="#%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%9E%8B">没有要求</a>，这种规约也更符合 G1b ；同时，这易于移植 Kernel 代码。</p>
<p><strong>注释</strong></p>
<p>　　Kernel 的合并子对应 NPL 的<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">真合并子</a>。</p>
<p>　　对最大包装数的要求需要实现支持包装数是能和宿主资源的空间相较规模的值，这保证使用包装数的实现的空间效率不弱于不使用包装数而直接分配合并子包装的实现。</p>
<p>　　这也表示通常<a href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>的操作不会发生包装数溢出：若包装操作的次数导致包装数溢出，则直接分配合并子的替代操作也应由于宿主资源耗尽而失败。</p>
<h3 id="npla1-数值"><a class="header" href="#npla1-数值">NPLA1 数值</a></h3>
<p>　　<a href="#%E9%99%84%E5%8A%A0%E5%8A%9F%E8%83%BD">数值支持</a>的实现兼容<a href="#npla-%E6%95%B0%E5%AD%A6%E5%8A%9F%E8%83%BD">NPLA 数学功能</a>。</p>
<p>　　<a href="#npla1-%E6%95%B0%E5%80%BC%E5%AD%97%E9%9D%A2%E9%87%8F">NPLA1 数值字面量</a>的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>是数值。</p>
<h2 id="函数的间接值使用约定"><a class="header" href="#函数的间接值使用约定">函数的间接值使用约定</a></h2>
<p>　　引用值作为间接值，首先符合作为实体的<a href="#npla1-%E5%BC%95%E7%94%A8">引用</a>的使用约定。</p>
<h3 id="间接值作为实际参数"><a class="header" href="#间接值作为实际参数">间接值作为实际参数</a></h3>
<p>　　除非另行指定，一般地，函数接受左值引用操作数，使用引用的对象的值和直接使用右值作用相同，但不会修改被左值引用的对象。</p>
<p>　　这等价隐含无副作用的<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">左值到右值转换</a>，被视为蕴含左值到右值转换。</p>
<p><strong>注释</strong></p>
<p>　　另行指定的例子如<a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91">函数参数转发</a>。</p>
<p>　　此处的左值引用和宿主语言中的（ <code>const</code> 非 <code>volatile</code> ）左值作用类似。</p>
<h3 id="间接值作为函数值"><a class="header" href="#间接值作为函数值">间接值作为函数值</a></h3>
<p>　　部分<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>总是非引用值。</p>
<p>　　这些操作对应的函数调用返回非引用值。</p>
<p>　　返回非引用值的行为应等价<a href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>。</p>
<p>　　其它操作可具有引用值结果，对应的函数调用可返回引用值。</p>
<p><strong>原理</strong></p>
<p>　　函数值非引用值可满足具体操作的语义要求（如非引用值的<a href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0">构造器</a>），减少误用的可能性，并帮助提供<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">内存安全保证</a>。</p>
<h3 id="保留引用值"><a class="header" href="#保留引用值">保留引用值</a></h3>
<p>　　<a href="#%E4%BF%9D%E7%95%99%E9%97%B4%E6%8E%A5%E5%80%BC">保留间接值</a>，包括<a href="#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%9D%A5%E6%BA%90">直接保留间接值和间接保留间接值</a>，适用<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>是<a href="#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>的情形，对应地称为保留引用值、直接保留引用值和间接保留引用值。</p>
<p>　　除非另行指定，被保留的引用值不被<a href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">折叠</a>。</p>
<p><strong>原理</strong></p>
<p>　　必要时要求引用折叠可避免引入非预期的引用的引用值。</p>
<p>　　被保留的引用值可能<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">逃逸</a>或不逃逸而通常不能直接证明具有<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">内存安全保证</a>。</p>
<h3 id="保留环境引用"><a class="header" href="#保留环境引用">保留环境引用</a></h3>
<p>　　<a href="#%E4%BF%9D%E7%95%99%E9%97%B4%E6%8E%A5%E5%80%BC">保留间接</a>值适用<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境引用</a>。</p>
<p><strong>注释</strong></p>
<p>　　和<a href="#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">保留引用值</a>的情形不同，因为只允许通过环境引用在对象语言中访问<a href="#npla1-%E7%8E%AF%E5%A2%83">环境对象</a>及其子对象，访问环境但不保留环境引用的操作<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">只可能在（不保证内存安全的）互操作中出现</a>。</p>
<h2 id="函数参数和函数值传递约定"><a class="header" href="#函数参数和函数值传递约定">函数参数和函数值传递约定</a></h2>
<p>　　函数可能<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0">接受引用值参数</a>和<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">返回引用值</a>，是对函数的形式参数或函数值的<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a>。</p>
<p>　　在复制初始化形式参数和<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>时，部分函数保证被初始化的值和<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初值符</a>的<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB%E5%92%8C%E7%B1%BB%E5%9E%8B">值类别和可修改性</a>一致。这些初始化是<a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%80%BC%E4%BC%A0%E9%80%92">转发</a>操作。</p>
<p><strong>注释</strong></p>
<p>　　另见<a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%80%BC%E4%BC%A0%E9%80%92">函数参数和函数值传递</a>。</p>
<h3 id="传递非引用值参数"><a class="header" href="#传递非引用值参数">传递非引用值参数</a></h3>
<p>　　一些函数的参数进行<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">左值到右值转换</a>，实现参数的<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值传递</a>。</p>
<p>　　这类似宿主语言中直接使用对象类型的形式参数。</p>
<h3 id="函数参数转发"><a class="header" href="#函数参数转发">函数参数转发</a></h3>
<p>　　一些求值为引用值的函数的部分实际参数被保留，而不进行<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">左值到右值转换</a>。</p>
<p>　　这些值以保留值类别不变的形式被直接作为操作数，用于调用其它合并子。这种参数被<a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%80%BC%E4%BC%A0%E9%80%92">转发</a>。</p>
<p><strong>注释</strong></p>
<p>　　这些参数的转发类似<a href="#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>支持的<a href="#%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91">参数转发</a>。</p>
<p>　　参数转发的实现可判断<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">值类别</a>后分别对<a href="#%E4%BC%A0%E9%80%92%E9%9D%9E%E5%BC%95%E7%94%A8%E5%80%BC%E5%8F%82%E6%95%B0">传递非引用值</a>或直接传递引用值提供实现，或直接使用绑定构造。前者支持本机实现。</p>
<h3 id="返回非引用值"><a class="header" href="#返回非引用值">返回非引用值</a></h3>
<p>　　返回非引用值和参数的<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值传递</a>类似：若初始化函数值的初值符是引用，复制或转移被引用对象的值而不是引用值。</p>
<p><strong>注释</strong></p>
<p>　　这类似宿主语言中返回 <code>auto</code> 类型。</p>
<h3 id="函数值转发"><a class="header" href="#函数值转发">函数值转发</a></h3>
<p>　　一些其它保留引用值的操作中，引用值来自参数，且难以通过自身的逻辑单独决定可否安全地直接返回引用值。</p>
<p>　　此时，在返回之前根据特定参数是否为引用值，可选地转换<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>以确定是否保留引用值，即进行转发。</p>
<p>　　特定的显式转发操作转发<a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的<a href="#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>使临时对象被转移，以转发的值作为结果，可不同于使用<a href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>：</p>
<ul>
<li>同返回值转换，转发转移右值，复制左值。</li>
<li>但当转发临时对象可确定唯一使用时，也转移临时对象。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　函数值转发使某些操作在默认情况下满足间接值生存期规则而保持内存安全，符合<a href="#%E9%80%82%E7%94%A8%E6%80%A7">适用性原则</a>。</p>
<p><strong>注释</strong></p>
<p>　　确定是否保留引用值的机制类似 [ISO C++14] 中从没有括号的 <code>id-expression</code> 上推断返回 <code>decltype(auto)</code> 类型是否为引用类型。</p>
<p>　　函数值转发的实现可通过判断是否需要转发引用而<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">按需决定返回引用值或非引用值</a>，或使用标准库的相关函数。前者支持本机实现。</p>
<p>　　另见<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%AF%E8%BD%AC%E7%A7%BB%E6%9D%A1%E4%BB%B6">对象的可转移条件</a>。</p>
<p>　　显式转发操作把右值、消亡值和带有<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">临时对象属性</a>的<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B">左值引用</a>视为被转发的目标。</p>
<p>　　转发列表对象的<a href="#%E6%9C%89%E5%BA%8F%E5%AF%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子对象</a>可能转移这个对象。</p>
<h3 id="创建和访问对象的函数"><a class="header" href="#创建和访问对象的函数">创建和访问对象的函数</a></h3>
<p>　　<em>构造器(constructor)</em> 是用于创建对象的函数。</p>
<p>　　除非显式指定创建的对象具有引用值类型，构造器是<em>典型的(typical)</em> ，<a href="#%E8%BF%94%E5%9B%9E%E9%9D%9E%E5%BC%95%E7%94%A8%E5%80%BC">返回非引用值</a>。</p>
<p>　　部分操作涉及对其它对象具有所有权的对象。</p>
<p>　　一部分对象的构造器创建的对象完全通过其它对象的引用或<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">对象的值</a>作为构造器的参数而决定，且创建的对象对这些参数具有所有权，这样的对象称为容器(container) 。</p>
<p>　　容器构造器的参数作为容器的<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>，是容器的<em>元素(element)</em> 。</p>
<p>　　以容器对象或其引用作为参数，取得容器元素对象或其引用的函数是容器元素<em>访问器(accessor)</em> 。</p>
<p>　　标准库提供一些属于构造器和访问器的操作。除非另行指定，标准库的访问器符合<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E7%BA%A6%E5%AE%9A">子对象访问约定</a>。</p>
<p><strong>注释</strong></p>
<p>　　容器的元素扩展了<a href="#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">有序对和列表的元素</a>的概念。</p>
<p>　　一些不是容器的对象（如<a href="#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">真合并子</a>）可通过非容器形式的构造器创建。</p>
<h3 id="转发参数或返回值的实现"><a class="header" href="#转发参数或返回值的实现">转发参数或返回值的实现</a></h3>
<p>　　没有约定需要转发的情形不使用显式的转发。</p>
<p><strong>注释</strong></p>
<p>　　可<a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91">转发参数</a>或<a href="#%E5%87%BD%E6%95%B0%E5%80%BC%E8%BD%AC%E5%8F%91">转发返回值</a>的函数可包含以下实现方式：</p>
<ul>
<li>使用特定的操作，以需被转发的表达式作为其操作数。</li>
<li>（仅对参数转发）使用<a href="#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">标记字符</a> <code>%</code> 的<a href="#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">参数绑定</a>的变量。</li>
</ul>
<p>　　上述特定的操作可在被求值的表达式中构造显式的转发。</p>
<h1 id="npla1-参照实现环境"><a class="header" href="#npla1-参照实现环境">NPLA1 参照实现环境</a></h1>
<p>　　NPLA1 提供参照实现环境。其实现可在内部使用 NPLA1 <a href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">库特性</a>，提供给 NPLA1 <a href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>。</p>
<p>　　NPLA1 参照实现环境和用户程序遵循部分不同的要求和约定。</p>
<p>　　本章中的其它约定适用 NPLA1 参照实现环境，且可选地被用户程序使用。</p>
<h2 id="npla1-初始求值环境"><a class="header" href="#npla1-初始求值环境">NPLA1 初始求值环境</a></h2>
<p>　　NPLA1 以<a href="#npla1-%E7%8E%AF%E5%A2%83">环境对象</a>中的绑定作为公开的接口提供库特性，以进一步提供<em>初始环境(initial environment)</em> 作为<a href="#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">求值环境</a>，即用户程序初始的<a href="#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>。</p>
<p>　　这些环境包含两类：</p>
<ul>
<li><em>根环境(root environment)</em> ：提供<a href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">核心语言特性</a>的<a href="#npla1-%E7%8E%AF%E5%A2%83">非一等环境</a>。
<ul>
<li>根环境应能和<a href="#npla1-%E7%8E%AF%E5%A2%83">一等环境</a>在<a href="#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>中的作用一致：作为<a href="#npla-%E7%8E%AF%E5%A2%83">父环境</a>。</li>
</ul>
</li>
<li><em>库环境(library environment)</em> ：作为库特性的一等环境。
<ul>
<li><strong>注释</strong> 通常是其它环境的<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>。</li>
</ul>
</li>
</ul>
<p>　　这些环境应按语言规范要求的方式<a href="#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">包含和展示</a>所有<a href="#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">可见的绑定</a>。</p>
<p>　　除非另行指定，这些环境对象初始化后在用户程序访问前被<a href="#%E5%86%BB%E7%BB%93">冻结</a>。</p>
<p>　　<em>基础环境(ground environment)</em> 是 NPLA1 程序可假定存在的一个根环境。</p>
<p>　　基础环境是<a href="#%E9%9A%90%E8%97%8F%E7%8E%AF%E5%A2%83">隐藏环境</a>。</p>
<p>　　除非另行指定：</p>
<ul>
<li>基础环境不展示名称语言规范要求的除<a href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E9%99%84%E5%8A%A0%E8%A7%84%E5%88%99">保留名称</a>外的绑定。</li>
<li>根环境是否展示基础环境中的绑定未指定。</li>
</ul>
<p>　　初始环境是一个包含基础环境作为直接或间接父环境的<a href="#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">空环境</a>。</p>
<p>　　实现可提供基础环境以外的根环境，允许派生实现定义在用户程序中<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改其中的绑定</a>的机制（而不一定是隐藏环境），直至被实现初始化参考环境的特定用户程序封装或冻结而避免进一步修改。</p>
<p>　　如有必要，用户程序可通过派生实现定义的方式引入其它根环境。</p>
<p><strong>原理</strong></p>
<p>　　这些环境对象设计为在参照实现环境提供，因为：</p>
<ul>
<li>不都保证能在用户程序中可移植地创建，而有必要在参照实现环境中提供。</li>
<li>提供的库特性在可移植程序中可能经常出现，而适合在参照实现环境中提供。</li>
</ul>
<p>　　根环境在功能上不需要展示基础环境中的绑定，这允许简化初始化。但允许展示基础环境中的绑定也使<a href="#%E5%AE%9E%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%BA%A6%E5%AE%9A">派生实现</a>能被简化。</p>
<p><strong>注释</strong></p>
<p>　　提供基础环境和 Kernel 类似。</p>
<p>　　<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>可能直接访问基础环境，这些操作应避免破坏实现和程序的假定。</p>
<p>　　特性设计注记：</p>
<ul>
<li>为避免依赖逻辑上复杂的形式，一些特性当前在当前设计中排除。
<ul>
<li>例如，依赖一阶算术的操作、其硬件加速形式的 ISA 表示的整数操作及依赖这些操作实现的<a href="https://en.wikipedia.org/wiki/Numerical_tower"><em>数值塔(numerical tower)</em> (en-US)</a> 被整体忽略。</li>
</ul>
</li>
<li>上述忽略的特性可由派生实现补充，在派生根环境后按需进行 AOT(ahead-of-time) 优化（如 Kernel 的 <code>$let-safe!</code> 中包含的内容，其中引用基础环境的符号不再可变），然后组成类似基础环境。</li>
</ul>
<p>　　通过派生实现定义的方式一般依赖<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>。</p>
<h3 id="npla1-实现环境初始化"><a class="header" href="#npla1-实现环境初始化">NPLA1 实现环境初始化</a></h3>
<p>　　<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">实现环境</a>的初始化完成初始环境的准备，包括蕴含所有初始环境依赖的资源<em>基础上下文(ground context)</em> 的初始化。</p>
<p>　　初始化基础上下文蕴含的根环境是<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值</a>默认使用的求值环境，初始化后可直接封装为基础环境使用。</p>
<p>　　派生实现可在以上初始化结束之后，在运行用户程序之前完成其它初始化。</p>
<p>　　初始化成功后，用户程序被运行；否则，程序非正常终止。</p>
<p>　　以上初始化同时可能提供<a href="#npla1-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F">扩展字面量</a>支持。</p>
<p><strong>注释</strong></p>
<p>　　对初始化失败而终止的程序，建议但不要求实现给出诊断。</p>
<h3 id="导入符号"><a class="header" href="#导入符号">导入符号</a></h3>
<p>　　在环境中定义另一个环境中的同名变量，使被定义的变量是后者的引用值或值的副本，则称指定此<a href="#npla-%E7%8E%AF%E5%A2%83">变量名</a>的<a href="#%E7%AC%A6%E5%8F%B7">符号值</a>在后者被<em>导入(import)</em> 前者。</p>
<p><strong>注释</strong> 用户程序可导入环境中的符号值使用库中的绑定。</p>
<h2 id="模块"><a class="header" href="#模块">模块</a></h2>
<p>　　NPLA1 以绑定提供的语言特性被分组归类为<a href="#%E6%A8%A1%E5%9D%97%E5%8C%96">模块</a>。</p>
<p><strong>注释</strong> 同 [R<sup>n</sup>RK] 。</p>
<p>　　模块的<em>源(source)</em> 提供特性的实现，可以是本机实现或者 NPLA1 程序。对应的模块分别是本机模块和<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源程序</a>模块。</p>
<p>　　模块的源可以是实现内建的，或位于实现环境提供的外部资源（如文件系统）。</p>
<p>　　因为模块以绑定的集合的形式提供，需被包含在可访问的环境，或包含环境作为<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的其它对象中。</p>
<p>　　以<a href="#npla1-%E7%8E%AF%E5%A2%83">环境对象</a>作为模块的源的模块化方式称为<em>环境作为模块(environment as module)</em> 。[R<sup>n</sup>RK] 的 <code>get-module</code> 的结果和<a href="#npla1-%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E6%89%A9%E5%B1%95%E7%8E%AF%E5%A2%83">参照实现扩展环境</a>的模块是这种方式的例子。</p>
<p>　　模块可能包含<em>子模块(submodule)</em> 提供其特性子集。以环境作为模块时，<a href="#npla1-%E7%8E%AF%E5%A2%83">环境子对象</a>可作为子模块。</p>
<p>　　从模块的源得到提供一个模块的所有绑定集合的环境对象的过程称为模块的<em>加载(loading)</em> 。</p>
<p>　　模块加载可能失败。失败的模块加载<a href="#npla1-%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　<a href="#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">根环境</a>加载的失败不被直接依赖这些环境的 NPLA1 用户程序处理（而视为实现初始化的运行时错误）。</p>
<p>　　一般地，模块和加载模块得到的环境对象不保证具有直接的对应关系：一个模块的绑定可以由一个或多个环境提供，一个已被加载的环境可能提供零个或多个程序可见的模块。但除非另行指定，一个模块的绑定不在超过一个的不相交的环境（之间没有直接或间接父环境关系）中提供。</p>
<p>　　<a href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">库</a>的实现可作为<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">语言实现</a>。<a href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">库特性</a>可以被模块化，在其中通过<a href="#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">库环境</a>一并被提供。</p>
<p>　　程序可通过加载外部模块来源取得模块。除非另行指定，这种模块以一个一等环境对象（可包含作为环境的直接或间接子对象）中的绑定提供。</p>
<h3 id="模块的初始化和加载"><a class="header" href="#模块的初始化和加载">模块的初始化和加载</a></h3>
<p>　　<a href="#npla1-%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96">实现环境初始化</a>时可提供模块，包含其中必要的使模块中特性可用的初始化。</p>
<p>　　实现环境初始化时，可访问不作为公开接口提供的模块的源，从源<em>加载(load)</em> 这些模块。</p>
<p><strong>注释</strong> 派生实现可同时以标准库以外形式提供这些源为公开接口，用户程序也可显式地加载这些源对应的模块。</p>
<p>　　待加载的源的位置可通过称为<em>加载路径(load path)</em> 的字符串指定。加载路径可精确指定确切的源，或提供使实现<em>搜索(search)</em> 特定的源的起点。具体可接受的加载路径格式以及加载路径映射到确切的源的规则由提供特性的实现定义。</p>
<p><strong>原理</strong> 有的语言实现直接使用加载路径作为搜索路径，如 <a href="https://www.gnu.org/software/guile/manual/html_node/Installing-Site-Packages.html">GNU Guile</a> 。有的语言实现基于不同的原语，称为<em>导入路径(import path)</em> ，如 <a href="https://docs.python.org/3/reference/import.html">Python</a> 。</p>
<p>　　除非另行指定：</p>
<ul>
<li>若这些源可能引起引入非公开的接口的副作用，则对应的模块不应被用户程序直接加载。</li>
<li>假定加载这些模块时，<a href="#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>是和<a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">标准环境</a>或与其等价的其它环境。
　　* <strong>注释</strong> 关于标准环境，参见 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>make-standard-environment</code></a> 。
<ul>
<li>其中，等价指使用其它环境不引入程序<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>差异。</li>
<li><strong>注释</strong> 等价的环境的例子包括以标准环境为父环境的<a href="#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">空环境</a>，以及这样的空环境<a href="#%E5%AF%BC%E5%85%A5%E7%AC%A6%E5%8F%B7">导入符号</a>的得到的结果。</li>
<li><strong>注释</strong> 若模块的加载不访问加载时初始的当前环境（通常仅在本机模块上适用），加载模块使用的环境可不影响可观察行为而不影响假定（即便和标准环境不等价）。</li>
</ul>
</li>
</ul>
<p>　　违反以上要求或假定的程序<a href="#npla1-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">行为未定义</a>。</p>
<p><strong>原理</strong></p>
<p>　　以源程序模块实现时，一般不要求检查<a href="#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">初始环境</a>。这能有效减少实现的复杂性。</p>
<p>　　因为标准环境不提供用户程序检查是否和其中定义的实体一致的直接的方法，通过替代的检查可能排除符合假定的初始环境。</p>
<p><strong>注释</strong></p>
<p>　　这里的初始化可包含派生实现定义的其它初始化。</p>
<p>　　虽然 NPLA1 标准库不作为接口保证提供这些源，这里的假定和 [ISO C++] <a href="https://eel.is/c++draft/using.headers">[using.headers]</a> 对引入标准库头的程序位置的限制类似：语言实现能有效地假定源程序中引入标准库头的上下文，因此标准库中的名称具有预期的含义。</p>
<h3 id="模块稳定性"><a class="header" href="#模块稳定性">模块稳定性</a></h3>
<p>　　提供模块绑定的环境依赖已知来源的绑定而确保<a href="#%E7%8E%AF%E5%A2%83%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7">稳定</a>。</p>
<p>　　除非另行指定，模块中的特性依赖提供模块绑定的环境的生存期。</p>
<p>　　除非另行指定，标准库实现应确保其中的模块在程序的生存期中可用。</p>
<p><strong>原理</strong></p>
<p>　　特性依赖性允许实现操作的模块中绑定的<a href="#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>可具有静态环境是提供模块绑定的环境的<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的合并子的实现。</p>
<p><strong>注释</strong></p>
<p>　　稳定要求同 [R<sup>n</sup>RK] 的 <code>get-module</code> 的约定。但因为<a href="#%E8%A2%AB%E7%BB%91%E5%AE%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%80%BC%E5%92%8C%E5%8F%AF%E8%A7%82%E5%AF%9F%E8%A1%8C%E4%B8%BA">值稳定性</a> ，<a href="#%E7%8E%AF%E5%A2%83%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7">和 Kernel 不同</a>，NPLA1 的稳定绑定<a href="#%E8%A2%AB%E7%BB%91%E5%AE%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%80%BC%E5%92%8C%E5%8F%AF%E8%A7%82%E5%AF%9F%E8%A1%8C%E4%B8%BA">一般不可修改</a>。</p>
<p>　　对标准库模块，稳定性要求一般表示其中的特性不能依赖用户程序运行时的非特定的<a href="#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>，而可依赖从<a href="#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">基础环境</a>及从基础环境派生的<a href="#%E6%96%B0%E7%8E%AF%E5%A2%83">新环境</a>。</p>
<p>　　生存期可用的规则一般要求标准库实现在初始化后保存<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境强引用</a>。</p>
<h2 id="库接口约定"><a class="header" href="#库接口约定">库接口约定</a></h2>
<p>　　<a href="#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">基础环境</a>的特性在<a href="#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">根环境</a>中直接绑定，统称根环境特性。</p>
<p>　　关于特性的约束作用于接口描述。不改变<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>时，实现可使用不同的未指定的根环境提供绑定。</p>
<p>　　描述模块接口的小节可以指定适用于该小节的模块约定。此时，描述的边界应能和其余的<a href="#%E5%BA%93%E6%8E%A5%E5%8F%A3%E5%AE%9E%E4%BD%93">实体</a>区分。</p>
<p>　　接口可能提供关于宿主语言<a href="#npla1-%E4%BA%92%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">互操作的约定</a>，作为对提供这些支持的实现的要求。</p>
<p><strong>注释</strong></p>
<p>　　具体特性参见 <a href="#npla1-%E6%A0%B9%E7%8E%AF%E5%A2%83%E7%89%B9%E6%80%A7">NPLA1 根环境特性</a>。</p>
<p>　　具体根环境的存在性未指定。在同一个环境中可见的不同变量可能来自不同的根环境。</p>
<p>　　接口描述的顺序同 [R<sup>n</sup>RK] §4 的原理，允许接口仅依赖先前出现的接口派生实现。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，库主要提供<a href="#%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB">一元谓词</a>，也不需要为 <code>&lt;body&gt;</code> 隐含 <code>$sequence</code> 支持重新定义 <code>$vau</code> 等操作，不需要拆分 Kernel 的核心库特性到 [R<sup>n</sup>RK] §5 和 §6 。</p>
<h3 id="库接口实体"><a class="header" href="#库接口实体">库接口实体</a></h3>
<p>　　按实体区分，NPLA1 的库特性有两类：<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">对象</a>和<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作</a>。</p>
<p>　　对象语言中可实现的操作以<a href="#%E5%87%BD%E6%95%B0">函数</a>的形式提供，可以是<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>的<a href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">宿主语言</a>函数或由现有操作派生的<a href="#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>。</p>
<p>　　除此之外，派生实现可指定提供对象或操作对应的<a href="#%E9%9D%9E%E5%B8%B8%E8%A7%84%E5%87%BD%E6%95%B0">非常规函数</a>。</p>
<p>　　操作的<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">结果</a>是对应的<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>在<a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%9D%A1%E4%BB%B6">正常控制</a>下取得的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>，即<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>；操作的作用即<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">函数调用的作用</a>。</p>
<p>　　根据操作的功能描述，对应的函数可能具有<a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%9D%A1%E4%BB%B6">非正常的控制条件</a>。此时，函数调用不取得函数值，操作不具有结果。</p>
<p><strong>注释</strong> 非正常退出时，函数调用的求值结果可以是<a href="#npla1-%E9%94%99%E8%AF%AF">错误对象</a>或派生实现定义的其它表示求值结果的实体。</p>
<p>　　除非另行指定，函数调用时具有的<a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF%E6%9D%A1%E4%BB%B6">错误条件</a>是非正常的控制条件；其中，以<a href="#npla1-%E5%BC%82%E5%B8%B8">异常</a>实现错误条件的情形具有<a href="#%E5%BC%82%E5%B8%B8">异常条件</a>。</p>
<p>　　特定的操作约定对应的函数是<a href="#%E7%BB%88%E6%AD%A2%E4%BF%9D%E8%AF%81">终止函数</a>或<a href="#%E7%BB%88%E6%AD%A2%E4%BF%9D%E8%AF%81">全函数</a>；这不适用于满足错误条件的情形。</p>
<p>　　特定的操作约定对应的函数<a href="#%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%BA%A6%E5%AE%9A">作为算法过程满足计算复杂度约定</a>。</p>
<p><strong>注释</strong> 排除错误条件，指定复杂度的函数是终止函数。</p>
<p>　　本章其余各节适用 NPLA1 对象语言中的这些操作。</p>
<p>　　操作中的大部分具有特定的名称，满足<a href="#%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E7%BA%A6%E5%AE%9A">函数名称约定</a>。</p>
<p>　　其它操作不具有特定名称，可由上述操作间接地提供，如蕴含在某些操作涉及的<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>中。</p>
<p><strong>注释</strong></p>
<p>　　在对象语言中不能直接表达的操作不能作为库特性，这些操作不对应库接口实体，其结果和作用仍照<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">更一般的规则</a>处理。</p>
<p>　　渐进复杂度常以 <a href="https://zh.wikipedia.org/zh-cn/%E5%A4%A7O%E7%AC%A6%E5%8F%B7"><tt>O</tt> 记号</a>指定上界。</p>
<p>　　若函数调用总是取得值，指定复杂度的函数同时是全函数。</p>
<h3 id="库特性实现分类"><a class="header" href="#库特性实现分类">库特性实现分类</a></h3>
<p>　　库特性分为<em>基本的(primitive)</em> 和<em>派生的(derived)</em> 。</p>
<p><strong>原理</strong></p>
<p>　　前者在设计上不分解为更小的其它特性的组合，通常需要本机实现；后者可由可移植的 NPLA1 源代码实现。</p>
<p><strong>注释</strong></p>
<p>　　区分基本和派生的特性在设计上类似 [R<sup>n</sup>RK] 中的基本和库特性。</p>
<p>　　注意和 [R<sup>n</sup>RK] 的库特性不同（而更接近宿主语言），NPLA1 的库特性是以 NPLA1 程序使用的接口而非实现的角度定义的，不总是使用对象语言实现，外延更广。</p>
<h3 id="标准库"><a class="header" href="#标准库">标准库</a></h3>
<p>　　本文档中要求的通过<a href="#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">基础环境</a>直接或间接提供的<a href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">库</a>总称<em>标准库(standard library)</em> 。</p>
<p>　　标准库的接口随语言规范在本章和<a href="#npla1-%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E6%89%A9%E5%B1%95%E7%8E%AF%E5%A2%83">参照实现扩展环境</a>约定。</p>
<p>　　<em>核心库(core library)</em> 是提供直接绑定在基础环境中的、保证可派生实现的接口的标准库模块。</p>
<p>　　在参照实现环境中的不同标准库模块的绑定都可在基础环境访问。</p>
<p>　　在参照实现扩展环境中的标准库模块以其它环境（通常作为基础环境的子对象提供）中的绑定和基础环境隔离。</p>
<p>　　派生实现可以库的形式提供语言扩展或其它功能特性，扩充标准库。</p>
<p><strong>注释</strong></p>
<p>　　因为<a href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">库的定义</a>和 [R<sup>n</sup>RK] 指定的不同，类似 [R<sup>n</sup>RK] §4 约定的基本特性，属于 NPLA1 <a href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">库特性</a>。</p>
<p>　　<a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">基本派生特性</a>可能从<a href="#%E6%A0%B8%E5%BF%83%E5%BA%93">核心库</a>中迁移。因为绑定的来源不变，使用其中的接口程序仍然可能保持兼容。</p>
<h3 id="扩展库"><a class="header" href="#扩展库">扩展库</a></h3>
<p>　　基础环境也可提供的附带的其它接口，和标准库使用相同的约束。</p>
<p>　　一些操作的描述使用等价的表达式求值指定。除非另行指定，这些表达式中：</p>
<ul>
<li>若<a href="#%E7%AC%A6%E5%8F%B7">符号值</a>和先前出现的函数同名，则指称对应的操作。</li>
<li>默认使用基础环境作为求值环境。</li>
</ul>
<h2 id="常规函数约定"><a class="header" href="#常规函数约定">常规函数约定</a></h2>
<p>　　本节提供<a href="#%E5%BA%93%E6%8E%A5%E5%8F%A3%E5%AE%9E%E4%BD%93">作为库特性的函数</a>的默认规则以简化库特性的描述。</p>
<p><strong>注释</strong> 库的一般派生实现和用户程序的实现也建议参照本节约定。</p>
<p>　　除非另行指定：</p>
<ul>
<li>操作以指定名称的变量的形式提供，求值为可参与<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>的一等实体（但函数合并不一定保证是<a href="#%E7%BF%BB%E8%AF%91%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%A7%84%E5%88%99">合式的</a>可求值的表达式）。</li>
<li>函数作为表达式，求值为<a href="#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>，其函数合并的求值蕴含<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">函数调用</a>。</li>
<li>本文档约定的函数在其调用不依赖用户程序提供的非终止函数时，总是<a href="#%E7%BB%88%E6%AD%A2%E4%BF%9D%E8%AF%81">终止函数</a>。
<ul>
<li>若满足上述条件的函数不具有<a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF%E6%9D%A1%E4%BB%B6">错误条件</a>，忽略因实现环境引发的错误（如<a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF%E6%9D%A1%E4%BB%B6">宿主资源耗尽</a>），视为（对象语言中的）<a href="#%E7%BB%88%E6%AD%A2%E4%BF%9D%E8%AF%81">全函数</a>。</li>
</ul>
</li>
<li>本文档约定的函数蕴含以下情形时，调用非<a href="#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>：
<ul>
<li><a href="#%E9%94%99%E8%AF%AF">引起</a>操作或其它语言规则指定的<a href="#npla1-%E9%94%99%E8%AF%AF">错误</a>。</li>
<li>引起<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">对象的修改和改变</a>。</li>
</ul>
</li>
<li>在指定对应的函数调用是纯求值的操作上，排除满足引起非纯求值的条件的作用的情形外的其余求值，仍应是纯求值。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　一些操作因不保证排除<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a> ，对应的调用非纯求值。</p>
<p>　　但通过补充约定，特定的作用可能视为<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定行为</a>，且不被程序的其它<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">行为</a>依赖（如<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">可变管理状态</a>的改变），仍可假定其求值是视为纯求值。</p>
<p><strong>注释</strong></p>
<p>　　无条件遍历访问<a href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用子对象</a>的程序具有 <a href="#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">NPLA 未定义行为</a>，在讨论终止函数时已被排除。</p>
<p>　　对象的修改和改变可包括<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">转移</a>参数。</p>
<h3 id="函数值约定"><a class="header" href="#函数值约定">函数值约定</a></h3>
<p>　　除非另行指定：</p>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数值</a>不是<a href="#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>，以便通过保证满足<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC">间接值</a>生存期规则维护<a href="#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>。</li>
<li>函数不在函数值中<a href="#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">保留引用值</a>，即<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">函数值经过返回值转换</a>。
<ul>
<li><strong>注释</strong> 保留引用值时，函数值仍可能是非引用值。</li>
</ul>
</li>
<li>若函数值保留引用值，引用值被<a href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">折叠</a>。</li>
</ul>
<h3 id="实际参数约定"><a class="header" href="#实际参数约定">实际参数约定</a></h3>
<p>　　除非另行指定：</p>
<ul>
<li>函数的实际参数的<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">传递</a>不具有影响<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">作用</a>。
<ul>
<li><strong>注释</strong> 这一般要求避免复制宿主语言中复制时具有副作用的对象。</li>
</ul>
</li>
<li>函数的实际参数若被求值，<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0">蕴含左值到右值转换</a>。</li>
</ul>
<h3 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h3>
<p>　　除非另行指定：</p>
<ul>
<li>若函数合并指定的操作的<a href="#%E6%8E%A5%E5%8F%A3%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">约束</a>或要求<a href="#%E9%94%99%E8%AF%AF%E6%A3%80%E6%9F%A5">检查</a>的条件不被满足，<a href="#npla1-%E9%94%99%E8%AF%AF">引起错误</a>。</li>
<li>引起错误时<a href="#npla1-%E5%BC%82%E5%B8%B8">抛出异常</a>。</li>
</ul>
<p>　　求值时引起的错误使求值中断，<a href="#%E4%BD%9C%E7%94%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99">可引起副作用</a>，这样的副作用总是<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">后序</a>于已被求值的表达式中引起的副作用。</p>
<p>　　被错误处理和检查的函数不<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>参数或者函数调用外创建的对象。</p>
<h3 id="非常规函数"><a class="header" href="#非常规函数">非常规函数</a></h3>
<p>　　<a href="#%E8%BF%87%E7%A8%8B">续延</a>是默认不符合<a href="#%E5%B8%B8%E8%A7%84%E5%87%BD%E6%95%B0%E7%BA%A6%E5%AE%9A">常规函数约定</a>的例外。</p>
<p>　　非常规函数归类为对象而非<a href="#%E5%BA%93%E6%8E%A5%E5%8F%A3%E5%AE%9E%E4%BD%93">操作</a>，但调用时<a href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">错误处理</a>同常规函数。</p>
<p><strong>注释</strong></p>
<p>　　类似 [R<sup>n</sup>RK] 而和 [R<sup>n</sup>RS] 不同，作为一等对象的续延和续延的实际参数是否求值无关，因此不是合并子，且默认<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值算法</a>不支持续延作为函数合并被求值；但续延可通过特定的操作转换为应用子。</p>
<h2 id="函数名称约定"><a class="header" href="#函数名称约定">函数名称约定</a></h2>
<p>　　除非另行指定，本文档以指定名称的函数表示具有名称的操作时，其命名由本节的规则约定。</p>
<p>　　<em>函数名(function name)</em> 即函数的名称。</p>
<p><strong>注释</strong> 除非派生实现另行指定，<a href="#npla-%E7%8E%AF%E5%A2%83">函数名是变量名</a>。</p>
<p>　　为提供库的描述，本节同时约定这些函数名关联的函数具有的性质。</p>
<h3 id="函数名称前缀"><a class="header" href="#函数名称前缀">函数名称前缀</a></h3>
<p>　　确定为求值为操作子的函数名以 <code>$</code> 作为命名的前缀。</p>
<p><strong>原理</strong></p>
<p>　　同 [R<sup>n</sup>RK] ，操作子一般应在视觉上被强调而避免误用。<code>$</code> 来自 <strong>S</strong>pecial form 。</p>
<h3 id="函数名称后缀"><a class="header" href="#函数名称后缀">函数名称后缀</a></h3>
<p>　　函数名的最后的字符表示函数预期满足特定的约束或具有特定的目的。</p>
<p>　　以<a href="#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">引用标记字符</a>结尾的表示涉及引用的操作，参见<a href="#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D%E5%90%8E%E7%BC%80">以下</a>约定。</p>
<h4 id="谓词名称后缀"><a class="header" href="#谓词名称后缀">谓词名称后缀</a></h4>
<p>　　NPLA1 中的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">谓词</a>是 <a href="#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;predicate&gt;</code></a>，即返回类型为 <a href="#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;boolean&gt;</code></a> 的函数。</p>
<p>　　谓词的名称使用 <code>?</code> 结尾。</p>
<p><strong>注释</strong> 这类似 [R<sup>n</sup>RS] 和 [R<sup>n</sup>RK] 。</p>
<p>　　除非另行指定，以下引入的对象语言中的谓词对应的函数调用的求值是<a href="#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>。</p>
<p>　　以下是谓词的典型实例：</p>
<ul>
<li><a href="#%E7%B1%BB%E5%9E%8B%E8%B0%93%E8%AF%8D">类型谓词</a>：接受一个 <a href="#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;object&gt;</code></a> 参数，判断参数是特定的类型的对象。
<ul>
<li>调用这些类型谓词不引起错误。</li>
<li>仅当参数指定的对象具有对应类型时结果是 <code>#t</code> 。</li>
<li>除非另行指定，这些类型谓词忽略值类别的差异。</li>
</ul>
</li>
<li><a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">等价谓词</a>：接受两个参数，判断参数是否属于同一个等价类。</li>
</ul>
<p>　　因为 <code>&lt;boolean&gt;</code> 是 <a href="#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;test&gt;</code></a>的<a href="#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">子类型</a>，按照返回值为 <code>&lt;test&gt;</code> 的函数可在不严格要求 <code>&lt;boolean&gt;</code> 的上下文中起类似的作用，视为<em>广义谓词(general predicate)</em> 。</p>
<p>　　谓词是广义谓词的子类型。</p>
<p><strong>注释</strong></p>
<p>　　大多数上下文接受 <code>&lt;test&gt;</code> 而不严格要求 <code>&lt;boolean&gt;</code> 。这<a href="#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">和 [R<sup>n</sup>RK] 不同</a>。</p>
<p>　　大多数类型谓词判断的类型一般同<a href="#%E6%8E%A5%E5%8F%A3%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">文法约定</a>，而无关<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB%E5%92%8C%E7%B1%BB%E5%9E%8B">值类别</a>。</p>
<p>　　以具名的函数提供的类型谓词，其函数名称通常和<a href="#%E5%AE%9E%E4%BD%93%E5%85%83%E7%B4%A0%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">文法指定的类型</a>对应。</p>
<p>　　引起错误可具有副作用，其求值不保证是纯求值。</p>
<p>　　广义谓词不使用后缀 <code>?</code> 。另见 [R<sup>n</sup>RK] §6.1.2 关于 <code>$and?</code> 的原理及 [R<sup>6</sup>RS-Rationale] §15.1 。</p>
<h4 id="赋值函数名称后缀"><a class="header" href="#赋值函数名称后缀">赋值函数名称后缀</a></h4>
<p>　　<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>一个对象而不要求第一参数是引用值且不改变被赋值对象类型的<a href="#%E8%B5%8B%E5%80%BC">赋值操作</a>对应的函数名以 <code>&lt;-</code> 结尾。</p>
<p><strong>注释</strong></p>
<p>　　这通常和宿主语言的赋值操作对应，可能有附加的副作用而不是简单地替换值。</p>
<h4 id="修改函数名称后缀"><a class="header" href="#修改函数名称后缀">修改函数名称后缀</a></h4>
<p>　　除<a href="#%E8%B5%8B%E5%80%BC%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E5%90%8E%E7%BC%80">函数名以 <code>&lt;-</code> 结尾</a>外的操作中，为了蕴含（不直接通过求值操作数或其子表达式引起的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>的）<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>的函数是<em>修改函数(modification function)</em> ，其名称使用 <code>!</code> 结尾。</p>
<p>　　<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">可变管理状态的改变</a>不需要指示可修改；此外，类似地，不改变<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>的<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">隐藏状态</a>的修改不属于上述修改。</p>
<p><strong>注释</strong> 这类似 [R<sup>n</sup>RK] 。</p>
<p>　　这类操作同时是<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">改变操作</a>。</p>
<p><strong>注释</strong> 这类似 [R<sup>n</sup>RS] 和 [R<sup>n</sup>RK] 。</p>
<p>　　一些其它情形下，特定的函数不被视为改变操作但其调用仍可能引起副作用，这样的函数名不要求带有 <code>!</code> 后缀：</p>
<ul>
<li>直接求值操作数、其子表达式关联的对象可能引起副作用。
<ul>
<li><strong>注释</strong> 这和 [R<sup>n</sup>RK] 类似。</li>
</ul>
</li>
<li>一些操作可能非确定性地包含使操作数指称或引用的对象的值<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC">有效但未指定</a>的修改。
<ul>
<li><strong>注释</strong> 这和 [R<sup>n</sup>RK] 不同。</li>
<li><strong>注释</strong> 如<a href="#%E8%BD%AC%E7%A7%BB%E5%AF%BC%E8%87%B4%E7%9A%84%E4%BF%AE%E6%94%B9">隐式的转移操作</a>。
<ul>
<li>这不包含预期成功时确定总是转移的操作。</li>
<li>排除不允许任何修改（如总是进行<a href="#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型错误</a>，要求操作数是<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">不可修改引用</a>）的情形，即便转移后<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">状态不变</a>，仍被视为修改。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　修改函数的调用的求值可能因为不同的操作数的影响，而可能依赖具体的条件确定是否改变对象：</p>
<ul>
<li>当通过操作数直接指定的条件确定是否修改时。</li>
<li>当通过操作数确定被修改的对象时。</li>
<li>当通过操作数确定引起修改的对象时。</li>
</ul>
<p>　　这些函数的<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>是<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">未指定值</a>。</p>
<p><strong>注释</strong></p>
<p>　　修改函数的调用不一定总是具有能视为修改的副作用，可能不改变任何对象。</p>
<p>　　这些函数的返回值的规定和 [R<sup>n</sup>RS] 相同，但和使用可用谓词 <code>inert?</code> 判断的<em>惰性(inert)</em> 值的 [R<sup>n</sup>RK] 不同。</p>
<h3 id="引用标记字符的函数名后缀"><a class="header" href="#引用标记字符的函数名后缀">引用标记字符的函数名后缀</a></h3>
<p>　　一些操作以（<a href="#%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E5%90%8E%E7%BC%80">可能的 <code>!</code></a> 前）结尾<a href="#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">引用标记字符</a>和不以引用标记字符结尾的名称提供多个变体。其中不含结尾的引用标记字符的表示<a href="#%E5%BA%93%E6%8E%A5%E5%8F%A3%E5%AE%9E%E4%BD%93">操作的结果</a>不是引用值，要求<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值传递</a>。</p>
<p>　　其它一些操作可能只提供以 <code>%</code> 结尾的变体。</p>
<p>　　不使用引用标记字符的函数及其函数值时，不因引入引用值违反<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">内存安全</a>。</p>
<p><strong>原理</strong> 这允许通过避免公开带有引用标记字符后缀的操作提供一个内存安全的子集，以在派生实现对语言进行裁剪。</p>
<p>　　名称以引用标记字符结尾的操作属于以下分类之一：</p>
<ul>
<li>可能<a href="#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">直接保留引用值</a>的操作：操作的<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">结果</a>及<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">作用</a>依赖实际参数（需要时经过隐含的<a href="#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">左值到右值转换</a>）的值。</li>
<li>可能<a href="#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">间接保留引用值</a>的操作：可涉及不同的环境，结果和作用依赖实际参数（需要时经过隐含的左值到右值转换）在这些环境中被求值后确定。</li>
</ul>
<p>　　对可能在函数值中间接保留引用值的操作，以 <code>%</code> 结尾表示对应的函数返回时<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">不要求返回非引用值</a>。</p>
<p>　　其它可能在函数值中直接保留引用值的提供不同引用标记字符的多个变体的操作：</p>
<ul>
<li>以 <code>%</code> 结尾表示函数使用不进行<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">左值到右值转换</a>的<a href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">折叠</a>的引用值参数，或返回折叠的引用值。</li>
<li>以 <code>&amp;</code> 结尾表示函数使用不进行左值到右值转换的折叠的引用值参数，或返回折叠的引用值。</li>
<li>以 <code>@</code> 结尾表示函数使用不进行左值到右值转换的<a href="#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">未折叠的引用值</a>参数，或返回未折叠的引用值。</li>
</ul>
<p>　　以上引用值参数的使用指以依赖这些参数的方式构成函数的<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>和/或决定引起的相应的副作用；返回的引用值来自引用值参数（若存在）。</p>
<p><strong>原理</strong></p>
<p>　　为满足<a href="#%E9%80%82%E7%94%A8%E6%80%A7">适用性</a>，同时考虑避免误用和允许使用引用避免复制，对一些操作显式使用以 <code>%</code> 或 <code>&amp;</code> 结尾的函数名称以得到特别关注。</p>
<p>　　因为语义相关，结尾引用标记字符使用和绑定的<a href="#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6">引用标记字符</a>相同的字符，但不复用具体规则。</p>
<p>　　尽管设计时没有参照，使用函数结尾的引用标记字符和其它一些语言的类似特性的使用惯例也一致，如 <a href="https://www.php.net/references.return">PHP 的 function <code>&amp;</code> 语法</a>。</p>
<p><strong>注释</strong></p>
<p>　　按这些规则，函数名以 <code>%</code> 结尾的操作在取折叠的引用值时，可能同时实现<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的转发。这相当于被访问的被引用对象作为宿主语言的 <code>std::forward</code> 的参数后的调用结果作为操作的结果，但此处一般仍然保证支持 <a href="#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C-ptc">PTC</a> 。</p>
<p>　　函数名以 <code>&amp;</code> 结尾的操作取得的折叠的引用值可能是<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">唯一引用</a>。</p>
<h4 id="引用折叠的约定"><a class="header" href="#引用折叠的约定">引用折叠的约定</a></h4>
<p>　　取得折叠的引用值的默认约定同<a href="#npla1-%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">NPLA1 默认规则</a>。</p>
<p>　　以上函数<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>中：</p>
<ul>
<li>折叠的引用值对调用时引入的引用值（不论是否来自参数）有效。</li>
<li>除非另行指定，不对同一个对象引用折叠多次。</li>
<li><strong>注释</strong> 这些规则不保证结果是<a href="#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">完全折叠的引用值</a>。返回折叠引用值的函数可因未完全折叠的引用值参数等返回未折叠的引用值。</li>
</ul>
<p>　　这允许函数的内部实现引入一次引用值时，对来自每个参数的引用值至多只需要实现一次折叠。</p>
<p>　　推论：若参数都不是未折叠的引用值，调用名称不以 <code>@</code> 结尾的函数不引入未折叠的引用值。</p>
<p>　　若指定的操作按不同操作数可涉及或不涉及和当前不同环境下的求值，提供不保留引用值和保留引用值的多个变体的操作以便保证内存安全。</p>
<p><strong>注释</strong></p>
<p>　　提供不保留引用值和保留引用值的多个变体的操作以便保证内存安全的操作包括<a href="#%E5%8F%AF%E6%8F%90%E4%BE%9B%E4%BB%A5%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%BB%93%E5%B0%BE%E5%8F%98%E4%BD%93%E7%9A%84%E5%87%BD%E6%95%B0">可提供以引用标记字符结尾变体的函数</a>和<a href="#%E4%B8%8D%E6%8F%90%E4%BE%9B%E7%BB%93%E5%B0%BE%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E5%AF%B9%E5%BA%94%E5%8F%98%E4%BD%93%E7%9A%84%E5%87%BD%E6%95%B0">不提供结尾引用标记字符对应变体的函数</a>指定的操作。</p>
<h4 id="引用标记字符函数名与内存安全的关系"><a class="header" href="#引用标记字符函数名与内存安全的关系">引用标记字符函数名与内存安全的关系</a></h4>
<p>　　利用区分引用标记字符结尾的操作，可指定具体关于具体操作的<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81%E6%9C%BA%E5%88%B6">对象语言接口的安全保证机制</a>。</p>
<p><strong>原理</strong></p>
<p>　　<a href="#%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E7%BA%A6%E5%AE%9A">函数名</a>结尾的引用标记字符用于强调无法总是保证内存安全的<a href="#%E9%80%82%E7%94%A8%E6%80%A7">危险操作</a>。</p>
<p>　　一般地，仅在明确需要引用值时使用引用标记字符结尾的操作，而避免返回悬空引用。这类似宿主语言函数的 <code>auto</code> 而非 <code>auto&amp;&amp;</code> 的返回类型，但宿主语言中返回非引用类型的表达式两者含义不同。</p>
<p>　　函数名不带有引用标记字符结尾的操作通过避免<a href="#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">保留引用值</a>提供一定的<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">内存安全保证</a>，而带有引用标记字符结尾的操作较容易引起注意。</p>
<p>　　这符合<a href="#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7">易预测性</a>。</p>
<p><strong>注释</strong></p>
<p>　　一个典型例子是在函数中<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">返回标识符求值</a>的表达式：</p>
<ul>
<li><a href="#npla1-%E8%A7%84%E8%8C%83%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">标识符求值后指称左值引用值</a>，这个引用值的有效性依赖<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">合并子调用</a>时创建的<a href="#npla1-%E7%8E%AF%E5%A2%83">新环境</a>的可被访问。</li>
<li>这个环境在调用后通常被销毁，若使用带有引用标记字符结尾的操作关于对应的函数返回引用值的语义，在函数值中保留引用值，返回为<a href="#%E6%97%A0%E6%95%88%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC">悬空引用</a>，容易误用。</li>
</ul>
<h4 id="保留引用值的约定"><a class="header" href="#保留引用值的约定">保留引用值的约定</a></h4>
<p>　　可能<a href="#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">直接保留引用值</a>的操作中，不带有引用标记字符的操作<a href="#%E4%BC%A0%E9%80%92%E9%9D%9E%E5%BC%95%E7%94%A8%E5%80%BC%E5%8F%82%E6%95%B0">传递非引用值参数</a>，其它函数<a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91">转发参数</a>。</p>
<p>　　可能直接保留引用值的操作包括<a href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0">容器构造器或访问器</a>，以及可能<a href="#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E7%9B%AE%E6%A0%87">使对象中包含引用值</a>的<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改操作</a> 。</p>
<p>　　这些操作的<a href="#%E5%BA%93%E6%8E%A5%E5%8F%A3%E5%AE%9E%E4%BD%93">结果</a>或引起的副作用完全由实际参数（根据是否存在引用标记字符 <code>%</code> 指定是否不经过隐含的左值到右值转换）的值确定。</p>
<p>　　其中，带有引用标记字符结尾的操作是直接保留引用值操作。</p>
<p>　　容器构造器可在元素保留参数的引用值。作为结果的容器总是<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">作为非引用值返回</a>，即在结果中保留参数的引用值。</p>
<p><strong>原理</strong></p>
<p>　　以上操作是否确定地保留引用值在一些情形容易证明<a href="#%E5%AE%89%E5%85%A8%E6%80%A7%E9%99%84%E5%8A%A0%E8%AF%81%E6%98%8E">附加调用安全</a>，此时可放宽<a href="#%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C%E5%AD%90%E9%9B%86">安全特性子集</a>的条件确保安全性；在此不作要求。</p>
<p>　　对构造器及部分修改操作区分引用标记字符结尾可强调一些非预期保留引用值的容易误用情形；尽管总是返回非引用值。</p>
<p>　　因<a href="#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">转发参数而被保留的引用值</a>不会被<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">返回值转换</a>或类似的操作影响，在构造的容器对象作为非引用值返回时，仍会保留引用值。对应宿主语言中，可有更显著的差异，如构造器对应的 <code>std::tuple</code> 的 <code>std::make_tuple</code> 和 <code>std::forward_as_tuple</code> 。</p>
<h3 id="可提供以引用标记字符结尾变体的操作"><a class="header" href="#可提供以引用标记字符结尾变体的操作">可提供以引用标记字符结尾变体的操作</a></h3>
<p>　　部分操作使用<a href="#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D%E5%90%8E%E7%BC%80">以引用标记字符结尾的函数名</a>。</p>
<p>　　可提供不同变体的操作被严格限制，以避免过度区分造成在使用上不必要的复杂性。</p>
<h4 id="可能使结果包含引用值的容器构造器"><a class="header" href="#可能使结果包含引用值的容器构造器">可能使结果包含引用值的容器构造器</a></h4>
<p>　　容器构造器作为包括典型的构造器，可提供不同的变体（或其中之一）：</p>
<ul>
<li>不在函数值中保留引用值，实际参数发生左值到右值转换作为容器的元素，这减少误用<a href="#%E6%97%A0%E6%95%88%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC">悬空引用</a>的可能性。</li>
<li>在函数值中保留引用值，实际参数不发生左值到右值转换而直接作为容器的元素，是<a href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">不安全操作</a>，但可以确保构造的对象中包含参数指定的引用值。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　当只提供没有结尾引用标记字符对应名称的操作时，不需要满足<a href="#%E4%B8%8D%E6%8F%90%E4%BE%9B%E7%BB%93%E5%B0%BE%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E5%AF%B9%E5%BA%94%E5%90%8D%E7%A7%B0%E7%9A%84%E6%93%8D%E4%BD%9C">以下</a>的约定。</p>
<p>　　在结果中保留参数的引用值的<a href="#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E7%BA%A6%E5%AE%9A">容器构造器</a>可能<a href="#%E4%BF%9D%E7%95%99%E9%97%B4%E6%8E%A5%E5%80%BC">保留可能无效的间接值</a>而属于不安全操作。</p>
<h4 id="可能使结果包含引用值的容器元素访问器"><a class="header" href="#可能使结果包含引用值的容器元素访问器">可能使结果包含引用值的容器元素访问器</a></h4>
<p>　　带有引用标记字符结尾的操作是<a href="#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">直接保留引用值</a>操作。</p>
<p>　　函数名不带有标记字符结尾的访问器属于<a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91">参数转发操作</a>和<a href="#%E5%87%BD%E6%95%B0%E5%80%BC%E8%BD%AC%E5%8F%91">函数值转发操作</a>。</p>
<h4 id="可能使对象中包含引用值的修改操作"><a class="header" href="#可能使对象中包含引用值的修改操作">可能使对象中包含引用值的修改操作</a></h4>
<p>　　<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">修改对象或对象的子对象</a>可<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC">无效化引用值</a>而影响内存安全。</p>
<p>　　对<a href="#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%9D%A5%E6%BA%90">可能保留参数中的引用值</a>的操作，内存安全也依赖这些操作的指定修改后的值的内存安全性。</p>
<p>　　在判定<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">内存安全</a>的意义上，以下操作的所有参数都可能是<a href="#%E4%BF%9D%E7%95%99%E9%97%B4%E6%8E%A5%E5%80%BC">被保留的间接值</a>：</p>
<ul>
<li><em>简单赋值(simple assignment)</em>（包含于<a href="#%E8%B5%8B%E5%80%BC">赋值操作</a>）。</li>
<li>列表元素<em>改变器(mutator)</em> 。</li>
</ul>
<p>　　修改的结果由实际参数（必要时经过隐含的<a href="#%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0%E7%BA%A6%E5%AE%9A">左值到右值转换</a>）的值确定。</p>
<p>　　以上操作都要求检查表示被修改的参数是左值。</p>
<p>　　以上操作中，带有引用标记字符结尾的操作<a href="#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">在对象中直接保留引用值</a>。</p>
<h4 id="可能间接保留引用值的操作"><a class="header" href="#可能间接保留引用值的操作">可能间接保留引用值的操作</a></h4>
<p>　　一些操作可涉及不同的环境，参数在这些环境中被求值可能得到引用值。</p>
<p>　　这些操作包括求值为操作子的以下函数：</p>
<ul>
<li>以求值 <code>&lt;body&gt;</code> 作为<a href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">尾上下文</a>的操作。</li>
<li>以求值 <code>&lt;expressions&gt;</code> 初始化 <code>&lt;defindiend&gt;</code> 指定的对象的<a href="#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>。</li>
<li>以求值 <code>&lt;expression&gt;</code> 或视为 <code>&lt;expression&gt;</code> 的 <code>&lt;object&gt;</code>（及可能发生的<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">返回值转换</a>）作为唯一作用的函数。</li>
</ul>
<p>　　以上操作中，带有引用标记字符结尾的操作是间接保留引用值操作，表示求值结果不要求<a href="#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">按值传递</a>并可<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">返回引用值</a>。</p>
<p><strong>原理</strong></p>
<p>　　不提供<a href="#%E5%87%BD%E6%95%B0%E5%80%BC%E8%BD%AC%E5%8F%91">函数值转发</a>的形式，因为：</p>
<ul>
<li>选用经过<a href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>得到的值已可保证避免求值结果中的<a href="#%E6%97%A0%E6%95%88%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC">悬空引用</a>。</li>
<li>直接返回可能是引用值的值具有更简明直观的语义。</li>
<li>若需转发，可直接<a href="#%E8%BD%AC%E5%8F%91%E5%8F%82%E6%95%B0%E6%88%96%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%AE%9E%E7%8E%B0">在被求值的表达式中显式构造</a>。</li>
<li>不需要假设求值结果<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初值符</a>作为函数值转发依据的参数。</li>
</ul>
<p>　　和此处直接在参数中给出被求值表达式不同，应用子中的一些求值的操作不属于上述操作，而不提供<a href="#%E5%8F%AF%E8%83%BD%E9%97%B4%E6%8E%A5%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C">结尾引用标记字符对应名称的操作</a>。</p>
<h3 id="不提供结尾引用标记字符对应名称的操作"><a class="header" href="#不提供结尾引用标记字符对应名称的操作">不提供结尾引用标记字符对应名称的操作</a></h3>
<p>　　其它操作不使用<a href="#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D%E5%90%8E%E7%BC%80">以引用标记字符结尾的函数名</a>。</p>
<p>　　若这些操作的结果直接<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">来自操作数或其子对象</a>（和以 <code>%</code> 结尾操作的情形类似），则：</p>
<ul>
<li>可<a href="#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%9D%A5%E6%BA%90">保留参数中的引用值</a>并<a href="#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E7%9B%AE%E6%A0%87">在函数值中保留</a>。</li>
<li>不提供避免保留值的对应操作，或仅在此基础上提供总是包含等价<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">返回值转换</a>的对应操作。</li>
</ul>
<p>　　否则，这些操作不具有引用值结果。</p>
<p>　　部分操作的结果直接来自实际参数。此时，若不具有引用值结果，则<a href="#%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0%E7%BA%A6%E5%AE%9A">蕴含左值到右值转换</a>。</p>
<p><strong>原理</strong> 这些操作不会使用<a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>作为环境，所以不需要使用以引用标记字符结尾的变体要求注意区分返回引用值而避免误用。因此，不提供区分涉及引用的变体，这也使接口设计更清晰。</p>
<p>　　这些操作包括以下小节的情形。</p>
<p>　　部分操作涉及<a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91">参数转发</a>和<a href="#%E5%87%BD%E6%95%B0%E5%80%BC%E8%BD%AC%E5%8F%91">函数值转发</a>。这些操作不包含可提供<a href="#%E5%8F%AF%E6%8F%90%E4%BE%9B%E4%BB%A5%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%BB%93%E5%B0%BE%E5%8F%98%E4%BD%93%E7%9A%84%E6%93%8D%E4%BD%9C">以引用标记字符结尾变体的操作中的个别变体</a>。</p>
<p>　　其它不提供结尾引用标记字符对应名称的操作暂不保证支持保留引用值。</p>
<p>　　部分操作的内存安全性和可提供<a href="#%E5%8F%AF%E6%8F%90%E4%BE%9B%E4%BB%A5%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%BB%93%E5%B0%BE%E5%8F%98%E4%BD%93%E7%9A%84%E6%93%8D%E4%BD%9C">以引用标记字符结尾变体的操作</a>类似，也是在函数值中保留引用值的不安全操作，但仅在引用值参数被保留且以此访问<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>时体现。</p>
<p>　　这包括<a href="#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">直接保留引用值和间接保留引用值</a>的不同情形。</p>
<p>　　除<a href="#%E5%8F%AF%E7%9B%B4%E6%8E%A5%E4%BB%A5%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%9C%E4%B8%BA%E7%BB%93%E6%9E%9C%E7%9A%84%E6%93%8D%E4%BD%9C">可直接以引用值作为结果的操作</a>和其它节的操作不相交，以下分类对操作的参数和函数值分别约定，可能相交。</p>
<h4 id="可直接以引用值作为结果的操作"><a class="header" href="#可直接以引用值作为结果的操作">可直接以引用值作为结果的操作</a></h4>
<p>　　一些求值为操作子提供的函数选取特定的参数进行求值，作为控制操作。</p>
<p>　　操作数中被求值的参数直接决定是否为引用部分操作直接返回引用值。</p>
<p>　　被求值的 <code>&lt;test&gt;</code> <a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0">蕴含左值到右值转换</a>，其它被求值的参数不蕴含左值到右值转换，调用者需负责决定是否求值其它参数。</p>
<p><strong>注释</strong></p>
<p>　　这类似宿主语言中参数传递和返回 <code>auto&amp;&amp;</code> 类型。</p>
<h4 id="不以引用值作为结果的操作"><a class="header" href="#不以引用值作为结果的操作">不以引用值作为结果的操作</a></h4>
<p>　　部分操作类似<a href="#%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%BB%93%E6%9E%9C%E5%8C%85%E5%90%AB%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AE%B9%E5%99%A8%E6%9E%84%E9%80%A0%E5%99%A8">容器构造器</a>保证<a href="#%E8%BF%94%E5%9B%9E%E9%9D%9E%E5%BC%95%E7%94%A8%E5%80%BC">返回非引用值</a>，但并非直接以参数实现决定函数值：</p>
<p>　　若非构造器的操作总是返回列表和其它对元素具有所有权的容器对象，返回的对象总是按值传递。</p>
<p>　　为简化接口以及满足其它分类（如<a href="#%E7%9B%B4%E6%8E%A5%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91%E6%93%8D%E4%BD%9C">直接参数转发操作</a>），不提供不保留引用值的操作。</p>
<p>　　和提供不同的变体的作为构造器的操作不同，此处的情形的结果可能包含引用值（和以 <code>%</code> 结尾构造器的情形类似）。</p>
<p>　　若需要排除通过参数引入的引用值，应进行适当处理使参数中不含有会使这些操作引入引用值的构造。</p>
<p>　　类似保留引用值的容器构造器，这些操作<a href="#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E7%BA%A6%E5%AE%9A">可在结果中保留参数的引用值</a>。</p>
<h4 id="直接参数转发操作"><a class="header" href="#直接参数转发操作">直接参数转发操作</a></h4>
<p>　　部分<a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91">不带有引用标记字符的参数转发操作</a>是<a href="#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">可能直接保留引用值的操作</a>，称为直接参数转发操作。</p>
<p>　　函数名不使用引用标记字符，和<a href="#%E5%8F%AF%E6%8F%90%E4%BE%9B%E4%BB%A5%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%BB%93%E5%B0%BE%E5%8F%98%E4%BD%93%E7%9A%84%E6%93%8D%E4%BD%9C">可直接保留引用值的函数名</a>使用引用标记字符不一致：</p>
<ul>
<li>本节约定的函数和可直接保留引用值的函数名中带有 <code>%</code> 结尾的函数同属参数转发操作，但后者同时有不带有引用标记字符的变体。</li>
<li>本节不约定和可直接保留引用值的函数名中不带有引用标记字符结尾的函数对应的操作。</li>
</ul>
<p>　　这种不一致（和<a href="#%E5%87%BD%E6%95%B0%E5%80%BC%E8%BD%AC%E5%8F%91%E6%93%8D%E4%BD%9C">函数值转发操作</a>不同）是预期的特性：</p>
<p>　　和可直接保留引用值的操作不同：</p>
<ul>
<li>这些操作并非用于构造对参数具有所有权的对象，不适合提供不保留引用值的操作。</li>
<li>这些操作并非用于<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">取子对象</a>，返回值不一定是引用值，和具体操作相关，不适合使用引用标记字符区分。</li>
<li>为简化接口及满足其它分类（如<a href="#%E4%B8%8D%E4%BB%A5%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%9C%E4%B8%BA%E7%BB%93%E6%9E%9C%E7%9A%84%E6%93%8D%E4%BD%9C">不以引用值作为结果的操作</a>），不适合提供不保留引用值的操作。</li>
</ul>
<p>　　本节约定的函数对引用标记字符的使用和可提供<a href="#%E5%8F%AF%E6%8F%90%E4%BE%9B%E4%BB%A5%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%BB%93%E5%B0%BE%E5%8F%98%E4%BD%93%E7%9A%84%E6%93%8D%E4%BD%9C">以引用标记字符结尾变体的操作</a>的函数名的使用不一致，含义相当于前者的结尾的 <code>%</code> 。</p>
<p>　　以下的<a href="#%E5%87%BD%E6%95%B0%E5%80%BC%E8%BD%AC%E5%8F%91%E6%93%8D%E4%BD%9C">函数值转发操作</a>同时也是直接参数转发操作。</p>
<p>　　其它函数的参数传递的一般规则参见<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0">引用值作为实际参数</a>、<a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%80%BC%E4%BC%A0%E9%80%92%E7%BA%A6%E5%AE%9A">函数参数和函数值传递约定</a>和<a href="#%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0%E7%BA%A6%E5%AE%9A">实际参数约定</a>。</p>
<h4 id="函数值转发操作"><a class="header" href="#函数值转发操作">函数值转发操作</a></h4>
<p>　　若其它情形确需非转发操作取得引用值，可使用<a href="#%E5%8F%AF%E6%8F%90%E4%BE%9B%E4%BB%A5%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%BB%93%E5%B0%BE%E5%8F%98%E4%BD%93%E7%9A%84%E6%93%8D%E4%BD%9C">带有 <code>%</code> 或 <code>&amp;</code> 结尾的操作</a>及可直接<a href="#%E5%8F%AF%E7%9B%B4%E6%8E%A5%E4%BB%A5%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%9C%E4%B8%BA%E7%BB%93%E6%9E%9C%E7%9A%84%E6%93%8D%E4%BD%9C">以引用值作为结果的操作</a>替代实现。</p>
<p>　　本节约定的函数不使用引用标记字符，和<a href="#%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%BB%93%E6%9E%9C%E5%8C%85%E5%90%AB%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE%E5%99%A8">容器元素访问器</a>的函数名不使用引用标记字符一致：</p>
<p>　　本节约定的函数和上述容器元素访问器的函数名中不带有引用标记字符结尾的函数同属函数值转发操作，但后者同时有带有引用标记字符的变体。</p>
<p><strong>原理</strong></p>
<p>　　和<a href="#%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%BB%93%E6%9E%9C%E5%8C%85%E5%90%AB%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AE%B9%E5%99%A8%E6%9E%84%E9%80%A0%E5%99%A8">容器构造器</a>引入引用值的情形不同，不带有后缀 <code>%</code> 相对不容易引起误用，因为返回值保留的引用<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">可以继续被返回值转换</a>影响。</p>
<p>　　例如，使用<a href="#%E5%8F%AF%E8%83%BD%E9%97%B4%E6%8E%A5%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C">保证返回非引用值的涉及环境中求值的操作</a>，引用值会在引用的对象生存期结束前被返回值转换而不影响内存安全。</p>
<h4 id="可能间接保留引用值的无引用标记字符对应名称的操作"><a class="header" href="#可能间接保留引用值的无引用标记字符对应名称的操作">可能间接保留引用值的无引用标记字符对应名称的操作</a></h4>
<p>　　类似可提供<a href="#%E5%8F%AF%E8%83%BD%E9%97%B4%E6%8E%A5%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C">以引用标记字符结尾变体的对应操作</a>，部分不带有引用标记字符的操作可能<a href="#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">间接保留引用值</a>。</p>
<p>　　这包括由类型为合并子的参数（而非 <code>&lt;body&gt;</code> 或 <code>&lt;expressions&gt;</code> ）决定是否保留引用值同时对其它参数进行转发的操作。</p>
<h3 id="函数名称中缀"><a class="header" href="#函数名称中缀">函数名称中缀</a></h3>
<p>　　中缀 <code>-&gt;</code> 在函数名中可能出现一次，表示其（移除前缀和后缀之后的函数名中的）左边为源类型名的值到右边为目标类型名的值的转换操作。</p>
<p>　　除作为源类型的值外，可能支持可选的附加其它参数。</p>
<p>　　除非另行指定，转换得到的值是<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">纯右值</a>。</p>
<p>　　除非另行指定，转换函数调用的求值是<a href="#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>。</p>
<p>　　除非另行指定，若被转换的<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">值的复制</a>可能影响<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>，被转换的值被<a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91">转发</a>以<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">初始化返回值</a>。其中的右值被转移时，使用<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">对象的转移</a>或<a href="#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">项的转移</a>未指定。</p>
<p>　　除非另行转定，按<a href="#%E6%8E%A5%E5%8F%A3%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A">接口文法约定</a>引入的操作数作为对应名称之间的转换，仅在引入其中之一的模块提供。具体规则如下：</p>
<ul>
<li>源或目标具有在同一个<a href="#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">根环境</a>或其中的环境引入的对象类型时，在根环境中提供转换函数的名称。</li>
<li>源或目标具有从根环境中的 <a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BA%93"><code>std.strings</code></a> 以外的环境中引入的类型时，仅在引入其中之一提供转换函数的名称。</li>
<li>否则，在模块 <code>std.strings</code> 提供转换函数的名称。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　如有可能，被转换的值一般应避免被复制。在接口上要求转发右值避免不必要的复制。</p>
<p>　　标准库模块 <code>std.strings</code> 支持 <a href="#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;string&gt;</code></a> 的值的有关操作。因为相关转换的潜在的普遍性，在此进行特殊约定。</p>
<p><strong>注释</strong></p>
<p>　　一般地，转换操作是源类型的值作为单一实际参数的转换目标类型的<a href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0">构造器</a>。</p>
<h2 id="不安全操作约定"><a class="header" href="#不安全操作约定">不安全操作约定</a></h2>
<p>　　除非另行指定，执行时蕴含以下操作的操作是<a href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">不安全操作</a>：</p>
<ul>
<li>以下不具有<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">内存安全保证</a>的操作：
<ul>
<li>使用<a href="#%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E7%BA%A6%E5%AE%9A">函数名称约定</a>的<a href="#%E5%8F%AF%E6%8F%90%E4%BE%9B%E4%BB%A5%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%BB%93%E5%B0%BE%E5%8F%98%E4%BD%93%E7%9A%84%E6%93%8D%E4%BD%9C">函数名带有后缀的操作</a>。</li>
<li>其它<a href="#%E4%BF%9D%E7%95%99%E9%97%B4%E6%8E%A5%E5%80%BC">保留间接值的操作</a>。</li>
</ul>
</li>
<li>以下可能引入循环引用的操作：
<ul>
<li>引入引用现有<a href="#npla1-%E7%8E%AF%E5%A2%83">环境对象</a>的<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境强引用</a>的操作。</li>
<li>引入共享持有者的<a href="#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">值数据成员</a>而可能通过循环引用等引起未定义行为操作。</li>
</ul>
</li>
<li>和以上不安全操作等效的互操作。</li>
<li>其它另行指定的操作。</li>
</ul>
<p>　　按不安全操作引起不同的未定义行为和不同的<a href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E9%97%B4%E6%8E%A5%E5%80%BC%E8%AE%BF%E9%97%AE">间接值</a>，以下小节对不安全操作进行分类。</p>
<p>　　分类之间的关系详见<a href="#%E4%BF%9D%E7%95%99%E9%97%B4%E6%8E%A5%E5%80%BC">保留间接值</a>。</p>
<p>　　分类可能不完全的且可能相交的（不安全操作可能不属于任何一个分类或同时属于多个分类）。</p>
<h3 id="在函数值中保留引用值的操作"><a class="header" href="#在函数值中保留引用值的操作">在函数值中保留引用值的操作</a></h3>
<p>　　在函数值中保留引用值的操作包括按<a href="#%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E7%BA%A6%E5%AE%9A">函数名称约定</a>具有引用标记字符结尾的操作。</p>
<p>　　<a href="#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC">直接保留引用值</a>操作可配合带有<a href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>的操作，指定个别函数参数不再保留引用值。</p>
<p>　　这些操作可引起之后的<a href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E9%97%B4%E6%8E%A5%E5%80%BC%E8%AE%BF%E9%97%AE">不安全引用值访问</a>。</p>
<p>　　保留的引用值同时可能被构造<a href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>。</p>
<p><strong>注释</strong></p>
<p>　　一些修改操作<a href="#%E6%97%A0%E6%95%88%E5%8C%96">无效化</a>引用值。这些引用值若被保留且被访问，可引起未定义行为。</p>
<p>　　不引起被绑定对象无效的修改操作不被视为不安全操作，即便它们无效化<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的引用值。</p>
<h3 id="在函数值中保留环境引用的操作"><a class="header" href="#在函数值中保留环境引用的操作">在函数值中保留环境引用的操作</a></h3>
<p>　　<a href="#%E7%8E%AF%E5%A2%83%E9%97%B4%E6%8E%A5%E5%80%BC">环境引用</a>被返回时，总是被<a href="#%E4%BF%9D%E7%95%99%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">保留</a>。</p>
<p>　　创建<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境强引用</a>的操作是在函数值中保留环境引用的操作。</p>
<p>　　这些对象可能因为没有及时保存环境引用使环境对象和其中的绑定一并被销毁，而使引用值访问其中的对象的程序具有未定义行为。</p>
<p>　　通过非引用的形式引入环境循环引用的操作同时可破坏环境的资源所有权。</p>
<p><strong>注释</strong></p>
<p>　　直接返回有效的<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境弱引用</a>的操作不引起环境失效，不在此列。</p>
<h3 id="在函数值中保留其它间接值的操作"><a class="header" href="#在函数值中保留其它间接值的操作">在函数值中保留其它间接值的操作</a></h3>
<p>　　特定的支持<a href="#%E5%BC%BA%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">强递归绑定</a>而在函数值中保留其它间接值，可能存在<a href="#%E5%85%B6%E5%AE%83%E6%97%A0%E6%95%88%E7%9A%84%E9%97%B4%E6%8E%A5%E5%80%BC">其它无效的间接值</a>。</p>
<p>　　在函数值中保留其它间接值的操作的强递归绑定过程中引用共享对象的中间值。</p>
<h3 id="在环境中保留环境引用的操作"><a class="header" href="#在环境中保留环境引用的操作">在环境中保留环境引用的操作</a></h3>
<p>　　环境中的被绑定对象可具有环境引用<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>，间接地在环境中保留环境引用。</p>
<p>　　这些操作使<a href="#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>或参数指定的环境（而不是<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">合并子调用</a>时创建的<a href="#npla1-%E7%8E%AF%E5%A2%83">新环境</a>）中的变量绑定包含间接值，后者可能依赖合并子调用时创建的新环境。</p>
<p>　　被绑定的对象中可能保留环境引用，而使用环境间接地保留对象中的引用。</p>
<p>　　使用这些操作时应总是注意被依赖的环境的可用性。</p>
<p>　　若环境对象销毁，所有直接和间接依赖环境对象的<a href="#%E6%97%A0%E6%95%88%E5%8C%96">间接值被无效化</a>。这些间接值的<a href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E9%97%B4%E6%8E%A5%E5%80%BC%E8%AE%BF%E9%97%AE">不安全间接值访问</a>引起未定义行为。</p>
<p><strong>注释</strong></p>
<p>　　绑定的对象中可能保留环境引用的典型的例子是合并子对象的静态环境。</p>
<p>　　创建合并子可在合并子中的环境中保留环境引用。</p>
<h3 id="无效化被绑定对象或环境引用的操作"><a class="header" href="#无效化被绑定对象或环境引用的操作">无效化被绑定对象或环境引用的操作</a></h3>
<p>　　特定的操作蕴含被绑定对象的存储期的结束而无效化它的引用值。</p>
<p>　　若<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的引用值已被绑定，这些引用值不需要通过其它不安全操作，而仅通过之后<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">访问标识符求值</a>的<a href="#npla1-%E8%A7%84%E8%8C%83%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">结果</a>即可引起未定义行为。</p>
<p>　　因为<a href="#%E7%8E%AF%E5%A2%83%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7">环境稳定性</a>要求，NPLA1 实现环境不提供这类绑定，因此这些操作不是不安全操作。</p>
<p>　　但派生实现可能在语言实现中提供不满足环境稳定性的一等环境，其中对象的子对象的引用值被绑定为变量，且前者可能被修改。</p>
<p>　　此时，这些操作可能允许无效化引用后的<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>被访问，成为不安全操作。</p>
<p>　　类似地，无效化环境引用而无效化环境对象也可使其中包含的被绑定对象的引用无效化。</p>
<p>　　但<a href="#%E7%8E%AF%E5%A2%83%E7%94%9F%E5%AD%98%E6%9C%9F">环境生存期</a>要求，除非作为不满足环境稳定性的环境的被绑定对象，NPLA1 实现环境不提供唯一的<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境强引用</a>可被<a href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">用户程序</a>修改而使环境对象被销毁。</p>
<p>　　在这个前提下，要通过使环境引用作为子对象被修改而结束环境对象的生存期，首先要求通过<a href="#%E5%9C%A8%E5%87%BD%E6%95%B0%E5%80%BC%E4%B8%AD%E4%BF%9D%E7%95%99%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C">在函数值中保留环境引用的操作</a>取得环境引用，得到包含环境引用作为子对象的对象，且保证只有这个对象保存<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境强引用</a>。</p>
<p>　　因此，若不存在其它不安全操作，即蕴含不存在在对象语言操作中无效化环境引用的情形。</p>
<p>　　类似地，派生实现可提供不满足环境生存期中的销毁顺序的环境，而使用户无效化对应的环境对象。</p>
<p>　　此时，这些操作可能允许无效化环境引用后的环境对象被访问，成为不安全操作。</p>
<h3 id="副作用可能引入循环引用的操作"><a class="header" href="#副作用可能引入循环引用的操作">副作用可能引入循环引用的操作</a></h3>
<p>　　一些操作不依赖其它不安全操作（保留引用值或环境引用）即可引入循环引用：</p>
<ul>
<li><a href="#%E8%B5%8B%E5%80%BC">自赋值</a>可能引入循环引用值。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　通过已有的不安全操作构造的引用值也可能引入循环引用（而引起未定义行为），但不是单一操作的副作用，不属于本节的实例。</p>
<p>　　例如<a href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>中使用 <code>list%</code> 的例子，<code>$def!</code> 或 <code>list%</code> 不会因此被视为此处的不安全操作，因为单一操作的语义不引入循环引用值。</p>
<h3 id="可能破坏环境稳定性的操作"><a class="header" href="#可能破坏环境稳定性的操作">可能破坏环境稳定性的操作</a></h3>
<p>　　通过引用值进行的<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改操作</a>可因破坏<a href="#npla1-%E7%8E%AF%E5%A2%83">环境稳定性</a>而引起<a href="#npla1-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">扩展 NPLA 未定义行为</a>（不一定违反<a href="#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8">内存安全</a>）。</p>
<p>　　这包括以下可无效化对象包含的引用值而使可通过环境访问的某个<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的同一性被改变，从而破坏<a href="#npla1-%E7%8E%AF%E5%A2%83">环境稳定性</a>的操作：</p>
<ul>
<li>对可能具有对象语言中可访问的子对象的对象的<a href="#%E8%B5%8B%E5%80%BC">赋值操作</a>。</li>
<li>可修改<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>的操作。
<ul>
<li>包括<a href="#%E9%87%8D%E7%BB%91%E5%AE%9A">重绑定</a> 。</li>
</ul>
</li>
</ul>
<h3 id="安全操作子集"><a class="header" href="#安全操作子集">安全操作子集</a></h3>
<p>　　作为<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81%E6%9C%BA%E5%88%B6">对象语言安全性保证</a>的一部分，用户程序通过限制或避免依赖特定的不安全操作，在特定情形下可实现<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">对象语言内存安全保证</a>，而不需要分析具体操作的语义：</p>
<ul>
<li>不依赖<a href="#%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E7%BA%A6%E5%AE%9A">操作命名</a>约定的带有后缀的操作。</li>
<li>若使用保留环境引用的操作，总是保存被依赖的环境以确保相关的环境对象及其中的<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>在间接访问对象时不被销毁。
<ul>
<li><strong>注释</strong> 如<a href="#%E5%9C%A8%E5%87%BD%E6%95%B0%E5%80%BC%E4%B8%AD%E4%BF%9D%E7%95%99%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C">在函数值中保留环境引用的操作</a>和<a href="#%E5%9C%A8%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BF%9D%E7%95%99%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C">在环境中保留环境引用的操作</a>。</li>
</ul>
</li>
<li>不使用引入最终不被保留的<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子有序对引用</a>以外其它间接值的操作。</li>
</ul>
<h2 id="参照实现约定"><a class="header" href="#参照实现约定">参照实现约定</a></h2>
<p>　　本节约定对 NPLA1 参照实现内部有效，不作用在用户程序。</p>
<p>　　除非另行指定，NPLA1 参照实现环境作为公开接口提供的变量在<a href="#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">根环境</a>中绑定。</p>
<p>　　除非另行指定，以变量绑定的提供接口没有严格的跨版本兼容性保证。</p>
<h3 id="参照实现接口描述"><a class="header" href="#参照实现接口描述">参照实现接口描述</a></h3>
<p>　　除非显式指定，空环境没有<a href="#npla1-%E7%8E%AF%E5%A2%83">父环境</a>。</p>
<p>　　约定的接口通过绑定在根环境中的名称提供，参见以下各节。</p>
<p>　　描述操作的上下文中，结果指<a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">操作的结果</a>而非<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">求值结果</a>。</p>
<p>　　除非是语义蕴含的操作结果或另行指定，所有取得函数值的<a href="#%E5%BA%93%E6%8E%A5%E5%8F%A3%E5%AE%9E%E4%BD%93">操作</a>满足：</p>
<ul>
<li><a href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA">结果</a>是<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">未指定值</a>。
<ul>
<li>未指定值可以是 <a href="#npla1-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F"><code>#inert</code></a>或其它值，但满足忽略值时不引起<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>的改变。
<ul>
<li><strong>注释</strong> 这排除了引入 <code>volatile</code> 类型或非平凡析构的<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主值</a>。</li>
</ul>
</li>
<li>若这些操作在 [R<sup>n</sup>RK] 或 klisp 中存在结果是 <code>#inert</code> 的对应的操作，且未指定作为函数值的结果，则结果是等于 <code>#inert</code> 的右值。</li>
</ul>
</li>
<li>这些操作若存在对应的<a href="#%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E7%BA%A6%E5%AE%9A">函数名</a>，满足<a href="#%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E7%BA%A6%E5%AE%9A">函数名称约定</a>。</li>
<li>这些操作中隐式分配的和按接口约定转移所有权给操作实现的资源不存在<a href="#%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F">资源泄漏</a>。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　<a href="#npla1-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F"><code>#inert</code> 是单元类型的值</a>。但是，未指定值并不依赖单元类型的性质，而只是需要一种可在对象语言中判断是否为实现（如 [R<sup>n</sup>RK] 的 <code>inert?</code> ），而避免使用特设的规则。</p>
<p>　　取而代之，一些语言或运行时支持<a href="#%E4%B8%80%E7%AD%89%E7%B1%BB%E5%9E%8B">非一等</a>的特设返回类型：<a href="#%E4%B8%80%E7%AD%89%E7%B1%BB%E5%9E%8B"><code>void</code></a> ，在对象语言中无法构造其值。这种特性引起一些实用上的困难而被考虑改进，替换成一等类型，如：</p>
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0146r1.html">[WG21 P0146R1]</a></li>
<li><a href="https://github.com/dotnet/csharplang/discussions/1603">[Proposal] <code>System.Void</code> as a first-class type</a></li>
</ul>
<p>　　即便被改进，这仍只是<a href="#%E7%B1%BB%E5%9E%8B">单元类型</a>，而不够清晰地反映未指定的意图。</p>
<p>　　未指定值蕴含的不确定性在对象语言中难以建模，因此直接通过语言规则约定直至作为内建的支持特性，能使语言的设计更<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单</a>。</p>
<p>　　未指定值的未指定性在接口意义上仍然不是一等实体，因为当前不提供如 <code>inert?</code> 这样的谓词。即便提供 <code>inert?</code> 也仅仅是判断值是否为 <code>#inert</code> ，而不是任意的未指定值。</p>
<p>　　相对 <code>inert?</code> ，这类谓词可能是有用的，例如元语言可能需要判断未指定性质以简化其派生实现。但这类需求和实现细节相关，且当前缺乏实例显示在对象语言中无条件提供的必要性。更重要的是，若要求提供这种谓词，限制派生实现在未指定值的类型上维持<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">开放类型</a>设计。</p>
<p>　　未指定值作为内建特性时，用户也无法直接提供这类谓词的派生（而不符合<a href="#%E7%BB%9F%E4%B8%80%E6%80%A7">统一性</a>）。在需要这类谓词时，派生语言设计可能视具体实现需要满足的条件补充。</p>
<h3 id="操作符合性"><a class="header" href="#操作符合性">操作符合性</a></h3>
<p>　　除非另行指定，以下关于操作实现的<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">未指定行为</a>：</p>
<ul>
<li>对<a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF%E6%9D%A1%E4%BB%B6">运行时错误条件</a>的<a href="#%E9%94%99%E8%AF%AF%E6%A3%80%E6%9F%A5">检查</a>及<a href="#%E8%AF%8A%E6%96%AD">诊断</a>的顺序。</li>
<li>满足运行时错误条件时，按要求诊断之后的操作内部分配的资源的状态。</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">变量绑定</a>或其它可选地由派生实现定义的可调试实体的引入是否由<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>的机制提供。</li>
<li>是否存在不改变操作语义的附加的可被捕获的续延和这些续延的操作数。</li>
<li>操作的实现使用的续延或者其它<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">实体</a>为<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>和调试目的保留的名称。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　以上未指定行为允许同一操作的接口约定和实现之间及不同实现之间允许存在引起调用操作时的可观察行为不同的次要差异。</p>
<h3 id="实体实现约定"><a class="header" href="#实体实现约定">实体实现约定</a></h3>
<p>　　在实现的意义上，<a href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">库特性</a>提供的实体的方式分为两类：</p>
<ul>
<li>调用本机 API ，提供<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>。
<ul>
<li>直接调用本机 API 提供绑定和组合本机 API 实现功能的派生实现都是本机实现。</li>
</ul>
</li>
<li>通过组合既有对象语言提供的接口实现，即<em>派生(derivation)</em> 。</li>
</ul>
<p>　　因不预期通过派生实现，一些特性被设计为<em>基本(primitive)</em> 特性，总是通过直接调用本机 API 的本机实现提供。</p>
<p>　　其它特性都是派生特性，可通过<em>派生(derived)</em> 实现提供：通过组合基本特性及其它已提供实现的派生特性实现。</p>
<p>　　典型地，派生实现通常不依赖实现特定的<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">互操作</a>接口的本机实现，这类派生实现是<em>非本机的(non-native)</em> ；其它的派生是本机的。</p>
<p>　　以下的<a href="#%E5%9F%BA%E7%A1%80%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">派生操作</a>应能以派生的方式提供。派生操作是否以派生的形式提供未指定。</p>
<p><strong>注释</strong></p>
<p>　　派生特性的实现方式可类似 [R<sup>n</sup>RK] 。</p>
<p>　　非本机的派生实现通常以求值特定的对象语言源代码引入。</p>
<p>　　非本机的实现最终依赖本机实现。</p>
<h4 id="预定义对象"><a class="header" href="#预定义对象">预定义对象</a></h4>
<p>　　除操作外，实现可定义特定名称的对象以变量绑定的形式在库中初始化，直接提供具有预设目的的可编程特性。</p>
<h1 id="npla1-根环境特性"><a class="header" href="#npla1-根环境特性">NPLA1 根环境特性</a></h1>
<p>　　本章指定在<a href="#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">根环境</a>提供的 <a href="#%E6%A0%87%E5%87%86%E5%BA%93">NPLA1 标准库特性</a>，即<a href="#%E5%BA%93%E6%8E%A5%E5%8F%A3%E7%BA%A6%E5%AE%9A">根环境特性</a>。</p>
<p>　　<a href="#%E6%A0%B9%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7">根环境基本特性</a>是单独的模块。</p>
<p>　　<a href="#%E5%9F%BA%E7%A1%80%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">基础派生特性</a>起的各节提供其余要求 NPLA1 实现直接支持的各个模块的操作。</p>
<p><strong>原理</strong></p>
<p>　　一些特性参照和类推扩展 [R<sup>n</sup>RK] 。</p>
<p>　　同 [R<sup>n</sup>RK] 的设计，<a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>eval</code></a>和 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$vau</code></a>是体现对象语言设计的<a href="#%E7%BB%9F%E4%B8%80%E6%80%A7">光滑性</a>的主要原语。</p>
<p>　　因为<a href="#%E5%9C%A8%E5%87%BD%E6%95%B0%E5%80%BC%E4%B8%AD%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C">保留引用值的不安全操作</a>的支持，类推 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>eval%</code></a>和 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$vau%</code></a>。</p>
<p>　　在本设计中，后者在逻辑意义上更基本，即便不指定为<a href="#%E5%AE%9E%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%BA%A6%E5%AE%9A">派生</a>。</p>
<p><strong>注释</strong></p>
<p>　　一些特性<a href="#npla1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80">可约定处理的值的宿主类型</a>。</p>
<h2 id="不安全函数索引"><a class="header" href="#不安全函数索引">不安全函数索引</a></h2>
<p>　　本节按<a href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">不安全操作约定</a>的分类对提供根环境中的<a href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">不安全操作</a>的函数进行归类。</p>
<p>　　<a href="#%E5%9C%A8%E5%87%BD%E6%95%B0%E5%80%BC%E4%B8%AD%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C">在函数值中保留引用值的不安全操作</a>已被<a href="#%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E7%BA%A6%E5%AE%9A">命名</a>归纳和<a href="#%E5%87%BD%E6%95%B0%E5%88%86%E7%B1%BB">函数分类</a>枚举，此处从略。</p>
<p>　　不安全操作中，在参数以外直接引入间接值的操作仅有以下的在函数值中保留引用值的不安全操作：</p>
<ul>
<li><a href="#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>ref&amp;</code></a></li>
</ul>
<p>　　<a href="#%E5%AE%89%E5%85%A8%E6%80%A7%E9%99%84%E5%8A%A0%E8%AF%81%E6%98%8E">附加调用安全</a>包括在函数值中保留引用值的不安全操作的调用。</p>
<p>　　当前，这种操作包括 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>assign!</code></a>。</p>
<p>　　隐藏环境排除可修改对象的引用，通过<a href="#%E5%86%BB%E7%BB%93">冻结</a>环境保证而提供静态的证明。</p>
<h3 id="在函数值中保留环境引用的函数"><a class="header" href="#在函数值中保留环境引用的函数">在函数值中保留环境引用的函数</a></h3>
<p>　　<a href="#%E5%9C%A8%E5%87%BD%E6%95%B0%E5%80%BC%E4%B8%AD%E4%BF%9D%E7%95%99%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C">在函数值中保留环境引用的操作</a>包括：</p>
<ul>
<li><a href="#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">基本操作</a>：
<ul>
<li><code>make-environment</code></li>
<li><code>copy-environment</code></li>
<li><code>lock-environment</code></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">派生操作</a>：
<ul>
<li><code>lock-current-environment</code></li>
<li><code>derive-current-environment</code></li>
<li><code>make-standard-environment</code></li>
<li><code>derive-environment</code></li>
<li><code>$provide/let!</code></li>
<li><code>$provide!</code></li>
</ul>
</li>
</ul>
<h3 id="在函数值中保留其它间接值的函数"><a class="header" href="#在函数值中保留其它间接值的函数">在函数值中保留其它间接值的函数</a></h3>
<p>　　<a href="#%E5%9C%A8%E5%87%BD%E6%95%B0%E5%80%BC%E4%B8%AD%E4%BF%9D%E7%95%99%E5%85%B6%E5%AE%83%E9%97%B4%E6%8E%A5%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C">在函数值中保留其它间接值的操作</a>包括：</p>
<ul>
<li><a href="#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>$defrec!</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$setrec!</code></a></li>
</ul>
<h3 id="在环境中保留环境引用的函数"><a class="header" href="#在环境中保留环境引用的函数">在环境中保留环境引用的函数</a></h3>
<p>　　<a href="#%E5%9C%A8%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BF%9D%E7%95%99%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C">在环境中保留环境引用的操作</a>包括<a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">派生操作</a>：</p>
<ul>
<li><code>$provide/let!</code></li>
<li><code>$provide!</code></li>
</ul>
<h3 id="无效化被绑定对象的函数"><a class="header" href="#无效化被绑定对象的函数">无效化被绑定对象的函数</a></h3>
<p>　　当前不提供<a href="#%E6%97%A0%E6%95%88%E5%8C%96%E8%A2%AB%E7%BB%91%E5%AE%9A%E5%AF%B9%E8%B1%A1%E6%88%96%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C">无效化被绑定对象的操作</a>。</p>
<p>　　这可包含直接移除变量绑定的操作。</p>
<h3 id="副作用可能引入循环引用的函数"><a class="header" href="#副作用可能引入循环引用的函数">副作用可能引入循环引用的函数</a></h3>
<p>　　<a href="#%E5%89%AF%E4%BD%9C%E7%94%A8%E5%8F%AF%E8%83%BD%E5%BC%95%E5%85%A5%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C">副作用可能引入循环引用的操作</a>包括可能<a href="#%E8%B5%8B%E5%80%BC">自赋值</a>而引入循环引用值的操作：</p>
<ul>
<li><code>assign@!</code></li>
<li><code>assign%!</code></li>
</ul>
<h3 id="可能破坏环境稳定性的函数"><a class="header" href="#可能破坏环境稳定性的函数">可能破坏环境稳定性的函数</a></h3>
<p>　　<a href="#%E5%8F%AF%E8%83%BD%E7%A0%B4%E5%9D%8F%E7%8E%AF%E5%A2%83%E7%A8%B3%E5%AE%9A%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C">可能破坏环境稳定性的操作</a>包括下列两类：</p>
<ul>
<li>对可能具有对象语言中可访问的<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的对象的<a href="#%E8%B5%8B%E5%80%BC">赋值操作</a>，包括：
<ul>
<li><a href="#%E5%8F%AF%E8%83%BD%E4%BD%BF%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%8C%85%E5%90%AB%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C">简单赋值</a>。</li>
<li><strong>注释</strong> 具体函数参见<a href="#%E5%8F%AF%E8%83%BD%E4%BD%BF%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%8C%85%E5%90%AB%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E4%BF%AE%E6%94%B9%E5%87%BD%E6%95%B0">可能使对象中包含引用值的修改函数</a>。</li>
</ul>
</li>
<li>可直接修改<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>的操作，包括：
<ul>
<li><a href="#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>move!</code></a></li>
</ul>
</li>
</ul>
<h2 id="函数分类"><a class="header" href="#函数分类">函数分类</a></h2>
<p>　　本节对函数按名称和其它不同性质进行分类。</p>
<p>　　在 NPLA1 参照实现环境提供的函数具体详见根环境基本特性和基础派生特性。</p>
<p>　　除非另行指定，本节约定的函数属于 NPLA1 参照实现环境。</p>
<p>　　本节约定的函数提供的部分操作属于<a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%80%BC%E4%BC%A0%E9%80%92%E7%BA%A6%E5%AE%9A">转发</a>。</p>
<p><strong>注释</strong></p>
<p>　　<a href="#%E8%BD%AC%E5%8F%91%E5%8F%82%E6%95%B0%E6%88%96%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%AE%9E%E7%8E%B0">转发参数或返回值的实现</a>中可使用 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>forward!</code></a>。</p>
<h3 id="可提供以引用标记字符结尾变体的函数"><a class="header" href="#可提供以引用标记字符结尾变体的函数">可提供以引用标记字符结尾变体的函数</a></h3>
<p>　　本节中的<a href="#%E5%8F%AF%E6%8F%90%E4%BE%9B%E4%BB%A5%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%BB%93%E5%B0%BE%E5%8F%98%E4%BD%93%E7%9A%84%E6%93%8D%E4%BD%9C">可提供以引用标记字符结尾变体的操作</a>的以下分类不相交，但部分分类中<a href="#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E5%87%BD%E6%95%B0%E5%90%8D%E4%B8%8E%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E7%9A%84%E5%85%B3%E7%B3%BB">函数名不带有引用标记字符结尾的操作</a>可能和<a href="#%E4%B8%8D%E6%8F%90%E4%BE%9B%E7%BB%93%E5%B0%BE%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E5%AF%B9%E5%BA%94%E5%8F%98%E4%BD%93%E7%9A%84%E5%87%BD%E6%95%B0">不提供结尾引用标记字符对应变体的函数</a>中的操作相交。</p>
<p>　　除非另行指定，符合以下分类的操作：</p>
<ul>
<li>不指定保留引用值时，不保留引用值。</li>
<li>指定保留引用值时，同指定<a href="#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E7%9B%AE%E6%A0%87">在结果中保留引用值</a>。</li>
<li>指定在结果中保留引用值时，根据结果是否为<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">未指定值</a>，应总能直接区分<a href="#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%9D%A5%E6%BA%90">被保留的来源</a>和<a href="#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E7%9B%AE%E6%A0%87">目标</a>。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　<a href="#%E5%87%BD%E6%95%B0%E5%80%BC%E7%BA%A6%E5%AE%9A">函数值约定</a>已指定函数值默认不保留引用值；这没有涵盖 <code>&lt;body&gt;</code> 的求值结果。</p>
<h4 id="可能使结果包含引用值的容器构造器函数"><a class="header" href="#可能使结果包含引用值的容器构造器函数">可能使结果包含引用值的容器构造器函数</a></h4>
<p>　　<a href="#%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%BB%93%E6%9E%9C%E5%8C%85%E5%90%AB%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AE%B9%E5%99%A8%E6%9E%84%E9%80%A0%E5%99%A8">可能使结果包含引用值的容器构造器</a>包括：</p>
<ul>
<li><a href="#%E6%9C%89%E5%BA%8F%E5%AF%B9%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>cons</code></a></li>
<li><a href="#%E6%9C%89%E5%BA%8F%E5%AF%B9%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>cons%</code></a></li>
<li><a href="#%E5%90%88%E5%B9%B6%E5%AD%90%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>wrap</code></a></li>
<li><a href="#%E5%90%88%E5%B9%B6%E5%AD%90%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>wrap%</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>list</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>list%</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>list*</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>list*%</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>box</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>box%</code></a></li>
</ul>
<h4 id="可能使结果包含引用值的容器元素访问器函数"><a class="header" href="#可能使结果包含引用值的容器元素访问器函数">可能使结果包含引用值的容器元素访问器函数</a></h4>
<p>　　<a href="#%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%BB%93%E6%9E%9C%E5%8C%85%E5%90%AB%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE%E5%99%A8">可能使结果包含引用值的容器元素访问器</a>包括<a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">基本派生特性</a>中的以下操作：</p>
<ul>
<li><code>first</code></li>
<li><code>first@</code></li>
<li><code>first%</code></li>
<li><code>first&amp;</code></li>
<li><code>rest%</code></li>
<li><code>rest&amp;</code></li>
<li><code>restv</code></li>
</ul>
<p>　　注意 <code>restv</code> 和 <code>rest%</code> 总是构造列表，并不直接返回<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的引用（另见<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">引用值构造函数</a>）；其它访问器若带有引用标记字符，可直接返回引用值。</p>
<p>　　此外，标准库中的<a href="#%E5%87%BD%E6%95%B0%E5%80%BC%E8%BD%AC%E5%8F%91%E5%87%BD%E6%95%B0">函数值转发操作</a>中部分函数也符合容器元素访问器的要求，但当前不提供带有后缀标记字符的变体。这些函数包括：</p>
<ul>
<li><a href="#%E5%90%88%E5%B9%B6%E5%AD%90%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>unwrap</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>unbox</code></a></li>
</ul>
<h4 id="可能使对象中包含引用值的修改函数"><a class="header" href="#可能使对象中包含引用值的修改函数">可能使对象中包含引用值的修改函数</a></h4>
<p>　　<a href="#%E5%8F%AF%E8%83%BD%E4%BD%BF%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%8C%85%E5%90%AB%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C">可能使对象中包含引用值的修改操作</a>包括：</p>
<ul>
<li>简单赋值：
<ul>
<li><a href="#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>assign@!</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>assign%!</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>assign!</code></a></li>
</ul>
</li>
<li>列表元素改变器：
<ul>
<li><a href="#%E6%9C%89%E5%BA%8F%E5%AF%B9%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>set-rest!</code></a></li>
<li><a href="#%E6%9C%89%E5%BA%8F%E5%AF%B9%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>set-rest%!</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>set-first!</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>set-first@!</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>set-first%!</code></a></li>
</ul>
</li>
</ul>
<h4 id="可能间接保留引用值的函数"><a class="header" href="#可能间接保留引用值的函数">可能间接保留引用值的函数</a></h4>
<p>　　<a href="#%E5%8F%AF%E8%83%BD%E9%97%B4%E6%8E%A5%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C">可能间接保留引用值的操作</a>包括以求值 <code>&lt;body&gt;</code> 作为尾上下文的操作：</p>
<ul>
<li>结果是合并子或用于在环境中绑定合并子的构造器操作。</li>
<li><a href="#%E6%A0%B8%E5%BF%83%E5%BA%93">核心库函数</a>中的绑定操作。</li>
<li>在尾上下文中求值 <code>&lt;expression&gt;</code> 参数视为的 <code>&lt;object&gt;</code> 的函数，包括 <a href="#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>eval@</code></a> 、<a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>eval</code></a> 和 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>eval%</code></a>。</li>
</ul>
<p>　　参见<a href="#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">环境基本函数</a>和<a href="#%E6%A0%B8%E5%BF%83%E5%BA%93">核心库</a>。</p>
<p><strong>注释</strong></p>
<p>　　以上操作中的求值符合<a href="#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">词法闭包</a>规则。</p>
<h3 id="不提供结尾引用标记字符对应变体的函数"><a class="header" href="#不提供结尾引用标记字符对应变体的函数">不提供结尾引用标记字符对应变体的函数</a></h3>
<p>　　本节列举<a href="#%E4%B8%8D%E6%8F%90%E4%BE%9B%E7%BB%93%E5%B0%BE%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E5%AF%B9%E5%BA%94%E5%90%8D%E7%A7%B0%E7%9A%84%E6%93%8D%E4%BD%9C">不提供结尾引用标记字符对应名称的操作</a>。</p>
<p><strong>注释</strong></p>
<p>　　派生实现中通常使用 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>forward!</code></a>进行<a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91">转发</a>实现上述保证。</p>
<h4 id="可直接以引用值作为结果的函数"><a class="header" href="#可直接以引用值作为结果的函数">可直接以引用值作为结果的函数</a></h4>
<p>　　<a href="#%E5%8F%AF%E7%9B%B4%E6%8E%A5%E4%BB%A5%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%9C%E4%B8%BA%E7%BB%93%E6%9E%9C%E7%9A%84%E6%93%8D%E4%BD%9C">可直接以引用值作为结果的操作</a>包括：</p>
<ul>
<li><a href="#%E6%8E%A7%E5%88%B6%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>$if</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$sequence</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$cond</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$when</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$unless</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$and</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$or</code></a></li>
</ul>
<h4 id="不以引用值作为结果的函数"><a class="header" href="#不以引用值作为结果的函数">不以引用值作为结果的函数</a></h4>
<p>　　<a href="#%E4%B8%8D%E4%BB%A5%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%9C%E4%B8%BA%E7%BB%93%E6%9E%9C%E7%9A%84%E6%93%8D%E4%BD%9C">不以引用值作为结果的操作</a>的返回值总是按值传递的操作涉及的容器包括列表、<a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">箱</a>或<a href="#%E5%B0%81%E8%A3%85%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">其它的封装类型</a>对象，包括：</p>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>map1</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>list-concat</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>append</code></a></li>
</ul>
<h4 id="直接参数转发函数"><a class="header" href="#直接参数转发函数">直接参数转发函数</a></h4>
<p>　　<a href="#%E7%9B%B4%E6%8E%A5%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91%E6%93%8D%E4%BD%9C">直接参数转发操作</a>包括：</p>
<ul>
<li><a href="#%E5%90%88%E5%B9%B6%E5%AD%90%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">合并子基本函数</a>：
<ul>
<li><code>unwrap</code></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">基本派生特性</a>：
<ul>
<li><code>accl</code></li>
<li><code>accr</code></li>
<li><code>foldr1</code></li>
<li><code>map1</code></li>
</ul>
</li>
</ul>
<p>　　基本派生特性和<a href="#%E6%A0%B8%E5%BF%83%E5%BA%93">核心库函数</a>中的绑定操作的非 <code>&lt;environment&gt;</code> 的形式参数支持转发。</p>
<p>　　参数形式上被转发但操作的语义并非总是转发到其它操作的操作不使用本节的名称约定，如以下仅有第二参数支持转发的操作是<a href="#%E5%8F%AF%E6%8F%90%E4%BE%9B%E4%BB%A5%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%BB%93%E5%B0%BE%E5%8F%98%E4%BD%93%E7%9A%84%E5%87%BD%E6%95%B0">提供结尾引用标记字符对应名称的函数</a>，有<a href="#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">对象基本函数</a>中的：</p>
<ul>
<li><code>assign%!</code></li>
<li><code>assign@!</code></li>
</ul>
<p><strong>注释</strong></p>
<p>　　<code>map1</code> 同时是<a href="#%E4%B8%8D%E4%BB%A5%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%9C%E4%B8%BA%E7%BB%93%E6%9E%9C%E7%9A%84%E5%87%BD%E6%95%B0">不以引用值作为结果的操作</a>。</p>
<h4 id="函数值转发函数"><a class="header" href="#函数值转发函数">函数值转发函数</a></h4>
<p>　　NPLA1 参照实现环境的<a href="#%E5%87%BD%E6%95%B0%E5%80%BC%E8%BD%AC%E5%8F%91%E6%93%8D%E4%BD%9C">函数值转发操作</a>包括以下访问对象或<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>自身或<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的函数：</p>
<ul>
<li><a href="#%E5%90%88%E5%B9%B6%E5%AD%90%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>unwrap</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>id</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>forward</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>forward!</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>unbox</code></a></li>
</ul>
<p>　　<a href="#%E6%A0%B9%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7">基本操作</a>的不具有名称的相关操作中参数和函数值原生支持的转发操作包括：</p>
<p>　　使用 <a href="#%E5%B0%81%E8%A3%85%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>make-encapsulation-type</code></a>返回的访问器合并子。</p>
<h4 id="可能间接保留引用值的函数-1"><a class="header" href="#可能间接保留引用值的函数-1">可能间接保留引用值的函数</a></h4>
<p>　　<a href="#%E5%8F%AF%E8%83%BD%E9%97%B4%E6%8E%A5%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C">可能间接保留引用值的操作</a>包括：</p>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>apply</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>apply-list</code></a></li>
</ul>
<h3 id="引用折叠相关函数"><a class="header" href="#引用折叠相关函数">引用折叠相关函数</a></h3>
<p>　　本节列举<a href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0">引用折叠</a>相关操作。</p>
<p>　　只有<a href="#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D%E5%90%8E%E7%BC%80">函数名以 <code>@</code> 结尾</a>的函数可能引入<a href="#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">未折叠的引用值</a>，包括：</p>
<ul>
<li><a href="#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>assign@!</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>set-first@!</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>first@</code></a></li>
</ul>
<p>　　此外，在参数保留引用值的修改操作可能使现有的引用值成为未折叠的引用值，包括：</p>
<ul>
<li><a href="#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>assign@!</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>assign%!</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>set-first@!</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>set-first%!</code></a></li>
</ul>
<p>　　函数 <a href="#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>uncollapsed?</code></a>区分未折叠的引用值。</p>
<p>　　<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0">蕴含左值到右值转换</a>的函数可以<a href="#%E5%B1%80%E9%83%A8%E9%97%B4%E6%8E%A5%E5%80%BC%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81">消除引用值</a>，如：</p>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>idv</code></a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>collapse</code></a></li>
</ul>
<p>　　其中，<code>collapse</code> 依赖 <code>uncollapsed?</code> 而针对未折叠的引用值消除引用值，实现引用折叠。</p>
<p>　　其它一些函数可能在非<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>中依赖未折叠引用但不在接口中体现，如 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>rulist</code></a> 。</p>
<h3 id="引用值构造函数"><a class="header" href="#引用值构造函数">引用值构造函数</a></h3>
<p>　　当前构造<a href="#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子对象引用</a>的操作有：</p>
<ul>
<li><a href="#%E5%90%88%E5%B9%B6%E5%AD%90%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>unwrap</code></a>创建合并子的子对象引用。</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>rest&amp;</code></a> 创建列表的子对象引用。</li>
<li>使用带有<a href="#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">省略</a>的<a href="#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">形式参数树</a>（如 <a href="#%E6%9C%AA%E6%B1%82%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;formals&gt;</code></a>）绑定操作数为<a href="#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D">结尾列表</a>，<a href="#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">创建列表的子对象引用</a>。</li>
</ul>
<h3 id="非引用值构造器函数"><a class="header" href="#非引用值构造器函数">非引用值构造器函数</a></h3>
<p>　　一些函数构造非引用值，包括：</p>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">基本派生特性</a>转换函数：
<ul>
<li><code>$bindings/p-&gt;environment</code></li>
<li><code>$bindings-&gt;environment</code></li>
<li><code>symbols-&gt;imports</code></li>
</ul>
</li>
<li><a href="#%E7%BB%AD%E5%BB%B6%E5%BA%93">续延库</a>转换函数：
<ul>
<li><code>continuation-&gt;applicative</code></li>
</ul>
</li>
</ul>
<p>　　其中，明确<a href="#%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E4%B8%AD%E7%BC%80">转移而不是复制被转换的右值</a>的函数有：</p>
<ul>
<li><code>continuation-&gt;applicative</code></li>
</ul>
<h2 id="根环境基本特性"><a class="header" href="#根环境基本特性">根环境基本特性</a></h2>
<p>　　NPLA1 通过<a href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1">预定义对象</a>的形式提供<a href="#npla1-%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E6%89%A9%E5%B1%95%E7%8E%AF%E5%A2%83">可选的模块</a>。</p>
<p>　　<a href="#%E6%A8%A1%E5%9D%97">根环境</a>基本特性是除了这些模块的以变量绑定形式提供的不要求可派生实现的特性。</p>
<p>　　根环境基本特性的<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>包括<a href="#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">基础环境</a>提供的预定义对象和在<a href="#npla1-%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96">基础上下文</a>的根环境中初始化的<em>基础基本操作(grounded primitive operations)</em> 的实现。</p>
<p>　　派生实现可以通过提供不公开<a href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">不安全操作</a>的根环境，但不符合此处的<a href="../Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87">规格要求</a>。</p>
<p>　　若派生实现不提供<a href="#%E5%9C%A8%E5%87%BD%E6%95%B0%E5%80%BC%E4%B8%AD%E4%BF%9D%E7%95%99%E5%85%B6%E5%AE%83%E9%97%B4%E6%8E%A5%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0">在函数值中保留其它间接值的操作</a>，可以简化部分<a href="#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">对象基本函数</a>中与之关联的操作的实现。</p>
<p>　　当前在根环境中的直接提供绑定的特性不依赖 <a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B"><code>&lt;number&gt;</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　和 [R<sup>n</sup>RK] 不同，为简化设计，不提供可选(optional) 的合并子。</p>
<p>　　可选功能不应被必要功能依赖。</p>
<p>　　根环境的基本特性为组合其它实用特性提供，而数值在设计中不是必要的功能特性。</p>
<p>　　部分其它原理参见<a href="#%E6%A0%B9%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%B9%89">根环境对象定义</a>。关于引用值的处理另见<a href="#%E5%87%BD%E6%95%B0%E5%88%86%E7%B1%BB">函数分类</a>。</p>
<p><strong>注释</strong></p>
<p>　　部分可选的 Kernel 合并子被直接提供。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，一些函数显式地操作<a href="#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a>，包括<a href="#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">未折叠的引用值</a>。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值算法</a>不直接处理对象的引用值。</p>
<p>　　为简化实现，部分提供 <a href="#%E5%8F%AF%E6%8F%90%E4%BE%9B%E4%BB%A5%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E7%BB%93%E5%B0%BE%E5%8F%98%E4%BD%93%E7%9A%84%E5%87%BD%E6%95%B0"><code>%</code> 等后缀的函数</a>不被派生。</p>
<p>　　因为设计原因，不提供以下 Kernel 合并子对应的操作：</p>
<ul>
<li><code>copy-es-immutable</code></li>
<li><code>inert?</code></li>
<li><code>ignore?</code></li>
</ul>
<p>　　考虑（可变对象的）一等引用和<a href="#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>绑定引用的的平摊复杂度，不提供需要同时转换不同层次子项的 <code>copy-es-immutable</code> 操作。</p>
<p>　　其它没有包含在以下节中的 Kernel 合并子对应的操作可能会在之后的版本中被支持。</p>
<h3 id="根环境对象定义"><a class="header" href="#根环境对象定义">根环境对象定义</a></h3>
<p>　　除<a href="#%E6%A8%A1%E5%9D%97">为提供根环境特性的模块</a>以外，当前根环境不定义对象。</p>
<p>　　以下各节引入的变量都表示操作。</p>
<h3 id="等价谓词基本函数"><a class="header" href="#等价谓词基本函数">等价谓词基本函数</a></h3>
<p><strong>模块约定：</strong></p>
<p>　　本节的操作不修改参数对象。</p>
<p>　　本节的操作的结果是 <code>&lt;boolean&gt;</code> 类型的纯右值。</p>
<p>　　用户定义的类型提供的等价谓词应满足和 NPLA1 提供的等价谓词的语义一致的等价关系，否则若谓词被求值，行为未指定。</p>
<p>　　一些具有<a href="#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">项节点</a>作为表示的对象的<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>具有递归相等性，仅当子对象符合以下递归相等关系：</p>
<ul>
<li>对不表示有序对的节点，同 <code>eqv?</code> 。</li>
<li>否则，同每个元素对应 <code>eqv?</code> 对应满足 <code>eqv?</code> 。</li>
</ul>
<p>　　判断子对象递归相等性的对象相等时，其续延未指定。</p>
<p>　　若右值之间 <code>eqv?</code> 比较结果是 <code>#t</code> ，<code>eq?</code> 比较结果未指定。</p>
<p><strong>操作：</strong></p>
<p><code>eq? &lt;object1&gt; &lt;object2&gt;</code></p>
<p>　　判断参数<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">同一</a>。</p>
<p>　　当且仅当两个参数是指定同一对象时，比较结果是 <code>#t</code> 。</p>
<p>　　<code>eq?</code> 的复杂度是 <tt>O(1)</tt> 。</p>
<p><code>eql? &lt;object1&gt; &lt;object2&gt;</code></p>
<p>　　判断表示参数的项的<a href="#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">值数据成员</a>相等。</p>
<p>　　忽略表示参数的项的值数据成员以外的子对象：若参数是列表，则视为空列表；若参数是有序对，则视为仅具有最后一个元素。</p>
<p>　　若参数是引用值，则被比较的项是表示它的<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的项。</p>
<p>　　当且仅当被比较的项的值数据成员相等时，比较结果是 <code>#t</code> 。</p>
<p>　　值数据成员相等蕴含参数的<a href="#%E7%B1%BB%E5%9E%8B">动态类型</a><a href="#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">相同</a>。</p>
<p><code>eqr? &lt;object1&gt; &lt;object2&gt;</code></p>
<p>　　判断表示参数的项的数据成员同一。</p>
<p>　　当且仅当表示被比较的项的值数据成员指定宿主语言中的同一对象（即引用相等）时，比较结果是 <code>#t</code> 。</p>
<p><code>eqv? &lt;object1&gt; &lt;object2&gt;</code></p>
<p>　　判断非<a href="#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">枝节点</a>表示的值相等。</p>
<p>　　若参数是引用值，则被比较的值是它的被引用对象。</p>
<p>　　根据项的内部表示：</p>
<ul>
<li>当表示值的项都是枝节点时，同 <code>eq?</code> 。</li>
<li>否则，若这两个参数的类型<a href="#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">不同</a>，则结果是 <code>#f</code> 。</li>
<li>否则，若这两个参数的 <code>eql?</code> 比较结果是 <code>#t</code> ，则结果是 <code>#t</code> 。</li>
</ul>
<p>　　若两个参数的 <code>eqv?</code> 比较结果是 <code>#f</code> ，则这两个参数以 <code>eq?</code> 比较结果总是 <code>#f</code> 。</p>
<p>　　除非<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>（参见以下描述）或派生实现另行指定，不<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">等价</a>的函数的 <code>eqv?</code> 比较结果是 <code>#f</code> 。</p>
<p>　　除以上规则确定的结果外，<code>eqv?</code> 对合并子或列表的比较结果未指定。</p>
<p>　　在互操作的意义上，当前 <code>eqv?</code> 定义的合并子的相等性由<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>的 <code>==</code> 或不影响可观察行为的其它宿主环境提供的 <code>==</code> 操作通过和 <code>eql?</code> 比较相同的方式确定。</p>
<p>　　除非另行指定，具有本文档引入的类型且不涉及互操作意义上用户自定义值的比较的操作数使用以上 <code>eq?</code> 以外的谓词比较的求值应保证能终止。</p>
<p><strong>原理</strong></p>
<p>　　除任何其它类型都可作为 <a href="#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;object&gt;</code> 的子类型</a>，<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">开放类型映射</a>的<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">类型系统</a>通常要求避免依赖 <code>&lt;object&gt;</code> 上的其它的<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">良序和良基的理论</a>，以避免对现有类型系统的扩展时需要修改已有的类型的相关操作。</p>
<p>　　不需要依赖序的等价谓词可为<a href="#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义类型</a>提供直接的支持。</p>
<p>　　NPLA1 提供默认相等为<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">抽象相等</a>，对任意的值适用。</p>
<p>　　NPLA1 还提供对一等对象保证结果有意义的<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">引用相等</a>操作。非一等实体的引用相等关系未指定。</p>
<p>　　当前 NPLA1 不支持 <a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">[EGAL]</a> ，因为 [EGAL] 要求存在分辨任意<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">对象的值</a>是否可被修改的元数据。</p>
<p>　　因为<a href="../Terminology.zh-CN.html#%E8%87%AA%E6%8C%87">对应等价的不变性</a>关系不具有<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">唯一性</a>，且可能允许不唯一的方式引起副作用（如缓存），和 [R<sup>n</sup>RK] 不同，不以基本操作提供 <code>equal?</code> 对任意对象提供一般的相等操作。</p>
<p>　　未指定 <code>eq?</code> 的比较结果可允许实现复用存储右值的<a href="#%E9%A9%BB%E7%95%99">驻留</a>对象。</p>
<p>　　<code>eql?</code> 实际比较宿主值的相等。允许 <code>eqv?</code> 和 <code>eql?</code> 的不同可允许<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">一对多的类型映射</a>下比较对象语言的值的相等。（而多对一的类型映射 <code>eql?</code> 和 <code>eqv?</code> 可一致地比较。）</p>
<p>　　但是，当前实现中，大多数一对多映射的类型（如环境）都没有引起使 <code>eql?</code> 和 <code>eqv?</code> 不同的比较实现，因为不同宿主值类型的对象具有足够显著的差异，在大多数上下文不通过一些具有不可忽略开销的<a href="#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">转换机制</a>（如锁定<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境弱引用</a>转换为<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境强引用</a>），无法直接相互替换而保证行为差异可被忽略，因此逻辑上不适合定义为相等的。</p>
<p>　　而基于性能等理由，等其它一对多映射的类型（特别是可能基于宿主类型的值的子集的，如 <a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">NPLA 数值类型</a>中的 <code>&lt;integer&gt;</code> ）的值的比较也没有特别的处理，而引起 <code>eqv?</code> 和 <code>eql?</code> 的不同。</p>
<p>　　这些类型可能需要其它针对特定类型的等价谓词（如 <a href="#%E6%95%B0%E5%AD%A6%E5%BA%93"><code>=?</code></a>）进行相等性的比较。</p>
<p>　　类似 [R<sup>n</sup>RS] ，不同类型决定 <code>eqv?</code> 的结果是 <code>#f</code> ，但此处类型相同的含义不通过<a href="#%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB">类型分区</a>定义。</p>
<p>　　类似 [R<sup>n</sup>RS] ，行为不等价的函数的 <code>eqv?</code> 结果原则上应为 <code>#f</code> ，但这种等价性一般不可证明而无法保证，特别在关于语言实现以外的调用上。</p>
<p>　　为支持互操作使用<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>及避免限制合并子的子类型的<a href="#%E5%BC%80%E6%94%BE%E6%80%A7">开放性</a>，允许这些实现另行指定规则，假定引起程序可观察行为差异的函数调用调用名义等价。</p>
<p><strong>注释</strong></p>
<p>　　通常，等价谓词比较的求值应保证能终止且对非列表项和 <tt>n</tt> 个子项的列表分别具有 <tt>O(1)</tt> 和 <tt>O(n)</tt> 平摊复杂度。这是依赖数据结构实现的细节；语言不需要约束这个性质。</p>
<h3 id="控制基本函数"><a class="header" href="#控制基本函数">控制基本函数</a></h3>
<p><code>$if &lt;test&gt; &lt;consequent&gt; &lt;alternative&gt;</code></p>
<p>　　条件分支，按条件成立与否返回 <code>&lt;consequent&gt;</code> 或 <code>&lt;alternative&gt;</code> 之一，可能是引用值。</p>
<p><code>$if &lt;test&gt; &lt;consequent&gt;</code></p>
<p>　　省略第三操作数的条件分支，条件成立时返回 <code>&lt;consequent&gt;</code> 。</p>
<p>　　和 [R<sup>n</sup>RK] 不同而和 [R<sup>n</sup>RS] 类似，如 <code>&lt;test&gt;</code> 的求值结果非 <code>#f</code> 即选择 <code>&lt;consequent&gt;</code> ，且支持省略第三参数。</p>
<p>　　若省略 <code>&lt;alternative&gt;</code> 且 <code>&lt;test&gt;</code> 求值为 <code>#f</code> ，则<a href="#%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0">结果未指定</a> 。</p>
<p><strong>注释</strong></p>
<p>　　对 <code>&lt;test&gt;</code> 的处理的主要原理和 Kernel 的 <code>$and?</code> 不要求尾上下文的表达式求值检查类型一致。</p>
<p>　　若需要检查类型避免误用，可以派生提供其它函数；相反的派生无法利用更<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单</a>的实现。</p>
<p><strong>原理</strong></p>
<p>　　和 [R<sup>7</sup>RS] 类似，但和 [Racket] 及 [R<sup>n</sup>RK] 不同，省略 <code>&lt;alternative&gt;</code> 被支持。</p>
<p>　　和 [R<sup>7</sup>RK] 不同，不使用 <code>#inert</code> ，参见关于<a href="#%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0">参照实现接口描述</a>的原理。</p>
<p>　　和 [R<sup>n</sup>RK] 中的相关讨论结论不同，是否省略 <code>&lt;alternative&gt;</code> 的形式应是一致的。这是因为：</p>
<ul>
<li>NPLA1 不假设作为基本控制操作的 <code>$if</code> 的作用（仅要 <code>&lt;consequent&gt;</code> 或 <code>&lt;alternative&gt;</code> 求值的结果，或仅为了副作用）。</li>
<li><code>$if</code> 不假设用户对 <code>&lt;consequent&gt;</code> 和 <code>&lt;alternative&gt;</code> 顺序选择性偏好，以避免限制用户选择否定谓词简化 <code>&lt;test&gt;</code> ，从而支持<a href="#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1">变化的自由</a>。</li>
</ul>
<p>　　此外，NPLA1 使用显式的 <code>&lt;expression-sequence&gt;</code>（而不是 <code>&lt;consequent&gt;</code> 和 <code>&lt;alternative&gt;</code> ）语法表示顺序求值，这不适合基本的控制操作子：</p>
<p>　　若分离二操作数和三操作数其它形式，则二操作数可以使用 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>&lt;expression-sequence&gt;</code> ，即 <code>$when</code></a> 。</p>
<p>　　但依赖 <code>&lt;expression-sequence&gt;</code> 的 <code>$when</code> 不应是比具有 <code>&lt;consequent&gt;</code> 的二操作数形式更基本的操作。</p>
<p>　　因此，仍然需要有 <code>$when</code> 以外的省略第三参数的基本控制操作子。基于<a href="#%E7%BB%9F%E4%B8%80%E6%80%A7">统一性</a>，对应函数名仍然为 <code>$if</code> 。（尽管使用了相同的原则，这和 Kernel 的结论恰好相反。）</p>
<p>　　与此类似，和 <a href="https://stackoverflow.com/questions/10863192">[Racket] 的理由</a>不同，不因为 <code>$when</code> 提供只强调副作用的操作而取消 <code>$if</code> 的 <code>&lt;alternative&gt;</code> 。</p>
<p>　　NPLA1 不会如 [Racket] 一样在此避免遗漏 <code>&lt;alternative&gt;</code> 导致的非预期结果。这并不违反<a href="#%E9%80%82%E7%94%A8%E6%80%A7">适用性</a>，因为不使用 <code>&lt;alternative&gt;</code> 的结果非常显然，同时选择使用 <code>$if</code> 这样的基本控制操作而不是更特定派生控制操作或更高级的抽象已蕴含注意误用的必要性。</p>
<p>　　一般地，NPLA1 不提供强调只存在副作用的操作。返回未指定（而不要求被使用）的求值结果的情形<a href="#%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0">并不表示只有副作用</a>，因为副作用是否存在原则上依赖具体操作。这和 Kernel 的 <code>#inert</code> 以及 [Racket] 的 <code>#&lt;void&gt;</code> 值即便在实现上都一致，但含义不同。</p>
<p>　　另见 <code>$when</code> 的说明。</p>
<h3 id="对象基本函数"><a class="header" href="#对象基本函数">对象基本函数</a></h3>
<p><strong>模块约定：</strong></p>
<p>　　因为<a href="#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>的限制，列表左值只能引用完整的列表的对象，而不支持部分列表。</p>
<p>　　这影响 <code>set-rest!</code> 和 <code>set-rest%!</code> 的第一个参数。</p>
<p><strong>操作：</strong></p>
<p><code>null? &lt;object&gt;</code></p>
<p>　　判断操作数是否为空列表。</p>
<p><code>nullv? &lt;object&gt;</code></p>
<p>　　判断操作数是否为空列表纯右值。</p>
<p>　　同 <code>null?</code> ，但不支持引用值。</p>
<p><code>branch? &lt;object&gt;</code></p>
<p>　　判断操作数是否具有<a href="#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">枝节点</a>表示。</p>
<p><code>branchv? &lt;object&gt;</code></p>
<p>　　判断操作数是否为具有枝节点表示的纯右值。</p>
<p>　　同 <code>branch?</code> ，但不支持引用值。</p>
<p><code>pair? &lt;object&gt;</code></p>
<p>　　<code>&lt;pair&gt;</code> 的<a href="#%E8%B0%93%E8%AF%8D%E5%90%8D%E7%A7%B0%E5%90%8E%E7%BC%80">类型谓词</a>。</p>
<p><code>pairv? &lt;object&gt;</code></p>
<p>　　判断操作数是否为有序对纯右值。</p>
<p>　　同 <code>pair?</code> ，但不支持引用值。</p>
<p><code>symbol? &lt;object&gt;</code></p>
<p>　　<code>&lt;symbol&gt;</code> 的类型谓词。</p>
<p><code>reference? &lt;object&gt;</code></p>
<p>　　判断操作数是否为引用值。</p>
<p><code>unique? &lt;object&gt;</code></p>
<p>　　判断操作数是否为<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">唯一引用</a>。</p>
<p><code>modifiable? &lt;object&gt;</code></p>
<p>　　判断操作数是否为可修改对象或可修改对象的引用值。</p>
<p><code>temporary? &lt;object&gt;</code></p>
<p>　　判断操作数是否为<a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>或临时对象的引用值。</p>
<p><code>bound-lvalue? &lt;object&gt;</code></p>
<p>　　判断操作数是否为被引用的<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>左值。</p>
<p>　　绑定临时对象的引用类型的参数不被视为左值引用。</p>
<p>　　配合[<a href="#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>$resolve-identifier</code></a>和 <code>%</code> 引用标记<a href="#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">绑定</a>的变量，可确定实际参数是否为左值；参见 <code>$lvalue-identifier?</code>](#基本派生特性) 。</p>
<p>　　使用 <code>bound-lvalue?</code> 和 <code>&amp;</code> 引用标记字符绑定的变量，可确定实际参数是否为引用。</p>
<p><code>uncollapsed? &lt;object&gt;</code></p>
<p>　　判断操作数是否为未折叠的引用值。</p>
<p><code>deshare &lt;object&gt;</code></p>
<p>　　取指定对象取消共享的值。</p>
<p>　　同 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>idv</code></a> ，但显式转换操作数中具有共享持有者的<a href="#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">值数据成员</a>为不共享的值，且不转移<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主值</a>。</p>
<p><strong>原理</strong></p>
<p>　　因为提供<a href="#%E5%9C%A8%E5%87%BD%E6%95%B0%E5%80%BC%E4%B8%AD%E4%BF%9D%E7%95%99%E5%85%B6%E5%AE%83%E9%97%B4%E6%8E%A5%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0">在函数值中保留其它间接值的操作</a>，这个区别是必要的。否则，使用 <code>idv</code> 替代应不影响<a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA">可观察行为</a>。</p>
<p><code>as-const &lt;object&gt;</code></p>
<p>　　取指定对象的<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">不可修改</a>的引用。</p>
<p>　　同 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>id</code></a> ，但当参数是引用值时，结果是和参数引用相同对象的不可修改的引用值。</p>
<p><code>expire &lt;object&gt;</code></p>
<p>　　取指定对象的<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">消亡值</a>。</p>
<p>　　同 <code>id</code> ，但当参数是引用值时，结果是和参数引用相同对象的唯一引用。</p>
<p>　　可用于显式地指定之后被<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">转移</a>的对象，而不需要直接转移参数。</p>
<p>　　特别地，指定列表的引用值被转移时，不需要立即转移列表的每个元素，而允许之后通过<a href="#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>等方式选择转移的<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>。</p>
<p>　　可能包含立即转移的操作如 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>forward!</code></a> 。</p>
<p><strong>原理</strong></p>
<p>　　这不直接转移对象，而不是<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改操作</a>，<a href="#%E4%BF%AE%E6%94%B9%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E5%90%8E%E7%BC%80">函数名不以 <code>!</code> 结尾</a>。</p>
<p><strong>注释</strong></p>
<p>　　这个函数类似宿主语言标准库中作用在对象类型实际参数的 <code>std::move</code> ，可能减少没有经过<a href="#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4">复制消除</a>的<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">复制或转移</a>而改变使用这个函数的<a href="#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">结果对象</a>的副作用。</p>
<p><code>move! &lt;object&gt;</code></p>
<p>　　转移对象。</p>
<p>　　若参数是不可修改的左值，则以复制代替转移；否则，直接转移<a href="#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">表示参数对象的项</a>。</p>
<p>　　结果是不经返回值转换的项。</p>
<p><strong>注释</strong> 另见<a href="#%E8%BD%AC%E7%A7%BB%E5%AF%BC%E8%87%B4%E7%9A%84%E4%BF%AE%E6%94%B9">转移的注意事项</a>。</p>
<p><code>transfer! &lt;object&gt;</code></p>
<p>　　转移对象。</p>
<p>　　同 <code>move!</code> ，但使用<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">对象的转移</a>，而不是<a href="#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">项的转移</a>，避免宿主对象转移消除而<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">允许调用宿主对象的转移构造函数</a>。</p>
<p><strong>注释</strong> 参数被转移后，和<a href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>等<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2">引入实质化临时对象</a>时可能具有的转移的效果（仅在<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>时可见）可能相同。</p>
<p><code>ref&amp; &lt;object&gt;</code></p>
<p>　　取引用。</p>
<p>　　对引用值同 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>id</code></a> ；对具有共享持有者的值数据成员的对象也视为左值。通过后者构造的引用值不被检查。</p>
<p>　　取得的引用值是<a href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E5%BC%95%E7%94%A8%E5%80%BC">不安全引用值</a>。</p>
<p><strong>原理</strong></p>
<p>　　因为提供在函数值中保留其它间接值的操作，对共享持有者的值数据成员的对象使用不同的处理。否则，对引用值参数的情形，使用 <code>id</code> 替代应不影响可观察行为。</p>
<p><code>assign@! &lt;reference&gt; &lt;object&gt;</code></p>
<p>　　<a href="#%E8%B5%8B%E5%80%BC">赋值</a><code>&lt;reference&gt;</code> 的<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>为指定对象的值，且 <code>&lt;object&gt;</code> 不<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0">蕴含左值到右值转换</a>且<a href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0">不被折叠</a>。</p>
<p>　　赋值被引用对象前首先检查 <code>&lt;reference&gt;</code> 是可修改的左值。</p>
<p>　　赋值对象直接<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>被引用的对象，但不<a href="#%E6%97%A0%E6%95%88%E5%8C%96">无效化</a>参数指定的引用。</p>
<p>　　支持修改 <code>&lt;reference&gt;</code> 指定的子对象引用的被引用对象。</p>
<p><strong>注释</strong> 被赋值替换的子对象的引用可被无效化。Scheme 的 <code>set!</code> 在 <a href="https://srfi.schemers.org/srfi-17/srfi-17.html">[SRFI-17]</a> 提供具有类似作用的支持，但第一操作数限于 set! 且为特定的过程调用；Kernel 没有类似的操作。另见<a href="#%E8%B5%8B%E5%80%BC">赋值的注意事项</a>。</p>
<h3 id="有序对基本函数"><a class="header" href="#有序对基本函数">有序对基本函数</a></h3>
<p><code>cons &lt;object1&gt; &lt;object2&gt;</code></p>
<p>　　构造参数指定的两个元素构成的有序对。</p>
<p>　　结果是 <code>&lt;pair&gt;</code> 类型的值。</p>
<p><strong>注释</strong></p>
<p>　　不保留 <code>&lt;object2&gt;</code> 的引用值，但这不涉及 <code>&lt;object2&gt;</code> 是有序对或有序对的引用值时其中可能具有的元素。</p>
<p>　　若 <code>&lt;object2&gt;</code> 中存在元素，直接被作为结果的元素，不经过返回值转换。</p>
<p><code>cons% &lt;object1&gt; &lt;object2&gt;</code></p>
<p>　　构造参数指定的两个元素构成的有序对，保留引用值。</p>
<p>　　同 <code>cons</code> ，但参数是引用值时，直接以其值作为元素的值，而不以其<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">被引用对象</a>的值创建有序对。</p>
<p><strong>注释</strong> 这允许被构造的结果中存在和参数相等的引用值，而非其被引用对象的副本。</p>
<p><code>set-rest! &lt;pair&gt; &lt;object&gt;</code></p>
<p>　　修改列表的第一个以外的元素。</p>
<p><strong>注释</strong> 和 [R<sup>n</sup>RK] 的 set-cdr! 类似，但检查列表是左值，且不保留被添加元素中的引用值。</p>
<p><code>set-rest%! &lt;pair&gt; &lt;object&gt;</code></p>
<p>　　同 <code>set-rest!</code> ，但保留引用值。</p>
<p><strong>注释</strong> 和 [R<sup>n</sup>RK] 的 set-cdr! 类似，但检查列表是左值。</p>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RK] 不同，NPL 不支持列表中存在环。</p>
<p>　　不使用相同的对象左值的 <code>cons%</code> 调用或<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改操作</a>导致<a href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>，用户应自行避免<a href="#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">未定义行为</a>。</p>
<p>　　结果具有的属性不被影响。</p>
<h3 id="符号基本函数"><a class="header" href="#符号基本函数">符号基本函数</a></h3>
<p><code>desigil &lt;symbol&gt;</code></p>
<p>　　移除符号中的引用标记字符 <a href="#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6"><code>&amp;</code> 或 <code>%</code></a>。</p>
<p>　　判断符号非空且以 <code>&amp;</code> 或 <code>%</code> 起始，结果是移除起始字符的参数。否则，结果是参数。</p>
<p>　　不处理引用标记字符 <a href="#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6"><code>@</code></a>。</p>
<h3 id="环境基本函数"><a class="header" href="#环境基本函数">环境基本函数</a></h3>
<p><strong>模块约定：</strong></p>
<p>　　为避免引入过于容易引入<a href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>，仅通过个别操作引入<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境强引用</a>：</p>
<ul>
<li><code>make-environment</code></li>
<li><code>lock-environment</code></li>
</ul>
<p><strong>操作：</strong></p>
<p><code>eval@ &lt;object&gt; &lt;environment&gt;</code></p>
<p>　　在参数指定的环境中求值，结果作为函数值。</p>
<p>　　<code>&lt;object&gt;</code> 在求值前被视为 <code>&lt;expression&gt;</code> 。</p>
<p>　　<code>&lt;object&gt;</code> 不<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0">蕴含左值到右值转换</a>。</p>
<p><code>eval-string% &lt;string&gt; &lt;environment&gt;</code></p>
<p>　　在参数指定的环境中求值作为外部表示的字符串。</p>
<p><strong>注释</strong></p>
<p>　　类似 <a href="http://klisp.org/docs/Environments.html#Environments">klisp 的同名操作</a>，但保留引用值。</p>
<p>　　不提供类似 <code>eval@</code> 的 <code>eval-string@</code> ，因为不论参数的值类别，求值总是依赖的参数字符串的值。</p>
<p><code>eval-unit &lt;string&gt;</code></p>
<p>　　规约字符串表示的翻译单元以求值。</p>
<p>　　直接使用当前环境，但其中求值不在<a href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC">尾上下文</a>，也不改变当前续延。</p>
<p><strong>注释</strong></p>
<p>　　和 <code>eval-string%</code> 类似，但不支持指定环境，求值不在尾上下文，也不改变当前续延。</p>
<p>　　使用的实现环境可以是 <a href="#%E8%AF%8A%E6%96%AD">REPL</a> 环境。</p>
<p><code>bound? &lt;string&gt;</code></p>
<p>　　判断指定字符串对应的符号是否被绑定。</p>
<p><code>$resolve-identifier &lt;symbol&gt;</code></p>
<p>　　解析<a href="#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>中的标识符。</p>
<p>　　结果是解析结果中的项。</p>
<p><strong>注释</strong> 参数不按成员访问规则确定<a href="#npla1-%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">值类别</a>，也不按<a href="#npla1-%E8%A7%84%E8%8C%83%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">解析名称表达式的规则确保结果总是左值</a>，可<a href="#npla1-%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">保留消亡值</a>。</p>
<p><code>$move-resolved! &lt;symbol&gt;</code></p>
<p>　　转移解析标识符的对象。</p>
<p>　　和 <code>$resolve-identifier</code> 类似，但直接取<a href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1">被绑定对象</a>并尝试从环境中转移。</p>
<p>　　若环境被<a href="#%E5%86%BB%E7%BB%93">冻结</a>，则复制被绑定对象；否则，直接<a href="#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">转移对象的项</a>。</p>
<p>　　一般应仅用于被绑定的对象不需要再被使用时。</p>
<p><code>() copy-environment</code></p>
<p>　　递归复制当前环境。当前忽略特定的<a href="#npla1-%E7%8E%AF%E5%A2%83">父环境</a>。</p>
<p>　　结果是新创建的环境的强引用。</p>
<p><strong>警告</strong> 这个函数仅用于测试时示例构造环境，通常不应被用户程序使用，且可能在未来移除。未确定环境宿主值时可引起未定义行为。</p>
<p><code>freeze-environment! &lt;environment&gt;</code></p>
<p>　　冻结环境。</p>
<p>　　这个操作处理操作数指定的一等环境。</p>
<p><strong>注释</strong> 对<a href="#%E9%9A%90%E8%97%8F%E7%8E%AF%E5%A2%83">隐藏环境</a>初始化时的相同操作参见<a href="#%E5%86%BB%E7%BB%93">冻结操作</a>。</p>
<p><code>lock-environment &lt;environment&gt;</code></p>
<p>　　锁定环境：使用<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境弱引用</a>创建<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境强引用</a>。</p>
<p>　　检查参数是环境弱引用，若失败则引起<a href="#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型错误</a>。结果是对应的环境强引用。</p>
<p>　　强引用可能引起环境之间的不被检查的<a href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>，用户应自行避免<a href="#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">未定义行为</a>。</p>
<p><code>make-environment &lt;environment&gt;...</code></p>
<p>　　创建以参数为父环境的环境。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，除对象类型外，没有对列表和绑定的附加检查。</p>
<p>　　结果是新创建的环境，是环境强引用，具有宿主值类型 <code>shared_ptr&lt;Environment&gt;</code> 。</p>
<p><code>weaken-environment &lt;environment&gt;</code></p>
<p>　　使用环境强引用创建环境弱引用。</p>
<p>　　检查参数是环境强引用，若失败则引起类型错误。结果是对应的环境弱引用。</p>
<p><strong>原理</strong> 因为 NPLA1 需要精确控制所有权而<a href="#%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5">不依赖 GC</a>，这可用于派生实现某些操作（如 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$sequence</code></a> 必要的）。</p>
<p><code>$def! &lt;definiend&gt; &lt;expressions&gt;</code></p>
<p>　　定义：修改当前环境中的绑定。满足<a href="#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0">绑定构造</a>的约定。</p>
<p>　　<code>$def!</code> 和 <code>$defrec!</code> 在求值 <code>&lt;expressions&gt;</code> 后，进行<a href="#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>，确保环境没有被冻结后添加绑定。</p>
<p>　　对 <code>&lt;definiend&gt;</code> 中已存在的标识符的绑定，保证<a href="#%E9%87%8D%E7%BB%91%E5%AE%9A">直接替换对象的值，对象的引用不失效</a>。</p>
<p><strong>注释</strong></p>
<p>　　类似 [R<sup>n</sup>RK] ，对在 [<code>&lt;body&gt;</code>] 中某些未被直接求值的子表达式（如 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$lambda</code></a>的 <code>&lt;body&gt;</code>），因为其中的求值依赖 <code>$def!</code> 表达式求值后的环境，在之后仍可以实现递归。</p>
<p>　　类似 [R<sup>n</sup>RK] 的 <code>$define!</code> ，但绑定构造的约定存在不同规则。</p>
<p>　　求值 <code>&lt;body&gt;</code> 后进行类型检查和 [R<sup>n</sup>RK] 的 <code>$define!</code> 不同。</p>
<p>　　由于递归调用依赖环境中的绑定，修改以上定义引入的绑定后可影响被递归函数的调用。</p>
<p><code>$defrec! &lt;definiend&gt; &lt;expressions&gt;</code></p>
<p>　　递归定义：修改绑定，同 <code>$def!</code> ，但在绑定时针对 <code>&lt;definiend&gt;</code> 指定的<a href="#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">操作数树</a>中的绑定名称有附加的处理以支持直接递归。</p>
<p>　　除和 <code>$def!</code> 相同过程的常规绑定（求值 <code>&lt;expressions&gt;</code> 和绑定符号）外，支持<a href="#%E5%BC%BA%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">强递归绑定</a>，其操作数树的附加处理分为两阶段；每个阶段深度优先遍历 <code>&lt;definiend&gt;</code> 指定的操作数树，对每个符号进行附加处理：</p>
<ul>
<li>在常规绑定前，每个遍历的待绑定符号在目标环境（被定义影响的环境）中预先进行绑定，保证指称一个对默认对象的弱引用，其中默认对象具有调用总是抛出异常的<a href="#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">非真合并子</a>的值；和这个弱引用的共享的强引用被临时另行保存。</li>
<li>在常规绑定后，再次遍历操作数树，对每个实现支持的<a href="#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">合并子</a>的的值，替换之前在环境中保存的共享定义为默认对象的共享强引用，最后释放先前临时保存的默认对象的强引用。
<ul>
<li><strong>注释</strong> 这里的合并子包括<a href="#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">非真合并子</a>。</li>
</ul>
</li>
</ul>
<p>　　调用<a href="#%E5%BC%BA%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">默认对象</a>时：</p>
<ul>
<li>若默认对象的强引用存在，<a href="#%E5%BC%BA%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">引起错误</a>。</li>
<li>否则，违反生存期规则而具有未定义行为。
<ul>
<li><strong>注释</strong> 和 <a href="#%E7%8E%AF%E5%A2%83%E7%94%9F%E5%AD%98%E6%9C%9F">vau 抽象对环境的检查</a>类似，未定义行为不应被依赖。</li>
</ul>
</li>
</ul>
<p>　　常规绑定后转移未被 <code>&lt;expressions&gt;</code> 求值影响的绑定中的默认对象的所有权到环境中，但不影响绑定目标在对象语言中指称的值。</p>
<p>　　在环境中未被 <code>&lt;expressions&gt;</code> 求值替换的绑定，在 <code>$defrec!</code> 求值仍指称默认对象（而不会是持有<a href="#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">真合并子</a>的值），若被作为合并子<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">调用</a>，则显示存在循环递归调用。</p>
<p>　　和 <code>$def!</code> 不同，求值 <code>$defrec!</code> 的 <code>&lt;expressions&gt;</code> 前保证 <code>&lt;defindiend&gt;</code> 中的名称已存在默认定义，求值 <code>&lt;expressions&gt;</code> 可访问对应的名称而不因<a href="#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">名称解析</a>失败而<a href="#npla1-%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p><strong>注释</strong></p>
<p>　　和 <code>$def!</code> 不同，即使不计绑定修改环境的副作用，常规绑定后的操作使 <code>&lt;expressions&gt;</code> 不在尾上下文求值。</p>
<p>　　这允许递归定义的名称在绑定完成前指称对象。例如，派生<a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">标准环境</a>，当前环境中未绑定变量 <code>a</code> 和 <code>b</code> 时：</p>
<ul>
<li>求值表达式 <code>$def! (a b) list b ($lambda () 1)</code> 因为被求值的 <code>b</code> 未被绑定而引起错误。</li>
<li>求值表达式 <code>$defrec! (a b) list b ($lambda () 1)</code> 不需要 <code>a</code> 或 <code>b</code> 已被绑定（即便 <code>b</code> 并不在 <code>$lambda</code> 的 <code>&lt;body&gt;</code> 中），求值后 <code>a</code> 为默认对象。</li>
<li>求值表达式 <code>$defrec! (b &amp;a) list ($lambda () 1) b</code> 绑定要求同上，但求值后 <code>a</code> 可能为默认对象（操作数树中的同级叶节点被未指定的绑定顺序影响）。</li>
</ul>
<p>　　这也允许在 <a href="#%E5%90%88%E5%B9%B6%E5%AD%90%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>$vau/e</code></a>等表达式的 <code>&lt;environment&gt;</code> 指定的静态环境使 <code>&lt;body&gt;</code> 不能访问目标环境时，直接定义递归函数。</p>
<p>　　递归定义的对象中的<a href="#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1">值数据成员</a>可能具有共享的持有者。若为合并子，直接调用会利用替换的值重新访问所在的环境。复制和转移这样的值不会改变被访问的环境。若访问的环境失效，则抛出异常，或无限递归调用自身。</p>
<p>　　特定情形使用 <a href="#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>deshare</code></a>可去除共享和避免以上可能非预期的行为。</p>
<p>　　另见]环境](#npla1-环境)。</p>
<h3 id="合并子基本函数"><a class="header" href="#合并子基本函数">合并子基本函数</a></h3>
<p>　　和 [R<sup>n</sup>RS] 及 [R<sup>n</sup>RK] 不同，<code>&lt;body&gt;</code> 可以是多个项，而不再派生另外的变体支持顺序求值。</p>
<p>　　引入合并子的操作子不求值 <code>&lt;body&gt;</code> ，后者在被调用时替换操作数以后被求值。这允许安全地使用 <code>$def!</code> 而不需要 <code>$defrec!</code> 进行<a href="#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">递归绑定</a>。</p>
<p>　　检查失败的<a href="#npla1-%E9%94%99%E8%AF%AF">错误</a>是（可能依赖<a href="#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型错误</a>的）<a href="#npla1-%E9%94%99%E8%AF%AF">语法错误</a>。</p>
<p><code>$vau/e &lt;parent&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　创建指定静态环境的 <a href="#vau-%E6%8A%BD%E8%B1%A1">vau 抽象</a>。</p>
<p>　　创建的对象是<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">操作子</a>。</p>
<p><code>$vau/e% &lt;parent&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$vau/e</code> ，但保留引用值。</p>
<p><code>wrap &lt;combiner&gt;</code></p>
<p>　　<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">包装</a>合并子为<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">应用子</a>。</p>
<p>　　包装应用子可能符合<a href="#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">包装数溢出的错误条件</a> 。</p>
<p><code>wrap% &lt;combiner&gt;</code></p>
<p>　　同 <code>wrap</code> ，但参数不蕴含左值到右值转换，<a href="#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E7%9B%AE%E6%A0%87">在结果中保留引用值</a>。</p>
<p><code>unwrap &lt;applicative&gt;</code></p>
<p>　　<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">解包装</a>应用子为<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">底层合并子</a>。</p>
<p>　　左值参数解包装的<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">结果是合并子的子对象引用</a>。</p>
<p><strong>原理</strong></p>
<p>　　指定 <code>&lt;parent&gt;</code> 作为静态环境可通过被绑定实体的所有权控制一等对象的生存期。同时，在没有 safe-for-space 保证时，仍可有效避免<a href="#ptr">资源泄漏</a> 。</p>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RK] 不同，因为支持保存环境的所有权，提供 <code>$vau/e</code> 作为比 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$vau</code></a> 更基本的操作。</p>
<p>　　不考虑所有权时，<a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>eval</code></a> 和 <code>$vau</code> 可派生 <code>$vau/e</code> 。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，参数是右值时解包装的<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>被复制。由这些合并子创建的操作子当前仍不足以取代内置的一等操作子，因为不支持只能转移而不能复制的对象。传递这些对象作为操作数会引起构造失败的异常。</p>
<h3 id="错误处理和检查基本函数"><a class="header" href="#错误处理和检查基本函数">错误处理和检查基本函数</a></h3>
<p>　　以下函数提供<a href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">错误处理</a>的相关支持。</p>
<p><code>raise-error &lt;string&gt;</code></p>
<p>　　<a href="#npla1-%E5%BC%82%E5%B8%B8">引发</a>表示错误的<a href="#npla1-%E5%BC%82%E5%B8%B8">异常</a>。</p>
<p><code>raise-invalid-syntax-error &lt;string&gt;</code></p>
<p>　　引发包含参数指定的字符串内容的<a href="#npla1-%E9%94%99%E8%AF%AF">语法错误</a>。</p>
<p><code>raise-type-error &lt;string&gt;</code></p>
<p>　　引发包含参数指定的字符串内容的<a href="#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型错误</a>。</p>
<p><code>check-list-reference &lt;object&gt;</code></p>
<p>　　检查对象是否是列表引用：若检查通过转发参数作为结果，否则引发错误对象。</p>
<p><code>check-pair-reference &lt;object&gt;</code></p>
<p>　　检查对象是否是有序对引用：若检查通过转发参数作为结果，否则引发错误对象。</p>
<h3 id="封装基本函数"><a class="header" href="#封装基本函数">封装基本函数</a></h3>
<p><code>() make-encapsulation-type</code></p>
<p>　　创建封装类型。</p>
<p>　　和 [R<sup>n</sup>RK] 类似，结果是三个合并子组成的列表，其元素分别表示用于构造封装类型对象的<em>封装(encapsulate)</em> 构造器、判断封装类型的谓词和用于<em>解封装(decapsulate)</em> 的访问器：</p>
<ul>
<li>构造器直接使用参数，在结果（构造的封装对象）中保留参数的引用值，类似<a href="#%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%BB%93%E6%9E%9C%E5%8C%85%E5%90%AB%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AE%B9%E5%99%A8%E6%9E%84%E9%80%A0%E5%99%A8%E5%87%BD%E6%95%B0">可能使结果包含引用值的容器构造器函数</a>中<a href="#%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%BB%93%E6%9E%9C%E5%8C%85%E5%90%AB%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AE%B9%E5%99%A8%E6%9E%84%E9%80%A0%E5%99%A8">带有 <code>%</code> 的容器构造器</a>。</li>
<li>访问器根据参数的值类别转发被封装的值。</li>
</ul>
<p>　　创建的封装类型支持判断相等（参见 <a href="#%E7%AD%89%E4%BB%B7%E8%B0%93%E8%AF%8D%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>eqv?</code></a>），相等定义为被封装的对象的<a href="#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1">子对象</a>的<a href="#%E7%AD%89%E4%BB%B7%E8%B0%93%E8%AF%8D%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">递归相等性</a>。</p>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RK] 不同，使用构造器初始化封装的对象作为容器，具有作为其子对象的被封装的对象的所有权。</p>
<p>　　需要注意保存被构造的封装对象。</p>
<p>　　另见 <a href="https://small.r7rs.org/wiki/UniqueTypesSnellPym/">Unique Types</a> 和 <a href="https://srfi.schemers.org/srfi-137/srfi-137.html">[SRFI-137]</a> 。</p>
<p>　　和 [R<sup>n</sup>RK] 及 [R<sup>n</sup>RS] 的各种实现（如<a href="http://www.r6rs.org/r6rs-editors/2005-August/000831.html">这里</a>提到的）不同，对相同类型的封装对象，<code>eqv?</code> 和 <code>equal?</code> 基于被封装对象的子对象（及子对象被引用的对象）递归比较，即使用封装的对象的 equal? 定义 eqv? 结果。</p>
<p>　　另见<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">等价谓词的设计用例</a>。</p>
<h2 id="基础派生特性"><a class="header" href="#基础派生特性">基础派生特性</a></h2>
<p>　　<a href="#%E5%BA%93%E6%8E%A5%E5%8F%A3%E7%BA%A6%E5%AE%9A">根环境特性</a>中，除<a href="#%E6%A0%B9%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7">根环境基本特性</a>的剩余接口是<a href="#%E5%AE%9E%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%BA%A6%E5%AE%9A">派生特性</a>。其中在基础环境中提供的特性是<em>基础派生特性(grounded derived feature)</em> 。</p>
<h3 id="基本派生特性"><a class="header" href="#基本派生特性">基本派生特性</a></h3>
<p>　　基本派生特性可使用派生实现。这可能蕴含使用根环境基本特性或已在基本派生特性中提供的特性中的部分非派生实现。</p>
<p><strong>模块约定：</strong></p>
<p>　　引入合并子的操作子对 <code>&lt;body&gt;</code> 的约定同<a href="#%E5%90%88%E5%B9%B6%E5%AD%90%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">合并子基本函数</a>。</p>
<p>　　因互相依赖，一些操作实现为派生操作时，不能用于直接派生特定一些其它操作。</p>
<p>　　和 <a href="#%E5%90%88%E5%B9%B6%E5%AD%90%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>$vau/e</code> 或 <code>$vau/e%</code></a>以及 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$lambda/e</code> 或 <code>$lambda/e%</code></a>不同，不指定静态环境的合并子构造器隐含总是使用<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境弱引用</a>形式的静态环境，以避免过于容易引入<a href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>。</p>
<p>　　本节约定以下<a href="#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">求值得到的操作数</a>：</p>
<ul>
<li><code>&lt;box&gt;</code> ：<em>箱(box)</em> ：可包含<a href="#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8">引用</a>的容器。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　注意 <code>$let</code> 等函数的 <code>&lt;body&gt;</code> 形式和 [R<sup>n</sup>RK] 不同。</p>
<p><strong>操作：</strong></p>
<p><code>eval &lt;object&gt; &lt;environment&gt;</code></p>
<p>　　同 <a href="#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>eval@</code></a> ，但 <code>&lt;object&gt;</code> <a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0">蕴含左值到右值转换</a>且不保留引用值。</p>
<p><strong>注释</strong></p>
<p>　　若 <code>&lt;object&gt;</code> 为元素中有引用值的列表，元素不会被特殊处理，<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0">不蕴含左值到右值转换</a>。</p>
<p>　　[R<sup>n</sup>RK] 中同名合并子的第一参数为 <code>&lt;expression&gt;</code> ，但这不是<a href="#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">已求值的操作数</a>的类型。</p>
<p><code>eval% &lt;object&gt; &lt;environment&gt;</code></p>
<p>　　同 <code>eval@</code> ，但 <code>&lt;object&gt;</code> 蕴含左值到右值转换。</p>
<p><strong>注释</strong> 同 <code>eval</code> ，但保留引用值。</p>
<p><code>eval-string &lt;string&gt; &lt;environment&gt;</code></p>
<p>　　同 <a href="#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>eval-string</code></a> ，但不保留引用值。</p>
<p><code>() get-current-environment</code></p>
<p>　　取<a href="#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>：取当前环境的<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">弱引用</a>。</p>
<p><strong>注释</strong></p>
<p>　　派生需要非派生实现的 <code>$vau/e</code> 。</p>
<p><code>() lock-current-environment</code></p>
<p>　　锁定当前环境：取当前环境的<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">强引用</a>。</p>
<p><code>$vau &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　创建 <a href="#vau-%E6%8A%BD%E8%B1%A1">vau 抽象</a>。</p>
<p>　　类似 <a href="#%E5%90%88%E5%B9%B6%E5%AD%90%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>$vau/e</code></a>，但以当前环境代替额外的求值环境作为静态环境。</p>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RK] 不同，可通过 <a href="#%E5%90%88%E5%B9%B6%E5%AD%90%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>$vau/e</code></a>和（非派生的）<code>get-current-environment</code> 派生，不是<a href="#%E6%A0%B9%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7">基本操作</a>。</p>
<p><code>$vau% &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$vau</code>，但保留引用值。</p>
<p><code>$quote &lt;expression&gt;</code></p>
<p>　　求值引用操作。结果是<a href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2">返回值转换</a>后的未被求值的操作数。</p>
<p>　　考虑通常引用操作对符号类型未被求值的左值操作数使用，保留引用值没有意义，因此不提供对应保留引用值的操作。</p>
<p><code>id &lt;object&gt;</code></p>
<p>　　结果是不蕴含左值到右值转换的参数，在结果中保留引用值。</p>
<p>　　其作用等价返回值转换，<a href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87">可能引起对象转移</a>。</p>
<p><code>idv &lt;object&gt;</code></p>
<p>　　同 <code>id</code> ，但结果是返回值转换后的值。</p>
<p><strong>注释</strong> 使用 <code>idv</code> 可指定在函数值中<a href="#%E5%9C%A8%E5%87%BD%E6%95%B0%E5%80%BC%E4%B8%AD%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C">保留引用值的不安全操作</a> 的个别操作数不再保留引用值。</p>
<p><code>list .&lt;object&gt;...</code></p>
<p>　　创建列表（类型为 <code>&lt;list&gt;</code> ）对象。结果是操作数的元素经蕴含左值到右值转换的值。</p>
<p>　　<code>list</code> 的<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">底层合并子</a>接受 <code>&lt;pair&gt;</code>（而不要求是列表）作为函数合并对象，结果的类型是 <code>&lt;pair&gt;</code> 而不一定是 <code>&lt;list&gt;</code> 。</p>
<p><strong>注释</strong> 除元素的转换，类似 [R<sup>n</sup>RK] 的 <code>list</code> 。</p>
<p><code>$lvalue-identifier? &lt;symbol&gt;</code></p>
<p>　　解析当前环境中的标识符（同 <a href="#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>$resolve-identifier</code></a>）并判断是否为左值（同 <a href="#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>bound-lvalue?</code></a>）。</p>
<p><code>$expire-rvalue &lt;symbol&gt;</code></p>
<p>　　解析当前环境中的标识符，判断是否为左值（同 <code>$lvalue-identifier?</code> ），取对应的转换操作：</p>
<ul>
<li>若判断为左值，则转换操作同 <code>id</code> 。</li>
<li>否则，则转换操作同 <a href="#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>expire</code></a> 。</li>
</ul>
<p>　　结果是在根环境求值转换操作对应的<a href="#%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E7%BA%A6%E5%AE%9A">函数名</a>得到的引用值。</p>
<p><strong>注释</strong> 结果相同即以 <a href="#%E7%AD%89%E4%BB%B7%E8%B0%93%E8%AF%8D%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>eq?</code></a> 和对应的值比较结果为 <code>#t</code> 。</p>
<p><code>forward! &lt;object&gt;</code></p>
<p>　　<a href="#%E5%87%BD%E6%95%B0%E5%80%BC%E8%BD%AC%E5%8F%91">转发</a><a href="#%E5%87%BD%E6%95%B0%E5%80%BC%E8%BD%AC%E5%8F%91%E5%87%BD%E6%95%B0">可能是引用的值</a>。</p>
<p>　　转移可修改的右值操作数（包括消亡值和临时对象）。</p>
<p>　　其中，需转移时，使用使用<a href="#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB">项的转移</a>。这和<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB">对象的转移</a>不同，不保证调用宿主环境的转移构造函数。</p>
<p><strong>原理</strong> 和宿主语言不同，直接转移允许区分消亡值和纯右值，同等地作为一等对象（如作为列表的元素）。</p>
<p><strong>注释</strong></p>
<p>　　被转发的值若是<a href="#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C">形式参数树</a>中的变量，一般应以<a href="#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A">带有标记字符 <code>&amp;</code> 的形式绑定</a>；否则，转发的不是对应的实际参数，而可能是其按值绑定的副本。</p>
<p>　　这个函数类似宿主语言以对象类型参数和推断的函数参数类型作为模板参数调用 <code>std::forward</code> ，但若需转移，直接转移而非如 <a href="#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>expire</code></a>返回指定结果是<a href="#%E5%80%BC%E7%B1%BB%E5%88%AB">消亡值</a>的<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">唯一引用</a>。</p>
<p><code>list% .&lt;object&gt;...</code></p>
<p>　　同 <code>list</code> ，但每个参数都不蕴含左值到右值转换，<a href="#%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%BB%93%E6%9E%9C%E5%8C%85%E5%90%AB%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AE%B9%E5%99%A8%E6%9E%84%E9%80%A0%E5%99%A8">在结果中保留参数的引用值</a>。</p>
<p>　　<code>list%</code> 的底层合并子接受 <code>&lt;pair&gt;</code> 作为操作数（而不要求是列表），结果的类型是 <code>&lt;pair&gt;</code> 而不一定是 <code>&lt;list&gt;</code> 。</p>
<p><strong>注释</strong> 类似 [R<sup>n</sup>RK] 的 <code>list</code> 。</p>
<p><code>rlist &lt;list&gt;</code></p>
<p>　　转换参数为引用列表元素的列表。</p>
<p>　　若参数是左值，则结果是参数的元素的左值引用值构成的列表；否则，结果同 <code>idv</code> 。</p>
<p><code>$remote-eval &lt;expression&gt; &lt;environment&gt;</code></p>
<p>　　在动态环境求值第二参数得到的环境中求值第一参数，结果作为函数值。</p>
<p><code>$remote-eval% &lt;expression&gt; &lt;environment&gt;</code></p>
<p>　　同 <code>$remote-eval</code> ，但保留引用值。</p>
<p><code>$deflazy! &lt;definiend&gt; &lt;expressions&gt;</code></p>
<p>　　修改绑定。</p>
<p>　　同 <code>$def!</code> ，但不求值参数；在添加绑定前仍<a href="#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">对冻结环境进行检查</a>。</p>
<p><code>$set! &lt;environment&gt; &lt;definiend&gt; &lt;expressions&gt;</code></p>
<p>　　设置：修改指定环境的变量绑定。</p>
<p>　　在当前环境求值 <code>&lt;environment&gt;</code> 和 <code>&lt;body&gt;</code> ，再以后者的求值结果修改前者的求值结果指定的环境中的绑定。绑定效果同使用 <a href="#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">`$def!</a>。</p>
<p>　　类似 [R<sup>n</sup>RK] 的 <code>$set!</code> ，但明确使用 <code>&lt;definiend&gt;</code> 而不是 <code>&lt;formals&gt;</code> 。注意 <code>&lt;body&gt;</code> 的形式不同。允许的递归操作参见 <code>$def!</code> 。</p>
<p>　　和 [R<sup>n</sup>RK] 不同而和 NPLA1 的 <code>$def!</code> 等类似，在修改绑定前对冻结环境进行检查。</p>
<p><code>$setrec! &lt;environment&gt; &lt;definiend&gt; &lt;expressions&gt;</code></p>
<p>　　递归设置：修改指定环境的绑定，绑定效果同使用 <a href="#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>$defrec!</code></a>。</p>
<p>　　同 <code>$set!</code> ，但允许不同的递归操作。</p>
<p><strong>注释</strong> 参见 <code>$defrec!</code> 。</p>
<p><code>$wvau &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　创建包装的 <a href="#vau-%E6%8A%BD%E8%B1%A1">vau 抽象</a>。</p>
<p>　　同 <code>$vau</code> ，但创建的是调用时对操作数的元素求值一次的<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">应用子</a>。</p>
<p>　　参数的作用同 <code>$vau</code> 的对应参数。</p>
<p><code>$wvau% &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$wvau</code> ，但允许函数体求值返回引用值。</p>
<p><code>$wvau/e &lt;parent&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$wvau</code> ，但支持显式指定求值环境参数作为静态环境。</p>
<p><code>$wvau/e% &lt;parent&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$wvau/e</code> ，但保留引用值。</p>
<p><code>$lambda &lt;formals&gt; &lt;body&gt;</code></p>
<p>　　创建 <a href="#%CE%BB-%E6%8A%BD%E8%B1%A1">λ 抽象</a>。</p>
<p>　　同 <code>$vau</code> ，但创建的是调用时对操作数的元素求值一次的应用子，且忽略动态环境。</p>
<p><strong>注释</strong> 可通过 vau 抽象或 <code>$lambda/e</code> 和（非派生的）<code>get-current-environment</code> 派生。</p>
<p>　　除未提供的 <code>&lt;eformal&gt;</code> ，参数的作用同 <code>$vau</code> 的对应参数。</p>
<p><code>$lambda% &lt;formals&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$lambda</code> ，但允许函数体求值返回引用值。</p>
<p><code>$lambda/e &lt;parent&gt; &lt;formals&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$lambda</code> ，但支持显式指定求值环境参数作为静态环境。</p>
<p><code>$lambda/e% &lt;parent&gt; &lt;formals&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$lambda/e</code> ，但保留引用值。</p>
<p><code>list? &lt;object&gt;</code></p>
<p>　　<code>&lt;list&gt;</code> 的<a href="#%E8%B0%93%E8%AF%8D%E5%90%8D%E7%A7%B0%E5%90%8E%E7%BC%80">类型谓词</a>。</p>
<p>　　若参数是列表或非真列表，时间复杂度不大于 <tt>O(n)</tt> ，其中 <tt>n</tt> 是其中的元素数。</p>
<p><strong>注释</strong> 本机实现可实现 <tt>O(1)</tt> 时间复杂度。</p>
<p><code>list* &lt;object&gt;+</code></p>
<p>　　在列表前附加元素创建对象或有序对。</p>
<p>　　类似 <code>cons</code> ，但支持一个和多个参数。</p>
<p>　　对一个参数的情形结果同参数，否则结果同右结合嵌套调用参数的数量减 1 次的 <code>cons</code> 。</p>
<p><strong>注释</strong> 一个参数的情形结果经<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">返回值转换</a>。因为不需要如 Kernel 支持派生 <code>$vau</code> ，可直接使用 <code>apply</code> 派生；但因底层合并子还需检查列表，所以可使用 <code>apply-list</code> 。而和 <code>apply-list</code> 内部共用实现的派生可能更高效。</p>
<p><code>list*% &lt;object&gt;+</code></p>
<p>　　同 <code>list*</code> ，但创建有序对类似 <code>cons%</code> ，且元素保留引用值。</p>
<p><strong>注释</strong> 一个参数的情形结果不经返回值转换。</p>
<p><code>apply &lt;applicative&gt; &lt;object&gt; &lt;environment&gt;?</code></p>
<p>　　转发第一参数指定的应用子和第二参数指定的参数构成<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>，在环境中<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">应用</a>。其中，环境是：</p>
<ul>
<li><a href="#npla1-%E7%8E%AF%E5%A2%83">新环境</a>，若第二参数不存在。</li>
<li>否则，第二参数指定的环境。</li>
</ul>
<p><strong>注释</strong> 检查 <code>&lt;environment&gt;</code> 和 [R<sup>n</sup>RK] 的参考派生不同。</p>
<p>　　<code>apply</code> 的函数值保留引用值。</p>
<p><code>apply-list &lt;applicative&gt; &lt;list&gt; &lt;environment&gt;?</code></p>
<p>　　转发第一参数指定的应用子和第二参数指定的<a href="#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">参数列表</a>构成函数合并，在环境中应用。其中，环境同 <code>apply</code> 中的方式指定。</p>
<p>　　同 <code>apply</code> ，但首先检查第二参数的类型，若失败则<a href="#npla1-%E9%94%99%E8%AF%AF">引发错误</a>。</p>
<p><code>$sequence &lt;expression-sequence&gt;</code></p>
<p>　　顺序求值。</p>
<p>　　操作数非空时结果是最后的参数，可能是引用值。</p>
<p><strong>注释</strong> 类似 [R<sup>n</sup>RK] 的同名操作子。</p>
<p>　　求值每个 <code>&lt;object&gt;</code> 的副作用包括其中<a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的销毁都被顺序限制。</p>
<p><strong>注释</strong> 这类似宿主语言的语句而不是保证子表达式中的临时对象的生存期延迟到完全表达式求值结束的逗号表达式。这也允许实现和 [R<sup>n</sup>RK] 同名操作类似的 PTC 要求。</p>
<p><code>collapse &lt;object&gt;</code></p>
<p>　　折叠可能是引用的值。</p>
<p><code>forward &lt;object&gt;</code></p>
<p>　　转发可能是引用的非临时对象的值。</p>
<p>　　同 <code>forward!</code> ，但对可修改的临时对象操作数，使用复制代替转移。</p>
<p><strong>注释</strong></p>
<p>　　按在所在的环境中解析的操作数的类型<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">可选地进行返回值转换</a>作为结果，其作用 <code>id</code> 或 <code>idv</code> 之一。</p>
<p>　　转移（而不是复制）可修改的右值操作数。</p>
<p>　　若右值操作数不可修改，复制不可复制构造的宿主对象会失败。</p>
<p><code>assign%! &lt;reference&gt; &lt;object&gt;</code></p>
<p>　　同 <a href="#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>assign@!</code></a>，但 <code>&lt;object&gt;</code> 是引用值时赋值的源操作数是 <code>&lt;object&gt;</code> 折叠后的值。</p>
<p><code>assign! &lt;reference&gt; &lt;object&gt;</code></p>
<p>　　同 <code>assign%!</code> ，但 <code>&lt;object&gt;</code> 蕴含左值到右值转换。</p>
<p><strong>注释</strong></p>
<p>　　因为左值到右值转换，即便 <code>&lt;object&gt;</code> 指定的值来自 <code>&lt;reference&gt;</code> ，也可赋值而不因此引起未定义行为。</p>
<p>　　另见<a href="#%E8%B5%8B%E5%80%BC">赋值的注意事项</a>。</p>
<p><code>$defv! &lt;variable&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　绑定 vau 抽象，等价 <code>$def! &lt;variable&gt; $vau &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code> 。</p>
<p><code>$defv%! &lt;variable&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　绑定 vau 抽象，等价 <code>$def! &lt;variable&gt; $vau% &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code> 。</p>
<p><code>$defv/e! &lt;variable&gt; &lt;parent&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　绑定指定静态环境的 vau 抽象，等价 <code>$def! &lt;variable&gt; $vau/e &lt;parent&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code> 。</p>
<p><code>$defv/e%! &lt;variable&gt; &lt;parent&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　绑定指定静态环境的 vau 抽象，等价 <code>$def! &lt;variable&gt; $vau/e% &lt;parent&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code> 。</p>
<p><code>$defw! &lt;variable&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　绑定包装的 vau 抽象，等价 <code>$def! &lt;variable&gt; $wvau &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code> 。</p>
<p><code>$defw%! &lt;variable&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　绑定包装的 vau 抽象，等价 <code>$def! &lt;variable&gt; $wvau% &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code> 。</p>
<p><code>$defw/e! &lt;variable&gt; &lt;parent&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　绑定包装的指定静态环境的 vau 抽象，等价 <code>$def! &lt;variable&gt; $wvau/e &lt;parent&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code> 。</p>
<p><code>$defw/e%! &lt;variable&gt; &lt;parent&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code></p>
<p>　　绑定包装的指定静态环境的 vau 抽象，等价 <code>$def! &lt;variable&gt; $wvau/e% &lt;parent&gt; &lt;formals&gt; &lt;eformal&gt; &lt;body&gt;</code> 。</p>
<p><code>$defl! &lt;variable&gt; &lt;formals&gt; &lt;body&gt;</code></p>
<p>　　绑定 λ 抽象，等价 <code>$def! &lt;variable&gt; $lambda &lt;formals&gt; &lt;body&gt;</code> 。</p>
<p><code>$defl%! &lt;variable&gt; &lt;formals&gt; &lt;body&gt;</code></p>
<p>　　绑定 λ 抽象，等价 <code>$def! &lt;variable&gt; $lambda% &lt;formals&gt; &lt;body&gt;</code> 。</p>
<p><code>$defl/e! &lt;variable&gt; &lt;parent&gt; &lt;formals&gt; &lt;body&gt;</code></p>
<p>　　绑定指定静态环境的 λ 抽象，等价 <code>$def! &lt;variable&gt; $lambda/e &lt;parent&gt; &lt;formals&gt; &lt;body&gt;</code> 。</p>
<p><code>$defl/e%! &lt;variable&gt; &lt;parent&gt; &lt;formals&gt; &lt;body&gt;</code></p>
<p>　　绑定指定静态环境的 λ 抽象，等价 <code>$def! &lt;variable&gt; $lambda/e% &lt;parent&gt; &lt;formals&gt; &lt;body&gt;</code> 。</p>
<p><code>forward-first% &lt;applicative&gt; &lt;list&gt;</code></p>
<p>　　取列表的第一元素并转发给指定的应用子。</p>
<p>　　设参数列表 <code>(&amp;appv (&amp;x .))</code> ，作用同求值：</p>
<pre><code class="language-npla1">(forward! appv) (list% ($move-resolved! x))
</code></pre>
<p>　　其中，调用 <code>appv</code> 的<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">底层合并子</a>的当前环境同调用 <code>forward-first%</code> 的动态环境。</p>
<p><code>first &lt;pair&gt;</code></p>
<p>　　取有序对的第一个元素的值。</p>
<p>　　当 <code>&lt;list&gt;</code> 是左值时结果是折叠的引用值，否则结果是返回值转换后的值。</p>
<p><strong>注释</strong> 类似传统 Lisp 及 [R<sup>n</sup>RK] 的 <code>car</code> 。命名和 <a href="https://srfi.schemers.org/srfi-1/srfi-1.html">[SRFI-1]</a> 及 Clojure 等现代变体一致。</p>
<p><code>first@ &lt;pair&gt;</code></p>
<p>　　同 <code>first</code> ，但结果<a href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0">不被折叠</a>而总是<a href="#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8">未折叠的引用值</a>。</p>
<p>　　首先同调用 <a href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%92%8C%E6%A3%80%E6%9F%A5%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>check-pair-reference</code></a>的方式检查参数是有序对引用，对右值引发错误。</p>
<p><code>first% &lt;pair&gt;</code></p>
<p>　　同 <code>first</code> ，但结果总是转发的值。</p>
<p>　　转发的值是经过折叠但没有返回值转换的列表元素的值，无论参数是否为引用值。</p>
<p><code>first&amp; &lt;pair&gt;</code></p>
<p>　　同 <code>first@</code> ，但结果总是折叠的引用值。</p>
<p>　　若元素是引用值，在结果中保留元素中的唯一引用属性。</p>
<p><strong>原理</strong> 详见 <a href="#npla1-%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A">NPLA1 引用值使用约定</a>。</p>
<p><code>firstv &lt;pair&gt;</code></p>
<p>　　同 <code>first</code> ，但结果总是返回值转换后的值。</p>
<p><code>rest% &lt;pair&gt;</code></p>
<p>　　取有序对的第一个元素以外的元素值经过转发的值构成的有序对。</p>
<p>　　若结果构成<a href="#%E6%9C%89%E5%BA%8F%E5%AF%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子有序对</a>，可能引入<a href="#%E6%9C%89%E5%BA%8F%E5%AF%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">子有序对引用</a>。</p>
<p><code>rest&amp; &lt;pair&gt;</code></p>
<p>　　取有序对的第一个元素以外的元素值的引用值构成的有序对的<a href="#%E5%BC%95%E7%94%A8%E5%80%BC%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">子对象引用</a>。</p>
<p>　　首先同调用 <code>check-pair-reference</code> 的方式检查参数是有序对引用，对右值引发错误。</p>
<p>　　若结果构成子有序对，引入子有序对引用。</p>
<p><code>restv &lt;pair&gt;</code></p>
<p>　　取有序对的第一个元素以外的元素值构成的有序对。</p>
<p>　　结果是有序对对象。</p>
<p><code>set-first! &lt;pair&gt; &lt;object&gt;</code></p>
<p>　　修改有序对的第一个元素。</p>
<p>　　和 [R<sup>n</sup>RK] 的 <code>set-car!</code> 类似，但可派生，检查列表是左值，且不保留引用值。</p>
<p><code>set-first@! &lt;pair&gt; &lt;object&gt;</code></p>
<p>　　同 <code>set-first%!</code> ，但<a href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0">保留未折叠的引用值</a>。</p>
<p><code>set-first%! &lt;pair&gt; &lt;object&gt;</code></p>
<p>　　同 <code>set-first!</code> ，但保留引用值。</p>
<p>　　不保证检查<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改操作</a>导致循环引用。</p>
<p><strong>注释</strong> 用户应自行避免<a href="#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">未定义行为</a>。</p>
<p><code>equal? &lt;object1&gt; &lt;object2&gt;</code></p>
<p>　　判断一般相等。</p>
<p>　　类似 <a href="#%E7%AD%89%E4%BB%B7%E8%B0%93%E8%AF%8D%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>eqv?</code></a>，但同时支持表示中具有子项作为子对象的对象。</p>
<p>　　判断的相等定义为子对象的递归<a href="#%E7%AD%89%E4%BB%B7%E8%B0%93%E8%AF%8D%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">相等性</a>。</p>
<p><strong>注释</strong></p>
<p>　　类似 [R<sup>n</sup>RK] 和 [R<sup>n</sup>RS] 的同名的二元谓词，但在此保证可通过 <code>eqv?</code> 直接构造。：</p>
<p>　　因为<a href="#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">列表的性质</a>，不需要支持<a href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>，可以直接派生。后者被视为基本的抽象而非实现细节。</p>
<p>　　和 <a href="#%E5%B0%81%E8%A3%85%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>make-encapsulation-type</code></a>创建的对象的相等比较不同，本机实现和派生实现都依赖当前上下文，允许捕获续延，尽管续延是未指定的。</p>
<p><code>check-environment &lt;object&gt;</code></p>
<p>　　检查<a href="#npla1-%E7%8E%AF%E5%A2%83">环境</a>。</p>
<p>　　若参数是 <code>&lt;environment&gt;</code> 则检查通过，结果是转发的参数；否则，<a href="#npla1-%E5%BC%82%E5%B8%B8">引发错误对象</a>。</p>
<p><strong>注释</strong> 当前实现中其它要求 <code>&lt;enviornment&gt;</code> 参数的操作中<a href="#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>失败和 <code>check-environment</code> 失败的行为一致。</p>
<p><code>check-parent &lt;object&gt;</code></p>
<p>　　检查作为环境的<a href="#npla1-%E7%8E%AF%E5%A2%83">父环境</a>的对象。</p>
<p>　　若参数是可以作为合并子环境的 <code>&lt;parent&gt;</code> 则检查通过，结果是转发的参数；否则，引发错误对象。</p>
<p>　　检查环境通过的条件同<a href="#%E5%90%88%E5%B9%B6%E5%AD%90%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">创建合并子时的检查</a>。</p>
<p>　　引发错误对象的作用同<a href="#npla1-%E9%94%99%E8%AF%AF">创建合并子时环境检查失败引起错误或引发其依赖</a>的错误对象（后者保证不是<a href="#npla1-%E9%94%99%E8%AF%AF">语法错误</a>）。</p>
<p><code>$cond &lt;clauses&gt;</code></p>
<p>　　条件选择。</p>
<p>　　类似 [R<sup>n</sup>RK] 的同名操作子，但 <code>&lt;test&gt;</code> 的判断条件和 <code>&lt;body&gt;</code> 形式不同。</p>
<p><code>$when &lt;test&gt; &lt;expression-sequence&gt;</code></p>
<p>　　条件成立时顺序求值。</p>
<p>　　类似 klisp 的同名操作子，但若 <code>&lt;expression-sequence&gt;</code> 被求值，结果是 <code>&lt;expression-sequence&gt;</code> 的最后一个 <code>&lt;expression&gt;</code> 的求值结果，而不是 <code>#inert</code> 。</p>
<p><strong>注释</strong> 这类似 [Racket] 的 <code>when</code> 而和 [R<sup>7</sup>RS] 的 <code>when</code> 或 klisp 的同名操作不同，因为 <code>$when</code> 被作为和 <code>$sequence</code> 类似的操作处理（对应 Racket 中的 <code>when</code> 和 <code>begin</code> 并列）。</p>
<p><code>$unless &lt;test&gt; &lt;expression-sequence&gt;</code></p>
<p>　　条件不成立时顺序求值。</p>
<p>　　类似 klisp 的同名操作子，但若 <code>&lt;expression-sequence&gt;</code> 被求值，结果和设计原理同上。</p>
<p><code>not? &lt;object&gt;</code></p>
<p>　　逻辑非。</p>
<p>　　被求值的参数同 <code>&lt;test&gt;</code> ，进行左值到右值转换。</p>
<p>　　若参数非 <code>#f</code> 时结果是 <code>#f</code> ，否则结果是 <code>#t</code> 。</p>
<p><strong>注释</strong> 和 [R<sup>n</sup>RK] 不同而和 Scheme 类似，视所有非 <code>#f</code> 的值为 <code>#t</code> 。</p>
<p><code>$and &lt;test&gt;...</code></p>
<p>　　逻辑与。</p>
<p>　　顺序短路求值。操作数为空时结果是 <code>#t</code> ；参数求值存在 <code>#f</code> 时结果是 <code>#f</code> ；否则结果是最后一个参数的值。</p>
<p>　　结果保留引用值。</p>
<p><strong>原理</strong></p>
<p>　　[R<sup>n</sup>RK] 的 <code>$and?</code> 和 <code>$or?</code> 的实现使用 <code>apply</code> 和 <code>wrap</code> ，这没有必要：</p>
<ul>
<li>按 [R<sup>n</sup>RK] 的 <code>apply</code> 的原理，这种对任意合并子适用的操作 <code>combine</code> 容易实现且干扰意图的理解。</li>
<li>对 NPLA1 的 <code>apply</code> ，还保证在第一参数是空列表时，为适应合<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6%E6%B1%82%E5%80%BC">求值函数合并（前缀 <code>()</code> ）</a>，被继续求值的对象仍是有序对（即函数合并，而不是单独的函数），但这在 NPLA1 的 <code>$and</code> 和 <code>$or</code> 中不必要，因为对应的情形（即 <code>$and</code> 或 <code>$or</code> 没有参数时）应被单独处理。</li>
<li>对派生实现，<code>apply</code> 通常比 <code>eval%</code> 更低效（因为包含了无用的检查和更多的非本机实现）。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RK] 的 <code>$and?</code> 不同，不检查类型，也不保证结果类型是 <code>&lt;boolean&gt;</code> ，所以命名<a href="#%E8%B0%93%E8%AF%8D%E5%90%8D%E7%A7%B0%E5%90%8E%E7%BC%80">不以 <code>?</code> 结尾</a>。</p>
<p>　　和 [R<sup>n</sup>RK] 中的原理描述的不同，这同时允许直接的满足 <a href="#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C-ptc">PTC</a> 要求的派生实现。</p>
<p><code>$or &lt;test&gt;...</code></p>
<p>　　逻辑或。</p>
<p>　　顺序短路求值。操作数为空时结果是 <code>#f</code> ，参数求值存在不是 <code>#f</code> 的值时结果是第一个这样的值；否则结果是 <code>#t</code> 。</p>
<p>　　结果保留引用值。</p>
<p><strong>原理</strong></p>
<p>　　参见以上 <code>$and</code> 的原理。</p>
<p><strong>注释</strong></p>
<p>　　和 [R<sup>n</sup>RK] 的 <code>$or?</code> 不同，具体差异参见以上 <code>$and</code> 的注释。</p>
<p><code>accl &lt;object1&gt; &lt;predicate&gt; &lt;object2&gt; &lt;applicative1&gt; &lt;applicative2&gt; &lt;applicative3&gt;</code></p>
<p>　　在抽象列表的元素上应用左结合的二元操作。</p>
<p>　　对 <code>&lt;object1&gt;</code> 指定的抽象列表进行处理，取得部分和。</p>
<p>　　当谓词 <code>&lt;predicate&gt;</code> 成立时结果是 <code>&lt;object2&gt;</code> ，否则继续处理抽象列表中余下的元素。</p>
<p>　　处理抽象的列表的操作通过余下的应用子分别定义：取列表头、取列表尾和部分和的二元合并操作。</p>
<p>　　参数 <code>&lt;applicative1&gt;</code> 和参数参数 <code>&lt;applicative2&gt;</code> 应接受两个参数，否则<a href="#npla1-%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　参数 <code>&lt;applicative3&gt;</code> 应接受两个参数，否则引起错误。</p>
<p>　　调用参数中的应用子的 <code>&lt;object1&gt;</code> 实际参数在不同的应用子调用中可能<a href="#npla1-%E5%AF%B9%E8%B1%A1%E5%90%8C%E4%B8%80%E6%80%A7">同一</a>。</p>
<p>　　调用参数中的应用子的底层合并子的当前环境同调用 <code>accl</code> 的动态环境。</p>
<p><code>accr &lt;object1&gt; &lt;predicate&gt; &lt;object2&gt; &lt;applicative1&gt; &lt;applicative2&gt; &lt;applicative3&gt;</code></p>
<p>　　在抽象列表的元素上应用右结合的二元操作。</p>
<p>　　操作方式同 <code>accl</code> 。</p>
<p>　　和 <code>accl</code> 不同，可保证合并操作是尾调用；相应地，递归调用不是尾上下文而无法满足 <a href="#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C-ptc">PTC</a> 要求。</p>
<p><code>foldr1 &lt;applicative&gt; &lt;object&gt; &lt;list&gt;</code></p>
<p>　　作用同符合以下要求的 <code>accr</code> 调用：</p>
<ul>
<li>指定 <code>accr</code> 的参数为 <code>&lt;list&gt;</code> 、<code>null?</code> 、<code>(forward! &lt;object&gt;)</code> 、<code>first%</code> 、<code>rest%</code> 和 <code>&lt;applicative&gt;</code> 。</li>
<li>调用应用子 <code>rest%</code> 时不复制 <code>&lt;object&gt;</code> 或其子对象。</li>
</ul>
<p>　　参数指定的应用子的调用不添加或移除列表元素，否则<a href="#npla1-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">行为未定义</a>。</p>
<p><strong>注释</strong></p>
<p>　　类似 <a href="https://srfi.schemers.org/srfi-1/srfi-1.html">[SRFI-1]</a>) 的 <code>fold-right</code> ，但只接受一个<a href="#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>。</p>
<p>　　<code>foldr1</code> 名称中的 <code>1</code> 指 <code>&lt;list&gt;</code> 参数的个数。（更一般的其它形式可接受多个 <code>&lt;list&gt;</code> 。）</p>
<p><code>map1 &lt;applicative&gt; &lt;list&gt;</code></p>
<p>　　单列表映射操作：使用指定应用子对列表中每个参数进行调用，结果是其<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>的列表。</p>
<p>　　参数 <code>&lt;applicative&gt;</code> 应接受一个参数，否则引起错误。</p>
<p>　　操作中的应用子和列表构造的结果的确定满足过程调用的<a href="#%E8%BF%87%E7%A8%8B">因果性</a>；其余任意 <code>&lt;applicative&gt;</code> 调用的求值、列表构造操作和销毁列表中的元素的操作的相对顺序未指定。</p>
<p>　　<code>&lt;applicative&gt;</code> 的调用不添加或移除列表元素，否则行为未指定。</p>
<p><strong>注释</strong></p>
<p>　　类似 [R<sup>n</sup>RK] 的 <code>map</code> ，但只接受一个<a href="#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>。</p>
<p>　　<code>map1</code> 名称中的 <code>1</code> 的含义类似 <code>fold1</code> 。</p>
<p><code>first-null? &lt;list&gt;</code></p>
<p>　　复合 <code>first</code> 和 <code>null?</code> 操作。</p>
<p><code>rulist &lt;list&gt;</code></p>
<p>　　转换参数为可带有唯一引用的引用列表元素的列表。</p>
<p>　　同 <code>rlist</code> ，但在参数是左值时，参数中的非引用值元素在结果中对应转换为其唯一引用。</p>
<p><strong>注释</strong> 消亡值处理和 <code>rlist</code> 不同。</p>
<p><code>list-concat &lt;list&gt; &lt;object&gt;</code></p>
<p>　　顺序连接列表和对象。</p>
<p><strong>注释</strong> 当且仅当 <code>&lt;object&gt;</code> 实际参数是 <code>&lt;list&gt;</code> 值时，结果是 <code>&lt;list&gt;</code> 值。</p>
<p><code>append &lt;list&gt;...</code></p>
<p>　　顺序连接零个或多个列表。</p>
<p><strong>注释</strong> 若没有参数，结果是空列表。</p>
<p><code>list-extract-first &lt;list&gt;</code></p>
<p>　　以 <code>first</code> 在参数指定的 <code>&lt;pair&gt;</code> 的列表中选取并合并内容为新的列表。</p>
<p>　　设参数列表 <code>(&amp;l)</code> ，结果同在新环境中求值表达式 <code>map1 first l</code> ，其中 <code>map1</code> 和 <code>first</code> 是标准库函数。</p>
<p><code>list-extract-rest%! &lt;list&gt;</code></p>
<p>　　以 <code>rest%</code> 在参数指定的 <code>&lt;pair&gt;</code> 的列表中选取并合并内容为新的列表。</p>
<p>　　设参数列表 <code>(&amp;l)</code> ，结果同在新环境中求值表达式 <code>map1 rest% l</code> ，其中 <code>map1</code> 和 <code>rest%</code> 是标准库函数。</p>
<p><code>list-push-front! &lt;list&gt; &lt;object&gt;</code></p>
<p>　　在列表前插入元素。</p>
<p>　　要求 <code>&lt;list&gt;</code> 可修改，否则<a href="#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>失败。</p>
<p>　　参数 <code>&lt;object&gt;</code> 被转发。</p>
<p><code>$let &lt;bindings&gt; &lt;body&gt;</code></p>
<p>　　局部绑定求值：创建以当前环境为父环境的空环境，在其中添加 <code>&lt;bindings&gt;</code> 指定的变量绑定，再求值 <code>&lt;body&gt;</code> 。</p>
<p>　　在添加绑定前，<code>&lt;bindings&gt;</code> 中的<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初值符</a>被求值。</p>
<p>　　<a href="#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%80%BC">返回非引用值</a>。</p>
<p><strong>注释</strong> 类似 [R<sup>n</sup>RK] 的同名操作子，但返回非引用值。</p>
<p><code>$let% &lt;bindings&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$let</code> ，但保留引用值。</p>
<p><code>$let/e &lt;parent&gt; &lt;bindings&gt; &lt;body&gt;</code></p>
<p>　　指定静态环境并局部绑定求值。</p>
<p><strong>原理</strong></p>
<p>　　显式控制 <code>&lt;parent&gt;</code> 以允许传递引用值并在外部确保环境（可以是<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境强引用</a>）被正确传递作为求值的父环境，而无需支持<a href="#%E7%94%9F%E5%AD%98%E6%9C%9F%E6%89%A9%E5%B1%95">扩展</a> <code>&lt;parent&gt;</code> 中的环境为右值时其中的环境临时对象的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">生存期</a>。</p>
<p>　　注意此时 <code>&lt;parent&gt;</code> 中的环境中创建的环境对象在表达式求值后仍会因引入的合并子生存期结束而被销毁。</p>
<p><strong>注释</strong></p>
<p>　　类似 [R<sup>n</sup>RK] 的 <code>$let-redirect</code> ，但使用 <code>$lambda/e</code> 而非 <code>$lambda</code> 作为抽象且支持 <code>&lt;parent&gt;</code> ，并返回非引用值。</p>
<p><code>$let/e% &lt;parent&gt; &lt;bindings&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$let/e</code> ，但使用 <code>$lambda/e%</code> 而非 <code>$lambda/e</code> 创建抽象，保留引用值。</p>
<p><code>$let* &lt;bindings&gt; &lt;body&gt;</code></p>
<p>　　顺序局部绑定求值。</p>
<p>　　同 <code>$let</code> ，但 <code>&lt;bindings&gt;</code> 中的被用于绑定的表达式从左到右顺序求值，被用于初始化变量的表达式在求值时可访问 <code>&lt;bindings&gt;</code> 中之前绑定的符号。</p>
<p><strong>注释</strong> 类似 [R<sup>n</sup>RK] 的同名操作。</p>
<p><code>$let*% &lt;bindings&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$let*</code> ，但保留引用值。</p>
<p><code>$letrec &lt;bindings&gt; &lt;body&gt;</code></p>
<p>　　允许递归引用绑定的顺序局部绑定求值。</p>
<p><strong>注释</strong> 类似 [R<sup>n</sup>RK] 的同名操作。</p>
<p>　　和 <code>$let</code> 及 <code>$let*</code> 不同，操作求值 <code>&lt;bindings&gt;</code> 的初值符时保证使用和求值 <code>&lt;body&gt;</code> 时的同一环境作为当前环境，因此可配合 <code>lock-current-environment</code> 传递具有所有权的环境。</p>
<p><code>$letrec% &lt;bindings&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$letrec</code> ，但保留引用值。</p>
<p><code>derive-current-environment &lt;environment&gt;...</code></p>
<p>　　创建当前环境的派生环境：以参数指定的环境和当前环境为<a href="#npla1-%E7%8E%AF%E5%A2%83">父环境</a>的<a href="#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">空环境</a>。</p>
<p>　　当前环境以外的父环境顺序同参数顺序。当前环境是最后一个父环境。</p>
<p><code>() make-standard-environment</code></p>
<p>　　创建<a href="#%E6%96%B0%E7%8E%AF%E5%A2%83">新</a><em>标准环境(standard environment)</em> ：以<a href="#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">基础环境</a>为父环境的空环境。</p>
<p>　　类似 [R<sup>n</sup>RK] 的 <code>make-standard-kernel-environment</code> ，但创建的环境基于 NPLA1 基础环境。</p>
<p><strong>注释</strong> 标准环境同 [R<sup>n</sup>RK] 约定的定义。</p>
<p><code>derive-environment &lt;environment&gt;...</code></p>
<p>　　创建基础环境的派生环境：以参数指定的环境和基础环境为父环境的空环境。</p>
<p>　　当前环境以外的父环境顺序同参数顺序。基础环境是最后一个父环境。</p>
<p>　　创建的环境是标准环境，当且仅当没有实际参数。</p>
<p><strong>注释</strong> 类似 <code>make-standard-environment</code> ，但具有参数指定的环境作为其它的父环境。</p>
<p><code>$as-environment &lt;body&gt;</code></p>
<p>　　求值表达式以构造环境。</p>
<p>　　创建以当前环境为父环境的空环境，并在其中求值参数指定的表达式。</p>
<p>　　结果是创建的环境强引用。</p>
<p><code>$bindings/p-&gt;environment (&lt;environment&gt;...) &lt;binding&gt;...</code></p>
<p>　　转换绑定列表为以指定的环境列表中的环境为父环境的具有这些绑定的环境。</p>
<p>　　类似 [R<sup>n</sup>RK] 的 <code>$binding-&gt;environment</code> ，但指定父环境，且具有适当的所有权。</p>
<p>　　使用 <a href="#%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>make-environment</code></a>而不是 <code>$let/e</code> 等绑定构造实现。</p>
<p><code>$bindings-&gt;environment &lt;binding&gt;...</code></p>
<p>　　转换绑定列表为没有父环境的具有这些绑定的环境。</p>
<p><strong>注释</strong> 类似 [R<sup>n</sup>RK] 的同名操作子，但因为要求对内部父环境环境所有权，使用 <code>$bindings/p-&gt;environment</code> 而不是 <code>$let/e</code> 等绑定构造派生。</p>
<p><code>symbols-&gt;imports &lt;symbol&gt;...</code></p>
<p>　　转换符号列表为未求值的适合初始化符号<a href="#%E5%AF%BC%E5%85%A5%E7%AC%A6%E5%8F%B7">导入</a>列表的初值符列表。</p>
<p>　　结果是包含同 <a href="#%E7%AC%A6%E5%8F%B7%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>desigil</code></a>的方式移除<a href="#%E6%96%87%E6%B3%95%E5%85%83%E7%B4%A0%E8%A1%A5%E5%85%85%E7%BA%A6%E5%AE%9A">标记字符</a>后的参数作为间接子项的列表。</p>
<p>　　求值这个列表，结果是同 <code>forward!</code> 的方式转发每个符号的列表，其元素顺序和 <code>&lt;symbols&gt;</code>... 中的值的顺序对应。</p>
<p>　　结果的结构和使用满足以下约定：</p>
<ul>
<li>结果中可能存在合并子作为其子对象，其<a href="#npla1-%E5%90%88%E5%B9%B6%E5%AD%90">包装数</a>未指定。</li>
<li>取结果中的子对象进行求值的行为未定义。</li>
<li>若结果被修改（如被转移），再求值时行为未定义。</li>
<li>若结果中的合并子在求值整个结果外的上下文被调用，行为未定义。</li>
</ul>
<p><strong>原理</strong> 这些约定可允许更有效的本机实现。</p>
<p><strong>注释</strong></p>
<p>　　类似 [R<sup>n</sup>RK] 的 <code>$provide!</code> 和 <code>$import!</code> 提供符号列表的方式，但有以下不同：</p>
<ul>
<li>支持移除引用标记字符。</li>
<li>支持转发参数。</li>
<li>不带有引用标记字符和符号指称的对象不是<a href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">临时对象</a>的默认情形复制值而不是初始化引用。</li>
</ul>
<p><code>$provide/let! &lt;symbols&gt; &lt;bindings&gt; &lt;body&gt;</code></p>
<p>　　指定局部绑定后在当前环境中提供绑定。</p>
<p>　　蕴含 <code>$let &lt;bindings&gt; &lt;body&gt;</code> ，在求值 <code>&lt;body&gt;</code> 后以结果作为操作数绑定到 <code>&lt;symbols&gt;</code> 的符号。</p>
<p>　　<code>&lt;symbols&gt;</code> 应能被作为 <code>&lt;definiend&gt;</code> 使用。</p>
<p>　　结果是对这些绑定具有所有权的环境强引用。</p>
<p>　　需要<a href="#%E5%AF%BC%E5%85%A5%E7%AC%A6%E5%8F%B7">导入符号</a>，即 <code>&lt;symbols&gt;...</code> 具有至少一个实际参数时，以同 <code>symbols-&gt;imports</code> 的方式确定初值符。其中，等效的 <code>symbols-&gt;imports</code> 的调用次数未指定。</p>
<p><strong>注释</strong> 绑定后的符号可通过作为 vau 抽象的<a href="#%E7%8E%AF%E5%A2%83%E7%94%9F%E5%AD%98%E6%9C%9F">父环境</a>等形式依赖这个环境，因此用户需适当保存<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>使<a href="#%E7%8E%AF%E5%A2%83%E7%94%9F%E5%AD%98%E6%9C%9F">其生存期</a>覆盖在被使用的绑定符号指称的对象生存期。</p>
<p><code>$provide! &lt;symbols&gt; &lt;body&gt;</code></p>
<p>　　在当前环境中提供绑定。</p>
<p>　　同 <code>$provide/let!</code> ，但不指定单独的 <code>&lt;bindings&gt;</code> 。</p>
<p>　　作用同 <code>&lt;bindings&gt;</code> 为空列表的 <code>$provide/let!</code> 。</p>
<p>　　结果是创建的环境的强引用。</p>
<p>　　需要导入符号时，以同 <code>symbols-&gt;imports</code> 的方式确定初值符。其中，等效的 <code>symbols-&gt;imports</code> 的调用次数未指定。</p>
<p><strong>注释</strong> 类似 [R<sup>n</sup>RK] 的同名操作子，但结果是创建的环境的强引用，且确定初值符的方式被显式要求。</p>
<p>　　仅当 <code>&lt;symbols&gt;</code> 类型检查通过时求值 <code>&lt;body&gt;</code> 。</p>
<p>　　检查当前<a href="#%E5%86%BB%E7%BB%93">环境可修改</a>失败时的副作用和以上任一等效求值 <code>symbols-&gt;imports</code> 应用子的结果可能具有的副作用<a href="#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F">非决定性有序</a>。</p>
<p><code>$import! &lt;environment&gt; &lt;symbol&gt;...</code></p>
<p>　　从指定的环境导入指定的符号。</p>
<p>　　对第一参数之后的其余参数指定的符号列表中的每个符号，修改第一参数指定的环境，创建和指定的符号具有相同的名称和值的变量绑定。</p>
<p>　　类似 [R<sup>n</sup>RK] 的同名操作子，但需要导入符号时，以同求值 <code>symbols-&gt;imports</code> 应用子的结果的方式确定初值符。其中，等效的 <code>symbols-&gt;imports</code> 的调用次数未指定。</p>
<p>　　当指定的环境中的指定符号对应的绑定以临时对象创建时，导入符号可修改指定的源环境的被绑定对象。</p>
<p><strong>注释</strong> 由于求值 <code>symbols-&gt;imports</code> 应用子的结果蕴含的转发语义，这和 [R<sup>n</sup>RK] 不同。</p>
<p>　　检查 <code>&lt;environment&gt;</code> 可修改失败时的副作用和以上任一等效求值 <code>symbols-&gt;imports</code> 应用子的结果可能具有的副作用非决定性有序。</p>
<p><code>$import&amp;! &lt;environment&gt; &lt;symbol&gt;...</code></p>
<p>　　从指定的环境以引用绑定导入指定的符号。</p>
<p>　　同 <code>$import!</code> ，但以 <a href="#%E6%A0%87%E5%87%86%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>ensigil</code></a>的方式指定绑定的符号。</p>
<p><code>nonfoldable? &lt;list&gt;</code></p>
<p>　　判断参数是否不可被继续折叠映射：存在空列表。</p>
<p>　　参数是同 [R<sup>n</sup>RK] 的 <code>map</code> 操作可接受的列表参数或空列表，但排除<a href="#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">非真列表</a>。</p>
<p>　　若参数是空列表，结果是 <code>#f</code> 。</p>
<p><code>assq &lt;object&gt; &lt;lists&gt;</code></p>
<p>　　取关联列表中和参数的引用相同的元素。</p>
<p>　　第二参数指定的列表中的元素应为有序对。</p>
<p>　　以 <code>eq?</code> 依次判断第二参数指定的列表中的每个元素的第一个元素是否和第一参数指定的元素等价。</p>
<p>　　若不存在等价的元素，结果为空列表右值；否则是同 <code>first%</code> 访问得到的等价的列表的值。</p>
<p><strong>原理</strong></p>
<p>　　和 [R<sup>n</sup>RK] 不同，NPLA1 只支持<a href="#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8">真列表</a>，因此可以要求顺序，提供关于等价的元素的更强的保证。</p>
<p>　　尽管和 [R<sup>n</sup>RK] 相同而和 [R<sup>n</sup>RS] 不同，<a href="#%E6%8E%A7%E5%88%B6%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>&lt;test&gt;</code> 支持非布尔值</a>，不存在元素时的 <code>#f</code> 结果可以简化比较，但和 [R<sup>n</sup>RK] 的原理类似，这不利于提供清晰的<a href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型错误</a>，且没有如空列表值这样作为求值算法的特殊值的自然推论。使用空列表值和传统 Lisp 也一致。</p>
<p><strong>注释</strong></p>
<p>　　类似 [R<sup>n</sup>RK] 的同名应用子，但保证顺序且转发参数。</p>
<p>　　类似 [R<sup>n</sup>RS] 的同名过程，但失败的结果不是 <code>#f</code> 。</p>
<p><code>assv &lt;object&gt; &lt;lists&gt;</code></p>
<p>　　取关联列表中和参数的值相等的元素。</p>
<p>　　第二参数指定的列表中的元素应为有序对。</p>
<p>　　以 <code>eqv?</code> 依次判断第二参数指定的列表中的第一个元素是否和第一参数指定的元素等价。</p>
<p>　　若不存在等价的元素，结果为空列表右值；否则是同 <code>first%</code> 访问得到的等价的列表的值。</p>
<p><strong>原理</strong> 参见 <code>assq</code> 。</p>
<p><strong>注释</strong></p>
<p>　　类似 [R<sup>n</sup>RK] 的 <code>assoc</code> ，但使用 <code>eqv?</code> 而不是 <code>equal?</code> ，保证顺序且转发参数。</p>
<p>　　类似 [R<sup>n</sup>RS] 的 <code>assv</code> ，但失败的结果不是 <code>#f</code> 。</p>
<p><code>box &lt;object&gt;</code></p>
<p>　　装箱：构造参数对象经左值到右值转换的箱（类型为 <code>&lt;box&gt;</code> 的对象）。</p>
<p><code>box% &lt;object&gt;</code></p>
<p>　　同 <code>box</code> ，但参数不蕴含左值到右值转换，<a href="#%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%BB%93%E6%9E%9C%E5%8C%85%E5%90%AB%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AE%B9%E5%99%A8%E6%9E%84%E9%80%A0%E5%99%A8">在结果中保留参数的引用值</a>。</p>
<p><code>box? &lt;object&gt;</code></p>
<p>　　<code>&lt;box&gt;</code> 的<a href="#%E8%B0%93%E8%AF%8D%E5%90%8D%E7%A7%B0%E5%90%8E%E7%BC%80">类型谓词</a>。</p>
<p><code>unbox &lt;box&gt;</code></p>
<p>　　拆箱：从箱中还原对象。</p>
<p>　　作为<a href="#%E5%87%BD%E6%95%B0%E5%80%BC%E8%BD%AC%E5%8F%91%E5%87%BD%E6%95%B0">函数值转发操作</a>，保留引用值。</p>
<p><strong>注释</strong></p>
<p>　　以上 4 个函数除<a href="#%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E7%BA%A6%E5%AE%9A">引用标记字符</a>对应处理引用值的差异外，功能和使用方式对应类似 <a href="https://srfi.schemers.org/srfi-111/srfi-111.html">[SRFI-111]</a> 的 3 个过程 <code>box</code> 、<code>box?</code> 和 <code>unbox</code> 。</p>
<p>　　<a href="#%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB">类型分区</a>使 <code>box?</code> 对 <code>&lt;list&gt;</code> 类型的参数的结果总是 <code>#f</code> 。若没有这个限制，不考虑<a href="#%E5%B0%81%E8%A3%85">封装性</a>时，用 <code>&lt;list&gt;</code> 的相关操作可整体替换进行功能等价的代替：<code>list</code> 、<code>list%</code> 和 <code>first</code> 可代替 <code>box</code> 、<code>box%</code> 和 <code>unbox</code> 。</p>
<p>　　和 <a href="http://community.schemewiki.org/?scheme-faq-language">关于 Scheme 的装箱的描述</a>不同，这样的代替不一定保证有更好的性能。</p>
<p>　　以上这些函数可使用 <a href="#%E5%B0%81%E8%A3%85%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>make-encapsulation-type</code></a>实现。</p>
<p>　　和 Scheme 等不同，箱具有被装箱对象的所有权，因此使用 <code>box%</code> 和 <code>unbox</code> 时，需注意保存被构造的箱或被箱中引用值引用的对象。</p>
<h3 id="标准派生特性"><a class="header" href="#标准派生特性">标准派生特性</a></h3>
<p>　　<em>标准派生特性(standard derived feature)</em> 同<a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">基本派生特性</a>，但其派生依赖<a href="#npla1-%E6%A0%B9%E7%8E%AF%E5%A2%83%E7%89%B9%E6%80%A7">标准库其它模块</a>。</p>
<p><code>ensigil &lt;symbol&gt;</code></p>
<p>　　修饰引用字符。</p>
<p>　　若参数非空且没有 <code>&amp;</code> 前缀，则结果是添加 <code>&amp;</code> 引用标记字符作为前缀的符号；否则是参数值。</p>
<p><code>$binds1? &lt;environment&gt; &lt;symbol&gt;</code></p>
<p>　　判断指定符号是否在指定表达式求值后指称的环境中绑定。</p>
<p><strong>注释</strong> 类似 [R<sup>n</sup>RK] 的 <code>$binds?</code> ，但只支持判断一个 <code>&lt;symbol&gt;</code> 操作数。</p>
<h3 id="核心库"><a class="header" href="#核心库">核心库</a></h3>
<p>　　<a href="#%E6%A0%87%E5%87%86%E5%BA%93">核心库</a>提供以下操作，即<em>核心库函数(core library function)</em> ：</p>
<p><code>map-reverse &lt;applicative&gt; &lt;list&gt;...</code></p>
<p>　　映射并反转结果。</p>
<p>　　参数 <code>&lt;applicative&gt;</code> 应满足以下要求，否则<a href="#npla1-%E9%94%99%E8%AF%AF">引起错误</a>：</p>
<ul>
<li><code>&lt;list&gt;...</code> 中的参数的元素数都相等。</li>
<li><code>&lt;list&gt;...</code> 中的参数的元素数量等于 <code>&lt;applicative&gt;</code> 接受的形式参数的元数。</li>
</ul>
<p><strong>注释</strong> 类似 [R<sup>n</sup>RK] 的 <code>map</code> ，但支持空的 <code>&lt;list&gt;...</code> 且保证顺序。</p>
<p><code>for-each-ltr &lt;applicative&gt; &lt;list&gt;...</code></p>
<p>　　从左到右映射取副作用。</p>
<p><strong>注释</strong> 类似 [R<sup>n</sup>RK] 的 <code>for-each</code> ，但支持空的 <code>&lt;list&gt;</code> 且保证顺序。</p>
<h1 id="npla1-参照实现扩展环境"><a class="header" href="#npla1-参照实现扩展环境">NPLA1 参照实现扩展环境</a></h1>
<p>　　类似 <a href="#npla1-%E6%A0%B9%E7%8E%AF%E5%A2%83%E7%89%B9%E6%80%A7">NPLA1 根环境特性</a>，NPLA1 以<a href="#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">根环境</a>的形式提供其它一些<a href="#%E6%A8%A1%E5%9D%97">模块</a>的操作，但默认不以根环境中的绑定而是以其中的<a href="#%E6%A8%A1%E5%9D%97">环境子对象</a>中的绑定提供。</p>
<p>　　除非另行指定，这些环境子对象作为<a href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">库特性</a>的一部分时，是以 <code>std.</code> 为前缀的名称命名的<a href="#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">库环境</a>。</p>
<p>　　除非派生实现另行指定，这些模块都应被提供。</p>
<p>　　这些模块和 <a href="#npla1-%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83">NPLA1 参照实现环境</a>提供的特性一同构成<a href="#%E6%A0%87%E5%87%86%E5%BA%93">标准库</a>。</p>
<p>　　除非派生实现定义，每个标准库模块都不是可选的。否则，作为被加载的模块的环境的名称由派生实现定义。</p>
<p>　　<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改</a>这些环境的程序<a href="#npla1-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">行为未定义</a>。</p>
<p>　　默认加载使用 <code>.</code> 分隔标识符得到的符号作为名称。</p>
<p>　　加载的模块依赖<a href="#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">初始化的根环境</a>。</p>
<p>　　当前实现中部分加载的环境依赖之前加载的环境，这些环境的名称是固定的。用户程序需要保证这些环境在加载时的静态环境中可用。</p>
<p>　　在调用其中的合并子时，可能求值符号引用依赖的环境。其中的环境可能在求值定义时不依赖而不作为对应的本机 API 的前置条件。</p>
<p>　　环境是否具有依赖的环境的绑定绑定是未指定的。</p>
<p>　　用户程序需保持加载为环境的模块具有适当的<a href="#%E7%8E%AF%E5%A2%83%E7%94%9F%E5%AD%98%E6%9C%9F">生存期</a>，以避免其中的<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">合并子调用</a>引起未定义行为。</p>
<p>　　本章的特性可使用<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">本机实现</a>或<a href="#%E5%AE%9E%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%BA%A6%E5%AE%9A">非本机的派生实现</a>，分别符合<a href="#%E6%A0%B9%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7">根环境基本特性</a>和<a href="#%E5%9F%BA%E7%A1%80%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">基础派生特性</a>的规则。具体使用何种实现是未指定的。</p>
<p>　　派生实现可定义更具体的实现要求，以便<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>的兼容性。</p>
<p><strong>原理</strong></p>
<p>　　这些绑定不需要被直接引入<a href="#npla1-%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96">基础上下文</a>的根环境中，因为：</p>
<ul>
<li>同时满足以下关于接口依赖的约束，而不必要以<a href="#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">基础环境</a>可访问的名称提供：
<ul>
<li>它们不是使用<a href="#%E6%A8%A1%E5%9D%97">作为环境的模块</a>时被依赖的主要操作。
<ul>
<li>为了使用非根环境的模块，需要绑定在根环境的函数引入其中的绑定。这样的接口应在根环境中提供而保证默认可访问，避免引入绑定这样的功能的在逻辑上的循环依赖。</li>
<li><strong>注释</strong> 这样的操作如 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>$import!</code></a>。</li>
</ul>
</li>
<li>它们不被<a href="#npla1-%E6%A0%B9%E7%8E%AF%E5%A2%83%E7%89%B9%E6%80%A7">根环境特性</a>的在接口意义上依赖。
<ul>
<li><strong>注释</strong> 在实现上仍可选依赖，参见<a href="#%E6%A0%87%E5%87%86%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">标准派生特性</a>。</li>
</ul>
</li>
</ul>
</li>
<li>接口的功能不对一般的实体具有足够普遍性，而不需要以基础环境默认可访问的名称提供。</li>
</ul>
<p>　　判定上述的足够普遍性的具体规则包括：</p>
<ul>
<li>普遍性以实体类型体现为接口的功能对非特定类型的对象适用，最终不依赖具有更特定的类型特有的性质。
<ul>
<li><strong>注释</strong> 一般的实体作为一等对象，即具有 <a href="#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;object&gt;</code></a>的值。<code>&lt;object&gt;</code> 是足够普遍的类型。</li>
<li><strong>注释</strong> <a href="#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;reference&gt;</code></a>和 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>&lt;box&gt;</code></a>等由 <code>&lt;object&gt;</code> 构造的值最终依赖 <code>&lt;object&gt;</code> 的值，而非其它更特定类型特有的性质。</li>
</ul>
</li>
<li>在<a href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95">求值算法</a>中出现决定具体步骤的具体实体类型，被认为是足够普遍的。
<ul>
<li><strong>注释</strong> 这包括 <a href="#%E6%9C%AA%E6%B1%82%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;symbol&gt;</code></a>、<a href="#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;list&gt;</code></a>和 <a href="#%E6%9C%AA%E6%B1%82%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;combiner&gt;</code></a>及其<a href="#%E6%9C%AA%E6%B1%82%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">子类型</a>。</li>
<li><strong>注释</strong> <a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B"><code>&lt;number&gt;</code></a>或 <a href="#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><code>&lt;string&gt;</code></a>等其它比 <code>&lt;object&gt;</code> 更具体类型的值不在此列。</li>
</ul>
</li>
<li>若接口的功能仅依赖比一般的实体更具体的特定类型的值，则不以基础环境默认可访问的名称提供。
<ul>
<li><strong>注释</strong> 功能上的依赖包含区分这些特定类型的值，如<a href="#%E8%B0%93%E8%AF%8D%E5%90%8D%E7%A7%B0%E5%90%8E%E7%BC%80">类型谓词</a>。</li>
</ul>
</li>
<li>接口的功能描述涉及的类型的足够普遍性对以基础环境默认可访问的名称提供是必要非充分条件。
<ul>
<li>这些类型仅决定接口功能的一部分。</li>
<li><strong>注释</strong> 若接口的功能仅依赖足够普遍的类型，但功能不足以涵盖它的任何的<a href="#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>或者值，也可在参照实现扩展环境中提供。</li>
<li><strong>注释</strong> 一个主要特例：足够普遍的具体类型的类型谓词涵盖所有值，因此类型的足够普遍性可直接作为对应的类型谓词的足够普遍性的充分必要条件。</li>
</ul>
</li>
</ul>
<p>　　具有足够普遍性而应在根环境而非参照实现扩展环境提供的操作具体包括以下几类：</p>
<ul>
<li>创建非特定的不同<a href="#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7">名义类型</a>的对象使用的普遍机制的主要操作。
<ul>
<li><strong>注释</strong> 使用 <a href="#%E5%B0%81%E8%A3%85%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>make-encapsulation-type</code></a>可创建不同名义类型。</li>
</ul>
</li>
<li>不改变一般的实体可能蕴含的<a href="#%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7">对象同一性</a>而同时附加非特定<a href="#%E4%BD%9C%E7%94%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99">种类</a>的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>的操作。
<ul>
<li>同一性是所有对象的属性。显示同一性不依赖具体副作用的种类，因此要求特定种类的接口削弱普遍性。另见<a href="#%E5%8F%AF%E5%8F%98%E7%8A%B6%E6%80%81%E5%92%8C%E6%99%AE%E9%81%8D%E6%80%A7">可变状态和普遍性</a>。</li>
<li><strong>注释</strong> 根环境中这样的操作如 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>box%</code> 和 <code>unbox</code></a>。</li>
</ul>
</li>
<li>不依赖特定对象类型，直接引入副作用的操作。
<ul>
<li>因为引入副作用可能是接口的关键功能及主要目的，此处的普遍性不限制非特定种类。</li>
<li><strong>注释</strong> 仅具有控制作用为副作用的操作仍被视为是普遍的。因此，可具有<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制作用</a>的 <a href="#%E6%8E%A7%E5%88%B6%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><code>$if</code></a>等函数仍在根环境中提供。</li>
<li><strong>注释</strong> 依赖<a href="#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">一等续延</a>的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制作用</a>因续延类型而不视为足够普遍，因此根环境不直接提供一等续延关联的操作。</li>
</ul>
</li>
</ul>
<p>　　在此基础上，这些绑定被设计为<a href="#npla1-%E7%8E%AF%E5%A2%83">环境子对象</a>提供的<a href="#%E6%A8%A1%E5%9D%97">子模块</a>，因为以下的一个或多个原因：</p>
<ul>
<li>它们可能具有非全局含义的名称而更适合隔离在不同<a href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">命名空间</a>中以避免使用时的歧义。</li>
<li>它们可能仅关注（如作为操作的参数或返回类型）特定的<a href="#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0">求值得到的操作数</a>类型。</li>
<li>它们中的每一个模块具有足够或内聚性而不和其它子模块耦合，且绑定提供的实体关注相同的功能集合，适合被派生实现直接配置为可选的(#根环境基本特性)特性分组。</li>
<li>允许实现使用特殊的环境子类型<a href="#%E6%A8%A1%E5%9D%97">延迟加载</a>。
<ul>
<li><strong>注释</strong> 当前 NPLA1 没有提供支持。</li>
</ul>
</li>
</ul>
<p><strong>注释</strong></p>
<p>　　类似<a href="#npla1-%E6%A0%B9%E7%8E%AF%E5%A2%83%E7%89%B9%E6%80%A7">根环境特性</a>，一些特性可<a href="#npla1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80">约定处理的值的宿主类型</a>。</p>
<p>　　使用 <code>.</code> 分隔标识符得到的符号类似 <a href="http://wiki.call-cc.org/eggref/4/r7rs#import">CHICKEN Scheme 的转换 R7RS 的标准模块名</a>。</p>
<h2 id="续延库"><a class="header" href="#续延库">续延库</a></h2>
<p>　　提供<a href="#%E7%BB%AD%E5%BB%B6">续延</a>支持。</p>
<p>　　默认加载为根环境下的 <code>std.continuations</code> 环境。</p>
<p><strong>模块约定：</strong></p>
<p>　　本节约定以下求值得到的操作数：</p>
<ul>
<li><code>&lt;continuation&gt;</code> ：<a href="#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">一等续延</a>。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　类似 Kernel 语言，NPLA1 续延不是合并子。这一设计的基本原理参见 [R<sup>n</sup>RK] §7（以及<a href="#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延的捕获和调用</a>），但理由不充分。更完整的分析如下：</p>
<ul>
<li>使用<em>守卫选择子(guard selector)</em> 是 Kernel 的具体特性的设计，不是一般求值算法中蕴含需要实现的选项，因此仅在 [R<sup>n</sup>RK] 内部生效。
<ul>
<li>这和类似的其它机制（如 [R<sup>n</sup>RS] 的 <code>dynamic-wind</code> thunk ）事实上都同以下关于续延组合性的理由类似，不需要单独列出。</li>
</ul>
</li>
<li>如 [R<sup>n</sup>RK] ，一般的合并子确实无法保证作为续延的父续延(parent continuation) 。
<ul>
<li>[R<sup>n</sup>RK] 在此没有进一步明确：
<ul>
<li>一般的合并子无法作为父续延的原因是因为（作为函数）不保证能接受操作数。</li>
<li>父续延对续延组合（接受两个续延结果是和两者连续调用等效的续延）操作是必要的输入。</li>
<li>更一般地，即便不支持续延组合操作，在抽象机语义描述续延的捕获得到一等续延依赖这种语义（即便父续延不是一等对象）。
<ul>
<li>只要描述依赖可组合的求值算法，除了最后一个<a href="#%E7%BB%AD%E5%BB%B6">无界续延</a>，其它续延都对应可组合的求值步骤，因此这隐含续延的可组合性。</li>
</ul>
  <!-- markdownlint-disable-next-line MD034 -->
<ul>
<li>其它在求值算法以外的机制的描述也可能依赖这种组合性，如：https://docs.racket-lang.org/reference/eval-model.html#(part._mark-model) 。</li>
<li>最后一个无界续延可不考虑可组合性。但只要它不是唯一的，为作为一等续延被直接捕获和调用，它仍应当接受程序指定的操作数。
<ul>
<li>仅当这个续延唯一时可不提供单独的续延类型。
<ul>
<li>此时，这个续延被隐含而不当作一等续延，其中的操作数直接通过非续延的函数直接表示，如 [ISO C] 标准库的 <code>exit</code> 函数。</li>
<li>然而这样的设计要求其它续延是可组合的，否则根本不支持一等续延。</li>
</ul>
</li>
<li>可组合续延时，这个唯一的续延会被这作为被组合的其它续延的公共后缀。
<ul>
<li>此时仍然需要支持指定操作数，以便最后一个续延能表现程序指定的不同行为；否则，显式提供这样的续延缺少实际意义。</li>
</ul>
</li>
<li>[R<sup>n</sup>RK] 要求 <code>root-continuation</code> 和 <code>error-continuation</code> 这两个不同的一等无界续延能作为后缀，因此不是唯一的。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>所以，为符合<a href="#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a>，一般的合并子不是续延的<a href="#%E7%B1%BB%E5%9E%8B%E5%BA%8F">子类型</a>。</li>
</ul>
</li>
<li>因为<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">包装</a>是独立在具体合并子类型外的操作，[R<sup>n</sup>RK] 说明了一般续延不应作为应用子的子类型，而这并没有有效说明续延无法作为<a href="#%E5%90%88%E5%B9%B6%E5%AD%90">操作子</a>的子类型。</li>
<li>一些观点认为无界续延不能作为函数。但这实际依赖具体对象语言的规则，同样无法说明一般的续延无法作为操作子的子类型。
<ul>
<li>典型的分析如<a href="https://okmij.org/ftp/continuations/undelimited.html#introduction">参见这里</a>。</li>
<li>这仅论述了<a href="#%E7%BB%AD%E5%BB%B6">续延界限</a>和续延（调用）的某种可组合性(composablility) 的要求之间的关系。
<ul>
<li>特别地，此处的可组合性局限于取得函数值。</li>
</ul>
</li>
<li>因为这种可组合性的限制，这隐含一个前提：函数不能不返回。这对一般的<a href="#%E5%87%BD%E6%95%B0">函数</a>并不成立，因为一般的函数允许存在副作用，这种副作用不一定局限于蕴含此处可组合的<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">控制作用</a>。</li>
<li>在类型系统中，不返回的函数仍可能是<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">良型的</a>，因为<a href="#%E7%B1%BB%E5%9E%8B%E7%A7%8D%E7%B1%BB">函数类型的构造器</a>是否接受<a href="#%E7%B1%BB%E5%9E%8B%E8%BE%B9%E7%95%8C%E5%85%83%E7%B4%A0">空类型</a>和具体类型系统的设计相关。
<ul>
<li>类型系统规则能保证编码可组合的函数的机制是确保语法上可构造可组合的嵌套函数调用（函数值可作为另一个函数的实际参数），以此构成传统数学函数复合的自然扩展，并保证作用可复合，但这不保证函数值可复合。
<ul>
<li>对总是不返回的函数，非终止(non-terminization) 是其作为后缀的一种单一副作用，吸收(absorb) 任何返回函数值的这一计算作用。这破坏函数调用具有返回值的预期，但并非在作用上不可组合。</li>
</ul>
</li>
<li>事实上，不提供一等控制作用机制的语言也可能允许这种类型规则。
<ul>
<li>如 [ISO C] 的 <code>_Noreturn</code> 函数实质上返回类型就是空类型（因为没有任何值可作为<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>的<a href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6">居留</a>），尽管 C 的类型系统编码中 <code>_Noreturn</code> 函数返回类型并不唯一（返回类型这在转换等其它类型检查中仍然有效）且空类型不被检查（违反 _Noreturn 约束是未定义行为）而可能显得不典型。</li>
<li><strong>注释</strong> [ISO C] 仅提供 <code>setjmp</code>/<code>longjmp</code> 改变通常的控制状态。此外，[ISO C++] 的类似的 <code>[[noreturn]]</code> 用于标注总是抛出异常的函数，而提供异常的（替代）实现是一等控制操作符的一个典型使用场景。</li>
</ul>
</li>
</ul>
</li>
<li>根本地，使用这种值而非一般计算作用的可组合性定义的理由，仅来自某种描述语言规则的元语言上推理的要求或约定。
<ul>
<li><strong>注释</strong> 例如，为了便于使用等式理论(equational theory) 进行推理，证明被描述的对象语言总是符合某种静态的性质。</li>
<li>一般地，基于目的的不确定性，元语言不总是遵循这种约定。</li>
<li>对象语言更没有必要遵循这种约定，因为这蕴含对对象语言功能完整性的任意地、不必要的限制。</li>
<li>避免非预期的终止性可很容易通过对维护外部语言实现环境的运行时的互操作实现：添加一个破坏维护非终止的运行时条件的操作（例如，撤除硬件电源），即便需要按某种方式保留运行时状态，通常仍远远比提供静态的证明更容易。</li>
<li>此外，不论对象语言是否有必要表达，普遍的组合性不总是有益的，自身可能不被预期。
<ul>
<li>易于排除非终止这种计算作用的实现方法，正好是得益于语言实现和外部系统之间的计算作用不能自发维持组合性的直接应用。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>实际决定对象语言中区分续延和合并子（且续延明确不使用合并子表示）的设计有不同的其它理由：
<ul>
<li>求值算法对合并子的处理决定合并子对<a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%9D%A1%E4%BB%B6">非正常控制</a>透明。作为引入非正常控制的机制，续延调用和遵循 <a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">β-规约</a>的合并子调用具有不同来源的语义规则，即便后者在元语言中可能实现前者。
<ul>
<li>因此，是否把续延表示为传统的过程或合并子等其它蕴含 β-规约的实体是实现细节。抽象上，这支持保持续延的表示不透明而和合并子相互独立。</li>
<li>对一等续延相关的控制操作的一种一般的语义描述参见<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.72.8645&amp;rep=rep1&amp;type=pdf">这里</a>。</li>
</ul>
</li>
<li>避免把续延作为合并子还有语用因素。具体地，续延调用通常使用<a href="#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">续延应用</a>的形式，而非操作子调用。续延应用不直接复用<a href="#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6">函数合并</a>的语法。
<ul>
<li>以操作子的方式类似进行续延调用可能依赖对象的内部表示而暴露不必要公开的抽象，并不常用，也并不被当前语言普遍支持。
<ul>
<li><strong>注释</strong> 大多数语言根本不支持操作子。</li>
<li>但禁用这种调用，在一等续延的调用规则中添加偶然耦合，阻碍功能<a href="#%E5%AE%8C%E6%95%B4%E6%80%A7">完整性</a>和设计的<a href="#%E7%AE%80%E5%8D%95%E6%80%A7">简单性</a> 。</li>
</ul>
</li>
<li>考虑到捕获的一等续延通过变量绑定提供，因为合并子不是应用子的子类型，若一等续延是合并子，只能是指称操作子的变量。
<ul>
<li>于是，程序中的续延应用总是要求对其包装后使用。</li>
<li>这种设计使程序的实现和简单性冲突，并违反多个<a href="#%E7%BB%93%E6%9E%84%E5%92%8C%E4%BE%9D%E8%B5%96%E5%8E%9F%E5%88%99">结构设计规则</a>，而削弱提供这些绑定的续延捕获特性的<a href="#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>。</li>
</ul>
</li>
<li>因此，一般的续延不是应用子的子类型，程序中一等续延的应用需转换续延为应用子。</li>
<li>推论：一般的续延不是合并子的子类型。</li>
</ul>
</li>
</ul>
</li>
<li>综上，结合以上合并子不是续延的子类型以及续延不是合并子的子类型，一般的续延和合并子类型是正交的。
<ul>
<li>但<a href="#%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB">和 [R<sup>n</sup>RK] 要求的类型分区不同</a>，派生实现仍可能提供同时是某个合并子的<a href="#%E7%B1%BB%E5%9E%8B%E5%BA%8F">严格子类型</a>的续延。</li>
</ul>
</li>
</ul>
<p>　　NPLA1 首先提供关于一等续延而不是<a href="#%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E7%9A%84%E8%AE%A1%E7%AE%97%E9%A1%BA%E5%BA%8F">一等协程</a>的控制操作，因为：</p>
<ul>
<li>协程要求支持具有更多的原语，包括基于（而非并行于）一般的例程的创建操作（<a href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0">构造器</a>）。</li>
<li>具有相等的一等协程的内部表示逻辑上更加复杂（总是涉及可变状态），即便具体实现并不一定更复杂（和内部表示相关）。</li>
<li>使用非对称协程派生对称协程比使用<a href="#%E7%BB%AD%E5%BB%B6">有界续延</a>派生无界续延在逻辑上依赖暴露更多的细节，如包含分支的跳板循环。</li>
</ul>
<p>　　尽管逻辑上有界续延能不依赖其它<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">副作用</a>而表达状态，提供有界续延或无界续延作为原语的差异相对次要，因为：</p>
<ul>
<li>NPLA1 不是<a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">纯函数式语言</a>而支持<a href="#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81">一等状态</a>在内的基本设计，在实现中不需要排除可变状态。</li>
<li>NPLA1 不提供特设的和续延并行的<a href="#%E5%BC%82%E5%B8%B8">异常</a>或者其它替代的<a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%9D%A1%E4%BB%B6">非正常控制</a>机制，而不具有<a href="https://okmij.org/ftp/continuations/undelimited.html#delim-vs-undelim">控制作用之间的互操作难以组合的问题</a>。
<ul>
<li>异常基于续延提供，能确保可预测的互操作行为，尽管在基本操作中仍然可能使用异常作为实现。</li>
<li>这类似 <a href="https://docs.racket-lang.org/reference/eval-model.html#(part._exn-model)">[Racket] 的“异常是派生的概念”的描述</a>，但 NPLA1 异常并非如 [Racket] 内建，因为<a href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">抛出异常</a>只是<a href="#npla1-%E9%94%99%E8%AF%AF">引起错误</a>的实现，而不是接口要求。</li>
</ul>
</li>
<li>尽管逻辑上引入<a href="#%E7%BB%AD%E5%BB%B6">续延界限</a>可能是有益的，且有微妙的语义上的效果，这并没有简化用户程序和语言实现，因此当前不要求。
<ul>
<li>当前不支持<a href="#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">多次续延</a>和续延复制。
<ul>
<li>当续延仅在同一个上下文中捕获时，缺少续延界限不会是一个明显的问题，因为被调用的续延总是会重新引入共享的子续延。</li>
</ul>
</li>
<li>一些当前语言设计在 [R<sup>n</sup>RS] 的操作上扩展了界限。
<ul>
<li>例如，不同于 [R<sup>n</sup>RS] ，<a href="https://docs.racket-lang.org/reference/cont.html#(def._((quote._~23~25kernel)._call-with-current-continuation))">[Racket] 的 <code>call/cc</code> 也检查提示(prompt) 的存在</a>。</li>
</ul>
</li>
<li>缺少续延界限可能引起控制操作符关联的一些模型之间的语义不等价问题而<a href="http://ix.cs.uoregon.edu/~ariola/tpdc11.pdf">难以使用其中的一种严格准确地表达其中的另一种</a>。
<ul>
<li>在 SML/NJ 等语言中，因为不存在顶层的续延界限，这些问题容易成为在程序中真正阻碍使用有界续延的困难。</li>
<li>在 [R<sup>n</sup>RK] ，正常程序运行的顶层续延界限以 <code>root-continuation</code> 提供。此外，提供 <code>error-continuation</code> 处理错误。</li>
<li>在完善的设计中，提供一个顶层的续延界限并非困难。因此，可能缺少取得续延界限的方法的问题不是核心困难。此外，如 [R<sup>n</sup>RK] 的 <code>error-continuation</code> 显示了其它类似的续延的实用性。
<ul>
<li>类似的特性可能会被加入此处的设计中。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>注释</strong></p>
<p>　　类似 [R<sup>n</sup>RK] 而和 [R<sup>n</sup>RS] 不同，续延具有单独的类型，续延应用也不是蕴含过程调用的函数应用。</p>
<p><strong>操作：</strong></p>
<p><code>call/1cc &lt;combiner&gt;</code></p>
<p>　　捕获<a href="#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">一次续延</a>，<a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">具现</a>为一等续延作为参数调用合并子。</p>
<p>　　续延首先在<a href="#%E5%B0%BE%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BA%A6%E5%AE%9A">尾上下文中</a>被<a href="#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F">按引用捕获</a>，再作为操作数，调用 <code>&lt;combiner&gt;</code> 。</p>
<p>　　来自同一具现的一次续延的任何副本只允许一次显式（续延应用）或者隐式（如被函数调用的返回蕴含）地成功调用；否则，调用被<a href="#%CE%BB-%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">重入</a>，<a href="#npla1-%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　捕获的续延之后允许被复制。</p>
<p><strong>注释</strong></p>
<p>　　<code>call1/cc</code> 的名称<a href="https://legacy.cs.indiana.edu/~dyb/pubs/call1cc.pdf">来源</a>同 Chez Scheme 。</p>
<p><code>continuation-&gt;applicative &lt;continuation&gt;</code></p>
<p>　　转换续延为<a href="#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8">关联的等效</a>应用子。</p>
<p>　　结果是转换的 <code>&lt;applicative&gt;</code> 类型的值。</p>
<p>　　在构造结果时，<code>&lt;continuation&gt;</code> 被转发。</p>
<p>　　结果的底层合并子被调用时，传递操作数树给 <code>&lt;continuation&gt;</code> 。</p>
<p><code>apply-continuation &lt;continuation&gt; &lt;object&gt;</code></p>
<p>　　应用续延。</p>
<p>　　以第二参数作为参数，以 <code>apply</code> 应用第一参数指定的续延转换的应用子。</p>
<p><strong>原理</strong></p>
<p>　　同 [R<sup>n</sup>RK] ，<code>apply-continuation</code> 不接受可选的环境，因为非正常控制忽略动态环境。</p>
<p><strong>注释</strong></p>
<p>　　即同求值：<code>apply (continuation-&gt;applicative &lt;continuation&gt;) &lt;object&gt;</code> 。</p>
<p>　　<code>apply-continuation</code> 同 [R<sup>n</sup>RK] 。取得非 <code>&lt;list&gt;</code> 结果依赖 <code>apply</code> 对 <code>&lt;pair&gt;</code> 的支持，这在 Scheme 中无法实现。</p>
<h2 id="代理求值"><a class="header" href="#代理求值">代理求值</a></h2>
<p>　　代理求值支持保存求值为代理对象以实现延迟求值。</p>
<p>　　默认加载为根环境下的 <code>std.promises</code> 环境。</p>
<p><strong>模块约定：</strong></p>
<p>　　本节约定以下求值得到的操作数：</p>
<ul>
<li><code>&lt;promise&gt;</code> ：求值代理：表示可被求值而取得<a href="#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">结果对象</a>的对象。
<ul>
<li>保存待求值的表达式和这个表达式<a href="#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83">求值时的动态环境</a>，或已求值的结果对象。</li>
</ul>
</li>
</ul>
<p><strong>原理</strong></p>
<p>　　代理求值的原语可实现惰性求值和透明的记忆化。</p>
<p>　　和一些流行的误解不同，尽管这些原语的原始设计是关于并行处理的，这不必然蕴含并发的投机执行(speculative execution) ，只是因为解析(resolve) 内部状态并不在用户程序中可见，而蕴含必要的最小同步。</p>
<p>　　由于<a href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C">当前语言不支持并发访问</a>，即使对 <code>&lt;promise&gt;</code> 的<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">修改操作</a>导致变化，在语言中其状态也不可见，没有要求支持这种同步；未来可能会附加要求以提供更完善的并发支持。</p>
<p>　　关于 <a href="../Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 的设计，参见 [R<sup>n</sup>RK] §9 和 <a href="https://srfi.schemers.org/srfi-45/srfi-45.html">[SRFI-45]</a> 。</p>
<p><strong>注释</strong></p>
<p>　　在 <code>&lt;promise&gt;</code> 上的<a href="#npla-%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE">并发访问</a>并不具有特别的同步保证和要求。并发访问<a href="#npla1-%E7%A8%8B%E5%BA%8F%E5%A4%96%E9%83%A8%E7%8E%AF%E5%A2%83">可引起宿主语言的未定义行为</a>。</p>
<p>　　除 <code>$lazy/d</code> 外，同 [R<sup>n</sup>RK] 的 promises 模块。</p>
<p>　　和 [R<sup>n</sup>RK] 不同，通过 <code>force</code> 引起 <code>&lt;promise&gt;</code> 对象的求值可能修改这个对象自身而使其中的状态失效（如通过 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>assign!</code></a>对这个对象赋值）。</p>
<p>　　因此，实现中需要重新访问状态，而重新进行类型检查。</p>
<p><strong>操作：</strong></p>
<p><code>promise? &lt;object&gt;</code></p>
<p>　　<code>&lt;promise&gt;</code> 的<a href="#%E8%B0%93%E8%AF%8D%E5%90%8D%E7%A7%B0%E5%90%8E%E7%BC%80">类型谓词</a>。</p>
<p><code>memoize &lt;object&gt;</code></p>
<p>　　记忆化求值：以参数作为已被求值的结果创建 <code>&lt;promise&gt;</code> 对象。</p>
<p>　　<a href="#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E7%BA%A6%E5%AE%9A">在结果中保留参数的引用值</a>。</p>
<p><code>$lazy &lt;body&gt;</code></p>
<p>　　惰性求值：以参数为待求值的表达式，以<a href="#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>作为这个表达式被求值的动态环境，创建 <code>&lt;promise&gt;</code> 对象。</p>
<p>　　当前环境的<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">环境弱引用</a>的副本被保存到结果。</p>
<p><code>$lazy% &lt;body&gt;</code></p>
<p>　　同 <code>$lazy</code> ，但保留引用值。</p>
<p><code>$lazy/d &lt;environment&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$lazy</code> ，但以参数指定环境替代动态环境。</p>
<p><code>$lazy/d% &lt;environment&gt; &lt;body&gt;</code></p>
<p>　　同 <code>$lazy%</code> ，但以参数指定环境替代动态环境。</p>
<p>　　参数指定的一等环境值的副本被保存到结果。</p>
<p><code>force &lt;object&gt;</code></p>
<p>　　若参数是 <code>&lt;promise&gt;</code> 值，立即求值指定的 <code>&lt;promise&gt;</code> 对象，得到的结果对象作为结果；否则，<a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91">转发参数</a>作为结果。</p>
<p>　　若参数在求值时修改为非 <code>&lt;promise&gt;</code> 类型的值，需要继续迭代求值时，引起<a href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型错误</a>。</p>
<h2 id="数学库"><a class="header" href="#数学库">数学库</a></h2>
<p>　　数学库提供<a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">数值类型</a>的操作和其它数学功能。</p>
<p>　　默认加载为根环境下的 <code>std.math</code> 环境。</p>
<p><strong>模块约定：</strong></p>
<p>　　以下操作中：</p>
<ul>
<li>除非另行指定，对应的函数调用的求值是<a href="#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8">纯求值</a>。</li>
<li>涉及数值操作数的操作符合<a href="#%E6%95%B0%E5%80%BC%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">数值操作约定</a>。</li>
<li>所有除法和取余数的计算符合<a href="#%E9%99%A4%E6%B3%95%E7%BA%A6%E5%AE%9A">除法约定</a>。</li>
</ul>
<p><strong>原理</strong></p>
<p>关于比较操作：</p>
<p>　　同 [R<sup>n</sup>RK] 而不同于 [R<sup>5</sup>RS] 、[R<sup>6</sup>RS] 和 [R<sup>7</sup>RS] ，比较操作不明确要求传递性（但精确数仍然因真值的数学性质而保证传递性），以允许操作数存在不精确数时，转换不精确数 flonum 的简单实现。</p>
<p>　　[R<sup>6</sup>RS] 继承了 [R<sup>5</sup>RS] 要求过程 <code>=</code> 具有传递性（注释指出传统类 Lisp 语言的实现不要求），而 [R<sup>7</sup>RS] 的对应注释指出这不能通过把所有操作数都转换为不精确数实现。</p>
<p>　　不要求不精确数的传递性和除法约定对除数为不精确数 0 值的处理兼容。</p>
<p>　　不同的语言在此<a href="https://codewords.recurse.com/issues/one/when-is-equality-transitive-and-other-floating-point-curiosities">可能有不同的规则</a>，可见：</p>
<ul>
<li>一些现代 Lisp 语言可能满足（即便不是 Scheme 实现，如 SBCL ）或不满足（即便是 Scheme 实现的派生，如 Racket ）此要求。</li>
<li>一些语言的不同版本的实现可能使用不同的规则（如 Ruby 1.8.7 和 Ruby 2.0 ）。</li>
</ul>
<p>　　使用以上链接中的测试用例，可发现一些 [R<sup>n</sup>RS] 的实现实际可能不符合 <code>=</code> 的传递性要求，如 x86-64 Linux 上：</p>
<ul>
<li>Chez Scheme 9.5.6 、Chibi Scheme 0.10.0 和 Gauche 0.9.11 不符合要求。</li>
<li>Chicken 5.3.0 、Guile 2.2.7 和 Gambit 4.9.4 符合要求。</li>
</ul>
<p>　　上述符合性问题已在以下实现中报告并被修复：</p>
<ul>
<li><a href="https://github.com/ashinn/chibi-scheme/issues/812">Chibi Scheme issue 812</a></li>
<li><a href="https://github.com/cisco/ChezScheme/issues/606">Chez Scheme issue 606</a></li>
<li><a href="https://github.com/shirok/Gauche/issues/805">Gauche issue 805</a></li>
</ul>
<p><strong>注释</strong></p>
<p>　　和数值操作约定不同，幂等操作要求超过一次应用时，结果和参数的宿主类型也相同。</p>
<p><strong>操作：</strong></p>
<p><code>number? &lt;object&gt;</code></p>
<p>　　<code>&lt;number&gt;</code> 的<a href="#%E8%B0%93%E8%AF%8D%E5%90%8D%E7%A7%B0%E5%90%8E%E7%BC%80">类型谓词</a>。</p>
<p><code>complex? &lt;object&gt;</code></p>
<p>　　<code>&lt;complex&gt;</code> 的类型谓词。</p>
<p><strong>注释</strong> 同 <code>number?</code> ，因为当前 <code>&lt;number&gt;</code> 值都是 <code>&lt;complex&gt;</code> 值。</p>
<p><code>real? &lt;object&gt;</code></p>
<p>　　<code>&lt;real&gt;</code> 的类型谓词。</p>
<p><strong>注释</strong> 同 <code>complex?</code> ，因为当前 <code>&lt;complex&gt;</code> 值都是 <code>&lt;real&gt;</code> 值。</p>
<p><code>rational? &lt;object&gt;</code></p>
<p>　　<code>&lt;rational&gt;</code> 的类型谓词。</p>
<p><strong>注释</strong> 当前实现仅需排除<a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">无限大和 NaN 值</a>。</p>
<p><code>integer? &lt;object&gt;</code></p>
<p>　　<code>&lt;integer&gt;</code> 的类型谓词。</p>
<p><code>exact-integer? &lt;object&gt;</code></p>
<p>　　判断参数是否为 <code>&lt;integer&gt;</code> 类型的<a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">精确数</a>对象。</p>
<p><code>fixnum? &lt;object&gt;</code></p>
<p>　　判断参数是否为 <a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">fixnum</a>对象。</p>
<p><code>flonum? &lt;object&gt;</code></p>
<p>　　判断参数是否为 <a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">flonum</a>对象。</p>
<p><code>exact? &lt;number&gt;</code></p>
<p>　　判断参数是否为精确数。</p>
<p><strong>注释</strong> 当前精确数都是 fixnum 。</p>
<p><code>inexact? &lt;number&gt;</code></p>
<p>　　判断参数是否为<a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">不精确数</a>。</p>
<p><strong>注释</strong> 当前不精确数都是 flonum 。</p>
<p><code>finite? &lt;number&gt;</code></p>
<p>　　判断参数是否为<a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">有限值</a>。</p>
<p><code>infinite? &lt;number&gt;</code></p>
<p>　　判断参数是否为无限大值。</p>
<p><code>nan? &lt;number&gt;</code></p>
<p>　　判断参数是否为 NaN 值。</p>
<p><code>=? &lt;number1&gt; &lt;number2&gt;</code></p>
<p>　　比较相等。</p>
<p><code>&lt;? &lt;real1&gt; &lt;real2&gt;</code></p>
<p>　　比较小于。</p>
<p><code>&gt;? &lt;real1&gt; &lt;real2&gt;</code></p>
<p>　　比较大于。</p>
<p><code>&lt;=? &lt;real1&gt; &lt;real2&gt;</code></p>
<p>　　比较小于等于。</p>
<p><code>&gt;=? &lt;real1&gt; &lt;real2&gt;</code></p>
<p>　　比较大于等于。</p>
<p><code>zero? &lt;number&gt;</code></p>
<p>　　判断参数是否为零值。</p>
<p><code>positive? &lt;real&gt;</code></p>
<p>　　判断参数是否为正数。</p>
<p><code>negative? &lt;real&gt;</code></p>
<p>　　判断参数是否为负数。</p>
<p><code>odd? &lt;real&gt;</code></p>
<p>　　判断参数是否为奇数。</p>
<p><code>even? &lt;real&gt;</code></p>
<p>　　判断参数是否为偶数。</p>
<p><code>max &lt;real1&gt; &lt;real2&gt;</code></p>
<p>　　计算参数中的最大值。</p>
<p><code>min &lt;real1&gt; &lt;real2&gt;</code></p>
<p>　　计算参数中的最小值。</p>
<p><code>add1 &lt;number&gt;</code></p>
<p>　　计算参数加 1 的值。</p>
<p><code>sub1 &lt;number&gt;</code></p>
<p>　　计算参数减 1 的值。</p>
<p><code>+ &lt;number1&gt; &lt;number2&gt;</code></p>
<p>　　加法：计算参数的和。</p>
<p><code>- &lt;number1&gt; &lt;number2&gt;</code></p>
<p>　　减法：计算参数的差。</p>
<p><code>* &lt;number1&gt; &lt;number2&gt;</code></p>
<p>　　乘法：计算参数的积。</p>
<p><code>/ &lt;number1&gt; &lt;number2&gt;</code></p>
<p>　　除法：计算参数的商。</p>
<p><code>abs &lt;real&gt;</code></p>
<p>　　计算参数的绝对值。</p>
<p>　　<code>abs</code> 是<a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5">幂等操作</a>。</p>
<p><strong>注释</strong> 同 [R<sup>n</sup>RS] 和 [R<sup>n</sup>RK] ，当前仅支持 <code>&lt;real&gt;</code> ，尽管数学上这对 <code>&lt;complex&gt;</code> 也有意义。</p>
<p><code>floor/ &lt;integer1&gt; &lt;integer2&gt;</code></p>
<p>　　数论除法：计算参数向下取整的整除的商和余数。</p>
<p><code>floor-quotient &lt;integer1&gt; &lt;integer2&gt;</code></p>
<p>　　数论除法：计算参数向下取整的整除的商。</p>
<p><code>floor-remainder &lt;integer1&gt; &lt;integer2&gt;</code></p>
<p>　　数论除法：计算参数向下取整的整除的余数。</p>
<p><code>truncate/ &lt;integer1&gt; &lt;integer2&gt;</code></p>
<p>　　数论除法：计算参数截断取整的整除的商和余数。</p>
<p><code>truncate-quotient &lt;integer1&gt; &lt;integer2&gt;</code></p>
<p>　　数论除法：计算参数截断取整的整除的商。</p>
<p><code>truncate-remainder &lt;integer1&gt; &lt;integer2&gt;</code></p>
<p>　　数论除法：计算参数截断取整的整除的余数。</p>
<p><code>inexact &lt;number&gt;</code></p>
<p>　　取和参数值最接近的不精确数：</p>
<ul>
<li>若参数是不精确数，则结果是参数值。</li>
<li>否则，若参数超过任意不精确数内部表示的有限值的范围，则结果是未指定宿主类型的对应符号的无限大值。</li>
<li>否则，若不存在和参数数值相等（以 <code>=?</code> 判断）的不精确数，则引起错误。</li>
<li>否则，结果是和参数数值相等的不精确数。</li>
</ul>
<p>　　<code>inexact</code> 是幂等操作。</p>
<p><strong>原理</strong></p>
<p>　　这里明确约定了<a href="#%E9%94%99%E8%AF%AF">错误条件</a>，这和 [R<sup>n</sup>RK] 及 [R<sup>n</sup>RS] 宽松地允许引起错误（也允许不引起<a href="#%E9%94%99%E8%AF%AF">要求诊断的错误</a>）不同。</p>
<p>　　允许返回无限大值使程序容易判断非预期值的原因。使用浮点数作为不精确数，无限大值的结果符合 [IEC 60559] 的定义。实际 [R<sup>n</sup>RS] 实现及 klisp 普遍使用这种实现。</p>
<p>　　对其它情形保证 <code>=?</code> 比较的后置条件允许用户定义严格相等的转换函数（通过对结果应用 <code>infinite?</code> 可发现并排除无限大值）。</p>
<p>　　典型实现中，当参数是 <a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">fixnum</a>值时，结果通常不超过不精确数能表示的范围，也不需要引起错误。</p>
<p><strong>注释</strong> 同 [R<sup>6</sup>RS] 和 [R<sup>7</sup>RS] 的同名过程，及 [R<sup>5</sup>RS] 的 <code>exact-&gt;inexact</code> ；因为当前实现不支持不是 <code>&lt;real&gt;</code> 的 <code>&lt;number&gt;</code> ，也同 [R<sup>n</sup>RK] 的 real-&gt;inexact 。关于 [R<sup>n</sup>RS] 中的命名，另见 <a href="https://small.r7rs.org/ticket/328/">R<sup>7</sup>RS ticket 328</a> 和 [R<sup>7</sup>RS] 的相关注释。</p>
<p><code>string-&gt;number &lt;string&gt;</code></p>
<p>　　转换字符串为数值。</p>
<p>　　若转换成功，结果是对应参数作为外部表示的数值。否则，结果是 <code>#f</code> 。</p>
<p>　　不因转换失败引起错误。</p>
<p>　　数值包括所有实现支持的值。</p>
<p><strong>注释</strong> 同 [R<sup>7</sup>RS] 的同名过程，但不支持附加的可选的进位制参数。</p>
<p><code>number-&gt;string &lt;number&gt;</code></p>
<p>　　转换数值为字符串。</p>
<p><strong>注释</strong> 同 [R<sup>7</sup>RS] 的同名过程，但不支持附加的可选的进位制参数且不因特定的参数值出错。</p>
<h3 id="除法约定"><a class="header" href="#除法约定">除法约定</a></h3>
<p>　　二元除法或者取余数的操作中，第一个参数是被除数，第二个参数是除数。</p>
<p>　　数论除法的结果中的数值具有整数类型。</p>
<p>　　当除数是不精确数 0 时：</p>
<ul>
<li>若被除数是非零有限数值或无限大值，则商的符号同被除数的符号。</li>
<li>否则，商的符号未指定。</li>
</ul>
<p>　　当被除数是不精确数时，若除数是精确数 0 ，则结果除符号外同除数是不精确数 0 的情形。</p>
<p>　　同时计算商和余数的操作的结果是商和余数构成的列表。</p>
<p><strong>原理</strong></p>
<p>　　Scheme 方言及实现中普遍存在不同的除零错误的条件。</p>
<p>　　[R<sup>5</sup>RS] 的过程 <code>/</code> 除以零的条件没有被明确约定。</p>
<p>　　[R<sup>6</sup>RS] 则明确要求过程 <code>/</code> 中：</p>
<ul>
<li>在所有参数为精确数，若除数存在零值时，引发条件类型为 <code>&amp;assertion</code> 的异常。</li>
<li>否则，以例子指定除数存在零值时的结果：
<ul>
<li>若被除数为非零有限数值，结果为符号同被除数的。</li>
<li>否则，结果为正的 NaN 值。</li>
</ul>
</li>
</ul>
<p>　　[R<sup>7</sup>RS] 中修订 [R<sup>5</sup>RS] 的过程 <code>/</code> 中存在精确数 0 作为除数的除法结果是错误，但这不要求引起错误。实现可以引起错误，或结果具有未指定的错误的值。</p>
<p>　　[R<sup>7</sup>RS] 实际维持 [R<sup>5</sup>RS] 的条件不变，而非 [R<sup>6</sup>RS] 附加更多的要求；参见 <a href="https://small.r7rs.org/ticket/367/">R<sup>7</sup>RS ticket 367</a> ，但其中关于 [R<sup>6</sup>RS] 实现可转换操作数为不精确数和其它操作一致有误，因为 [R<sup>6</sup>RS] 的过程 = 不能以此方式实现（参见以上关于比较操作的原理的讨论）。</p>
<p>　　不同的 Scheme 实现对零值的处理（包括除零错误的条件）另见<a href="https://small.r7rs.org/wiki/Zero/">这里</a> 。</p>
<p>　　[R<sup>n</sup>RK] 的合并子 <code>/</code> ，存在任意除数为零值则引起错误。</p>
<p>　　因为 [R<sup>n</sup>RK] 的不精确数是可选模块，不讨论除数的零值是否精确值而保持简单性是合理的。</p>
<p>　　[R<sup>n</sup>RS] 明确要求支持精确数和不精确数（存在不同的字面量），但是只有 [R<sup>6</sup>RS] 要求存在不精确值时的确切结果。</p>
<p>　　<a href="#npla-%E6%95%B0%E5%AD%A6%E5%8A%9F%E8%83%BD">NPLAMath</a>的数值操作约定和 [R<sup>7</sup>RS] 类似，但在此附加和 [R<sup>6</sup>RS] 类似的要求而覆盖数值操作约定，因为：</p>
<ul>
<li>不精确数 0 往往来自表示<a href="#%E6%95%B0%E5%80%BC%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">下溢</a>的计算结果，而不是精确的真值 0 ，因此数学上商应存在定义。
<ul>
<li>参见 <a href="https://people.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF">IEEE-754 的分析</a>。</li>
<li>另见<a href="https://stackoverflow.com/a/14684474">这里</a>。</li>
</ul>
</li>
<li>同 [R<sup>n</sup>RS] ，NPLAMath 支持的不精确数允许自然地定义除数为不精确数 0 时的结果：
<ul>
<li>NPLAMath 明确要求支持不精确数（而非 [R<sup>n</sup>RK] 作为可选的特性提供），能区分不精确数 0 和精确数 0 的不同结果。</li>
<li>NPLAMath 的不精确数 0 允许支持符号据此确定作为商的无限值的符号（而非 [R<sup>n</sup>RK] 无法区分符号而无法按数学定义确定极限值的符号）。</li>
</ul>
</li>
<li>这些规则允许更优化的实现：
<ul>
<li>避免要求实现检查特定的精确数（在此是精确数 0 ）的存在，而允许更简单高效的直接使用 <a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">flonum</a>内部操作的实现。</li>
<li>不在此转换不精确数到精确数，和当前实现<a href="#%E6%95%B0%E5%80%BC%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A">没有提供精确数可能替换计算结果中的不精确数的机制</a>具有更好的一致性。</li>
</ul>
</li>
<li>不存在 [R<sup>n</sup>RS] 需要关心继续使用 [R<sup>6</sup>RS] 规则的<a href="https://small.r7rs.org/ticket/367/">一些问题</a>：
<ul>
<li>在被除数和除数都存在零值时，没有同 [R<sup>6</sup>RS] 的 / 的例子要求结果的符号，逻辑上仍然能保持一致。</li>
<li>NPLA1 不需要考虑不完全支持不精确数的（不满足 [R<sup>n</sup>RS] 符合性）的实现的兼容性等问题。</li>
</ul>
</li>
</ul>
<p><strong>注释</strong></p>
<p>　　同 [R<sup>7</sup>RS] ，若被除数是零值，且除数不是精确数 0 ，计算结果可能是精确数 0 。但当前实现没有提供精确数替换计算结果中的这种机制。</p>
<p>　　NPLA1 <code>std.math</code> 中名称以 <code>floor</code> 和 <code>truncate*</code> 起始的函数的语义同 [R<sup>7</sup>RS] 的定义，要求参数是整数。一些 Scheme 实现不严格要求整数。</p>
<p>　　[R<sup>6</sup>RS] 的整除基本操作（过程 <code>div</code> 、<code>mod</code> 、<code>div0</code> 、<code>mod0</code> ）没有严格定义，仅通过例子说明一些差异，但明确不要求整数。</p>
<p>　　[R<sup>n</sup>RK] 的整除同 [R<sup>6</sup>RS] ，但描述和 [R<sup>6</sup>RS] 矛盾；klisp 实现行为同 [R<sup>6</sup>RS] 。</p>
<p>　　更一般的定义参见 <a href="https://srfi.schemers.org/srfi-141/srfi-141.html">[SRFI-141]</a> 和其它相关参考文献：</p>
<!-- markdownlint-capture -->
<!-- markdownlint-disable MD034 -->
<ul>
<li>http://dl.acm.org/citation.cfm?id=128862</li>
<li>http://people.csail.mit.edu/riastradh/tmp/division.txt</li>
<li>https://www.gnu.org/software/guile/manual/html_node/Arithmetic.html</li>
<li>https://github.com/johnwcowan/r7rs-work/blob/master/WG1Ballot3Results.md#185-add-sixth-centered-division-operator</li>
<li>https://wiki.call-cc.org/eggref/5/srfi-141</li>
</ul>
<!-- markdownlint-restore -->
<h2 id="字符串库"><a class="header" href="#字符串库">字符串库</a></h2>
<p>　　提供字符串和正则表达式的相关操作。</p>
<p>　　默认加载为根环境下的 <code>std.strings</code> 环境。</p>
<p><strong>模块约定：</strong></p>
<p>　　本节约定以下求值得到的操作数：</p>
<ul>
<li><code>&lt;regex&gt;</code> ：正则表达式。</li>
</ul>
<p>　　为提供<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">宿主语言互操作</a>支持，正则表达式以 <code>std::regex</code> 类型表示，实现保证可通过 <code>&lt;string&gt;</code> 对应的 <a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84"><code>string</code></a> 值初始化。</p>
<p>　　除非另行指定，以上所有正则表达式的操作使用 [ISO C++11] 指定的默认选项，即：</p>
<ul>
<li><code>std::regex_constants::ECMAScript</code> 。</li>
<li><code>std::regex_constants::match_default</code> 。</li>
<li><code>std::regex_constants::format_default</code> 。</li>
</ul>
<p><strong>操作：</strong></p>
<p><code>string? &lt;object&gt;</code></p>
<p>　　<code>&lt;string&gt;</code> 的<a href="#%E8%B0%93%E8%AF%8D%E5%90%8D%E7%A7%B0%E5%90%8E%E7%BC%80">类型谓词</a>。</p>
<p><code>++ &lt;string&gt;...</code></p>
<p>　　字符串串接。</p>
<p><code>string-empty? &lt;string&gt;</code></p>
<p>　　判断字符串是否为空。</p>
<p><strong>注释</strong> 同 <a href="https://srfi.schemers.org/srfi-152/srfi-152.html">[SRFI-152]</a> 的过程 <code>string-null?</code> 。</p>
<p><code>string&lt;- &lt;string1&gt; &lt;string2&gt;</code></p>
<p>　　字符串<a href="#%E8%B5%8B%E5%80%BC">赋值</a>。</p>
<p>　　以第二参数为源，修改第一参数指定的目标。</p>
<p><code>string-trim &lt;string1&gt;</code></p>
<p>　　删除字符串中指定的连续前缀空白符。</p>
<p>　　空白符是 C++ 字符串中 <code>" \n\r\t\v"</code> 的字符之一。</p>
<p><strong>注释</strong> 同 [SRFI-152] 的过程 <code>string-trim-both</code> ，但不支持可选参数，且默认指定的空白符不同。</p>
<p><code>string-trim-left &lt;string1&gt;</code></p>
<p>　　删除字符串中指定的连续后缀空白符。</p>
<p>　　空白符同 <code>string-trim</code> 中的定义。</p>
<p><strong>注释</strong> 同 [SRFI-152] 的过程 <code>string-trim</code> ，但不支持可选参数，且默认指定的空白符不同。</p>
<p><code>string-trim-right &lt;string1&gt;</code></p>
<p>　　删除字符串中指定的连续前缀和后缀空白符。</p>
<p>　　空白符同 <code>string-trim</code> 中的定义。</p>
<p><strong>注释</strong> 同 [SRFI-152] 的同名过程，但不支持可选参数，且默认指定的空白符不同。</p>
<p><code>string-prefix? &lt;string1&gt; &lt;string2&gt;</code></p>
<p>　　判断第一参数是否包含第二参数作为前缀子串。</p>
<p><strong>注释</strong> 同 [SRFI-152] 的同名过程，但不支持可选参数。</p>
<p><code>string-suffix? &lt;string1&gt; &lt;string2&gt;</code></p>
<p>　　判断第一参数是否包含第二参数作为后缀子串。</p>
<p><strong>注释</strong> 同 [SRFI-152] 的同名过程，但不支持可选参数。</p>
<p><code>string-contains? &lt;string1&gt; &lt;string2&gt;</code></p>
<p>　　判断第一参数是否包含第二参数作为子串。</p>
<p><strong>注释</strong></p>
<p>　　一个串总是包含相等的串。空串被任何串包含，且总是不包含任何非空串。</p>
<p>　　同 [SRFI-152] 的过程 <code>string-contains</code> ，但不支持可选参数，且结果是 <code>#t</code> 或 <code>#f</code> 。</p>
<p><code>string-contains-ci? &lt;string1&gt; &lt;string2&gt;</code></p>
<p>　　判断第一参数是否包含第二参数作为子串，忽略大小写。</p>
<p>　　只在单字节字符集内的字符中区分大小写。</p>
<p><strong>注释</strong> 除不区分大小写外同 <code>string-contains?</code> 。</p>
<p><code>string-split &lt;string1&gt; &lt;string2&gt;</code></p>
<p>　　取第二参数分隔第一参数得到的字符串的列表。</p>
<p><strong>注释</strong> 同 [SRFI-152] 的同名过程，但不支持可选参数。</p>
<p><code>string-&gt;symbol &lt;string&gt;</code></p>
<p>　　转换字符串为符号。</p>
<p><code>symbol-&gt;string &lt;symbol&gt;</code></p>
<p>　　转换符号为字符串。</p>
<p>　　不检查值是否符合符号要求。</p>
<p><code>string-&gt;regex &lt;string&gt;</code></p>
<p>　　转换字符串为以这个字符串作为串的正则表达式。</p>
<p>　　若正则表达式无效，则<a href="#npla1-%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p><code>regex-match? &lt;string&gt; &lt;regex&gt;</code></p>
<p>　　判断字符串中是否匹配正则表达式的模式串。</p>
<p>　　若 <code>&lt;string&gt;</code> 匹配 <code>&lt;regex&gt;</code> 指定的模式串，结果是 <code>#t</code> ，否则结果是 <code>#f</code> 。</p>
<p><code>regex-replace &lt;string1&gt; &lt;regex&gt; &lt;string2&gt;</code></p>
<p>　　替换字符串中的模式串，构造新字符串。</p>
<p>　　在 <code>&lt;string1&gt;</code> 的副本中搜索正则表达式指定的模式串的所有匹配，替换为 <code>&lt;string2&gt;</code> 指定的格式字符串。</p>
<p>　　结果是替换后的字符串。</p>
<p><strong>注释</strong></p>
<p>　　当前实现不处理实现抛出的 <code>std::regex_error</code> 异常。</p>
<h2 id="输入输出库"><a class="header" href="#输入输出库">输入/输出库</a></h2>
<p>　　提供输入/输出操作。</p>
<p>　　默认加载为根环境下的 <code>std.io</code> 环境。</p>
<p><strong>模块约定：</strong></p>
<p>　　文件系统中创建或移除项的函数的<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>是表示操作是否成功的 <code>&lt;bool&gt;</code> 值。</p>
<p>　　除非另行指定：</p>
<ul>
<li>对创建目录的操作，在若目录已存在，则视为操作失败且无作用；否则，若创建失败，则<a href="#npla1-%E9%94%99%E8%AF%AF">引起错误</a>。</li>
<li>对创建多个目录的操作，仅在所有目录都创建成功时操作成功。操作失败可能仍存在部分目录被创建成功。</li>
<li>对访问文件的操作，若读或写失败，则引起错误。</li>
<li>对访问文件系统路径的操作，除非另行指定，若<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">实现环境</a>支持跟随文件系统对象的链接，隐含跟随链接（即解析指定链接的文件系统路径到最终的非链接对象作为路径指定的资源）。
<ul>
<li>解析链接可能引起错误。</li>
<li><strong>注释</strong> 文件系统对象链接的实例如 POSIX 符号链接(symbolic link) 和 Windows 重解析点(reparse point) 。</li>
</ul>
</li>
</ul>
<p><strong>原理</strong></p>
<p>　　文件系统解析文件名可支持链接，但不是所有环境有同等支持。</p>
<p>　　<a href="https://scsh.net/docu/html/man-Z-H-4.html#node_idx_318">Scsh 的 <code>file-not-readable?</code></a> 等明确不支持 <code>chase?</code> 指定跟随链接，理由是不检查符号链接权限，但这并不充分。</p>
<p>　　事实上：</p>
<ul>
<li>对 POSIX 实现：
<ul>
<li><a href="https://pubs.opengroup.org/onlinepubs/9699919799.2008edition/">POSIX.1-2008</a> 和<a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/access.html">后续修订的 <code>faccessat</code></a> 不支持 <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/fcntl.h.html"><code>AT_SYMLINK_NOFOLLOW</code></a> 。</li>
<li><a href="https://man.freebsd.org/cgi/man.cgi?query=faccessat&amp;sektion=2&amp;n=1">FreeBSD 的 <code>faccessat</code></a> 也不支持 <code>AT_SYMLINK_NOFOLLOW</code> 。</li>
<li>但是，<a href="https://man7.org/linux/man-pages/man2/access.2.html">Linux (glibc)</a> 和 <a href="https://android-review.googlesource.com/c/platform/bionic/+/128582">bionic</a> 可支持 <code>AT_SYMLINK_NOFOLLOW</code> 。</li>
<li>于是，至少在特定的 POSIX 实现中，对链接自身的权限判断是有意义的。</li>
</ul>
</li>
<li>此外，Windows 也允许单独判断链接和不同链接目标的权限。</li>
</ul>
<p>　　因此，一般的 API 应当允许区分访问文件是否跟随链接。</p>
<p><strong>注释</strong></p>
<p>　　当前派生实现依赖可用的 <a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BA%93"><code>std.strings</code></a>环境。</p>
<p>　　当前实现的文件系统操作失败可能修改宿主环境的 <code>errno</code> 。</p>
<p><strong>操作：</strong></p>
<p><code>file-exists? &lt;string&gt;</code></p>
<p>　　判断参数指定的文件名对应的文件是否存在。</p>
<p><strong>注释</strong></p>
<p>　　同：</p>
<ul>
<li>[R<sup>7</sup>RS] 的同名过程，但明确跟随链接。</li>
<li><a href="https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s141">Chez Scheme 的同名过程</a>，但不支持可选参数。
<ul>
<li>Chez Scheme（至少在截至版本 9.5.6 ）在 Windows 上<a href="https://github.com/cisco/ChezScheme/issues/716">并没有实现可选参数，实际总是不跟随链接</a>。</li>
</ul>
</li>
</ul>
<p><code>file-directory? &lt;string&gt;</code></p>
<p>　　判断参数指定的文件名对应的文件是否存在且为目录文件。</p>
<p><strong>注释</strong></p>
<p>　　同：</p>
<ul>
<li><a href="https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s143">Chez Scheme 的同名过程</a>，但不支持可选参数。
<ul>
<li>参见 <code>file-exists?</code> 的注释。</li>
</ul>
</li>
<li><a href="https://practical-scheme.net/gauche/man/gauche-refe/System-interface.html#index-file_002dis_002ddirectory_003f">Gauche</a> 和 <a href="https://stklos.net/Doc/html/stklos-ref-4.html#--index-entry-32817">STklos</a> 的 <code>file-is-directory?</code> ，但明确跟随链接。</li>
</ul>
<p><code>file-regular? &lt;string&gt;</code></p>
<p>　　判断参数指定的文件名对应的文件是否存在且为常规文件。</p>
<p><strong>注释</strong></p>
<p>　　同：</p>
<ul>
<li><a href="https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s142">Chez Scheme 的同名过程</a>，但不支持可选参数。
<ul>
<li>参见 <code>file-exists?</code> 的注释。</li>
</ul>
</li>
<li><a href="https://practical-scheme.net/gauche/man/gauche-refe/System-interface.html#index-file_002dis_002dregular_003f">Gauche</a> 和 <a href="https://stklos.net/Doc/html/stklos-ref-4.html#--index-entry-32813">STklos</a> 的 <code>file-is-regular?</code> ，但明确跟随链接。</li>
</ul>
<p><code>readable-file? &lt;string&gt;</code></p>
<p>　　判断参数指定的文件名对应的文件是否存在且可读。</p>
<p><strong>注释</strong></p>
<p>　　同：</p>
<ul>
<li><a href="https://scsh.net/docu/html/man-Z-H-4.html#node_idx_324">Scsh 的 <code>file-readable?</code></a>。</li>
<li><a href="https://practical-scheme.net/gauche/man/gauche-refe/Filesystem-utilities.html#index-file_002dis_002dreadable_003f">Gauche</a> 和 <a href="https://stklos.net/Doc/html/stklos-ref-4.html#--index-entry-32805">STklos</a> 的 <code>file-is-readable?</code> ，但明确跟随链接。</li>
</ul>
<p><code>readable-nonempty-file? &lt;string&gt;</code></p>
<p>　　判断参数指定的文件名对应的文件是否存在、可读且文件内容非空。</p>
<p><code>writable-file? &lt;string&gt;</code></p>
<p>　　判断参数指定的文件名对应的文件是否存在且可写。</p>
<p><strong>注释</strong></p>
<p>　　同：</p>
<ul>
<li><a href="https://scsh.net/docu/html/man-Z-H-4.html#node_idx_326">Scsh 的 <code>file-writable?</code></a>。</li>
<li><a href="https://practical-scheme.net/gauche/man/gauche-refe/Filesystem-utilities.html#index-file_002dis_002dwritable_003f">Gauche</a> 和 <a href="https://stklos.net/Doc/html/stklos-ref-4.html#--index-entry-32809">STklos</a> 的 <code>file-is-writable?</code> ，但明确跟随链接。</li>
</ul>
<p><code>() newline</code></p>
<p>　　输出换行并刷新缓冲。</p>
<p>　　若无法输出，则没有作用。</p>
<p><code>put &lt;string&gt;</code></p>
<p>　　输出字符串。</p>
<p><code>puts &lt;string&gt;</code></p>
<p>　　输出字符串和换行并刷新缓冲。</p>
<p><strong>注释</strong> 同 <code>put</code> 和 <code>newline</code> 的组合。</p>
<p><strong>原理</strong> 和 ISO C 的 <code>puts</code> 不同，保证刷新缓冲，以对交互式设备具有更友好的行为一致性。</p>
<p><code>load &lt;string&gt;</code></p>
<p>　　加载参数指定的翻译单元作为<a href="#%E6%A8%A1%E5%9D%97">源</a>的<a href="#%E6%A8%A1%E5%9D%97">模块</a>。</p>
<p>　　加载时在<a href="#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83">当前环境</a>读取翻译单元后求值，以求值后的这个环境对象作为调用的结果。</p>
<p>　　参数是指定源的确切位置的<a href="#npla1-%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E6%89%A9%E5%B1%95%E7%8E%AF%E5%A2%83">加载路径</a>。当前实现中，参数为文件系统路径。</p>
<p>　　被加载的翻译单元视为对象的<a href="#%E8%A1%A8%E7%A4%BA">外部表示</a>，经读取翻译为 NPLA1 对象。</p>
<p><strong>原理</strong></p>
<p>　　和 [R<sup>7</sup>RS] 不同，<code>load</code> 不支持指定环境，而总是使用当前环境。</p>
<p>　　类似 Kernel ，当前环境可通过不同机制改变，而不需由 <code>load</code> 提供特设的支持。例如，可使用 <a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7"><code>eval</code></a>指定蕴含 <code>load</code> 的调用的求值使用的环境。</p>
<p>　　和其它一些语言的类似命名的功能（如 Lua 的 <code>loadfile</code> ）不同，<code>load</code> 的语义隐含从外部来源取得求值构造(evaluation construct) 后在当前环境求值，其中的求值明确允许隐含副作用。在此，<code>load</code> 的求值被视为初始化加载的模块过程中的一部分。</p>
<p>　　因为当前不提供取得求值构造的读取(read) 等函数，不要求 <code>load</code> 具有非本机的派生实现。并且，取得求值构造可能有其它方式，如从二进制映像映射(map) 到内部表示等替代，这些实现通常不应被要求为总是具有本机派生实现而降低实现质量。</p>
<p><strong>注释</strong></p>
<p>　　参数一般指定视为外部翻译单元的文件名。</p>
<p>　　类似 klisp 的同名操作。类似地，不使用 klisp 的 <code>find-required-filename</code> 机制，直接以宿主的运行环境为基准使用路径。</p>
<p>　　和 klisp 不同，在尾上下文中求值被加载后读取的对象，并以其求值结果作为操作的结果，且错误不影响操作的结果。</p>
<p>　　[Shu09] 缺少 <code>load</code> 的详细描述而仅有标题。</p>
<p>　　另见以下关于 <code>get-module</code> 的说明。</p>
<p><code>get-module &lt;string&gt; &lt;environment&gt;?</code></p>
<p>　　创建标准环境并在其中加载模块。</p>
<p>　　创建<a href="#%E6%96%B0%E7%8E%AF%E5%A2%83">新</a>标准环境并以这个环境为当前环境加载 <code>&lt;string&gt;</code> 指定的翻译单元作为源的模块。</p>
<p>　　若第二参数非空，则在加载前首先绑定创建的环境中的 <code>module-parameters</code> 变量为第二参数的值。</p>
<p>　　结果在加载完成后取得，是先前被创建的标准环境。</p>
<p><strong>注释</strong></p>
<p>　　第一参数的作用同 <code>load</code> 的参数。</p>
<p>　　类似 klisp 和 [Shu09] 中的同名操作。</p>
<p>　　<a href="http://klisp.org/docs/Ports.html#Ports">klisp 文档中的 <code>load</code></a> 描述中求值环境有误：</p>
<ul>
<li>按 [Shu09] 一致的描述和 klisp 的实际实现，调用 <code>load</code> 时应在当前环境求值，而不同于 [Shu09] 的 <code>get-module</code> 中描述的使用创建的新标准环境进行求值。</li>
<li>否则，使用 [Shu09] 的 <code>get-module</code> 的派生不能实现 klisp 和 [Shu09] 中描述的 <code>get-module</code> 的预期语义。</li>
</ul>
<p><code>absolute-path? &lt;string&gt;</code></p>
<p>　　判断参数是否指定绝对路径。</p>
<p><strong>注释</strong></p>
<p>　　同：</p>
<ul>
<li><a href="https://practical-scheme.net/gauche/man/gauche-refe/Filesystem-utilities.html#index-absolute_002dpath_003f">Gauche 的同名过程</a>。</li>
<li><a href="https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s154">Chez Scheme 的 <code>path-absolute?</code></a> 。</li>
<li><a href="http://api.call-cc.org/5/doc/chicken/pathname#sec:absolute-pathname.3f">Chicken 的 <code>absolute-pathname?</code></a> 。</li>
<li><a href="https://www.gnu.org/software/guile/manual/html_node/File-System.html">Guile 的 <code>absolute-file-name?</code></a> 。</li>
</ul>
<p><code>path-parent &lt;string&gt;</code></p>
<p>　　参数字符串视为路径，结果是字符串指定的路径所在的父目录（当路径非根目录），或路径自身转换到的字符串值。</p>
<p>　　结果的路径不带有结尾分隔符。不检查路径实际存在。</p>
<p><strong>注释</strong></p>
<p>　　同：</p>
<ul>
<li><a href="https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s154">Chez Scheme 的同名过程</a>。</li>
<li><a href="http://api.call-cc.org/5/doc/chicken/pathname#sec:pathname-directory">Chicken 的 <code>pathname-directory</code></a> ，但对不包含目录的参数，结果是空串而不是 <code>#f</code> 。
<ul>
<li><strong>注释</strong> 文档没有显示指出结果是 <code>#f</code> 。</li>
</ul>
</li>
<li><a href="https://practical-scheme.net/gauche/man/gauche-refe/System-interface.html#index-sys_002ddirname">Gauche 的 <code>sys-dirname</code></a> ，但对不包含目录的参数，结果是空串而不是 <code>.</code> 。
<ul>
<li><strong>注释</strong> 文档没有显示指出结果是 <code>.</code> 。</li>
</ul>
</li>
<li><a href="https://www.gnu.org/software/guile/manual/html_node/File-System.html">Guile 的 <code>dirname</code></a> ，但对不包含目录的参数，结果是空串而不是 <code>.</code> 。</li>
</ul>
<p><code>remove-file &lt;string&gt;</code></p>
<p>　　移除参数指定的路径命名的文件。若成功结果为 <code>#t</code> ，否则结果为 <code>#f</code> 。</p>
<p><strong>注释</strong></p>
<p>　　同：</p>
<!-- markdownlint-disable-next-line MD034 -->
<ul>
<li>[STklos 的同名过程](https://stklos.net/Doc/html/stklos-ref-4.html#delete-file) ，但通过函数值指定调用失败而非引起错误。</li>
<li>[R<sup>7</sup>RS] 的 <code>delete-file</code> ，但通过函数值指定调用失败而非引起错误。</li>
</ul>
<p><code>create-directory &lt;string&gt;</code></p>
<p>　　创建参数指定的名称的文件系统目录。</p>
<p><strong>原理</strong></p>
<p>　　<code>create-directory</code> 在一些其它语言的实现中命名为 <code>make-directory</code> 。</p>
<p>　　NPLA1 中，作为非正式约定，<code>make</code> 前缀被预留给通过函数值得到创建的对象的过程。</p>
<p>　　这和 <a href="https://practical-scheme.net/gauche/man/gauche-refe/Filesystem-utilities.html">Gauche 不区分两者</a>不同。</p>
<p>　　使用 <code>create-directory</code> 的命名也和 <a href="https://srfi.schemers.org/srfi-170/srfi-170.html">[SRFI-170]</a> 一致，但 NPLA1 中，目录存在时不引起错误而以函数值 <code>#f</code> 指示。</p>
<p>　　此外，[ISO C++] 中存在类似名称的<a href="https://eel.is/c++draft/fs.op.funcs#fs.op.create.directory">函数 <code>std::filesystem::create_directory</code></a> 。</p>
<p><strong>注释</strong></p>
<p>　　类似：</p>
<ul>
<li><a href="http://api.call-cc.org/5/doc/chicken/file#def:create-directory">Checken 的同名过程</a>，但不支持可选参数且函数值不同。</li>
<li><a href="https://scsh.net/docu/html/man-Z-H-4.html#node_sec_3.3">Scsh 的同名过程</a>，但不支持包括权限的可选参数且函数值不同。</li>
<li><a href="http://www-sop.inria.fr/mimosa/fp/Bigloo/manual-chapter5.html#G17247">Bigloo 的 <code>make-directory</code></a> ，但可能引起错误。</li>
<li><a href="https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s146">Chez Scheme</a> 和 <a href="https://www.gnu.org/software/guile/manual/html_node/File-System.html">Guile</a> 的 <code>mkdir</code> ，但不支持可选的权限参数且函数值不同。</li>
<li><a href="https://docs.racket-lang.org/reference/Filesystem.html#%28def._%28%28quote._~23~25kernel%29._make-directory%29%29">[Racket] 的 <code>make-directory</code></a> ，但不支持非字符串参数和可选的权限参数，且通过函数值指定调用失败而非引起错误。</li>
</ul>
<p><code>create-directory* &lt;string&gt;</code></p>
<p>　　创建参数指定的名称的文件系统目录及其必要的父目录。</p>
<p>　　<code>create-directory</code> 和 <code>create-directory*</code> 只创建一级目录时的行为确保一致。</p>
<p><strong>注释</strong></p>
<p>　　类似：</p>
<ul>
<li><a href="http://www-sop.inria.fr/mimosa/fp/Bigloo/manual-chapter5.html#G17256">Bigloo 的 <code>make-directories</code></a> ，但可能引起错误。</li>
<li><a href="https://practical-scheme.net/gauche/man/gauche-refe/Filesystem-utilities.html#Directory-utilities">Gauche 的同名过程和 <code>make-directory*</code></a> ，但不支持可选的权限参数。</li>
<li><a href="https://docs.racket-lang.org/reference/Filesystem.html#%28def._%28%28lib._racket%2Ffile..rkt%29._make-directory%2A%29%29">[Racket] 的 <code>make-directory*</code></a> ，但不支持非字符串参数和可选的权限参数。</li>
</ul>
<p><code>create-parent-directory* &lt;string&gt;</code></p>
<p>　　创建参数指定的名称对应的父目录及其必要的父目录。</p>
<p><strong>注释</strong></p>
<p>　　类似 <a href="https://docs.racket-lang.org/reference/Filesystem.html#%28def._%28%28lib._racket%2Ffile..rkt%29._make-parent-directory%2A%29%29">[Racket] 的 <code>make-parent-directory*</code></a> ，但不支持非字符串参数和可选的权限参数。</p>
<p>　　当前实现中，若创建目录失败而引起错误，抛出 <code>std::system_error</code> 异常。</p>
<h2 id="系统库"><a class="header" href="#系统库">系统库</a></h2>
<p>　　提供和<a href="../Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">实现环境</a>的交互功能。</p>
<p>　　默认加载为根环境下的 <code>std.system</code> 环境。</p>
<p><strong>对象：</strong></p>
<p><code>version-string</code></p>
<p>　　当前实现的版本字符串。</p>
<p>　　类型为 <code>&lt;string&gt;</code> 。</p>
<p><code>build-number</code></p>
<p>　　当前实现的构建版本号。</p>
<p>　　类型为 <code>&lt;integer&gt;</code> ，值为正整数。</p>
<p><code>revision-description</code></p>
<p>　　实现的版本说明。</p>
<p>　　类型为 <code>&lt;string&gt;</code> 。</p>
<p><strong>操作：</strong></p>
<p><code>() get-current-repl</code></p>
<p>　　取表示当前 REPL 环境的引用值。</p>
<p><code>() cmd-get-args</code></p>
<p>　　返回<a href="#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">宿主环境</a>程序接受的命令行参数列表。</p>
<p>　　其中参数数组保存在实现内部访问的对象中。</p>
<p>　　传递给 REPL 的命令行参数通常是宿主程序中主函数的 <code>argv</code> 参数数组中处理后去除特定参数后的程序。</p>
<p>　　宿主程序复制 <code>argv</code> 到这个数组作为副本后，作为<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">返回值</a>的列表的来源。</p>
<p><code>env-get &lt;string&gt;</code></p>
<p>　　取宿主环境的环境变量字符串。</p>
<p>　　字符串参数指定环境变量的名称。</p>
<p><code>env-set &lt;string1&gt; &lt;string2&gt;</code></p>
<p>　　设置宿主环境的环境变量字符串。</p>
<p>　　两个字符串参数分别指定环境变量的名称和设置的值。</p>
<p>　　使用 <code>env-get</code> 和 <code>env-set</code> 及对应宿主环境的操作不保证线程安全。</p>
<p><code>env-empty? &lt;string&gt;</code></p>
<p>　　判断字符串指定名称的环境变量是否为空。</p>
<p><code>system &lt;string&gt;</code></p>
<p>　　以 <code>std::system</code> 兼容的方式调用外部命令。</p>
<p>　　结果是宿主环境命令返回的命令退出状态。</p>
<p><strong>注释</strong></p>
<p>　　类似 <a href="https://cisco.github.io/ChezScheme/csug9.5/foreign.html">Chez Scheme 的外部接口</a> ，但更接近 [ISO C] 和 [ISO C++] 的原始含义，当前不提供关于信号等依赖特定实现环境的保证。</p>
<p>　　使用 [ISO C] 和 <a href="https://eel.is/c++draft/basic.start.main#2">[ISO C++] 的宿主环境的命令退出状态是 <code>int</code> 值</a>。由 <a href="#npla-%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83">NPLA 实现环境</a>，这里的结果的<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">宿主类型</a>是确定的。而 <a href="#npla1-%E6%95%B0%E5%80%BC">NPLA1 数值</a>使用 <a href="#npla-%E6%95%B0%E5%AD%A6%E5%8A%9F%E8%83%BD">NPLA 数学功能</a>确保其被<a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">映射</a>为<a href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">确定的数值类型</a>。</p>
<p><code>system-get &lt;string&gt;</code></p>
<p>　　调用命令，返回命令调用结果。</p>
<p><strong>注释</strong> 在典型的 C++ 宿主实现中，命令的调用结果是来自标准输出的数据。</p>
<p>　　返回一个两个元素的列表，分别是管道输出字符串和宿主环境命令返回的命令退出状态。</p>
<p>　　调用命令和 <code>system</code> 的方式类似。</p>
<p><code>make-temporary-filename &lt;string1&gt; &lt;string2&gt;</code></p>
<p>　　取适合命名新创建的临时文件的随机文件名。</p>
<p>　　参数分别指定前缀和后缀。参数可能为空。随机文件名以生成的有限长度的随机字符串添加前缀和后缀组成。</p>
<p>　　生成的字符串只包含 C++ 基本字符串的可打印字符，且不使用大写字母，以兼容大小写不敏感的文件系统。</p>
<p>　　随机的文件名被打开以检查是否可访问。若失败则重试，若最终失败，则引起错误。</p>
<p><strong>注释</strong></p>
<p>　　功能类似 <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdio.h.html">POSIX <code>::tmpnam</code> 和 <code>::mkstemp</code></a> ，以及 <a href="https://www.gnu.org/software/guile/manual/html_node/File-System.html">Guile 对应的过程 <code>tmpnam</code> 和 <code>mkstemp</code></a> ，有以下不同：</p>
<ul>
<li>和 <code>tmpname</code> 类似，结果是文件名，而不是打开的文件或端口。</li>
<li>和 <code>mkstemp</code> 类似，使用模板字符串作为文件名，但模板不在参数中指定。</li>
</ul>
<p>　　	保证生成的文件名在不同<a href="#%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0">宿主实现</a>（文件系统）中的兼容性。</p>
<p>　　当前实现中的随机字符串长度为 6 。当前实现中重试的上限是 16 次（宿主平台）或 1 次（非宿主平台）。若最终失败，抛出 <code>std::system_error</code> 异常。</p>
<h2 id="模块管理"><a class="header" href="#模块管理">模块管理</a></h2>
<p>　　提供使用模块和其中符号的相关功能。</p>
<p>　　默认加载为根环境下的 <code>std.modules</code> 环境。</p>
<p><strong>模块约定：</strong></p>
<p>　　<em>需求字符串(requirement string)</em> 是具有 <code>&lt;string&gt;</code> 类型的非空字符串。</p>
<p>　　若操作的形式参数是需求字符串，实际参数是空字符串，则<a href="#npla1-%E9%94%99%E8%AF%AF">引起错误</a>。</p>
<p>　　本模块共享<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98">可变管理状态</a>，以支持操作访问确定的模块字符串集合。</p>
<p>　　本模块隐含一个字符串的序列，其中的每个元素都是可<a href="#npla1-%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E6%89%A9%E5%B1%95%E7%8E%AF%E5%A2%83">指定搜索起点的模块的加载路径</a>，称为<em>需求字符串模板(requirement string template)</em> 。</p>
<p>　　除非派生实现另行指定，需求字符串模板序列在<a href="#npla1-%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96">实现环境初始化</a>后不可变。</p>
<p>　　初始化决定的需求字符串模板序列的内容由实现定义。</p>
<p>　　程序可通过本模块<em>注册(register)</em> 需求字符串。本模块维护已被注册的需求字符串的集合。若一个字符串的值和集合中的某个值相等，则这个字符串作为需求字符串已被注册。</p>
<p>　　注册新的需求字符串时，同时创建和保存：</p>
<ul>
<li>待加载结果的对象，其初始值为 <code>()</code> 。</li>
<li>可供加载使用的<a href="#%E6%96%B0%E7%8E%AF%E5%A2%83">新</a><a href="#%E5%9F%BA%E6%9C%AC%E6%B4%BE%E7%94%9F%E7%89%B9%E6%80%A7">标准环境</a>。</li>
</ul>
<p>　　本模块确保对不同的被维护的需求字符串，对应的上述资源不同一。</p>
<p><strong>原理</strong></p>
<p>　　参数的值和结果不需要保证一一对应。通过指定需求字符串模板序列，可以指定在文件系统不同位置的相同文件名模式的多个文件作为需求字符串对应的候选模块的源，按需选取其中之一指定其确切位置。</p>
<p>　　为避免名称污染等问题，不提供显式指定命名环境的模块创建操作，如 <a href="http://www.lua.org/manual/5.1/manual.html#pdf-module">Lua 5.1 的 <code>module</code> 函数</a>等<a href="http://lua-users.org/wiki/LuaModuleFunctionCritiqued">存在一些问题</a>。</p>
<p>　　不提供访问创建的环境的操作，以避免污染外部的访问。若需公开其中的变量绑定，可使用返回或模块参数。</p>
<p>　　提供较少的操作以简化规则，避免<a href="https://xkcd.com/1987/">多个运行时可能造成的混乱</a>。关于搜索规则，另见以下 <code>find-required-filename</code> 的说明。</p>
<p><strong>注释</strong></p>
<p>　　对内部共享状态的<a href="#npla-%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE">并发访问</a>并不具有特别的同步保证和要求。并发访问<a href="#npla1-%E7%A8%8B%E5%BA%8F%E5%A4%96%E9%83%A8%E7%8E%AF%E5%A2%83">可引起宿主语言的未定义行为</a>。</p>
<p>　　当前实现中，若环境变量 <code>NPLA1_PATH</code> 的值非空，则需求字符串模板序列是这个值以单字符子串 <code>;</code> 分隔后的结果串接组成的序列；否则，默认值是字符串 <code>./?</code> 和 <code>./?.txt</code> 构成的序列。</p>
<p>　　关于使用需求字符串模板序列搜索模块，参见以下 <code>find-required-filename</code> 的说明。</p>
<p>　　当前派生实现依赖可用的 <a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BA%93"><code>std.strings</code></a>、<a href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%BA%93"><code>std.io</code></a>和 <a href="#%E7%B3%BB%E7%BB%9F%E5%BA%93"><code>std.system</code></a>环境。</p>
<p>　　通过不经过本模块的操作（如<a href="#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81">互操作</a>）、重复字符串模板的重复项、符号链接和字符串大小写不敏感的文件名等可能绕过本模块的注册机制而重复加载同一个外部文件。本模块的操作不对这些情形进行任何检查。</p>
<p><strong>操作：</strong></p>
<p><code>registered-requirement? &lt;string&gt;</code></p>
<p>　　判断参数是否是已在本模块注册的需求字符串。</p>
<p><code>register-requirement! &lt;string&gt;</code></p>
<p>　　在本模块注册参数为需求字符串。</p>
<p>　　若参数指定的需求字符串已被注册，则引起错误；否则，创建并保存新标准环境。</p>
<p>　　结果是保存的环境的<a href="#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8">弱引用</a>。</p>
<p><code>unregister-requirement! &lt;string&gt;</code></p>
<p>　　在本模块解除注册参数为需求字符串。</p>
<p>　　若参数指定的需求字符串没有被注册，则引起错误；否则，移除与参数的值相等的需求字符串以及保存的关联的资源。</p>
<p><code>find-required-filename &lt;string&gt;</code></p>
<p>　　查找需求字符串对应的文件名。</p>
<p>　　在需求字符串模板序列中顺序地检查每一个元素：</p>
<ul>
<li>使用参数的值替换元素中的每个单字符子串 <code>?</code> 。</li>
<li>判断经替换得到的字符串是否构成指定一个可读文件的文件名。</li>
</ul>
<p>　　若不存在这样的文件名，则引起错误；否则，结果是第一个符合条件的文件名。</p>
<p>　　替换字符串时，每一个子串被同时一次替换；不对替换结果进一步递归地替换。</p>
<p><strong>原理</strong></p>
<p>　　类似 klisp 而和 Lua（ <a href="https://www.lua.org/source/5.3/loadlib.c.html"><code>require</code> 的实现</a>；没有<a href="https://www.lua.org/pil/8.1.html">在此</a>明确）及 <a href="https://www.haskell.org/hugs/pages/users_guide/module-commands.html">Haskell</a> 等不同，不替换名称中的 <code>.</code> 为路径分隔符，以简化对实现环境的假设。</p>
<p><strong>注释</strong></p>
<p>　　若需求字符串模板的元素中没有通配符 <code>?</code> ，则不需要替换，需求字符串模板直接是指定确切位置的结果文件名。</p>
<p><code>require &lt;string&gt; &lt;environment&gt;?</code></p>
<p>　　按需在新标准环境加载需求字符串对应的模块。</p>
<p>　　若第二参数非空，则在加载前首先绑定创建的环境中的 <code>module-parameters</code> 变量为第二参数的值。</p>
<p>　　按需加载包含以下步骤：</p>
<ul>
<li>若参数指定的需求字符串没有注册，则：
<ul>
<li>以同调用 <code>register-requirement?</code> 等价的方式注册需求字符串，确保注册时的环境被创建。</li>
<li>以同调用 <code>find-required-filename</code> 等价的方式确定待加载的源的文件名。</li>
<li>以同模块 <a href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%BA%93"><code>std.io</code> 中的 <code>load</code></a>相同的方式在注册时创建的环境加载上述文件名指定的源。</li>
<li>保存加载的结果。</li>
</ul>
</li>
<li>否则，不进行加载。</li>
<li>结果是已保存的加载的结果。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　先注册需求字符串允许重入调用 <code>require</code> ，即加载模块时求值的源代码包含和先前的字符串参数相同的 <code>require</code> 调用，而不至于无限递归。</p>
<p><strong>注释</strong></p>
<p>　　类似 klisp 的 ports 模块中的同名应用子，但有以下不同：</p>
<ul>
<li>同时保存创建的环境，以避免因程序没有保存环境引用而<a href="#%E6%97%A0%E6%95%88%E5%8C%96">无效化</a>，使访问变量绑定的程序具有未定义行为。</li>
<li>结果是加载结果（同模块 <code>std.io</code> 中的 <code>load</code> ）而不是 <code>#inert</code> 。</li>
<li>支持同 <a href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%BA%93"><code>std.io</code> 中的 <code>get-module</code></a> 的可选参数。</li>
</ul>
<h1 id="附录"><a class="header" href="#附录">附录</a></h1>
<h2 id="进一步阅读"><a class="header" href="#进一步阅读">进一步阅读</a></h2>
<p>　　关于 NPL 语言<a href="#%E7%95%A5%E7%A7%B0">派生实现</a>的具体实现，参见 YSLib 项目文档 <a href="https://osdn.net/projects/yslib/scm/hg/YSLib/blobs/tip/doc/NPL.txt"><code>doc/NPL.txt</code></a> 。</p>
<h2 id="kernel-实现"><a class="header" href="#kernel-实现">Kernel 实现</a></h2>
<p>　　NPL 文法是 S-表达式语法和 Kernel 兼容语义的简化，某些 NPLA1 程序可以原封不动地作为 Kernel 程序运行。因为参考文献可用性以及相似性几乎独一无二，建议深入使用前参照 Kernel 相关的文档并实际使用，以和 NPL 进行比较（当前 NPL 开发文档也引用包括 [R<sup>n</sup>RK] 在内的一些规格说明）。现有较完整可用的一个 Kernel 实现是 <a href="http://klisp.org/">Klisp</a> 。</p>
<h2 id="计划支持特性"><a class="header" href="#计划支持特性">计划支持特性</a></h2>
<p>　　在 Kernel 中已存在但当前 NPLA1 未支持，而计划在未来添加的特性：</p>
<ul>
<li>一等续延(first-class continuation)
<ul>
<li><a href="http://okmij.org/ftp/continuations/against-callcc.html">基于一些显著的理论和实现可用性的理由</a>，需要考察<a href="#%E7%BB%AD%E5%BB%B6">有界续延</a>（如 <code>shift</code>/<code>reset</code> ）而不是传统的 <code>call/cc</code> 的支持。</li>
<li>和 Klisp 的异步实现方式类似但不同，NPLA1 核心已使用一种同 <a href="http://www.ccs.neu.edu/home/dvanhorn/pubs/vanhorn-might-icfp10.pdf">CESK-style 的抽象机</a>的异步风格独立重新实现（<a href="http://www.brics.dk/RS/05/16/BRICS-RS-05-16.pdf">原理参考</a>），并兼容混合原有实现。并且状态支持已提供基本操作，但仍待更多测试。</li>
</ul>
</li>
<li><a href="http://klisp.org/docs/Promises.html#Promises">Promises</a>
<ul>
<li>虽然 NPLA1 之前有部分原生实现，但计划改用基于封装类型派生。</li>
</ul>
</li>
<li><a href="http://klisp.org/docs/Keyed-Variables.html#Keyed-Variables">Keyed Variables</a>
<ul>
<li>有效的 keyed dynamic varabile 实现可能依赖一等续延数据结构。</li>
<li>有效的 keyed static varabile 实现需要调整环境数据结构。</li>
</ul>
</li>
<li><a href="http://klisp.org/docs/Ports.html#Ports">Ports</a>
<ul>
<li>需要调查内存映射文件和其它系统支持。</li>
</ul>
</li>
<li><a href="http://klisp.org/docs/Libraries.html#Libraries">Libraries</a>
<ul>
<li>可能需要提供多种不同的接口。</li>
</ul>
</li>
</ul>
<p>　　已提供但考虑可能优化实现的特性：</p>
<ul>
<li><a href="http://klisp.org/docs/Encapsulations.html#Encapsulations">封装类型</a>
<ul>
<li>需要调查互操作相关的特性和持久化支持。</li>
</ul>
</li>
</ul>
<p>　　计划考虑提供其它设计替代选项的 Klisp 特性：</p>
<ul>
<li><a href="http://klisp.org/docs/Characters.html#Characters">Characters</a>
<ul>
<li>满足互操作要求的前提下，使用设计更合理的类型替代。</li>
</ul>
</li>
<li><a href="http://klisp.org/docs/Vectors.html#Vectors">Vectors</a>
<ul>
<li>使用更完善的用户自定义派生类型替代。</li>
</ul>
</li>
</ul>
<p>　　其它 NPL 计划实现特性：</p>
<ul>
<li>模块化框架</li>
<li>支持类型系统的子语言
<ul>
<li>类似 <a href="https://docs.racket-lang.org/ts-reference/index.html">Typed Racket</a> 。</li>
</ul>
</li>
<li>测试框架</li>
<li>基于 <code>$let-safe</code> 的静态环境操作替换优化</li>
<li>用于编译的中间代码格式和二进制代码生成框架
<ul>
<li>类似 <a href="https://www.scheme.com/">Chez Scheme</a> 对 <a href="http://nanopass.org/">Nanopass</a> 的使用。</li>
</ul>
</li>
<li><a href="https://en.wikipedia.org/wiki/Metacompilation">元编译(metacompilation)(en-US)</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../ProjectDependencies.zh-CN.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../EMPTY.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../ProjectDependencies.zh-CN.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../EMPTY.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
