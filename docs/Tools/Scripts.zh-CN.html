<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>脚本 - The YSLib Book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Book tranplanted from YSLib BitBucket wiki.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The YSLib Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="概述"><a class="header" href="#概述">概述</a></h1>
<p>　　YSLib 项目提供一系列工具脚本。这些脚本主要集中位于 <code>Tools</code> 和 <code>Tools/Scripts</code> 。其余特定局部用途的脚本可能位于其它目录，这些脚本可能依赖版本库内的工具脚本或 YSLib 安装时部署的工具脚本。</p>
<p>　　关于脚本的解释环境和其它一般规则，参见<a href="../Development.zh-CN.html#%E8%84%9A%E6%9C%AC">关于脚本的开发说明</a>。关于 shell 脚本，同时参见 <a href="../Development.zh-CN.html#shell-%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E8%A7%84%E7%BA%A6">shell 语言使用规约</a>。</p>
<p>　　本文档附加约定，除非另行指定：</p>
<ul>
<li>公开的 shell 脚本和 NPLA1 脚本被 <a href="#toolsinstall-sysrootsh"><code>Tools/install-sysroot.sh</code></a> 分别部署到安装路径下的 <code>bin</code> 和 <code>share/NPLA1</code> 目录下。</li>
<li>除<a href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">用于构建选项的环境配置</a>外，提供的 shell 变量可能设置为只读。</li>
<li>脚本引入不具有后缀 <code>_</code> 的名称若不是被导出的变量，可在脚本之间使用，满足关于名称的约束，但不保证接口稳定性。</li>
</ul>
<p><strong>注释</strong> 维护者和开发者需要阅读开发说明，以保持脚本程序符合文档的描述。其中的一些信息（如关于环境变量等运行时环境的描述）也可能提供对脚本的非开发者用户有帮助的说明，作为<a href="../Run.zh-CN.html">运行环境</a>中说明的补充。</p>
<h1 id="tools"><a class="header" href="#tools">Tools</a></h1>
<p>　　未归类的工具目录。这个目录提供可用于整个项目或非特定子项目的工具，其中包含实现为脚本的工具。</p>
<p>　　工具脚本位于<a href="Terminology.zh-CN.html#%E7%89%88%E6%9C%AC%E5%BA%93">存储库</a>目录 <code>Tools</code> 及其子目录 <code>Scripts</code> 下。后者的工具脚本在设计上确定为脚本。</p>
<p>　　工具主要用于开发，包括构建和存储库维护。</p>
<p>　　一部分 <code>Scripts</code> 目录下的工具脚本也可被部署到 <a href="../Sysroot.zh-CN.html">Sysroot</a> 。在 <a href="SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 2 SHBuild</a> 安装后运行的脚本可依赖安装的 Sysroot 实例的文件系统布局。支持维护存储库的开发脚本应保证在此之前（不依赖 Sysroot 的实例或仅依赖构建 <a href="SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 1</a> 后可用的有限环境）可用。</p>
<h2 id="环境配置"><a class="header" href="#环境配置">环境配置</a></h2>
<p>　　一些环境变量可能被可选地在外部环境或在调用脚本的其它脚本中指定。若没有被指定为非空值，则可被特定上下文按需初始化。初始化后的值可能被断言非空，断言失败则非正常地退出脚本。</p>
<p>　　这些变量可能指定外部环境的配置。</p>
<p>　　在<a href="../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">开发文档中的环境变量</a>的基础上，以下各节补充指定适用于多个脚本的变量。在对应的脚本的文档中可能补充描述。</p>
<p>　　一些环境变量具有特定的命名模式：</p>
<ul>
<li><a href="../Development.zh-CN.html">开发文档</a>中的环境变量具有相同前缀的外部扩展环境变量：
<ul>
<li>具有前缀 <code>SHBuild_</code> ：可能适用于所有构建脚本流程。
<ul>
<li><strong>注释</strong> 具有前缀 <code>SHBuild_S1_</code> 和 <code>SHBuild_S2_</code> 的名称不指定环境变量，而是函数名称。</li>
</ul>
</li>
<li>具有前缀 <code>YSLib_</code> ：指定和 YSLib 库相关的环境和配置。</li>
<li><strong>注释</strong> 这些前缀的变量通常在开发文档中指定。仅在个别脚本中适用或不在 shell 脚本（而仅在 <a href="../Development.zh-CN.html#npla1-%E8%84%9A%E6%9C%AC">NPLA1 脚本</a>）适用时，在本文档指定扩展。</li>
</ul>
</li>
<li>具有前缀 <code>SS_</code> ：<a href="#%E5%85%AC%E5%85%B1%E6%9E%84%E5%BB%BA%E9%85%8D%E7%BD%AE%E5%8F%98%E9%87%8F">公共构建配置变量</a>。
<ul>
<li><strong>注释</strong> 环境变量名称中的 <code>SS</code> 前缀表示 <a href="SHBuild.zh-CN.html">SHBuild</a> 设置(settings) 。</li>
</ul>
</li>
<li>具有前缀 <code>S1_</code> ：在 <a href="SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 1 SHBuild</a> 构建流程中作用的变量。
<ul>
<li><strong>注释</strong> 环境变量名称中的 <code>S1</code> 前缀表示 Stage 1 。</li>
</ul>
</li>
<li>具有前缀 <code>CFLAGS</code> 、<code>CXXFLAGS</code> 和 <code>LDFLAGS</code> 等：指定构建工具使用的选项。
<ul>
<li><strong>注释</strong> 在 shell 环境中这主要通过 <a href="#toolsscriptsshbuild-common-optionssh"><code>Tools/Scripts/SHBuild-common-options.sh</code></a> 配置。</li>
</ul>
</li>
</ul>
<h3 id="公共构建配置变量"><a class="header" href="#公共构建配置变量">公共构建配置变量</a></h3>
<p>　　以下配置行为的环境变量可在多个构建脚本中被支持且具有一致的含义：</p>
<ul>
<li><code>SS_DebugEnv</code> 启用脚本执行时系统环境相关的调试输出。</li>
<li><code>SS_DirectExtract</code> 启用直接解压缩。</li>
<li><code>SS_NoParallel</code> 不使用并行命令调用。</li>
<li><code>SS_Offline</code> 离线模式：不使用互联网。</li>
<li><code>SS_Verbose</code> 启用详细消息输出。</li>
</ul>
<p>　　除非另行指定，这些变量的值当且仅当非空表示启用特性。</p>
<p>　　具体作用在具体脚本的说明中详细描述。</p>
<h3 id="stage-1-共享变量"><a class="header" href="#stage-1-共享变量">Stage 1 共享变量</a></h3>
<p>　　以下变量影响 stage 1 的多个构建脚本的行为。</p>
<ul>
<li><code>S1_BuildConf</code> 内部配置名称。
<ul>
<li>通常指定不同的值对应不共享的构建配置组合。</li>
<li><strong>注释</strong> 可影响默认构建目录。</li>
</ul>
</li>
<li><code>S1_BuildDir</code> Stage 1 SHBuild 构建和输出文件目录路径。</li>
<li><code>S1_CacheFile</code> Stage 1 缓存文件名。</li>
<li><code>S1_CacheMode</code> Stage 1 缓存模式。
<ul>
<li>可选模式是如下子模式的组合：
<ul>
<li>读模式：加载缓存时，无条件忽略或不忽略缓存之一。</li>
<li>默认写模式：保存缓存且缓存文件不存在时，不写入、写入空文件或写入缓存之一。</li>
<li>覆盖写模式：保存缓存且缓存文件存在时，不写入、写入空文件、覆盖写入缓存或清除缓存文件之一。</li>
</ul>
</li>
<li>组合模式如下：
<ul>
<li>加载缓存时忽略：
<ul>
<li>默认不写入：
<ul>
<li><code>disable</code> 禁用缓存：不覆盖写入。</li>
<li><code>reset</code> 复位为空文件：覆盖写入空文件。</li>
<li><code>update</code> 只更新：覆盖写入。</li>
<li><code>clean</code> 清理：清除缓存文件。</li>
</ul>
</li>
<li>默认写入空文件：
<ul>
<li><code>touch</code> 只创建空文件：不覆盖写入。</li>
<li><code>mark</code> 标记：覆盖写入空文件。</li>
</ul>
</li>
<li>默认写入：
<ul>
<li><code>create</code> 只创建新文件：不覆盖写入。</li>
<li><code>writeonly</code> 只写：覆盖写入。</li>
</ul>
</li>
</ul>
</li>
<li>加载缓存时不忽略：
<ul>
<li>默认不写入：
<ul>
<li><code>readonly</code> 只读：不覆盖写入。</li>
<li><code>clear</code> 清除：覆盖写入空文件。</li>
<li><code>writeback</code> 写回：覆盖写入。</li>
<li><code>purge</code> 清洗：清除缓存文件。</li>
</ul>
</li>
<li>默认写入空文件：
<ul>
<li><code>move</code> 转移：不覆盖写入。</li>
<li><code>absorb</code> 吸收：覆盖写入空文件。</li>
</ul>
</li>
<li>默认写入：
<ul>
<li><code>keep</code> 保持：不覆盖写入。</li>
<li><code>force</code> 强制：覆盖写入。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>别名：
<ul>
<li><code>disabled</code> 同 <code>disable</code> 。</li>
<li><code>false</code> 同 <code>disable</code> 。</li>
<li><code>ignore</code> 同 <code>disable</code> 。</li>
<li><code>n</code> 同 <code>disable</code> 。</li>
<li><code>no</code> 同 <code>disable</code> 。</li>
<li><code>none</code> 同 <code>disable</code> 。</li>
<li><code>once</code> 同 <code>purge</code> 。</li>
<li><code>overwrite</code> 同 <code>force</code> 。</li>
<li><code>skip</code> 同 <code>disable</code> 。</li>
<li><code>writethrough</code> 同 <code>update</code> 。</li>
<li>其它值的含义同未设置此变量，默认启用缓存，同 <code>keep</code> ：加载和保存缓存，但不覆盖已有缓存。</li>
</ul>
</li>
</ul>
</li>
<li>前缀为 <code>S1_Cached_</code> 的变量是可在外部指定的缓存项。作为配置项的变量支持以下值：
<ul>
<li><code>disable</code> 禁用：不使用。</li>
<li><code>disabled</code> 同 <code>disable</code> 。</li>
<li><code>false</code> 同 <code>disable</code> 。</li>
<li><code>n</code> 同 <code>disable</code> 。</li>
<li><code>no</code> 同 <code>disable</code> 。</li>
<li><code>none</code> 同 <code>disable</code> 。</li>
<li>其它非空值视为 <code>true</code> ，指定启用库：使用库配置参数。</li>
<li>空值（未缓存）：自动检查可用性并确定配置项的变量值，之后可写入缓存。</li>
</ul>
</li>
<li><code>S1_DistDir</code> Stage 1 SHBuild 可执行程序目录路径。</li>
<li><code>S1_SHBuild</code> Stage 1 SHBuild 可执行文件路径。
<ul>
<li><strong>注释</strong> Win32 平台实际的可执行文件可隐含后缀 <code>.exe</code> 。</li>
</ul>
</li>
</ul>
<p>　　具体作用可在具体脚本的说明中详细描述。</p>
<h3 id="版本控制系统支持"><a class="header" href="#版本控制系统支持">版本控制系统支持</a></h3>
<p>　　部分脚本使用以下方式检查和识别版本控制系统。</p>
<p>　　以下环境变量提示使用 Mercurial 或 Git ：</p>
<ul>
<li>若<a href="../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量 <code>SHBuild_VCS_hg</code></a> 非空，则检查 <code>hg</code> 命令可用。</li>
<li>否则，若<a href="../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量 <code>SHBuild_VCS_git</code></a> 非空，则检查 <code>git</code> 命令可用。</li>
<li>否则，依次检查 <code>hg</code> 和 <code>git</code> 命令可用，若 <code>hg</code> 可用则不再检查 <code>git</code> 。</li>
</ul>
<p>　　命令可用需要满足以下条件：</p>
<ul>
<li>被检查的命令应在 <code>$PATH</code> 中。
<ul>
<li>若在 Windows 中使用 shell ，可能需要提前设置环境以确保继承环境变量。</li>
<li><strong>注意</strong> MSYS2 提供的 <code>mercurial</code> 包的可执行文件是脚本而不是可执行文件，不被 NPLA1 脚本调用的 Windows 命令行支持。</li>
<li><strong>注释</strong> 不使用 <code>HG</code> 环境变量，因为可能设置为不被支持的 <code>hg</code> 程序路径。事实上，MSYS2 的包 <code>mercurial</code> 安装到 <code>/etc/profile.d/mercurial.sh</code> 设置 <code>HG</code> 为脚本，覆盖从其它位置继承的 <code>hg.exe</code> 。</li>
</ul>
</li>
<li>且当前工作目录求在对应的版本库中，同时确定仓库的顶层目录路径。
<ul>
<li>对 Git ，要求存在工作区。</li>
</ul>
</li>
</ul>
<h2 id="toolsinstall-sysrootsh"><a class="header" href="#toolsinstall-sysrootsh">Tools/install-sysroot.sh</a></h2>
<p>　　Sysroot 安装脚本。用于直接构建和部署基础环境。</p>
<p>　　构建时会调用 <code>Tools/Scripts</code> 目录下的脚本，按需构建 <a href="SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 1 SHBuild</a> 后间接调用 <code>SHBuild</code> 构建 <code>YBase</code> 和 <code>YFramework</code> 的静态库和动态库，再构建依赖于动态库的 <code>SHBuild</code> ：</p>
<ul>
<li>按需初始化<a href="../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">变量 <code>SHBuild_ToolDir</code></a> 。</li>
<li>包含脚本 <a href="#toolsscriptsshbuild-commonsh"><code>Tools/Scripts/SHBuild-common.sh</code></a> 以按需初始化确定默认构建位置依赖的环境变量。</li>
<li>设置<a href="#stage-1-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">变量 <code>S1_BuildConf</code></a> 的值，并调用<a href="#%E5%87%BD%E6%95%B0-shbuild_s1_initconf">函数 <code>SHBuild_S1_InitConf</code></a> 初始化必要的变量，以允许判断是否在预期位置存在 stage 1 SHBuild 。</li>
<li>按需构建 stage 1 SHBuild 。</li>
<li>间接调用 stage 1 SHBuild 构建 <code>YBase</code> 和 <code>YFramework</code> 的静态库和动态库。</li>
<li>再构建依赖于动态库的 <code>SHBuild</code> 。</li>
</ul>
<p>　　构建使用<a href="../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">变量 <code>SHBuild_BuildDir</code></a> 指定的路径作为中间输出目录。</p>
<p><strong>注释</strong> 另见 <a href="#toolsscriptsshbuild-bootstrapsh"><code>Tools/Scripts/SHBuild-bootstrap.sh</code></a> 。</p>
<p>　　构建脚本同时可安装文件，完成 Sysroot 所需文件的部署。安装的起始目标位置由称为<strong>安装路径</strong>的目录路径指定，其字符串形式去除结尾分隔符的目录文件名为<strong>安装路径前缀</strong>。安装过程在必要时可创建 Sysroot 根目录、安装路径指定的目录及其子目录。安装路径的确定方式详见以下的使用方式。</p>
<p>　　部署时使用 stage 1 SHBuild 更新文件和目录，在必要时创建符号链接或硬链接，若失败则改为普通复制。仅当被部署的文件为中间目标启用硬链接，以免后续操作意外覆盖源文件。注意在 Windows 上创建符号链接可能因为权限不足失败，取决于用户和组策略。建议使用系统管理权限运行以避免可能的权限问题。</p>
<h3 id="基本使用"><a class="header" href="#基本使用">基本使用</a></h3>
<p>　　脚本接受在 stage 2 使用的 <code>SHBuild</code> 命令行中的选项为命令行参数，如</p>
<pre><code class="language-shell">Tools/install-sysroot.sh -xj,2
</code></pre>
<p>　　使用 2 个并行线程构建。</p>
<p>　　脚本也支持变量配置构建使用的路径，默认相当于使用如下 bash 命令配置变量：</p>
<pre><code class="language-bash">: ${SHBuild_SysRoot:="$YSLib_BaseDir/sysroot"}
: ${SHBuild_BuildDir:="$YSLib_BaseDir/build/$(SHBuild_GetBuildName)"}
</code></pre>
<p>　　其中：</p>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0-shbuild_preparebuild"><code>SHBuild_PrepareBuild</code></a> 是 <code>Tools/Scripts/SHBuild-common.sh</code> 中的函数。</li>
<li>各个变量参见<a href="../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">开发文档中的环境变量的说明</a>。</li>
</ul>
<p>　　在 stage 1 SHBuild 构建调用 NPLA1 脚本 <code>Tools/Scripts/SHBuild-YSLib*.txt</code> ，调用方式和接受的配置（构建目标等）、具体默认设置和注意事项见对应 shell 脚本的文档相关章节。</p>
<h1 id="toolsscripts"><a class="header" href="#toolsscripts">Tools/Scripts</a></h1>
<p>　　这个目录的脚本可用于整个项目或项目核心部分的构建工具使用。</p>
<p>　　当前有以下脚本忽略重复的 <code>.</code> 或 <code>source</code> 命令：</p>
<ul>
<li>SHBuild-common.sh</li>
</ul>
<p>　　以前缀 <code>SHBuild_</code> 起始的名称保留使用。</p>
<p>　　其中，前缀 <code>SHBuild_Env_</code> 总是表示环境配置的只读变量名。这些变量若未被指定，可在第一次访问时（具体时机未指定）初始化为：</p>
<ul>
<li><code>SHBuild_Env_Arch</code> ：参见函数 <code>SHBuild_CheckUName</code> 。</li>
<li><code>SHBuild_Env_OS</code> ：参见函数 <code>SHBuild_CheckUName</code> 。</li>
<li><code>SHBuild_Env_TempDir</code> ：缓存函数 <code>SHBuild_GetTempDir</code> 的输出。</li>
<li><code>SHBuild_Env_uname</code> ：缓存命令 <code>uname</code> 的输出。</li>
<li><code>SHBuild_Env_uname_m</code> ：缓存命令 <code>uname -m</code> 的输出。</li>
</ul>
<h2 id="toolsscriptsgenerateprojectssh"><a class="header" href="#toolsscriptsgenerateprojectssh">Tools/Scripts/GenerateProjects.sh</a></h2>
<p>　　调用 <a href="ProjectGenerator.zh-CN.html">ProjectGenerator</a> 生成项目文件。</p>
<p>　　当前支持生成所有 <code>.cbp</code> 文件。</p>
<p>　　要求可使用 <code>hg</code> 或 <code>git</code> 命令取版本库根目录，否则不保证输出到正确的路径。</p>
<h3 id="变量-projectgenerator"><a class="header" href="#变量-projectgenerator">变量 ProjectGenerator</a></h3>
<p>　　调用 RevisionPatcher 的命令。默认直接使用 <code>type -P ProjectGenerator</code> 的结果，一般要求可执行文件在环境变量 <code>PATH</code> 中。</p>
<h2 id="toolsscriptspatchrevisionsh"><a class="header" href="#toolsscriptspatchrevisionsh">Tools/Scripts/PatchRevision.sh</a></h2>
<p>　　开发过程中使用 <a href="RevisionPatcher.zh-CN.html">RevisionPatcher</a> 维护源文件中版本号的脚本。</p>
<p>　　当前只支持 Mercurial 或 Git 版本库的已添加或修改的未提交文件。</p>
<p>　　使用的版本控制系统会被检查。通过检查的条件、确定使用的版本控制的机制及支持的控制检查的环境变量参见<a href="#%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E6%94%AF%E6%8C%81">版本控制系统支持</a>。</p>
<p>　　若检查都失败，则脚本出错，不再继续运行。</p>
<p>　　脚本利用 <code>hg</code> 或 <code>git</code> 命令把未提交的这些修改导出为补丁备份到版本库根目录的 <code>bak.patch</code> ，然后使用这些内容调用 RevisionPatcher 取得文件和对应的新的版本号列表，最后使用 <code>sed</code> 查找对应文件并更新版本号。</p>
<p>　　脚本依赖 <code>sed</code> 命令。使用的 <code>sed</code> 应支持 <code>-b -i</code> 选项。可使用 Linux 或 MSYS2 的发行版中的 sed 4.8 程序。</p>
<p><strong>警告</strong> 某些 Win32 版本的 <code>sed</code> ，如 MSYS2 MinGW64 sed 4.4 可能损坏文本文件的行尾。有些替代版本可能解决<a href="https://stackoverflow.com/questions/4652652">这一问题</a>。</p>
<p><strong>注释</strong> 当前不检查特定版本 <code>sed</code> 对选项的支持。</p>
<p>　　若没有找到 <code>\version r</code> 模式的版本号前缀则忽略写入版本号。写入的版本号不影响换行符。</p>
<p><strong>注释</strong> 这个脚本可用于自动化。例如，在 Mercurial 仓库的 <code>hgrc</code> 的 <code>[hooks]</code> 节中添加 <code>precommit.PatchRevision = bash Tools/Scripts/PatchRevision.sh</code> 可在每次提交前调用这个脚本。在 YSLib 中，仅在主分支版本中启用。</p>
<h3 id="变量-patchbegin"><a class="header" href="#变量-patchbegin">变量 PatchBegin</a></h3>
<p>　　匹配版本号的起始行，应为一个表示行数的正整数。默认值为 <code>"1"</code> 。</p>
<h3 id="变量-patchend"><a class="header" href="#变量-patchend">变量 PatchEnd</a></h3>
<p>　　匹配版本号的结束行，应为一个表示行数的正整数。默认值为 <code>"20"</code> 。</p>
<h3 id="变量-revisionpatcher"><a class="header" href="#变量-revisionpatcher">变量 RevisionPatcher</a></h3>
<p>　　调用 RevisionPatcher 的命令。默认值为 <code>type -P RevisionPatcher</code> 的结果。</p>
<p><strong>注释</strong> 可执行文件可以在环境变量 <code>PATH</code> 中。</p>
<h3 id="变量-patchhg"><a class="header" href="#变量-patchhg">变量 PatchHg</a></h3>
<p>　　指定使用 Mercurial 。参见以上确定使用 Mercurial 或 Git 的说明。</p>
<h3 id="变量-patchgit"><a class="header" href="#变量-patchgit">变量 PatchGit</a></h3>
<p>　　指定使用 Git 。参见以上确定使用 Mercurial 或 Git 的说明。</p>
<h2 id="toolsscriptsshbuild-bootstrapsh"><a class="header" href="#toolsscriptsshbuild-bootstrapsh">Tools/Scripts/SHBuild-bootstrap.sh</a></h2>
<p>　　编译 <a href="SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 1 SHBuild</a> 时被包含的脚本。</p>
<p>　　脚本执行构建配置的环境初始化。其中指定静态链接需要依赖的 YSLib 源文件以及头文件路径等的必要变量。</p>
<p>　　脚本按需设置<a href="#stage-1-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">变量 <code>S1_BuildConf</code></a> 的值，以确保部分变量之后在包含 <a href="#toolsscriptsshbuild-yslibsh"><code>Tools/Scripts/SHBuild-YSLib.sh</code></a> 时能被按需初始化。默认值为 <code>stage1</code> 。</p>
<ul>
<li><strong>注释</strong> 有的脚本如 <a href="#toolsinstall-sysrootsh"><code>Tools/install-sysroot.sh</code></a> 在此之前应已初始化部分变量。其它脚本可能依赖这里的初始化。</li>
</ul>
<p>　　包含 <code>Tools/Scripts/SHBuild-YSLib.sh</code> 后，<a href="#toolsscriptsshbuild-yslibsh">被缓存的变量</a>的值可首先从持久存储的缓存文件中获取。</p>
<p>　　以下在这个脚本中可被使用的 stage 1 共享变量属于被缓存的变量：</p>
<ul>
<li><code>S1_Cached_quadmath</code> 支持使用 quadmath ，作为<a href="#stage-1-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">配置项</a>。</li>
</ul>
<p>　　配置结束后，通过调用<a href="#%E5%87%BD%E6%95%B0-shbuild_savecache">函数 SHBuild_SaveCache</a>写入所有被缓存的变量。</p>
<h2 id="toolsscriptsshbuild-buildsh"><a class="header" href="#toolsscriptsshbuild-buildsh">Tools/Scripts/SHBuild-build.sh</a></h2>
<p>　　编译 <a href="SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 1 SHBuild</a> 的脚本。</p>
<p>　　以下<a href="#%E5%85%AC%E5%85%B1%E6%9E%84%E5%BB%BA%E9%85%8D%E7%BD%AE%E5%8F%98%E9%87%8F">公共构建配置变量</a>影响脚本的特定行为：</p>
<ul>
<li><code>SS_NoParallel</code> 的作用当前包括：
<ul>
<li>不检查并行命令的可用性。</li>
<li>不使用并行命令构建。</li>
</ul>
</li>
<li><code>SS_Verbose</code> 的作用当前包括：
<ul>
<li>调用命令前回显。</li>
</ul>
</li>
</ul>
<p>　　使用变量 <code>SHBuild_Output</code> 指定输出路径。默认值为 <code>SHBuild</code> ，即在当前工作目录下生成名为 <code>SHBuild</code> 的可执行文件（视宿主平台不同可能带后缀如 Win32 带 <code>.exe</code> ）。</p>
<p>　　调用函数 <code>SHBuild_CheckPCH</code> 检查预编译头：若变量 <code>SHBuild_NoPCH</code> 非空则跳过预编译头，否则使用预编译头包含标准库头。预编译的头文件目标由 YBase 下的 <code>stdinc.h</code> ，之后构建时包含预编译头路径为 <code>$SHBuild_PCH_stdinc_h</code> 。后者的默认路径为当前工作目录下的 <code>stdinc.h</code> 。</p>
<p>　　因为升级或更换编译器和/或选项，可导致预编译头文件（ <code>.gch</code> 文件）不和生成的环境匹配而不被识别。</p>
<p><strong>注意</strong> 预编译头文件不保证对不同的操作系统版本兼容，参见<a href="../Prerequisitions.zh-CN.html">先决条件</a>中 PC(Win32) 平台关于操作系统版本的说明。</p>
<p>　　不被识别的预编译头文件通常：</p>
<ul>
<li>可引起编译器警告，并忽略预编译头文件。
<ul>
<li>若仅需避免产生警告，确保编译器命令行使用恰当选项，如添加 <code>-Wno-invalid-pch</code> 。</li>
</ul>
</li>
<li>可能引起无法构建的错误。</li>
</ul>
<p>　　一般仍然需要避免使用不匹配的预编译头文件。若无法保证预编译头文件和使用的工具链和选项匹配：</p>
<ul>
<li>可设置变量 <code>SHBuild_NoPCH</code> 的值非空以跳过预编译头文件的使用。</li>
<li>可以手动删除生成的预编译头文件。在没有设置变量 <code>SHBuild_NoPCH</code> 的情形下构建通常会默认自动生成。
<ul>
<li><strong>注释</strong> 具体的支持和生成预编译头文件的位置参见具体构建目标的说明，如 <a href="../Sysroot.zh-CN.html#%E6%9E%84%E5%BB%BA%E4%B8%AD%E9%97%B4%E6%96%87%E4%BB%B6">Sysroot</a> 。</li>
</ul>
</li>
</ul>
<p><strong>已知缺陷</strong> 构建时不自动更新预编译头。</p>
<p>　　除非环境变量 <code>SS_NoParallel</code> 的值非空，构建前可选地检查可用的并行命令。支持如下：</p>
<ul>
<li>支持 <a href="https://www.gnu.org/software/parallel/">GNU parallel</a> 命令 <code>parallel</code> 。</li>
<li>不支持 <a href="https://manpages.debian.org/testing/moreutils/parallel.1.en.html">moreutils <code>parallel</code></a> 且 <code>parallel</code> 命令的可用性会忽略。</li>
<li>不对并行数指定选项。
<ul>
<li><strong>原理</strong> 默认应已能充分使用宿主环境的计算资源。</li>
</ul>
</li>
</ul>
<h2 id="toolsscriptsshbuild-buildappsh"><a class="header" href="#toolsscriptsshbuild-buildappsh">Tools/Scripts/SHBuild-BuildApp.sh</a></h2>
<p>　　应用程序构建脚本。这个脚本被保留，不再具有实际功能。</p>
<p>　　<strong>这个脚本是公开的工具</strong>，被安装脚本部署。</p>
<h2 id="toolsscriptsshbuild-buildpkgsh"><a class="header" href="#toolsscriptsshbuild-buildpkgsh">Tools/Scripts/SHBuild-BuildPkg.sh</a></h2>
<p>　　包构建脚本。当前只支持构建应用程序，具体步骤和使用的参数参见 <a href="#toolsscriptsshbuild-buildapptxt"><code>Tools/Script/SHBuild-BuildApp.txt</code></a> 。</p>
<p>　　<strong>这个脚本是公开的工具</strong>，被安装脚本部署。</p>
<h2 id="toolsscriptsshbuild-commonsh"><a class="header" href="#toolsscriptsshbuild-commonsh">Tools/Scripts/SHBuild-common.sh</a></h2>
<p>　　被应用程序构建脚本包含的脚本，提供公共基础功能。</p>
<p>　　<strong>这个脚本是公开的工具</strong>，被安装脚本部署。</p>
<p><strong>注意</strong> 这个脚本包含 <code>INC_SHBuild_common</code> 守卫变量检查，默认重复包含只被执行一次。</p>
<h3 id="函数-shbuild_popd"><a class="header" href="#函数-shbuild_popd">函数 SHBuild_Popd</a></h3>
<p>　　同 <code>bash</code> 内建 <code>popd</code> 但不回显标准输出。</p>
<h3 id="函数-shbuild_pushd"><a class="header" href="#函数-shbuild_pushd">函数 SHBuild_Pushd</a></h3>
<p>　　同 <code>bash</code> 内建 <code>pushd</code> 但不回显标准输出。</p>
<h3 id="函数-shbuild_put"><a class="header" href="#函数-shbuild_put">函数 SHBuild_Put</a></h3>
<p>　　使用 <code>printf</code> 输出非格式字符串。</p>
<p>　　使用 <code>$*</code> 形式传递字符串，此时 <code>IFS</code> 是默认值。</p>
<h3 id="函数-shbuild_puts"><a class="header" href="#函数-shbuild_puts">函数 SHBuild_Puts</a></h3>
<p>　　使用 <code>printf</code> 输出非格式的换行的字符串。</p>
<p>　　使用 <code>$*</code> 形式传递字符串，此时 <code>IFS</code> 是默认值。</p>
<p>　　换行符由变量 <code>SHBuild_EOL</code> 指定。若值为空，则首先初始化为全局只读变量。当前默认值通过检查 <code>$COMSPEC</code> 是否定义，以确保 Windows 环境（包括 MSYS ）使用 CR+LF ，其它情况使用 LF 。</p>
<p>　　这个函数在可用时可用于代替 <code>echo</code> ，以取得对环境更好的适应性。</p>
<p><strong>注意</strong> 具体的检查逻辑实现可能在以后改变。</p>
<h3 id="函数-shbuild_puts_err"><a class="header" href="#函数-shbuild_puts_err">函数 SHBuild_Puts_Err</a></h3>
<p>　　同<a href="#%E5%87%BD%E6%95%B0-shbuild_puts">函数 <code>SHBuild_Puts</code></a>，但重定向标准输出到标准错误。</p>
<h3 id="函数-shbuild_puts_exit"><a class="header" href="#函数-shbuild_puts_exit">函数 SHBuild_Puts_Exit</a></h3>
<p>　　第一参数指定错误码，以之后的参数调用<a href="#%E5%87%BD%E6%95%B0-shbuild_puts_exit">函数 <code>SHBuild_Puts_Exit</code></a>，然后以错误码退出。</p>
<h3 id="函数-shbuild_puts_verbose"><a class="header" href="#函数-shbuild_puts_verbose">函数 SHBuild_Puts_Verbose</a></h3>
<p>　　当<a href="#%E5%85%AC%E5%85%B1%E6%9E%84%E5%BB%BA%E9%85%8D%E7%BD%AE%E5%8F%98%E9%87%8F">变量 <code>SS_Verbose</code></a> 的值非空时，调用<a href="#%E5%87%BD%E6%95%B0-shbuild_puts">函数 <code>SHBuild_Puts</code></a>。</p>
<h3 id="函数-shbuild_assertnonempty"><a class="header" href="#函数-shbuild_assertnonempty">函数 SHBuild_AssertNonempty</a></h3>
<p>　　断言第一参数为名称的变量非空，否则显示出错并退出。</p>
<p>　　使用 <code>eval</code> 实现。</p>
<h3 id="函数-shbuild_checkedcall"><a class="header" href="#函数-shbuild_checkedcall">函数 SHBuild_CheckedCall</a></h3>
<p>　　检查第一参数为名称的命令存在，否则显示出错并退出。</p>
<p>　　使用 <code>hash</code> 实现以优化性能。</p>
<h3 id="函数-shbuild_checkedcallsilent"><a class="header" href="#函数-shbuild_checkedcallsilent">函数 SHBuild_CheckedCallSilent</a></h3>
<p>　　同 SHBuild_CheckedCall ，但不显示错误外的标准输出。</p>
<h3 id="函数-shbuild_initreadonly"><a class="header" href="#函数-shbuild_initreadonly">函数 SHBuild_InitReadonly</a></h3>
<p>　　断言第一参数为名称的变量非空，若空则使用 <code>eval</code> 对后续求值并初始化第一参数指定的只读变量。</p>
<p>　　初始化时在当前 shell 中求值初值。</p>
<p>　　若发生初始化且<a href="#%E5%85%AC%E5%85%B1%E6%9E%84%E5%BB%BA%E9%85%8D%E7%BD%AE%E5%8F%98%E9%87%8F">变量 <code>SS_Verbose</code></a> 的值非空，则在标准输出中显示。</p>
<p><strong>已知限制</strong> 当前实现使用临时文件 <code>/tmp/InitReadonly</code> 暂存作为初值的调用结果。需确保这个临时文件所在的目录和这个文件可写。</p>
<p><strong>原理</strong></p>
<p>　　保证当前 shell 中求值允许初值中调用可能修改当前 shell 环境的 shell 函数。这使一个 <code>SHBuild_InitReadonly</code> 调用中，间接的嵌套调用可使用先前已通过同一个调用者初始化的变量。</p>
<h3 id="函数-shbuild_2m"><a class="header" href="#函数-shbuild_2m">函数 SHBuild_2m</a></h3>
<p>　　接受 1 个表示路径的参数，调用 <code>cygpath</code> 转换路径到 Windows 混合风格路径。</p>
<p>　　当 <code>cygpath</code> 不存在时返回原路径。</p>
<h3 id="函数-shbuild_2u"><a class="header" href="#函数-shbuild_2u">函数 SHBuild_2u</a></h3>
<p>　　接受 1 个表示路径的参数。</p>
<p>　　调用 <code>cygpath</code> 转换 Windows 路径到 UNIX 路径。</p>
<p>　　当 <code>cygpath</code> 不存在时返回原路径。</p>
<h3 id="函数-shbuild_echoescape"><a class="header" href="#函数-shbuild_echoescape">函数 SHBuild_EchoEscape</a></h3>
<p>　　当标准输出使用终端时调用 <code>echo -ne</code> 输出参数指定的 ANSI 转义序列。</p>
<p><strong>已知缺陷</strong> 不检查 <code>$TERM</code> 支持。</p>
<h3 id="函数-shbuild_echostring"><a class="header" href="#函数-shbuild_echostring">函数 SHBuild_EchoString</a></h3>
<p>　　接受 2 个参数，输出转义序列指定格式的内容，包含以下步骤：</p>
<ul>
<li>使用 <code>SHBuild_EchoEscape</code> 输出第二参数指定的转义序列。</li>
<li>使用 <code>SHBuild_Put</code> 输出第一参数的内容。</li>
<li>使用 <code>SHBuild_EchoEscape</code> 输出复位格式的转义序列。</li>
</ul>
<h3 id="函数-shbuild_echovar"><a class="header" href="#函数-shbuild_echovar">函数 SHBuild_EchoVar</a></h3>
<p>　　接受 2 个参数 <code>x</code> 和 <code>y</code> ，以特定颜色显示为 <code>x = "$y"</code> 的形式，其中 <code>$y</code> 是 <code>y</code> 的值。</p>
<p>　　第二参数一般是字符串。</p>
<h3 id="函数-shbuild_echovar_n"><a class="header" href="#函数-shbuild_echovar_n">函数 SHBuild_EchoVar_N</a></h3>
<p>　　接受 1 个参数 <code>x</code> ，调用 <code>SHBuild_EchoVar</code> 显示为 <code>x = $x</code> 的形式。</p>
<p>　　右侧求值时会替换参数中的 <code>.</code> 为 <code>_</code> 。</p>
<p>　　参数一般是字符串。</p>
<h3 id="函数-shbuild_echovara"><a class="header" href="#函数-shbuild_echovara">函数 SHBuild_EchoVarA</a></h3>
<p>　　接受 2 个参数 <code>x</code> 和 <code>y</code> ，以特定颜色显示为 <code>x = ($y)</code> 的形式，其中 <code>$y</code> 是 <code>y</code> 的值。</p>
<p>　　第二参数一般是数组。</p>
<h3 id="函数-shbuild_echovara_n"><a class="header" href="#函数-shbuild_echovara_n">函数 SHBuild_EchoVarA_N</a></h3>
<p>　　接受 1 个参数 <code>x</code> ，调用 <code>SHBuild_EchoVarA</code> 显示为 <code>x = $x</code> 的形式。</p>
<p>　　右侧求值时会替换参数中的 <code>.</code> 为 <code>_</code> 。</p>
<p>　　参数一般是数组。</p>
<h3 id="函数-shbuild_checkuname"><a class="header" href="#函数-shbuild_checkuname">函数 SHBuild_CheckUName</a></h3>
<p>　　调用 <code>SHBuild_CheckedCall</code> 按需初始化只读变量 <code>SHBuild_Env_OS</code> 和 <code>SHBuild_Env_Arch</code> 的值。</p>
<p>　　变量 <code>SHBuild_Env_OS</code> 的值通过分类系统的值（一般即 <code>SHBuild_Env_uname</code> 的值）标识操作系统：</p>
<ul>
<li><code>OS_X</code> ：输入匹配 <code>*Darwin*</code> ，用于标识 OS X 系统。</li>
<li><code>Win32</code> ：输入匹配 <code>*MINGW*</code> 或 <code>*MSYS*</code> ，用于标识 Windows 系统。</li>
<li><code>Linux</code> ：输入匹配 <code>*Linux*</code> ，用于标识 Linux 系统。</li>
<li><code>unknown</code> ：不支持的系统。</li>
</ul>
<p>　　变量 <code>SHBuild_Env_Arch</code> 的值通过分类输入的处理器体系结构的值（一般即 <code>SHBuild_Env_uname_m</code> 的值）标识体系结构：</p>
<ul>
<li><code>x86_64</code> ：输入匹配 <code>x86_64</code> 或 <code>i*86-64</code> 。</li>
<li><code>i*86</code> ：输入匹配 <code>i*86</code> ，使用原值。</li>
<li><code>aarch64</code> ：输入是 <code>aarch64</code> 。</li>
<li><code>unknown</code> ：不支持的体系结构。</li>
</ul>
<p>　　若同时指定环境变量 <code>SHBuild_Env_Arch</code> 和 <code>SHBuild_Env_OS</code> ，不进行<a href="../Prerequisitions.zh-CN.html">自动环境检测</a>，不依赖 <code>uname</code> 。</p>
<h3 id="函数-shbuild_gettempdir"><a class="header" href="#函数-shbuild_gettempdir">函数 SHBuild_GetTempDir</a></h3>
<p>　　取临时目录的路径。</p>
<p>　　依次检查以下环境变量的值，若非空则作为结果：</p>
<ul>
<li><code>TMPDIR</code></li>
<li><code>TEMP</code></li>
<li><code>TMP</code></li>
</ul>
<p>　　若这些环境变量都没有非空值，则使用经过 <code>SHBuild_2m</code> 转换的 <code>/tmp</code>（被 <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap10.html#tag_10_01">POSIX.1 要求支持</a>）作为结果。</p>
<p><strong>注意</strong> 以上过程在所有平台上都一致。这是自适应环境的基本接口，因此不对环境变量的值的合法性进行判断。若结果不表示一个可访问的目录，在访问以此构造的文件路径时可能引发错误。应用程序一般需自行检查或保证使用的环境中这些路径可访问。</p>
<p><strong>说明</strong> 以上检查中，支持的环境变量符合<a href="https://en.wikipedia.org/wiki/TMPDIR">惯例(en-US)</a> 。检查环境变量的顺序（偶然地）和一些类似功能的实现（如 <a href="https://dev.mysql.com/doc/refman/8.0/en/temporary-files.html">MySQL 在 Windows 上</a>）一致，和其它一些特定平台的 API（如 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-gettemppathw">Win32 API</a> ）及另一些不作为公开行为的实现（如 <a href="https://gcc.gnu.org/onlinedocs/gcc-4.8.5/libiberty/Functions.html#index-choose_005ftmpdir-66">libiberty 的 <code>choose_tmpdir</code></a> ）可能不一致。被支持的环境变量可用性举例：</p>
<ul>
<li><code>TMPDIR</code> ：<a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html">POSIX.1 要求的环境变量</a> 。</li>
<li><code>TEMP</code> ：被 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-gettemppathw">Win32 文件 API</a> 等使用。</li>
<li><code>TMP</code> ：被 Win32 文件 API 和 <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/tempnam-wtempnam-tmpnam-wtmpnam?view=msvc-160">Microsoft C 运行时 API</a> 等使用。</li>
<li>另见<a href="https://devblogs.microsoft.com/oldnewthing/20150417-00/?p=44213">对 MS-DOS 和 Microsoft Windows 使用的临时目录环境变量解释</a>。</li>
</ul>
<p><strong>已知限制</strong> 不检查路径是否表示实际可写的目录。另见文件访问约定。</p>
<p>　　当前脚本实现假定临时目录可写，不满足条件时，文件操作可能失败。脚本使用的临时文件前也不保证检查文件可写。若此文件不可写（例如，在之前被 <code>root</code> 等高权限用户创建），则依赖文件可写的操作可能失败。对构建脚本，这可能导致依赖临时文件进行检查判断失效，而使错误的选项被使用。</p>
<p>　　一般地，脚本可使用特定的例程（如 Shell 脚本可选地使用<a href="https://stackoverflow.com/questions/2792675">在许多环境中可用的 <code>mktemp</code> 命令</a>）随机化文件名减少冲突。若需要更可靠地避免上述问题，可在运行脚本前清理临时目录，或预先设置 <code>SHBuild_GetTempDir</code> 访问的环境变量指定确保可写的空目录，同时避免并发调用脚本导致不安全并发访问此目录中的临时文件。脚本不使用其它方法确定直接使用的临时目录，但脚本间接调用的外部工具仍可能导致不安全的访问，而无法保证可靠。</p>
<h3 id="函数-shbuild_platform_detect"><a class="header" href="#函数-shbuild_platform_detect">函数 SHBuild_Platform_Detect</a></h3>
<p>　　通过参数指定的操作系统和体系结构名，结合环境变量，确定平台名称，检查非空并返回。</p>
<p>　　第一和第二参数分别指定操作系统名和体系结构名，接受的取值参见<a href="#%E5%87%BD%E6%95%B0-shbuild_checkuname">函数 <code>SHBuild_CheckUName</code></a> 。</p>
<p>　　当前 <code>Win32</code> 系统外的结果和 <code>SHBuild_CheckUName</code> 初始化 <code>SHBuild_Env_OS</code> 的结果一致。处理如下：</p>
<ul>
<li>若操作系统名为 <code>Win32</code> ：
<ul>
<li>若环境变量 <code>MSYSTEM</code> 设置为 <a href="https://www.msys2.org/docs/environments/">MSYS2 支持的环境</a>，结果对应如下：
<ul>
<li><code>MINGW64</code>：<code>MinGW64</code> 。</li>
<li><code>MINGW32</code>：<code>MinGW32</code> 。</li>
<li><code>CLANG64</code>：<code>MinGW_Clang64</code> 。</li>
<li><code>CLANG32</code>：<code>MinGW_UCRT64</code> 。</li>
<li><code>CLANGARM64</code>：<code>MinGW_ClangARM64</code> 。</li>
<li><code>UCRT64</code>：<code>MinGW_UCRT64</code> 。</li>
</ul>
</li>
<li>否则，若体系结构为 <code>x86_64</code> ，则结果为 <code>MinGW64</code> 。</li>
<li>否则，结果为 <code>MinGW32</code> 。</li>
</ul>
</li>
<li>否则，结果为操作系统名。</li>
</ul>
<h3 id="函数-shbuild_preparebuild"><a class="header" href="#函数-shbuild_preparebuild">函数 SHBuild_PrepareBuild</a></h3>
<p>　　准备构建环境。按以下方式初始化变量使之具有非空值：</p>
<ul>
<li>调用<a href="#%E5%87%BD%E6%95%B0-shbuild_gettempdir">函数 <code>SHBuild_GetTempDir</code></a> 初始化 <code>SHBuild_Env_TempDir</code> 。</li>
<li>调用<a href="#%E5%87%BD%E6%95%B0-shbuild_checkuname">函数 <code>SHBuild_CheckUName</code></a> 初始化 <code>SHBuild_Env_OS</code> 和 <code>SHBuild_Env_Arch</code> 。</li>
<li>初始化 <code>SHBuild_Host_OS</code> 为 <code>SHBuild_Env_OS</code> 的值。</li>
<li>当变量 <code>SHBuild_Host_OS</code> 的值是 <code>Win32</code> 时，且环境变量 <code>MSYSTEM</code> 的值是 <a href="https://www.msys2.org/docs/environments/">MSYS2 支持的环境</a>支持的值，初始化 <code>SHBuild_Host_Arch</code> 对应的目标体系结构；否则，初始化 <code>SHBuild_Host_Arch</code> 为 <code>SHBuild_Env_Arch</code> 的值。</li>
</ul>
<h3 id="函数-shbuild_getbuildname"><a class="header" href="#函数-shbuild_getbuildname">函数 SHBuild_GetBuildName</a></h3>
<p>　　取用于进一步初始化构建路径的构建名称。</p>
<p>　　首先调用<a href="#%E5%87%BD%E6%95%B0-shbuild_preparebuild">函数 <code>SHBuild_PrepareBuild</code></a> 按需初始化变量 <code>SHBuild_Env_Arch</code> 和 <code>SHBuild_Env_OS</code> 为非空值。</p>
<p>　　结果为以变量 <code>SHBuild_Env_OS</code> 和 <code>SHBuild_Env_Arch</code> 的值作为参数调用<a href="#%E5%87%BD%E6%95%B0-shbuild_platform_detect">函数 <code>SHBuild_Platform_Detect</code></a> 的结果。</p>
<h3 id="函数-shbuild_buildgch"><a class="header" href="#函数-shbuild_buildgch">函数 SHBuild_BuildGCH</a></h3>
<p>　　构建 GNU 预编译头文件，依次执行：</p>
<ul>
<li>以第二参数指定的路径附加 <code>.gch</code> 后缀确定输出路径。</li>
<li>检查输出路径是否已存在文件，若存在则视为目标已被构建，输出消息并跳过以下步骤。</li>
<li>确保输出路径所在的目录被创建。</li>
<li>输出开始构建的消息。</li>
<li>硬链接第一参数指定输入的头文件路径到第二参数指定的安装路径。</li>
<li>按第一参数指定的输入路径和输出路径调用第三个参数指定构建命令。</li>
<li>输出构建完成的消息。</li>
</ul>
<p><strong>已知限制</strong> 构建命令仅支持 GNU 兼容工具链。</p>
<h3 id="函数-shbuild_checkpch"><a class="header" href="#函数-shbuild_checkpch">函数 SHBuild_CheckPCH</a></h3>
<p>　　检查和按需构建 GNU 预编译头文件并设置变量，依次执行：</p>
<ul>
<li>检查变量 <code>SHBuild_NoPCH</code> 的值，若为空值，则：
<ul>
<li>以第一参数、第二参数和 <code>$CXX -xc++-header $CXXFLAGS</code> 调用 <code>SHBuild_BuildGCH</code> 生成 GNU 风格预编译头文件。</li>
<li>设置内部变量 <code>SHBuild_IncPCH</code> 为合适的命令行选项的数组（以 <code>"-include"</code> 和头文件名作为其元素）用于包含生成的预编译头文件。</li>
</ul>
</li>
<li>否则：
<ul>
<li>输出跳过消息。</li>
<li>设置 <code>SHBuild_IncPCH</code> 的值为空数组。</li>
</ul>
</li>
</ul>
<p><strong>已知限制</strong> 构建命令仅支持 GNU 兼容工具链。</p>
<h3 id="函数-shbuild_2w"><a class="header" href="#函数-shbuild_2w">函数 SHBuild_2w</a></h3>
<p>　　接受 1 个表示路径的参数，调用 <code>cygpath</code> 转换 UNIX 路径到 Windows 路径。</p>
<p>　　当 <code>cygpath</code> 不存在时返回原路径。</p>
<h3 id="函数-shbuild_install"><a class="header" href="#函数-shbuild_install">函数 SHBuild_Install</a></h3>
<p>　　接受 2 个表示路径的参数，安装前者指定的文件到后者。</p>
<p>　　首先调用 <code>rsync</code> ，若失败调用 <code>cp</code> 。</p>
<p><strong>注意</strong> 防火墙可能导致 <code>rsync</code> 超时失败。</p>
<h3 id="函数-shbuild_installdir"><a class="header" href="#函数-shbuild_installdir">函数 SHBuild_InstallDir</a></h3>
<p>　　接受 2 个表示路径的参数，安装前者指定的目录到后者。</p>
<p>　　首先调用 <code>rsync</code> ，若失败调用 <code>cp</code> 。</p>
<p><strong>注意</strong> 防火墙可能导致 <code>rsync</code> 超时失败。</p>
<h3 id="函数-shbuild_install_exe"><a class="header" href="#函数-shbuild_install_exe">函数 SHBuild_Install_Exe</a></h3>
<p>　　接受 2 个表示路径的参数，安装前者指定的可执行文件到后者。</p>
<p>　　首先调用 <code>SHBuild_Install</code> ，然后在目标上设置可执行权限。</p>
<h3 id="函数-shbuild_install_hardlink"><a class="header" href="#函数-shbuild_install_hardlink">函数 SHBuild_Install_HardLink</a></h3>
<p>　　接受 2 个表示路径的参数，安装前者指定的文件到后者为硬链接。</p>
<p>　　首先删除目标，其次调用 Windows 命令解释器的 <code>mklink</code> ，若失败调用 <code>ln</code> 。</p>
<h3 id="函数-shbuild_install_hardlink_exe"><a class="header" href="#函数-shbuild_install_hardlink_exe">函数 SHBuild_Install_HardLink_Exe</a></h3>
<p>　　接受 2 个表示路径的参数，安装前者指定的可执行文件到后者为硬链接。</p>
<p>　　首先调用 <code>SHBuild_Install_HardLink</code> ，然后在目标上设置可执行权限。</p>
<p><strong>注意</strong> <code>mklink</code> 需要 Windows Vista 后的命令解释器(<code>cmd</code>) 的支持。硬链接需要文件系统（如 NTFS ）支持。</p>
<h3 id="函数-shbuild_install_link"><a class="header" href="#函数-shbuild_install_link">函数 SHBuild_Install_Link</a></h3>
<p>　　接受 2 个表示路径的参数，安装前者指定的文件到后者为符号链接。</p>
<p>　　首先删除目标，其次调用 Windows 命令解释器的 <code>mklink</code> ，若失败调用 <code>ln</code> 。</p>
<p><strong>注意</strong> <code>mklink</code> 需要 Windows Vista 后的命令解释器(<code>cmd</code>) 的支持。符号链接需要文件系统（如 NTFS ）支持。权限不足可能导致 <code>mklink</code> 创建符号链接失败，可在组策略改变相关默认行为。在一些版本的系统上，可能需要<a href="https://support.microsoft.com/en-us/kb/2856739/en-us">进一步的配置</a>以通过链接执行文件。</p>
<h3 id="函数-shbuild_loadcache"><a class="header" href="#函数-shbuild_loadcache">函数 SHBuild_LoadCache</a></h3>
<p>　　加载环境缓存。</p>
<p>　　函数接收 2 个参数，分别是缓存文件路径和被缓存的变量名的正则表达式模式的数组。</p>
<p>　　<a href="#stage-1-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">变量 <code>S1_CacheMode</code></a> 可配置模式控制缓存行为：</p>
<ul>
<li>若配置忽略，则无作用。</li>
<li>否则加载缓存。</li>
</ul>
<p>　　加载缓存通过解析文件内容验证后包含实现。</p>
<p>　　文件的内容应为可执行的 shell 赋值代码。当前检查支持的格式如下：</p>
<ul>
<li>每行一个条目，忽略首尾空白符。</li>
<li>若条目的形式是 <code>if ... then; ASSIGNMENT; fi</code> ，简化为 <code>ASSIGNMENT</code> 进行下一步检查，忽略其余部分。</li>
<li>进一步地，若条目的形式是 <code>declare -X VAR=...</code> ，其中 <code>X</code> 是匹配正则表达式模式 <code>(-|[Aagirx]+)</code> 的属性之一，简化为 <code>VAR</code> 进行下一步检查，忽略其余部分。
<ul>
<li><strong>注释</strong> 作为全局变量，<code>declare</code> 条目一般应具有 <code>-g</code> 属性，否则声明为局部变量，实际没有加载配置。</li>
</ul>
</li>
<li>进一步地，<code>VAR</code> 应为合法的标识符，匹配正则表达式模式 <code>[A-Za-z_][A-Za-z_0-9]*</code> 。</li>
</ul>
<p>　　若任意检查失败，则缓存格式无效，内容不会被加载；否则，包含缓存文件，以执行其中的赋值代码。</p>
<p>　　函数的返回值如下：</p>
<ul>
<li><code>0</code> ：成功。</li>
<li><code>1</code> ：内容无效。</li>
<li><code>2</code> ：指定的缓存文件无法读取。</li>
</ul>
<h3 id="函数-shbuild_savecache"><a class="header" href="#函数-shbuild_savecache">函数 SHBuild_SaveCache</a></h3>
<p>　　保存环境缓存。</p>
<p>　　函数接受的参数及其含义和<a href="#%E5%87%BD%E6%95%B0-shbuild_loadcache">函数 <code>SHBuild_LoadCache</code></a> 一致。</p>
<p>　　<a href="#stage-1-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">变量 <code>S1_CacheMode</code></a> 可配置缓存模式控制缓存行为：</p>
<ul>
<li>若配置忽略，则无作用。</li>
<li>若缓存模式配置为清除缓存文件则删除缓存文件。</li>
<li>否则保存缓存。</li>
</ul>
<p>　　保存缓存操作如下：</p>
<ul>
<li>打开并清空缓存文件。</li>
<li>若缓存模式配置为清除缓存内容则打开文件成功时直接视为成功。</li>
<li>否则，继续解析 <code>declare -p</code> 结果，把其中变量名匹配第二参数中任意的正则表达式且内容满足函数 <code>SHBuild_LoadCache</code> 格式要求的行写入指定的缓存文件。
<ul>
<li>写入前，替换内容中的 <code>declare --</code> 或 <code>declare -</code> 为 <code>declare -g</code> 以确保声明全局变量。</li>
<li><strong>注释</strong> 不要求支持 <code>declare -p</code> 结果中的所有变量属性。不支持的属性被忽略。</li>
</ul>
</li>
</ul>
<p>　　函数的返回值如下：</p>
<ul>
<li><code>0</code> ：成功。</li>
<li><code>2</code> ：指定的缓存文件无法写入。</li>
</ul>
<h3 id="函数-shbuild_getsystemprefix"><a class="header" href="#函数-shbuild_getsystemprefix">函数 SHBuild_GetSystemPrefix</a></h3>
<p>　　转换参数指定的平台名称字符串为系统前缀字符串。</p>
<p>　　系统前缀用于在文件系统中安装部署。</p>
<p>　　通常系统前缀因为之前仍有非空的其它前缀（如 <a href="../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><code>SHBuild_SysRoot</code></a> 指定的值）而不是绝对路径的前缀。因此，系统前缀以 <code>/</code> 起始而不需要考虑所在的环境是否符合<a href="../Run.zh-CN.html#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80">局部 FHS 目录布局</a> 的问题。</p>
<p>　　当前支持的结果包括：</p>
<ul>
<li>参数为 <code>MinGW64</code> 时，结果为 <code>/mingw64</code> 。</li>
<li>参数为 <code>MinGW32</code> 时，结果为 <code>/mingw32</code> 。</li>
<li>否则，结果为 <code>/usr</code> 。</li>
</ul>
<p>　　本函数的结果支持 <a href="../Sysroot.zh-CN.html#%E5%B8%83%E5%B1%80">Sysroot 的目录布局</a>。</p>
<p><strong>注释</strong> 参数典型地来自调用<a href="#%E5%87%BD%E6%95%B0-shbuild_platform_detect">函数 <code>SHBuild_Platform_Detect</code></a> 的结果。</p>
<h3 id="函数-shbuild_s1_initconf"><a class="header" href="#函数-shbuild_s1_initconf">函数 SHBuild_S1_InitConf</a></h3>
<p>　　初始化 <a href="../Sysroot.zh-CN.html">stage 1 Sysroot</a> 构建配置，依次执行：</p>
<ul>
<li>断言<a href="../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">变量 <code>SHBuild_ToolDir</code></a> 非空。</li>
<li>按需初始化<a href="../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">变量 <code>YSLib_BaseDir</code></a> ，默认值为 <code>"$SHBuild_ToolDir/../.."</code> 。
<ul>
<li><strong>注释</strong> Stage 1 环境下总是可通过脚本所在目录推断 YSLib 源代码和存储库中的其它源文件的位置。</li>
</ul>
</li>
<li>尝试以切换当前目录的方式访问 <code>$YSLib_BaseDir</code> 。</li>
<li>按需初始化<a href="../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">变量 <code>SHBuild_BuildDir</code></a> ，默认值为 YSLib 版本库根目录下的 <code>build/$(SHBuild_GetBuildName)</code> 。</li>
<li>确保变量 <code>SHBuild_BuildDir</code> 指定的目录被创建，并尝试以切换当前目录的方式访问。</li>
<li>若<a href="#stage-1-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">变量 <code>S1_BuildDir</code></a> 的值为空，断言<a href="#stage-1-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">变量 <code>S1_BuildConf</code></a> 的值非空。
<ul>
<li><strong>注释</strong> 这排除以下的初始化默认值使用非预期路径。</li>
</ul>
</li>
<li>按需初始化变量 <code>S1_BuildDir</code> ，默认值为 <code>"$SHBuild_BuildDir/.$S1_BuildConf"</code> 。</li>
<li>按需初始化<a href="#stage-1-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">变量 <code>S1_DistDir</code></a> ，默认值为 <code>"$S1_BuildDir/.stage1"</code> 。</li>
<li>按需初始化<a href="#stage-1-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">变量 <code>S1_SHBuild</code></a> ，默认值为 <code>"$S1_DistDir/SHBuild"</code> 。</li>
<li>确保变量 <code>S1_BuildDir</code> 指定的目录被创建，并尝试以切换当前目录的方式访问。</li>
<li>确保变量 <code>S1_DistDir</code> 指定的目录被创建，并尝试以切换当前目录的方式访问。</li>
</ul>
<p>　　以上变量初始化后只读。</p>
<h3 id="函数-shbuild_s2_prepare"><a class="header" href="#函数-shbuild_s2_prepare">函数 SHBuild_S2_Prepare</a></h3>
<p>　　准备 <a href="../Sysroot.zh-CN.html">stage 2 Sysroot</a> 环境，依次执行：</p>
<ul>
<li>确保变量 <code>SHBuild_SysRoot</code> 的初始化。
<ul>
<li>使用第一参数作为这个变量的默认值。若这个变量未被设置，则以默认值赋值。</li>
</ul>
</li>
<li>断言这个变量的值非空，以其值作为创建目录，若指定的目录已存在则忽略。</li>
<li>初始化变量 <code>SHBuild_SystemPrefix</code> 。
<ul>
<li><strong>注释</strong> 参见 <a href="#toolsscriptsshbuild-yslib-buildtxt"><code>Tools/Scripts/SHBuild-YSLib-build.txt</code></a> 的说明。</li>
</ul>
</li>
<li>初始化变量 <code>SR_Prefix</code> 的值为 <code>"$SHBuild_SysRoot$SHBuild_SystemPrefix"</code> 。</li>
</ul>
<h3 id="函数-shbuild_s2_prepare_build"><a class="header" href="#函数-shbuild_s2_prepare_build">函数 SHBuild_S2_Prepare_Build</a></h3>
<p>　　准备 stage 2 Sysroot 构建环境，依次执行</p>
<ul>
<li>以第一参数调用 <code>SHBuild_S2_Prepare</code> 。</li>
<li>导出变量 <code>SHBuild</code> 的值为 <code>"$SR_Prefix/bin/SHBuild"</code> 。</li>
</ul>
<h2 id="toolsscriptsshbuild-common-optionssh"><a class="header" href="#toolsscriptsshbuild-common-optionssh">Tools/Scripts/SHBuild-common-options.sh</a></h2>
<p>　　被应用程序构建脚本包含的基础功能，提供默认的编译器和链接器命令行选项。</p>
<p>　　若某个变量提供默认值且执行脚本时没有非空值，则设置为脚本提供的默认值。</p>
<p>　　<strong>这个脚本是公开的工具</strong>，被安装脚本部署。</p>
<p>　　包含 <code>Tools/Scripts/SHBuild-common-toolchain.sh</code> 确定工具链。</p>
<p><strong>注意</strong> G++ 和 Clang++ 不完全兼容。以下部分变量通过 <code>Tools/Scripts/SHBuild-common-toolchain.sh</code> 中的例程判断 G++ 和 Clang ，并自动使用不同的选项默认值。因此直接通过名称和符号链接等方式伪装会失效而可能导致错误。</p>
<p>　　以下所有变量仅在外部环境设置为空或未设置时提供默认值，按顺序被指定。可在外部设置为非空值以避免被本脚本中的值覆盖。以下仅列出部分相对不容易变动的默认值，其它默认值参见脚本源代码。若不需要默认值，可以提前设置非空值或在 <code>.</code> 指令后直接设置其它（可能为空的）值。</p>
<h3 id="变量-shbuild_debug"><a class="header" href="#变量-shbuild_debug">变量 SHBuild_Debug</a></h3>
<p>　　默认值为空。</p>
<p>　　非空时，指定变量的值：</p>
<pre><code class="language-shell">CXXFLAGS_OPT_DBG='-O0 -g -D_GLIBCXX_DEBUG_PEDANTIC'
LDFLAGS_OPT_DBG=' '
</code></pre>
<h3 id="变量-c_cxxflags_gc"><a class="header" href="#变量-c_cxxflags_gc">变量 C_CXXFLAGS_GC</a></h3>
<p>　　C/C++ 编译器生成二进制节 GC 选项。</p>
<p>　　默认值为 <code>-fdata-sections -ffunction-sections</code> 。</p>
<p>　　设置后会被检查是否支持，参见下文。</p>
<h3 id="变量-ldflags_gc"><a class="header" href="#变量-ldflags_gc">变量 LDFLAGS_GC</a></h3>
<p>　　链接器生成二进制节 GC 选项。</p>
<p>　　默认值为 <code>-Wl,--gc-sections</code> 。</p>
<p>　　设置后会和 <code>C_CXXFLAGS_GC</code> 通过 <code>$CXX</code> 作为编译器编译链接简单程序测试是否支持。若不支持，此变量和 <code>C_CXXFLAGS_GC</code> 都会被置空。</p>
<p><strong>已知限制</strong> <a href="http://sourceforge.net/p/msys2/discussion/general/thread/2d6adff2/?limit=25">Windows 上的工具链可能缺乏 <code>/dev/null</code> 的必要支持</a>，因此此项检查使用的输出路径指定为 <code>/tmp/null</code> 。</p>
<h3 id="变量-c_cxxflags_pic"><a class="header" href="#变量-c_cxxflags_pic">变量 C_CXXFLAGS_PIC</a></h3>
<p>　　C 和 C++ 编译器共用的 PIC （ Position Independent Code ，位置无关代码）生成选项。</p>
<p>　　默认值在 Win32 上为空，其它平台上为 <code>-fPIC -fno-semantic-interposition</code> 。</p>
<p>　　用于保证生成的对象文件可被用于生成动态库。</p>
<h3 id="变量-ldflags_strip"><a class="header" href="#变量-ldflags_strip">变量 LDFLAGS_STRIP</a></h3>
<p>　　链接器剥离符号选项。</p>
<p>　　默认值为 <code>-s</code> 。</p>
<h3 id="变量-c_cxxflags_ext"><a class="header" href="#变量-c_cxxflags_ext">变量 C_CXXFLAGS_EXT</a></h3>
<p>　　指定 C/C++ 语言扩展的选项。</p>
<p>　　默认值和平台相关：若为 Win32 环境则为空，否则为 <code>-D_POSIX_C_SOURCE=200809L</code> 。</p>
<p><strong>注释</strong> 若实现环境没有提供适当的宏定义，YFramework 中使用 POSIX 平台文件系统 API 的实现要求不被满足而可能构建失败。</p>
<h3 id="变量-c_cxxflags_arch"><a class="header" href="#变量-c_cxxflags_arch">变量 C_CXXFLAGS_ARCH</a></h3>
<p>　　C 和 C++ 编译器共用的体系结构相关选项。</p>
<p>　　默认值为空。</p>
<p>　　不限制具体形式，使用 G++ 时可以是 <code>-march=native</code> 。</p>
<h3 id="变量-c_cxxflags_common"><a class="header" href="#变量-c_cxxflags_common">变量 C_CXXFLAGS_COMMON</a></h3>
<p>　　C 和 C++ 编译器共用的公共选项。</p>
<p>　　默认值为 <code>-pipe $C_CXXFLAGS_GC $C_CXXFLAGS_ARCH -pedantic-errors $C_CXXFLAGS_EXT</code> 。</p>
<h3 id="变量-c_cxxflags_opt_lv"><a class="header" href="#变量-c_cxxflags_opt_lv">变量 C_CXXFLAGS_OPT_LV</a></h3>
<p>　　C 和 C++ 编译器优化等级选项。</p>
<p>　　默认值为 <code>-O3</code> 。</p>
<h3 id="函数-shbuild_get_c_cxxflags_warning"><a class="header" href="#函数-shbuild_get_c_cxxflags_warning">函数 SHBuild_Get_C_CXXFLAGS_WARNING</a></h3>
<p>　　取 C 和 C++ 编译器共用的警告命令行选项的默认值。</p>
<p>　　结果包括以下列表中的内容：</p>
<ul>
<li><code>-Wall</code></li>
<li><code>-Wcast-align</code></li>
<li><code>-Wdeprecated</code></li>
<li><code>-Wdeprecated-declarations</code></li>
<li><code>-Wdouble-promotion</code></li>
<li><code>-Wextra</code></li>
<li><code>-Wfloat-equal</code></li>
<li><code>-Wformat=2</code></li>
<li><code>-Winvalid-pch</code></li>
<li><code>-Wlogical-op</code></li>
<li><code>-Wmissing-declarations</code></li>
<li><code>-Wmissing-include-dirs</code></li>
<li><code>-Wmultichar</code></li>
<li><code>-Wno-format-nonliteral</code></li>
<li><code>-Wredundant-decls</code></li>
<li><code>-Wshadow</code></li>
<li><code>-Wsign-conversion</code></li>
<li><code>-Wstringop-overflow=0</code></li>
<li><code>-Wsuggest-attribute=const</code></li>
<li><code>-Wsuggest-attribute=noreturn</code></li>
<li><code>-Wsuggest-attribute=pure</code></li>
<li><code>-Wtrampolines</code></li>
</ul>
<p>　　通过检查 C++ 编译器和版本已知不支持的选项会被替换为其它功能近似的选项或被排除。</p>
<p><strong>注释</strong> 当前仅检查 C++ 编译器，假定 C 编译器和 C++ 编译器版本对应一致（即 G++ 蕴含 GCC ，Clang++ 蕴含 Clang ）。</p>
<h3 id="变量-c_cxxflags_warning"><a class="header" href="#变量-c_cxxflags_warning">变量 C_CXXFLAGS_WARNING</a></h3>
<p>　　C 和 C++ 编译器共用的警告命令行选项。</p>
<p>　　默认值是调用<a href="#%E5%87%BD%E6%95%B0-shbuild_get_c_cxxflags_warning">函数 <code>SHBuild_Get_C_CXXFLAGS_WARNING</code></a> 得到的值。</p>
<h3 id="变量-c_cxxflags_impl_warning"><a class="header" href="#变量-c_cxxflags_impl_warning">变量 C_CXXFLAGS_IMPL_WARNING</a></h3>
<p>　　和特定实现相关的 C 和 C++ 编译器共用的警告命令行选项。</p>
<p>　　默认值为空值。</p>
<h3 id="变量-cxxflags_impl_warning"><a class="header" href="#变量-cxxflags_impl_warning">变量 CXXFLAGS_IMPL_WARNING</a></h3>
<p>　　和特定实现相关的 C++ 编译器警告命令行选项。</p>
<p>　　默认值为空值。</p>
<h3 id="变量-cxxflags_impl_common"><a class="header" href="#变量-cxxflags_impl_common">变量 CXXFLAGS_IMPL_COMMON</a></h3>
<p>　　和特定实现相关的 C++ 编译器一般命令行选项。</p>
<p>　　默认值包括若干特定实现的选项。</p>
<h3 id="线程命令行选项"><a class="header" href="#线程命令行选项">线程命令行选项</a></h3>
<p>　　线程命令行选项是一组未指定名称的内部命令行选项，包含编译器选项和链接器选项的默认值。其中，编译器选项被<a href="#%E5%8F%98%E9%87%8F-cflags">变量 <code>CFLAGS</code></a> 和<a href="#%E5%8F%98%E9%87%8F-cxxflags">变量 <code>CXXFLAGS</code></a> 的默认值使用，链接器选项被<a href="#%E5%8F%98%E9%87%8F-ldflags">变量 <code>LDFLAGS</code></a> 的默认值使用。</p>
<p>　　默认值按以下方式检查和指定线程参数：</p>
<ul>
<li>通过 <code>-dumpspecs</code> 的内容检查是否匹配 <code>mthreads:</code> 。若成功，编译器和链接器选项添加 <code>-mthreads</code> 。</li>
<li>否则，测试带有 <code>-mthread</code> 选项的构建。若（直接调用编译器驱动）构建通过，则链接器选项添加 <code>-mthreads</code> ，并检查编译。
<ul>
<li>若编译不通过，则编译器选项添加 <code>-D_MT</code> ，否则添加 <code>-mthreads</code> 。</li>
</ul>
</li>
<li>否则，若通过 <code>-dumpspecs</code> 的内容检查匹配 <code>no-pthread:</code> 且带有 <code>-pthread</code> 时无法构建，则保持编译器和链接器选项不变。</li>
<li>否则，编译器和链接器选项添加 <code>-pthread</code> 。</li>
</ul>
<p><strong>注意</strong> 不论 C 或 C++ ，当前实现在调用编译器测试构建时总是使用<a href="#%E5%87%BD%E6%95%B0-shbuild_cxx_testsimple">函数 SHBuild_CXX_TestSimple</a> 。</p>
<h3 id="变量-cxxflags_impl_opt"><a class="header" href="#变量-cxxflags_impl_opt">变量 CXXFLAGS_IMPL_OPT</a></h3>
<p>　　和特定工具相关的 C++ 编译器优化命令行选项。</p>
<p>　　默认值包括若干特定实现的选项。</p>
<h3 id="变量-cflags_std"><a class="header" href="#变量-cflags_std">变量 CFLAGS_STD</a></h3>
<p>　　指定 C 标准的编译器命令行选项。</p>
<p>　　默认值为 <code>-std=c11</code> 。</p>
<h3 id="变量-cflags_warning"><a class="header" href="#变量-cflags_warning">变量 CFLAGS_WARNING</a></h3>
<p>　　C 编译器警告命令行选项。</p>
<p>　　默认值包含以下列表中的内容：</p>
<ul>
<li>变量 <code>C_CXXFLAGS_WARNING</code> 的内容</li>
<li>变量 <code>C_CXXFLAGS_IMPL_WARNING</code> 的内容</li>
</ul>
<h3 id="变量-cxxflags_std"><a class="header" href="#变量-cxxflags_std">变量 CXXFLAGS_STD</a></h3>
<p>　　指定 C++ 标准的编译器命令行选项。</p>
<p>　　默认值为 <code>-std=c++11</code> 。</p>
<h3 id="函数-shbuild_get_cxxflags_warning"><a class="header" href="#函数-shbuild_get_cxxflags_warning">函数 SHBuild_Get_CXXFLAGS_WARNING</a></h3>
<p>　　取 C++ 编译器的警告命令行选项的默认值。</p>
<p>　　结果包括以下列表中的内容：</p>
<ul>
<li>变量 <code>C_CXXFLAGS_WARNING</code> 的内容</li>
<li>变量 <code>C_CXXFLAGS_IMPL_WARNING</code> 的内容</li>
<li><code>-Wconditionally-supported</code></li>
<li><code>-Wctor-dtor-privacy</code></li>
<li><code>-Wdeprecated</code>（仅当旧版本 GCC 中这个选项支持 C++ 但不支持 C 时）</li>
<li><code>-Wno-deprecated-register</code></li>
<li><code>-Wno-mismatched-tags</code></li>
<li><code>-Wno-missing-braces</code>（仅当 Clang++ &lt; 6.0 ，作为<a href="https://bugs.llvm.org/show_bug.cgi?id=21629">这个问题</a>的变通）</li>
<li><code>-Wnon-virtual-dtor</code></li>
<li><code>-Woverloaded-virtual</code></li>
<li><code>-Wsign-promo</code></li>
<li><code>-Wshorten-64-to-32</code></li>
<li><code>-Wstrict_null_sentinal</code></li>
<li><code>-Wsuggest-final-methods</code></li>
<li><code>-Wsuggest-final-types</code></li>
<li><code>-Wweak-vtables</code></li>
<li><code>-Wzero-as-null-pointer-constant</code></li>
<li>变量 <code>CXXFLAGS_IMPL_WARNING</code> 的内容</li>
</ul>
<p>　　除以上变量中的内容外，通过检查 C++ 编译器和版本已知不支持的选项会被替换为其它功能近似的选项或被排除。</p>
<h3 id="变量-cxxflags_warning"><a class="header" href="#变量-cxxflags_warning">变量 CXXFLAGS_WARNING</a></h3>
<p>　　C++ 编译器警告命令行选项。</p>
<p>　　默认值是调用<a href="#%E5%87%BD%E6%95%B0-shbuild_get_cxxflags_warning">函数 <code>SHBuild_Get_CXXFLAGS_WARNING</code></a> 得到的值。</p>
<h3 id="变量-cxxflags_opt_dbg"><a class="header" href="#变量-cxxflags_opt_dbg">变量 CXXFLAGS_OPT_DBG</a></h3>
<p>　　C++ 编译器优化和调试相关的命令行选项。在未设置非空的 <code>SHbuild_Debug</code> 时。</p>
<p>　　默认值包含以下列表中的内容：</p>
<ul>
<li>变量 <code>C_CXXFLAGS_OPT_LV</code> 的内容</li>
<li>变量 <code>CXXFLAGS_OPT_UseAssert</code> 没有被设置非空值时包含 <code>-NDEBUG</code></li>
<li>变量 <code>CXXFLAGS_IMPL_OPT</code> 的内容</li>
<li><code>-fomit-frame-pointer</code></li>
</ul>
<h3 id="变量-cflags"><a class="header" href="#变量-cflags">变量 CFLAGS</a></h3>
<p>　　C 编译器使用的命令行选项。</p>
<p>　　默认值为 <code>$CFLAGS_STD $C_CXXFLAGS_PIC $C_CXXFLAGS_COMMON $CFLAGS_WARNING $C_CXXFLAGS_IMPL_THRD_ $C_CXXFLAGS_COMMON_IMPL_ $CXXFLAGS_OPT_DBG</code> 。其中，<code>C_CXXFLAGS_COMMON_IMPL_</code> 是<a href="#%E7%BA%BF%E7%A8%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9">编译器线程命令行选项</a>，而 <code>C_CXXFLAGS_COMMON_IMPL_</code> 是根据支持的编译器在内部定义的非公开变量。</p>
<p><strong>注意</strong> 当前和 C++ 编译器选项共用 <code>CXXFLAGS_OPT_DBG</code> 。</p>
<h3 id="变量-cxxflags"><a class="header" href="#变量-cxxflags">变量 CXXFLAGS</a></h3>
<p>　　C++ 编译器使用的命令行选项。</p>
<p>　　默认值为 <code>$CXXFLAGS_STD $C_CXXFLAGS_PIC $C_CXXFLAGS_COMMON $CXXFLAGS_WARNING $C_CXXFLAGS_IMPL_THRD_ $CXXFLAGS_IMPL_COMMON $CXXFLAGS_OPT_DBG</code> 。其中，<code>C_CXXFLAGS_COMMON_IMPL_</code> 是<a href="#%E7%BA%BF%E7%A8%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9">编译器线程命令行选项</a>，而 <code>CXXFLAGS_IMPL_COMMON</code> 的默认值包含<a href="#%E5%8F%98%E9%87%8F-cflags">变量 <code>C_CXXFLAGS_COMMON_IMPL_</code></a> 的内容。</p>
<h3 id="变量-ldflags_opt_dbg"><a class="header" href="#变量-ldflags_opt_dbg">变量 LDFLAGS_OPT_DBG</a></h3>
<p>　　链接器优化和调试相关的命令行选项。在未设置非空的 <code>SHbuild_Debug</code> 时。</p>
<p>　　默认值为 <code>$LDFLAGS_STRIP $LDFLAGS_IMPL_OPT $LDFLAGS_GC</code> 。</p>
<h3 id="变量-ldflags"><a class="header" href="#变量-ldflags">变量 LDFLAGS</a></h3>
<p>　　链接器使用的命令行选项。</p>
<p>　　默认值依次包含以下内容：</p>
<ul>
<li>变量 <code>C_CXXFLAGS_PIC</code> 的内容。</li>
<li>变量 <code>CXXFLAGS_WARNING</code> 的内容。</li>
<li>默认的<a href="#%E7%BA%BF%E7%A8%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9">线程命令行选项</a>。</li>
<li>变量 <code>LDFLAGS_OPT_DBG</code> 的内容。</li>
<li>可选的其它选项（参见以下 <a href="#toolsscriptsshbuild-yslib-commontxt"><code>Tools/Scripts/SHBuild-YSLib-common.txt</code></a> ）。</li>
</ul>
<p>　　默认使用 <code>-Wl,</code> 传递链接器特定的命令行。</p>
<h2 id="toolsscriptsshbuild-common-toolchainsh"><a class="header" href="#toolsscriptsshbuild-common-toolchainsh">Tools/Scripts/SHBuild-common-toolchain.sh</a></h2>
<p>　　被应用程序构建脚本包含的基础功能，提供默认的编译器和链接器等工具的名称。</p>
<p>　　支持 GCC/G++ 和 Clang/Clang++ 。</p>
<p>　　支持 <code>ar</code> 及与其兼容的工具 <code>gcc-ar</code>/<code>llvm-ar</code> 的自动检测。对 Clang++ 和 G++ ，分别使用 <code>llvm-ar</code> 和 <code>gcc-ar</code> 。</p>
<p>　　以下可在环境外部配置，在值确定后被导出：</p>
<ul>
<li><code>CC</code>
<ul>
<li>若操作系统为 <code>Win32</code> 且 <code>MSYSTEM</code> 指定为默认使用 llvm 工具链（即 Clang ）的环境，默认值为 <code>clang</code> ，否则为 <code>gcc</code> 。</li>
</ul>
</li>
<li><code>CXX</code>
<ul>
<li>若操作系统为 <code>Win32</code> 且 <code>MSYSTEM</code> 指定为默认使用 llvm 工具链（即 Clang++ ）的环境，默认值为 <code>clang++</code> ，否则为 <code>g++</code> 。</li>
</ul>
</li>
<li><code>AR</code>
<ul>
<li>默认值为变量 <code>CXX</code> 指定的 C++ 编译器确定的自动检测结果；若非 Clang++ 和 G++ ，则使用 <code>ar</code> 。</li>
</ul>
</li>
<li><code>ARFLAGS</code>
<ul>
<li>默认值为 <code>rcs</code> 。</li>
</ul>
</li>
<li><code>LD</code>
<ul>
<li>默认值为变量 <code>CXX</code> 的值。</li>
</ul>
</li>
</ul>
<p>　　关于 <code>MSYSTEM</code> 指定的环境和使用的工具链的对应关系，参见 <a href="https://www.msys2.org/docs/environments/">MSYS2 支持的环境</a>；关于支持的 <code>MSYSTEM</code> 的值和 MSYS2 环境，另见<a href="#%E5%87%BD%E6%95%B0-shbuild_platform_detect">函数 <code>SHBuild_Platform_Detect</code></a> 。</p>
<p>　　以下只读变量在初始化配置时被按需初始化并断言非空：</p>
<ul>
<li><code>SHBuild_CC_Name</code> ：C 编译器名称。
<ul>
<li>在调用函数 <code>SHBuild_CC_GetVersion</code> 时被首先初始化。</li>
<li>初值是 <code>$CC</code> 作为参数调用函数 <code>SHBuild_CheckCC</code> 的结果。</li>
</ul>
</li>
<li><code>SHBuild_CC_Version</code> ：C 编译器版本号。
<ul>
<li>当前未使用。</li>
<li>初值是调用函数 <code>SHBuild_CC_GetVersion</code> 的结果。</li>
</ul>
</li>
<li><code>SHBuild_CXX_Name</code> ：C++ 编译器名称。
<ul>
<li>在调用<a href="#%E5%87%BD%E6%95%B0-shbuild_cxx_getversion">函数 <code>SHBuild_CXX_GetVersion</code></a> 时被首先初始化。</li>
<li>在脚本 <a href="#toolsscriptsshbuild-common-toolchainsh"><code>Tools/Scripts/SHBuild-common-toolchain.sh</code></a> 确定 <code>AR</code> 的默认值值前初始化。</li>
<li>在脚本 <a href="#toolsscriptsshbuild-common-optionssh"><code>Tools/Scripts/SHBuild-common-options.sh</code></a> 确定 <code>CXXFLAGS</code> 等其它配置变量的默认值值前初始化。</li>
<li>初值是 <code>$CXX</code> 作为参数调用函数 <code>SHBuild_CheckCXX</code> 的结果。</li>
</ul>
</li>
<li><code>SHBuild_CXX_Version</code> ：C++ 编译器版本号。
<ul>
<li>在脚本 <code>Tools/Scripts/SHBuild-common-toolchain.sh</code> 确定 C++ 版本号前初始化。</li>
<li>初值是调用函数 <code>SHBuild_CXX_GetVersion</code> 的结果。</li>
</ul>
</li>
</ul>
<p>　　上述按需初始化使用<a href="#%E5%87%BD%E6%95%B0-shbuild_initreadonly">函数 <code>SHBuild_InitReadonly</code></a>。</p>
<p><strong>注释</strong> 可通过外部执行环境指定这些变量具有非空值而跳过初始化。</p>
<p>　　<strong>这个脚本是公开的工具</strong>，被安装脚本部署。</p>
<h3 id="函数-shbuild_checkcompiler"><a class="header" href="#函数-shbuild_checkcompiler">函数 SHBuild_CheckCompiler</a></h3>
<p>　　尝试以参数指定的编译参数和输入调用参数指定的编译器，并按检查结果选择和输出参数的值。</p>
<p>　　检查编译器时，首先排除参数指定的编译器不可执行的情形，然后通过尝试编译以参数指定的源程序进行。</p>
<p>　　前四参数分别指定编译器的路径、尝试编译的源程序、检查成功时输出的结果和检查失败时输出的结果，之后的参数指定编译选项和源文件。选项和源文件参数中，应在语言选项（如 <code>-xc++</code> ）后出现一次表示输入源程序的 <code>-</code> 。</p>
<p><strong>注释</strong> 这允许自由安排参数中 <code>-</code> 的顺序。一般地，<code>-</code> 应出现在 <code>-xc++</code> 等参数之后，而出现在链接的库选项之前（如有）。若指定链接的其它库选项在 <code>-</code> 之前，其中的符号在使用 GNU ld 等对出现顺序敏感的链接器时，无法在源程序中引用而链接失败。</p>
<p>　　检查前断言前两个参数非空。指定编译选项的参数为空时，第三和第四参数可能不提供或为空。</p>
<p>　　源程序和换行符通过管道输入编译器。</p>
<p><strong>注释</strong> 对 ISO C 以及 ISO C++11 前的版本，翻译单元不以空行结尾引起未定义行为。此处指定源程序的参数可以不以换行结尾也可安全处理。</p>
<p>　　结果是以下之一：</p>
<ul>
<li>空值（第一参数指定不可执行的路径）。</li>
<li>第三参数（检查成功时的结果）。</li>
<li>第四参数（检查失败时的结果）。</li>
</ul>
<p><strong>注意</strong> 当前不检查失败原因。编译命令调用依赖可写的临时目录。参见函数 <code>SHBuild_GetTempDir</code> 的已知限制。</p>
<h3 id="函数-shbuild_checkcc"><a class="header" href="#函数-shbuild_checkcc">函数 SHBuild_CheckCC</a></h3>
<p>　　尝试调用参数指定的编译器以检查 C 编译器风格。</p>
<p>　　第一参数指定编译器可执行文件路径。</p>
<p>　　结果是以下之一：</p>
<ul>
<li>空值（不支持的编译器）。</li>
<li><code>Clang</code> 。</li>
<li><code>GCC</code> 。</li>
</ul>
<h3 id="函数-shbuild_checkcxx"><a class="header" href="#函数-shbuild_checkcxx">函数 SHBuild_CheckCXX</a></h3>
<p>　　尝试调用参数指定的编译器以检查 C++ 编译器名称。</p>
<p>　　第一参数指定编译器可执行文件路径。</p>
<p>　　结果是以下之一：</p>
<ul>
<li>空值（不支持的编译器）。</li>
<li><code>Clang++</code> 。</li>
<li><code>G++</code> 。</li>
</ul>
<h3 id="函数-shbuild_cc_test"><a class="header" href="#函数-shbuild_cc_test">函数 SHBuild_CC_Test</a></h3>
<p>　　测试 <code>"$CC"</code> 指定的编译器 C 编译器命令行是否可成功调用。</p>
<p>　　第一参数指定源程序，之后的参数指定编译选项。编译选项前隐含 <code>-pipe -xc</code> 。</p>
<p>　　以 <code>SHBuild_CheckCompiler</code> 实现编译器调用。</p>
<h3 id="函数-shbuild_cc_testsimple"><a class="header" href="#函数-shbuild_cc_testsimple">函数 SHBuild_CC_TestSimple</a></h3>
<p>　　测试 <code>"$CC"</code> 指定的编译器 C 编译器命令行编译最小程序是否可成功调用。</p>
<p>　　参数指定编译选项。</p>
<p>　　以 <code>SHBuild_CC_Test</code> 实现编译器调用。</p>
<p>　　使用的最小程序是 <code>int main(void){return 0;}</code> 。</p>
<h3 id="函数-shbuild_cxx_test"><a class="header" href="#函数-shbuild_cxx_test">函数 SHBuild_CXX_Test</a></h3>
<p>　　测试 <code>"$CXX"</code> 指定的编译器 C++ 编译器命令行是否可成功调用。</p>
<p>　　第一参数指定源程序，之后的参数指定编译选项。编译选项前隐含 <code>-pipe -xc++</code> 。</p>
<p>　　以 <code>SHBuild_CheckCompiler</code> 实现编译器调用。</p>
<h3 id="函数-shbuild_cxx_testsimple"><a class="header" href="#函数-shbuild_cxx_testsimple">函数 SHBuild_CXX_TestSimple</a></h3>
<p>　　测试 <code>"$CXX"</code> 指定的编译器 C++ 编译器命令行编译最小程序是否可成功调用。</p>
<p>　　参数指定编译选项。</p>
<p>　　以 <code>SHBuild_CXX_Test</code> 实现编译器调用。</p>
<p>　　使用的最小程序是 <code>int main(){}</code> 。</p>
<h3 id="函数-shbuild_cc_getversion"><a class="header" href="#函数-shbuild_cc_getversion">函数 SHBuild_CC_GetVersion</a></h3>
<p>　　尝试调用 <code>"$CC"</code> 指定的编译器以管道输入的程序取 C 编译器版本号。</p>
<p>　　结果是以下之一：</p>
<ul>
<li>成功时：GCC 或 Clang 版本号的 <code>X.Y.Z</code> 转换为 <code>X * 10000 + Y * 100 + Z</code> 的数值的字符串。</li>
<li>失败时：空。</li>
</ul>
<p><strong>已知缺陷</strong> 不支持无法取得 <code>__GNUC_PATCHLEVEL__</code> 的旧版本 GCC 。
<strong>已知缺陷</strong> 不支持 Apple Clang 。</p>
<h3 id="函数-shbuild_cxx_getversion"><a class="header" href="#函数-shbuild_cxx_getversion">函数 SHBuild_CXX_GetVersion</a></h3>
<p>　　尝试调用 <code>"$CXX"</code> 指定的编译器以管道输入的程序取 C++ 编译器版本号。</p>
<p>　　结果是以下之一：</p>
<ul>
<li>成功时：G++ 或 Clang++ 版本号的 <code>X.Y.Z</code> 转换为 <code>X * 10000 + Y * 100 + Z</code> 的数值的字符串。</li>
<li>失败时：空。</li>
</ul>
<p><strong>已知缺陷</strong> 不支持无法取得 <code>__GNUC_PATCHLEVEL__</code> 的旧版本 GCC 。
<strong>已知缺陷</strong> 不支持 Apple Clang 。</p>
<h2 id="toolsscriptsshbuild-self-hostsh"><a class="header" href="#toolsscriptsshbuild-self-hostsh">Tools/Scripts/SHBuild-self-host.sh</a></h2>
<p>　　<a href="SHBuild.zh-CN.html">SHBuild</a> 自举测试用脚本。</p>
<p>　　使用 SHBuild 编译并静态链接构建 SHBuild 。和 <a href="SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 1 SHBuild</a> 类似，直接使用 YSLib 源文件。</p>
<h2 id="toolsscriptsshbuild-self-host-dllsh"><a class="header" href="#toolsscriptsshbuild-self-host-dllsh">Tools/Scripts/SHBuild-self-host-DLL.sh</a></h2>
<p>　　<a href="SHBuild.zh-CN.html">SHBuild</a> 自举测试用脚本。</p>
<p>　　使用 SHBuild 编译并动态链接构建 SHBuild 。依赖 <code>/usr/lib</code> 中存在的 YFramework 和 YBase 动态库文件。</p>
<h2 id="toolsscriptsshbuild-yslibsh"><a class="header" href="#toolsscriptsshbuild-yslibsh">Tools/Scripts/SHBuild-YSLib.sh</a></h2>
<p>　　作为 <a href="SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 1 SHBuild</a> 公共配置脚本被不同的 stage 1 构建脚本包含。</p>
<p>　　包含脚本依次执行：</p>
<ul>
<li>按需初始化<a href="../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">变量 <code>SHBuild_ToolDir</code></a> 。</li>
<li>包含脚本 <a href="#toolsscriptsshbuild-commonsh"><code>Tools/Scripts/SHBuild-common.sh</code></a> 以按需初始化确定默认构建位置依赖的环境变量。</li>
<li>调用<a href="#%E5%87%BD%E6%95%B0-shbuild_s1_initconf">函数 <code>SHBuild_S1_InitConf</code></a> 初始化 stage 1 SHBuild 配置。</li>
<li>初始化缓存：
<ul>
<li>按需初始化<a href="#stage-1-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">变量 <code>S1_CacheFile</code></a> ，默认值为 <code>"$S1_BuildDir/config.cache"</code> 。</li>
<li>初始化缓存相关的内部状态，并调用<a href="#%E5%87%BD%E6%95%B0-shbuild_loadcache">函数 <code>SHBuild_LoadCache</code></a> 加载缓存。</li>
<li>内部状态决定传递给函数 <code>SHBuild_LoadCache</code> 被缓存的变量的名称模式：<code>(CC CXX LD AR '(C|CXX|LD|AR)FLAGS.*' 'SHBuild_(C|CXX)_.*' 'S1_Cached_.*'</code>)。</li>
</ul>
</li>
<li>初始化 stage 1 公共构建资源和配置：
<ul>
<li>按需初始化<a href="#%E5%8F%98%E9%87%8F-shbuild_pch_stdinc_h">变量 <code>SHBuild_PCH_stdinc_h</code></a> 。</li>
<li>包含脚本 <a href="#toolsscriptsshbuild-common-optionssh"><code>Tools/Scripts/SHBuild-common-options.sh</code></a> 以按需初始化构建工具使用的选项。</li>
<li>初始化变量 <code>INCLUDE_PCH</code> 为指定版本库下 <code>YBase/include/stdinc.h</code> 的路径字符串。</li>
<li>初始化变量 <code>INCLUDES</code> 为版本库目录下的适合作为编译器选项使用的头文件目录列表。</li>
</ul>
</li>
<li>定义函数（参见以下各节）。</li>
</ul>
<p><strong>注意</strong> 这个脚本包含 <code>INC_SHBuild_YSLib</code> 守卫变量检查，默认重复包含只被执行一次。</p>
<h3 id="变量-shbuild_pch_stdinc_h"><a class="header" href="#变量-shbuild_pch_stdinc_h">变量 SHBuild_PCH_stdinc_h</a></h3>
<p>　　预编译头文件名称，默认值为 <code>"$S1_BuildDir/stdinc.h"</code> 。</p>
<h3 id="函数-shbuild_s1_initializepch"><a class="header" href="#函数-shbuild_s1_initializepch">函数 SHBuild_S1_InitializePCH</a></h3>
<p>　　初始化 stage 1 使用的预编译头文件：即调用：</p>
<pre><code class="language-shell">SHBuild_CheckPCH "$INCLUDE_PCH" "$SHBuild_PCH_stdinc_h"
</code></pre>
<h2 id="toolsscriptsshbuild-yslibtxt"><a class="header" href="#toolsscriptsshbuild-yslibtxt">Tools/Scripts/SHBuild-YSLib*.txt</a></h2>
<p>　　构建 YSLib 用的 <a href="../Development.zh-CN.html#npla1-%E8%84%9A%E6%9C%AC">NPLA1 脚本</a>，包含以下文件：</p>
<ul>
<li><a href="#toolsscriptsshbuild-yslib-commontxt"><code>Tools/Scripts/SHBuild-YSLib-common.txt</code></a> ：被 <code>Tools/Scripts/SHBuild-YSLib-build.txt</code> 加载的 NPLA1 脚本。</li>
<li><a href="#toolsscriptsshbuild-yslib-buildtxt"><code>Tools/Scripts/SHBuild-YSLib-build.txt</code></a> ：使用 SHBuild 构建 debug 或 release 配置的 YBase 和 YFramework 库的 NPLA1 脚本，被 <code>Tools/install-sysroot.sh</code> 调用，其中 <a href="SHBuild.zh-CN.html">SHBuild</a> 默认为 <a href="SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 1 SHBuild</a> 。</li>
</ul>
<p>　　调用方式详见<a href="SHBuild.zh-CN.html#npl-%E6%94%AF%E6%8C%81">关于 NPL 支持的说明</a>。</p>
<p>　　可通过<a href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">外部环境变量</a>配置脚本行为。</p>
<p>　　构建过程中可能检查版本控制系统以计算版本号等元信息，这可被环境变量控制，参见<a href="#%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E6%94%AF%E6%8C%81">版本控制系统支持</a>。</p>
<p>　　被支持的具体脚本参见以下各节：</p>
<ul>
<li><a href="#toolsscriptsshbuild-yslib-commontxt"><code>Tools/Scripts/SHBuild-YSLib-common.txt</code></a></li>
<li><a href="#toolsscriptsshbuild-yslib-buildtxt"><code>Tools/Scripts/SHBuild-YSLib-build.txt</code></a></li>
</ul>
<h2 id="toolsscriptsshbuild-yslib-commontxt"><a class="header" href="#toolsscriptsshbuild-yslib-commontxt">Tools/Scripts/SHBuild-YSLib-common.txt</a></h2>
<p>　　这个脚本提供一些公共的库，包括支持类似 <a href="#toolsscriptsshbuild-common-optionssh"><code>Tools/Scripts/SHBuild-common-options.sh</code></a> 和 <a href="#toolsscriptsshbuild-common-toolchainsh"><code>Tools/Scripts/SHBuild-common-toolchain.sh</code></a> 的选项以环境变量的方式配置，但 C 编译器相关的选项除外（不使用而被忽略）。</p>
<p>　　除关于 <a href="../Development.zh-CN.html#shell-%E8%84%9A%E6%9C%AC">shell 脚本</a>和 <a href="../Development.zh-CN.html#npla1-%E8%84%9A%E6%9C%AC">NPLA1 脚本</a>之间的一般差异外，与 <code>Tools/Scripts/SHBuild-common-options.sh</code> 和 <code>Tools/Scripts/SHBuild-common-toolchain.sh</code> 的不同为：</p>
<ul>
<li>通过调用函数进入<strong>构建环境变量检测</strong>并在之后进入回调函数中构建。
<ul>
<li>按需初始化变量。构建环境变量检测可能延迟访问以避免不必要初始化的值。配置时为确定变量的默认值的检查的调用顺序可能不同。</li>
<li>使用 debug 模式时，<code>CXXFLAGS_OPT_DBG</code> 设置为 <code>-O0 -g -D_GLIBCXX_DEBUG_PEDANTIC</code> ，不再被环境变量覆盖。</li>
<li>生成变量默认值的选项之间的空白符可能不同（通常可确保为一个空格）。</li>
<li>附加支持构建应用的配置，在导出的变量的默认值中添加扩展的选项（参见以下相关说明）替换 shell 脚本中指定的默认值（可影响其它默认值）。</li>
<li>附加检查 <a href="https://github.com/google/sanitizers/wiki">sanitizer</a> 。参见以下相关章节的说明。</li>
</ul>
</li>
<li>部分函数具有不同的参数：
<ul>
<li><a href="#%E5%87%BD%E6%95%B0-shbuild_get_c_cxxflags_warning">函数 <code>SHBuild_Get_C_CXXFLAGS_WARNING</code></a> 具有参数列表 <code>(cxx-name cxx-version)</code> ，接受参数代替<a href="#toolsscriptsshbuild-common-toolchainsh">变量 <code>SHBuild_CXX_Name</code></a> 和<a href="#toolsscriptsshbuild-common-toolchainsh">变量 <code>SHBuild_CXX_Version</code></a> 的值。</li>
<li><a href="#%E5%87%BD%E6%95%B0-shbuild_get_cxxflags_warning">函数 <code>SHBuild_Get_CXXFLAGS_WARNING</code></a> 具有参数列表 <code>(cxx-name cxx-version C_CXXFLAGS_WARNING C_CXXFLAGS_IMPL_WARNING CXXFLAGS_IMPL_WARNING)</code> ，接受参数代替<a href="#toolsscriptsshbuild-common-toolchainsh">变量 <code>SHBuild_CXX_Name</code></a> 、<a href="#toolsscriptsshbuild-common-toolchainsh">变量 <code>SHBuild_CXX_Version</code></a> 、 <a href="#%E5%8F%98%E9%87%8F-c_cxxflags_warning">变量 <code>C_CXXFLAGS_WARNING</code></a>、<a href="#%E5%8F%98%E9%87%8F-c_cxxflags_impl_warning">变量 <code>C_CXXFLAGS_IMPL_WARNING</code></a>和<a href="#%E5%8F%98%E9%87%8F-cxxflags_impl_warning">变量 <code>CXXFLAGS_IMPL_WARNING</code></a>的值。</li>
</ul>
</li>
<li>支持更多变量和默认值。
<ul>
<li>除非另行指定，这些变量在构建环境变量检测中使用。参见以下各节。</li>
<li>在构建动态库或应用程序时，使用空 <code>C_CXXFLAGS_GC</code> 值。
<ul>
<li><strong>原理</strong> 这些选项<a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html">影响编译时代码生成，不总是优化的</a>。对静态库，因为始终无法预测可能需要排除的定义，启用这些选项是合理的。否则，通常从源代码直接确保排除冗余定义更有效。</li>
<li><strong>注释</strong> <code>LDFLAGS_GC</code> 的值仍被保持。对使用空的 <code>C_CXXFLAGS_GC</code> 值构建的目标文件这没有预期的作用，但对其它情形（典型地，静态库）仍然有效。</li>
</ul>
</li>
</ul>
</li>
<li>提供部分和 shell 脚本不同的函数，详见版本库中的 <code>doc/NPL.txt</code> 。</li>
<li>提供单独的缓存机制。
<ul>
<li>配置缓存的变量的名称具有 <code>SHBuild_</code> ，可能具有名称前缀为 <code>S1_</code> 的对应的 <a href="#stage-1-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">stage 1 共享变量</a>。
<ul>
<li>两者功能相同，但指定 <a href="SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 2 和之后阶段而非 stage 1</a> 的缓存行为。</li>
</ul>
</li>
<li>支持以下被缓存的变量：
<ul>
<li><a href="#toolsscriptsshbuild-yslibsh">Stage 1 被缓存的变量</a>的一个子集，名称以 NPLA1 字符串列表定义为：<code>list "CXX" "LD" "AR" "CFLAGS" "CXXFLAGS" "LDFLAGS" "ARFLAGS" "SHBuild_CXX_Name" "SHBuild_CXX_Version"</code> 。</li>
<li>缓存的配置变量，作为配置项取值同 <a href="#stage-1-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">stage 1 共享变量</a>，且支持 <code>#f</code> 同 <code>"false"</code> ，<code>#t</code> 同 <code>"true"</code> 。
<ul>
<li>变量 <code>SHBuild_Cached_quadmath</code> ：类似变量 <a href="#toolsscriptsshbuild-bootstrapsh"><code>S1_Cached_quadmath</code></a> 。</li>
</ul>
</li>
</ul>
</li>
<li><code>SHBuild_CacheFile</code> ：类似变量 <code>S1_CacheFile</code> 。默认值为构建目录下的 <code>config.cache</code> 。</li>
<li><code>SHBuild_CacheMode</code> ：类似变量 <code>S1_CacheMode</code> 。</li>
</ul>
</li>
</ul>
<p>　　这个脚本被 <a href="#toolsscriptsshbuild-yslib-buildtxt"><code>Tools/Scripts/SHBuild-YSLib-build.txt</code></a> 加载，并被 <a href="#toolsinstall-sysrootsh"><code>Tools/install-sysroot.sh</code></a> 间接调用。</p>
<p>　　以下<a href="#%E5%85%AC%E5%85%B1%E6%9E%84%E5%BB%BA%E9%85%8D%E7%BD%AE%E5%8F%98%E9%87%8F">公共构建配置变量</a>影响脚本的特定行为：</p>
<ul>
<li><code>SS_DebugEnv</code> 的作用当前包括：
<ul>
<li>对环境变量修改时输出修改的变量名和对应的值。</li>
</ul>
</li>
<li><code>SS_Verbose</code> 的作用当前包括：
<ul>
<li>在 <code>LDFLAGS</code> 变量中附加 <code>-mwindows</code> 时提示。</li>
<li>在安装文件时输出安装类型、目标和源。</li>
</ul>
</li>
</ul>
<p>　　脚本支持外部调用这个脚本的命令行设置变量的默认值，以覆盖直接指定构建环境变量检测确定的选项，如：</p>
<pre><code class="language-bash">CXX=clang++ CXXFLAGS='-std=c++11 -O2' Tools/install-sysroot.sh
</code></pre>
<p><strong>警告</strong> 使用预编译头选项和缺陷同 <a href="#toolsscriptsshbuild-buildsh"><code>Tools/Scripts/SHBuild-build.sh</code></a> 。其中的特性未指定使用 shell 实现，和后者可能存在 shell 环境中可见的差异。</p>
<p>　　<strong>这个脚本是公开的工具</strong>，被安装脚本部署。</p>
<h3 id="变量-ldflags_dyn_base"><a class="header" href="#变量-ldflags_dyn_base">变量 LDFLAGS_DYN_BASE</a></h3>
<p>　　指定动态库基础链接选项。</p>
<p>　　默认值和平台相关：若为 Win32 环境则使用 <code>-shared -Wl,--dll</code> ，否则为 <code>-shared</code> 。</p>
<h3 id="变量-ldflags_dyn_extra"><a class="header" href="#变量-ldflags_dyn_extra">变量 LDFLAGS_DYN_EXTRA</a></h3>
<p>　　指定动态库附加链接选项。</p>
<p>　　默认值等价于 <code>-Wl,--no-undefined,--dynamic-list-data,--dynamic-list-cpp-new,--dynamic-list-cpp-typeinfo</code> 。</p>
<h3 id="变量-ldflags_dyn"><a class="header" href="#变量-ldflags_dyn">变量 LDFLAGS_DYN</a></h3>
<p>　　指定动态库链接选项。</p>
<p>　　默认值为 <code>$LDFLAGS_DYN_BASE $LDFLAGS_DYN_EXTRA</code> 。</p>
<h3 id="变量-libs_rpath"><a class="header" href="#变量-libs_rpath">变量 LIBS_RPATH</a></h3>
<p>　　用于指定在运行时 ELF 映像需要的动态库的路径的链接器选项。</p>
<p>　　在 Win32 默认不设置，其它平台默认值为 <code>-Wl,-rpath,'\$ORIGIN:\$ORIGIN/../lib'</code> 。</p>
<h3 id="变量-libpfx"><a class="header" href="#变量-libpfx">变量 LIBPFX</a></h3>
<p>　　库前缀。</p>
<p>　　在 Win32 默认不设置，其它平台默认值为 <code>lib</code> 。</p>
<h3 id="变量-dsosfx"><a class="header" href="#变量-dsosfx">变量 DSOSFX</a></h3>
<p>　　动态库文件名后缀。</p>
<p>　　在 Win32 默认值为 <code>.dll</code> ，其它平台默认值为 <code>.so</code> 。</p>
<h3 id="变量-exesfx"><a class="header" href="#变量-exesfx">变量 EXESFX</a></h3>
<p>　　可执行文件名后缀。</p>
<p>　　在 Win32 默认值为 <code>.exe</code> ，其它平台默认不设置。</p>
<h3 id="sanitizer-检查支持"><a class="header" href="#sanitizer-检查支持">Sanitizer 检查支持</a></h3>
<p>　　构建环境变量检测支持 sanitizer ：若在变量 <code>CFLAGS</code>、<code>CXXFLAGS</code>、<code>LDFLAGS</code> 或 <code>SHBuild_CXXFLAGS</code> 中包含启用被支持的 sanitizer 的选项 （以 <code>-fsanitizer=address</code> 起始），配置最终在 <code>CFLAGS</code>、<code>CXXFLAGS</code> 和 <code>LDFLAGS</code> 最后添加自动调整的选项。</p>
<p>　　构建配置支持 ASan、TSan、MSan、UBSan 和 LSan 。Sanitizer 自身支持的系统和编译器详见 sanitizer 的文档。</p>
<p>　　ASan 使用的选项要求和建议参见 <a href="https://github.com/google/sanitizers/wiki/AddressSanitizer#faq">FAQ</a> 。</p>
<p><strong>注意</strong> <a href="https://gcc.gnu.org/legacy-ml/gcc/2014-10/msg00006.html">GCC 不支持 MSan</a> 。MSan 要求标准库<a href="https://github.com/google/sanitizers/wiki/MemorySanitizerLibcxxHowTo">使用带 MSan 的选项构建</a>，否则<a href="https://github.com/google/sanitizers/issues/542">会有假阳性结果</a>。</p>
<p><strong>注意</strong> 具体调整的选项参见脚本具体实现，不保持构建版本之间稳定。* <strong>注意</strong> 构建脚本不保证构建的二进制程序的具体可用性。构建的程序可能因为程序及 sanitizer 实现的缺陷运行时出错，可能另需具体排查原因修复。</p>
<h3 id="扩展选项的默认值"><a class="header" href="#扩展选项的默认值">扩展选项的默认值</a></h3>
<p>　　变量 <code>LDFLAGS</code> 的默认值依次包含：</p>
<ul>
<li>和 shell 脚本中相同的默认值。</li>
<li>生成可执行程序时且要求按需调整链接器参数时，附加的值：
<ul>
<li>当需要生成 Win32 子系统程序时，附加 <code>-mwindows</code> 。</li>
</ul>
</li>
<li>构建动态可执行程序时，变量 <code>LIBS_RPATH</code> 的内容。</li>
<li>构建动态库或应用时，变量 <code>LDFLAGS_DYN</code> 的内容。</li>
</ul>
<h3 id="shbuild-附加构建选项环境变量"><a class="header" href="#shbuild-附加构建选项环境变量">SHBuild 附加构建选项环境变量</a></h3>
<p>　　若回调函数中调用 SHBuild 构建，可在此之前设置<strong>扩展环境变量</strong>并调用函数 <code>SHBuild_Extend_CallVariables</code> 以更新被 SHBuild 使用的环境变量 <code>LDFLAGS</code> 和 <code>LIBS</code> 的值。这些影响 SHBuild 工具调用构建工具的命令行的 <strong>SHBuild 附加构建选项环境变量</strong>，包括：</p>
<ul>
<li><code>SHBuild_CFLAGS</code></li>
<li><code>SHBuild_CXXFLAGS</code></li>
<li><code>SHBuild_LDFLAGS</code></li>
<li><code>SHBuild_LIBS</code></li>
</ul>
<p>　　除非另行指定，SHBuild 附加构建选项环境变量的默认值为空，不被脚本设置。</p>
<h3 id="其它函数和可在外部设置的其它变量"><a class="header" href="#其它函数和可在外部设置的其它变量">其它函数和可在外部设置的其它变量</a></h3>
<p>　　详见版本库中的 <code>doc/NPL.txt</code> 。</p>
<p>　　其它变量不被构建环境变量检测访问，而通过函数调用生效，如 <code>SHBuild_Extend_CallVariables</code> 。</p>
<h2 id="toolsscriptsshbuild-yslib-buildtxt"><a class="header" href="#toolsscriptsshbuild-yslib-buildtxt">Tools/Scripts/SHBuild-YSLib-build.txt</a></h2>
<p>　　这个脚本当前包括和安装相关的流程，实现 <code>Tools/install-sysroot.sh</code> 在 <a href="SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 1 SHBuild 构建后的主要逻辑</a>。</p>
<p>　　脚本支持在构建前自动从网络安装<a href="../Archives.zh-CN.html#external">外部依赖项二进制归档文件</a>以准备从源代码构建安装 YFramework 库。这仅在环境变量 <code>YSLib_DistDir</code> 被设置非空值时启用。这需要一些外部工具命令的支持：</p>
<ul>
<li>下载归档依次检查以下工具命令：
<ul>
<li><code>wget</code></li>
<li><code>curl</code></li>
<li><strong>注释</strong> 因为 <a href="../Run.zh-CN.html#%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%8E%AF%E5%A2%83">PowerShell 不被支持</a>，实现不检查<a href="https://daniel.haxx.se/blog/2016/08/19/removing-the-powershell-curl-alias/">对 <code>wget</code> 和 <code>curl</code> 的不兼容别名</a>。</li>
<li><strong>注释</strong> 另见以下环境变量 <code>SS_Offline</code> 的说明。</li>
</ul>
</li>
<li>解压缩归档依次检查以下工具命令：
<ul>
<li><code>bsdtar</code></li>
<li><code>7za</code></li>
</ul>
</li>
<li><strong>注释</strong> 当前不提供这些工具的自动安装。
<ul>
<li><strong>原理</strong> 这些工具广泛可用，在不同环境中具有不同情形。
<ul>
<li><a href="https://techcommunity.microsoft.com/t5/containers/tar-and-curl-come-to-windows/bc-p/3272679">自 Microsoft Windows 10 Insider Build 17063/1809</a> 起，<a href="https://curl.se/windows/microsoft.html">随系统提供 <code>curl</code> 的可执行文件</a> 。</li>
<li>MSYS2 和一些 Linux 发行版等环境通过包管理器提供这些命令行工具。</li>
</ul>
</li>
<li><strong>原理</strong> 这些工具通常被全局安装，可能需要系统管理员权限才能执行安装命令。考虑潜在的<a href="../Run.zh-CN.html#%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%8E%AF%E5%A2%83">安全性</a>和复杂性问题，本脚本不支持确保提供这个前提。</li>
</ul>
</li>
</ul>
<p>　　脚本使用 <a href="#toolsscriptsshbuild-yslib-commontxt"><code>Tools/Scripts/SHBuild-YSLib-common.txt</code></a> 中提供的一些函数。</p>
<p>　　脚本支持以下<a href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">外部扩展环境变量</a>指定构建和部署目标：</p>
<ul>
<li><code>SHBuild_UseDebug</code> 非空时启用构建和安装 debug 配置的库。</li>
<li><code>SHBuild_UseRelease</code> 非空时启用构建和安装 release 配置的库。</li>
<li><code>SHBuild_NoStatic</code> 非空时跳过静态库构建。</li>
<li><code>SHBuild_NoDynamic</code> 非空时跳过动态库构建。</li>
<li><code>SHBuild_No3rd</code> 非空时跳过第三方库安装。
<ul>
<li>对<a href="../Development.zh-CN.html#%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96%E9%A1%B9">外部依赖项</a>中的库，只安装启用的配置决定的必要的外部依赖。启用的配置由 <code>SHBuild_UseDebug</code> 和 <code>SHBuild_UseRelease</code> 指定。</li>
</ul>
</li>
<li><code>SHBuild_NoDev</code> 非空时跳过可选的开发工具构建和安装。</li>
<li><code>SHBuild_Rebuild_S1</code> 非空时跳过文件存在性检查，总是重新构建 stage 1 SHBuild 。</li>
<li><code>SHBuild_NoDev</code> 非空时跳过 stage 2 SHBuild 后的开发工具构建和安装。</li>
<li><code>YSLib_DistDir</code> 非空时应指定包含一个绝对路径作为储存 YSLib 归档的目录。</li>
</ul>
<p>　　以下<a href="#%E5%85%AC%E5%85%B1%E6%9E%84%E5%BB%BA%E9%85%8D%E7%BD%AE%E5%8F%98%E9%87%8F">公共构建配置变量</a>影响脚本的特定行为：</p>
<ul>
<li>所有调用 <code>Tools/Scripts/SHBuild-YSLib-common.txt</code> 而生效的公共构建配置变量在此作用相同。</li>
<li><code>SS_DirectExtract</code> 的作用包括：
<ul>
<li>安装下载的归档时，直接用工具命令行覆盖对应位置的文件，而不先解压缩释放到临时目录后再更新。</li>
</ul>
</li>
<li><code>SS_Offline</code> 的作用包括：
<ul>
<li>不检查下载工具命令的可用性。</li>
<li>不使用网络下载资源。</li>
</ul>
</li>
</ul>
<p>　　以下构建时的中间变量可被外部配置，当外部没有配置或为空值时使用默认值：</p>
<ul>
<li><code>SHBuild_SystemPrefix</code> ：系统前缀，在 Sysroot 根路径下决定安装路径。
<ul>
<li>默认值由脚本 <code>Tools/Scripts/SHBuild-YSLib-common.txt</code> 中的函数的调用确定：同 <code>SHBuild_GetSystemPrefix (SHBuild_Platform_Detect SHBuild_Host_OS SHBuild_Host_Arch)</code> 的结果。</li>
<li>脚本 <code>Tools/Scripts/SHBuild-common.sh</code> 中提供 shell 脚本的等价调用：<code>$(SHBuild_GetSystemPrefix (SHBuild_Platform_Detect "$SHBuild_Host_OS" "$SHBuild_Host_Arch"))</code> 。</li>
</ul>
</li>
<li><code>SHBuild_YF_Libs_freetype</code> ：freetype 库链接参数。
<ul>
<li>默认值为 <code>-lfreetype</code> 或 <code>pkg-config --libs freetype2</code> 的输出结果。
<ul>
<li>其中存在 Sysroot <code>libfreetype.a</code> 时默认值为前者。</li>
</ul>
</li>
</ul>
</li>
<li><code>SHBuild_YF_Libs_FreeImage</code> ：FreeImage 库链接参数。
<ul>
<li>默认值为 <code>-lFreeImaged</code> 或 <code>-lFreeImage</code> ，对应 debug 和非 debug 配置。</li>
</ul>
</li>
</ul>
<p>　　这个脚本也可能使用其它变量用于传递参数给被调用的命令，包括一些 <code>SHBuild</code> 预期的变量；后者作为公开接口，但<strong>其具体含义和使用不保证在不同版本间稳定</strong>。</p>
<p>　　在<a href="SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">自举构建 stage 2 SHBuild</a> 前构建安装 YFramework 库时，接受以下环境变量：</p>
<ul>
<li><code>INCLUDES_freetype</code> 指定覆盖包含路径的编译器命令行选项。
<ul>
<li>默认值以 <code>-I</code> 起始，使用版本库目录下的 <code>3rdparty/freetype/include</code> 目录带有适当引号的完整路径。</li>
</ul>
</li>
<li><a href="../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量 <code>SHBuild_VCS_hg</code> 或 <code>SHBuild_VCS_git</code></a> 指定构建时的版本控制系统，作用参见以下说明。</li>
</ul>
<p>　　在 stage 2 环境中构建其它目标时接受以下<a href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">外部环境变量</a>（部分被 SHBuild 直接以环境变量的方式接受）：</p>
<ul>
<li><code>INCLUDES</code> ：包含路径，和非 SHBuild 中的 <code>Makefile</code> 惯用法含义类似。</li>
<li><code>LDFLAGS</code> ：链接命令行选项。</li>
<li><code>LIBS</code> ：作为命令行选项的链接时使用的库路径。</li>
<li><code>LIBS_RPATH</code> ：非 Windows 平台使用的 <code>rpath</code> 路径。</li>
<li>SHBuild 附加构建选项环境变量：参见 <code>Tools/Scripts/SHBuild-YSLib-common.txt</code> 。其中变量 <code>SHBuild_CXXFLAGS</code> 同时作用在预编译头构建。</li>
</ul>
<h3 id="版本字符串"><a class="header" href="#版本字符串">版本字符串</a></h3>
<p>　　在 stage 1 构建 YFramework 前，通过选择的版本控制系统指定确定版本字符串，可在被构建的 YFramework 库中引用。</p>
<p>　　确定版本字符串时，检查对应的命令，具体方式详见关于<a href="#%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E6%94%AF%E6%8C%81">版本控制系统支持</a>的描述。若检查都失败，则版本字符串为空串。否则，使用第一个检查成功的命令生成对应的版本字符串。</p>
<p><strong>已知限制</strong> 若使用 <code>git</code> 生成版本字符串，当前同时依赖 <code>sed</code> 命令。</p>
<p>　　若版本字符串非空，则通过宏定义的方式参与之后的构建。当前影响以下源文件所在的翻译单元：</p>
<ul>
<li><code>YFramework/source/YSLib/Core/YCoreUtilities.cpp</code></li>
</ul>
<p>　　在构建前，若被影响的上述翻译单元已被构建，在生成目录中对应的（以 <code>.d</code> 为扩展名的）依赖文件被修改，以添加对版本控制系统中的特定文件的依赖。这能使最新的版本控制系统的修改影响生成的目标代码，而无需手动修改这些翻译单元的源文件。</p>
<p><strong>已知限制</strong> 当前自动更新依赖的实现同时依赖 <code>sed -i</code> 命令。</p>
<h2 id="toolsscriptsshbuild-buildapptxt"><a class="header" href="#toolsscriptsshbuild-buildapptxt">Tools/Scripts/SHBuild-BuildApp.txt</a></h2>
<p>　　NPLA1 应用程序构建脚本。可利用此工具脚本调用 SHBuild 构建特定<em>配置(configuration)</em> 下使用 YSLib 库和基础环境开发的应用程序。</p>
<p>　　<strong>这个脚本是公开的工具</strong>，被安装脚本部署。</p>
<h3 id="基本原理"><a class="header" href="#基本原理">基本原理</a></h3>
<p>　　<strong>配置</strong>是特定用途的一组程序输出的集合。常见软件配置可以区分目标平台，是否为调试配置等。</p>
<p>　　脚本通过设置特定的环境变量并调用 SHBuild 递归扫描指定目录完成构建。其中调用命令由环境变量 <code>SHBuild</code> 指定。若变量 <code>SHBuild</code> 为空，则假定使用脚本程序在 Sysroot 中，由 Sysroot 的布局确定的 SHBuild 的位置作为变量 <code>SHBuild</code> 的默认值。</p>
<p>　　脚本支持区分 debug 和非 debug 配置以及静态和 DLL 配置。详见以下说明。</p>
<p>　　使用 debug 配置总称 debug 模式。使用其它配置总称 release 模式。</p>
<h3 id="调用方式"><a class="header" href="#调用方式">调用方式</a></h3>
<p>　　无参数调用时，显示帮助文本。以第一参数指定<strong>配置名称</strong>，执行脚本直接一次性配置后构建。之后可选的其它参数被脚本传递给 SHBuild ，详见以下的操作说明。</p>
<h3 id="使用须知"><a class="header" href="#使用须知">使用须知</a></h3>
<p>　　脚本依赖 Sysroot 。</p>
<p>　　这个脚本被 <a href="#toolsscriptsshbuild-buildpkgsh"><code>Tools/Scripts/SHBuild-BuildPkg.sh</code></a> 调用。</p>
<p>　　当前只支持构建，不支持部署。</p>
<p>　　构建时调用的工具链命令行及配置详见 <a href="#toolsscriptsshbuild-yslib-commontxt"><code>Tools/Scripts/SHBuild-YSLib-common.txt</code></a> 的说明。</p>
<p>　　需要先确保源代码可访问。<strong>注意</strong>源代码目录会被递归扫描，建议在目录中只包含所有需要构建的源文件或被包含的文件。</p>
<h3 id="操作说明"><a class="header" href="#操作说明">操作说明</a></h3>
<p>　　一般步骤：</p>
<ul>
<li>新建一个 GNU bash 脚本（以下称为<em>用户构建脚本</em> ），调用此脚本（若无法在 <code>PATH</code> 找到，需要使用完整路径）。</li>
<li>以源代码所在目录的路径作为参数，执行通过此脚本包含的 <code>SHBuild_BuildApp</code> 函数，等待构建完成。</li>
<li>直接包含后的脚本仍可使用无参数调用用户构建脚本查看选项和说明。</li>
</ul>
<p>　　简化操作：也可以不创建用户构建脚本，直接在命令行中执行，例子见<a href="../GettingStarted.zh-CN.html">入门</a>。</p>
<p>　　若有必要，在调用本脚本之前设置 <code>SHBuild_BuildDir</code> 变量为指定输出文件所在的目录的完整路径，如：</p>
<pre><code class="language-shell">export SHBuild_BuildDir=$(dirname "$0"`/../build)
</code></pre>
<p>　　上述命令行指定相对于用户构建脚本上一层目录的 <code>build</code> 子目录下作为基准输出路径。若不显式设置此变量，工具脚本会指定其默认值为用户构建脚本所在的目录。</p>
<p>　　调用本脚本。脚本会自动加入必要的参数调用 SHBuild ，传递的参数依次具体如下：</p>
<ul>
<li>中间变量 <code>SHBOPT</code> 的值，包括根据配置决定的目录设置选项、<code>-xid,include -xmode,2</code> 以及用户在脚本命令行指定的剩余选项 <code>SHBOPT_BASE</code> 。</li>
<li>传递给本脚本的配置名称以外的可选参数。</li>
<li><code>SHBuild_BuildApp</code> 的值，用于编译器的库配置（包含路径以及使用 DLL 需要的宏定义 <code>-DYF_DLL -DYB_DLL</code> ），由脚本根据静态或动态库配置自动确定，无需重复输入类似选项。</li>
</ul>
<p><strong>特别注意</strong> 脚本执行<strong>以输出基准路径作为当前工作目录</strong>，需要以此为基准指定源文件路径（ <code>SHBuild</code> 使用的 <code>SRCPATH</code> 参数）。</p>
<p>　　通过脚本命令行间接传递给 <code>SHBuild</code> 的参数 <code>SHBOPT_BASE</code> 以及函数 <code>SHBuild_BuildApp</code> 的参数都可以进一步对构建过程进行调整，如 <code>-xj,2</code> 指定 2 个并行线程构建。</p>
<p><strong>注意</strong> 以 SHBuild 作为 <a href="../Development.zh-CN.html#npla1-%E8%84%9A%E6%9C%AC">NPLA1 脚本</a>解释器时，传递的参数可能会被 SHBuild 截获，而不被继续传递给脚本中调用的 SHBuild 。为避免这种情形，在 <code>-xcmd,RunNPLFile</code> 和本的脚本文件名选项后，可加上 <code>--</code> 分隔其余命令行参数。</p>
<h3 id="配置设置"><a class="header" href="#配置设置">配置设置</a></h3>
<p>　　传递给 SHBuild 指定使用 <code>.配置名称</code> 相对路径（无需另外指定 <code>-xd,</code> 参数）。如 <code>-cdebug</code> 指定输出路径为 <code>.debug</code> 。省略此项默认配置名为 <code>shbuild</code> 。</p>
<p>　　脚本根据以下规则自动检测配置：</p>
<ul>
<li>若配置名称以 <code>debug</code> 起始，或环境变量的 <code>SHBuild_Debug</code> 值非空，则视为使用 debug 配置。</li>
<li>若配置名称以 <code>static</code> 结束，活环境变量 <code>SHBuild_Static</code> 的值非空，则视为使用 static 配置。</li>
</ul>
<h3 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h3>
<p>　　环境变量 <code>SHBuild_Debug</code> 和 <code>SHBuild_Static</code> 可按上述自动检测配置过程指定配置类型。</p>
<p>　　默认情况下，release 配置会在链接器命令行加入 <code>-mwindows</code> ，<a href="../Prerequisitions.zh-CN.html">和 debug 配置编译的程序行为不保证相同</a>。设置非空变量 <code>SHBuild_NoAdjustSubsystem</code> 禁用此行为。</p>
<p>　　脚本使用包含 YSLib 库的编译器命令行。脚本已经导出了用于链接器的包含使用 YSLib 库命令行参数的变量 <code>LDFLAGS</code> 和 <code>LIBS</code> 。若有必要，可设置 SHBuild 附加构建选项环境变量（参见 Tools/Scripts/SHBuild-YSLib-common.txt ）。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Tools/ProjectGenerator.zh-CN.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../Tutorial.zh-CN.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Tools/ProjectGenerator.zh-CN.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../Tutorial.zh-CN.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
