<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>脚本 - The YSLib Book</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Book tranplanted from YSLib BitBucket wiki.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Home.html"><strong aria-hidden="true">1.</strong> 索引/Index</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Home.en-US.html"><strong aria-hidden="true">1.1.</strong> English Version</a></li><li class="chapter-item expanded "><a href="../Home.zh-CN.html"><strong aria-hidden="true">1.2.</strong> 简体中文版</a></li><li class="chapter-item expanded "><a href="../Contents.zh-CN.html"><strong aria-hidden="true">1.3.</strong> Contents(zh-CN)/主题目录</a></li></ol></li><li class="chapter-item expanded "><a href="../GettingStarted.zh-CN.html"><strong aria-hidden="true">2.</strong> 入门</a></li><li class="chapter-item expanded "><a href="../Development.zh-CN.html"><strong aria-hidden="true">3.</strong> 开发说明</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Prerequisitions.zh-CN.html"><strong aria-hidden="true">3.1.</strong> 先决条件</a></li><li class="chapter-item expanded "><a href="../GettingSources.zh-CN.html"><strong aria-hidden="true">3.2.</strong> 获取源代码</a></li><li class="chapter-item expanded "><a href="../Build.zh-CN.html"><strong aria-hidden="true">3.3.</strong> 构建</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../BuildDocumentation.zh-CN.html"><strong aria-hidden="true">3.3.1.</strong> 构建文档</a></li></ol></li><li class="chapter-item expanded "><a href="../Test.zh-CN.html"><strong aria-hidden="true">3.4.</strong> 测试</a></li><li class="chapter-item expanded "><a href="../Run.zh-CN.html"><strong aria-hidden="true">3.5.</strong> 运行</a></li></ol></li><li class="chapter-item expanded "><a href="../Features.zh-CN.html"><strong aria-hidden="true">4.</strong> 结构和特性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ProjectDependencies.zh-CN.html"><strong aria-hidden="true">4.1.</strong> （内部）项目依赖性说明</a></li><li class="chapter-item expanded "><a href="../Features/NPL.zh-CN.html"><strong aria-hidden="true">4.2.</strong> NPL</a></li></ol></li><li class="chapter-item expanded "><a href="../EMPTY.html"><strong aria-hidden="true">5.</strong> 应用开发环境</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Sysroot.zh-CN.html"><strong aria-hidden="true">5.1.</strong> Sysroot</a></li><li class="chapter-item expanded "><a href="../YDE.zh-CN.html"><strong aria-hidden="true">5.2.</strong> YDE</a></li></ol></li><li class="chapter-item expanded "><a href="../EMPTY.html"><strong aria-hidden="true">6.</strong> 项目维护资源</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Releases.zh-CN.html"><strong aria-hidden="true">6.1.</strong> 发布工程</a></li><li class="chapter-item expanded "><a href="../Archives.zh-CN.html"><strong aria-hidden="true">6.2.</strong> 归档</a></li></ol></li><li class="chapter-item expanded "><a href="../EMPTY.html"><strong aria-hidden="true">7.</strong> 工具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Tools/SHBuild.zh-CN.html"><strong aria-hidden="true">7.1.</strong> SHBuild</a></li><li class="chapter-item expanded "><a href="../Tools/RevisionPatcher.zh-CN.html"><strong aria-hidden="true">7.2.</strong> RevisionPatcher</a></li><li class="chapter-item expanded "><a href="../Tools/SXML2XML.zh-CN.html"><strong aria-hidden="true">7.3.</strong> SXML2XML</a></li><li class="chapter-item expanded "><a href="../Tools/ProjectGenerator.zh-CN.html"><strong aria-hidden="true">7.4.</strong> ProjectGenerator</a></li><li class="chapter-item expanded "><a href="../Tools/Scripts.zh-CN.html" class="active"><strong aria-hidden="true">7.5.</strong> 脚本</a></li></ol></li><li class="chapter-item expanded "><a href="../Tutorial.zh-CN.html"><strong aria-hidden="true">8.</strong> 教程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Tutorial/Overview.zh-CN.html"><strong aria-hidden="true">8.1.</strong> 综述</a></li><li class="chapter-item expanded "><a href="../Tutorial/GUI.zh-CN.html"><strong aria-hidden="true">8.2.</strong> GUI</a></li><li class="chapter-item expanded "><a href="../Tutorial/Configuration.zh-CN.html"><strong aria-hidden="true">8.3.</strong> 程序配置</a></li></ol></li><li class="chapter-item expanded "><a href="../EMPTY.html"><strong aria-hidden="true">9.</strong> 附录/Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Terminology.zh-CN.html"><strong aria-hidden="true">9.1.</strong> 术语概要</a></li><li class="chapter-item expanded "><a href="../StandardUsing.en-US.html"><strong aria-hidden="true">9.2.</strong> Standard Using</a></li><li class="chapter-item expanded "><a href="../ReportedIssues.en-US.html"><strong aria-hidden="true">9.3.</strong> Reported Issues</a></li><li class="chapter-item expanded "><a href="../WikiRules.en-US.html"><strong aria-hidden="true">9.4.</strong> Wiki Rules</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The YSLib Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="概述"><a class="header" href="#概述">概述</a></h1>
<p>　　YSLib 项目提供一系列工具脚本。这些脚本主要集中位于 <code>Tools</code> 和 <code>Tools/Scripts</code> 。其余特定局部用途的脚本可能位于其它目录，这些脚本可能依赖版本库内的工具脚本或 YSLib 安装时部署的工具脚本。</p>
<p>　　关于脚本的解释环境和其它一般规则，参见<a href="../Development.zh-CN.html#%E8%84%9A%E6%9C%AC">关于脚本的开发说明</a>。</p>
<p><strong>注释</strong> 维护者和开发者需要阅读开发说明，以保持脚本程序符合文档的描述。其中的一些信息（如关于环境变量等运行时环境的描述）也可能提供对脚本的非开发者用户有帮助的说明，作为<a href="../Run.zh-CN.html">运行环境</a>中说明的补充。</p>
<h1 id="tools"><a class="header" href="#tools">Tools</a></h1>
<p>　　未归类的工具目录。这个目录的脚本是可用于整个项目或非特定子项目的工具脚本，如公用的构建脚本。</p>
<p>　　工具脚本位于版本库目录 <code>Tools</code> 及其子目录 <code>Scripts</code> 下。</p>
<p>　　工具主要用于开发，包括构建和版本库维护。</p>
<p>　　一部分工具脚本也可被部署到 <a href="../Sysroot.zh-CN.html">Sysroot</a> 。在 <a href="SHBuild.zh-CN.html">stage 2 SHBuild</a> 安装后运行的脚本可依赖安装的 Sysroot 实例的文件系统布局。支持维护版本库的开发脚本应保证在此之前（不依赖 Sysroot 的实例或仅依赖构建 stage 1 后可用的有限环境）可用。</p>
<h2 id="toolsinstall-sysrootsh"><a class="header" href="#toolsinstall-sysrootsh">Tools/install-sysroot.sh</a></h2>
<p>　　Sysroot 安装脚本。用于直接构建和部署基础环境。</p>
<p>　　构建时会调用 <code>Tools/Scripts</code> 目录下的脚本，按需构建 <a href="SHBuild.zh-CN.html">stage 1 SHBuild</a> 后间接调用 <code>SHBuild</code> 构建 <code>YBase</code> 和 <code>YFramework</code> 的静态库和动态库，再构建依赖于动态库的 <code>SHBuild</code> 。</p>
<p>　　构建使用变量 <code>SHBuild_BuildDir</code> 指定的路径作为中间输出目录，默认为 YSLib 版本库根目录下的 <code>build/$(SHBuild_GetBuildName)</code> 目录。</p>
<p>　　构建脚本同时可安装文件，完成 Sysroot 所需文件的部署。安装的起始目标位置由称为<strong>安装路径</strong>的目录路径指定，其字符串形式去除结尾分隔符的目录文件名为<strong>安装路径前缀</strong>。安装过程在必要时可创建 Sysroot 根目录、安装路径指定的目录及其子目录。安装路径的确定方式详见以下的使用方式。</p>
<p>　　部署时使用 stage 1 SHBuild 更新文件和目录，在必要时创建符号链接或硬链接，若失败则改为普通复制。仅当被部署的文件为中间目标启用硬链接，以免后续操作意外覆盖源文件。注意在 Windows 上创建符号链接可能因为权限不足失败，取决于用户和组策略。建议使用系统管理权限运行以避免可能的权限问题。</p>
<h3 id="基本使用"><a class="header" href="#基本使用">基本使用</a></h3>
<p>　　脚本接受在 stage 2 使用的 <code>SHBuild</code> 命令行中的选项为命令行参数，如</p>
<pre><code>Tools/install-sysroot.sh -xj,2
</code></pre>
<p>　　使用 2 个并行线程构建。</p>
<p>　　脚本也支持变量配置构建使用的路径，默认相当于使用如下 bash 命令配置变量：</p>
<pre><code class="language-bash">: ${SHBuild_SysRoot:=&quot;$YSLib_BaseDir/sysroot&quot;}
SHBuild_PrepareBuild
: ${SHBuild_BuildDir:=&quot;$YSLib_BaseDir/build/$(SHBuild_GetBuildName)&quot;}
</code></pre>
<p>　　其中：</p>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0-shbuild_preparebuild"><code>SHBuild_PrepareBuild</code></a> 是 <code>Tools/Scripts/SHBuild-common.sh</code> 中的函数。</li>
<li>各个变量参见<a href="../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">开发文档中的环境变量的说明</a>。</li>
</ul>
<p>　　在 stage 1 SHBuild 构建调用 NPLA1 脚本 <code>Tools/Scripts/SHBuild-YSLib*.txt</code> ，调用方式和接受的配置（构建目标等）、具体默认设置和注意事项见对应 shell 脚本的文档相关章节。</p>
<h1 id="toolsscripts"><a class="header" href="#toolsscripts">Tools/Scripts</a></h1>
<p>　　这个目录的脚本可用于整个项目或项目核心部分的构建工具使用。</p>
<p>　　当前有以下脚本忽略重复的 <code>.</code> 或 <code>source</code> 命令：</p>
<ul>
<li>SHBuild-common.sh</li>
</ul>
<p>　　以前缀 <code>SHBuild_</code> 起始的名称保留使用。</p>
<p>　　其中，前缀 <code>SHBuild_Env_</code> 总是表示环境配置的只读变量名。这些变量若未被指定，可在第一次访问时（具体时机未指定）初始化为：</p>
<ul>
<li><code>SHBuild_Env_Arch</code> ：参见函数 <code>SHBuild_CheckUName</code> 。</li>
<li><code>SHBuild_Env_OS</code> ：参见函数 <code>SHBuild_CheckUName</code> 。</li>
<li><code>SHBuild_Env_TempDir</code> ：缓存函数 <code>SHBuild_GetTempDir</code> 的输出。</li>
<li><code>SHBuild_Env_uname</code> ：缓存命令 <code>uname</code> 的输出。</li>
<li><code>SHBuild_Env_uname_m</code> ：缓存命令 <code>uname -m</code> 的输出。</li>
</ul>
<h2 id="toolsscriptsgenerateprojectssh"><a class="header" href="#toolsscriptsgenerateprojectssh">Tools/Scripts/GenerateProjects.sh</a></h2>
<p>　　调用 <a href="ProjectGenerator.zh-CN.html">ProjectGenerator</a> 生成项目文件。</p>
<p>　　当前支持生成所有 <code>.cbp</code> 文件。</p>
<p>　　要求可使用 <code>hg</code> 或 <code>git</code> 命令取版本库根目录，否则不保证输出到正确的路径。</p>
<h3 id="变量-projectgenerator"><a class="header" href="#变量-projectgenerator">变量 ProjectGenerator</a></h3>
<p>　　调用 RevisionPatcher 的命令。默认直接使用 <code>which ProjectGenerator</code> 的结果，一般要求可执行文件在环境变量 <code>PATH</code> 中。</p>
<h2 id="toolsscriptspatchrevisionsh"><a class="header" href="#toolsscriptspatchrevisionsh">Tools/Scripts/PatchRevision.sh</a></h2>
<p>　　开发过程中使用 <a href="RevisionPatcher.zh-CN.html">RevisionPatcher</a> 维护源文件中版本号的脚本。</p>
<p>　　当前只支持 Mercurial 或 Git 版本库的已添加或修改的未提交文件。</p>
<p>　　使用的版本控制系统会被检查。通过检查的条件、确定使用的版本控制的机制及支持的控制检查的环境变量同 Tools/Scripts/SHBuild-YSLib*.txt 公用的版本控制系统支持，参见以下相关章节的说明。</p>
<p>　　若检查都失败，则脚本出错，不再继续运行。</p>
<p>　　脚本利用 <code>hg</code> 或 <code>git</code> 命令把未提交的这些修改导出为补丁备份到版本库根目录的 <code>bak.patch</code> ，然后使用这些内容调用 RevisionPatcher 取得文件和对应的新的版本号列表，最后使用 <code>sed</code> 查找对应文件并更新版本号。</p>
<p>　　脚本依赖 <code>sed</code> 命令。使用的 <code>sed</code> 应支持 <code>-b -i</code> 选项。可使用 Linux 或 MSYS2 的发行版中的 sed 4.8 程序。</p>
<p><strong>警告</strong> 某些 Win32 版本的 <code>sed</code> ，如 MSYS2 MinGW64 sed 4.4 可能损坏文本文件的行尾。有些替代版本可能解决<a href="https://stackoverflow.com/questions/4652652">这一问题</a>。</p>
<p><strong>注释</strong> 当前不检查特定版本 <code>sed</code> 对选项的支持。</p>
<p>　　若没有找到 <code>\version r</code> 模式的版本号前缀则忽略写入版本号。写入的版本号不影响换行符。</p>
<p><strong>注释</strong> 这个脚本可用于自动化。例如，在 Mercurial 仓库的 <code>hgrc</code> 的 <code>[hooks]</code> 节中添加 <code>precommit.PatchRevision = bash Tools/Scripts/PatchRevision.sh</code> 可在每次提交前调用这个脚本。在 YSLib 中，仅在主分支版本中启用。</p>
<h3 id="变量-patchbegin"><a class="header" href="#变量-patchbegin">变量 PatchBegin</a></h3>
<p>　　匹配版本号的起始行，应为一个表示行数的正整数。默认值为 <code>&quot;1&quot;</code> 。</p>
<h3 id="变量-patchend"><a class="header" href="#变量-patchend">变量 PatchEnd</a></h3>
<p>　　匹配版本号的结束行，应为一个表示行数的正整数。默认值为 <code>&quot;20&quot;</code> 。</p>
<h3 id="变量-revisionpatcher"><a class="header" href="#变量-revisionpatcher">变量 RevisionPatcher</a></h3>
<p>　　调用 RevisionPatcher 的命令。默认值为 <code>which RevisionPatcher</code> 的结果。</p>
<p><strong>注释</strong> 可执行文件可以在环境变量 <code>PATH</code> 中。</p>
<h3 id="变量-patchhg"><a class="header" href="#变量-patchhg">变量 PatchHg</a></h3>
<p>　　指定使用 Mercurial 。参见以上确定使用 Mercurial 或 Git 的说明。</p>
<h3 id="变量-patchgit"><a class="header" href="#变量-patchgit">变量 PatchGit</a></h3>
<p>　　指定使用 Git 。参见以上确定使用 Mercurial 或 Git 的说明。</p>
<h2 id="toolsscriptsshbuild-bootstrapsh"><a class="header" href="#toolsscriptsshbuild-bootstrapsh">Tools/Scripts/SHBuild-bootstrap.sh</a></h2>
<p>　　编译 <a href="SHBuild.zh-CN.html">stage 1 SHBuild</a> 时被包含的脚本。</p>
<p>　　其中指定了静态链接需要依赖的 YSLib 源文件以及头文件路径等。</p>
<h2 id="toolsscriptsshbuild-buildsh"><a class="header" href="#toolsscriptsshbuild-buildsh">Tools/Scripts/SHBuild-build.sh</a></h2>
<p>　　编译 <a href="SHBuild.zh-CN.html">stage 1 SHBuild</a> 的脚本。</p>
<p>　　使用变量 <code>SHBuild_Output</code> 指定输出路径。默认值为 <code>SHBuild</code> ，即在当前工作目录下生成名为 <code>SHBuild</code> 的可执行文件（视宿主平台不同可能带后缀如 Win32 带 <code>.exe</code> ）。</p>
<p>　　调用函数 <code>SHBuild_CheckPCH</code> 检查预编译头：若变量 <code>SHBuild_NoPCH</code> 非空则跳过预编译头，否则使用预编译头包含标准库头。预编译的头文件目标由 YBase 下的 <code>stdinc.h</code> ，之后构建时包含预编译头路径为 <code>$SHBuild_PCH_stdinc_h</code> 。后者的默认路径为当前工作目录下的 <code>stdinc.h</code> 。</p>
<p>　　因为升级或更换编译器和/或选项，可导致预编译头文件（ <code>.gch</code> 文件）不和生成的环境匹配而不被识别。</p>
<p><strong>注意</strong> 预编译头文件不保证对不同的操作系统版本兼容，参见<a href="../Prerequisitions.zh-CN.html">先决条件</a>中 PC(Win32) 平台关于操作系统版本的说明。</p>
<p>　　不被识别的预编译头文件通常：</p>
<ul>
<li>可引起编译器警告，并忽略预编译头文件。
<ul>
<li>若仅需避免产生警告，确保编译器命令行使用恰当选项，如添加 <code>-Wno-invalid-pch</code> 。</li>
</ul>
</li>
<li>可能引起无法构建的错误。</li>
</ul>
<p>　　一般仍然需要避免使用不匹配的预编译头文件。若无法保证预编译头文件和使用的工具链和选项匹配：</p>
<ul>
<li>可设置变量 <code>SHBuild_NoPCH</code> 的值非空以跳过预编译头文件的使用。</li>
<li>可以手动删除生成的预编译头文件。在没有设置变量 <code>SHBuild_NoPCH</code> 的情形下构建通常会默认自动生成。
<ul>
<li><strong>注释</strong> 具体的支持和生成预编译头文件的位置参见具体构建目标的说明，如 <a href="../Sysroot.zh-CN.html#%E6%9E%84%E5%BB%BA%E4%B8%AD%E9%97%B4%E6%96%87%E4%BB%B6">Sysroot</a> 。</li>
</ul>
</li>
</ul>
<p><strong>已知缺陷</strong> 构建时不自动更新预编译头。</p>
<h2 id="toolsscriptsshbuild-buildappsh"><a class="header" href="#toolsscriptsshbuild-buildappsh">Tools/Scripts/SHBuild-BuildApp.sh</a></h2>
<p>　　应用程序构建脚本。这个脚本被保留，不再具有实际功能。</p>
<p>　　<strong>这个脚本是公开的工具</strong>，被 <code>Tools/install-sysroot.sh</code> 部署到安装路径下的 <code>bin</code> 目录下。</p>
<h2 id="toolsscriptsshbuild-buildpkgsh"><a class="header" href="#toolsscriptsshbuild-buildpkgsh">Tools/Scripts/SHBuild-BuildPkg.sh</a></h2>
<p>　　包构建脚本。当前只支持构建应用程序，具体步骤和使用的参数参见 <code>Tools/Script/SHBuild-BuildApp.txt</code> 。</p>
<p>　　<strong>这个脚本是公开的工具</strong>，被 <code>Tools/install-sysroot.sh</code> 部署到安装路径下的 <code>bin</code> 目录下。</p>
<h2 id="toolsscriptsshbuild-commonsh"><a class="header" href="#toolsscriptsshbuild-commonsh">Tools/Scripts/SHBuild-common.sh</a></h2>
<p>　　被应用程序构建脚本包含的脚本，提供公共基础功能。</p>
<p>　　<strong>这个脚本是公开的工具</strong>，被 <code>Tools/install-sysroot.sh</code> 部署到安装路径下的 <code>bin</code> 目录下。</p>
<p><strong>注意</strong> 这个脚本包含 <code>INC_SHBuild_common</code> 守卫变量检查，默认重复包含只被执行一次。</p>
<h3 id="函数-shbuild_popd"><a class="header" href="#函数-shbuild_popd">函数 SHBuild_Popd</a></h3>
<p>　　同 <code>bash</code> 内建 <code>popd</code> 但不回显标准输出。</p>
<h3 id="函数-shbuild_pushd"><a class="header" href="#函数-shbuild_pushd">函数 SHBuild_Pushd</a></h3>
<p>　　同 <code>bash</code> 内建 <code>pushd</code> 但不回显标准输出。</p>
<h3 id="函数-shbuild_put"><a class="header" href="#函数-shbuild_put">函数 SHBuild_Put</a></h3>
<p>　　使用 <code>printf</code> 输出非格式字符串。</p>
<h3 id="函数-shbuild_puts"><a class="header" href="#函数-shbuild_puts">函数 SHBuild_Puts</a></h3>
<p>　　使用 <code>printf</code> 输出非格式的换行的字符串。</p>
<p>　　换行符由变量 <code>SHBuild_EOL</code> 指定。当前默认值通过检查 <code>$COMSPEC</code> 是否定义，以确保 Windows 环境（包括 MSYS ）使用 CR+LF ，其它情况使用 LF 。</p>
<p>　　这个函数在可用时可用于代替 <code>echo</code> ，以取得对环境更好的适应性。</p>
<p><strong>注意</strong> 具体的检查逻辑实现可能在以后改变。</p>
<h3 id="函数-shbuild_assertnonempty"><a class="header" href="#函数-shbuild_assertnonempty">函数 SHBuild_AssertNonempty</a></h3>
<p>　　断言第一参数为名称的变量非空，否则显示出错并退出。</p>
<p>　　使用 <code>eval</code> 实现。</p>
<h3 id="函数-shbuild_checkedcall"><a class="header" href="#函数-shbuild_checkedcall">函数 SHBuild_CheckedCall</a></h3>
<p>　　检查第一参数为名称的命令存在，否则显示出错并退出。</p>
<p>　　使用 <code>hash</code> 实现以优化性能。</p>
<h3 id="函数-shbuild_checkedcallsilent"><a class="header" href="#函数-shbuild_checkedcallsilent">函数 SHBuild_CheckedCallSilent</a></h3>
<p>　　同 SHBuild_CheckedCall ，但不显示错误外的标准输出。</p>
<h3 id="函数-shbuild_initreadonly"><a class="header" href="#函数-shbuild_initreadonly">函数 SHBuild_InitReadonly</a></h3>
<p>　　断言第一参数为名称的变量非空，若空则使用 <code>eval</code> 对后续求值并初始化第一参数指定的只读变量。若发生初始化则在标准输出中显示。</p>
<h3 id="函数-shbuild_2m"><a class="header" href="#函数-shbuild_2m">函数 SHBuild_2m</a></h3>
<p>　　接受 1 个表示路径的参数，调用 <code>cygpath</code> 转换路径到 Windows 混合风格路径。</p>
<p>　　当 <code>cygpath</code> 不存在时返回原路径。</p>
<h3 id="函数-shbuild_2u"><a class="header" href="#函数-shbuild_2u">函数 SHBuild_2u</a></h3>
<p>　　接受 1 个表示路径的参数。</p>
<p>　　调用 <code>cygpath</code> 转换 Windows 路径到 UNIX 路径。</p>
<p>　　当 <code>cygpath</code> 不存在时返回原路径。</p>
<h3 id="函数-shbuild_echoescape"><a class="header" href="#函数-shbuild_echoescape">函数 SHBuild_EchoEscape</a></h3>
<p>　　当标准输出使用终端时调用 <code>echo -ne</code> 输出参数指定的 ANSI 转义序列。</p>
<p><strong>已知缺陷</strong> 不检查 <code>$TERM</code> 支持。</p>
<h3 id="函数-shbuild_echovar"><a class="header" href="#函数-shbuild_echovar">函数 SHBuild_EchoVar</a></h3>
<p>　　接受 2 个参数 x 和 y ，以特定颜色显示为 x = y 的形式。</p>
<h3 id="函数-shbuild_echovar_n"><a class="header" href="#函数-shbuild_echovar_n">函数 SHBuild_EchoVar_N</a></h3>
<p>　　接受 1 个参数 x ，调用 <code>SHBuild_EchoVar</code> 显示为 x = $x 的形式。</p>
<p>　　右侧求值时会替换参数中的 <code>.</code> 为 <code>_</code> 。</p>
<h3 id="函数-shbuild_checkuname"><a class="header" href="#函数-shbuild_checkuname">函数 SHBuild_CheckUName</a></h3>
<p>　　调用 <code>SHBuild_CheckedCall</code> 初始化只读变量 <code>SHBuild_Env_OS</code> 和 <code>SHBuild_Env_Arch</code> 的值。</p>
<p>　　变量 <code>SHBuild_Env_OS</code> 的值通过分类系统的值（一般即 <code>SHBuild_Env_uname</code> 的值）标识操作系统：</p>
<ul>
<li><code>OS_X</code> ：输入匹配 *Darwin* ，用于标识 OS X 系统</li>
<li><code>Win32</code> ：输入匹配 *MIGW* 或 *MSYS* ，用于标识 Windows （桌面）系统</li>
<li><code>Linux</code> ：输入匹配 *Linux* ，用于标识 Linux 系统。</li>
<li><code>unknown</code> ： 不支持的系统。</li>
</ul>
<p>　　变量 <code>SHBuild_Env_Arch</code> 的值通过分类输入的处理器体系结构的值（一般即 <code>SHBuild_Env_uname_m</code> 的值）标识体系结构：</p>
<ul>
<li><code>x86_64</code> ：输入匹配 x86_64 或 i*86-64 。</li>
<li><code>i*86</code> ：输入匹配 i*86 ，使用原值。</li>
<li><code>aarch64</code> ：输入是 aarch64 。</li>
<li><code>unknown</code> ：不支持的体系结构。</li>
</ul>
<p>　　若同时指定环境变量 <code>SHBuild_Env_Arch</code> 和 <code>SHBuild_Env_OS</code> ，不进行<a href="../Prerequisitions.zh-CN.html">自动环境检测</a>，不依赖 <code>uname</code> 。</p>
<h3 id="函数-shbuild_gettempdir"><a class="header" href="#函数-shbuild_gettempdir">函数 SHBuild_GetTempDir</a></h3>
<p>　　取临时目录的路径。</p>
<p>　　依次检查以下环境变量的值，若非空则作为结果：</p>
<ul>
<li><code>TMPDIR</code></li>
<li><code>TEMP</code></li>
<li><code>TMP</code></li>
</ul>
<p>　　若这些环境变量都没有非空值，则使用经过 <code>SHBuild_2m</code> 转换的 <code>/tmp</code>（被 <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap10.html#tag_10_01">POSIX.1 要求支持</a>）作为结果。</p>
<p><strong>注意</strong> 以上过程在所有平台上都一致。这是自适应环境的基本接口，因此不对环境变量的值的合法性进行判断。若结果不表示一个可访问的目录，在访问以此构造的文件路径时可能引发错误。应用程序一般需自行检查或保证使用的环境中这些路径可访问。</p>
<p><strong>说明</strong> 以上检查中，支持的环境变量符合<a href="https://en.wikipedia.org/wiki/TMPDIR">惯例(en-US)</a> 。检查环境变量的顺序（偶然地）和一些类似功能的实现（如 <a href="https://dev.mysql.com/doc/refman/8.0/en/temporary-files.html">MySQL 在 Windows 上</a>）一致，和其它一些特定平台的 API（如 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-gettemppathw">Win32 API</a> ）及另一些不作为公开行为的实现（如 <a href="https://gcc.gnu.org/onlinedocs/gcc-4.8.5/libiberty/Functions.html#index-choose_005ftmpdir-66">libiberty 的 <code>choose_tmpdir</code></a> ）可能不一致。被支持的环境变量可用性举例：</p>
<ul>
<li><code>TMPDIR</code> ：<a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html">POSIX.1 要求的环境变量</a> 。</li>
<li><code>TEMP</code> ：被 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-gettemppathw">Win32 文件 API</a> 等使用。</li>
<li><code>TMP</code> ：被 Win32 文件 API 和 <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/tempnam-wtempnam-tmpnam-wtmpnam?view=msvc-160">Microsoft C 运行时 API</a> 等使用。</li>
<li>另见<a href="https://devblogs.microsoft.com/oldnewthing/20150417-00/?p=44213">对 MS-DOS 和 Microsoft Windows 使用的临时目录环境变量解释</a>。</li>
</ul>
<p><strong>已知限制</strong> 不检查路径是否表示实际可写的目录。另见文件访问约定。</p>
<p>　　当前脚本实现假定临时目录可写，不满足条件时，文件操作可能失败。脚本使用的临时文件前也不保证检查文件可写。若此文件不可写（例如，在之前被 <code>root</code> 等高权限用户创建），则依赖文件可写的操作可能失败。对构建脚本，这可能导致依赖临时文件进行检查判断失效，而使错误的选项被使用。</p>
<p>　　一般地，脚本可使用特定的例程（如 Shell 脚本可选地使用<a href="https://stackoverflow.com/questions/2792675">在许多环境中可用的 <code>mktemp</code> 命令</a>）随机化文件名减少冲突。若需要更可靠地避免上述问题，可在运行脚本前清理临时目录，或预先设置 <code>SHBuild_GetTempDir</code> 访问的环境变量指定确保可写的空目录，同时避免并发调用脚本导致不安全并发访问此目录中的临时文件。脚本不使用其它方法确定直接使用的临时目录，但脚本间接调用的外部工具仍可能导致不安全的访问，而无法保证可靠。</p>
<h3 id="函数-shbuild_platform_detect"><a class="header" href="#函数-shbuild_platform_detect">函数 SHBuild_Platform_Detect</a></h3>
<p>　　通过参数指定的操作系统和体系结构名，并结合环境变量，确定平台名称，检查非空并返回。</p>
<p>　　当前支持的结果包括：</p>
<ul>
<li>MinGW64</li>
<li>MinGW32</li>
<li>MinGW_Clang64</li>
<li>MinGW_Clang32</li>
<li>MinGW_UCRT64</li>
<li>MinGW_ClangARM64</li>
<li>第一个参数指定的操作系统名</li>
</ul>
<p>　　当前 <code>Win32</code> 系统外的结果和 <code>SHBuild_CheckUName</code> 初始化 <code>SHBuild_Env_OS</code> 的结果一致。否则，处理如下：</p>
<ul>
<li>若环境变量 <code>MSYSTEM</code> 设置为 <code>MINGW64</code> 或 <code>MINGW32</code> ，结果对应为 <code>MinGW64</code> 或 <code>MinGW32</code> 。</li>
<li>否则，若操作系统名为 <code>Win32</code> ：
<ul>
<li>若体系结构为 <code>x86_64</code> ，则结果为 <code>MinGW64</code> 。</li>
<li>否则，结果为 <code>MinGW32</code> 。</li>
</ul>
</li>
<li>否则，结果为操作系统名。</li>
</ul>
<h3 id="函数-shbuild_preparebuild"><a class="header" href="#函数-shbuild_preparebuild">函数 SHBuild_PrepareBuild</a></h3>
<p>　　准备构建环境。初始化以下变量使之具有非空值：</p>
<ul>
<li><code>SHBuild_Env_TempDir</code></li>
<li><code>SHBuild_Env_Arch</code></li>
<li><code>SHBuild_Env_OS</code></li>
<li><code>SHBuild_Host_Arch</code></li>
<li><code>SHBuild_Host_OS</code></li>
</ul>
<h3 id="函数-shbuild_getbuildname"><a class="header" href="#函数-shbuild_getbuildname">函数 SHBuild_GetBuildName</a></h3>
<p>　　取用于进一步初始化构建路径的构建名称。</p>
<p>　　首先断言变量 <code>SHBuild_Env_Arch</code> 和 <code>SHBuild_Env_OS</code> 非空。结果为以变量 <code>SHBuild_Env_OS</code> 和 <code>SHBuild_Env_Arch</code> 的值作为参数调用函数 <code>SHBuild_Platform_Detect</code> 的结果。</p>
<h3 id="函数-shbuild_buildgch"><a class="header" href="#函数-shbuild_buildgch">函数 SHBuild_BuildGCH</a></h3>
<p>　　接受第一个参数指定的路径的头文件安装到第二个参数指定的路径下并使用第三个参数指定的命令行构建 GNU 预编译头。</p>
<h3 id="函数-shbuild_checkpch"><a class="header" href="#函数-shbuild_checkpch">函数 SHBuild_CheckPCH</a></h3>
<p>　　检查是否设置了非空的变量 <code>SHBuild_NoPCH</code> ，否则调用 <code>SHBuild_BuildGCH</code> 并生成 GNU 风格预编译头文件并设置内部变量 <code>SHBuild_IncPCH</code> 为合适的命令行选项用于包含生成的预编译头文件。</p>
<p>　　支持两个参数，同 <code>SHBuild_BuildGCH</code> 的前两个参数。</p>
<h3 id="函数-shbuild_2w"><a class="header" href="#函数-shbuild_2w">函数 SHBuild_2w</a></h3>
<p>　　接受 1 个表示路径的参数，调用 <code>cygpath</code> 转换 UNIX 路径到 Windows 路径。</p>
<p>　　当 <code>cygpath</code> 不存在时返回原路径。</p>
<h3 id="函数-shbuild_install"><a class="header" href="#函数-shbuild_install">函数 SHBuild_Install</a></h3>
<p>　　接受 2 个表示路径的参数，安装前者指定的文件到后者。</p>
<p>　　首先调用 <code>rsync</code> ，若失败调用 <code>cp</code> 。</p>
<p><strong>注意</strong> 防火墙可能导致 <code>rsync</code> 超时失败。</p>
<h3 id="函数-shbuild_installdir"><a class="header" href="#函数-shbuild_installdir">函数 SHBuild_InstallDir</a></h3>
<p>　　接受 2 个表示路径的参数，安装前者指定的目录到后者。</p>
<p>　　首先调用 <code>rsync</code> ，若失败调用 <code>cp</code> 。</p>
<p><strong>注意</strong> 防火墙可能导致 <code>rsync</code> 超时失败。</p>
<h3 id="函数-shbuild_install_exe"><a class="header" href="#函数-shbuild_install_exe">函数 SHBuild_Install_Exe</a></h3>
<p>　　接受 2 个表示路径的参数，安装前者指定的可执行文件到后者。</p>
<p>　　首先调用 <code>SHBuild_Install</code> ，然后在目标上设置可执行权限。</p>
<h3 id="函数-shbuild_install_hardlink"><a class="header" href="#函数-shbuild_install_hardlink">函数 SHBuild_Install_HardLink</a></h3>
<p>　　接受 2 个表示路径的参数，安装前者指定的文件到后者为硬链接。</p>
<p>　　首先删除目标，其次调用 Windows 命令解释器的 <code>mklink</code> ，若失败调用 <code>ln</code> 。</p>
<h3 id="函数-shbuild_install_hardlink_exe"><a class="header" href="#函数-shbuild_install_hardlink_exe">函数 SHBuild_Install_HardLink_Exe</a></h3>
<p>　　接受 2 个表示路径的参数，安装前者指定的可执行文件到后者为硬链接。</p>
<p>　　首先调用 <code>SHBuild_Install_HardLink</code> ，然后在目标上设置可执行权限。</p>
<p><strong>注意</strong> <code>mklink</code> 需要 Windows Vista 后的命令解释器(<code>cmd</code>) 的支持。硬链接需要文件系统（如 NTFS ）支持。</p>
<h3 id="函数-shbuild_install_link"><a class="header" href="#函数-shbuild_install_link">函数 SHBuild_Install_Link</a></h3>
<p>　　接受 2 个表示路径的参数，安装前者指定的可执行文件到后者为符号链接。</p>
<p>　　首先删除目标，其次调用 Windows 命令解释器的 <code>mklink</code> ，若失败调用 <code>ln</code> 。</p>
<p><strong>注意</strong> <code>mklink</code> 需要 Windows Vista 后的命令解释器(<code>cmd</code>) 的支持。符号链接需要文件系统（如 NTFS ）支持。权限不足可能导致 <code>mklink</code> 创建符号链接失败，可在组策略改变相关默认行为。在一些版本的系统上，可能需要<a href="https://support.microsoft.com/en-us/kb/2856739/en-us">进一步的配置</a>以通过链接执行文件。</p>
<h3 id="函数-shbuild_getsystemprefix"><a class="header" href="#函数-shbuild_getsystemprefix">函数 SHBuild_GetSystemPrefix</a></h3>
<p>　　按参数指定的平台名称字符串返回系统前缀字符串。</p>
<p>　　系统前缀用于在文件系统中安装部署。</p>
<p>　　通常系统前缀因为之前仍有非空的其它前缀（如 <code>SHBuild_SysRoot</code> 指定的值）而不是绝对路径的前缀。因此，系统前缀以 <code>/</code> 起始而不需要考虑所在的环境是否符合 FHS 的问题。</p>
<p>　　当前支持的结果包括：</p>
<ul>
<li>参数为 <code>MinGW64</code> 时，结果为 <code>/mingw64</code> 。</li>
<li>参数为 <code>MinGW32</code> 时，结果为 <code>/mingw32</code> 。</li>
<li>否则，结果为 <code>/usr</code> 。</li>
</ul>
<p>　　本函数的结果符合 <a href="../Sysroot.zh-CN.html">Sysroot</a> 中关于 Sysroot 的目录布局的约定。</p>
<h3 id="函数-shbuild_s2_prepare"><a class="header" href="#函数-shbuild_s2_prepare">函数 SHBuild_S2_Prepare</a></h3>
<p>　　初始化 <a href="../Sysroot.zh-CN.html">stage 2 Sysroot</a> 环境。</p>
<p>　　函数可使用一个参数作为变量 <code>SHBuild_SysRoot</code> 的默认值。</p>
<p>　　初始化这个变量后，断言其值非空，以其值作为创建目录，若指定的目录已存在则忽略。然后，初始化变量 <code>SHBuild_SystemPrefix</code>（参见 <code>Tools/Scripts/SHBuild-YSLib-build.txt</code> 的说明）。之后，初始化变量 <code>SR_Prefix</code> 的值为 <code>&quot;$SHBuild_SysRoot$SHBuild_SystemPrefix&quot;</code> 。</p>
<h3 id="函数-shbuild_s2_prepare_build"><a class="header" href="#函数-shbuild_s2_prepare_build">函数 SHBuild_S2_Prepare_Build</a></h3>
<p>　　初始化 stage 2 Sysroot 构建环境。</p>
<p>　　函数可使用一个参数。以这个参数调用 <code>SHBuild_S2_Prepare</code> ，然后导出变量 <code>SHBuild</code> 的值为 <code>&quot;$SR_Prefix/bin/SHBuild&quot;</code> 。</p>
<h2 id="toolsscriptsshbuild-common-optionssh"><a class="header" href="#toolsscriptsshbuild-common-optionssh">Tools/Scripts/SHBuild-common-options.sh</a></h2>
<p>　　被应用程序构建脚本包含的基础功能，提供默认的编译器和链接器命令行选项。</p>
<p>　　若某个变量提供默认值且执行脚本时没有非空值，则设置为脚本提供的默认值。</p>
<p>　　<strong>这个脚本是公开的工具</strong>，被 <code>Tools/install-sysroot.sh</code> 部署到安装路径下的 <code>bin</code> 目录下。</p>
<p>　　包含 <code>Tools/Scripts/SHBuild-common-toolchain.sh</code> 确定工具链。</p>
<p><strong>注意</strong> G++ 和 Clang++ 不完全兼容。以下部分变量通过 <code>Tools/Scripts/SHBuild-common-toolchain.sh</code> 中的例程判断 G++ 和 Clang ，并自动使用不同的选项默认值。因此直接通过名称和符号链接等方式伪装会失效而可能导致错误。</p>
<p>　　以下所有变量仅在外部环境设置为空或未设置时提供默认值，按顺序被指定。可在外部设置为非空值以避免被本脚本中的值覆盖。以下仅列出部分相对不容易变动的默认值，其它默认值参见脚本源代码。若不需要默认值，可以提前设置非空值或在 <code>.</code> 指令后直接设置其它（可能为空的）值。</p>
<h3 id="变量-shbuild_debug"><a class="header" href="#变量-shbuild_debug">变量 SHBuild_Debug</a></h3>
<p>　　默认值为空。</p>
<p>　　非空时，指定变量的值：</p>
<pre><code>CXXFLAGS_OPT_DBG='-O0 -g -D_GLIBCXX_DEBUG_PEDANTIC'
LDFLAGS_OPT_DBG=' '
</code></pre>
<h3 id="变量-c_cxxflags_gc"><a class="header" href="#变量-c_cxxflags_gc">变量 C_CXXFLAGS_GC</a></h3>
<p>　　C/C++ 编译器生成二进制节 GC 选项。</p>
<p>　　默认值为 <code>-fdata-sections -ffunction-sections</code> 。</p>
<p>　　设置后会被检查是否支持，参见下文。</p>
<h3 id="变量-ldflags_gc"><a class="header" href="#变量-ldflags_gc">变量 LDFLAGS_GC</a></h3>
<p>　　链接器生成二进制节 GC 选项。</p>
<p>　　默认值为 <code>-Wl,--gc-sections</code> 。</p>
<p>　　设置后会和 <code>C_CXXFLAGS_GC</code> 通过 <code>$CXX</code> 作为编译器编译链接简单程序测试是否支持。若不支持，此变量和 <code>C_CXXFLAGS_GC</code> 都会被置空。</p>
<p><strong>已知限制</strong> <a href="http://sourceforge.net/p/msys2/discussion/general/thread/2d6adff2/?limit=25">Windows 上的工具链可能缺乏 <code>/dev/null</code> 的必要支持</a>，因此此项检查使用的输出路径指定为 <code>/tmp/null</code> 。</p>
<h3 id="变量-c_cxxflags_pic"><a class="header" href="#变量-c_cxxflags_pic">变量 C_CXXFLAGS_PIC</a></h3>
<p>　　C 和 C++ 编译器共用的 PIC （ Position Independent Code ，位置无关代码）生成选项。</p>
<p>　　默认值在 Win32 上为空，其它平台上为 <code>-fPIC -fno-semantic-interposition</code> 。</p>
<p>　　用于保证生成的对象文件可被用于生成动态库。</p>
<h3 id="变量-ldflags_strip"><a class="header" href="#变量-ldflags_strip">变量 LDFLAGS_STRIP</a></h3>
<p>　　链接器剥离符号选项。</p>
<p>　　默认值为 <code>-s</code> 。</p>
<h3 id="变量-c_cxxflags_ext"><a class="header" href="#变量-c_cxxflags_ext">变量 C_CXXFLAGS_EXT</a></h3>
<p>　　指定 C/C++ 语言扩展的选项。</p>
<p>　　默认值和平台相关：若为 Win32 环境则为空，否则为 <code>-D_POSIX_C_SOURCE=200809L</code> 。</p>
<p><strong>注释</strong> 若实现环境没有提供适当的宏定义，YFramework 中使用 POSIX 平台文件系统 API 的实现要求不被满足而可能构建失败。</p>
<h3 id="变量-c_cxxflags_arch"><a class="header" href="#变量-c_cxxflags_arch">变量 C_CXXFLAGS_ARCH</a></h3>
<p>　　C 和 C++ 编译器共用的体系结构相关选项。</p>
<p>　　默认值为空。</p>
<p>　　不限制具体形式，使用 G++ 时可以是 <code>-march=native</code> 。</p>
<h3 id="变量-c_cxxflags_common"><a class="header" href="#变量-c_cxxflags_common">变量 C_CXXFLAGS_COMMON</a></h3>
<p>　　C 和 C++ 编译器共用的公共选项。</p>
<p>　　默认值为 <code>-pipe $C_CXXFLAGS_GC $C_CXXFLAGS_ARCH -pedantic-errors $C_CXXFLAGS_EXT</code> 。</p>
<h3 id="变量-c_cxxflags_opt_lv"><a class="header" href="#变量-c_cxxflags_opt_lv">变量 C_CXXFLAGS_OPT_LV</a></h3>
<p>　　C 和 C++ 编译器优化等级选项。</p>
<p>　　默认值为 <code>-O3</code> 。</p>
<h3 id="变量-c_cxxflags_warning"><a class="header" href="#变量-c_cxxflags_warning">变量 C_CXXFLAGS_WARNING</a></h3>
<p>　　C 和 C++ 编译器共用的警告命令行选项。</p>
<p>　　默认值包括以下列表中的内容：</p>
<ul>
<li><code>-Wall</code></li>
<li><code>-Wcast-align</code></li>
<li><code>-Wdeprecated</code></li>
<li><code>-Wdeprecated-declarations</code></li>
<li><code>-Wextra</code></li>
<li><code>-Wfloat-equal</code></li>
<li><code>-Wformat=2</code></li>
<li><code>-Winvalid-pch</code></li>
<li><code>-Wmissing-declarations</code></li>
<li><code>-Wmissing-include-dirs</code></li>
<li><code>-Wmultichar</code></li>
<li><code>-Wno-format-nonliteral</code></li>
<li><code>-Wredundant-decls</code></li>
<li><code>-Wshadow</code></li>
<li><code>-Wsign-conversion</code></li>
</ul>
<p>　　使用符合项目要求支持的 Clang++ 和 G++ 应支持这些选项。</p>
<h3 id="变量-c_cxxflags_impl_warning"><a class="header" href="#变量-c_cxxflags_impl_warning">变量 C_CXXFLAGS_IMPL_WARNING</a></h3>
<p>　　和特定实现相关的 C 和 C++ 编译器共用的警告命令行选项。</p>
<p>　　默认值包括若干特定实现的选项。</p>
<h3 id="变量-cxxflags_impl_warning"><a class="header" href="#变量-cxxflags_impl_warning">变量 CXXFLAGS_IMPL_WARNING</a></h3>
<p>　　和特定实现相关的 C++ 编译器警告命令行选项。</p>
<p>　　默认值包括若干特定实现的选项。</p>
<h3 id="变量-cxxflags_impl_common"><a class="header" href="#变量-cxxflags_impl_common">变量 CXXFLAGS_IMPL_COMMON</a></h3>
<p>　　和特定实现相关的 C++ 编译器一般命令行选项。</p>
<p>　　默认值包括若干特定实现的选项。</p>
<p>　　默认值按以下方式检查和指定线程参数：</p>
<ul>
<li>通过 <code>-dumpspecs</code> 的内容检查是否匹配 <code>mthreads:</code> 。若成功，编译器和链接器选项添加 <code>-mthreads</code> 。</li>
<li>否则，检查带有 <code>-mthread</code> 选项的构建。若（直接调用编译器驱动）构建通过，则链接器选项添加 <code>-mthreads</code> ，并检查编译。
<ul>
<li>若编译不通过，则编译器选项添加 <code>-D_MT</code> ，否则添加 <code>-mthreads</code> 。</li>
</ul>
</li>
<li>否则，若通过 <code>-dumpspecs</code> 的内容检查匹配 <code>no-pthread:</code> 且带有 <code>-pthread</code> 时无法构建，则保持编译器和链接器选项不变。</li>
<li>否则，编译器和链接器选项添加 <code>-pthread</code> 。</li>
</ul>
<p><strong>注意</strong> 当前不检查失败原因。参见函数 <code>SHBuild_GetTempDir</code> 的已知限制。</p>
<p>　　当前暂不支持判断其它环境。</p>
<h3 id="变量-cxxflags_impl_opt"><a class="header" href="#变量-cxxflags_impl_opt">变量 CXXFLAGS_IMPL_OPT</a></h3>
<p>　　和特定工具相关的 C++ 编译器优化命令行选项。</p>
<p>　　默认值包括若干特定实现的选项。</p>
<h3 id="变量-cflags_std"><a class="header" href="#变量-cflags_std">变量 CFLAGS_STD</a></h3>
<p>　　指定 C 标准的编译器命令行选项。</p>
<p>　　默认值为 <code>-std=c11</code> 。</p>
<h3 id="变量-cflags_warning"><a class="header" href="#变量-cflags_warning">变量 CFLAGS_WARNING</a></h3>
<p>　　C 编译器警告命令行选项。</p>
<p>　　默认值为 <code>$C_CXXFLAGS_WARNING $C_CXXFLAGS_IMPL_WARNING</code> 。</p>
<h3 id="变量-cxxflags_std"><a class="header" href="#变量-cxxflags_std">变量 CXXFLAGS_STD</a></h3>
<p>　　指定 C++ 标准的编译器命令行选项。</p>
<p>　　默认值为 <code>-std=c++11</code> 。</p>
<h3 id="变量-cflags_warning-1"><a class="header" href="#变量-cflags_warning-1">变量 CFLAGS_WARNING</a></h3>
<p>　　C 编译器警告命令行选项。</p>
<p>　　默认值包含以下列表中的内容：</p>
<ul>
<li>变量 <code>CFLAGS_WARNING</code> 的内容</li>
<li><code>-Wctor-dtor-privacy</code></li>
<li><code>-Wnon-virtual-dtor</code></li>
<li><code>-Woverloaded-virtual</code></li>
<li><code>-Wsign-promo</code></li>
<li>变量 <code>CXXFLAGS_IMPL_WARNING</code> 的内容</li>
</ul>
<h3 id="变量-cxxflags_opt_dbg"><a class="header" href="#变量-cxxflags_opt_dbg">变量 CXXFLAGS_OPT_DBG</a></h3>
<p>　　C++ 编译器优化和调试相关的命令行选项。在未设置非空的 <code>SHbuild_Debug</code> 时。</p>
<p>　　默认值包含以下列表中的内容：</p>
<ul>
<li>变量 <code>C_CXXFLAGS_OPT_LV</code> 的内容</li>
<li>变量 <code>CXXFLAGS_OPT_UseAssert</code> 没有被设置非空值时包含 <code>-NDEBUG</code></li>
<li>变量 <code>CXXFLAGS_IMPL_OPT</code> 的内容</li>
<li><code>-fomit-frame-pointer</code></li>
</ul>
<h3 id="变量-cflags"><a class="header" href="#变量-cflags">变量 CFLAGS</a></h3>
<p>　　C 编译器使用的命令行选项。</p>
<p>　　默认值为 <code>$CFLAGS_STD $C_CXXFLAGS_PIC $C_CXXFLAGS_COMMON $CFLAGS_WARNING $C_CXXFLAGS_COMMON_IMPL_ $CXXFLAGS_OPT_DBG</code> 。其中，<code>C_CXXFLAGS_COMMON_IMPL_</code> 是根据支持的编译器在内部定义的非公开变量。</p>
<p><strong>注意</strong> 当前和 C++ 编译器选项共用 <code>CXXFLAGS_OPT_DBG</code> 。</p>
<h3 id="变量-cxxflags"><a class="header" href="#变量-cxxflags">变量 CXXFLAGS</a></h3>
<p>　　C++ 编译器使用的命令行选项。</p>
<p>　　默认值为 <code>$CXXFLAGS_STD $C_CXXFLAGS_PIC $C_CXXFLAGS_COMMON $CXXFLAGS_WARNING $CXXFLAGS_IMPL_COMMON $C_CXXFLAGS_COMMON_IMPL_ $CXXFLAGS_OPT_DBG</code> 。其中，<code>C_CXXFLAGS_COMMON_IMPL_</code> 是根据支持的编译器在内部定义的非公开变量。</p>
<h3 id="变量-ldflags_opt_dbg"><a class="header" href="#变量-ldflags_opt_dbg">变量 LDFLAGS_OPT_DBG</a></h3>
<p>　　链接器优化和调试相关的命令行选项。在未设置非空的 <code>SHbuild_Debug</code> 时。</p>
<p>　　默认值为 <code>$LDFLAGS_STRIP $LDFLAGS_IMPL_OPT $LDFLAGS_GC</code> 。</p>
<h3 id="变量-ldflags"><a class="header" href="#变量-ldflags">变量 LDFLAGS</a></h3>
<p>　　链接器使用的命令行选项。</p>
<p>　　默认值依次包含以下内容：</p>
<ul>
<li>变量 <code>C_CXXFLAGS_PIC</code> 的内容。</li>
<li>和变量 <code>CXXFLAGS_IMPL_COMMON</code> 中等价的线程命令行选项。</li>
<li>变量 <code>LDFLAGS_OPT_DBG</code> 的内容。</li>
<li>可选的其它选项（参见以下 <code>Tools/Scripts/SHBuild-YSLib-common.txt</code> ）。</li>
</ul>
<p>　　默认使用 <code>-Wl,</code> 传递链接器特定的命令行。</p>
<h2 id="toolsscriptsshbuild-common-toolchainsh"><a class="header" href="#toolsscriptsshbuild-common-toolchainsh">Tools/Scripts/SHBuild-common-toolchain.sh</a></h2>
<p>　　被应用程序构建脚本包含的基础功能，提供默认的编译器和链接器等工具的名称。</p>
<p>　　支持 GCC/G++ 和 Clang/Clang++ 。</p>
<p>　　支持 <code>ar</code> 及与其兼容的工具 <code>gcc-ar</code>/<code>llvm-ar</code> 的自动检测。对 Clang++ 和 G++ ，分别使用 <code>llvm-ar</code> 和 <code>gcc-ar</code> 。</p>
<p>　　以下可在环境外部配置，在值确定后被导出：</p>
<ul>
<li><code>CC</code>
<ul>
<li>默认值为 <code>gcc</code> 。</li>
</ul>
</li>
<li><code>CXX</code>
<ul>
<li>默认值为 <code>g++</code> 。</li>
</ul>
</li>
<li><code>AR</code>
<ul>
<li>默认值为变量 <code>CXX</code> 指定的 C++ 编译器确定的自动检测结果；若非 Clang++ 和 G++ ，则使用 <code>ar</code> 。</li>
</ul>
</li>
<li><code>ARFLAGS</code>
<ul>
<li>默认值为 <code>rcs</code> 。</li>
</ul>
</li>
<li><code>LD</code>
<ul>
<li>默认值为变量 <code>CXX</code> 的值。</li>
</ul>
</li>
</ul>
<p>　　<strong>这个脚本是公开的工具</strong>，被 <code>Tools/install-sysroot.sh</code> 部署到安装路径下的 <code>bin</code> 目录下。</p>
<h3 id="函数-shbuild_checkcompiler"><a class="header" href="#函数-shbuild_checkcompiler">函数 SHBuild_CheckCompiler</a></h3>
<p>　　尝试调用以参数指定的编译器，并按检查结果选择和输出参数的值。</p>
<p>　　检查编译器时，首先排除参数指定的编译器不可执行的情形，然后通过尝试编译以参数指定的源程序进行。前四参数分别指定编译器的路径、尝试编译的源程序、检查成功时输出的结果和检查失败时输出的结果，之后的参数指定编译选项。</p>
<p>　　检查前断言前两个参数非空。指定编译选项的参数为空时，第三和第四参数可能不提供或为空。</p>
<p>　　结果是以下之一：</p>
<ul>
<li>空值（第一参数指定不可执行的路径）</li>
<li>第三参数（检查成功时的结果）</li>
<li>第四参数（检查失败时的结果）</li>
</ul>
<h3 id="函数-shbuild_checkcc"><a class="header" href="#函数-shbuild_checkcc">函数 SHBuild_CheckCC</a></h3>
<p>　　尝试调用参数指定的编译器以检查 C 编译器风格。结果是以下之一：</p>
<ul>
<li>空值（不支持的编译器）</li>
<li><code>Clang</code></li>
<li><code>GCC</code></li>
</ul>
<h3 id="函数-shbuild_checkcxx"><a class="header" href="#函数-shbuild_checkcxx">函数 SHBuild_CheckCXX</a></h3>
<p>　　尝试调用参数指定的编译器以检查 C++ 编译器风格。结果是以下之一：</p>
<ul>
<li>空值（不支持的编译器）</li>
<li><code>Clang++</code></li>
<li><code>G++</code></li>
</ul>
<h2 id="toolsscriptsshbuild-self-hostsh"><a class="header" href="#toolsscriptsshbuild-self-hostsh">Tools/Scripts/SHBuild-self-host.sh</a></h2>
<p>　　<a href="SHBuild.zh-CN.html">SHBuild</a> 自举测试用脚本。</p>
<p>　　使用 SHBuild 编译并静态链接构建 SHBuild 。和 stage 1 SHBuild 类似，直接使用 YSLib 源文件。</p>
<h2 id="toolsscriptsshbuild-self-host-dllsh"><a class="header" href="#toolsscriptsshbuild-self-host-dllsh">Tools/Scripts/SHBuild-self-host-DLL.sh</a></h2>
<p>　　<a href="SHBuild.zh-CN.html">SHBuild</a> 自举测试用脚本。</p>
<p>　　使用 SHBuild 编译并动态链接构建 SHBuild 。依赖 <code>/usr/lib</code> 中存在的 YFramework 和 YBase 动态库文件。</p>
<h2 id="toolsscriptsshbuild-yslibsh"><a class="header" href="#toolsscriptsshbuild-yslibsh">Tools/Scripts/SHBuild-YSLib.sh</a></h2>
<p>　　作为 stage 1 SHBuild 公共配置脚本被不同的 stage 1 构建脚本包含。</p>
<p>　　包含脚本依次执行：</p>
<ul>
<li>初始化变量 <a href="../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><code>SHBuild_ToolDir</code></a> 。</li>
<li>初始化变量 <a href="../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><code>YSLib_BaseDir</code></a> 。</li>
<li>初始化变量 <code>SHBuild_PCH_stdinc_h</code> 。</li>
<li>包含脚本 Tools/Scripts/SHBuild-common-options.sh 。</li>
<li>赋值变量 <code>INCLUDE_PCH</code> 为版本库的 YBase/include/stdinc.h 。</li>
<li>赋值变量 <code>INCLUDES</code> 为版本库目录下的适合作为编译器选项使用的头文件目录列表。</li>
<li>定义函数。</li>
</ul>
<p><strong>注意</strong> 这个脚本包含 <code>INC_SHBuild_YSLib</code> 守卫变量检查，默认重复包含只被执行一次。</p>
<h3 id="变量-shbuild_pch_stdinc_h"><a class="header" href="#变量-shbuild_pch_stdinc_h">变量 SHBuild_PCH_stdinc_h</a></h3>
<p>　　预编译头文件名称，默认为 &quot;<code>stdinc.h</code>&quot; 。</p>
<h3 id="函数-shbuild_s1_initializepch"><a class="header" href="#函数-shbuild_s1_initializepch">函数 SHBuild_S1_InitializePCH</a></h3>
<p>　　初始化 stage 1 使用的预编译头文件。</p>
<pre><code>SHBuild_CheckPCH &quot;$INCLUDE_PCH&quot; &quot;$SHBuild_PCH_stdinc_h&quot;
</code></pre>
<h2 id="toolsscriptsshbuild-yslibtxt"><a class="header" href="#toolsscriptsshbuild-yslibtxt">Tools/Scripts/SHBuild-YSLib*.txt</a></h2>
<p>　　构建 YSLib 用的 NPLA1 脚本，包含以下文件：</p>
<ul>
<li>Tools/Scripts/SHBuild-YSLib-common.txt ：被 <code>Tools/Scripts/SHBuild-YSLib-build.txt</code> 加载的 NPLA1 脚本。</li>
<li>Tools/Scripts/SHBuild-YSLib-build.txt ：使用 SHBuild 构建 debug 或 release 配置的 YBase 和 YFramework 库的 NPLA1 脚本，被 <code>Tools/install-sysroot.sh</code> 调用，其中 SHBuild 默认为 stage 1 SHBuild 。</li>
</ul>
<p>　　调用方式详见 <a href="SHBuild.zh-CN.html">stage 1 SHBuild 中关于 NPL 支持的说明</a>。</p>
<p>　　可通过外部环境变量配置脚本行为。</p>
<h3 id="版本控制系统支持"><a class="header" href="#版本控制系统支持">版本控制系统支持</a></h3>
<p>　　脚本以相同的方式检查和识别版本控制系统。</p>
<p>　　以下环境变量提示使用 Mercurial 或 Git ：</p>
<ul>
<li>若<a href="../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量 <code>SHBuild_VCS_hg</code></a> 非空，则检查 <code>hg</code> 命令可用。</li>
<li>否则，若<a href="../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量 <code>SHBuild_VCS_git</code></a> 非空，则检查 <code>git</code> 命令可用。</li>
<li>否则，依次检查 <code>hg</code> 和 <code>git</code> 命令可用，若 <code>hg</code> 可用则不再检查 <code>git</code> 。</li>
</ul>
<p>　　命令可用需要满足以下条件：</p>
<ul>
<li>被检查的命令应在 <code>$PATH</code> 中。
<ul>
<li>若在 Windows 中使用 shell ，可能需要提前设置环境以确保继承环境变量。
　　* <strong>注意</strong> MSYS2 提供的 <code>mercurial</code> 包的可执行文件是脚本而不是可执行文件，不被 NPLA1 脚本调用的 Windows 命令行支持。
　　* <strong>注释</strong> 不使用 <code>HG</code> 环境变量，因为可能设置为不被支持的 <code>hg</code> 程序路径。事实上，MSYS2 的包 <code>mercurial</code> 安装到 <code>/etc/profile.d/mercurial.sh</code> 设置 <code>HG</code> 为脚本，覆盖从其它位置继承的 <code>hg.exe</code> 。</li>
</ul>
</li>
<li>且当前工作目录求在对应的版本库中，同时确定仓库的顶层目录路径。
<ul>
<li>对 Git ，要求存在工作区。</li>
</ul>
</li>
</ul>
<h2 id="toolsscriptsshbuild-yslib-commontxt"><a class="header" href="#toolsscriptsshbuild-yslib-commontxt">Tools/Scripts/SHBuild-YSLib-common.txt</a></h2>
<p>　　<code>Tools/Scripts/SHBuild-YSLib-common.txt</code> 包含一些公共的库，包括支持类似 <code>Tools/Scripts/SHBuild-common-options.sh</code> 和 <code>Tools/Scripts/SHBuild-common-toolchain.sh</code> 的选项以环境变量的方式配置，但 C 编译器相关的选项除外（不使用而被忽略）。</p>
<p>　　除关于 <a href="../Development.zh-CN.html#shell-%E8%84%9A%E6%9C%AC">shell 脚本</a>和 <a href="../Development.zh-CN.html#npla1-%E8%84%9A%E6%9C%AC">NPLA1 脚本</a>之间的一般差异外，与 <code>Tools/Scripts/SHBuild-common-options.sh</code> 和 <code>Tools/Scripts/SHBuild-common-toolchain.sh</code> 的不同为：</p>
<ul>
<li>通过调用函数进入<strong>构建环境变量检测</strong>并在之后进入回调函数中构建。
<ul>
<li>按需初始化变量。构建环境变量检测可能延迟访问以避免不必要初始化的值。配置时为确定变量的默认值的检查的调用顺序可能不同。</li>
<li>使用 debug 模式时，<code>CXXFLAGS_OPT_DBG</code> 设置为 <code>-O0 -g -D_GLIBCXX_DEBUG_PEDANTIC</code> ，不再被环境变量覆盖。</li>
<li>生成变量默认值的选项之间的空白符可能不同（通常可确保为一个空格）。</li>
<li>附加支持构建应用的配置，在导出的变量的默认值中添加扩展的选项（参见以下相关说明）替换 shell 脚本中指定的默认值（可影响其它默认值）。</li>
<li>附加检查 <a href="https://github.com/google/sanitizers/wiki">sanitizer</a> 。参见以下相关章节的说明。</li>
</ul>
</li>
<li>支持更多变量和默认值。除非另行指定，这些变量在构建环境变量检测中使用。参见以下各节。</li>
<li>提供部分和 shell 脚本不同的函数，详见版本库中的 <code>doc/NPL.txt</code> 。</li>
</ul>
<p>　　这个脚本被 <code>Tools/Scripts/SHBuild-YSLib-build.txt</code> 加载，并被 <code>Tools/install-sysroot.sh</code> 间接调用。</p>
<p>　　脚本支持外部调用这个脚本的命令行设置变量的默认值，以覆盖直接指定构建环境变量检测确定的选项，如：</p>
<pre><code>CXX=clang++ CXXFLAGS='-std=c++11 -O2' Tools/install-sysroot.sh
</code></pre>
<p><strong>警告</strong> 使用预编译头选项和缺陷同 <a href="#toolsscriptsshbuild-buildsh"><code>Tools/Scripts/SHBuild-build.sh</code></a> 。其中的特性未指定使用 shell 实现，和后者可能存在 shell 环境中可见的差异。</p>
<p>　　<strong>这个脚本是公开的工具</strong>，被 <code>Tools/install-sysroot.sh</code> 部署到安装路径下的 <code>var/NPLA1</code> 目录下。</p>
<h3 id="变量-ldflags_dyn_base"><a class="header" href="#变量-ldflags_dyn_base">变量 LDFLAGS_DYN_BASE</a></h3>
<p>　　指定动态库基础链接选项。</p>
<p>　　默认值和平台相关：若为 Win32 环境则使用 <code>-shared -Wl,--dll</code> ，否则为 <code>-shared</code> 。</p>
<h3 id="变量-ldflags_dyn_extra"><a class="header" href="#变量-ldflags_dyn_extra">变量 LDFLAGS_DYN_EXTRA</a></h3>
<p>　　指定动态库附加链接选项。</p>
<p>　　默认值等价于 <code>-Wl,--no-undefined,--dynamic-list-data,--dynamic-list-cpp-new,--dynamic-list-cpp-typeinfo</code> 。</p>
<h3 id="变量-ldflags_dyn"><a class="header" href="#变量-ldflags_dyn">变量 LDFLAGS_DYN</a></h3>
<p>　　指定动态库链接选项。</p>
<p>　　默认值为 <code>$LDFLAGS_DYN_BASE $LDFLAGS_DYN_EXTRA</code> 。</p>
<h3 id="变量-libs_rpath"><a class="header" href="#变量-libs_rpath">变量 LIBS_RPATH</a></h3>
<p>　　用于指定在运行时 ELF 映像需要的动态库的路径的链接器选项。</p>
<p>　　在 Win32 默认不设置，其它平台默认值为 <code>-Wl,-rpath,'\$ORIGIN:\$ORIGIN/../lib'</code> 。</p>
<h3 id="变量-libpfx"><a class="header" href="#变量-libpfx">变量 LIBPFX</a></h3>
<p>　　库前缀。</p>
<p>　　在 Win32 默认不设置，其它平台默认值为 <code>lib</code> 。</p>
<h3 id="变量-dsosfx"><a class="header" href="#变量-dsosfx">变量 DSOSFX</a></h3>
<p>　　动态库文件名后缀。</p>
<p>　　在 Win32 默认值为 <code>.dll</code> ，其它平台默认值为 <code>.so</code> 。</p>
<h3 id="变量-exesfx"><a class="header" href="#变量-exesfx">变量 EXESFX</a></h3>
<p>　　可执行文件名后缀。</p>
<p>　　在 Win32 默认值为 <code>.exe</code> ，其它平台默认不设置。</p>
<h3 id="sanitizer-检查支持"><a class="header" href="#sanitizer-检查支持">Sanitizer 检查支持</a></h3>
<p>　　构建环境变量检测支持 sanitizer ：若在变量 <code>CFLAGS</code>、<code>CXXFLAGS</code>、<code>LDFLAGS</code> 或 <code>SHBuild_CXXFLAGS</code> 中包含启用被支持的 sanitizer 的选项 （以 <code>-fsanitizer=address</code> 起始），配置最终在 <code>CFLAGS</code>、<code>CXXFLAGS</code> 和 <code>LDFLAGS</code> 最后添加自动调整的选项。</p>
<p>　　构建配置支持 ASan、TSan、MSan、UBSan 和 LSan 。Sanitizer 自身支持的系统和编译器详见 sanitizer 的文档。</p>
<p>　　ASan 使用的选项要求和建议参见 <a href="https://github.com/google/sanitizers/wiki/AddressSanitizer#faq">FAQ</a> 。</p>
<p><strong>注意</strong> <a href="https://gcc.gnu.org/legacy-ml/gcc/2014-10/msg00006.html">GCC 不支持 MSan</a> 。MSan 要求标准库<a href="https://github.com/google/sanitizers/wiki/MemorySanitizerLibcxxHowTo">使用带 MSan 的选项构建</a>，否则<a href="https://github.com/google/sanitizers/issues/542">会有假阳性结果</a>。</p>
<p><strong>注意</strong> 具体调整的选项参见脚本具体实现，不保持构建版本之间稳定。* <strong>注意</strong> 构建脚本不保证构建的二进制程序的具体可用性。构建的程序可能因为程序及 sanitizer 实现的缺陷运行时出错，可能另需具体排查原因修复。</p>
<h3 id="扩展选项的默认值"><a class="header" href="#扩展选项的默认值">扩展选项的默认值</a></h3>
<p>　　变量 <code>LDFLAGS</code> 的默认值依次包含：</p>
<ul>
<li>和 shell 脚本中相同的默认值。</li>
<li>生成可执行程序时且要求按需调整链接器参数时，附加的值：
<ul>
<li>当需要生成 Win32 子系统程序时，附加 <code>-mwindows</code> 。</li>
</ul>
</li>
<li>构建动态可执行程序时，变量 <code>LIBS_RPATH</code> 的内容。</li>
<li>构建动态库或应用时，变量 <code>LDFLAGS_DYN</code> 的内容。</li>
</ul>
<h3 id="shbuild-附加构建选项环境变量"><a class="header" href="#shbuild-附加构建选项环境变量">SHBuild 附加构建选项环境变量</a></h3>
<p>　　若回调函数中调用 SHBuild 构建，可在此之前设置<strong>扩展环境变量</strong>并调用函数 <code>SHBuild_Extend_CallVariables</code> 以更新被 SHBuild 使用的环境变量 <code>LDFLAGS</code> 和 <code>LIBS</code> 的值。这些影响 SHBuild 工具调用构建工具的命令行的 <strong>SHBuild 附加构建选项环境变量</strong>，包括：</p>
<ul>
<li><code>SHBuild_CFLAGS</code></li>
<li><code>SHBuild_CXXFLAGS</code></li>
<li><code>SHBuild_LDFLAGS</code></li>
<li><code>SHBuild_LIBS</code></li>
</ul>
<p>　　除非另行指定，SHBuild 附加构建选项环境变量的默认值为空，不被脚本设置。</p>
<h3 id="其它函数和可在外部设置的其它变量"><a class="header" href="#其它函数和可在外部设置的其它变量">其它函数和可在外部设置的其它变量</a></h3>
<p>　　详见版本库中的 <code>doc/NPL.txt</code> 。</p>
<p>　　其它变量不被构建环境变量检测访问，而通过函数调用生效，如 <code>SHBuild_Extend_CallVariables</code> 。</p>
<h2 id="toolsscriptsshbuild-yslib-buildtxt"><a class="header" href="#toolsscriptsshbuild-yslib-buildtxt">Tools/Scripts/SHBuild-YSLib-build.txt</a></h2>
<p>　　这个脚本当前包括和安装相关的流程，实现 <code>Tools/install-sysroot.sh</code> 在 stage 1 SHBuild 构建后的主要逻辑。</p>
<p>　　脚本使用 <code>Tools/Scripts/SHBuild-YSLib-common.txt</code> 中提供的一些函数。</p>
<p>　　脚本支持 <code>SHBuild_</code> 为前缀的环境变量指定构建和部署目标：</p>
<ul>
<li><code>SHBuild_UseDebug</code> 非空时启用构建和安装 debug 配置的库。</li>
<li><code>SHBuild_UseRelease</code> 非空时启用构建和安装 release 配置的库。</li>
<li><code>SHBuild_NoStatic</code> 非空时跳过静态库构建。</li>
<li><code>SHBuild_NoDynamic</code> 非空时跳过动态库构建。</li>
<li><code>SHBuild_No3rd</code> 非空时跳过第三方库安装。
<ul>
<li>对<a href="../Development.zh-CN.html#%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96%E9%A1%B9">外部依赖项</a>中的库，只安装启用的配置决定的必要的外部依赖。启用的配置由 <code>SHBuild_UseDebug</code> 和 <code>SHBuild_UseRelease</code> 指定。</li>
</ul>
</li>
<li><code>SHBuild_NoDev</code> 非空时跳过可选的开发工具构建和安装。</li>
<li><code>SHBuild_Rebuild_S1</code> 非空时跳过文件存在性检查，总是重新构建 stage 1 SHBuild 。</li>
<li><code>SHBuild_NoDev</code> 非空时跳过 stage 2 SHBuild 后的开发工具构建和安装。</li>
</ul>
<p>　　以下配置行为的环境变量（其中 <code>SS</code> 表示 SHBuild Settings ）被支持：</p>
<ul>
<li><code>SS_DebugEnv</code> 值非空时启用脚本执行时系统环境相关的调试输出，当前包括：
<ul>
<li>对环境变量修改时输出修改的变量名和对应的值。</li>
</ul>
</li>
<li><code>SS_Verbose</code> 值非空时启用详细消息输出，当前包括：
<ul>
<li>在 <code>LDFLAGS</code> 变量中附加 <code>-mwindows</code> 时提示。</li>
</ul>
</li>
</ul>
<p>　　以下构建时的中间变量可被外部配置，当外部没有配置或为空值时使用默认值：</p>
<ul>
<li><code>SHBuild_SystemPrefix</code> ：系统前缀，在 Sysroot 根路径下决定安装路径。
<ul>
<li>默认值由脚本 <code>Tools/Scripts/SHBuild-YSLib-common.txt</code> 中的函数的调用确定：同 <code>SHBuild_GetSystemPrefix (SHBuild_Platform_Detect SHBuild_Host_OS SHBuild_Host_Arch)</code> 的结果。</li>
<li>脚本 <code>Tools/Scripts/SHBuild-common.sh</code> 中提供 shell 脚本的等价调用：<code>$(SHBuild_GetSystemPrefix (SHBuild_Platform_Detect &quot;$SHBuild_Host_OS&quot; &quot;$SHBuild_Host_Arch&quot;))</code> 。</li>
</ul>
</li>
<li><code>SHBuild_YF_Libs_freetype</code> ：freetype 库链接参数。
<ul>
<li>默认值为 <code>-lfreetype</code> 或 <code>pkg-config --libs freetype2</code> 的输出结果。
<ul>
<li>其中存在 Sysroot <code>libfreetype.a</code> 时默认值为前者。</li>
</ul>
</li>
</ul>
</li>
<li><code>SHBuild_YF_Libs_FreeImage</code> ：FreeImage 库链接参数。
<ul>
<li>默认值为 <code>-lFreeImaged</code> 或 <code>-lFreeImage</code> ，对应 debug 和非 debug 配置。</li>
</ul>
</li>
</ul>
<p>　　<code>Tools/Scripts/SHBuild-YSLib-build.txt</code> 也可能使用其它变量用于传递参数给被调用的命令，包括一些 <code>SHBuild</code> 预期的变量；后者作为公开接口，但<strong>其具体含义和使用不保证在不同版本间稳定</strong>。</p>
<p>　　在 stage 1 构建时，接受以下环境变量：</p>
<ul>
<li><code>INCLUDES_freetype</code> 指定覆盖包含路径的编译器命令行选项。
<ul>
<li>默认值以 <code>-I</code> 起始，使用版本库目录下的 <code>3rdparty/freetype/include</code> 目录带有适当引号的完整路径。</li>
</ul>
</li>
<li><a href="../Development.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量 <code>SHBuild_VCS_hg</code> 或 <code>SHBuild_VCS_git</code></a> 指定构建时的版本控制系统，作用参见以下说明。</li>
</ul>
<p>　　在 stage 2 构建时接受以下外部环境变量（部分被 SHBuild 直接以环境变量的方式接受）：</p>
<ul>
<li><code>INCLUDES</code> ：包含路径，和非 SHBuild 中的 <code>Makefile</code> 惯用法含义类似。</li>
<li><code>LDFLAGS</code> ：链接命令行选项。</li>
<li><code>LIBS</code> ：作为命令行选项的链接时使用的库路径。</li>
<li><code>LIBS_RPATH</code> ：非 Windows 平台使用的 <code>rpath</code> 路径。</li>
<li>SHBuild 附加构建选项环境变量：参见 Tools/Scripts/SHBuild-YSLib-common.txt 。其中变量 <code>SHBuild_CXXFLAGS</code> 同时作用在预编译头构建。</li>
</ul>
<h3 id="版本字符串"><a class="header" href="#版本字符串">版本字符串</a></h3>
<p>　　在 stage 1 构建 YFramework 前，通过选择的版本控制系统指定确定版本字符串，可在被构建的 YFramework 库中引用。</p>
<p>　　确定版本字符串时，检查对应的命令，具体方式详见以上关于版本控制系统支持的描述。若检查都失败，则版本字符串为空串。否则，使用第一个检查成功的命令生成对应的版本字符串。</p>
<p><strong>已知限制</strong> 若使用 <code>git</code> 生成版本字符串，当前同时依赖 <code>sed</code> 命令。</p>
<p>　　若版本字符串非空，则通过宏定义的方式参与之后的构建。当前影响以下源文件所在的翻译单元：</p>
<ul>
<li><code>YFramework/source/YSLib/Core/YCoreUtilities.cpp</code></li>
</ul>
<p>　　在构建前，若被影响的上述翻译单元已被构建，在生成目录中对应的（以 <code>.d</code> 为扩展名的）依赖文件被修改，以添加对版本控制系统中的特定文件的依赖。这能使最新的版本控制系统的修改影响生成的目标代码，而无需手动修改这些翻译单元的源文件。</p>
<p><strong>已知限制</strong> 当前自动更新依赖的实现同时依赖 <code>sed -i</code> 命令。</p>
<h2 id="toolsscriptsshbuild-buildapptxt"><a class="header" href="#toolsscriptsshbuild-buildapptxt">Tools/Scripts/SHBuild-BuildApp.txt</a></h2>
<p>　　NPLA1 应用程序构建脚本。可利用此工具脚本调用 SHBuild 构建特定<em>配置(configuration)</em> 下使用 YSLib 库和基础环境开发的应用程序。</p>
<p>　　<strong>这个脚本是公开的工具</strong>，被 <code>Tools/install-sysroot.sh</code> 部署到安装路径下的 <code>var/NPLA1</code> 目录下。</p>
<h3 id="基本原理"><a class="header" href="#基本原理">基本原理</a></h3>
<p>　　<strong>配置</strong>是特定用途的一组程序输出的集合。常见软件配置可以区分目标平台，是否为调试配置等。</p>
<p>　　脚本通过设置特定的环境变量并调用 SHBuild 递归扫描指定目录完成构建。其中调用命令由环境变量 <code>SHBuild</code> 指定。若变量 <code>SHBuild</code> 为空，则假定使用脚本程序在 Sysroot 中，由 Sysroot 的布局确定的 SHBuild 的位置作为变量 <code>SHBuild</code> 的默认值。</p>
<p>　　脚本支持区分 debug 和非 debug 配置以及静态和 DLL 配置。详见以下说明。</p>
<p>　　debug 配置总称 debug 模式。非 debug 配置总称 release 模式。</p>
<h3 id="调用方式"><a class="header" href="#调用方式">调用方式</a></h3>
<p>　　无参数调用时，显示帮助文本。以第一参数指定<strong>配置名称</strong>，执行脚本直接一次性配置后构建。之后可选的其它参数被脚本传递给 SHBuild ，详见以下的操作说明。</p>
<h3 id="使用须知"><a class="header" href="#使用须知">使用须知</a></h3>
<p>　　脚本依赖 Sysroot 。</p>
<p>　　这个脚本被 <code>Tools/Scripts/SHBuild-BuildPkg.sh</code> 调用。</p>
<p>　　当前只支持构建，不支持部署。</p>
<p>　　构建时调用的工具链命令行及配置详见 <code>Tools/Scripts/SHBuild-YSLib-common.txt</code> 的说明。</p>
<p>　　需要先确保源代码可访问。<strong>注意</strong>源代码目录会被递归扫描，建议在目录中只包含所有需要构建的源文件或被包含的文件。</p>
<h3 id="操作说明"><a class="header" href="#操作说明">操作说明</a></h3>
<p>　　一般步骤：</p>
<ul>
<li>新建一个 GNU bash 脚本（以下称为<em>用户构建脚本</em> ），调用此脚本（若无法在 <code>PATH</code> 找到，需要使用完整路径）。</li>
<li>以源代码所在目录的路径作为参数，执行通过此脚本包含的 <code>SHBuild_BuildApp</code> 函数，等待构建完成。</li>
<li>直接包含后的脚本仍可使用无参数调用用户构建脚本查看选项和说明。</li>
</ul>
<p>　　简化操作：也可以不创建用户构建脚本，直接在命令行中执行，例子见<a href="../GettingStarted.zh-CN.html">入门</a>。</p>
<p>　　若有必要，在调用本脚本之前设置 <code>SHBuild_BuildDir</code> 变量为指定输出文件所在的目录的完整路径，如：</p>
<pre><code>export SHBuild_BuildDir=$(dirname &quot;$0&quot;`/../build)
</code></pre>
<p>　　上述命令行指定相对于用户构建脚本上一层目录的 <code>build</code> 子目录下作为基准输出路径。若不显式设置此变量，工具脚本会指定其默认值为用户构建脚本所在的目录。</p>
<p>　　调用本脚本。脚本会自动加入必要的参数调用 SHBuild ，传递的参数依次具体如下：</p>
<ul>
<li>中间变量 <code>SHBOPT</code> 的值，包括根据配置决定的目录设置选项、<code>-xid,include -xmode,2</code> 以及用户在脚本命令行指定的剩余选项 <code>SHBOPT_BASE</code> 。</li>
<li>传递给本脚本的配置名称以外的可选参数。</li>
<li><code>SHBuild_BuildApp</code> 的值，用于编译器的库配置（包含路径以及使用 DLL 需要的宏定义 <code>-DYF_DLL -DYB_DLL</code> ），由脚本根据静态或动态库配置自动确定，无需重复输入类似选项。</li>
</ul>
<p><strong>特别注意</strong> 脚本执行<strong>以输出基准路径作为当前工作目录</strong>，需要以此为基准指定源文件路径（ <code>SHBuild</code> 使用的 <code>SRCPATH</code> 参数）。</p>
<p>　　通过脚本命令行间接传递给 <code>SHBuild</code> 的参数 <code>SHBOPT_BASE</code> 以及函数 <code>SHBuild_BuildApp</code> 的参数都可以进一步对构建过程进行调整，如 <code>-xj,2</code> 指定 2 个并行线程构建。</p>
<p><strong>注意</strong> 以 SHBuild 作为 NPLA1 脚本解释器时，传递的参数可能会被 SHBuild 截获，而不被继续传递给 脚本中调用的 SHBuild 。为避免这种情形，在 <code>-xcmd,RunNPLFile</code> 和本的脚本文件名选项后，可加上 <code>--</code> 分隔其余命令行参数。</p>
<h3 id="配置设置"><a class="header" href="#配置设置">配置设置</a></h3>
<p>　　传递给 SHBuild 指定使用 <code>.配置名称</code> 相对路径（无需另外指定 <code>-xd,</code> 参数）。如 <code>-cdebug</code> 指定输出路径为 <code>.debug</code> 。省略此项默认配置名为 <code>shbuild</code> 。</p>
<p>　　脚本根据以下规则自动检测配置：</p>
<ul>
<li>若配置名称以 <code>debug</code> 起始，或环境变量的 <code>SHBuild_Debug</code> 值非空，则视为使用 debug 配置。</li>
<li>若配置名称以 <code>static</code> 结束，活环境变量 <code>SHBuild_Static</code> 的值非空，则视为使用 static 配置。</li>
</ul>
<h3 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h3>
<p>　　环境变量 <code>SHBuild_Debug</code> 和 <code>SHBuild_Static</code> 可按上述自动检测配置过程指定配置类型。</p>
<p>　　默认情况下，release 配置会在链接器命令行加入 <code>-mwindows</code> ，<a href="../Prerequisitions.zh-CN.html">和 debug 配置编译的程序行为不保证相同</a>。设置非空变量 <code>SHBuild_NoAdjustSubsystem</code> 禁用此行为。</p>
<p>　　脚本使用包含 YSLib 库的编译器命令行。脚本已经导出了用于链接器的包含使用 YSLib 库命令行参数的变量 <code>LDFLAGS</code> 和 <code>LIBS</code> 。若有必要，可设置 SHBuild 附加构建选项环境变量（参见 Tools/Scripts/SHBuild-YSLib-common.txt ）。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Tools/ProjectGenerator.zh-CN.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../Tutorial.zh-CN.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Tools/ProjectGenerator.zh-CN.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../Tutorial.zh-CN.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
