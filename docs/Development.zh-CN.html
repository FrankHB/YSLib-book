<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>开发说明 - The YSLib Book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Book tranplanted from YSLib BitBucket wiki.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The YSLib Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="开发说明"><a class="header" href="#开发说明">开发说明</a></h1>
<p>　　关于环境配置，详见<a href="Prerequisitions.zh-CN.html">先决条件</a>和<a href="Run.zh-CN.html">运行</a>。其中后者也包含部分面向最终用户的说明。</p>
<p>　　以下为面向开发者的说明。</p>
<h1 id="准备"><a class="header" href="#准备">准备</a></h1>
<ul>
<li>了解<a href="Prerequisitions.zh-CN.html">先决条件</a></li>
<li><a href="GettingSources.zh-CN.html">获取源代码</a></li>
<li>了解<a href="ProjectDependencies.zh-CN.html">项目依赖性</a>以确保源代码以外的必要的<a href="Terminology.zh-CN.html#%E5%86%85%E9%83%A8%E4%BE%9D%E8%B5%96%E5%92%8C%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96">外部依赖</a>可用</li>
<li>了解<a href="Terminology.zh-CN.html">术语概要</a>的体例以备参考</li>
</ul>
<p>　　YSLib 项目文档位于 YSLib 项目而不是本 wiki 项目中：</p>
<ul>
<li>维护者参考的细节和一般规则详见 YSLib 项目文档 <code>doc/ProjectRules.txt</code> 。</li>
<li>在 <a href="Terminology.zh-CN.html">本 wiki 项目文档约定的术语</a>的基础上，其它术语的完整定义详见 YSLib 项目文档 <code>doc/CommonRules.txt</code> 。</li>
<li>在 <a href="Features/NPL.zh-CN.html">本 wiki 的预定的 NPL 规范文档</a>的基础上，具体实现参见 YSLib 项目文档 <code>doc/NPL.txt</code> 。</li>
</ul>
<p><strong>注释</strong> 项目文件在 YSLib <a href="Terminology.zh-CN.html#%E7%89%88%E6%9C%AC%E5%BA%93">存储库</a>中维护。</p>
<h1 id="项目过程"><a class="header" href="#项目过程">项目过程</a></h1>
<p>　　基本规则参见 YSLib 项目文档 <code>doc/ProjectRules.txt</code> 。</p>
<p>　　本 wiki 项目作为用户手册和开发者补充文档的形式作为实现及之后阶段输出。</p>
<p>　　实现的附加输出为库和工具。</p>
<p>　　之前阶段（如设计）为前期过程，其文档和适用于维护过程的项目规则位于 YSLib 的项目文档中的 <code>doc/</code> 目录。其中整体过程由 <code>doc/Designation.txt</code> 指定。当前内联设计以外的过程，因此不存在设计外前期过程的单独文档。</p>
<h1 id="开发"><a class="header" href="#开发">开发</a></h1>
<ul>
<li><a href="Build.zh-CN.html">构建</a>
<ul>
<li><a href="BuildDocumentation.zh-CN.html">构建文档</a></li>
</ul>
</li>
<li><a href="Run.zh-CN.html">运行</a></li>
<li>使用 <a href="Sysroot.zh-CN.html">Sysroot</a> 开发和部署程序</li>
</ul>
<h1 id="平台"><a class="header" href="#平台">平台</a></h1>
<p>　　关于<strong>外部依赖</strong>、<strong>平台</strong>、<strong>目标平台</strong>和<strong>宿主平台</strong>等概念的一般定义参见<a href="Terminology.zh-CN.html#%E5%B9%B3%E5%8F%B0">术语概要</a>。</p>
<p>　　YSLib 项目约定一个体系结构和使用的外部依赖是一个平台。</p>
<p><strong>注释</strong> 这仍然满足<a href="Terminology.zh-CN.html#%E5%B9%B3%E5%8F%B0%E6%A0%87%E8%AF%86">关于平台标识默认的使用约定</a>。</p>
<p>　　YSLib 支持不同的目标平台。类似 ISO C/C++ 的独立实现(freestanding implementation) 和宿主实现(hosted implementation) ，平台分为两类：<strong>独立实现平台</strong>和<strong>宿主实现平台</strong>。后者存在操作系统的支持而前者没有。</p>
<h2 id="语言使用和实现要求"><a class="header" href="#语言使用和实现要求">语言使用和实现要求</a></h2>
<p>　　本节适用于 YSLib 项目，不直接限制依赖项和用户程序。项目中特定部分的规则及适用性详见 YSLib 项目文档 <code>doc/ProjectRules.txt</code> 。</p>
<p>　　本节不保证所有具体要求都是完备的。特别地，这里不指定仅具体平台配置适用的要求。对一般开发者，<a href="Prerequisitions.zh-CN.html">先决条件</a>中应已足够配置开发环境。</p>
<p><strong>原理</strong> 本节中的要求和配置补充<a href="Prerequisitions.zh-CN.html">先决条件</a>，和开发环境的选型可能直接相关，为维护者提供设定平台配置要求提供基准依据。</p>
<p>　　除脚本（见以下相关章节）外，使用 ISO C++ 作为主要开发语言。</p>
<p>　　不使用和 ISO C++03 以后被接受的特性不兼容的特性，包括但不限于：</p>
<ul>
<li>被取消的特性，如 ISO C++03 后导出模板的 <code>export</code> 关键字。
<ul>
<li>不限制有条件使用的之后的其它特性，如 <code>export</code> 被作为模块。（当前不使用模块。）</li>
</ul>
</li>
<li>在 ISO C++03 中标记为 deprecated 而在之后版本去除的特性，如 <code>const char</code> 数组类型左值到 <code>char*</code> 右值的转换。</li>
<li>在 ISO C++03 中标记为 deprecated 但在之后版本重新取消 deprecated 的特性，如修饰命名空间作用域声明的 <code>static</code> 。</li>
<li>实现的 Defect Report ，如 <a href="http://wg21.cmeerw.net/cwg/issue615">CWG 615</a> 。</li>
<li>显式排除的特定的语言特性：
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r3.pdf">P0145R3</a> ：ISO C++17 指定的特定表达式的求值顺序。
<ul>
<li><strong>注释</strong> 使用 <a href="https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Dialect-Options.html">G++ 的 <code>-fno-strong-eval-order</code> 选项</a>可显式指定假定避免依赖这项特性。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　注意即使使用特定模式，一些实现也可能引入之后的 Defect Report 而不保证兼容，如 <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65890">GCC PR 65890</a> 。</p>
<p>　　关于精确的特性使用规则、具体使用及备选的特性的清单等，详见<a href="StandardUsing.en-US.html">标准使用（英文）</a> 。</p>
<p>　　以下对语言实现的要求和支持情况适用整个项目。具体内容可能会在未来变动。</p>
<h3 id="基准实现要求"><a class="header" href="#基准实现要求">基准实现要求</a></h3>
<p>　　YSLib 依赖 ISO C++ 独立实现或宿主实现，附加以下要求：</p>
<ul>
<li>满足<a href="StandardUsing.en-US.html">标准使用(en-US)</a> 中具体特性的要求。
<ul>
<li><strong>注释</strong> 默认基于 ISO C++11 环境，但并不要求实现完整支持所有特性。</li>
<li><strong>注释</strong> 一些特性具有替代实现或者是可选的，而不被依赖。</li>
</ul>
</li>
<li>满足 ISO C++11 [implimits] 建议的最小实现要求。</li>
<li>标准库基于 ISO C++11 定义的宿主实现，并满足以下要求：
<ul>
<li><strong>注释</strong> 语言实现不需要是完整的宿主实现。</li>
<li>提供以下符合标准的整数类型：
<ul>
<li>定宽整数 <code>std::intN_t</code> 和 <code>std::uintN_t</code>（其中 N 为 8 、16 、32 或 64 ）。</li>
<li>类型 <code>std::uintptr_t</code> 。</li>
<li><strong>注释</strong> 定宽整数在 ISO C++11 中为可选支持。</li>
</ul>
</li>
<li>满足以下实现定义行为的要求：
<ul>
<li>至少支持 <code>std::placeholders::_7</code>。</li>
<li><strong>注释</strong> 按 ISO C++11 Annex B [implimits] ，符合标准的下限为 10 ，因此已被上述规则涵盖。</li>
</ul>
</li>
<li>假定用于迭代器的 <code>difference_type</code> 或坐标计算的有符号整数作为显式转换的目标类型且结果不能在范围内表示时，不引起副作用且结果的值不是能在此范围内表示的任意值（即为小于 <code>0</code> 的值）。
<ul>
<li><strong>注释</strong> 一个典型的例子是 <code>std::ptrdiff_t</code> 。</li>
<li>当前标准中，转换到有符号数的结果由实现定义。</li>
<li><a href="http://wg21.link/p0907">WG21 P0907</a> 已提议修改使用补码表示，并在 ISO C++20 采纳，按，符合此要求。</li>
<li><strong>注释</strong> 一般的到有符号数转换的由实现定义的行为仍不被依赖。</li>
</ul>
</li>
<li>假定特定类型的特定操作无异常抛出。
<ul>
<li><strong>注释</strong> 可能具有相应的异常规范。</li>
<li>当前包括：
<ul>
<li><code>std::string</code> 的默认构造函数。
<ul>
<li>注释 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4002.pdf">WG21 N4002</a> 引入了显式指定 <code>noexcept</code> ，仅从标准草案 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf">WG21 N4296</a> 起有效）。</li>
</ul>
</li>
<li>容器类型的迭代器的复制初始化。
<ul>
<li><strong>原理</strong> 这允许使用迭代器类型作为函数的参数时，不影响调用者的异常安全保证。</li>
<li><strong>注释</strong> 包括可能被显式定义的类的复制构造和转移构造函数。</li>
<li><strong>注释</strong> 已知 libstdc++ 、libc++ 和 Microsoft STL 的当前实现（蕴含所有被支持的平台配置）的非调试版本都满足这些要求且具有无异常抛出的异常规范。因为 <a href="https://eel.is/c++draft/nullablepointer.requirements#4"><code>NullablePointer</code> 的操作满足无异常抛出保证</a>，使用这些类型直接实现的迭代器的操作满足这里的要求。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>假定被包含在具有外部链接实体的函数体或声明命名空间作用域中外部链接名称的被 ODR 使用(<a href="http://eel.is/c++draft/basic.def.odr#3">odr-used</a>) 的 lambda 表达式相同。
<ul>
<li>否则会引起被包含的代码中的 lambda 在多个翻译单元 ODR 使用时<a href="http://eel.is/c++draft/basic.def.odr#6">违反 ODR 引发未定义行为</a> 。此类未定义行为包括以下情形：
<ul>
<li>所在函数体在 <code>extern inline</code> 函数。这被 <a href="http://wg21.cmeerw.net/cwg/issue765">CWG 765</a> 解决并存在于 ISO C++11 和<a href="http://eel.is/c++draft/dcl.fct.spec#4">之后的标准文本</a>中。
<ul>
<li>对符合 ISO C++11 及之后版本标准的实现，<a href="https://www.reddit.com/r/cpp/comments/40saz8/a_workaround_for_dangerous_lambda_odr_violations/">这个变通</a> 对其中的示例代码因此是不必要的；其它情况也有代码膨胀的缺陷，不应使用。</li>
<li>已知当前所有版本的 Microsoft VC++ 编译器都<a href="https://www.reddit.com/r/cpp/comments/40lm8o/lambdas_are_dangerous/">没有实现这个特性且会在内联代码后引起未预期的行为，计划在下一版本修复</a>。</li>
</ul>
</li>
<li>命名空间作用域中的 lambda 表达式，或所在函数体在其它实体，包括函数模板、类模板的成员函数以及类模板的成员函数模板。这是<a href="http://stackoverflow.com/questions/34717823/can-using-a-lambda-in-header-files-violate-the-odr/34721371#34721371">未被提交和解决的 ISO C++ 缺陷</a>。此处的假定作为用于避免这个问题。</li>
</ul>
</li>
<li>基于 <a href="https://mentorembedded.github.io/cxx-abi/abi.html#closure-types">Itanium ABI</a> 的实现符合这个条件。</li>
</ul>
</li>
<li>对宿主环境中程序外部的状态的并发修改不引起未定义行为。
<ul>
<li>现有操作系统和文件系统提供的接口和实现普遍不能保证避免 <a href="https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use">TOCTTOU 访问(en-US)</a> 导致的问题。具体修改的结果未指定，但应不直接引起无法预测的程序行为。</li>
<li>除非另行指定，本项目的实现不保证检查外部程序的修改。</li>
</ul>
</li>
</ul>
<p>　　假定 YSLib 实现和用户程序的代码满足以下要求：</p>
<ul>
<li>假定异常和标准库 RTTI 对象满足 ODR ，即使是在使用动态库的宿主实现中。
<ul>
<li>但影响用户代码生成的实现的二进制约定（如 <a href="https://reviews.llvm.org/rL205139">ARM64</a> ）且不使用以下错误实现变通的情形除外。</li>
<li>这要求用户代码不依赖影响相关符号可见性而导致 ODR 失效的特性。
<ul>
<li>例如，这不允许如 <code>dlopen</code> 使用 <code>RTLD_LOCAL</code> 加载具有相关符号的库。</li>
</ul>
</li>
<li>这允许 <code>std::type_info</code> 的比较操作和散列操作的高效实现，并避免一些实现错误。
<ul>
<li>使用 libstdc++ (libsupc++) 时，需要重定义宏 <code>__GXX_TYPEINFO_EQUALITY_INLINE</code> 和宏 <code>__GXX_MERGED_TYPEINFO_NAMES</code> 为 <code>1</code> 。
<ul>
<li>这是对 <code>std::type_info</code> 比较操作的错误实现的变通。
<ul>
<li>参见 <a href="https://gcc.gnu.org/viewcvs/gcc?view=revision&amp;revision=179236">GCC r179236</a> 的修改。</li>
<li>参见 <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=103240">GCC PR 103240</a> 。</li>
</ul>
</li>
<li>一般在编译器命令行中使用 <code>-U</code> 选项取消可能存在的预定义再使用 <code>-D</code> 选项重新显式定义，以避免预定义宏被重定义。</li>
<li>调整 <code>__GXX_TYPEINFO_EQUALITY_INLINE</code> 对启用 <code>__GXX_MERGED_TYPEINFO_NAMES</code> 是必要的。</li>
<li><strong>注释</strong> <code>__GXX_MERGED_TYPEINFO_NAMES</code> 默认值被<a href="https://gcc.gnu.org/viewcvs/gcc?view=revision&amp;revision=149964">修改</a> 以支持上述影响符号可见性的特性。</li>
</ul>
</li>
<li>其它实现暂不使用选项支持，以避免和上述二进制约定冲突。
<ul>
<li>libc++ 不支持另行调整，由实现根据<a href="Terminology.zh-CN.html#%E5%B9%B3%E5%8F%B0">平台环境</a>指定 <code>_LIBCPP_HAS_NONUNIQUE_TYPEINFO</code> 。</li>
<li>另见以下关于 <code>std::type_info</code> 比较的限制。</li>
</ul>
</li>
</ul>
</li>
<li>链接时除上述二进制约定，假定 <code>std::type_info</code> 相关的符号被共享。
<ul>
<li>这不允许在实现生成以外显式地<a href="https://stackoverflow.com/questions/19496643/using-clang-fvisibility-hidden-and-typeinfo-and-type-erasure">隐藏相关的符号</a>（如通过 <code>#pragma</code> 预处理指令或 <code>-fvisibility=hidden</code> 编译器命令行选项）。</li>
<li>这一般要求在兼容 GNU ld 的链接器在<a href="https://sourceware.org/binutils/docs/ld/Options.html#Options">命令行选项</a>中使用 <code>--dynamic-list-cpp-typeinfo</code> 等方式导出相关符号（也允许但不要求使用 <code>-rdynamic</code> 或 <code>-export-dynamic</code> ）。</li>
</ul>
</li>
</ul>
</li>
<li>不依赖 RTTI 的 <code>std::type_info</code> 对象在未命名命名空间中同名不同实体的比较结果：
<ul>
<li>libc++ 没有正确支持这些比较，参见 <a href="https://bugs.llvm.org/show_bug.cgi?id=34907">LLVM PR 34907</a>(<a href="https://github.com/llvm/llvm-project/issues/34255">LLVM GitHub issue 34255</a>)。</li>
<li>Clang++ <a href="https://github.com/llvm/llvm-project/issues/59790">当前没有正确支持生成相关名称</a>。</li>
<li><strong>注释</strong> 在未命名命名空间的实体和命名命名空间的实体之间的比较不被涵盖。</li>
</ul>
</li>
<li>假定在标准库宏 <code>NDEBUG</code> 被定义的翻译单元中的代码不违反异常规范。
<ul>
<li><strong>原理</strong> 这允许改进代码生成，如使用 <a href="https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Dialect-Options.html">G++ 的 <code>-fno-enforce-eh-specs</code> 选项</a>。</li>
<li>程序应不依赖违反异常规范时调用标准库的函数的行为。否则，程序行为未定义。
<ul>
<li><strong>注释</strong> 例如，违反上述特定类型的特定操作无异常抛出的假定时。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　YSLib 中具体子项目可要求更严格的实现假定，违反这些假定要求诊断，并可能在不保证支持的构建配置环境下终止构建。需要显式提供诊断时，若可行，应使用符合上述要求的可移植特性。此外，YSLib 实现可依赖可选的语言实现扩展。具体的更严格的假定、可选特性或非全局的特性使用参见项目版本库中 <code>doc</code> 目录下的相关项目文档。</p>
<p><strong>注释</strong> 一些诊断通过语言规则保证而无需显式提供。提供诊断使用的可移植特性的一个例子是 <code>#error</code> 预处理命令。</p>
<p><strong>原理</strong></p>
<p>　　本节中指定的要求通常难以以源代码的形式检查或检测，因此在此作为前提明确。一些普遍但并非严格必须作为全局依赖的特性和实现假定，可以通过源程序表达时，不在这里指定；但为简化实现，也可以通过要求的形式可选地指定。</p>
<p>　　YBase 对标准库的修正实现要求更严格的关于实现细节的假定。YBase 对标准库的不分替代（如 <code>std::addressof</code> ）需依赖更严格的实现特性才能完整实现和标准库相同的保证（尽管不分保证作为 YBase 替代是可选提供的）。依赖更严格的实现假定也允许依赖和向用户代码提供特定平台配置的功能特性，以及提供质量更好的高性能实现。</p>
<p><strong>注释</strong></p>
<p>　　非全局的特性涉及的假定可能以子项目或更小的模块作为单位明确其适用范围。关于可选指定的实现要求，参见以下的<a href="#%E5%8F%AF%E9%80%89%E5%AE%9E%E7%8E%B0%E8%A6%81%E6%B1%82">可选实现要求</a>。</p>
<h3 id="可选实现要求"><a class="header" href="#可选实现要求">可选实现要求</a></h3>
<p>　　以下相对<a href="#%E5%9F%BA%E5%87%86%E5%AE%9E%E7%8E%B0%E8%A6%81%E6%B1%82">基准实现要求</a>更严格的实现要求默认不作为全局默认要求，而可供特定的子项目和平台配置按需启用。具体使用参见存储库中 <code>doc/</code> 目录下有关具体子项目的项目文档。</p>
<ul>
<li>关于整数类型的假定：
<ul>
<li>1 字节具有 8 位（即 <code>CHAR_BIT == 8</code> ）。</li>
<li>相对 ISO C++ 要求更严格的特定整数类型的取值范围。</li>
<li>语言实现和外部环境满足以下表示的要求：
<ul>
<li>除指定的例外，整数类型的表示不具有<em>填充位(padding bit)</em> ，即构成其<a href="https://eel.is/c++draft/basic.types"><em>对象表示(object representation)</em></a> 的位和<a href="https://eel.is/c++draft/basic.types#general-4"><em>值表示(value representation)</em></a>一致，但这里指定的例外除外。
<ul>
<li><strong>注释</strong> 关于填充位，参见 ISO C 关于整数类型的描述。</li>
<li>指定的例外包含以下情形：
<ul>
<li>（可能 <em>cv</em> 限定的）<code>bool</code> 类型。</li>
<li>语义和表示可能兼容 ISO C23 <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2763.pdf"><code>_BitInt(N)</code></a> 的类型。
<ul>
<li><strong>注释</strong> 一个例子是 LLVM 扩展 <a href="https://blog.llvm.org/2020/04/the-new-clang-extint-feature-provides.html"><code>_ExtInt(N)</code></a> 。</li>
</ul>
</li>
<li>其它在 YSLib 中的 API 或<a href="#%E4%BA%92%E6%93%8D%E4%BD%9C">互操作</a>规范中指定的允许接受的特定整数类型。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>关于标准库实现的附加假定：
<ul>
<li>假定 <code>std::chrono::system_clock</code> 使用 1970-01-01 00:00:00 UTC 作为时间历元。
<ul>
<li><strong>注释</strong> 这和 <a href="https://zh.wikipedia.org/wiki/UNIX%E6%97%B6%E9%97%B4">UNIX 时间</a> 以及<a href="https://pubs.opengroup.org/onlinepubs/9699919799.orig/basedefs/V1_chap04.html#tag_04_15">POSIX.1</a> 的基本概念实质相同。这是 ISO C++11 中不存在但 ISO C++20 起在添加的要求，由 <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0355r7.html#time.clock.system">WG21 P0355R7</a> 引入。</li>
<li><strong>原理</strong> 主要的标准库实现（ libstdc++ 、libc++ 或 Microsoft STL ）都满足这个要求。被支持的实现不使用其它标准库，因此也都满足这个要求。即便使用其它实现，未来出现不满足这个要求的实现的可能性很小。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>原理</strong> 以上假定通常被主流实现支持，但并不直接被满足<a href="#%E5%9F%BA%E5%87%86%E5%AE%9E%E7%8E%B0%E8%A6%81%E6%B1%82">基准实现要求</a>中的 ISO C++ 保证，因此不作为基准实现要求。但是，被支持的实现<a href="#%E5%B9%B3%E5%8F%B0">平台</a>一般都满足这些条件，因此直接完整地使用本项目的应用可以直接依赖这些特性。区分基准实现要求和可选实现要求允许对本项目的组件以更细粒度的方式使用。</p>
<h3 id="历史实现要求"><a class="header" href="#历史实现要求">历史实现要求</a></h3>
<p>　　以下要求已被修改或取消。</p>
<ul>
<li>假定提供撤销标准库未定义行为的保证：
<ul>
<li>撤销 <a href="http://eel.is/c++draft/res.on.functions#2.5">[res.on.functions]/2.5</a> 对特定不完整类型作为模板实际参数引起未定义行为的限制，包括：
<ul>
<li>使用默认分配器（ <code>std::allocator</code> 的实例）的 <code>std::vector</code> 的 <code>value_type</code> 类型。
<ul>
<li>这被包含在 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4510.html">WG21 N4510</a> 。</li>
<li><code>ystdex::pmr::pool_resource</code> 的实现从 b843[2018-11-10] 起依赖这项特性。</li>
<li>从 b863[2019-07-26] 起不使用不完整类型的元素而不再依赖这项特性。</li>
</ul>
</li>
<li>使用默认分配器（ <code>std::allocator</code> 的实例）的关联容器（即 <code>std::map</code> 和 <code>std::set</code> ）的 <code>value_type</code> 类型。
<ul>
<li>对 <code>std::vector</code> 、<code>std::list</code> 和 <code>std::forward_list</code> ，<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4510.html">WG21 N4510</a> 引入了不完整类型的支持。这<strong>不在</strong>此处要求。关联容器的要求预期在未来被添加。</li>
<li>已知 libstdc++ 的实现符合这个条件。</li>
<li>在 YSLib 中仅被 <code>YSLib::ValueNode</code> 通过在 <code>std::map</code> 使用递归的键类型的实现从 b338[2012-09-13] 起依赖。</li>
<li>因为使用 <code>ystdex::map</code> 替代 <code>std::map</code> ，从 b830[2017-08-11] 起取消这个要求，不再依赖标准库实现提供的扩展特性。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>假定特定类型的特定操作无异常抛出（但不依赖异常规范的行为），包括：
<ul>
<li><code>std::function::swap</code>（ <a href="https://wg21.cmeerw.net/lwg/issue2062">LWG 2062</a> 起有效）。
<ul>
<li>因为使用 <code>ystdex::function</code> 替代 <code>std::function</code> ，从 b848[2018-12-24] 起取消这个要求。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="可选实现支持"><a class="header" href="#可选实现支持">可选实现支持</a></h3>
<p>　　允许使用 ISO C++11 以后兼容最新标准草案的正式标准中的特性（可通过 <code>__cplusplus</code> 宏和 <a href="https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations">SG10 建议的特性检查</a>判断）。</p>
<h3 id="扩展特性"><a class="header" href="#扩展特性">扩展特性</a></h3>
<p>　　除非另行指定，不依赖实现的方言扩展。</p>
<p><strong>注释</strong> 在确保实现能支持时，在特定的代码中可通过条件包含等方式选用。</p>
<p>　　关于语言特性中的具体使用以及启用的扩展，参见 YSLib 项目文档 <code>doc/LanguageRules.txt</code> 和 <code>doc/YBase.txt</code> 等具体部分的相关开发文档。</p>
<p>　　若实现默认具有不符合标准的特性，在本项目的代码中不依赖这些特性，即便外部依赖项可能对此进行配置（如 MinGW G++ 为了和 Microsoft VC++ 兼容启用的 <code>-mms-bitfields</code> ，而 MSYS2 安装的 freetype2 的 <code>pkg-config</code> 的 CFLAGS 隐含此参数）。</p>
<h2 id="保留名称"><a class="header" href="#保留名称">保留名称</a></h2>
<p>　　YSLib 项目中，除了 YBase.LibDefect 是对标准库实现的修正外，并不是语言的实现，因此公开接口遵循 ISO C++ 对保留名称的使用，如不引入以 <code>__</code> 起始的标识符。</p>
<p>　　对实现环境已经以保留标识符提供的接口，适用以下规则：</p>
<ul>
<li><code>&lt;ydef.h&gt;</code> 提供宏包装特定实现的标识符。</li>
<li>除标准预定义的（如 <code>__cplusplus</code> ）和用于特性检查的标识符（以 <code>__cpp</code> 或 <code>__has</code> 起始），以及上述被包装时的宏定义，不在注解（作为宏 <code>YB_ATTR</code> 和 <code>YB_ATTR_STD</code> 的参数）外直接使用保留标识符。</li>
</ul>
<p>　　<code>&lt;ydef.h&gt;</code> 和其它一些 YSLib 项目头文件保留特定的不被标准保留的标识符，详见 YSLib 项目文档 <code>doc/Definitions.txt</code> 。</p>
<h1 id="库概述"><a class="header" href="#库概述">库概述</a></h1>
<p>　　YSLib 项目由多个子项目组成。其中主要的有顶级子项目：YBase 和 YFramework 。它们是开发 YSLib 应用的必备的库。每个库被构建为单独的映像（静态库或动态库）。</p>
<p>　　YSLib 的组件有些是依赖于特定平台的，但更多是<strong>平台中立</strong>的。关于库的组件在此的不同，详见下文的解释。</p>
<p>　　静态库、动态库或其它可能被库构建时依赖的输入以及构建使用的工具是库构建的<strong>依赖项</strong>。关于依赖项的一般说明，详见<a href="Terminology.zh-CN.html">术语</a>中关于依赖管理的说明。</p>
<h2 id="平台模拟"><a class="header" href="#平台模拟">平台模拟</a></h2>
<p>　　除非另行指定，文档中的狭义的“模拟”概念指程序模拟。</p>
<p>　　YSLib 项目中，<strong>平台模拟(platform emulation)</strong> 主要指直接以运行时环境适配层嵌入宿主平台运行时，在具体程序中提供类似被模拟的目标平台的具体特性和接口。</p>
<p>　　完整的定义详见 YSLib 项目文档 <code>doc/CommonRules.txt</code> 。</p>
<h2 id="模块"><a class="header" href="#模块">模块</a></h2>
<p>　　YSLib 项目组织为一个逻辑上的树形结构，其叶节点称为<strong>模块</strong>。类似文件系统，非叶节点称为<strong>模块目录</strong>。在源代码中使用<strong>模块路径</strong>来标识不同的模块，其分隔符为 <code>::</code> 。在 YSLib 项目下直接划分的<strong>顶级子项目</strong>的名称仅在必要时出现在模块路径中，完整模块路径一般从<strong>次级子项目</strong>的名称起始。</p>
<p>　　C 和 C++ 源代码的一个模块由以下三种形式之一构成：</p>
<ul>
<li>一个头文件</li>
<li>一个非头文件的源文件</li>
<li>一个头文件和对应的源文件</li>
</ul>
<p>　　作为公开接口的模块是公开模块。公开模块的头文件在单独的目录中以便部署。</p>
<p>　　按 ISO C 和 ISO C++ 规定，C 或 C++ 模块中存在的非头文件的源文件和包含的头文件构成一个 C 或 C++（预处理）翻译单元，简称<strong>单元</strong>。注意这里包含的头文件不仅限于模块中的头文件。</p>
<p>　　关于模块的进一步说明以及模块路径的形式文法和头文件依赖的基本规则，参见 YSLib 项目文档 <code>doc/ProjectRules.txt</code> 。</p>
<h2 id="文件系统布局"><a class="header" href="#文件系统布局">文件系统布局</a></h2>
<p>　　作为 C++ 项目，YSLib 把每个顶级子项目的源文件和公开模块头文件分别保存在不同的目录中，即 <code>include</code> 和 <code>source</code> 。非公开模块若有头文件，也位于 <code>source</code> 。</p>
<p>　　特定于目标平台配置的代码会直接位于 <code>平台名</code> 目录下，称为<strong>平台扩展</strong>。对应的两个目录为 <code>平台名/include</code> 和 <code>平台名/source</code> 。</p>
<p>　　除了平台扩展的内容，文件系统目录和模块目录的每一级对应。平台扩展的模块目录名是对应平台中立部分加上后缀 <code>_(平台名)</code> 。</p>
<p>　　举例：顶级子项目 YFramework 下的次级子项目 Helper 的非平台扩展的源代码在目录 <code>YFramework/include/Helper</code> 和 <code>YFramework/source/Helper</code> 中，它的 DS 平台扩展的源代码位于 <code>YFramework/DS/include/Helper</code> 和 <code>YFramework/DS/source/Helper</code> 中。</p>
<p>　　提供平台扩展的次级子项目只有 YCLib 和 Helper 。</p>
<p>　　编译项目时包含的头文件是合并的，如编译器命令行 <code>-IYFramework/DS/include -IYFramework/include</code> 在一次编译中同时使用平台中立和特定于平台 DS 的模块的 YFramework 头文件。</p>
<h2 id="yslib-及其本体"><a class="header" href="#yslib-及其本体">YSLib 及其本体</a></h2>
<p>　　在 YBase 和 YFramework 分离之前，YSLib 是一整个库。原 YSLib 大部分仍然在 YFramework 中，仍然可称为 YSLib ，是一个 YFramework 下的次级子项目。注意和整个项目名的不同，以下称为 <strong>YSLib 库</strong>，以示区分。</p>
<p>　　YSLib 库中，Adaptor 用于适配特定于具体外部依赖的接口。可以通过修改其中的代码替换外部依赖，包括部分标准库兼容接口。</p>
<p>　　其它部分的接口和实现都是严格平台中立且不依赖外部特定接口而变化的，称为<strong>本体</strong>。本体中提供了 YSLib 的主要功能。</p>
<h2 id="helper"><a class="header" href="#helper">Helper</a></h2>
<p>　　若需要开发依赖平台特定的应用，本体接口可能不足，而需要使用平台扩展。此外，可能需要一些便利功能。</p>
<p>　　在 YSLib 库之上，Helper 对此类需求提供了一致而灵活的接口。</p>
<p>　　若需要更接近特定平台实现的接口，可以使用 YCLib 及其平台扩展。</p>
<p>　　YCLib 和 Helper 在宿主实现上都提供了更加丰富的功能。</p>
<h1 id="持久数据"><a class="header" href="#持久数据">持久数据</a></h1>
<p>　　除非另行指定，项目中处理的文件符合本节规则。</p>
<h2 id="文件格式"><a class="header" href="#文件格式">文件格式</a></h2>
<p>　　文件可具有编码的数据。存储库文件的内容作为持久保存的数据，其中的<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">编码</a>可满足外部交互的需要而应约定具体的格式，即<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">外部编码</a>。</p>
<p>　　<a href="Terminology.zh-CN.html#%E7%89%88%E6%9C%AC%E5%BA%93">存储库</a>的文件编码应当使用外部编码。</p>
<p><strong>原理</strong> 存储库的文件具有持久保存的内容。明确格式以确保内容的相对稳定，有助于维护。</p>
<p>　　若<a href="WikiRules.en-US.html">本 wiki 的规则(en-US)</a> 存在指定文件格式的规则，在适用外部编码的上下文中，从其约定。</p>
<p><strong>原理</strong> 应用 wiki 规则以允许本 wiki 作为<a href="Terminology.zh-CN.html#%E7%89%88%E6%9C%AC%E5%BA%93">版本库</a>的一部分被管理。</p>
<h3 id="文本文件"><a class="header" href="#文本文件">文本文件</a></h3>
<p><strong>推论</strong> 按 <a href="WikiRules.en-US.html#textfiles">wiki 规则</a>，文本文件使用带有字节序标记(BOM, byte order mark) 的 UTF-8 编码以及 CR+LF 行尾(EOL, end-of-line) 。</p>
<p><strong>原理</strong> 文本文件格式具有以下几个原因：</p>
<ul>
<li>使用 UTF-8 + BOM 的原因是：
<ul>
<li>作为外部编码具有良好的可用性和可移植性。
<ul>
<li>UTF-8 是当前最被广泛使用的外部文本编码。</li>
<li>尽管<a href="https://github.com/FrankHB/pl-docs/blob/master/zh-CN/criticisms-on-UTF-8-everywhere-manifesto">具有技术缺陷</a>，普遍上仍然缺乏其它替代。</li>
<li>尽管存在<a href="https://github.com/FrankHB/pl-docs/blob/master/zh-CN/about-operating-systems.md#%E9%9D%A2%E5%90%91%E6%96%87%E6%9C%ACtextoriented">历史遗留问题问题导致的误解</a>，因为确定使用的编码，相对不使用 BOM ，处理 BOM 的程序的行为更加确定，而具有更好的可移植性。
<ul>
<li>不带 BOM 的 UTF-8 编码的文本内容可能在不同的运行环境中识别为不同的编码。
<ul>
<li>例如，在 Windows 程序（例如 Visual Studio ）中带有 BOM 的文本文件不会认为使用代码页(codepage) 的非 UTF 编码的文本文件；在 Linux 等环境的用户程序中往往默认不带 BOM 的文本文件以 UTF-8 编码。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>可兼容不同的 UTF 编码作为外部编码（外部编码 UTF 的主要使用场景）；参见 wiki 规则中的原理(rationale) 。</li>
<li>同以上应用 wiki 规则的原理，使文本文件能作为版本库的一部分管理。</li>
</ul>
</li>
<li>使用 CR+LF 的原因是：
<ul>
<li>CR 和 LF 具有不同的含义。强调 CR+LF 允许处理只有 CR 的例外情形（尽管除直接以 CR 作为行尾的情形这通常被视为格式错误）。</li>
<li>CR+LF 被强调作为外部编码。相对地，ISO C 和 ISO C++ 等文件流读写实现的文本模式可能处理这些格式并转换为只有 LF 结尾的内部编码。直接使用 LF 可以被兼容且更简单，但损失了边界区分外部编码和内部编码的边界。</li>
<li>CR+LF 是一些最被广泛使用的外部编码标准（如 <a href="https://www.rfc-editor.org/rfc/rfc9110">HTTP</a> ）中要求的一部分。</li>
</ul>
</li>
</ul>
<p>　　程序的<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源代码</a>作为文本文件，应满足文本文件的要求。</p>
<p><strong>注释</strong> 静态确定的源代码一般都以文本文件的形式存储。</p>
<h1 id="代码规范"><a class="header" href="#代码规范">代码规范</a></h1>
<p>　　YSLib 项目维护的代码规范符合 YSLib 项目中的文档约定的规则，包括：</p>
<ul>
<li><code>doc/CommonRules.txt</code> ：一般规则。</li>
<li><code>doc/ProjectRules.txt</code> ：项目规则。</li>
<li><code>doc/LanguageConvention.txt</code> ：语言使用约定。</li>
</ul>
<p>　　YSLib 中的脚本代码应符合以下相关章节的约定。</p>
<h2 id="代码格式化"><a class="header" href="#代码格式化">代码格式化</a></h2>
<p>　　<code>doc/CommonRules.txt</code> 中规定了命名风格和参考的代码格式。由于格式化代码涉及语义分析，并不保证可以完全自动化进行，需要在编码时注意调整。</p>
<p>　　以下工具配置可以把其中的主要工作自动化进行：</p>
<ul>
<li><code>clang-format</code>
<ul>
<li>可通过 MSYS2 包 <code>mingw-w64-i686-clang</code> 或 <code>mingw-w64-x86_64-clang</code> 安装，以下配置以这里的 3.7 版本为基准测试</li>
<li>配置选项的文档参见<a href="http://clang.llvm.org/docs/ClangFormatStyleOptions.html">这里</a></li>
<li>通过命令行 <code>-style=</code> 指定使用选项文件 <code>Tools/YSLib.clang-format</code></li>
<li><strong>注意</strong> 至少以下格式需要手动调整
<ul>
<li>在 <a href="http://lists.llvm.org/pipermail/cfe-commits/Week-of-Mon-20160808/167367.html">LLVM r278121</a> 添加 <a href="https://reviews.llvm.org/D23317">SpaceAfterTemplateKeyword 支持</a> 前 <a href="http://stackoverflow.com/questions/34423615/cpp-template-spacing-using-clang-format-3-6-not-working-as-expected">只支持 <code>template &lt;</code> 而不支持 <code>template&lt;</code></a></li>
<li>行末的 <code>\</code> 前可能附加多个空格</li>
<li><code>{}</code> 会被拆分</li>
<li>部分宏会被作为块的起始叠加缩进</li>
<li>选项 <code>AlwaysBreakAfterReturnType</code> 未被支持，部分函数和函数模板声明的返回类型后缺少换行</li>
</ul>
</li>
<li>通过命令行 <code>-i</code> 直接编辑文件而不是打印结果到标准输出</li>
<li>命令行示例： <code>find YBase YFramework YSTest -name "*.h" -o -name "*.hpp" -o -name "*. cpp" | xargs clang-format -i -style=file</code></li>
<li>命令行示例： <code>find YBase YFramework YSTest -name "*.h" -o -name "*.hpp" -o -name "*. cpp" | xargs -i sh -c "clang-format -i -style=file {}"</code></li>
<li>命令行示例（同时替换 <code>template &lt;</code> ）： <code>find YBase YFramework YSTest -name "*.h" -o -name "*.hpp" -o -name "*. cpp" | xargs -i sh -c "clang-format -i -style=file {} &amp;&amp; sed -bi 's/template &lt;/template&lt;/g' {}"</code></li>
</ul>
</li>
<li><code>astyle</code>
<ul>
<li>可通过 MSYS2 包 <code>mingw-w64-i686-astyle</code> 或 <code>mingw-w64-x86_64-astyle</code> 安装，以下命令行以这里的 2.05.1 版本为基准测试
*（版本 2.05 ）命令行选项的文档参见<a href="http://astyle.sourceforge.net/astyle.html">这里</a>
<ul>
<li><code>--help</code> 取得的文档可能<a href="https://github.com/Alexpux/MINGW-packages/issues/1011">有问题</a>，<code>--delete-empty-lines</code> 对应的短选项应为 <code>-xe</code> 而不是 <code>-xd</code></li>
</ul>
</li>
<li>使用命令行选项 <code>-A1 -T -p -U -k1 -xj -xy -xC80</code>
<ul>
<li>短选项可以缩写</li>
<li>和上述 <code>clang-format</code> 比较，少了部分功能，主要有
<ul>
<li><code>AlignAfterOpenBracket: DontAlign</code></li>
<li><code>AlignTrailingComments: true</code></li>
<li><code>AlwaysBreakAfterReturnType: All</code></li>
<li><code>MaxEmptyLinesToKeep: 2</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>注意</strong> 至少以下格式需要手动调整
<ul>
<li>无法正确识别 <code>constexpr</code> 导致错误的缩进</li>
<li>虽然<a href="http://sourceforge.net/p/astyle/bugs/265/">右值引用识别问题</a>已解决，但实测对模板参数无效</li>
<li>对 <code>extern "C"</code> 块冗余缩进</li>
<li>断行后的缩进</li>
<li>lambda 表达式的捕获列表中的 <code>=</code> 周围的冗余空格以及对应的 <code>{</code> 断行</li>
<li><code>static_cast</code> 等关键字后的 <code>&lt;&gt;</code> 周围的冗余空格</li>
<li>宏实际参数列表头部的 <code>(</code> 和作为第一个参数的标点可能有冗余空格</li>
<li>宏实际参数列表尾部的 <code>,)</code> 没有以空格隔离</li>
<li>初始化数组的列表 <code>{</code> 和之前的 <code>]</code> 存在冗余空格</li>
</ul>
</li>
<li>不使用 <code>-xp</code> ，尽管一些注释需要（移除行首 <code>*</code> 后保持一级缩进）的此类格式，但它会不必要地影响大部分 Doxygen 注释块</li>
<li>默认备份文件后缀 <code>.orig</code> ；可选使用 <code>-n</code> 取消备份文件，或 <code>--suffix=</code> 修改备份文件后缀</li>
<li>使用 <code>-r</code> 递归处理子目录</li>
<li>可选使用 <code>-v</code> 显示详细过程</li>
<li>可选使用 <code>-Q</code> 只显示被处理的文件</li>
<li>可选使用 <code>--dry-run</code> 不实际处理文件</li>
<li>命令行示例：<code>astyle -vQnrA1TpUk1xjxyxC80 YBase/*.h* YBase/*.cpp YFramework/*.h* YFramework/*.cpp YSTest/*.h* YSTest/*.cpp</code></li>
</ul>
</li>
</ul>
<h2 id="shell-语言使用规范"><a class="header" href="#shell-语言使用规范">Shell 语言使用规范</a></h2>
<p>　　本节提供除测试用途和一次性交互式使用场景外的 <a href="https://pubs.opengroup.org/onlinepubs/9799919799/utilities/V3_chap02.html#tag_19">shell 命令语言</a>及其兼容方言的代码的特性使用和代码风格的规则。</p>
<p><strong>注释</strong> YSLib 提供和使用的<a href="#shell-%E8%84%9A%E6%9C%AC">shell 脚本</a>具有明确的环境要求，其中的代码也<a href="#shell-%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E8%A7%84%E7%BA%A6">被本节涵盖且满足其它一些具体要求</a>。</p>
<h3 id="空白符"><a class="header" href="#空白符">空白符</a></h3>
<p>　　注意 shell 语言和方言的类似赋值的操作符（如 <code>=</code> 、<code>:=</code> 等）和操作数不能有空白符。</p>
<p><strong>原理</strong></p>
<p>　　文法规则中，赋值不能有空白符，否则被视为单独的构成命令的<em>字(word)</em> 而被分析为命令或参数等非预期的记号。具体地，没有空白符的带有赋值的字视为 <strong>ASSIGNMENT_WORD</strong> 在之后进一步被解析。</p>
<p>　　这和历史同期的 B 语言和 C 语言不同，因为 shell 语言被设计为命令语言，而非更通用的编程语言更强调表达式（例如，考虑到赋值作为表达式可以嵌套使用作为另一赋值表达式的右操作数），赋值被直接视为一类表达式而非一类记号。</p>
<h4 id="重定向"><a class="header" href="#重定向">重定向</a></h4>
<p>　　一般地，<a href="https://pubs.opengroup.org/onlinepubs/9799919799/utilities/V3_chap02.html#tag_19_7">shell 重定向</a>语法中：</p>
<ul>
<li><code>&gt;&amp;</code> 和 <code>&lt;&amp;</code> 按 shell 语言文法规则要求被视为一个记号时内部不应有空白符。</li>
<li>重定向操作符和以数值表示文件描述符或非文件名的 <code>-</code> 操作数之间一般不应有空白符，而其它操作数之间保留空格（与常规命令以及命令参数类似）。</li>
<li>省略重定向操作符之前表示文件描述符的操作数 <code>1</code> 。</li>
</ul>
<p>　　重定向在命令中出现的位置未指定，可被适当调整位置以满足源代码排版清晰，如减少出现在字符串参数中的 <code>\</code> 。</p>
<p><strong>注释</strong> 这可能引起 <a href="https://www.shellcheck.net/wiki/SC2210">ShellCheck 警告 SC2210</a> 。这是其中例外情形而可安全忽略。</p>
<p><strong>示例</strong></p>
<ul>
<li>使用 <code>&gt; &amp;2</code> 或 <code>&gt; &amp; 2</code> 复制输出文件描述符 <code>2</code> 是错误的。</li>
<li>一般应使用 <code>2&gt; /dev/null</code> 和 <code>2&gt; 1</code> ，而不是 <code>2&gt;/dev/null</code> 和 <code>2&gt;1</code> 。</li>
<li>一般应使用 <code>&gt;&amp;2</code> 或 <code>&gt;&amp;-</code> 而不是 <code>1&gt;&amp;2</code> 、<code>1 &gt;&amp; 2</code> 或 <code>&gt;&amp; -</code> 。</li>
</ul>
<p><strong>原理</strong></p>
<p>　　作为命令语言，shell 语言传统上更加强调重定向的 I/O 功能先于指定环境的赋值语法。一般的实现中，重定向被分析出记号之前单独处理，重定向操作符和操作数之间的空格是可选的。POSIX 关于重定向的规范也有和命令中的其它部分更多非平凡的规则：</p>
<ul>
<li>在 shell 重定向的<a href="(https://pubs.opengroup.org/onlinepubs/9799919799/utilities/V3_chap02.html#tag_19_7)">一般格式</a> [<em>n</em>]<em>redir_op</em> <em>word</em> 这个表示中，重定向操作符和之后的操作数技术上没有空格，仅为元语言避免 <em>redir_opword</em> 保持。
<ul>
<li>后文 [<em>n</em>]&gt;<em>word</em> 等描述和示例不再有空格也可以证实这一点。</li>
</ul>
</li>
<li>依照 <a href="https://pubs.opengroup.org/onlinepubs/9799919799/utilities/V3_chap02.html#tag_19_10_02">shell 文法规则</a>：
<ul>
<li>重定向操作符之前的操作数是 <code>IO_NUMBER</code> 而非 <code>WORD</code> 。</li>
<li>重定向操作符之后的操作数在是 <code>io_file</code> ，由重定向操作符（如记号 <code>&gt;</code> ）和规约至 <code>filename</code> 的 <code>WORD</code> 组成。</li>
</ul>
</li>
</ul>
<p>　　但是，除了 <code>&gt;&amp;</code> 应被视为整个记号这样的符合文法规则要求的要点外，这里约定的风格不直接由文法规则决定，而指派相对独立的用例场景分类。（事实上，套用文法规约反而会和这里规则相反地得到 <code>IO_NUMBER</code> 和之后的重定向操作符之间有空白符而重定向操作符和之后的字之间可省略空白符的结论。）这是因为：</p>
<ul>
<li>强调重定向的传统惯用的命令风格中，文件描述符或非文件名的 <code>-</code> 操作数和重定向操作符被视为一个整体，而命令中的其它字则不是，如：<code>command &lt; input &gt; output 2&gt;&amp;1</code> 。
<ul>
<li>重定向规则中的 <code>-</code> 在被（不视为文件名）单独支持时，和文件描述符遵循相同的规则。</li>
<li>和重定向的格式描述中的示例不同，在 <a href="https://pubs.opengroup.org/onlinepubs/9799919799/utilities/V3_chap02.html#exec"><code>exec</code> 的示例</a>等描述中，使用了这种方式，同时在格式上也把 <code>-</code> 视为文件描述符。</li>
</ul>
</li>
<li>操作数是否被视为文件描述符的规则和具体重定向操作符相关，特别是预期使用文件名的而实际是文件名的易错情形。强调区分这两种用法风格可能减少这些误用。</li>
</ul>
<h4 id="保留字和命令"><a class="header" href="#保留字和命令">保留字和命令</a></h4>
<p>　　注意命令之间需要有空白符；但 <code>((</code> 虽然是命令，其后的表达式被视为特设语法的一部分而不被视为命令的操作数而可能被特殊处理。具体地：</p>
<ul>
<li>在 <code>[</code> 和参数之间应有空白符，否则语法错误。</li>
<li>在 <code>$((</code> 或 <code>((</code> 和之后的表达式可以有空白符，但一般应省略。
<ul>
<li><strong>原理</strong> 这使 <code>if</code> 和 <code>for</code> 等关键字相对接近 C 语法风格惯例。</li>
</ul>
</li>
<li>在 <code>((</code> 和之前的关键字之间不省略空格。
<ul>
<li><strong>注释</strong> 尽管在 GNU Bash 文档中没有提及，如 <code>if((</code> 和 <code>for((</code> 实际上可被 Bash 解释器识别并拆分出关键字和 <code>((</code> 记号。这不被这里依赖。</li>
<li><strong>原理</strong> 一般避免依赖 POSIX <a href="https://pubs.opengroup.org/onlinepubs/9799919799/utilities/V3_chap02.html#tag_19_04">从命令识别保留字</a>以外的附加处理。</li>
</ul>
</li>
<li><strong>注释</strong> <code>((</code> 在扩展方言中使用。POSIX 在<a href="https://pubs.opengroup.org/onlinepubs/9799919799/utilities/V3_chap02.html#tag_19_09_04_01">组合命令(compound commands)</a> 中提及实现可能提供这种算术求值(arithmetic evaluation) 语法。</li>
</ul>
<p>　　除非另行指定，以下命令的行为未指定：</p>
<ul>
<li>在 POSIX 或使用的 shell 语言实现环境（如特定方言扩展）中未指定的行为。</li>
<li>诊断消息的具体内容。</li>
<li>除 <a href="https://pubs.opengroup.org/onlinepubs/9799919799/utilities/V3_chap02.html#tag_19_09">POSIX 指定的命令行长度限制</a>以及显式引用这个限制的情形，这个命令行长度限制的具体值。
<ul>
<li><strong>示例</strong> 使用 <a href="https://pubs.opengroup.org/onlinepubs/9799919799/utilities/getconf.html"><code>getconf</code> 实用工具</a> 能显式得到这个值（即 <a href="https://pubs.opengroup.org/onlinepubs/9799919799/functions/sysconf.html"><code>ARG_MAX</code></a> 值）。</li>
</ul>
</li>
</ul>
<h3 id="引号"><a class="header" href="#引号">引号</a></h3>
<p>　　使用引用时，优先使用单引号。</p>
<p>　　考察以下情形决定是否使用引号：</p>
<ul>
<li>在字符串字面量使用 shell 参数或其它其它在字面量中起作用的扩展时，应使用双引号。</li>
<li>在字符串字面量使用 shell 通配符或其它不在字面量中起作用的扩展时，应不使用双引号。</li>
<li>对 <code>echo</code> 和类似能支持多个参数合并字符串的命令的字符串字面量一般应始终使用引号以确保作为单一参数处理。</li>
<li>对其它的简单的命令参数，特别是相对固定的参数（如 <code>%s</code> 这样的仅包含不被 shell 扩展的格式字符串），一般应省略引号。</li>
</ul>
<p><strong>原理</strong> 使用引号使字符串字面量的内容和源代码直接对应，可避免一些非预期 shell 导致的难以检查的误用。</p>
<h3 id="变量和环境"><a class="header" href="#变量和环境">变量和环境</a></h3>
<p>　　变量的初始化和默认值满足以下约定：</p>
<ul>
<li>若没有指定变量的初始化调用函数，则使用 shell 内建的方式（如赋值）直接实现。
<ul>
<li><strong>注释</strong> 变量的初始化还可通过调用函数间接实现。</li>
</ul>
</li>
<li>除非另行指定，初始化的变量具有的只读或导出等属性未指定。
<ul>
<li><strong>注释</strong> 之后可能通过声明只读或取消属性。</li>
</ul>
</li>
<li>除非另行指定，变量被修改前要求非只读。
<ul>
<li>若不满足要求，则运行出错。</li>
<li><strong>注释</strong> 另行指定的特定的变量可能通过声明取消只读之后被修改。</li>
<li>取消只读的变量在修改后重新设置只读属性。</li>
</ul>
</li>
<li>初始化变量时若需使用默认值，可能发生附加的求值（如命令调用）以其结果确定具体默认值。</li>
<li>除非变量的初始化被指定为由特定的函数确定，变量在未指定的脚本被执行时无条件初始化，而不需要使用变量的值前调用特定的函数。</li>
<li>除非另行指定：
<ul>
<li>在特定函数中初始化的变量由此函数指定其默认值。</li>
<li>初始化时使用的外部环境变量的值可假定和脚本运行环境直接或间接调用脚本前相同。</li>
</ul>
</li>
</ul>
<p>　　除非另行指定，shell 的变量可能被 shell 脚本执行时修改。</p>
<p><strong>原理</strong> 这允许一般不要求检查变量是否只读，包括提供默认值或直接复用外部可能已初始化的环境变量，以简化实现。</p>
<p>　　注意循环等语法隐式引入的 shell 变量是全局变量。若有可能（当 shell 方言支持的上下文时），显式声明局部变量后再使用变量；在 POSIX shell 中可引入函数使用参数代替。</p>
<p><strong>原理</strong> 使用局部变量代替全局变量以在不需要共享时避免污染全局环境。这要求方言和特定的上下文（如函数体中），不总是容易实现。使用函数是相对容易在 POSIX shell 中实现局部作用于的方法；其它方式（如子 shell ）可具有更大的开销和更多的可能非预期的副作用（如无法共享变量），因此不作要求。</p>
<h3 id="实用程序"><a class="header" href="#实用程序">实用程序</a></h3>
<p>　　实用程序(utility) 提供 shell 语言中可用的命令。</p>
<ul>
<li>功能可满足需要且没有显著的性能问题时，优先使用兼容 POSIX 的实用程序。</li>
<li>除非另行指定，假定实用程序不具有调用时不一致的行为的别名。
<ul>
<li><strong>注释</strong> 不假定不存在对其它命令可见的不同的行为，如特定的 <code>alias</code> 和 <code>command -v</code> 调用可能结果不同。</li>
<li><strong>注释</strong> 约定的未指定行为不视为不一致，如<a href="#%E4%BF%9D%E7%95%99%E5%AD%97%E5%92%8C%E5%91%BD%E4%BB%A4">命令行长度</a>的改变。</li>
<li><strong>示例</strong> 在非交互式 shell 中，<code>alias=ls --color=auto</code> 不影响 <code>ls</code> 命令的行为而满足假定。</li>
</ul>
</li>
<li>使用 <a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/env.html">POSIX <code>env</code> 实用程序</a> 以避免对<a href="#%E5%8F%98%E9%87%8F%E5%92%8C%E7%8E%AF%E5%A2%83">只读变量</a>的赋值。</li>
<li>除非另行指定，不使用 <code>which</code> 。
<ul>
<li><strong>原理</strong> 这个命令不是 POSIX 实用程序，兼容性相对较差，且一般没有 shell 内建支持。
<ul>
<li>另见 <a href="https://www.shellcheck.net/wiki/SC2230">ShellCheck 警告 SC2230</a> 和<a href="https://github.com/koalaman/shellcheck/issues/1162">相关讨论</a>。</li>
</ul>
</li>
<li>在 GNU Bash 中，对检查一个操作数的情形，使用 <code>type -P</code> 代替。
<ul>
<li>在 makefile 中，可<a href="https://www.gnu.org/software/make/manual/html_node/Choosing-the-Shell.html">使用 <code>SHELL</code></a> 或 <code>bash -c</code> 等方式调用 <code>type -P</code> 。</li>
</ul>
</li>
<li>在不依赖 shell 扩展和不同行为时，可使用 <code>command -v</code> 。
<ul>
<li><strong>注意</strong> <code>command -v</code> 对别名等非 <code>$PATH</code> 中可搜索的程序以及多个参数时的处理和 <code>which</code> 的一般实现不同。</li>
</ul>
</li>
<li>在没有满足要求的替代确定可依赖 <code>which</code> 时，可使用 <code>which</code> 。</li>
</ul>
</li>
</ul>
<h2 id="构建选项"><a class="header" href="#构建选项">构建选项</a></h2>
<p>　　一般地，在脚本中默认指定的工具链的警告选项应能支持代码规范。</p>
<h1 id="脚本"><a class="header" href="#脚本">脚本</a></h1>
<p>　　YSLib 版本库中包含若干脚本。这些脚本和 YSLib 安装部署的脚本使用<a href="Run.zh-CN.html#%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%8E%AF%E5%A2%83">命令行程序运行环境</a>和本章中的约定。</p>
<p>　　脚本一般通过调用解释器运行。<em>脚本运行环境(script runtime environment)</em> 是支持脚本运行的命令行程序运行环境。除非另行指定，脚本运行环境是<a href="Terminology.zh-CN.html#%E7%8E%AF%E5%A2%83">宿主环境</a>或非宿主环境内部通过<a href="#%E5%B9%B3%E5%8F%B0%E6%A8%A1%E6%8B%9F">平台模拟</a>提供的类宿主环境。</p>
<p><strong>注释</strong> 符合 YSLib 源码 <code>YF_Hosted</code> 定义支持的平台能提供宿主环境。</p>
<p>　　除非另行指定，脚本以文件的形式部署。</p>
<h2 id="外部环境"><a class="header" href="#外部环境">外部环境</a></h2>
<ul>
<li>除非另行指定，脚本不假定自身的存储位置。
<ul>
<li>一般地，这允许脚本的内容不总是可通过文件系统访问。这包括执行时脚本的来源被移除和不公开以文件的形式部署等情形。</li>
</ul>
</li>
<li>对文件系统中的脚本：
<ul>
<li>脚本文件总是普通文件或可解析到普通文件的有效的符号链接。</li>
<li>除非另行指定，不假定脚本文件所在的位置或其父路径可写。</li>
</ul>
</li>
</ul>
<p>　　项目中提供的脚本在版本库中具有固定的相对路径。除解释环境适用的公共的约定，脚本不预设绝对路径的假定。</p>
<p><strong>示例</strong> 公共约定如使用一般类 UNIX 系统使用的文件系统布局的 <a href="https://zh.wikipedia.org/zh-cn/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86">FHS（文件系统层次结构标准）</a>。另见<a href="Run.zh-CN.html#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80">文件系统布局</a>。</p>
<p><strong>警告</strong> 小心处理路径。当前脚本直接或间接使用的所有涉及文件系统递归操作均不假设检查遍历的目标之间是否重复，若使用不恰当的目录链接，可能造成未预期的行为（如复制指向父目录的目录链接时可引起无限递归）。部署时应提前确保不存在这样的链接。</p>
<p>　　脚本实现假定没有可能冲突的并发文件访问。</p>
<h2 id="脚本文件"><a class="header" href="#脚本文件">脚本文件</a></h2>
<p>　　<strong>脚本文件总是使用以下约定的扩展名。</strong></p>
<p>　　除了 Windows 命令解释器使用的 <code>.cmd</code> 文件以及 <a href="Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0">NPLA1</a> 脚本使用的 <code>.txt</code> 文件，所有脚本使用 <a href="http://zh.wikipedia.org/zh-cn/Shebang">Shebang</a> 明确需要使用的解释环境（详见 <a href="#shell-%E8%84%9A%E6%9C%AC">shell 脚本的说明</a>）。</p>
<p>　　Windows 命令解释器脚本因为实现限制使用本机 ANSI 代码页的编码，约定为兼容 ASCII 。</p>
<p>　　<a href="#npla1-%E8%84%9A%E6%9C%AC">NPLA1 脚本</a>约定使用带有 BOM 的 UTF-8 编码（去除 BOM 的脚本可能兼容 ASCII ）。</p>
<p><strong>注释</strong></p>
<p>　　关于 NPLA1 脚本编码，另见：</p>
<ul>
<li>以上关于<a href="#%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6">文本文件</a>的规则。</li>
<li><a href="Features/NPL.zh-CN.html#%E5%BD%93%E5%89%8D%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">NPL 当前实现</a>的说明。</li>
<li><a href="Tools/SHBuild.zh-CN.html#npl-%E6%94%AF%E6%8C%81">Stage 1 SHBuild 中关于 NPL 支持</a>的说明。</li>
</ul>
<h2 id="接口约定"><a class="header" href="#接口约定">接口约定</a></h2>
<p>　　脚本变量可能被读取和加载。</p>
<p>　　除非另行指定，脚本引入的非导出的变量和名称以 <code>_</code> 结尾的变量，都不是公开接口。</p>
<p><strong>原理</strong> 基于名称约定便于和构成公开接口的名称区分。</p>
<h3 id="路径"><a class="header" href="#路径">路径</a></h3>
<p>　　<em>路径(path)</em> 是由有限的路径<em>组件(component)</em> 构成的序列。在不引起歧义时，路径即指文件系统路径。文件系统的路径组件能以字符串形式表示。</p>
<p>　　特定的路径上的规约操作是<em>路径解析(path resolution)</em> 。</p>
<p>　　路径的字符串表示可具有<em>分隔符(separater)</em> ，以显式区分组件的边界。</p>
<p>　　<em>路径后缀(path suffix)</em> 是路径中最后的一个或多个组件序列构成的序列。路径表示的后缀蕴含分隔这些组件的内部分隔符和之后的分隔符。除非另行指定，一个路径的后缀中的组件序列是最后一个组件（若存在）。</p>
<p>　　<em>路径前缀(path prefix)</em> 是路径或其表示中不包含路径后缀的部分。</p>
<p>　　在支持相对路径的环境中，是否支持相对路径取决于被使用的具体程序（可能是脚本）。</p>
<p>　　除非另行指定，内部的路径的分隔符使用 <code>/</code> 。通过<a href="Tools/Scripts.zh-CN.html">工具脚本</a>提供的 <a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-SHBuild_2w"><code>SHBuild_2w</code></a> 等函数，可转换为带有不同路径分隔符的路径字符串。这种转换通常仅在必要时（如明确作为外部工具的输入）使用。</p>
<p>　　字符串形式的路径（即路径字符串）可能是保证不以分隔符结尾的文件名和确保以分隔符结尾的目录路径字符串。目录路径指目录路径字符串或其对应的非字符串形式的路径。</p>
<p>　　两个路径字符串的拼接可构成新的路径字符串。这两个路径字符串分别是路径前缀和路径后缀。除非另行指定，作为路径前缀使用的路径字符串是文件名。这要求通过串接路径后缀构成访问前缀指定的目录的新的路径时，路径后缀需要以分隔符起始。</p>
<p><strong>注意</strong> YBase 的 <code>ystdex::path</code> 和 YFramework 的 <code>YSLib::IO::Path</code> 等数据结构表示根路径外无视结尾分隔符的非字符串形式的路径，因为有效的分隔符仅在根路径中出现。这些实现一般不检查分隔符的合法性，如其中具有包含分隔符的路径组件，也可能正常转换为字符串形式的合法路径。当前脚本只使用字符串形式的路径。</p>
<p><strong>示例</strong></p>
<p>　　在使用 POSIX.1 定义的宿主环境中：</p>
<ul>
<li>文件系统路径及其字符串表示是 <a href="https://pubs.opengroup.org/onlinepubs/9799919799/basedefs/V1_chap03.html#tag_03_254">POSIX 路径名(pathname)</a> 。</li>
<li>使用的分隔符是非前缀的至少一个连续字符 <code>/</code> 。</li>
<li>对应的路径解析适用 <a href="https://pubs.opengroup.org/onlinepubs/9799919799/basedefs/V1_chap04.html#tag_04_16">POSIX.1 路径名解析(pathname resolution)</a> 的规则，且 YSLib 的具体程序可指定应用其它不依赖 POSIX.1 的转换规则。路径前缀是<a href="https://pubs.opengroup.org/onlinepubs/9799919799/basedefs/V1_chap03.html#tag_03_256">POSIX.1 路径前缀</a> 。</li>
<li><em>文件名(filename)</em> 作为文件系统路径的组件。</li>
</ul>
<p><strong>注释</strong></p>
<p>　　POSIX 路径名 <code>/</code> 是根路径；前缀 <code>//</code> 在路径解析中具有实现定义的行为，但 3 个或以上 <code>/</code> 视为 1 个 <code>/</code> 而不具有类似的实现定义语义。</p>
<p>　　Windows 的 POSIX 实现如 Cygwin 和 MSYS 使用 <code>//</code> 作为 POSIX 路径的 UNC 路径前缀（在 Win32 中为 <code>\\</code> ）。</p>
<h3 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h3>
<p>　　依照<a href="Run.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">运行时环境的约定</a>，除非另行指定，YSLib 程序（包含脚本）不区分未设置的环境变量和已设置但具有空值的环境变量，以允许在外部环境配置脚本的执行。这两种情形下，被用于脚本中的变量的都可能被指定一个非空的初始值，称为变量的<em>默认值(default value)</em> 。</p>
<p>　　程序中参照环境变量管理的具有对应字符串类型的值的具名配置项，也可视为具有默认值的变量。</p>
<p><strong>注释</strong> 被作为环境变量传递的值应能通过<a href="#%E4%BA%92%E6%93%8D%E4%BD%9C">互操作</a>确保和环境变量的值具有对应关系。即便变量仅在脚本或非脚本的程序内部使用，也可用本节的规则，但这部分是可选的。</p>
<p>　　变量是否使用默认值总在先于第一次使用变量的值的初始化时确定。指定按需<em>按需(as needed)</em> 初始化的变量，当且仅当具有非空值时被初始化为默认值。</p>
<p>　　YSLib 程序可按需使用以下能通过外部环境指定值的环境变量及其默认值：</p>
<ul>
<li>用于指定命令：
<ul>
<li><code>SHBuild</code> ：外部 <a href="Tools/SHBuild.zh-CN.html">SHBuild</a> 可执行文件路径。</li>
</ul>
</li>
<li>用于指定存储库中的资源：
<ul>
<li><code>SHBuild_ToolDir</code> ：工具目录中的脚本目录即 <a href="Tools/Scripts.zh-CN.html#Tools"><code>Tools/Scripts</code></a> 。</li>
<li><code>SHBuild_BaseDir</code> : SHBuild 目录，是工具目录中提供 SHBuild 的源代码的目录。
<ul>
<li>默认值按 <code>SHBuild_ToolDir</code> 初始化后的相对位置确定，为 <code>"$SHBuild_ToolDir/../SHBuild"</code>。</li>
</ul>
</li>
<li><code>YSLib_BaseDir</code> ：YSLib 目录，即版本库检出后的工作目录。</li>
</ul>
</li>
<li>用于指定输出目录：
<ul>
<li><code>SHBuild_BuildDir</code> ：构建使用的中间输出文件路径。
<ul>
<li>默认值定义如下：
<ul>
<li>对不依赖 <a href="Sysroot.zh-CN.html">Sysroot</a> 的以及 <code>YSLib/YSTest</code> 目录下的项目构建脚本，默认值指定在完整的版本库中和 <code>"$YSLib_BaseDir/build/$(SHBuild_GetBuildName)"</code> 相同的目录，且构建 <a href="Sysroot.zh-CN.html">stage 1</a> YSLib 时确保为绝对路径。</li>
<li>对 <code>YSLib/YDE</code> 目录下的项目构建脚本，默认值是 <code>".$(SHBuild_GetBuildName)"</code> 。</li>
<li>否则，默认值是当前工作目录 <code>.</code> 。</li>
<li>以上调用的函数 <code>SHBuild_GetBuildName</code> 在<a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-commonsh">脚本 <code>Tools/Scripts/SHBuild-common.sh</code></a> 中，依赖具有非空值的变量 <code>SHBuild_Host_OS</code> 和 <code>SHBuild_Host_Arch</code> 。</li>
</ul>
</li>
</ul>
</li>
<li><code>SHBuild_SysRoot</code> ：Sysroot 根路径。
<ul>
<li>在 <a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">SHBuild 构建环境</a>中，指定 <a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 2 SHBuild</a> 的输出目录；默认值是 <code>"$YSLib_BaseDir/sysroot"</code> 。</li>
<li>在<a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">部署后环境</a>中，指定一个先前的 Sysroot 安装位置；默认值按 <code>SHBuild</code> 初始化后的相对位置确定。
<ul>
<li><strong>注释</strong> 当前仅在经过 SHBuild 构建环境后直接复用，而不单独作为<a href="#%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D">入口位置</a>。</li>
</ul>
</li>
<li>其值被作为路径使用时，结尾的一个或多个 <code>/</code> 被忽略。</li>
<li><strong>原理</strong> 忽略结尾 <code>/</code> 允许 Sysroot 根路径的字符串表示作为<a href="#%E8%B7%AF%E5%BE%84">路径前缀</a>和一个 POSIX 绝对路径的路径前缀（以 <code>/</code> 起始的字符串）拼接时，把后者视为相对 Sysroot 根路径的<a href="#%E8%B7%AF%E5%BE%84">路径后缀</a>而不在结果中引入多余的 <code>/</code> 。否则，支持被拼接的路径前缀视为路径后缀时 Sysroot 根路径无法支持指定 POSIX 根路径 <code>/</code> ，因为这要求变量 <code>SHBuild_SysRoot</code> 的值是空值而和默认值冲突。</li>
</ul>
</li>
</ul>
</li>
<li>用于配置构建环境：
<ul>
<li>其它情形不用于指定输出目录，不保证具有默认值。</li>
<li><code>SHBuild_Env_TempDir</code> ：构建时使用的临时目录路径。
<ul>
<li>由脚本 <code>Tools/Scripts/SHBuild-common.sh</code> 的<a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_preparebuild">函数 <code>SHBuild_PrepareBuild</code></a> 初始化。</li>
<li>默认值由脚本 <code>Tools/Scripts/SHBuild-common.sh</code> 中的<a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_gettempdir">函数 <code>SHBuild_GetTempDir</code></a> 的调用确定。</li>
</ul>
</li>
<li><code>SHBuild_Env_Arch</code> ：构建系统架构。
<ul>
<li>由脚本 <code>Tools/Scripts/SHBuild-common.sh</code> 的<a href="Tools/Scripts.zh-CN.html#%E5%87%BD%E6%95%B0-shbuild_checkuname">函数 <code>SHBuild_CheckUName</code></a> 初始化。</li>
</ul>
</li>
<li><code>SHBuild_Env_OS</code> ：构建系统操作系统。
<ul>
<li>初始化和确定值的方式同 <code>SHBuild_Env_Arch</code> 。</li>
</ul>
</li>
<li><code>SHBuild_Host_Arch</code> ：宿主架构。
<ul>
<li>由脚本 <code>Tools/Scripts/SHBuild-common.sh</code> 的函数 <code>SHBuild_PrepareBuild</code> 初始化。</li>
<li>默认值使用以下方式指定：
<ul>
<li>当 <code>SHBuild_Env_OS</code> 的值是 <code>Win32</code> 且外部变量 <code>MSYSTEM</code> 的值是 <code>MSYSTEM64</code> 时，默认值为 <code>x86_64</code> 。</li>
<li>当 <code>SHBuild_Env_OS</code> 的值是 <code>Win32</code> 且外部变量 <code>MSYSTEM</code> 的值是 <code>MSYSTEM32</code> 时，默认值为 <code>i686</code> 。</li>
<li>其它情形默认值同 <code>SHBuild_Env_Arch</code> 初始化后的值。</li>
</ul>
</li>
</ul>
</li>
<li><code>SHBuild_Host_OS</code> ：宿主操作系统。
<ul>
<li>初始化的方式同 <code>SHBuild_Host_Arch</code> 。</li>
<li>默认值同 <code>SHBuild_Env_OS</code> 初始化后的值。</li>
</ul>
</li>
<li><code>SHBuild_VCS_</code> 起始的变量：指定使用的版本控制系统。
<ul>
<li><code>SHBuild_VCS_hg</code> ：若非空，指定使用 <a href="https://www.mercurial-scm.org/">Mercurial</a> 。</li>
<li><code>SHBuild_VCS_git</code> ：若非空，指定使用 <a href="http://git-scm.com/">Git</a> 。</li>
<li>除非另行指定，若同时指定使用 Mercurial 和 Git 两者，则使用 Mercurial 。</li>
<li>指定使用版本控制系统是提示，不保证是实际的选择。具体使用前，脚本可能自动对可用性（命令行 <code>hg</code> 和 <code>git</code> 及当前工作目录是否位于对应的版本库）进行检查，当不满足要求时可能忽略提示。</li>
<li><strong>原理</strong> 若当前工作目录同时位于多个版本控制系统的版本库，使用提示可以明确选择其中之一。</li>
<li><strong>注释</strong> 本项目的<a href="GettingSources.zh-CN.html">源代码可从 Mercurial 或 Git 中取得</a>。</li>
</ul>
</li>
<li><code>SHBuild</code> 构建使用的变量：详见 SHBuild 的帮助信息。</li>
<li>其它构建脚本使用的变量：详见以下具体脚本的说明。</li>
</ul>
</li>
<li><strong>注释</strong> 上述变量中，可作为<a href="#%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D">入口位置</a>的变量的默认值在此省略，详见<a href="#%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D">文件定位</a>的相关说明。</li>
</ul>
<p><strong>注释</strong> <a href="Tools/Scripts.zh-CN.html#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">脚本中的环境配置约定</a>指定更具体的脚本可访问的变量，其命名满足以上变量名要求。</p>
<p>　　若以上变量在上述任一情形存在作为路径的默认值且外部环境指定变量的值，则指定的值应表示合法的路径。若指定的是可执行文件，则具有可访问和执行的权限。脚本可对这些条件进行检查，若失败则引起错误。</p>
<h2 id="互操作"><a class="header" href="#互操作">互操作</a></h2>
<p>　　脚本源代码中可引用自身或其它程序，被引用的程序是<em>目标程序(target program)</em> 。目标程序可使用脚本实现，即<em>目标脚本(target script)</em> 。被执行的<em>当前脚本(current script)</em> 可能通过文件路径和脚本语言支持的构造使用目标程序。</p>
<p><strong>示例</strong> Shell 脚本中可使用 <code>.</code> 或 <code>source</code> 命令执行参数指定路径的兼容 shell 的目标脚本、调用脚本解释器命令执行参数指定的被解释器支持的目标脚本或直接使用带有适当权限的文件名作为命令执行目标程序。</p>
<h3 id="文件定位"><a class="header" href="#文件定位">文件定位</a></h3>
<p>　　被引用的目标程序或其它文件被运行时相对特定的文件系统中的位置应被确定，即对<em>目标文件(target file)</em> 的<em>定位(locating)</em> 。</p>
<p>　　定位包含一次或多次对输入的指定文件位置的参数进行处理，输出新的路径作为候选，这个过程即<em>解析(resolution)</em> 。<em>入口位置(entry location)</em> 是定位的起始位置，作为第一步路径解析的输入，之后可选的步骤迭代可继续输入不同的相对路径迭代解析，直至取得与其的目标文件的位置。入口位置可以是当前被执行的脚本文件在文件系统中的位置，或通过<a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">特定的环境变量</a>的值指定。其它一些变量也可指定路径解析步骤的输入。</p>
<p><strong>注释</strong> 定位解析的迭代方式和文件系统对<a href="#%E8%B7%AF%E5%BE%84">路径解析</a>的方式类似，但输入和输出不一定是路径。通常最终的输出是能在当前上下文中直接和唯一地确定文件位置的路径。若当前上下文不支持访问工作目录，这个路径一般应为绝对路径。和路径解析不同，位置的抽象解析可以包含执行任意操作而不排除其中可能具有副作用，但通常仍应完全避免依赖这些副作用。</p>
<p>　　同时在多个环境都适用的目标文件，相对当前脚本的位置不保证相同。若表达这些相对位置的相对路径确保作用等价，则视为相对位置唯一确定。</p>
<p><strong>注释</strong> 目标程序通常是 YSLib 提供的脚本或构建后部署的程序。若使用其它程序，可能安装在 <code>$PATH</code> 可引用的路径或其它周知的位置，而不需要使用本节的方式定位；但本节的方式仍可能（有限地）适用。</p>
<p>　　当前设计中，YSLib 提供的脚本可以在 <a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">SHBuild 构建环境</a>和<a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">部署后环境</a>中使用，即可访问和可执行。Sysroot 布局可提供在部署后环境脚本的特定位置的目标文件。YSLib <a href="Terminology.zh-CN.html#%E7%89%88%E6%9C%AC%E5%BA%93">存储库</a>提供部署之前的确定的相对位置的脚本。</p>
<p><strong>注释</strong> 可能有程序在不同环境中的<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">可观察行为</a>不完全相同，如 <a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 1 和 stage 2 SHBuild</a> 依赖不同的库，也不保证未来具有完全相同的特性集。</p>
<p>　　定位解析的典型情形如下：</p>
<ul>
<li>使用已知位置的相对路径定位：位置由表示已知位置的路径和相对当前脚本的相对路径确定。
<ul>
<li>其中，已知位置是当前脚本或一个已被定位的目标文件的位置。</li>
<li><strong>注释</strong> 当脚本同时支持 SHBuild 构建环境和部署后环境，预期使用等效的目标文件，一般应使用文件直接确定而非以下可配置的<a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量</a>。对无法唯一定位的目标文件，则可使用以下其它方式。</li>
</ul>
</li>
<li>使用<a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">变量</a>的值定位：位置由作为路径的变量的值指定，若非空则需要<a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">默认值</a>。</li>
<li>搜索路径定位：使用搜索特定变量值中的元素作为路径前缀的结果。
<ul>
<li>除非另行指定，被搜索变量是内容满足 <a href="https://pubs.opengroup.org/onlinepubs/9799919799/basedefs/V1_chap08.html">POSIX.1 定义</a>的 <code>PATH</code> ，使用 <a href="#%E8%B7%AF%E5%BE%84">POSIX.1 路径名解析</a> 的方式取得结果。</li>
</ul>
</li>
</ul>
<p>　　可用于指定入口的<a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量</a>的默认值和特定脚本被设计适应的部署环境可能相关，确定如下：</p>
<ul>
<li><code>SHBuild</code> ：
<ul>
<li>SHBuild 构建环境中的安装过程中的默认值参见<a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">构建过程</a>。</li>
<li>否则，对部署后环境中的可执行脚本，默认值是 Sysroot 中的脚本直接指定 Sysroot 根目录定位的结果。</li>
<li>否则，默认值是搜索路径定位的结果。</li>
</ul>
</li>
<li><code>SHBuild_ToolDir</code> ：
<ul>
<li>默认值按脚本根据存储库所在目录确定。</li>
<li><strong>注释</strong> 在 SHBuild 构建之后，脚本可能脱离存储库运行，不保证这个目录存在，因此部署后环境下的脚本不依赖 <code>SHBuild_ToolDir</code> 取脚本路径。</li>
</ul>
</li>
<li><code>YSLib_BaseDir</code> ：
<ul>
<li>默认值按变量 <code>SHBuild_ToolDir</code> 初始化后的值指定的位置的相对路径确定，为 <code>"$SHBuild_ToolDir/../.."</code>。</li>
</ul>
</li>
<li><strong>原理</strong> 工具目录及其子目录相对存储库的布局（相对路径）是确定的，可直接使用相对路径定位。</li>
<li><strong>原理</strong> <a href="Sysroot.zh-CN.html#%E5%B8%83%E5%B1%80">Sysroot 布局</a>已能在 <a href="Tools/SHBuild.zh-CN.html#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">stage 1 环境</a>之后假定固定的相对路径的存在性。为简化规则，不使用<a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">变量 <code>SHBuild_SysRoot</code></a> 的值指定入口。</li>
</ul>
<p>　　在以上通用的变量外，特定脚本使用不同的变量指定入口位置，默认值<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">由实现定义</a>（如通过脚本的接口规范指定）或未指定。</p>
<p>　　指定入口位置以外，定位解析的中间结果可被保存在由实现定义或未指定的变量中。</p>
<p><strong>注释</strong> 使用的变量一般被明确指定或至少指定变量名的模式(pattern) ，以便用户避免使用可能引发潜在冲突的无关的变量。</p>
<p>　　YSLib 提供的脚本的实现中，定位目标文件所在目录（以确定脚本所在路径）的一般策略如下：</p>
<ul>
<li>若目标文件在 SHBuild 构建环境和部署后环境中同时可用，且被当前脚本使用具有的可观察行为相同，同时相对当前脚本的位置唯一确定，使用当前脚本作为已知位置，以相对路径定位。
<ul>
<li><strong>原理</strong> 总是使用当前脚本的相对路径定位，因为需要兼容 SHBuild 构建环境，而部署后环境可用的脚本无法依赖<a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">变量 <code>SHBuild_ToolDir</code></a> 的值指定目标文件所在的目录。</li>
</ul>
</li>
<li>否则，若目标文件是部署后环境中被部署的公开可执行程序，使用变量的值指定，其默认值对应指定其位置，是搜索路径定位的结果。
<ul>
<li>若目标文件是可执行程序 <code>SHBuild</code> ，使用<a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">变量 <code>SHBuild</code></a> 。</li>
<li>否则，使用<a href="Terminology.zh-CN.html#%E8%A7%84%E8%8C%83">由实现定义</a>的变量。</li>
<li><strong>注释</strong> 除 <code>SHBuild</code> 外仅可在部署后环境使用；确定默认值的方式和部署后环境的 <code>SHBuild</code> 相同。</li>
</ul>
</li>
<li>否则，若目标文件是 Sysroot 根路径指定的目录，使用 <code>SHBuild</code> 的位置的相对路径定位。</li>
<li>否则，若目标文件在 Sysroot 根路径指定的目录或子目录中，按 Sysroot 根目录的位置的相对路径定位目标文件。
<ul>
<li><strong>注释</strong> 另见 <a href="#npla1-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">NPLA1 环境变量</a>。</li>
</ul>
</li>
<li>否则，若目标文件是工具目录中的脚本目录，使用<a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">变量 <code>SHBuild_ToolDir</code></a> 的值作为定位的结果。</li>
<li>否则，若目标文件在工具目录中的脚本目录中，按工具目录的位置的相对路径定位目标文件。</li>
<li>否则，若目标文件是存储库根目录，使用<a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">变量 <code>YSLib_BaseDir</code></a> 的值作为定位的结果。</li>
<li>否则，若目标文件在存储库根目录或子目录中，按存储库根目录的位置的相对路径定位目标文件。
<ul>
<li><strong>注释</strong> 典型地，YSLib 存储库的工具目录外的源代码属于这种情形。</li>
</ul>
</li>
<li>否则，对每个目标文件，当前脚本可通过由实现定义的方式确定其位置的方式。
<ul>
<li><strong>注释</strong> 这是可选的。可能不通过公开文档指定，如使用注释。</li>
</ul>
</li>
<li>否则，目标文件的位置未指定。
<ul>
<li><strong>注释</strong> 一般仅在实现内部使用未指定唯一位置的文件，以避免影响约定的脚本程序的可观察行为。</li>
</ul>
</li>
<li><strong>注释</strong> 一般分别使用以上策略对不同目标文件定位。
<ul>
<li><strong>原理</strong> 即便脚本还依赖以下其它规则定位仅在部署后环境可用的目标文件，也不影响单独定位，以在支持尽可能多的配置组合同时减少规则的复杂性。</li>
<li><strong>示例</strong> 在 SHBuild 构建环境和部署后环境可用的公共脚本，不使用 <code>SHBuild</code> 以外的变量的值指定位置。</li>
</ul>
</li>
<li><strong>注释</strong> 通过变量定位时，原则上优先使用相对路径较简单的较近父目录的位置。
<ul>
<li><strong>原理</strong> 单独指定更上级目录的变量因此无效。这避免要求实现检查所有可能涉及的变量。</li>
</ul>
</li>
<li><strong>注释</strong> 一些目标文件的定位可作为其它文件的已完成的解析步骤。
<ul>
<li><strong>示例</strong> 通过定位确定工具目录位置后，可定位其中的其它文件。</li>
<li>这些定位不一定通过<a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">周知的变量</a>访问，可能由实现定义或未指定。</li>
</ul>
</li>
</ul>
<p>　　定位所在的目录后，其中的脚本可基于所在目录的路径表达式构造路径指定位置。定位可在脚本中的不同位置中出现，应当满足依赖项的使用需求。</p>
<p><strong>原理</strong> 当存在多个<a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">配置入口的不同环境变量</a>时，以上定位的规则能无歧义地指定其中<a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">默认值</a>的生效方式。特别地，Sysroot 的布局蕴含 <code>SHBuild</code> 、Sysroot 根目录和目标文件的位置之间的相对路径是确定的，能保证唯一确定路径。</p>
<p><strong>警告</strong> 假定脚本定位的目标程序是支持的版本且不依赖其具体位置，否则调用目标程序的脚本行为未指定。特别地，混用不同版本的存储库或 Sysroot 对应的文件不被支持。</p>
<h2 id="shell-脚本"><a class="header" href="#shell-脚本">Shell 脚本</a></h2>
<p>　　扩展名 <code>.sh</code> 的脚本文件是 shell 脚本文件。大多数脚本需要使用 <a href="https://www.gnu.org/software/bash/">GNU Bash</a> 运行，如：</p>
<pre><code class="language-shell">#!/usr/bin/bash
</code></pre>
<p>　　需要考虑兼容性时，一般使用以下替代：</p>
<pre><code class="language-bash">#!/usr/bin/env bash
</code></pre>
<p>　　其它可以直接兼容 POSIX shell 的 <code>.sh</code> 脚本使用 Shebang 如：</p>
<pre><code class="language-shell">#!/usr/bin/sh
</code></pre>
<p>　　需要考虑兼容性时，一般使用以下替代：</p>
<pre><code class="language-shell">#!/usr/bin/env sh
</code></pre>
<p>　　若脚本可以确保兼容 POSIX shell ，使用 <code>sh</code> 而不是 <code>bash</code> 。</p>
<p>　　为简化脚本代码，用户需要保证调用 shell 脚本时，环境应满足以下条件，否则行为未指定：</p>
<ul>
<li>使用满足要求的 shell 语言实现：
<ul>
<li>对 Bash 脚本：
<ul>
<li>满足版本要求：<strong>当前最低版本为 <a href="https://www.gnu.org/software/bash/manual/">GNU Bash</a> 4.4 。</strong>
<ul>
<li><strong>注释</strong> 要求 4.0 保证能使用 <a href="https://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html#index-mapfile"><code>mapfile</code></a> 等 <a href="https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html">Bash 内建命令</a>。</li>
<li><strong>注释</strong> 要求 4.4 保证能使用 <code>${@@Q}</code> 等<a href="https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html">参数替换</a>。</li>
</ul>
</li>
<li>不使用 POSIX 兼容模式。</li>
</ul>
</li>
<li>对其它 POSIX shell 脚本：
<ul>
<li>使用符合 POSIX 的 shell ，或使用以上要求相同的 <code>bash</code> 运行 shell 脚本。</li>
</ul>
</li>
<li>可支持使用特定的公共非 POSIX 扩展：
<ul>
<li>使用 <a href="https://unix.stackexchange.com/questions/614808"><code>mktemp</code></a> 命令创建临时文件名。</li>
<li><strong>注释</strong> 这些扩展在应在受支持的<a href="Terminology.zh-CN.html#%E5%B9%B3%E5%8F%B0">平台环境</a>中可用。</li>
</ul>
</li>
<li><strong>注释</strong> 除非另行指定，不要求对 shell 环境进行检查。</li>
</ul>
</li>
<li>不论是否设置了变量 <code>POSIXLY_CORRECT</code> ，命令解释环境的变量满足：
<ul>
<li><a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_14">特殊内建工具</a>没有被用户定义的同名变量或别名覆盖。</li>
<li>被脚本调用的 POSIX 定义的工具命令没有被用户定义的同名变量或别名覆盖为调用时<a href="Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">可观察行为</a>不等价的实体。</li>
<li>变量 <code>IFS</code> 未设置或设置为默认值。</li>
</ul>
</li>
<li>命令解释器同 <code>bash</code> 的 <code>-p</code> 选项启用时效果相同。
<ul>
<li>用户应保证不设置 <code>CDPATH</code> 等 <code>-p</code> 忽略的<a href="Run.zh-CN.html">环境变量</a>及 <code>$BASH_ENV</code> 等启动文件，以避免未预期的不同行为。</li>
</ul>
</li>
<li>脚本文件不是目标在不同目录中的符号链接。
<ul>
<li>对 Bash 脚本，允许使用变量 <code>BASH_SOURCE</code> 的值（如 <code>${BASH_SOURCE[0]}</code> 或 <code>${BASH_SOURCE%/*}</code> 等形式） 较可靠地判断脚本文件的路径。此时，隐含需要附加假定通过脚本文件路径确定其它资源的位置。</li>
<li>部分脚本可能有更进一步的使用限制或不依赖 <code>.</code> 命令及命令解释器调用的差异。此时，可直接使用 <code>"$0"</code> 判断路径。</li>
</ul>
</li>
<li>除非另行指定，调用的外部命令的程序满足以下可用性要求：
<ul>
<li>以 POSIX 实用程序名称直接调用的满足 POSIX 对应的要求。</li>
<li>当前使用的 shell 的名称（如 <code>bash</code> ）总是能被 <a href="#%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F">POSIX <code>env</code> 实用程序</a>搜索到并调用。</li>
<li><code>/usr/bin/env</code> 总是提供可用的 POSIX <code>env</code> 实用程序。
<ul>
<li><strong>注释</strong> 这允许上述 Shebang 可用。同时，<code>/usr/bin/env</code> 作为命令名称一般等同于 <code>env</code> 。</li>
</ul>
</li>
<li><strong>注释</strong> <a href="#%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F">避免使用 <code>which</code></a>。</li>
</ul>
</li>
</ul>
<p>　　脚本实现中的调用不受以上限制。</p>
<p>　　若对应解释器位于其它目录，可通过符号链接以满足以上要求。</p>
<p><strong>注释</strong> 一般不检查解释器的路径是否指定一个符号链接。</p>
<p>　　除非另行指定，本文档约定使用的路径字符串的分隔符为 <code>/</code> ，不连续出现在路径中，且不在结尾出现。例外：</p>
<ul>
<li>平台相关的绝对路径转义可出现 <code>//</code> 。</li>
<li>构成路径的路径前缀可能以分隔符结尾，直接表示上层目录。</li>
</ul>
<p><strong>注意</strong> 当前版本库中的文件不保证跟踪权限。在一些环境中可能因为可执行权限问题导致无法立即执行脚本，参见<a href="GettingSources.zh-CN.html">这里的说明</a> 。</p>
<p>　　脚本可能执行 <code>set -e</code> 以及早发现错误，包括但不限于<a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">变量的默认值</a>初始化失败。</p>
<p>　　<a href="Releases.zh-CN.html">正式支持的发布版本</a>中的公开 Shell 脚本应保证用 <a href="https://www.shellcheck.net/">ShellCheck</a> 0.7 或以上版本（任选）检查没有诊断消息。检查的命令行为 <code>shellcheck -x -P SCRIPTDIR</code> 跟随文件名。除非另行指定，使用明确的方式避免引起检查的问题而不是使用指令消除检查的结果，如使用 <code>${BASH_SOURCE[0]}</code> 代替 <code>$BASH_SOURCE</code> 以避免 <a href="https://www.shellcheck.net/wiki/SC2128">ShellCheck 警告 SC2128</a> 。</p>
<h3 id="shell-语言使用规约"><a class="header" href="#shell-语言使用规约">Shell 语言使用规约</a></h3>
<p>　　对 shell 命令语言和兼容方言的使用符合 <a href="#shell-%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83">shell 语言使用规范</a> 。</p>
<p>　　脚本程序不调整影响别名扩展的 shell 选项（如 Bash 的 <code>shopt -u expand_aliases</code> ）。</p>
<p>　　非生成的脚本源代码中不使用包含 <code>__</code> 的名称。</p>
<p>　　公开函数的函数名及公开的变量名<a href="#%E6%8E%A5%E5%8F%A3%E7%BA%A6%E5%AE%9A">不以 <code>_</code> 结尾</a>，否则以一个 <code>_</code> 结尾。</p>
<p>　　对 <a href="Tools/SHBuild.zh-CN.html">SHBuild</a> 相关工具使用的函数，使用前缀 <code>SHBuild</code> 。</p>
<p>　　函数出错且无法恢复时退出脚本。</p>
<p>　　版本库中的提供的脚本一般应能通过 ShellCheck 检查。对需要使用 <a href="https://github.com/koalaman/shellcheck/wiki/Directive">ShellCheck 指令</a>指定脚本起始构造的检查时，在之前添加一行空命令（对 Bash 脚本使用 <code>:</code> ，非 Bash 脚本命令使用 <code>true</code> ）以避免非预期地使指令作用于整个脚本。</p>
<h3 id="shell-变量"><a class="header" href="#shell-变量">Shell 变量</a></h3>
<p>　　除非另行指定，shell 脚本对变量的使用符合 <a href="#%E5%8F%98%E9%87%8F%E5%92%8C%E7%8E%AF%E5%A2%83">shell 代码对变量的规则</a>。</p>
<p>　　Shell 脚本可使用<a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量</a>指定外部配置变量的值，即<em>外部变量(external variable)</em> 。</p>
<p><strong>示例</strong> Bash 命令 <code>_="${SHBuild:="$(type -P SHBuild)"}"</code> 初始化变量 <code>SHBuild</code> 的值<a href="#%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D%E7%9A%84%E5%AE%9E%E7%8E%B0">实现搜索 <code>$PATH</code> 的路径定位</a> <code>SHBuild</code> 命令。</p>
<p>　　Shell 的<em>内部变量(internal variable)</em> 在脚本之间使用，通过 <a href="#%E4%BA%92%E6%93%8D%E4%BD%9C"><code>.</code> 或 <code>source</code> 命令共享</a>。</p>
<p><strong>注释</strong> 外部变量和内部变量类似 C 语言标识符的链接。类似地，局部变量不是外部变量或内部变量。</p>
<p>　　以下内部变量具有公共的含义：</p>
<ul>
<li><code>INC_SHBuild_</code> ：用于指定标记已被检查<a href="#%E4%BA%92%E6%93%8D%E4%BD%9C">用 <code>.</code> 或 <code>source</code> 命令包含</a>的前缀。
<ul>
<li><strong>注释</strong> 类似 C 和 C++ 源程序中的守卫宏(macro name) 的名称。多次调用可能效果不同的脚本一般不使用。</li>
<li>这些变量不被设置为只读以支持显式地取消定义而重复包含脚本。</li>
</ul>
</li>
</ul>
<p>　　除非另行指定，外部变量总是允许指定通过环境变量值，内部变量总是能通过互操作共享值，但这些变量不一定被视为公开接口。</p>
<p>　　除指定入口的环境变量，是否支持外部可覆盖默认值的上述环境变量是可选的，取决于各个脚本的具体支持。</p>
<p>　　典型地，Shell 指定的环境变量可被以下方式在被 shell 运行的命令中使用：</p>
<ul>
<li>标记导出变量，在调用的命令访问变量：
<ul>
<li><a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_22"><code>export</code></a> 命令。</li>
<li><a href="https://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html#index-declare"><code>declare -x</code></a> 命令。</li>
<li>使用 <a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html"><code>set -a</code></a> 命令后的变量声明。</li>
</ul>
</li>
<li>启用子 shell(subshell) 或调用 shell 解释器等方式运行 shell 脚本或以下命令等方式使用当前环境或继承环境：
<ul>
<li><a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_18_01"><code>.</code></a> 命令。</li>
<li><a href="https://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html#index-source"><code>source</code></a> 命令。</li>
<li><a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#eval"><code>eval</code></a> 命令。</li>
</ul>
</li>
<li>临时指定特定的环境并调用命令：
<ul>
<li>使用 <a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/env.html"><code>env</code></a> 命令。</li>
<li>调用命令时以兼容 Bourne shell 的<a href="https://www.gnu.org/software/bash/manual/html_node/Environment.html">使用前缀参数赋值的命令调用</a>临时指定特定的环境。</li>
<li>使用 <a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html"><code>set -k</code></a> 命令后的参数赋值。</li>
</ul>
</li>
<li><strong>注释</strong> 另见 <a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_12">POSIX 命令执行环境</a> 和 <a href="https://www.gnu.org/software/bash/manual/html_node/Command-Execution-Environment.html">GNU Bash 命令执行环境</a>。</li>
</ul>
<p>　　关于这些环境变量如何影响其它程序，参见<a href="Run.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">运行时的环境变量</a>。</p>
<h3 id="shell-函数"><a class="header" href="#shell-函数">Shell 函数</a></h3>
<p>　　除非另行指定，shell 函数满足以下约定：</p>
<ul>
<li>已定义的 shell 函数假定不被其它变量覆盖。
<ul>
<li><strong>原理</strong> 这允许实现省略 <code>readonly -f</code> 或 <code>declare -g -r -f</code> 声明，且允许使用相同的定义覆盖以简化调试。</li>
</ul>
</li>
<li>Shell 函数返回值是通过接口语义中蕴含的最后的命令调用的返回值；或当不存在这样的命令时，默认为 <code>0</code> 。</li>
<li>Shell 函数的结果是标准输出的内容。
<ul>
<li><strong>注释</strong> 通常使用 <code>echo</code> 或功能蕴含 <code>echo</code> 的命令调用输出返回的值。</li>
</ul>
</li>
</ul>
<h3 id="文件定位的实现"><a class="header" href="#文件定位的实现">文件定位的实现</a></h3>
<p>　　定位<a href="#%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D">入口位置</a>的实现一般如下：</p>
<ul>
<li>使用当前脚本的相对路径定位：
<ul>
<li><strong>示例</strong> Bash 脚本可使用 <code>${BASH_SOURCE[0]}</code> 引用自身，使用 <code>$(dirname ${BASH_SOURCE[0]})</code> 表达被定位的目录，如：<code>. "$(dirname "${BASH_SOURCE[0]}")/SHBuild-common.sh"</code> 执行当前脚本目录下的 <a href="Tools/Scripts.zh-CN.html#toolsscriptsshbuild-commonsh"><code>SHBuild-common.sh</code></a> 。</li>
<li><strong>示例</strong> Shell 脚本可使用 <code>"$0"</code> 指定自身位置，使用 <code>cd</code> 、<code>dirname</code> 和 <code>pwd</code> 解析构造的相对路径的结果。</li>
</ul>
</li>
<li>搜索路径定位：
<ul>
<li><strong>示例</strong> Bash 脚本可使用 <code>$(type -P program)</code> 指定 <code>program</code> 的位置。</li>
</ul>
</li>
</ul>
<h2 id="npla1-脚本"><a class="header" href="#npla1-脚本">NPLA1 脚本</a></h2>
<p>　　NPLA1 脚本可被 SHBuild 调用。SHBuild 支持特定的选项作为 NPLA1 的脚本解释器。脚本解释器支持 NPLA1 脚本文件。此外，在 shell 脚本中，NPLA1 脚本代码可能以字符串的形式存储和被 SHBuild 调用。</p>
<h3 id="npla1-环境变量"><a class="header" href="#npla1-环境变量">NPLA1 环境变量</a></h3>
<p>　　NPLA1 脚本可使用和 shell 脚本通用的环境变量，如 <code>SHBuild</code> 。</p>
<p>　　除 stage 1 外，shell 脚本使用环境变量 <code>NPLA1_ROOT</code> 指定的根目录路径表示 SHBuild 加载 NPLA1 脚本使用的<a href="#%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D">入口位置</a>。</p>
<p>　　脚本（包括直接或间接调用 NPLA1 脚本的其它脚本）除默认值外不需要依赖 Sysroot 的安装路径下的目录和文件布局，环境变量 <code>SHBuild</code> 和 <code>NPLA1_ROOT</code> 可分别指定相互无依赖的路径。当仅指定 <code>SHBuild</code> 时，通过指定的 SHBuild 路径推断 <code>NPLA1_ROOT</code> 默认值，此时使用假定符合 Sysroot 约定的相对路径。</p>
<p>　　NPLA1 脚本可使用以上约定含义和默认值的 shell 环境变量并初始化 NPLA1 脚本内的同名变量，但部分变量的作用域和初始化方式可能不同：</p>
<ul>
<li>在 Tools/Scripts/SHBuild-YSLib-common.txt 中直接初始化变量 <code>SHBuild_Env_Arch</code> 和 <code>SHBuild_Env_OS</code> 。</li>
<li>在 Tools/Scripts/SHBuild-YSLib-common.txt 的函数 <code>SHBuild_GetPlatformStrings</code>（详见版本库中的 <code>doc/NPL.txt</code>）的调用中初始化变量 <code>SHBuild_Host_Arch</code> 和 <code>SHBuild_Host_OS</code> 。</li>
</ul>
<p>　　注意在 NPLA1 脚本中创建的变量不是环境变量；但和 shell 脚本类似，若需作为其它外部命令的环境变量，可先导出再调用对应的程序。</p>
<h3 id="npla1-函数"><a class="header" href="#npla1-函数">NPLA1 函数</a></h3>
<p>　　NPLA1 脚本可提供部分 shell 脚本中的同名函数。除非另行指定，这些函数的调用接口以及功能和 shell 脚本中的同名函数一致，但实现和以下行为不保证相同：</p>
<ul>
<li>出错时的诊断方式。</li>
<li>缓存的变量及相关的输出提示信息。</li>
<li>性能。</li>
<li>影响的非公开环境变量等其它外部环境状态。</li>
</ul>
<p>　　作为公开接口的 NPLA1 函数另见 <code>doc/NPL.txt</code> 中的描述。</p>
<h2 id="构建脚本"><a class="header" href="#构建脚本">构建脚本</a></h2>
<p>　　一些开发脚本被用于构建。构建脚本的一般形式提供配置和生成阶段的自动化功能。</p>
<p>　　配置阶段设置交互环境。典型地，通过执行命令前设置的环境变量指定可配置项。</p>
<p>　　生成阶段调用合适的工具完成构建。</p>
<p>　　配置阶段的接口可能对外隐藏，此时使用默认配置进行构建。</p>
<p>　　一些公用的构建脚本可适用于整个项目。其它的构建脚本可构建具体子项目中的目标。</p>
<p>　　构建脚本可以是 makefile 或其它可执行的脚本。其中，makefile 可能使用以上约定含义的 shell 环境变量，但不保证可被外部指定覆盖脚本中指定的默认值。</p>
<h1 id="参考"><a class="header" href="#参考">参考</a></h1>
<ul>
<li>YSLib 项目文档 <code>doc/Dependencies.txt</code> 了解组织结构、开发规则、默认使用的外部依赖项（包括语言实现）和相关约定。</li>
<li><a href="Features.zh-CN.html">结构和特性</a> 中的树形结构了解项目依赖性。</li>
<li>YSLib 项目文档 <code>doc/ProjectRules.txt</code> 了解组织结构、开发规则和相关约定。</li>
<li>YSLib 项目文档 <code>doc/YBase.txt</code> 了解顶级子项目 YBase 。</li>
<li>YSLib 项目文档 <code>doc/YFramework.txt</code> 了解顶级子项目 YFramework 。</li>
<li>YSLib 项目文档 <code>doc/YSLib.txt</code> 了解 YFramework 的次级子项目 YSLib 。</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="GettingStarted.zh-CN.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="Prerequisitions.zh-CN.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="GettingStarted.zh-CN.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="Prerequisitions.zh-CN.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
