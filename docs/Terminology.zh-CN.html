<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>术语概要 - The YSLib Book</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Book tranplanted from YSLib BitBucket wiki.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Home.html"><strong aria-hidden="true">1.</strong> 索引/Index</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Home.en-US.html"><strong aria-hidden="true">1.1.</strong> English Version</a></li><li class="chapter-item expanded "><a href="Home.zh-CN.html"><strong aria-hidden="true">1.2.</strong> 简体中文版</a></li><li class="chapter-item expanded "><a href="Contents.zh-CN.html"><strong aria-hidden="true">1.3.</strong> Contents(zh-CN)/主题目录</a></li></ol></li><li class="chapter-item expanded "><a href="GettingStarted.zh-CN.html"><strong aria-hidden="true">2.</strong> 入门</a></li><li class="chapter-item expanded "><a href="Development.zh-CN.html"><strong aria-hidden="true">3.</strong> 开发说明</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Prerequisitions.zh-CN.html"><strong aria-hidden="true">3.1.</strong> 先决条件</a></li><li class="chapter-item expanded "><a href="GettingSources.zh-CN.html"><strong aria-hidden="true">3.2.</strong> 获取源代码</a></li><li class="chapter-item expanded "><a href="Build.zh-CN.html"><strong aria-hidden="true">3.3.</strong> 构建</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="BuildDocumentation.zh-CN.html"><strong aria-hidden="true">3.3.1.</strong> 构建文档</a></li></ol></li><li class="chapter-item expanded "><a href="Test.zh-CN.html"><strong aria-hidden="true">3.4.</strong> 测试</a></li><li class="chapter-item expanded "><a href="Run.zh-CN.html"><strong aria-hidden="true">3.5.</strong> 运行</a></li></ol></li><li class="chapter-item expanded "><a href="Features.zh-CN.html"><strong aria-hidden="true">4.</strong> 结构和特性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ProjectDependencies.zh-CN.html"><strong aria-hidden="true">4.1.</strong> （内部）项目依赖性说明</a></li><li class="chapter-item expanded "><a href="Features/NPL.zh-CN.html"><strong aria-hidden="true">4.2.</strong> NPL</a></li></ol></li><li class="chapter-item expanded "><a href="EMPTY.html"><strong aria-hidden="true">5.</strong> 应用开发环境</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Sysroot.zh-CN.html"><strong aria-hidden="true">5.1.</strong> Sysroot</a></li><li class="chapter-item expanded "><a href="YDE.zh-CN.html"><strong aria-hidden="true">5.2.</strong> YDE</a></li></ol></li><li class="chapter-item expanded "><a href="EMPTY.html"><strong aria-hidden="true">6.</strong> 项目维护资源</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Releases.zh-CN.html"><strong aria-hidden="true">6.1.</strong> 发布工程</a></li><li class="chapter-item expanded "><a href="Archives.zh-CN.html"><strong aria-hidden="true">6.2.</strong> 归档</a></li></ol></li><li class="chapter-item expanded "><a href="EMPTY.html"><strong aria-hidden="true">7.</strong> 工具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Tools/SHBuild.zh-CN.html"><strong aria-hidden="true">7.1.</strong> SHBuild</a></li><li class="chapter-item expanded "><a href="Tools/RevisionPatcher.zh-CN.html"><strong aria-hidden="true">7.2.</strong> RevisionPatcher</a></li><li class="chapter-item expanded "><a href="Tools/SXML2XML.zh-CN.html"><strong aria-hidden="true">7.3.</strong> SXML2XML</a></li><li class="chapter-item expanded "><a href="Tools/ProjectGenerator.zh-CN.html"><strong aria-hidden="true">7.4.</strong> ProjectGenerator</a></li><li class="chapter-item expanded "><a href="Tools/Scripts.zh-CN.html"><strong aria-hidden="true">7.5.</strong> 脚本</a></li></ol></li><li class="chapter-item expanded "><a href="Tutorial.zh-CN.html"><strong aria-hidden="true">8.</strong> 教程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Tutorial/Overview.zh-CN.html"><strong aria-hidden="true">8.1.</strong> 综述</a></li><li class="chapter-item expanded "><a href="Tutorial/GUI.zh-CN.html"><strong aria-hidden="true">8.2.</strong> GUI</a></li><li class="chapter-item expanded "><a href="Tutorial/Configuration.zh-CN.html"><strong aria-hidden="true">8.3.</strong> 程序配置</a></li></ol></li><li class="chapter-item expanded "><a href="EMPTY.html"><strong aria-hidden="true">9.</strong> 附录/Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Terminology.zh-CN.html" class="active"><strong aria-hidden="true">9.1.</strong> 术语概要</a></li><li class="chapter-item expanded "><a href="StandardUsing.en-US.html"><strong aria-hidden="true">9.2.</strong> Standard Using</a></li><li class="chapter-item expanded "><a href="ReportedIssues.en-US.html"><strong aria-hidden="true">9.3.</strong> Reported Issues</a></li><li class="chapter-item expanded "><a href="WikiRules.en-US.html"><strong aria-hidden="true">9.4.</strong> Wiki Rules</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The YSLib Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="术语概要"><a class="header" href="#术语概要">术语概要</a></h1>
<p>　　本文档概述及约定 YSLib 基本的概念含义，主要用于<a href="Development.zh-CN.html">开发</a>。</p>
<p>　　一些术语概念适用各种不同的上下文，主要用于开发过程中的设计和规则说明。</p>
<p>　　术语以列表形式的条目列出。通过使用元语言语法 <em>&lt;相关范畴/上下文&gt;</em> 标记指示被修饰或被限定的概念的适用范围。不需要消歧义时，省略标记。</p>
<h1 id="通用领域"><a class="header" href="#通用领域">通用领域</a></h1>
<p>　　除非另行指定，适用于任意<a href="#%E8%87%AA%E6%8C%87">上下文</a>；但存在更具体的上下文的特定概念定义时，优先适用后者。</p>
<h2 id="经验语义"><a class="header" href="#经验语义">经验语义</a></h2>
<p>　　经验语义解释的术语的含义总是假定可被实证，不需要进一步解释。</p>
<p>　　元语言中的标记使用经验语义。标记可被本文档中已归类的章节提供。</p>
<p>　　本文档中非形式地使用在特定理论中严格定义的、和<a href="#%E9%80%9A%E7%94%A8%E7%BA%A6%E5%AE%9A">本章</a>的条目具有逻辑上相容的含义的概念时，不进一步解释。</p>
<h2 id="自指"><a class="header" href="#自指">自指</a></h2>
<p>　　<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E6%8C%87"><strong>自指</strong></a>是概念定义形式上的自我指涉。</p>
<p><strong>举例</strong> “<a href="#%E9%80%9A%E7%94%A8%E9%A2%86%E5%9F%9F">本章</a>”是关于位置的自指。</p>
<p>　　有必要通过自指定义的概念，隐含引入定义内容的过程的<a href="https://zh.wikipedia.org/zh-cn/%E5%BE%AA%E7%92%B0%E8%AB%96%E8%AD%89">循环论证</a>。这些概念的精确内涵和外延依赖<a href="#%E7%BB%8F%E9%AA%8C%E8%AF%AD%E4%B9%89">经验语义</a>的实证，否则在自然语言语言中可能需要循环论证而失去定义的意义。此处的条目内容（包括链接的外部定义）仅仅供参考，而不是精确的内涵和外延。为简化复杂度，限制自指定义的概念都是名词。</p>
<p><strong>举例</strong> 上述注释中，<strong>内涵</strong>和<strong>外延</strong>约定为以下<a href="#%E9%9D%9E%E8%87%AA%E6%8C%87">非自指</a>的概念，因此可依据本文档给出明确的定义来源。</p>
<p><strong>举例</strong> 在程序语言理论中，上下文(context) 指形式上可继续补充内容的构造；文档可能非形式地使用和这个含义相容的概念。</p>
<ul>
<li>实体(entity) ：任意被自然语言表达的目标；不需要通过自然语言先验定义；参见经验语义。</li>
<li>语义(semantics) ：参见经验语义。</li>
<li>经验(experience) ：参见哲学或一般等价的经验语义。</li>
<li>范畴(category) ：参见<a href="https://zh.wikipedia.org/zh-cn/%E8%8C%83%E7%95%B4%E8%AE%BA">范畴论</a>。</li>
<li>态射(morphism) ：参见范畴论。</li>
<li>归纳(induction) ：一种态射，可操作性参见经验语义。</li>
<li>方法学(methodology) ：一个归纳经验得到的范畴；参见哲学或一般等价的经验语义。</li>
<li>方法(method) ：方法学的一个子范畴；可操作性参见经验语义。</li>
<li>概念(concept) ：参见逻辑学。</li>
<li>上下文(context) ：一种概念范畴适用的态射；参见经验语义。</li>
</ul>
<h2 id="非自指"><a class="header" href="#非自指">非自指</a></h2>
<p>　　包含多个一般领域的概念。</p>
<ul>
<li><em>&lt;名词&gt;</em> 形式(form) ：参见经验语义和数学。</li>
<li><em>&lt;概念&gt;</em> 内涵：参见逻辑学。</li>
<li><em>&lt;概念&gt;</em> 外延：参见逻辑学。</li>
<li><em>&lt;概念&gt;</em> 定义(definition) ：确定概念内涵和外延的方法；参见任意一种形式逻辑学。</li>
<li><em>&lt;动词&gt;</em> 抽象(abstracting) ：通过经验语义定义概念范畴或集合的方法。</li>
<li><em>&lt;名词&gt;</em> 抽象(abstraction) ：<em>&lt;动词&gt;</em> 抽象的结果。</li>
<li><em>&lt;动词&gt;</em> 封装(encapsulating) ：从某一个范畴中抽象一个子范畴的方法。</li>
<li><em>&lt;名词&gt;</em> 封装(encapsulation) ：<em>&lt;动词&gt;</em> 封装的结果。</li>
<li>规范(specialization) ：一种提供在特定上下文中可定义的描述的封装，参见工程学（特别是软件工程学，下同）。</li>
<li>接口(interface) ：一种封装，参见工程学。</li>
<li>实现(implementation) ：一种封装，参见工程学。</li>
<li>重用(reusing) ：参见经验语义和工程学。</li>
<li>不变性(invariance) ：满足某种<a href="https://zh.wikipedia.org/zh-cn/%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB">等价关系</a>（自反、传递、对称的<a href="https://zh.wikipedia.org/zh-cn/%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB">二元关系</a>）。</li>
<li>不变量(invariant) ：具有不变性的实体。参见数学和契约式程序设计。</li>
<li>状态(state) ：可以和其它实体关联的、可在某个上下文中保持变化或不变的实体。同一状态总是保持变化或保持不变。状态变化的含义参见经验语义、数学或另行指定。
<ul>
<li>可变状态(mutable state) ：在某个上下文中可能映射到若干其它状态的状态。</li>
<li>不可变状态(immutable state) ：不是可变状态的状态。</li>
</ul>
</li>
<li><em>&lt;动词&gt;</em> 派生(deriving) ：基于重用的操作。</li>
<li><em>&lt;名词&gt;</em> 派生(derivation) ：<em>&lt;动词&gt;</em> 派生的结果。</li>
</ul>
<h1 id="计算机科学"><a class="header" href="#计算机科学">计算机科学</a></h1>
<p>　　包含多个关于数学、逻辑学和计算机领域的概念。</p>
<ul>
<li><em>&lt;动词&gt;</em> 形式化(formalize) ：建立数学意义上的严格<a href="#%E9%9D%9E%E8%87%AA%E6%8C%87">形式</a>。</li>
<li><em>&lt;名词&gt;</em> 形式化(formalization) ：建立形式的过程。</li>
<li>形式方法(formal method) ：包含形式化的<a href="#%E8%87%AA%E6%8C%87">方法</a>。</li>
<li><em>&lt;动词&gt;</em> 建模(model) ：建立形式化输出的形式。</li>
<li><em>&lt;名词&gt;</em> 模型(model) ：建模的结果。</li>
<li>可计算性(computability) ：参见数学。
<ul>
<li>通常由 <a href="https://zh.wikipedia.org/zh-cn/%E9%82%B1%E5%A5%87%EF%BC%8D%E5%9B%BE%E7%81%B5%E8%AE%BA%E9%A2%98">Church-Turing 论题</a>定义。</li>
</ul>
</li>
<li>计算(computation) ：由可计算性定义的操作的等价类。</li>
<li>计算模型(computation model) ：描述计算的模型，是对计算建模的结果。</li>
<li>集合(set) ：一种数学模型，参见 <a href="https://zh.wikipedia.org/zh-cn/%E5%86%AF%E8%AF%BA%E4%BC%8A%E6%9B%BC-%E5%8D%9A%E5%86%85%E6%96%AF-%E5%93%A5%E5%BE%B7%E5%B0%94%E9%9B%86%E5%90%88%E8%AE%BA">NBG 集合论</a>。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E7%B1%BB_%28%E6%95%B0%E5%AD%A6%29">类</a>(class) ：参见 NBG 集合论和范畴论。</li>
<li>真类(proper class) ：参见 NBG 集合论和范畴论。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB">二元关系</a>(binary relationship) ：一种基于集合上定义的数学实体。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB">等价关系</a>(equivalence relationship) ：自反的(reflexive) 、对称的(symentric) 和传递的(transitive) 的二元关系。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E7%AD%89%E4%BB%B7%E7%B1%BB">等价类</a>(equivalence class) ：等价关系划分集合得到的类。</li>
<li>序列(sequence) ：有序集合。</li>
<li>形式语义(formal semantics) ：使用形式化的方式表达的语义。</li>
<li>形式语言(formal language) : 特定形式化的方式确定的元素的全集。
<ul>
<li><strong>注释</strong> 这也可能作为<a href="#%E8%A7%84%E8%8C%83">语言规则</a>对应的某种形式语义。这同时是语言对应的<a href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">语法</a>的外延。</li>
</ul>
</li>
<li>计算复杂度(computational complexity) ：某个形式化计算模型中以有限的正整数作为模型决定的规模(metric) 作为参数的渐进(asymptotic) 性质确定的度量。
<ul>
<li>时间复杂度(time complexity) ：描述步骤规模的计算复杂度。</li>
<li>空间复杂度(space comlexity) ：描述存储规模的计算复杂度。</li>
</ul>
</li>
</ul>
<h1 id="规范"><a class="header" href="#规范">规范</a></h1>
<p>　　包含提供<a href="#%E8%87%AA%E6%8C%87">规范</a>的<a href="#%E8%87%AA%E6%8C%87">实体</a>定义。</p>
<ul>
<li>符合性(conformance) ：满足规范的实现性质。</li>
<li>要求(requirement) ：规范对实现的作为判断符合性的条件。</li>
<li>约束(constraint) ：可被<a href="#%E9%9D%9E%E8%87%AA%E6%8C%87">形式</a>表达，用于限制和明确行为的规则。不一定使用形式表达。</li>
<li>违反(violation) ：对约束指定的条件的不满足。</li>
<li>过时的(obsolesent) ：已确认因为存在更合适的选项而建议不继续使用的（接口/特性）。</li>
<li>废弃的(deprecated) ：过时的但因为兼容性等原因，暂时保留的、一般可提供替代的接口或特性。</li>
<li>语言：<a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">模型</a>或者非形式地其它方式定义的一种<a href="#%E9%9D%9E%E8%87%AA%E6%8C%87">接口</a>。</li>
<li><em>&lt;语言&gt;</em> 接口(<em>&lt;language&gt;</em> interface) ：和表达<a href="#%E8%87%AA%E6%8C%87">语义</a>有关的语言的可见的特征。</li>
</ul>
<p>　　包含关于语言的规范的定义。</p>
<ul>
<li><em>&lt;语言&gt;</em> 实现(<em>&lt;language&gt;</em> implementation)：对语言规则中的要求的<a href="#%E9%9D%9E%E8%87%AA%E6%8C%87"><em>&lt;非自指&gt;</em> 实现</a>。</li>
<li><em>&lt;语言&gt;</em> 人类接口(human interface) ：语义仅对人类有意义（内容改变时可以导致语义的差异性），不提供为涉及作为计算模型实现的语言接口。</li>
<li><em>&lt;语言&gt;</em> 机器接口(machine interface) ：对机器（或特定语言实现的特定部分）有意义的语言接口。注意不同语言实现组成部分可以不同。
<ul>
<li><strong>举例</strong> 对 <a href="https://zh.wikipedia.org/zh-cn/C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8">C 语言的预处理器</a>，C 源代码中的空白符是机器接口，而对翻译器来说则不是。就源代码而言，机器接口总是人类接口的子集。</li>
</ul>
</li>
<li><em>&lt;语言&gt;</em> 特性(*&lt;language&gt; feature) ：作为功能提供的人类接口。</li>
<li>语言规则(language rule) ：约定可实现及应被实现的语言接口的描述，可包含语言特性的表达。</li>
<li>语言规范(language specialization) ：包含正式的(normative) 的语言规则的集合的<a href="#%E8%87%AA%E6%8C%87">规范</a>；或称语言规格说明。</li>
<li>语言实现(language implementation) ：语言提供的接口的实现，是语言的表现形式，可以是具体语言实现或抽象语言实现之一。
<ul>
<li>具体语言实现(concreate language implementation) ：能最终完全表达为可预测的物理现象一一对应的表达<a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">可计算性</a>的实现（如机器指令），一般应为程序。</li>
<li>抽象语言实现(abstract language implementation) ：非具体语言实现的语言实现。形式意义的标准定义的语言属于此类。</li>
</ul>
</li>
<li>派生语言实现(derived language implementation) ：派生已有实现的部分或全部得到的语言实现。以下简作“派生实现”。</li>
<li><em>&lt;语言&gt;</em> 实现环境(environment of implementation) ：对应特定语言实现的特定不变状态（对机器来说可以是配置项，对人来说不确定，所以一般忽略）的集合。</li>
<li><em>&lt;语言&gt;</em> 互操作(interoperation) ：不同的语言实现环境中发生的交互。</li>
<li>未定义的(undefined) ：可能导致违反<a href="#%E8%87%AA%E6%8C%87">规范</a>的约束但语言规范同时没有要求提供任何可能影响<a href="#%E9%9D%9E%E8%87%AA%E6%8C%87">符合性</a>的保证（如具有诊断消息）的。
<ul>
<li><strong>注释</strong> 表示置于语言规则下的行为等不可预测。</li>
</ul>
</li>
<li>良定义的(well-defined) ：明确地非未定义的。</li>
<li>未指定的(unspecified) ：<a href="#%E8%87%AA%E6%8C%87">规范</a>隐式或显式地允许但不要求唯一确定的至少一个实现选项。
<ul>
<li><strong>注释</strong> 通常允许多种不同的选项；但在特定实现配置下，规则中未指定的选项也可被限制为只有一种可行的选项。</li>
<li><strong>注释</strong> 同一个实现或者不同实现可能确定地或非确定地选取不同的选项而不保证表现一致。</li>
</ul>
</li>
<li>由实现定义的(implementation-defined) ：取决于各个具体语言实现的，要求有文档说明。</li>
<li>由派生实现定义的(derived-implementation-defined) ：取决于各个派生语言实现的，要求除存在默认定义或被派生实现的部分有明确的文档说明。</li>
</ul>
<h1 id="程序设计语言"><a class="header" href="#程序设计语言">程序设计语言</a></h1>
<p>　　提供上下文 <em>&lt;程序设计语言&gt;</em> ，特别是语言规范的定义。</p>
<p>　　主要用例参见版本库中的项目文档 <code>doc/NPL.txt</code> 。</p>
<ul>
<li>广义实体：<em>&lt;通用领域&gt;</em> 实体。语言抽象的目标，不另行定义（意义最终取决于自然语言）。</li>
<li>名称(name) ：一种特殊的广义实体，专用于指称另一个广义实体。</li>
<li>实体(entity) ：非名称的广义实体。</li>
<li>表示(representation) ：以一个符合某种形式的约束的实体指称另一个实体。</li>
<li>符号(symbol) ：<a href="#%E8%A7%84%E8%8C%83">语言规则</a>允许的不使用其它对象表示的对象。符号可实现名称。</li>
<li>字母表(alphabet) ：符号在语言中的全集。</li>
<li>串(string) ：可能重复出现的符号的有限序列。</li>
<li>文法(grammar) ：描述任意的可形式化的语言规则。</li>
<li>语法(syntax) ：以语言中的串作为基本元素，描述语言的字面(literal) 结构模式(pattern) 的语言规则，通常是文法的一部分。</li>
<li>语义(semantics) ：非语法的考虑逻辑上的释义(interpretation) 或含义(meaning) 的规则、原理和过程，通常可被语法以外的文法描述并可约束含义的表达。</li>
<li>实例(instance) ：具有代表性含义的集合的元素。</li>
<li>代码(code)：任意有限的语言的实例片段组成的语法范畴。</li>
<li>伪代码(pseudo code)：抽象语言实现的语言的代码。
<ul>
<li><strong>注释</strong> 习惯上和具体语言实现代码完全一致的代码可以不作为伪代码考虑。</li>
</ul>
</li>
<li>程序(program) ：具体语言实现接受的以代码表示的输入，或被变换后对应的输出。</li>
<li>行为(behavior) ：语言实现或在满足符合性的具体语言实现中的程序的外部表现。基于可操作性考虑，一般仅约束实现的机器<a href="#%E9%9D%9E%E8%87%AA%E6%8C%87">接口</a>。</li>
<li>计算作用(computational effect) ：可被某个形式化计算模型描述的行为。</li>
<li>翻译(translation) ：不同语言的程序之间的变换，可作为语言实现的形式。
<ul>
<li><strong>注释</strong> 输入和输出具有相同表示的恒等变换不被视为翻译。</li>
</ul>
</li>
<li>运行(run) ：实现程序或组成程序的实体的行为的动作。</li>
<li>加载(load) ：运行程序或组成程序的实体时从实现环境取得相关实体的动作，可蕴含创建这些实体的副本或翻译其中的代码到特定形式。</li>
<li>执行(execute) ：处理程序或组成程序的实体，使这些实体或实体的副本作为资源被消费而蕴含这些实体被运行，同时可能蕴含消费实现环境的其它资源。
<ul>
<li><strong>注释</strong> 执行强调资源的消费，是运行的子集。资源被消费后不再可用。因此，除非同时蕴含资源的<em>再生(reclaim)</em> ，被执行的同一实体不预期被再次执行。再生资源包括实体加载时翻译或取得副本，及实现环境中补充的替代资源。</li>
</ul>
</li>
<li>解释(interpretation) ：通过不依赖显式指定的附加的程序翻译而直接运行表现行为的具体语言实现的形式。</li>
<li>源语言(source language) ：翻译的输入的语言。</li>
<li>目标语言(destination language) ：翻译的输入的语言。</li>
<li>源代码(source code) ：源语言编码的代码。</li>
<li>源程序(source program) ：形式为作为翻译的输入的源代码程序。</li>
<li>复杂度(complexity) ：以程序的规模作为参数的关于程序的直接执行的<a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算复杂度</a>。</li>
<li>元语言(metalanguage) ：描述其它语言的语言。</li>
<li>对象语言(object language)：被元语言操作或实现的语言。</li>
<li>元编程(metaprograming) ：使用元语言编程。</li>
<li>反射(reflection) ：元语言和对象语言相同的元编程。</li>
<li>具现(reification) ：在对象语言中以数据模型作为关联实体以表示程序的语义。</li>
<li>诊断(diagnostics) ：明确的对特定预期或非预期执行的行为的响应的总和。</li>
<li>诊断消息(diagnostic message) ：用于和用户交互的表现诊断的告知及提示。</li>
<li>未定义行为(undefined behavior) ：<a href="#%E8%A7%84%E8%8C%83">未定义的</a>行为。</li>
<li>良定义行为(well-defined behavior) ：<a href="#%E8%A7%84%E8%8C%83">良定义的</a>行为。</li>
<li>未指定行为(unspecified behavior) ：<a href="#%E8%A7%84%E8%8C%83">未指定的</a>行为。
<ul>
<li><strong>注释</strong> 由实现选取<a href="#%E8%A7%84%E8%8C%83">语言规范</a>中可能允许的指定行为的不确定选项，这些选项可能由显式或隐式的语言规则确定。</li>
<li><strong>注释</strong> 推论：由实现定义的行为是未指定行为。在本文档中，为最小化依赖，不在正式规则中明确这些关系。</li>
</ul>
</li>
<li>语言特性(language feature) ：语言提供的功能接口，可以是具体语言特性或抽象语言特性之一。</li>
<li>具体语言特性(concrete language feature) ：完全没有派生语言实现定义的语言特性。</li>
<li>抽象语言特性(abstract language feature) ：非具体语言特性的语言特性。</li>
<li>外部环境(external environment) ：和程序及被翻译的程序没有交集的和实现环境无关的状态。</li>
<li>外部表示(external representation) ：具有特定形式的用于和外部环境交互的表示。</li>
<li>内部表示(internal representation) ：非外部表示的表示。</li>
</ul>
<h1 id="项目管理"><a class="header" href="#项目管理">项目管理</a></h1>
<p>　　提供上下文 <em>&lt;项目&gt;</em> 。</p>
<p>　　主要用例参见版本库中的项目文档 <code>doc/ProjectRules.txt</code> 。</p>
<ul>
<li>涉众(skateholder) ：项目关联的各方的主体。</li>
<li>角色(role) ：依据项目过程中起到的作用，对项目涉众实行一些附加归类。
<ul>
<li><strong>注释</strong> 项目的角色同时可用于项目阶段的描述中。</li>
</ul>
</li>
<li>用户(user) ：使用项目输出的项目涉众。</li>
<li>维护者(maintainer) ：决定项目中各个部分的内容的用户。
<ul>
<li><strong>注释</strong> 维护者可参与和维护部分相关的项目决策。</li>
</ul>
</li>
<li>开发者(developer) ：参与程序库和开发工具的功能修改的用户。
<ul>
<li><strong>注释</strong> 开发者可参与公开的构建过程以完成这些修改。</li>
</ul>
</li>
<li>最终用户(end user) ：独立为项目过程的用户。
<ul>
<li><strong>注释</strong> 最终用户可以不参与提前(ahead-of-time) 构建的项目过程。基于认知需求的差异可能需要从一般用户中单独区分。</li>
</ul>
</li>
</ul>
<h2 id="依赖管理"><a class="header" href="#依赖管理">依赖管理</a></h2>
<p>　　项目管理的客体被分解为特定关联的依赖项。任意两个依赖项之间存在<a href="https://zh.wikipedia.org/zh-cn/%E5%8F%8D%E5%AF%B9%E7%A7%B0%E5%85%B3%E7%B3%BB">反对称</a>和<a href="https://zh.wikipedia.org/zh-cn/%E4%BC%A0%E9%80%92%E5%85%B3%E7%B3%BB">传递</a>的<a href="https://zh.wikipedia.org/zh-cn/%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB">二元关系</a>称为<strong>依赖关系</strong>。<strong>严格依赖关系</strong>是反自反的依赖关系。</p>
<p>　　依赖项和依赖项之间的严格依赖关系统称为<em>依赖(dependency)</em> 。</p>
<h3 id="依赖引用"><a class="header" href="#依赖引用">依赖引用</a></h3>
<p>　　因为依赖关系的传递性，多个依赖关系可能存在无法满足严格依赖关系的情形，即<em>循环依赖(cyclic dependency)</em> 。这导致以确定的顺序解析依赖不可行，增加维护成本。</p>
<p>　　为了避免一定层次上的循环依赖，以该层次内组件为顶点的依赖关系的关系图应明确组织为有向无环图。
在最简单情况下依赖关系可退化为线性顺序依赖。</p>
<h3 id="内部依赖和外部依赖"><a class="header" href="#内部依赖和外部依赖">内部依赖和外部依赖</a></h3>
<p>　　项目中的组成部分之间的依赖称为<strong>内部依赖</strong>，其它依赖为<strong>外部依赖</strong>。</p>
<h2 id="源代码"><a class="header" href="#源代码"><a href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源代码</a></a></h2>
<p>　　源代码用于生成指定目标代码(target code) 。</p>
<p>　　通常源代码以文件形式保存，即源代码文件(source code file) ，简称源文件(source file) 。</p>
<h2 id="版本库"><a class="header" href="#版本库">版本库</a></h2>
<p>　　项目使用的版本控制系统(version controlling system) 具有存储库(repository) 作为持久存储实体，即版本库。</p>
<p>　　当前使用的主要版本控制系统为 <a href="https://www.mercurial-scm.org/">Mercurial</a> 。因为是分布式版本控制，也用于直接分发源代码。</p>
<p>　　每个文件系统上存储的版本库实例中，<code>.hg</code> 目录存储版本库元数据。</p>
<h1 id="设计和模型"><a class="header" href="#设计和模型">设计和模型</a></h1>
<h2 id="环境"><a class="header" href="#环境">环境</a></h2>
<p>　　程序中的某一部分的外界称为<strong>环境(environment)</strong>。根据限定程序的范围，可以有更确切的定义，如<a href="#%E8%A7%84%E8%8C%83">实现环境</a>（对一类语言实现而言）、运行时环境（对共享实现环境的一类程序而言）。</p>
<p>　　一般地，实现环境可以分为<em>独立环境(freestanding environment)</em> 和<em>宿主环境(hosted environment)</em> ，区分依据为是否依赖宿主（对部署在单一计算机上的实现，一般指操作系统）的支持。因此，环境有时指操作系统及其提供的外部服务的集合。</p>
<p>　　一些语言，如 ISO C 和 ISO C++ ，可以同时支持宿主环境和独立环境的实现，对应<em>独立实现(freestanding impementation)</em> 和<em>宿主实现(hosted impementation)</em> 。</p>
<h2 id="平台"><a class="header" href="#平台">平台</a></h2>
<p>　　环境中决定程序适用环境的被依赖的特定资源集合称为<strong>平台环境(platform environment)</strong>，简称<strong>平台(platform)</strong>。平台的典型例子有：</p>
<ul>
<li>运行时支持的<a href="https://zh.wikipedia.org/zh-cn/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%A7%8B">硬件的体系结构</a> ；</li>
<li>操作系统和 <a href="https://zh.wikipedia.org/zh-cn/%E5%BA%94%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8E%A5%E5%8F%A3">ABI</a> 。</li>
</ul>
<p>　　平台的内涵是资源的集合，其构成并非任意。构成平台的特定准则应使之保持相对的稳定和可预期，即可配置；即平台是名义的(nominal) 可配置的资源集合。</p>
<p>　　若平台包含的资源是已知的，则不需要平台的观念，分析其资源子集（即便不构成平台）即可解决几乎平台抽象涉及的所有技术问题（同时这也是定义一个具体平台的基础）。但在简化资源集合的全局性质分析（如比较资源配置方案）和名义抽象以隐藏实现（如为开发者提供预设环境集合）的应用角度上，平台仍有被单独讨论的意义。</p>
<h3 id="兼容性和可移植性"><a class="header" href="#兼容性和可移植性">兼容性和可移植性</a></h3>
<p>　　若一个依赖项对应的平台可以替换，则此依赖项和此平台<em>兼容(compatible)</em> 。<strong>兼容性(compatibility)</strong> 是平台兼容的二元关系。兼容性不是一种<a href="https://zh.wikipedia.org/zh-cn/%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB">等价关系</a>，因为不保证传递。</p>
<p>　　替换平台的过程称为<em>移植(porting)</em> 。移植的可行性称为<strong>可移植性(portability)</strong> 。</p>
<p>　　兼容任意平台的依赖项被称为是<em>平台中立(platform-neutral)</em> 的。</p>
<p>　　当平台中立的依赖项的依赖能被自动满足而不需要考虑时，是<em>平台无关(platform-independent)</em> 的。平台中立<a href="https://zh.wikipedia.org/zh-cn/%E5%AE%9E%E8%B4%A8%E6%9D%A1%E4%BB%B6">实质蕴含</a>平台无关。</p>
<h3 id="依赖和外延"><a class="header" href="#依赖和外延">依赖和外延</a></h3>
<p>　　若平台之间不出现平台的实现（如开发语言的实现）和环境自身的相互依赖，则这些平台相互<em>独立(independent)</em> 。总是保持相互独立的一组平台称为<em>独立平台(independent platforms)</em> 。每一组独立平台保证可以相对于其它独立平台分离开发和测试。</p>
<p>　　注意以上术语和 ISO C 和 ISO C++ 定义的<em>宿主实现(hosted implementation)</em> 和<em>独立实现(freestanding implementation)</em> 的关联和区别。</p>
<p>　　典型的应用场景约定以下类型的平台：</p>
<ul>
<li>构建平台(build platform) ：运行开发环境的平台。</li>
<li>宿主平台(host platform) ：运行构建平台输出代码的平台。</li>
<li>目标平台(target platform) ：运行最终目标代码的平台。</li>
</ul>
<p>　　若宿主平台和构建平台一致，称为<em>本机构建(native build)</em> ；否则，称为<em>交叉构建(corss build)</em> 。</p>
<p>　　通常构建工具在本机构建时提供对构建平台的检查以确定自身是否能够运行；交叉构建环境需要显式指定。</p>
<p>　　目标平台通常和宿主平台一致。指定目标平台的理由是，存在最终不一定在宿主平台上运行的程序，其运行的环境可能需要宿主平台不保证支持的特性，这典型地包括：</p>
<ul>
<li>构建的程序自身是生成其它程序的程序，如编译器和链接器。这些程序生成的平台是目标平台，不需要和它们的宿主平台相同。</li>
<li>构建的程序可以在宿主平台上运行，但在其它平台上具有更完全的特性集。后者被作为目标平台。</li>
</ul>
<p><strong>注意</strong> 此处的宿主平台具有相对意义，不一定脱离被运行的目标平台。一个宿主平台通常自身是宿主实现平台，但这点不被保证。</p>
<h3 id="模拟和仿真"><a class="header" href="#模拟和仿真">模拟和仿真</a></h3>
<p>　　<strong>模拟(emulation)</strong> 指适配和运行为不同平台设计的程序，广义上包括以下两类：</p>
<ul>
<li>环境模拟(environment emulation) ：使用模拟器(emulator)或虚拟机(virtual machine) 等作为宿主平台的程序，模拟运行环境的通用解决方案。</li>
<li>程序模拟(program emulation) ：直接以运行时环境适配层嵌入宿主平台运行时，在具体程序中提供类似被模拟的目标平台的具体特性和接口。</li>
</ul>
<p>　　运行模拟程序的环境和被模拟环境分别是宿主平台和目标平台。</p>
<p>　　注意虚拟机在这个意义下是广义的模拟器，但一般仍然分别对待。</p>
<p>　　环境模拟和程序模拟的主要差异为是否独立的、专用的宿主平台程序作为中介以维护目标平台和宿主平台的隔离。</p>
<p>　　在一般意义上，<strong>仿真(simulation)</strong> 指对需要分析的问题建立的模型(model) 的过程、方法和机制，在软件工程以外也被称为模拟，如计算机模拟(computer simulation) 。对于以计算机系统为目标的仿真，建立的模型可以是具体的实物（包括硬件和软件），称为仿真器(simulator) 。以软件接口为主要操作方式实现的仿真器同时实现了环境模拟，但侧重不同：精确重现需要分析行为，而非实用的功能等价性和体系中的可替换性。</p>
<h3 id="平台配置"><a class="header" href="#平台配置">平台配置</a></h3>
<p>　　实际的平台实现可能复用部分实现，配置之间可存在某种构成依赖关系的<a href="https://zh.wikipedia.org/zh-cn/%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB">偏序关系</a>（如继承关系）。这些在项目中所有被配置的平台称为<em>公共平台(common platform)</em> ，其中能对应生成输出的称为<em>具体平台(concrete platform)</em> ，否则为<em>抽象平台(abstract platform)</em> 。</p>
<p>　　对一个平台配置，程序可提供更多的子配置共用现有的相同的配置。子配置可继续对平台特性具体特化，而对原始配置的用户程序隐藏细节。</p>
<p>　　普遍适用于一般功能配置也可被作为平台配置的一部分而作为子配置。</p>
<p><strong>注释</strong> 例如，多线程和非多线程版本、调试和非调试版本可作为平台配置的功能子配置。</p>
<p><strong>原理</strong> 尽管功能配置提供的特性可能是普遍的，但它的实现依赖的特性不都在每个平台中存在，而可能需要一定程度的模拟和仿真，或可选地提供部分特性。提供功能子配置可把这些特性作为次要的实现细节，和原始的平台上的更显著特性隔离。</p>
<p>　　若存在这样的子配置，应当满足：</p>
<ul>
<li>这些子配置应当在每个部署的用户程序的依赖中保持唯一，即一个环境中不能同时依赖不同的子配置的程序映像。
<ul>
<li><strong>原理</strong> 这样不但不需要保持子配置之间的 ABI 兼容性，同时 API 也可以存在不兼容（而不仅仅是调试符号等附加元数据的差异）。</li>
</ul>
</li>
<li>相应地，依赖不同子配置的用户程序也具有对应的子配置。用户程序可以仅提供其中的部分子配置的程序映像。
<ul>
<li><strong>原理</strong> 对每个子配置需要提供单独的依赖路径以避免冲突，因此一般不能在同一个部署中直接复用不同子配置的程序映像。为了避免不必要的资源占用，支持用户程序仅提供部分子配置（而非所有子配置的映像）是必要的。</li>
</ul>
</li>
<li>除非另行指定，被复用的公开库的程序名称在不同子配置中应当存在差异。
<ul>
<li><strong>原理</strong> 尽管不会同时被一个用户程序依赖，每个部署中，不同的子配置的程序映像通常仍需共存。在名称上要求差异允许文件系统直接支持这种策略。</li>
</ul>
</li>
</ul>
<h3 id="标识"><a class="header" href="#标识">标识</a></h3>
<p>　　不同平台可以标识符加以区分。由于平台受到不同环境因素决定的正交性，通常此类标识符可以分解为表示这些正交环境的标识符的元组形式，用 <code>-</code> 等字符分隔。</p>
<p>　　一种常用的方式是 GNU 构建系统的<a href="https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.69/html_node/System-Type.html#System-Type">系统类型(en-US)</a>，经典表示方式为三元组(triplet) ，或其省略形式：</p>
<ul>
<li>一般包括体系结构、系统厂商和系统软件环境。</li>
<li>第一项不可省略，之后的项可省略。</li>
<li>体系结构一般指定 CPU 要求的最小指令集架构。</li>
<li>系统厂商指集成平台的环境厂商。</li>
<li>系统软件环境保证满足 ABI 要求，可以包含操作系统及本机语言运行时实现的名称。</li>
</ul>
<p>　　确定为宿主环境时，系统软件同时指定操作系统和运行时环境而拆分为两项，三元组扩充为四元组，如 <a href="https://wiki.gentoo.org/wiki/CHOST">Gentoo 使用的 CHOST (en-US)</a>。</p>
<p>　　在不够充分体现平台的必要差异（尤其是体系结构相关的配置）时也可通过自行定义标识符并指定与三元组的对应关系，如 <a href="%5Bhttps://wiki.debian.org/Multiarch/Tuples%5D">Debian multiarch (en-US)</a> 。</p>
<p>　　系统类型用来提供一定程度的兼容（替换和互操作）：</p>
<ul>
<li>系统类型代表了系统厂商的预设的配置集合，因此可提供符合相对上的（事实）标准的构建和运行环境。</li>
<li>这种兼容性有时会被过度依赖，乃至被误认为完全的 ABI 兼容：
<ul>
<li>系统类型不保证涵盖所有 ABI 细节，满足相同的系统类型的程序实例之间不一定符合完全相同的 ABI 而可相互替换或互操作，即原则上即不保证完全的 ABI 兼容。
<ul>
<li><strong>原理</strong> 实现的差异原则上不适合或无法通过系统类型区分。否则，系统类型事实上需要任意地长以涵盖不同细节，而会导致程序部署环境的碎片化，使维护兼容性的原始目的失去主要意义。</li>
</ul>
</li>
<li>一个主要实例：不同构建工具链生成的二进制程序之间不总是保证完全的 ABI 兼容。
<ul>
<li>同一个版本的同一工具链通过某些构建选项即可能构建出不能保证 ABI 兼容的二进制程序映像。
<ul>
<li>例如，GCC 使用 <code>-m</code> 前缀选项可能影响 ABI 。</li>
</ul>
</li>
<li>即便使用工具链发行版固定的默认预设选项，不同版本工具链在设计上不能完全保证二进制兼容性。
<ul>
<li>例如，为兼容 ISO C++11 中关于 <code>std::basic_string</code> 和 <code>std::list</code> 等 API 改动，GCC 5 显式提供<a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_dual_abi.html">不同的 ABI 配置</a> 而在支持这些改动的配置上[放弃对原有 libstdc++ 的 ABI 兼容保证。</li>
</ul>
</li>
</ul>
</li>
<li>相同的系统类型可以对应不同的依赖集合，已被作为实用的维护兼容性的方法。
<ul>
<li>这种差异通常隐藏在系统库之下，此时提供不同的二进制兼容映像可以在部署时对依赖系统库的程序隐藏这些差异。</li>
</ul>
</li>
<li><strong>注释</strong> 现代 Microsoft Windows（基于 Windows NT 执行体）是应用包括这类兼容性在内的多种策略的一个典型实例：
<ul>
<li>隐藏二进制差异的主要实例是 Microsoft Windows NT 的 Win32 和 <a href="https://zh.wikipedia.org/zh-cn/%E5%BE%AE%E8%BD%AFPOSIX%E5%AD%90%E7%B3%BB%E7%BB%9F">POSIX 子系统</a>，用户程序通过链接到不同的子系统 DLL ，可共享上层 ABI 。</li>
<li><a href="https://www.cygwin.com/">Cygwin</a> 是一个类似的 POSIX 子系统替代实现，其用户程序当前默认依赖系统库 <code>cygwin1.dll</code> 。</li>
<li>Windows Subsystem for Linux (WSL) 则不是这种兼容性的实例。
<ul>
<li>因为映像格式的差异，它的用户空间程序使用的系统类型更接近 x86_64-pc-linux（具体系统类型取决于安装的发行版；典型地是 x86_64-pc-linux-gnu ）。</li>
<li>部署 WSL 环境需要涉及一整套不同系统类型的二进制映像，仅在子系统的内部实现存在（对 Windows NT 执行体而言的）隐藏实现差异的情形。</li>
</ul>
</li>
<li>不涉及子系统但同样通过 DLL 隐藏二进制的实例是隐藏系统库的版本差异：不同版本的 C 运行时(CRT) 和 Microsoft VC++ 运行时库可以在一个 Windows 系统实例中共存。
<ul>
<li>特别地，MSVCRT 和 UCRT 作为不同的 CRT ，可在同一个系统映像中安装，并作为同一个系统类型的不同实现提供。</li>
<li>同时，不同的 CRT 可具有不同的工具链支持。</li>
<li>不同版本的运行时中每个子配置（多线程和非多线程版本、调试和非调试版本）共用相同的配置，在此不视为存在差异。</li>
<li>CRT 的多版本部署和其它一些系统中 libc 显式影响系统类型不同。
<ul>
<li><strong>原理</strong> 尽管同样是作为语言实现的一部分部署的系统库（至少在通常以此<a href="https://www.gnu.org/licenses/gcc-exception-3.1-faq.html">为由</a>取得<a href="https://www.gnu.org/licenses/gcc-exception-3.1.html">许可证豁免</a>的意义上），仅有后者通常是影响整个系统部署的库，而不适合通过相同的系统类型提供二进制不兼容的版本。否则，这会使整个系统中的几乎所有二进制程序映像之间都不具有二进制兼容性，而无法通过<a href="https://en.wikipedia.org/wiki/Dynamic_linker#Implementations">通常的机制</a>共享二进制代码。</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://www.msys2.org/docs/environments/MSYS">MSYS2 提供的不同环境</a> 是体现上述所有各种不同兼容性方式的一个复杂实例。
<ul>
<li>其中，MSYS2 环境基于 Cygwin ，是通过类似子系统 DLL 部署的兼容层，其用户程序当前默认依赖系统库 <code>msys-2.0.dll</code> 。</li>
<li>其余环境被视为原生的 Win32 应用，使用 Win32 子系统。按体系结构归类分组，每一组内可存在原生的共用相同系统类型的不同实现。
<ul>
<li>例如，<code>/mingw64</code> 、<code>/clang64</code> 和 <code>/ucrt64</code> 中部署的二进制程序共享系统类型 <code>x86_64-w64-mingw32</code> 。</li>
<li>其中 <code>/mingw64</code> 中的程序依赖的 CRT 和另两种共享 <code>x86_64-w64-mingw32</code> 的环境不同，而 <code>/clang64</code> 中的程序依赖的 C++ 运行时库也和另两种环境不同。</li>
</ul>
</li>
</ul>
</li>
<li>上述的这些配置仍然没有穷尽系统库的 ABI 的差异。
<ul>
<li>例如，GCC 工具链中预设了<a href="https://github.com/FrankHB/pl-docs/blob/master/zh-CN/mingw-vs-mingw-v64.md">无法保证 ABI 相互兼容的不同异常处理和线程模型</a>（每个不同的模型同时可需要部署不同的 DLL 作为系统库依赖）。</li>
</ul>
</li>
<li>包括上述 MSYS2 中的每个环境的使用 GCC 的不同发行版都预设了具体的内部依赖，如：
<ul>
<li>MSYS2 中，<code>x86_64-w64-mingw32</code> 环境使用 SEH 异常处理模型，其用户程序当前默认依赖系统库 <code>libgcc_s_seh-1.dll</code> 。</li>
<li>MSYS2 中，<code>i686-w64-mingw32</code> 环境使用 Dwarf2 线程处理模型，其用户程序当前默认依赖系统库 <code>libgcc_s_dw2-1.dll</code> 。</li>
<li>一些发行版如 <a href="https://github.com/niXman/mingw-builds">MinGW-builds</a> 默认使用 SjLj 异常处理模型，其用户程序当前默认依赖系统库 <code>libgcc_s_sjlj-1.dll</code> 。</li>
<li>MSYS2 和大多数其它 <a href="https://www.mingw-w64.org/">MinGW-w64</a> 发行版中长期使用 POSIX 线程模型提供较完善的 C++ 标准库线程特性实现，当前使用 <a href="https://www.mingw-w64.org/#headers-libraries-and-runtime">winpthreads</a> ，其用户程序当前默认依赖系统库 <code>libwinpthread-1.dll</code> 。</li>
<li>预期可在现代环境中替代 <a href="https://www.mingw-w64.org/contribute/#mcfgthread">winpthreads</a> 的 <a href="https://github.com/lhmouse/mcfgthread">mcfgthread</a> 对<a href="https://gcc.gnu.org/pipermail/gcc-patches/2022-October/602704.html">上游的修改已被讨论</a>，使用新的线程模型 <code>mcf</code> ，其用户程序会依赖不同的系统库。</li>
</ul>
</li>
<li>实现系统库时，可依赖非系统库 API 。通常，系统库可直接在运行时依赖 Windows NT 执行体。系统库之间也可存在其它单向的内部依赖。这些情形下，系统库自身不是符合环境要求的程序。
<ul>
<li>例如，mcfgthread 依赖非 Win32 API ，自身不是严格意义的 Win32 程序（尽管构建时仍在运行于 Win32 子系统的假定下链接）。</li>
<li>POSIX 子系统依赖 Win32 系统。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>为了避免兼容性保证过程的复杂性，除非另行指定，关于系统类型：
<ul>
<li>可标识通过源代码部署的单一配置。构建支持和其它外部环境应当被文档明确。</li>
<li>避免认为其它形式部署的唯一依据。特别地，支持可共享相同二进制部署的<a href="#%E5%B9%B3%E5%8F%B0%E9%85%8D%E7%BD%AE">平台子配置</a>。</li>
</ul>
</li>
</ul>
<p>　　除非另行指定：</p>
<ul>
<li>本项目的文档描述使用和三元组兼容的方式指定平台标识的基本形式。</li>
<li>若同一个平台配置存在多个不同的标识符，默认使用以下规则确定：
<ul>
<li>对使用 MinGW-w64 实现的工具链，使用<a href="https://sourceforge.net/p/mingw-w64/wiki2/TypeTriplets/">工具链定义的三元组</a></li>
<li>否则，使用 <a href="https://savannah.gnu.org/projects/config">GNU config</a> 的最新版本中指定的标识符。
<ul>
<li>即 <a href="https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD">config.guess</a> 和 <a href="https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD">config.sub</a> 脚本。</li>
</ul>
</li>
<li><strong>注意</strong> MinGW.org 和 MinGW-w64 都使用 <code>mingw32</code> 而非 <code>mingw64</code> ，这和 GNU guess 不同。应当避免<a href="https://github.com/msys2/MINGW-packages/issues/8020">可能存在的混淆</a>。</li>
</ul>
</li>
<li><strong>注释</strong> 通常不使用 <a href="https://clang.llvm.org/docs/CrossCompilation.html#target-triple">Clang 的三元组</a>。
<ul>
<li><strong>原理</strong> 尽管形式上更清晰，<code>&lt;sys&gt;-&lt;abi&gt;</code> 的划分实际使之成为四元组而非三元组，这种明确划分不总是符合现实的复杂需求。
<ul>
<li>这在关于 ABI 兼容的不明确性和歧义更加显著。这类不一致对适配更多不在现有清单上的平台更加困难，特别是未指定 <code>&lt;vendor&gt;</code> 时。
<ul>
<li><strong>注释</strong> 一个歧义的例子：<code>gnu</code> 在 Linux 上特指 glibc ，而在 Windows 上却指 libstdc++ 代表的 Itanium C++ ABI 实现。后者的 C 运行时库（通称 CRT ）却和 <code>msvc</code> 兼容。</li>
</ul>
</li>
<li>和 GNU guess 不同，Clang 三元组使用的情形相当有限，甚至<a href="https://stackoverflow.com/questions/15036909/">长期以来并不具有用户文档中明确的列表或检查规则</a>。
<ul>
<li>虽然 <code>clang</code> 接受 <code>-triple</code> 指定三元组，<code>clang --print-targets</code> 却输出平台标识符而非三元组。</li>
<li>三元组实际来自 <a href="https://llvm.org/doxygen/Triple_8h_source.html">LLVM 而非 Clang 的支持</a>。</li>
<li>更接近此处需求的是同时使用 LLVM 的 <a href="https://docs.rust-embedded.org/embedonomicon/compiler-support.html#built-in-target"><code>rustc --print target-list</code></a> 的输出。</li>
</ul>
</li>
<li>默认 <code>&lt;unknown&gt;</code> 但不一定在清单中被排除。这种随意性引起一些解析和理解上的困难。
<ul>
<li><strong>注释</strong> 在清单中滥用 <code>&lt;unknown&gt;</code> 的大量（却不是每个）例子可在 <code>rustc --print target-list</code> 的输出中找到。例如，通常读者（和系统维护者）难以理解：为何存在 <code>wasm32-unknown-emscripten</code> 和 <code>wasm32-wasi</code> 的同时还有 <code>wasm32-unknown-unknown</code> 而非 <code>wasm32-unknown</code> ？</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>具体构建过程可按需不同形式的标识符。
<ul>
<li><strong>原理</strong> 平台配置不一定通过系统类型描述。
<ul>
<li><strong>注释</strong> 例如，<code>cmake -G</code> 支持的标识依赖生成系统的配置，而非运行程序的系统类型。</li>
</ul>
</li>
<li><strong>原理</strong> 在不需要关心系统类型中各个组成部分的情形，其它的平台标识符可提供更简单明确的替代。
<ul>
<li><strong>注释</strong> <code>cmake -G clang --print-targets</code> 的结果是一个实例。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多平台构建"><a class="header" href="#多平台构建">多平台构建</a></h3>
<p>　　构建系统中可能涉及多个平台。</p>
<p>　　运行构建系统的环境和被构建的程序的环境不需要相同，对应的平台分别称为宿主平台(host platform) 和目标平台(target platform) 。宿主平台和目标平台相同时称为本机(native) 构建；不同时称为交叉(build) 构建。</p>
<p>　　多个构建过程可能串联组成更大的构建过程。不同构建过程存在输出和输入之间的依赖。此时，前一过程输出的目标平台需要兼容于后一过程作为输入的宿主平台，否则无法直接运行。典型情况下这些平台是相同的，但也可以存在平台之间自身保证二进制<a href="#%E8%A7%84%E8%8C%83">互操作</a>兼容性（如支持 x86_64 的体系结构上混用 i686 和 x86_64 ）的情况。</p>
<p>　　一些构建系统如 <a href="https://gcc.gnu.org/onlinedocs/gccint/Configure-Terms.html">GNU 工具链(en-US) 使用更复杂的术语</a>，单独引入构建(build) 平台。为确保一般性并简化模型，YSLib 不使用这个概念，而把构建平台作为第一级构建过程（即 GNU autoconf 的“配置”）的宿主平台。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="EMPTY.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="StandardUsing.en-US.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="EMPTY.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="StandardUsing.en-US.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
