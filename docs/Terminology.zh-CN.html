<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>术语概要 - The YSLib Book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Book tranplanted from YSLib BitBucket wiki.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The YSLib Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="术语概要"><a class="header" href="#术语概要">术语概要</a></h1>
<p>　　本文档概述及约定 YSLib 基本的概念含义，主要用于<a href="Development.zh-CN.html">开发</a>。</p>
<p>　　一些术语概念适用各种不同的上下文，主要用于开发过程中的设计和规则说明。</p>
<p>　　术语以列表形式的条目列出。通过使用元语言语法 <em>&lt;相关范畴/上下文&gt;</em> 标记指示被修饰或被限定的概念的适用范围。不需要消歧义时，省略标记。</p>
<h1 id="通用领域"><a class="header" href="#通用领域">通用领域</a></h1>
<p>　　除非另行指定，适用于任意<a href="#%E8%87%AA%E6%8C%87">上下文</a>；但存在更具体的上下文的特定概念定义时，优先适用后者。</p>
<h2 id="经验语义"><a class="header" href="#经验语义">经验语义</a></h2>
<p>　　经验语义解释的术语的含义总是假定可被实证，不需要进一步解释。</p>
<p>　　元语言中的标记使用经验语义。标记可被本文档中已归类的章节提供。</p>
<p>　　本文档中非形式地使用在特定理论中严格定义的、和<a href="#%E9%80%9A%E7%94%A8%E9%A2%86%E5%9F%9F">本章</a>的条目具有逻辑上相容的含义的概念时，不进一步解释。</p>
<h2 id="自指"><a class="header" href="#自指">自指</a></h2>
<p>　　<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E6%8C%87"><strong>自指</strong></a>是概念定义形式上的自我指涉。</p>
<p><strong>示例</strong> “<a href="#%E9%80%9A%E7%94%A8%E9%A2%86%E5%9F%9F">本章</a>”是关于位置的自指。</p>
<p>　　有必要通过自指定义的概念，隐含引入定义内容的过程的<a href="https://zh.wikipedia.org/zh-cn/%E5%BE%AA%E7%92%B0%E8%AB%96%E8%AD%89">循环论证</a>。这些概念的精确内涵和外延依赖<a href="#%E7%BB%8F%E9%AA%8C%E8%AF%AD%E4%B9%89">经验语义</a>的实证，否则在自然语言语言中可能需要循环论证而失去定义的意义。此处的条目内容（包括链接的外部定义）仅仅供参考，而不是精确的内涵和外延。为简化复杂度，限制自指定义的概念都是名词。</p>
<p><strong>示例</strong> 上述注释中，<strong>内涵</strong>和<strong>外延</strong>约定为以下<a href="#%E9%9D%9E%E8%87%AA%E6%8C%87">非自指</a>的概念，因此可依据本文档给出明确的定义来源。</p>
<p><strong>示例</strong> 在程序语言理论中，上下文(context) 指形式上可继续补充内容的构造；文档可能非形式地使用和这个含义相容的概念。</p>
<ul>
<li>实体(entity) ：任意被自然语言表达的目标；不需要通过自然语言先验定义；参见经验语义。</li>
<li>语义(semantics) ：参见经验语义。</li>
<li>经验(experience) ：参见哲学或一般等价的经验语义。</li>
<li>范畴(category) ：参见<a href="https://zh.wikipedia.org/zh-cn/%E8%8C%83%E7%95%B4%E8%AE%BA">范畴论</a>。</li>
<li>态射(morphism) ：参见范畴论。</li>
<li>归纳(induction) ：一种态射，可操作性参见经验语义。</li>
<li>方法学(methodology) ：一个归纳经验得到的范畴；参见哲学或一般等价的经验语义。</li>
<li>方法(method) ：方法学的一个子范畴；可操作性参见经验语义。</li>
<li>概念(concept) ：参见逻辑学。</li>
<li>上下文(context) ：一种概念范畴适用的态射；参见经验语义。</li>
</ul>
<h2 id="非自指"><a class="header" href="#非自指">非自指</a></h2>
<p>　　包含多个一般领域的概念。</p>
<ul>
<li><em>&lt;名词&gt;</em> 形式(form) ：参见经验语义和数学。</li>
<li><em>&lt;概念&gt;</em> 内涵：参见逻辑学。</li>
<li><em>&lt;概念&gt;</em> 外延：参见逻辑学。</li>
<li><em>&lt;概念&gt;</em> 定义(definition) ：确定概念内涵和外延的方法；参见任意一种形式逻辑学。</li>
<li><em>&lt;动词&gt;</em> 抽象(abstracting) ：通过经验语义定义概念范畴或集合的方法。</li>
<li><em>&lt;名词&gt;</em> 抽象(abstraction) ：<em>&lt;动词&gt;</em> 抽象的结果。</li>
<li><em>&lt;动词&gt;</em> 封装(encapsulating) ：从某一个范畴中抽象一个子范畴的方法。</li>
<li><em>&lt;名词&gt;</em> 封装(encapsulation) ：<em>&lt;动词&gt;</em> 封装的结果。</li>
<li>规范(specialization) ：一种提供在特定上下文中可定义的描述的封装，参见工程学（特别是软件工程学，下同）。</li>
<li>接口(interface) ：一种封装，参见工程学。</li>
<li>实现(implementation) ：一种封装，参见工程学。</li>
<li>重用(reusing) ：参见经验语义和工程学。</li>
<li>不变性(invariance) ：满足某种<a href="https://zh.wikipedia.org/zh-cn/%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB">等价关系</a>（自反、传递、对称的<a href="https://zh.wikipedia.org/zh-cn/%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB">二元关系</a>）。</li>
<li>不变量(invariant) ：具有不变性的实体。参见数学和契约式程序设计。</li>
<li>状态(state) ：可以和其它实体关联的、可在某个上下文中保持变化或不变的实体。同一状态总是保持变化或保持不变。状态变化的含义参见经验语义、数学或另行指定。
<ul>
<li>可变状态(mutable state) ：在某个上下文中满足以下条件的状态：
<ul>
<li>可能映射到超过一个其它状态。</li>
<li>存在对应的重新配置可变状态映射到不同的其它状态的<em>改变(mutate)</em> 操作。</li>
</ul>
</li>
<li>不可变状态(immutable state) ：不是可变状态的状态。</li>
</ul>
</li>
<li><em>&lt;动词&gt;</em> 派生(deriving) ：基于重用的操作。</li>
<li><em>&lt;名词&gt;</em> 派生(derivation) ：<em>&lt;动词&gt;</em> 派生的结果。</li>
</ul>
<h1 id="计算机科学"><a class="header" href="#计算机科学">计算机科学</a></h1>
<p>　　包含多个关于数学、逻辑学和计算机领域的概念。</p>
<ul>
<li><em>&lt;动词&gt;</em> 形式化(formalize) ：建立数学意义上的严格<a href="#%E9%9D%9E%E8%87%AA%E6%8C%87">形式</a>。</li>
<li><em>&lt;名词&gt;</em> 形式化(formalization) ：建立形式的过程。</li>
<li>形式方法(formal method) ：包含形式化的<a href="#%E8%87%AA%E6%8C%87">方法</a>。</li>
<li><em>&lt;动词&gt;</em> 建模(model) ：建立形式化输出的形式。</li>
<li><em>&lt;名词&gt;</em> 模型(model) ：建模的结果。</li>
<li>集合(set) ：一种数学模型，参见 <a href="https://zh.wikipedia.org/zh-cn/%E5%86%AF%E8%AF%BA%E4%BC%8A%E6%9B%BC-%E5%8D%9A%E5%86%85%E6%96%AF-%E5%93%A5%E5%BE%B7%E5%B0%94%E9%9B%86%E5%90%88%E8%AE%BA">NBG 集合论</a>。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E7%B1%BB_%28%E6%95%B0%E5%AD%A6%29">类</a>(class) ：参见 NBG 集合论和范畴论。</li>
<li>真类(proper class) ：参见 NBG 集合论和范畴论。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB">二元关系</a>(binary relationship) ：一种基于集合上定义的数学实体。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB">等价关系</a>(equivalence relationship) ：<a href="https://zh.wikipedia.org/zh-cn/%E8%87%AA%E5%8F%8D%E5%85%B3%E7%B3%BB">自反的(reflexive)</a> 、<a href="https://zh.wikipedia.org/zh-cn/%E5%AF%B9%E7%A7%B0%E5%85%B3%E7%B3%BB">对称的(symentric)</a> 且<a href="https://zh.wikipedia.org/zh-cn/%E4%BC%A0%E9%80%92%E5%85%B3%E7%B3%BB">传递的(transitive)</a> 二元关系。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB">偏序关系</a>(paritial order relationship) ：自反的、<a href="https://zh.wikipedia.org/zh-cn/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%85%B3%E7%B3%BB">反对称的(asymentric)</a> 且传递的的二元关系。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB">严格偏序关系</a>(paritial order relationship) ：<a href="https://zh.wikipedia.org/zh-cn/%E8%87%AA%E5%8F%8D%E5%85%B3%E7%B3%BB#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">反自反的(irreflexive)</a>、反对称的且传递的的二元关系。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E7%AD%89%E4%BB%B7%E7%B1%BB">等价类</a>(equivalence class) ：等价关系划分集合得到的类。</li>
<li>可计算性(computability) ：参见数学。
<ul>
<li>通常由 <a href="https://zh.wikipedia.org/zh-cn/%E9%82%B1%E5%A5%87%EF%BC%8D%E5%9B%BE%E7%81%B5%E8%AE%BA%E9%A2%98">Church-Turing 论题</a>定义。</li>
</ul>
</li>
<li>计算(computation) ：由可计算性定义的操作的等价类，可表现为特定的外在的行为(behavior) 。</li>
<li>计算模型(computation model) ：描述计算的模型，是对计算建模的结果。</li>
<li>序列(sequence) ：有序集合。</li>
<li>形式语义(formal semantics) ：使用形式化的方式表达的语义。</li>
<li>形式语言(formal language) : 特定形式化的方式确定的元素的全集。
<ul>
<li><strong>注释</strong> 这也可能作为<a href="#%E8%A7%84%E8%8C%83">语言规则</a>对应的某种形式语义。这同时是语言对应的<a href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">语法</a>的外延。</li>
</ul>
</li>
<li>计算复杂度(computational complexity) ：某个形式化计算模型中以有限的正整数作为模型决定的规模(metric) 作为参数的渐进(asymptotic) 性质确定的度量。
<ul>
<li>时间复杂度(time complexity) ：描述步骤规模的计算复杂度。</li>
<li>空间复杂度(space comlexity) ：描述存储规模的计算复杂度。</li>
</ul>
</li>
<li>并发(concurrency) ：计算的非确定性的(non-deterministic) 组合(composition) 的性质。
<ul>
<li>并发的(concurrent) ：已被并发方式组合的。</li>
</ul>
</li>
<li>并行(parallelism) ：确定性的(deterministic) 计算行为蕴含的可提升渐进效率(asymptotic efficiency) 而不改变计算预期的其它行为的性质。
<ul>
<li>并行的(parallel) ：已蕴含并行的。</li>
<li>可并行化的(parallelizable) ：允许改变而蕴含并行的。</li>
<li><strong>注释</strong> 渐进效率可使用渐进形式的复杂度描述。</li>
<li><strong>注释</strong> 一个表达渐进效率的具体例子是<a href="https://en.wikipedia.org/wiki/Big_O_notation">大 O 记号(en-US)</a> 。</li>
</ul>
</li>
<li>二进制(binary) ：实数的二进位制表示格式。</li>
</ul>
<h1 id="规范"><a class="header" href="#规范">规范</a></h1>
<p>　　包含提供<a href="#%E8%87%AA%E6%8C%87">规范</a>的<a href="#%E8%87%AA%E6%8C%87">实体</a>定义。</p>
<ul>
<li>符合性(conformance) ：满足规范的实现性质。</li>
<li>要求(requirement) ：规范对实现的作为判断符合性的条件。</li>
<li>约束(constraint) ：可被<a href="#%E9%9D%9E%E8%87%AA%E6%8C%87">形式</a>表达，用于限制和明确行为的规则。不一定使用形式表达。</li>
<li>违反(violation) ：对约束指定的条件的不满足。</li>
<li>过时的(obsolesent) ：已确认因为存在更合适的选项而建议不继续使用的（接口/特性）。</li>
<li>废弃的(deprecated) ：过时的但因为兼容性等原因，暂时保留的、一般可提供替代的接口或特性。</li>
<li>语言：<a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">模型</a>或者非形式地其它方式定义的一种<a href="#%E9%9D%9E%E8%87%AA%E6%8C%87">接口</a>。</li>
<li><em>&lt;语言&gt;</em> 接口(<em>&lt;language&gt;</em> interface) ：和表达<a href="#%E8%87%AA%E6%8C%87">语义</a>有关的语言的可见的特征。</li>
</ul>
<p>　　包含关于语言的规范的定义。</p>
<ul>
<li><em>&lt;语言&gt;</em> 实现(<em>&lt;language&gt;</em> implementation)：对语言规则中的要求的<a href="#%E9%9D%9E%E8%87%AA%E6%8C%87"><em>&lt;非自指&gt;</em> 实现</a>。</li>
<li><em>&lt;语言&gt;</em> 人类接口(human interface) ：语义仅对人类有意义（内容改变时可以导致语义的差异性），不提供为涉及作为计算模型实现的语言接口。</li>
<li><em>&lt;语言&gt;</em> 机器接口(machine interface) ：对机器（或特定语言实现的特定部分）有意义的语言接口。注意不同语言实现组成部分可以不同。
<ul>
<li><strong>示例</strong> 对 <a href="https://zh.wikipedia.org/zh-cn/C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8">C 语言的预处理器</a>，C 源代码中的空白符是机器接口，而对<a href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">翻译器</a>来说则不是。就源代码而言，机器接口总是人类接口的子集。</li>
</ul>
</li>
<li><em>&lt;语言&gt;</em> 特性(*&lt;language&gt; feature) ：作为功能提供的人类接口。</li>
<li>语言规则(language rule) ：约定可实现及应被实现的语言接口的描述，可包含语言特性的表达。</li>
<li>语言规范(language specialization) ：包含正式的(normative) 的语言规则的集合的<a href="#%E8%87%AA%E6%8C%87">规范</a>；或称语言规格说明。</li>
<li>语言实现(language implementation) ：语言提供的接口的实现，是语言的表现形式，可以是具体语言实现或抽象语言实现之一。
<ul>
<li>具体语言实现(concreate language implementation) ：能最终完全表达为可预测的物理现象一一对应的表达<a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">可计算性</a>的实现，一般应为程序。</li>
<li>抽象语言实现(abstract language implementation) ：非具体语言实现的语言实现。形式意义的标准定义的语言属于此类。</li>
</ul>
</li>
<li>派生语言实现(derived language implementation) ：派生已有实现的部分或全部得到的语言实现。以下简作“派生实现”。</li>
<li><em>&lt;语言&gt;</em> 实现环境(environment of implementation) ：对应特定语言实现的特定不变状态（对机器来说可以是配置项，对人来说不确定，所以一般忽略）的集合。</li>
<li><em>&lt;语言&gt;</em> 互操作(interoperation) ：不同的语言实现环境中发生的交互。</li>
<li><em>&lt;语言&gt;</em> 嵌入实现(embedded implemenation) ：在现有的其它语言实现上建立的可共享部分实现环境支持互操作的语言实现。</li>
<li>宿主语言(host language) ：提供嵌入实现的现有实现中使用的语言。</li>
<li>客户语言(guest language) ：嵌入实现中被宿主语言支持实现的语言。</li>
<li>未定义的(undefined) ：可能导致违反<a href="#%E8%87%AA%E6%8C%87">规范</a>的约束但语言规范同时没有要求提供任何可能影响<a href="#%E9%9D%9E%E8%87%AA%E6%8C%87">符合性</a>的保证（如具有诊断消息）的。
<ul>
<li><strong>注释</strong> 表示置于语言规则下的行为等不可预测。</li>
</ul>
</li>
<li>良定义的(well-defined) ：明确地非未定义的。</li>
<li>未指定的(unspecified) ：<a href="#%E8%87%AA%E6%8C%87">规范</a>隐式或显式地允许但不要求唯一确定的至少一个实现选项。
<ul>
<li><strong>注释</strong> 通常允许多种不同的选项；但在特定实现配置下，规则中未指定的选项也可被限制为只有一种可行的选项。</li>
<li><strong>注释</strong> 同一个实现或者不同实现可能确定地或非确定地选取不同的选项而不保证表现一致。</li>
</ul>
</li>
<li>由实现定义的(implementation-defined) ：取决于各个具体语言实现的，要求有文档说明。</li>
<li>由派生实现定义的(derived-implementation-defined) ：取决于各个派生语言实现的，要求除存在默认定义或被派生实现的部分有明确的文档说明。</li>
</ul>
<h1 id="程序设计语言"><a class="header" href="#程序设计语言">程序设计语言</a></h1>
<p>　　提供上下文 <em>&lt;程序设计语言&gt;</em> ，特别是语言规范的定义。</p>
<p>　　主要用例参见 <a href="Features/NPL.zh-CN.html">NPL</a> 。</p>
<ul>
<li>广义实体：<em>&lt;通用领域&gt;</em> 实体。语言抽象的目标，不另行定义（意义最终取决于自然语言）。</li>
<li>名称(name) ：一种特殊的可比较相等的广义实体，专用于和另一个的广义实体关联。</li>
<li><em>&lt;动词&gt;</em> 指称(denote) ：名称对广义实体的关联动作。</li>
<li><em>&lt;名词&gt;</em> 指称(denotation) ：被名称指称而关联的实体。</li>
<li>实体(entity) ：非名称的广义实体。</li>
<li>表示(representation) ：以一个符合某种形式的约束的实体指称另一个实体。</li>
<li>符号(symbol) ：<a href="#%E8%A7%84%E8%8C%83">语言规则</a>允许的不使用其它对象表示的对象。符号可实现名称。</li>
<li>字母表(alphabet) ：符号在语言中的全集。</li>
<li>串(string) ：可能重复出现的符号的有限序列。</li>
<li>文法(grammar) ：描述任意的可形式化的语言规则。</li>
<li>语法(syntax) ：以语言中的串作为基本元素，描述语言的字面(literal) 结构模式(pattern) 的语言规则，通常是文法的一部分。</li>
<li>语义(semantics) ：非语法的考虑逻辑上的释义(interpretation) 或含义(meaning) 的规则、原理和过程，通常可被语法以外的文法描述并可约束含义的表达。</li>
<li>实例(instance) ：具有代表性含义的集合的元素。</li>
<li>代码(code) ：任意有限的语言的实例片段组成的语法范畴。</li>
<li>伪代码(pseudo code)：抽象语言实现的语言的代码。
<ul>
<li><strong>注释</strong> 习惯上和具体语言实现代码完全一致的代码可以不作为伪代码考虑。</li>
</ul>
</li>
<li>程序(program) ：具体语言实现接受的以代码表示的输入，或被变换后对应的输出。</li>
<li>数据(data) ：程序处理的一般信息。
<ul>
<li><strong>注释</strong> 除以下的编码外，通常不直接作为代码处理。</li>
</ul>
</li>
<li>编码(encode) ：变换数据为确切格式的代码。
<ul>
<li><strong>注释</strong> 格式通常使用语言定义。</li>
</ul>
</li>
<li><em>&lt;名词&gt;</em> 编码(encoding) ：经编码得到的结果。
<ul>
<li><strong>原理</strong> 相对被编码的数据，因可预测格式，这可能更容易处理。因此，同时可能被视为数据。</li>
</ul>
</li>
<li>解码(decode) ：变换确切格式的代码为数据。
<ul>
<li><strong>注释</strong> 编码和解码可以是对应可逆的。</li>
</ul>
</li>
<li>行为(behavior) ：语言实现或在满足符合性的具体语言实现中的程序的外部表现。
<ul>
<li>基于可操作性考虑，一般仅约束实现的机器<a href="#%E9%9D%9E%E8%87%AA%E6%8C%87">接口</a>。</li>
<li><strong>注释</strong> 程序的行为是具体的<a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算行为</a>的实例。</li>
</ul>
</li>
<li>可观察行为(observable behavior) ：影响语言实现环境中外部的行为。
<ul>
<li><strong>注释</strong> 语言可通过在一般的行为上添加特定附加限制规定其具体外延。</li>
</ul>
</li>
<li>计算作用(computational effect) ：可被某个形式化计算模型描述的行为。</li>
<li>翻译(translation) ：不同语言的程序之间的变换，可作为语言实现的形式。
<ul>
<li><strong>注释</strong> 输入和输出具有相同表示的恒等变换不被视为翻译。</li>
</ul>
</li>
<li>IR（intermediate representation ，中间表示）：翻译过程中使用的和输入及输出都不同的表示。</li>
<li>翻译器(translator) ：实现翻译的程序。</li>
<li>运行(run) ：实现程序或组成程序的实体的行为的动作。</li>
<li>加载(load) ：运行程序或组成程序的实体时从实现环境取得相关实体的动作，可蕴含创建这些实体的副本或翻译其中的代码到特定形式。</li>
<li>执行(execute) ：处理程序或组成程序的实体，使这些实体或实体的副本作为资源被消费而蕴含这些实体被运行，同时可能蕴含消费实现环境的其它资源。
<ul>
<li><strong>注释</strong> 执行强调资源的消费，是运行的子集。资源被消费后不再可用。因此，除非同时蕴含资源的<em>再生(reclaim)</em> ，被执行的同一实体不预期被再次执行。再生资源包括实体加载时翻译或取得副本，及实现环境中补充的替代资源。</li>
</ul>
</li>
<li>解释(interpretation) ：通过不依赖显式指定的附加的程序翻译而直接运行表现行为的具体语言实现的形式。</li>
<li>解释器(interpreter) ：实现解释的程序。
<ul>
<li><strong>注释</strong> 解释器是翻译器的真子集。</li>
</ul>
</li>
<li>编译(compilation) ：通过依赖显式指定的附加的程序翻译而运行翻译的输出表现行为的具体语言实现的形式。
<ul>
<li><strong>注释</strong> 典型的编译以生成 IR 作为附加的程序翻译过程。</li>
</ul>
</li>
<li>编译器(compiler) ：实现编译的程序。
<ul>
<li><strong>注释</strong> 编译器是翻译器的真子集。</li>
</ul>
</li>
<li>源语言(source language) ：翻译的输入的语言。</li>
<li>目标语言(target language) ：编译的输出的语言。</li>
<li>转译器(transpiler) ：源语言和目标语言都能作为典型的源语言的翻译器。
<ul>
<li><strong>注释</strong> 或称为<strong>源到源翻译器(source-to-source translator)</strong> 。</li>
</ul>
</li>
<li>转译编译器(transcompiler) ：源语言和目标语言都能作为典型的源语言的编译器。
<ul>
<li><strong>注释</strong> 或称为<strong>源到源编译器(source-to-source compiler)</strong> 。</li>
<li><strong>注释</strong> 通常转译器需要明确的 IR ，所以都是转译编译器。</li>
</ul>
</li>
<li>源代码(source code) ：源语言编码的代码。</li>
<li><em>&lt;翻译&gt;</em> 目标代码(target code) ：目标语言编码的代码。</li>
<li>目标代码(code code) ：编译器输出的代码。
<ul>
<li><strong>注释</strong> 编译器输出的目标代码是翻译的目标代码的特例，一般具有<a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">二进制</a>编码。</li>
</ul>
</li>
<li>源程序(source program) ：形式为作为翻译的输入的源代码程序。</li>
<li>复杂度(complexity) ：以程序的规模作为参数的关于程序的直接执行的<a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算复杂度</a>。</li>
<li>元语言(metalanguage) ：描述其它语言的语言。</li>
<li>对象语言(object language)：被元语言操作或实现的语言。</li>
<li>元编程(metaprograming) ：使用元语言编程。</li>
<li>反射(reflection) ：元语言和对象语言相同的元编程。</li>
<li>具现(reification) ：在对象语言中以数据模型作为关联实体以表示程序的语义。</li>
<li>诊断(diagnostics) ：明确的对特定预期或非预期执行的行为的响应的总和。</li>
<li>诊断消息(diagnostic message) ：用于和用户交互的表现诊断的告知及提示。</li>
<li>未定义行为(undefined behavior) ：<a href="#%E8%A7%84%E8%8C%83">未定义的</a>行为。</li>
<li>良定义行为(well-defined behavior) ：<a href="#%E8%A7%84%E8%8C%83">良定义的</a>行为。</li>
<li>未指定行为(unspecified behavior) ：<a href="#%E8%A7%84%E8%8C%83">未指定的</a>行为。
<ul>
<li><strong>注释</strong> 由实现选取<a href="#%E8%A7%84%E8%8C%83">语言规范</a>中可能允许的指定行为的不确定选项，这些选项可能由显式或隐式的语言规则确定。</li>
<li><strong>注释</strong> 推论：由实现定义的行为是未指定行为。在本文档中，为最小化依赖，不在正式规则中明确这些关系。</li>
</ul>
</li>
<li>语言特性(language feature) ：语言提供的功能接口，可以是具体语言特性或抽象语言特性之一。</li>
<li>具体语言特性(concrete language feature) ：完全没有派生语言实现定义的语言特性。</li>
<li>抽象语言特性(abstract language feature) ：非具体语言特性的语言特性。</li>
<li>外部环境(external environment) ：和程序及被翻译的程序没有交集的和实现环境无关的状态。</li>
<li>外部表示(external representation) ：具有特定形式的用于和外部环境交互的表示。</li>
<li>内部表示(internal representation) ：非外部表示的表示。</li>
<li>外部编码(external encoding) ：程序和外部环境交互使用的编码。</li>
<li>内部编码(internal encoding) ：非外部的编码。</li>
<li>可编程性(programmability) ：允许使用程序提供实现的性质。</li>
<li>API（application programming interface ，应用程序编程接口）：提供可编程性以实现程序之间交互的接口。</li>
<li>ABI（application binary interface ，<a href="https://zh.wikipedia.org/zh-cn/%E5%BA%94%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8E%A5%E5%8F%A3">应用程序二进制接口</a>）：提供可编程性以实现二进制编码的程序之间交互的接口。
<ul>
<li><strong>注释</strong> ABI 可以是明确指定了二进制形式的程序之间的 API ，也可以是不依赖二进制编码实现的程序的 API 的实现细节。</li>
</ul>
</li>
</ul>
<h1 id="计算机体系结构"><a class="header" href="#计算机体系结构">计算机体系结构</a></h1>
<p>　　提供上下文 <em>&lt;计算机体系结构&gt;</em> ，特别是作为<a href="#%E8%A7%84%E8%8C%83">语言实现</a>补充的定义。</p>
<ul>
<li>指令(instruction) ：构成代码的具有有限的表示的基本单元，其表示一般具有<a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">二进制</a>编码。
<ul>
<li><strong>注释</strong> 指令序列可作为一种<a href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">目标代码</a>的形式，可实现<a href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">程序</a>。</li>
<li><strong>注释</strong> 典型地，指令是通过特定的机器的实现支持，即<em>机器指令(machine instruction)</em> 。这些机器可以是物理的(physical) 或虚拟的(virtual) 。一般物理的机器由特定的机器硬件直接提供指令功能实现的支持，而虚拟的机器指通过软件方式在其它硬件的基础上提供适配支持。</li>
</ul>
</li>
<li>指令集(instruction set) ：通过指令的集合提供<a href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">可编程</a>功能的<a href="#%E8%A7%84%E8%8C%83">接口</a>。
<ul>
<li><strong>注释</strong> 指令集是提供接口为目的设计的具有相近格式的指令构成的统一<a href="#%E8%87%AA%E6%8C%87">规范</a>，而非任意指令的集合。</li>
</ul>
</li>
<li>ISA（instruction-set architecture ，<a href="https://zh.wikipedia.org/zh-cn/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%A7%8B">指令集架构</a>）：依赖和蕴含特定指令集设计的程序之间交互的接口，包括指令集和<a href="#%E8%A7%84%E8%8C%83">实现环境</a>的相关假设。
<ul>
<li><strong>注释</strong> 实现环境假设可蕴含明确的 ABI 和指令集以外的配置。</li>
<li><strong>注释</strong> ISA 可作为<a href="#%E8%A7%84%E8%8C%83">具体语言实现</a>的一部分。</li>
<li><strong>注释</strong> ISA 可为特定的物理的或虚拟的机器设计，而不需要具有适应不同机器的<em>可移植性(potability)</em> 。</li>
<li><strong>注释</strong> 典型地，ISA 是软件实现<a href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">可编程性</a>的最底层次的<a href="#%E8%A7%84%E8%8C%83">机器接口</a>；更低层次的接口通常依赖不能被纯软件方式访问的机器实现细节。但这并非绝对。</li>
</ul>
</li>
<li>本机语言(native language) ：通过 ISA 直接支持的<a href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">目标代码</a>实现的语言。</li>
<li>地址(address) ：在实现中指定实体位置的<a href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">编码</a>。</li>
<li>地址空间(address space) ：映射到地址的操作中，地址的陪域(codomain) 。</li>
<li>寻址(addressing) ：在地址空间中确定实体关联的地址。</li>
<li>CPU（central processing unit，<a href="https://zh.wikipedia.org/zh-cn/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8">中央处理单元</a>) ：带有运算部件和控制部件，允许对物理计算资源寻址的物理 ISA 的通用实现。
<ul>
<li><strong>注释</strong> CPU 是 ISA 的主要实现。</li>
<li>物理的实现又称为中央处理器。强调具有<em>缓存(cache)</em> 时，又称为中央处理机。</li>
<li>除非另行指定，讨论特定的（物理）机器的体系结构时，默认指 CPU 支持的 ISA 。</li>
</ul>
</li>
<li>GPU（graphics processing unit，<a href="https://zh.wikipedia.org/zh-cn/%E5%9C%96%E5%BD%A2%E8%99%95%E7%90%86%E5%99%A8">图形处理单元</a>）：带有图形处理功能的物理 ISA 的专用实现。
<ul>
<li><strong>注释</strong> GPU 是非通用 ISA 的常见主要实现。</li>
<li>物理的实现又称为图形处理器或显示核心，因其主要以处理 2D/3D 图形计算而得名。</li>
<li>但 GPU 也能适用于比 CPU 更（计算时间和能效意义上）高效的特定计算任务，不一定和图形处理相关，即 <a href="https://zh.wikipedia.org/zh-cn/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%99%A8%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97">GPGPU</a> 。</li>
<li>为通用的计算加速的类似设备仍可能被称为 CPU ，即便其中没有<em>光栅化单元(rasterization unit)</em> 或最后用于输出的 ROP（<a href="https://zh.wikipedia.org/zh-cn/%E6%B8%B2%E6%9F%93%E8%BE%93%E5%87%BA%E5%8D%95%E5%85%83">渲染输出单元</a>，render output unit ），但保留了和<a href="https://zh.wikipedia.org/zh-cn/%E7%B9%AA%E5%9C%96%E7%AE%A1%E7%B7%9A">图形处理流水线</a>共用的物理部件，如支持<a href="https://zh.wikipedia.org/zh-cn/%E7%9D%80%E8%89%B2%E5%99%A8"><em>着色器(shader)</em></a> 的硬件实现。</li>
</ul>
</li>
</ul>
<h1 id="项目管理"><a class="header" href="#项目管理">项目管理</a></h1>
<p>　　提供上下文 <em>&lt;项目&gt;</em> 。</p>
<p>　　主要用例参见版本库中的项目文档 <code>doc/ProjectRules.txt</code> 。</p>
<ul>
<li>构建(build) ：通过确定的规则生成预设项目产出的动作。
<ul>
<li><strong>注释</strong> 典型地，包括从源代码翻译得到程序的过程。</li>
</ul>
</li>
<li>涉众(skateholder) ：项目关联的各方的主体。</li>
<li>角色(role) ：依据项目过程中起到的作用，对项目涉众实行一些附加归类。
<ul>
<li><strong>注释</strong> 项目的角色同时可用于项目阶段的描述中。</li>
</ul>
</li>
<li>用户(user) ：使用项目输出的项目涉众。</li>
<li>维护者(maintainer) ：决定项目中各个部分的内容的用户。
<ul>
<li><strong>注释</strong> 维护者可参与和维护部分相关的项目决策。</li>
</ul>
</li>
<li>开发者(developer) ：参与程序库和开发工具的功能修改的用户。
<ul>
<li><strong>注释</strong> 开发者可参与公开的构建过程以完成这些修改。</li>
</ul>
</li>
<li>最终用户(end user) ：独立为项目过程的用户。
<ul>
<li><strong>注释</strong> 最终用户可以不参与提前(ahead-of-time) 构建的项目过程。基于认知需求的差异可能需要从一般用户中单独区分。</li>
</ul>
</li>
</ul>
<h2 id="依赖管理"><a class="header" href="#依赖管理">依赖管理</a></h2>
<p>　　项目管理的客体被分解为特定关联的依赖项。任意两个依赖项之间存在<a href="https://zh.wikipedia.org/zh-cn/%E5%8F%8D%E5%AF%B9%E7%A7%B0%E5%85%B3%E7%B3%BB">反对称</a>和<a href="https://zh.wikipedia.org/zh-cn/%E4%BC%A0%E9%80%92%E5%85%B3%E7%B3%BB">传递</a>的<a href="https://zh.wikipedia.org/zh-cn/%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB">二元关系</a>称为<strong>依赖关系</strong>。<strong>严格依赖关系</strong>是反自反的依赖关系。</p>
<p>　　依赖项和依赖项之间的严格依赖关系统称为<em>依赖(dependency)</em> 。</p>
<h3 id="依赖引用"><a class="header" href="#依赖引用">依赖引用</a></h3>
<p>　　因为依赖关系的传递性，多个依赖关系可能存在无法满足严格依赖关系的情形，即<em>循环依赖(cyclic dependency)</em> 。这导致以确定的顺序解析依赖不可行，增加维护成本。</p>
<p>　　为了避免一定层次上的循环依赖，以该层次内组件为顶点的依赖关系的关系图应明确组织为有向无环图。
在最简单情况下依赖关系可退化为线性顺序依赖。</p>
<h3 id="内部依赖和外部依赖"><a class="header" href="#内部依赖和外部依赖">内部依赖和外部依赖</a></h3>
<p>　　项目中的组成部分之间的依赖称为<strong>内部依赖</strong>，其它依赖为<strong>外部依赖</strong>。</p>
<h2 id="源代码"><a class="header" href="#源代码">源代码</a></h2>
<p>　　<a href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源代码</a>用于生成指定目标代码。</p>
<p>　　通常源代码以文件形式保存，即<em>源代码文件(source code file)</em> ，简称<em>源文件(source file)</em> 。</p>
<h2 id="版本库"><a class="header" href="#版本库">版本库</a></h2>
<p>　　项目使用的<em>版本控制系统(version controlling system)</em> 具有<em>存储库(repository)</em> 作为持久存储实体，即版本库。</p>
<p>　　当前使用的主要版本控制系统为 <a href="https://www.mercurial-scm.org/">Mercurial</a> 。因为是分布式版本控制，也用于直接分发源代码。</p>
<p>　　每个文件系统上存储的版本库实例中，<code>.hg</code> 目录存储版本库元数据。</p>
<h1 id="设计和模型"><a class="header" href="#设计和模型">设计和模型</a></h1>
<h2 id="环境"><a class="header" href="#环境">环境</a></h2>
<p>　　程序中的某一部分的外界称为<strong>环境(environment)</strong>。根据限定程序的范围，可以有更确切的定义，如<a href="#%E8%A7%84%E8%8C%83">实现环境</a>（对一类语言实现而言）、运行时环境（对共享实现环境的一类程序而言）。</p>
<p>　　一般地，实现环境可以分为<em>独立环境(freestanding environment)</em> 和<em>宿主环境(hosted environment)</em> ，区分依据为是否依赖宿主（对部署在单一计算机上的实现，一般指操作系统）的支持。因此，环境有时指操作系统及其提供的外部服务的集合。</p>
<p>　　一些语言，如 ISO C 和 ISO C++ ，可以同时支持宿主环境和独立环境的实现，对应<em>独立实现(freestanding impementation)</em> 和<em>宿主实现(hosted impementation)</em> 。</p>
<p>　　<em>构建系统(build system)</em> 是环境中包含语言实现的自动执行<a href="#%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86">构建</a>任务的系统，包含一个或多个完成构建任务的工具<a href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">程序</a>即<em>构建程序(build program)</em> 。一般地，构建系统被<a href="#%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86">开发者</a>使用，<em>开发环境(development environment)</em> 包含构建系统。</p>
<p>　　程序构建使用的环境是<em>构建环境(build environment)</em> 。程序运行使用的环境是<em>运行时环境(runtime environment)</em>，简称<em>运行环境</em>。</p>
<p><strong>注释</strong> 最终用户也可能是开发者，或有构建需求的非开发者，因此也可能使用部署到运行环境中的构建系统。</p>
<h2 id="平台"><a class="header" href="#平台">平台</a></h2>
<p>　　环境中决定程序适用环境的被依赖的特定资源集合称为<strong>平台环境(platform environment)</strong>，简称<strong>平台(platform)</strong>。平台的典型例子有：</p>
<ul>
<li>运行时支持的 <a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">ISA</a> 。</li>
<li>操作系统和 <a href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">ABI</a> 。</li>
</ul>
<p>　　平台的内涵是资源的集合，其构成并非任意。构成平台的特定准则应使之保持相对的稳定和可预期，即可配置；即平台是名义的(nominal) 可配置的资源集合。</p>
<p>　　若平台包含的资源是已知的，则不需要平台的观念，分析其资源子集（即便不构成平台）即可解决几乎平台抽象涉及的所有技术问题（同时这也是定义一个具体平台的基础）。但在简化资源集合的全局性质分析（如比较资源配置方案）和名义抽象以隐藏实现（如为开发者提供预设环境集合）的应用角度上，平台仍有被单独讨论的意义。</p>
<h3 id="兼容性和可移植性"><a class="header" href="#兼容性和可移植性">兼容性和可移植性</a></h3>
<p>　　若一个依赖项对应的平台可以替换，则此依赖项和此平台<em>兼容(compatible)</em> 。<strong>兼容性(compatibility)</strong> 是平台兼容的二元关系。兼容性不是一种<a href="https://zh.wikipedia.org/zh-cn/%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB">等价关系</a>，因为不保证传递。</p>
<p>　　替换平台的过程称为<em>移植(porting)</em> 。移植的可行性称为<strong>可移植性(portability)</strong> 。</p>
<p>　　兼容任意平台的依赖项被称为是<em>平台中立(platform-neutral)</em> 的。</p>
<p>　　当平台中立的依赖项的依赖能被自动满足而不需要考虑时，是<em>平台无关(platform-independent)</em> 的。平台中立<a href="https://zh.wikipedia.org/zh-cn/%E5%AE%9E%E8%B4%A8%E6%9D%A1%E4%BB%B6">实质蕴含</a>平台无关。</p>
<h3 id="运行平台"><a class="header" href="#运行平台">运行平台</a></h3>
<p>　　一般的程序可涉及以下类型的平台：</p>
<ul>
<li>宿主平台(host platform) ：程序被<a href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">运行</a>的平台是程序的宿主平台。</li>
<li>目标平台(target platform) ：程序运行目标支持的平台。
<ul>
<li>除非另行指定，目标平台同程序的宿主平台。</li>
<li><strong>注释</strong> 例如，对一个<a href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">翻译器</a>，可以指定目标平台是其输出的程序支持运行目标的平台。</li>
</ul>
</li>
</ul>
<p>　　<em>本机平台(native platform)</em> 是通过<a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">本机语言</a>实现而不需附加翻译的运行平台。</p>
<p><strong>原理</strong></p>
<p>　　目标平台通常和宿主平台一致。指定目标平台的理由是，存在最终不一定在宿主平台上运行的程序，其运行的环境可能需要宿主平台不保证支持的特性，这典型地包括：</p>
<ul>
<li>构建的程序自身是生成其它程序的程序，如编译器和链接器。这些程序生成的平台是目标平台，不需要和它们的宿主平台相同。</li>
<li>构建的程序可以在宿主平台上运行，但在其它平台上具有更完全的特性集。后者被作为目标平台。</li>
</ul>
<p><strong>注意</strong> 此处的宿主平台具有相对意义，不一定脱离被运行的目标平台。一个宿主平台通常自身是宿主实现平台，但这点不被保证。</p>
<p>　　总是指定存在目标平台可简化<a href="#%E6%A8%A1%E6%8B%9F%E5%92%8C%E4%BB%BF%E7%9C%9F">适配不同平台的描述</a>。</p>
<h3 id="依赖和外延"><a class="header" href="#依赖和外延">依赖和外延</a></h3>
<p>　　若平台之间不出现平台的实现（如开发语言的实现）和环境自身的相互依赖，则这些平台相互<em>独立(independent)</em> 。总是保持相互独立的一组平台称为<em>独立平台(independent platforms)</em> 。每一组独立平台保证可以相对于其它独立平台分离开发和测试。</p>
<p>　　注意以上术语和 ISO C 和 ISO C++ 定义的<em>宿主实现(hosted implementation)</em> 和<em>独立实现(freestanding implementation)</em> 的关联和区别。</p>
<p>　　对<a href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">编译器</a>，若<a href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">编译</a>输出的程序代码被宿主平台支持运行，其目标平台即被视为和宿主平台一致，称为<em>本机编译(native build)</em> ；否则，称为<em>交叉编译(corss build)</em> 。</p>
<p>　　对<a href="#%E7%8E%AF%E5%A2%83">构建系统</a>的典型的应用场景，多个<a href="#%E7%8E%AF%E5%A2%83">构建程序</a>可能具有不同的<a href="#%E8%BF%90%E8%A1%8C%E5%B9%B3%E5%8F%B0">运行平台</a>集合。为简化统一的描述，约定以下类型的平台：</p>
<ul>
<li>构建平台(build platform) ：运行初始的构建程序的<a href="#%E8%BF%90%E8%A1%8C%E5%B9%B3%E5%8F%B0">宿主平台</a>。
<ul>
<li><strong>原理</strong> 无论是否可构建成功，对一个构建系统，构建平台应当总是存在。以进入构建系统作为基准，可有效避免对其它平台的依赖。</li>
</ul>
</li>
<li>宿主平台：运行构建平台输出代码的平台。</li>
<li>目标平台：运行最终目标代码的平台。</li>
<li><strong>注释</strong> 若构建系统的输出是一个编译器，则构建系统的宿主平台和目标平台同这个编译器的宿主平台和目标平台。</li>
</ul>
<p>　　若宿主平台和构建平台一致，称为<em>本机构建(native build)</em> ；否则，称为<em>交叉构建(corss build)</em> 。</p>
<p><strong>注释</strong></p>
<p>　　本机构建和交叉构建通过初始的构建程序的<a href="#%E8%BF%90%E8%A1%8C%E5%B9%B3%E5%8F%B0">宿主平台</a>是否和<a href="#%E8%BF%90%E8%A1%8C%E5%B9%B3%E5%8F%B0">目标平台</a>相同确定，而和输出无关。这和交叉编译比较宿主平台和目标平台不同。</p>
<p>　　通常构建系统在本机构建时提供对构建平台的检查以确定自身是否能够运行；交叉构建环境需要显式指定。</p>
<p>　　编译器可能隐含地支持交叉编译（如 GCC ），也可能需要显示指定目标平台（如 LLVM ）。</p>
<h3 id="模拟和仿真"><a class="header" href="#模拟和仿真">模拟和仿真</a></h3>
<p>　　<strong>模拟(emulation)</strong> 指适配和运行为不同平台设计的程序，广义上包括以下两类：</p>
<ul>
<li>环境模拟(environment emulation) ：使用<em>模拟器(emulator)</em> 或<em>虚拟机(virtual machine)</em> 等作为宿主平台的程序，模拟<a href="#%E7%8E%AF%E5%A2%83">运行环境</a>的通用解决方案。</li>
<li>程序模拟(program emulation) ：直接以运行时环境适配层嵌入宿主平台运行时，在具体程序中提供类似被模拟的目标平台的具体特性和接口。</li>
</ul>
<p>　　运行模拟程序的环境和被模拟环境分别是宿主平台和目标平台。</p>
<p>　　虚拟机在这个意义下是广义的模拟器中对<a href="#%E8%A7%84%E8%8C%83">机器接口</a>提供支持的子集，一般和其余的模拟器分别对待。</p>
<p>　　环境模拟和程序模拟的主要差异为是否独立的、专用的宿主平台程序作为中介以维护目标平台和宿主平台的隔离。</p>
<p>　　在一般意义上，<strong>仿真(simulation)</strong> 指对需要分析的问题建立的<a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">模型</a>的过程、方法和机制，在软件工程以外也被称为模拟，如计算机模拟(computer simulation) 。对于以计算机系统为目标的仿真，建立的模型可以是具体的实物（包括硬件和软件），称为<em>仿真器(simulator)</em> 。以软件接口为主要操作方式实现的仿真器同时实现了环境模拟，但侧重不同：精确重现需要分析行为，而非实用的功能等价性和体系中的可替换性。</p>
<h3 id="平台配置"><a class="header" href="#平台配置">平台配置</a></h3>
<p>　　实际的平台实现可能复用部分实现，配置之间可存在某种构成依赖关系的<a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">偏序关系</a>（如继承关系）。这些在项目中所有被配置的平台称为<em>公共平台(common platform)</em> ，其中能对应生成输出的称为<em>具体平台(concrete platform)</em> ，否则为<em>抽象平台(abstract platform)</em> 。</p>
<p>　　对一个平台配置，程序可提供更多的子配置共用现有的相同的配置。子配置可继续对平台特性具体特化，而对原始配置的用户程序隐藏细节。</p>
<p>　　普遍适用于一般功能配置也可被作为平台配置的一部分而作为子配置。</p>
<p><strong>注释</strong> 例如，多线程和非多线程版本、调试和非调试版本可作为平台配置的功能子配置。</p>
<p><strong>原理</strong> 尽管功能配置提供的特性可能是普遍的，但它的实现依赖的特性不都在每个平台中存在，而可能需要一定程度的模拟和仿真，或可选地提供部分特性。提供功能子配置可把这些特性作为次要的实现细节，和原始的平台上的更显著特性隔离。</p>
<p>　　若存在这样的子配置，应当满足：</p>
<ul>
<li>这些子配置应当在每个部署的用户程序的依赖中保持唯一，即一个环境中不能同时依赖不同的子配置的程序映像。
<ul>
<li><strong>原理</strong> 这样不但不需要保持子配置之间的 <a href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">ABI</a> 兼容性，同时 <a href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 也可以存在不兼容（而不仅仅是调试符号等附加元数据的差异）。</li>
</ul>
</li>
<li>相应地，依赖不同子配置的用户程序也具有对应的子配置。用户程序可以仅提供其中的部分子配置的程序映像。
<ul>
<li><strong>原理</strong> 对每个子配置需要提供单独的依赖路径以避免冲突，因此一般不能在同一个部署中直接复用不同子配置的程序映像。为了避免不必要的资源占用，支持用户程序仅提供部分子配置（而非所有子配置的映像）是必要的。</li>
</ul>
</li>
<li>除非另行指定，被复用的公开库的程序名称在不同子配置中应当存在差异。
<ul>
<li><strong>原理</strong> 尽管不会同时被一个用户程序依赖，每个部署中，不同的子配置的程序映像通常仍需共存。在名称上要求差异允许文件系统直接支持这种策略。</li>
</ul>
</li>
</ul>
<h3 id="平台标识"><a class="header" href="#平台标识">平台标识</a></h3>
<p>　　不同平台可以标识符加以区分。由于平台受到不同环境因素决定的正交性，通常此类标识符可以分解为表示这些正交环境的标识符的元组形式，用 <code>-</code> 等字符分隔。</p>
<p>　　一种常用的方式是 GNU <a href="#%E7%8E%AF%E5%A2%83">构建系统</a>的<a href="https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.69/html_node/System-Type.html#System-Type">系统类型</a>，经典表示方式为三元组(triplet) ，或其省略形式：</p>
<ul>
<li>一般包括体系结构(architecture) 、系统厂商(system vendor) 和系统软件环境。</li>
<li>第一项不可省略，之后的项可省略。</li>
</ul>
<p>　　其中：</p>
<ul>
<li>体系结构一般指定 <a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">CPU</a> 要求的最小 <a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">ISA</a> 。</li>
<li>系统厂商指集成平台的环境厂商。</li>
<li>系统软件环境保证满足 <a href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">ABI</a> 要求，可以包含操作系统及<a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">本机语言</a>运行时实现的名称。</li>
<li>通过<em>工具链(toolchain)</em> 等<a href="#%E8%A7%84%E8%8C%83">具体语言实现</a>构建时环境确定的程序依赖项是系统库(system library) ，是系统软件环境的一部分。
<ul>
<li>系统库可能被作为<a href="https://www.gnu.org/licenses/gcc-exception-3.1-faq.html">特定许可证例外</a>涵盖的范围。
<ul>
<li>详见 <a href="http://www.gnu.org/licenses/gpl.html">GNU GPLv3</a> 的 <a href="http://www.gnu.org/licenses/gpl-faq.html#SystemLibraryException">system library exception</a> 中的 system library 定义。</li>
</ul>
</li>
<li><strong>注释</strong> 系统库一般是特定平台或操作系统提供运行时支持的、由特定第三方环境提供开发支持的<a href="#%E5%86%85%E9%83%A8%E4%BE%9D%E8%B5%96%E5%92%8C%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96">外部依赖</a>，例如提供特定平台的 ISO C++ 标准库部分实现的 libstdc++ 和提供 Windows API 实现的 GDI32 等。</li>
<li>被分发的程序源代码可能仅依赖不受到许可证影响的、公开的接口规范（如<a href="#%E8%A7%84%E8%8C%83">语言规范</a>），而不直接依赖实现，而不构成版权法意义的衍生作品，但同时构建的二进制程序可以依赖二进制的系统库。</li>
</ul>
</li>
</ul>
<p>　　确定为<a href="#%E7%8E%AF%E5%A2%83">宿主环境</a>时，系统软件同时指定操作系统和运行时环境而拆分为两项，三元组扩充为四元组，如 <a href="https://wiki.gentoo.org/wiki/CHOST">Gentoo 使用的 CHOST</a> 。</p>
<p>　　在不够充分体现平台的必要差异（尤其是体系结构相关的配置）时也可通过自行定义标识符并指定与三元组的对应关系，如 <a href="https://wiki.debian.org/Multiarch/Tuples">Debian multiarch</a> 。</p>
<p>　　系统类型用来提供一定程度的兼容（替换和<a href="#%E8%A7%84%E8%8C%83">互操作</a>）：</p>
<ul>
<li>系统类型代表了系统厂商的预设的配置集合，因此可提供符合相对上的（事实）标准的构建和运行环境。</li>
<li>这种兼容性有时会被过度依赖，乃至被误认为完全的 ABI 兼容：
<ul>
<li>系统类型不保证涵盖所有 ABI 细节，满足相同的系统类型的程序实例之间不一定符合完全相同的 ABI 而可相互替换或互操作，即原则上即不保证完全的 ABI 兼容。
<ul>
<li><strong>原理</strong> 实现的差异原则上不适合或无法通过系统类型区分。否则，系统类型事实上需要任意地长以涵盖不同细节，而会导致程序部署环境的碎片化，使维护兼容性的原始目的失去主要意义。</li>
</ul>
</li>
<li>一个主要实例：不同构建工具链生成的二进制程序之间不总是保证完全的 ABI 兼容：即便程序代码不改变，工具链生成的二进制代码之间也不保证可互操作即确保<em>二进制兼容性(binary compatibility)</em> 。
<ul>
<li>同一个版本的同一工具链通过某些构建选项即可能构建出不能保证 ABI 兼容的二进制程序映像。
<ul>
<li>例如，GCC 使用 <code>-m</code> 前缀选项可能影响 ABI 。</li>
</ul>
</li>
<li>即便使用工具链发行版固定的默认预设选项，不同版本工具链在设计上不能完全保证二进制兼容性。
<ul>
<li>例如，为兼容 ISO C++11 中关于 <code>std::basic_string</code> 和 <code>std::list</code> 等 <a href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">API</a> 改动，GCC 5 显式提供<a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_dual_abi.html">不同的 ABI 配置</a> 而在支持这些改动的配置上[放弃对原有 libstdc++ 的 ABI 兼容保证。</li>
</ul>
</li>
</ul>
</li>
<li>相同的系统类型可以对应不同的依赖集合，已被作为实用的维护兼容性的方法。
<ul>
<li>这种差异通常隐藏在系统库之下，此时提供不同的二进制兼容映像可以在部署时对依赖系统库的程序隐藏这些差异。</li>
</ul>
</li>
<li><strong>注释</strong> 现代 Microsoft Windows（基于 Windows NT 执行体）是应用包括这类兼容性在内的多种策略的一个典型实例：
<ul>
<li>隐藏二进制差异的主要实例是 Microsoft Windows NT 的 Win32 和 <a href="https://zh.wikipedia.org/zh-cn/%E5%BE%AE%E8%BD%AFPOSIX%E5%AD%90%E7%B3%BB%E7%BB%9F">POSIX 子系统</a>，用户程序通过链接到不同的子系统 DLL ，可共享上层 ABI 。</li>
<li><a href="https://www.cygwin.com/">Cygwin</a> 是一个类似的 POSIX 子系统替代实现，其用户程序当前默认依赖系统库 <code>cygwin1.dll</code> 。</li>
<li>Windows Subsystem for Linux (WSL) 则不是这种兼容性的实例。
<ul>
<li>因为映像格式的差异，它的用户空间程序使用的系统类型更接近 x86_64-pc-linux（具体系统类型取决于安装的发行版；典型地是 x86_64-pc-linux-gnu ）。</li>
<li>部署 WSL 环境需要涉及一整套不同系统类型的二进制映像，仅在子系统的内部实现存在（对 Windows NT 执行体而言的）隐藏实现差异的情形。</li>
</ul>
</li>
<li>不涉及子系统但同样通过 DLL 隐藏二进制的实例是隐藏系统库的版本差异：不同版本的 C 运行时(CRT) 和 Microsoft VC++ 运行时库可以在一个 Windows 系统实例中共存。
<ul>
<li>特别地，MSVCRT 和 UCRT 作为不同的 CRT ，可在同一个系统映像中安装，并作为同一个系统类型的不同实现提供。</li>
<li>同时，不同的 CRT 可具有不同的工具链支持。</li>
<li>不同版本的运行时中每个子配置（多线程和非多线程版本、调试和非调试版本）共用相同的配置，在此不视为存在差异。</li>
<li>CRT 的多版本部署和其它一些系统中 libc 显式影响系统类型不同。
<ul>
<li><strong>原理</strong> 尽管同样是作为语言实现的一部分部署的系统库（至少在通常以此<a href="https://www.gnu.org/licenses/gcc-exception-3.1-faq.html">为由</a>取得<a href="https://www.gnu.org/licenses/gcc-exception-3.1.html">许可证豁免</a>的意义上），仅有后者通常是影响整个系统部署的库，而不适合通过相同的系统类型提供二进制不兼容的版本。否则，这会使整个系统中的几乎所有二进制程序映像之间都不具有二进制兼容性，而无法通过<a href="https://en.wikipedia.org/wiki/Dynamic_linker#Implementations">通常的机制</a>共享二进制代码。</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://www.msys2.org/docs/environments/MSYS">MSYS2 提供的不同环境</a> 是体现上述所有各种不同兼容性方式的一个复杂实例。
<ul>
<li>其中，MSYS2 环境基于 Cygwin ，是通过类似子系统 DLL 部署的兼容层，其用户程序当前默认依赖系统库 <code>msys-2.0.dll</code> 。</li>
<li>其余环境被视为原生的 Win32 应用，使用 Win32 子系统。按体系结构归类分组，每一组内可存在原生的共用相同系统类型的不同实现。
<ul>
<li>例如，<code>/mingw64</code> 、<code>/clang64</code> 和 <code>/ucrt64</code> 中部署的二进制程序共享系统类型 <code>x86_64-w64-mingw32</code> 。</li>
<li>其中 <code>/mingw64</code> 中的程序依赖的 CRT 和另两种共享 <code>x86_64-w64-mingw32</code> 的环境不同，而 <code>/clang64</code> 中的程序依赖的 C++ 运行时库也和另两种环境不同。</li>
</ul>
</li>
</ul>
</li>
<li>上述的这些配置仍然没有穷尽系统库的 ABI 的差异。
<ul>
<li>例如，GCC 工具链中预设了<a href="https://github.com/FrankHB/pl-docs/blob/master/zh-CN/mingw-vs-mingw-v64.md">无法保证 ABI 相互兼容的不同异常处理和线程模型</a>（每个不同的模型同时可需要部署不同的 DLL 作为系统库依赖）。</li>
</ul>
</li>
<li>包括上述 MSYS2 中的每个环境的使用 GCC 的不同发行版都预设了具体的内部依赖，如：
<ul>
<li>MSYS2 中，<code>x86_64-w64-mingw32</code> 环境使用 SEH 异常处理模型，其用户程序当前默认依赖系统库 <code>libgcc_s_seh-1.dll</code> 。</li>
<li>MSYS2 中，<code>i686-w64-mingw32</code> 环境使用 Dwarf2 线程处理模型，其用户程序当前默认依赖系统库 <code>libgcc_s_dw2-1.dll</code> 。</li>
<li>一些发行版如 <a href="https://github.com/niXman/mingw-builds">MinGW-builds</a> 默认使用 SjLj 异常处理模型，其用户程序当前默认依赖系统库 <code>libgcc_s_sjlj-1.dll</code> 。</li>
<li>MSYS2 和大多数其它 <a href="https://www.mingw-w64.org/">MinGW-w64</a> 发行版中长期使用 POSIX 线程模型提供较完善的 C++ 标准库线程特性实现，当前使用 <a href="https://www.mingw-w64.org/#headers-libraries-and-runtime">winpthreads</a> ，其用户程序当前默认依赖系统库 <code>libwinpthread-1.dll</code> 。</li>
<li>预期可在现代环境中替代 <a href="https://www.mingw-w64.org/contribute/#mcfgthread">winpthreads</a> 的 <a href="https://github.com/lhmouse/mcfgthread">mcfgthread</a> 对<a href="https://gcc.gnu.org/pipermail/gcc-patches/2022-October/602704.html">上游的修改已被讨论</a>，使用新的线程模型 <code>mcf</code> ，其用户程序会依赖不同的系统库。</li>
</ul>
</li>
<li>实现系统库时，可依赖非系统库 API 。通常，系统库可直接在运行时依赖 Windows NT 执行体。系统库之间也可存在其它单向的内部依赖。这些情形下，系统库自身不是符合环境要求的程序。
<ul>
<li>例如，mcfgthread 依赖非 Win32 API ，自身不是严格意义的 Win32 程序（尽管构建时仍在运行于 Win32 子系统的假定下链接）。</li>
<li>POSIX 子系统依赖 Win32 系统。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>为了避免兼容性保证过程的复杂性，除非另行指定，关于系统类型：
<ul>
<li>可标识通过源代码部署的单一配置。构建支持和其它外部环境应当被文档明确。</li>
<li>避免认为其它形式部署的唯一依据。特别地，支持可共享相同二进制部署的<a href="#%E5%B9%B3%E5%8F%B0%E9%85%8D%E7%BD%AE">平台子配置</a>。</li>
</ul>
</li>
</ul>
<p>　　除非另行指定：</p>
<ul>
<li>本项目的平台定义不依赖具体的标识，但文档描述使用和三元组兼容的方式指定平台标识的基本形式。
<strong>原理</strong> 这在设计上避免对具体的平台标识的表示方式的接口依赖。因为系统厂商不一定具有相同的约定，且并非总是存在一种最优的选择，使用具体方式唯一地描述平台既无法保证描述清楚所有必要的细节（而足以确保兼容性），也不利于可移植性；更重要地，实际上和平台中立的目的矛盾。但是，默认的实现仍然遵循通行的规则和约定，可以减少实现和用户使用上的复杂性。
<strong>注释</strong> 一个例子是 GNU 和 LLVM 工具链使用不同的方式提供三元组；此外，有的实现提供四元组。详见以下的说明。</li>
<li>若同一个平台配置存在多个不同的标识符，默认使用以下规则确定：
<ul>
<li>对使用 MinGW-w64 实现的工具链，使用<a href="https://sourceforge.net/p/mingw-w64/wiki2/TypeTriplets/">工具链定义的三元组</a></li>
<li>否则，使用 <a href="https://savannah.gnu.org/projects/config">GNU config</a> 的最新版本中指定的标识符。
<ul>
<li>即 <a href="https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD"><code>config.guess</code></a> 和 <a href="https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD"><code>config.sub</code></a> 脚本。</li>
</ul>
</li>
<li><strong>注意</strong> <a href="https://sourceforge.net/p/mingw-w64/mingw-w64/ci/master/tree/mingw-w64-doc/howto-build/mingw-w64-howto-build-adv.txt">MinGW.org 和 MinGW-w64 都使用 <code>mingw32</code> 而非 <code>mingw64</code></a> ，这和 GNU guess 不同。
<ul>
<li>MinGW-w64 的源代码中仅有<a href="https://www.msys2.org/docs/environments/">环境路径前缀</a> 和 GNU config 的代码使用 <code>mingw64</code> 。</li>
<li>GCC 可接受 <code>mingw*</code> 而忽略其中的差异，但通常并不使用 GNU config 的 <code>mingw64</code> 配置 GCC。
<ul>
<li>因此这里的标识符能和 <code>gcc -v</code> 的结果中的 <code>Target:</code> 结果兼容。</li>
</ul>
</li>
<li>应当避免<a href="https://github.com/msys2/MINGW-packages/issues/8020">可能存在的混淆</a>。</li>
</ul>
</li>
<li><strong>注释</strong> <code>config.guess</code> 支持更一般的输入，包含 1 到 4 个部分，规格化为三元组 <code>CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM</code> 或四元组 <code>CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM</code> 。
<ul>
<li>前两个部分是机器类型，其中的厂商仅指制造商。如 <code>i686-w64-mingw32</code> 中的 <code>w64</code> 实际上不符合其含义。</li>
<li>最后或后两个部分是操作系统，实际包含操作系统和 C 运行时实现的 ABI（可选），即 <code>&lt;kernel&gt;-&lt;libc&gt;</code> 或 <code>&lt;kernel&gt;-&lt;abi&gt;</code> 。
<ul>
<li><a href="#%E7%8E%AF%E5%A2%83">独立实现</a>的 ABI 配置也被视为操作系统，如 <code>eabi</code> 和 <code>gnueabi</code> 。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>注释</strong> 通常不使用 <a href="https://clang.llvm.org/docs/CrossCompilation.html#target-triple">Clang 的三元组</a>。
<ul>
<li><strong>原理</strong> 尽管形式上更清晰，<code>&lt;sys&gt;-&lt;abi&gt;</code> 的划分实际使之成为四元组而非三元组，这种明确划分不总是符合现实的复杂需求。
<ul>
<li>这在关于 ABI 兼容的不明确性和歧义更加显著。这类不一致对适配更多不在现有清单上的平台更加困难，特别是未指定 <code>&lt;vendor&gt;</code> 时。
<ul>
<li><strong>注释</strong> 一个歧义的例子：<code>gnu</code> 在 Linux 上特指 glibc ，而在 Windows 上却指 libstdc++ 代表的 Itanium C++ ABI 实现。后者的 C 运行时库（通称 CRT ）却和 <code>msvc</code> 兼容。</li>
</ul>
</li>
<li>和 GNU guess 不同，Clang 三元组使用的情形相当有限，甚至<a href="https://stackoverflow.com/questions/15036909/">长期以来并不具有用户文档中明确的列表或检查规则</a>。
<ul>
<li>虽然 <code>clang</code> 接受 <code>-triple</code> 指定三元组，<code>clang --print-targets</code> 却输出平台标识符而非三元组。</li>
<li>三元组实际来自 <a href="https://llvm.org/doxygen/Triple_8h_source.html">LLVM 而非 Clang 的支持</a>。</li>
<li>更接近此处需求的是同时使用 LLVM 的 <a href="https://docs.rust-embedded.org/embedonomicon/compiler-support.html#built-in-target"><code>rustc --print target-list</code></a> 的输出。</li>
</ul>
</li>
<li>默认 <code>&lt;unknown&gt;</code> 但不一定在清单中被排除。这种随意性引起一些解析和理解上的困难。
<ul>
<li><strong>注释</strong> 在清单中滥用 <code>&lt;unknown&gt;</code> 的大量（却不是每个）例子可在 <code>rustc --print target-list</code> 的输出中找到。例如，通常读者（和系统维护者）难以理解：为何存在 <code>wasm32-unknown-emscripten</code> 和 <code>wasm32-wasi</code> 的同时还有 <code>wasm32-unknown-unknown</code> 而非 <code>wasm32-unknown</code> ？</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>具体构建过程可按需不同形式的标识符。
<ul>
<li><strong>原理</strong> 平台配置不一定通过系统类型描述。
<ul>
<li><strong>注释</strong> 例如，<code>cmake -G</code> 支持的标识依赖生成系统的配置，而非运行程序的系统类型。</li>
</ul>
</li>
<li><strong>原理</strong> 在不需要关心系统类型中各个组成部分的情形，其它的平台标识符可提供更简单明确的替代。
<ul>
<li><strong>注释</strong> <code>cmake -G clang --print-targets</code> 的结果是一个实例。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多平台构建"><a class="header" href="#多平台构建">多平台构建</a></h3>
<p>　　构建系统中可能涉及多个平台。</p>
<p>　　运行构建系统的环境和被构建的程序的环境不需要相同，对应的平台分别是<a href="#%E4%BE%9D%E8%B5%96%E5%92%8C%E5%A4%96%E5%BB%B6">宿主平台</a>和<a href="#%E4%BE%9D%E8%B5%96%E5%92%8C%E5%A4%96%E5%BB%B6">目标平台</a> 。宿主平台和目标平台相同时称为<em>本机(native)</em> 构建；不同时称为<em>交叉(cross)</em> 构建。</p>
<p>　　多个构建过程可能串联组成更大的构建过程。不同构建过程存在输出和输入之间的依赖。此时，前一过程输出的目标平台需要兼容于后一过程作为输入的宿主平台，否则无法直接运行。典型情况下这些平台是相同的，但也可以存在平台之间自身保证二进制<a href="#%E8%A7%84%E8%8C%83">互操作</a>兼容性（如支持 x86_64 的体系结构上混用 i686 和 x86_64 ）的情况。</p>
<p>　　一些构建系统如 <a href="https://gcc.gnu.org/onlinedocs/gccint/Configure-Terms.html">GNU 工具链使用更复杂的术语</a>，单独引入<a href="#%E4%BE%9D%E8%B5%96%E5%92%8C%E5%A4%96%E5%BB%B6">构建平台</a>。</p>
<p>　　除非另行指定，本文档不要求单独使用这个概念，而默认构建平台是第一级构建过程（即 GNU autoconf 的“配置”）的宿主平台。</p>
<p><strong>原理</strong></p>
<p>　　不要求显式的构建平台确保一般性并简化模型。</p>
<p>　　特别地，能单独指定构建平台，是因为已知第一级配置可以单独通过<a href="#%E7%8E%AF%E5%A2%83">宿主环境</a>运行本机程序（典型地，如 C 语言等<a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">本机语言</a>实现的<a href="#%E4%BE%9D%E8%B5%96%E5%92%8C%E5%A4%96%E5%BB%B6">宿主实现</a>程序）。典型地，GNU autoconf 等使用宿主环境脚本调用配置阶段构建的程序实现构建的第一级阶段。</p>
<p><strong>注释</strong></p>
<p>　　一些支持交叉构建的系统，即便被设计为配合已知的第一级构建的本机语言实现，也使用简化的模型。</p>
<p>　　例如，Go 语言的交叉编译实现中，可<a href="https://dh1tw.de/2019/12/cross-compiling-golang-cgo-projects/">使用简化的模型</a>，也可能<a href="https://go.dev/wiki/GccgoCrossCompilation">使用区分构建平台的模型</a>。</p>
<p>　　构建系统实现可能通过不同的环境变量区分针对<a href="#%E4%BE%9D%E8%B5%96%E5%92%8C%E5%A4%96%E5%BB%B6">不同的平台</a>的对应的<a href="#%E7%8E%AF%E5%A2%83">构建程序</a>。例如，一些主要的 GNU 项目有以下支持：</p>
<ul>
<li>多个环境变量指定构建系统中不同阶段使用的生成不同平台代码的编译器。以 C 编译器为例：
<ul>
<li>环境变量 <code>CC</code> 指定宿主平台使用的编译器，其宿主平台以及目标平台和构建系统的对应平台相同。</li>
<li>环境变量 <code>CC_FOR_BUILD</code> 或 <code>BUILD_CC</code> 指定构建平台的 C <a href="#%E4%BE%9D%E8%B5%96%E5%92%8C%E5%A4%96%E5%BB%B6">本机编译器</a>。
<ul>
<li>它输出的目标程序可作为构建脚本调用的一部分，即它的目标平台是构建平台。</li>
<li>指定 <code>CC_FOR_BUILD</code> 和 <code>CC</code> 不同的值可允许它不是宿主平台的本机编译器；其输出的目标程序能在构建平台运行，而不一定能在宿主平台运行。</li>
<li>构建平台和宿主平台相同时，一般同 <code>CC</code> 。</li>
</ul>
</li>
<li>环境变量 <code>CC_FOR_HOST</code> 或 <code>HOST_CC</code> 指定宿主平台的 C 编译器。
<ul>
<li><code>HOST_CC</code> 名义上指定宿主平台编译器，实际因为被用于构建过程而更应视为构建平台的编译器，因此可能同 <code>CC_FOR_BUILD</code> 且当前一般建议使用 <code>CC_FOR_BUILD</code> 替代，尽管因为兼容性可能仍被支持。</li>
<li><code>CC_FOR_HOST</code> 很少使用，一般同 <code>CC</code>（尽管<a href="https://github.com/mesonbuild/meson/issues/3969">有时后者总是被视为本机编译器</a>）。</li>
</ul>
</li>
<li>环境变量 <code>CC_FOR_TARGET</code> 指定目标平台的 C 编译器。
<ul>
<li>不使用 <code>TARGET_CC</code> 。</li>
</ul>
</li>
</ul>
</li>
<li>在 GNU binutils 的历史中：
<ul>
<li><code>HOST_CC</code> 在<a href="https://sourceware.org/git/?p=binutils-gdb.git;a=commitdiff;h=fecd2382e77b89f12c9d630ed4e42e9a54ba6953">初始提交</a>中即已出现。</li>
<li><code>CC_FOR_TARGET</code> 在<a href="https://sourceware.org/git/?p=binutils-gdb.git;a=commit;h=5148923360989fb54088f499e4b4cefd14088f9a">这个提交</a>中被引入。</li>
<li><code>CC_FOR_BUILD</code> 在<a href="https://sourceware.org/git/?p=binutils-gdb.git;a=commit;h=440868a029f0e200c019dce82ec783163fa59eed">这个提交</a>中被引入。</li>
<li><code>CC_FOR_HOST</code>（以及 <code>CFLAGS_FOR_HOST</code> ）最早在<a href="https://sourceware.org/git/?p=binutils-gdb.git;a=commitdiff;h=3c2476067c4b9c7db494af355e575b607fededee">这个提交</a>中出现。
<ul>
<li>仅在测试中使用。</li>
</ul>
</li>
<li><code>BUILD_CC</code> 最早在<a href="https://sourceware.org/git/?p=binutils-gdb.git;a=commitdiff;h=3866be5d4e427b4d114ad3b145496b8125c0fb0c">这个提交</a>中出现，代替 <code>HOST_CC</code> 。</li>
<li><code>BUILD_CC</code> 的支持在<a href="https://sourceware.org/git/?p=binutils-gdb.git;a=commit;h=4ec9a3b2495d5b49da1d83ac4ca0e3f90f8d2f75">这个提交</a>被移除。
<ul>
<li>参见以下 GCC 的更改。</li>
<li>剩余的更改被之后的提交（<a href="https://sourceware.org/git/?p=binutils-gdb.git;a=commitdiff;h=4fa63067931306bf5a9f9894bf4d2f5e14a1228f">[1]</a><a href="https://sourceware.org/git/?p=binutils-gdb.git;a=commitdiff;h=37ad95141b084645ed5729a0f36e1c945b0ac693">[2]</a><a href="https://sourceware.org/git/?p=binutils-gdb.git;a=commitdiff;h=3866be5d4e427b4d114ad3b145496b8125c0fb0c">[3]</a>）移除。</li>
</ul>
</li>
</ul>
</li>
<li>在 GCC 的历史中：
<ul>
<li><code>HOST_CC</code> 在<a href="https://sourceware.org/git/?p=binutils-gdb.git;a=commitdiff;h=79d8453e1c6f6e7e304d6f44da0dd018c459a121">初始提交</a>中即已出现。</li>
<li><a href="https://gcc.gnu.org/git/?p=gcc.git;a=commit;h=c192da272be503d6d70ee09165cbac6de7b0b88a">这个提交</a>支持 <code>HOST_CC</code> 。</li>
<li><a href="https://gcc.gnu.org/git/?p=gcc.git;a=commit;h=b7cb92adc97bd0cde5263493567cff7d23ed65d7">这个提交</a>在配置脚本中支持 <code>BUILD_CC</code> 。</li>
<li><a href="https://gcc.gnu.org/git/?p=gcc.git;a=commit;h=fe81dd695d4f49444de0114ee69b219c8d6aa45c">这个提交</a>使用 <code>BUILD_FOR_CC</code> 代替 <code>BUILD_CC</code> 。</li>
<li><code>BUILD_CC</code> 支持在<a href="https://gcc.gnu.org/git/?p=gcc.git;a=commit;h=eaf9f3b2e936e437092978ee61606cb53f87e5bc">之后</a>被移除。</li>
<li>没有出现 <code>CC_FOR_HOST</code> 。</li>
</ul>
</li>
<li>GNU Autoconf <a href="https://git.savannah.gnu.org/cgit/autoconf.git/commit/?id=723cfb231e56f59931a0553b46754c1189a44f04">引入环境变量 <code>BUILD_CC</code> 和 <code>HOST_CC</code></a> 代替 <code>CC</code> 指定构建平台和宿主平台运行的 C 编译器。</li>
<li>GNU config <a href="https://git.savannah.gnu.org/cgit/config.git/commit/?id=b0f77efb54be49c9f3b73a970e0224dd8ff28bea">引入 GNU Autoconf 的上述更改</a>。</li>
<li>GNU config <a href="https://git.savannah.gnu.org/cgit/config.git/commit/?id=045c3cc31298d4270d4b3a2e36531819206dd4d1">之后引入的更改</a>补充的注释指出 <code>CC_FOR_BUILD</code> 代替 <code>HOST_CC</code> 。
<ul>
<li>这在更早的提交中也有出现，如<a href="https://sourceware.org/git/?p=binutils-gdb.git;a=commitdiff;h=2412a768378f4c97e28f82824cbccc0c52b83938">这个 GNU binutils 提交</a>。</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="EMPTY.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="StandardUsing.en-US.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="EMPTY.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="StandardUsing.en-US.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
