<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>术语概要 - The YSLib Book</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Book tranplanted from YSLib BitBucket wiki.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Home.html"><strong aria-hidden="true">1.</strong> 索引/Index</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Home.en-US.html"><strong aria-hidden="true">1.1.</strong> English Version</a></li><li class="chapter-item expanded "><a href="Home.zh-CN.html"><strong aria-hidden="true">1.2.</strong> 简体中文版</a></li><li class="chapter-item expanded "><a href="Contents.zh-CN.html"><strong aria-hidden="true">1.3.</strong> Contents(zh-CN)/主题目录</a></li></ol></li><li class="chapter-item expanded "><a href="GettingStarted.zh-CN.html"><strong aria-hidden="true">2.</strong> 入门</a></li><li class="chapter-item expanded "><a href="Development.zh-CN.html"><strong aria-hidden="true">3.</strong> 开发说明</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Prerequisitions.zh-CN.html"><strong aria-hidden="true">3.1.</strong> 先决条件</a></li><li class="chapter-item expanded "><a href="GettingSources.zh-CN.html"><strong aria-hidden="true">3.2.</strong> 获取源代码</a></li><li class="chapter-item expanded "><a href="Build.zh-CN.html"><strong aria-hidden="true">3.3.</strong> 构建</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="BuildDocumentation.zh-CN.html"><strong aria-hidden="true">3.3.1.</strong> 构建文档</a></li></ol></li><li class="chapter-item expanded "><a href="Test.zh-CN.html"><strong aria-hidden="true">3.4.</strong> 测试</a></li><li class="chapter-item expanded "><a href="Run.zh-CN.html"><strong aria-hidden="true">3.5.</strong> 运行</a></li></ol></li><li class="chapter-item expanded "><a href="Features.zh-CN.html"><strong aria-hidden="true">4.</strong> 结构和特性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ProjectDependencies.zh-CN.html"><strong aria-hidden="true">4.1.</strong> （内部）项目依赖性说明</a></li><li class="chapter-item expanded "><a href="Features/NPL.zh-CN.html"><strong aria-hidden="true">4.2.</strong> NPL</a></li></ol></li><li class="chapter-item expanded "><a href="EMPTY.html"><strong aria-hidden="true">5.</strong> 应用开发环境</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Sysroot.zh-CN.html"><strong aria-hidden="true">5.1.</strong> Sysroot</a></li><li class="chapter-item expanded "><a href="YDE.zh-CN.html"><strong aria-hidden="true">5.2.</strong> YDE</a></li></ol></li><li class="chapter-item expanded "><a href="EMPTY.html"><strong aria-hidden="true">6.</strong> 项目维护资源</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Releases.zh-CN.html"><strong aria-hidden="true">6.1.</strong> 发布工程</a></li><li class="chapter-item expanded "><a href="Archives.zh-CN.html"><strong aria-hidden="true">6.2.</strong> 归档</a></li></ol></li><li class="chapter-item expanded "><a href="EMPTY.html"><strong aria-hidden="true">7.</strong> 工具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Tools/SHBuild.zh-CN.html"><strong aria-hidden="true">7.1.</strong> SHBuild</a></li><li class="chapter-item expanded "><a href="Tools/RevisionPatcher.zh-CN.html"><strong aria-hidden="true">7.2.</strong> RevisionPatcher</a></li><li class="chapter-item expanded "><a href="Tools/SXML2XML.zh-CN.html"><strong aria-hidden="true">7.3.</strong> SXML2XML</a></li><li class="chapter-item expanded "><a href="Tools/ProjectGenerator.zh-CN.html"><strong aria-hidden="true">7.4.</strong> ProjectGenerator</a></li><li class="chapter-item expanded "><a href="Tools/Scripts.zh-CN.html"><strong aria-hidden="true">7.5.</strong> 脚本</a></li></ol></li><li class="chapter-item expanded "><a href="Tutorial.zh-CN.html"><strong aria-hidden="true">8.</strong> 教程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Tutorial/Overview.zh-CN.html"><strong aria-hidden="true">8.1.</strong> 综述</a></li><li class="chapter-item expanded "><a href="Tutorial/GUI.zh-CN.html"><strong aria-hidden="true">8.2.</strong> GUI</a></li><li class="chapter-item expanded "><a href="Tutorial/Configuration.zh-CN.html"><strong aria-hidden="true">8.3.</strong> 程序配置</a></li></ol></li><li class="chapter-item expanded "><a href="EMPTY.html"><strong aria-hidden="true">9.</strong> 附录/Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Terminology.zh-CN.html" class="active"><strong aria-hidden="true">9.1.</strong> 术语概要</a></li><li class="chapter-item expanded "><a href="StandardUsing.en-US.html"><strong aria-hidden="true">9.2.</strong> Standard Using</a></li><li class="chapter-item expanded "><a href="ReportedIssues.en-US.html"><strong aria-hidden="true">9.3.</strong> Reported Issues</a></li><li class="chapter-item expanded "><a href="WikiRules.en-US.html"><strong aria-hidden="true">9.4.</strong> Wiki Rules</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The YSLib Book</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="术语概要"><a class="header" href="#术语概要">术语概要</a></h1>
<p>　　本文档概述及约定 YSLib 基本的概念含义，主要用于<a href="Development.zh-CN.html">开发</a>。</p>
<p>　　一些术语概念适用各种不同的上下文，主要用于开发过程中的设计和规则说明。</p>
<p>　　术语以列表形式的条目列出。通过使用元语言语法 <em>&lt;相关范畴/上下文&gt;</em> 标记指示被修饰或被限定的概念的适用范围。不需要消歧义时，省略标记。</p>
<h1 id="通用领域"><a class="header" href="#通用领域">通用领域</a></h1>
<p>　　除非另行指定，适用于任意<a href="#%E8%87%AA%E6%8C%87">上下文</a>；但存在更具体的上下文的特定概念定义时，优先适用后者。</p>
<h2 id="经验语义"><a class="header" href="#经验语义">经验语义</a></h2>
<p>　　经验语义解释的术语的含义总是假定可被实证，不需要进一步解释。</p>
<p>　　元语言中的标记使用经验语义。标记可被本文档中已归类的章节提供。</p>
<p>　　本文档中非形式地使用在特定理论中严格定义的、和<a href="#%E9%80%9A%E7%94%A8%E7%BA%A6%E5%AE%9A">本章</a>的条目具有逻辑上相容的含义的概念时，不进一步解释。</p>
<h2 id="自指"><a class="header" href="#自指">自指</a></h2>
<p>　　<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E6%8C%87"><strong>自指</strong></a>是概念定义形式上的自我指涉。</p>
<p><strong>举例</strong> “<a href="#%E9%80%9A%E7%94%A8%E9%A2%86%E5%9F%9F">本章</a>”是关于位置的自指。</p>
<p>　　有必要通过自指定义的概念，隐含引入定义内容的过程的<a href="https://zh.wikipedia.org/zh-cn/%E5%BE%AA%E7%92%B0%E8%AB%96%E8%AD%89">循环论证</a>。这些概念的精确内涵和外延依赖<a href="#%E7%BB%8F%E9%AA%8C%E8%AF%AD%E4%B9%89">经验语义</a>的实证，否则在自然语言语言中可能需要循环论证而失去定义的意义。此处的条目内容（包括链接的外部定义）仅仅供参考，而不是精确的内涵和外延。为简化复杂度，限制自指定义的概念都是名词。</p>
<p><strong>举例</strong> 上述注释中，<strong>内涵</strong>和<strong>外延</strong>约定为以下<a href="#%E9%9D%9E%E8%87%AA%E6%8C%87">非自指</a>的概念，因此可依据本文档给出明确的定义来源。</p>
<p><strong>举例</strong> 在程序语言理论中，上下文(context) 指形式上可继续补充内容的构造；文档可能非形式地使用和这个含义相容的概念。</p>
<ul>
<li>实体(entity) ：任意被自然语言表达的目标；不需要通过自然语言先验定义；参见经验语义。</li>
<li>语义(semantics) ：参见经验语义。</li>
<li>经验(experience) ：参见哲学或一般等价的经验语义。</li>
<li>范畴(category) ：参见<a href="https://zh.wikipedia.org/zh-cn/%E8%8C%83%E7%95%B4%E8%AE%BA">范畴论</a>。</li>
<li>态射(morphism) ：参见范畴论。</li>
<li>归纳(induction) ：一种态射，可操作性参见经验语义。</li>
<li>方法学(methodology) ：一个归纳经验得到的范畴；参见哲学或一般等价的经验语义。</li>
<li>方法(method) ：方法学的一个子范畴；可操作性参见经验语义。</li>
<li>概念(concept) ：参见逻辑学。</li>
<li>上下文(context) ：一种概念范畴适用的态射；参见经验语义。</li>
</ul>
<h2 id="非自指"><a class="header" href="#非自指">非自指</a></h2>
<p>　　包含多个一般领域的概念。</p>
<ul>
<li><em>&lt;名词&gt;</em> 形式(form) ：参见经验语义和数学。</li>
<li><em>&lt;概念&gt;</em> 内涵：参见逻辑学。</li>
<li><em>&lt;概念&gt;</em> 外延：参见逻辑学。</li>
<li><em>&lt;概念&gt;</em> 定义(definition) ：确定概念内涵和外延的方法；参见任意一种形式逻辑学。</li>
<li><em>&lt;动词&gt;</em> 抽象(abstracting) ：通过经验语义定义概念范畴或集合的方法。</li>
<li><em>&lt;名词&gt;</em> 抽象(abstraction) ：<em>&lt;动词&gt;</em> 抽象的结果。</li>
<li><em>&lt;动词&gt;</em> 封装(encapsulating) ：从某一个范畴中抽象一个子范畴的方法。</li>
<li><em>&lt;名词&gt;</em> 封装(encapsulation) ：<em>&lt;动词&gt;</em> 封装的结果。</li>
<li>规范(specialization) ：一种提供在特定上下文中可定义的描述的封装，参见工程学（特别是软件工程学，下同）。</li>
<li>接口(interface) ：一种封装，参见工程学。</li>
<li>实现(implementation) ：一种封装，参见工程学。</li>
<li>重用(reusing) ：参见经验语义和工程学。</li>
<li>不变性(invariance) ：满足某种<a href="https://zh.wikipedia.org/zh-cn/%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB">等价关系</a>（自反、传递、对称的<a href="https://zh.wikipedia.org/zh-cn/%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB">二元关系</a>）。</li>
<li>不变量(invariant) ：具有不变性的实体。参见数学和契约式程序设计。</li>
<li>状态(state) ：可以和其它实体关联的、可在某个上下文中保持变化或不变的实体。同一状态总是保持变化或保持不变。状态变化的含义参见经验语义、数学或另行指定。
<ul>
<li>可变状态(mutable state) ：在某个上下文中可能映射到若干其它状态的状态。</li>
<li>不可变状态(immutable state) ：不是可变状态的状态。</li>
</ul>
</li>
<li><em>&lt;动词&gt;</em> 派生(deriving) ：基于重用的操作。</li>
<li><em>&lt;名词&gt;</em> 派生(derivation) ：<em>&lt;动词&gt;</em> 派生的结果。</li>
</ul>
<h1 id="计算机科学"><a class="header" href="#计算机科学">计算机科学</a></h1>
<p>　　包含多个关于数学、逻辑学和计算机领域的概念。</p>
<ul>
<li><em>&lt;动词&gt;</em> 形式化(formalize) ：建立数学意义上的严格<a href="#%E9%9D%9E%E8%87%AA%E6%8C%87">形式</a>。</li>
<li><em>&lt;名词&gt;</em> 形式化(formalization) ：建立形式的过程。</li>
<li>形式方法(formal method) ：包含形式化的<a href="#%E8%87%AA%E6%8C%87">方法</a>。</li>
<li><em>&lt;动词&gt;</em> 建模(model) ：建立形式化输出的形式。</li>
<li><em>&lt;名词&gt;</em> 模型(model) ：建模的结果。</li>
<li>可计算性(computability) ：参见数学。
<ul>
<li>通常由 <a href="https://zh.wikipedia.org/zh-cn/%E9%82%B1%E5%A5%87%EF%BC%8D%E5%9B%BE%E7%81%B5%E8%AE%BA%E9%A2%98">Church-Turing 论题</a>定义。</li>
</ul>
</li>
<li>计算(computation) ：由可计算性定义的操作的等价类。</li>
<li>计算模型(computation model) ：描述计算的模型，是对计算建模的结果。 </li>
<li>集合(set) ：一种数学模型，参见 <a href="https://zh.wikipedia.org/zh-cn/%E5%86%AF%E8%AF%BA%E4%BC%8A%E6%9B%BC-%E5%8D%9A%E5%86%85%E6%96%AF-%E5%93%A5%E5%BE%B7%E5%B0%94%E9%9B%86%E5%90%88%E8%AE%BA">NBG 集合论</a>。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E7%B1%BB_%28%E6%95%B0%E5%AD%A6%29">类</a>(class) ：参见 NBG 集合论和范畴论。</li>
<li>真类(proper class) ：参见 NBG 集合论和范畴论。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB">二元关系</a>(binary relationship) ：一种基于集合上定义的数学实体。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB">等价关系</a>(equivalence relationship) ：自反的(reflexive) 、对称的(symentric) 和传递的(transitive) 的二元关系。</li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E7%AD%89%E4%BB%B7%E7%B1%BB">等价类</a>(equivalence class) ：等价关系划分集合得到的类。</li>
<li>序列(sequence) ：有序集合。</li>
<li>形式语义(formal semantics) ：使用形式化的方式表达的语义。</li>
<li>形式语言(formal language) : 特定语言规则确定的串的全集，是语言规则对应的语法的外延（也可能作为其它语言规则对应的某种形式语义）。</li>
<li>计算复杂度(computational complexity) ：某个形式化计算模型中以有限的正整数作为模型决定的规模(metric) 作为参数的渐进(asymptotic) 性质确定的度量。
<ul>
<li>时间复杂度(time complexity) ：描述步骤规模的计算复杂度。</li>
<li>空间复杂度(space comlexity) ：描述存储规模的计算复杂度。</li>
</ul>
</li>
</ul>
<h1 id="规范"><a class="header" href="#规范">规范</a></h1>
<p>　　包含提供<a href="#%E8%87%AA%E6%8C%87">规范</a>的<a href="#%E8%87%AA%E6%8C%87">实体</a>定义。</p>
<ul>
<li>符合性(conformance) ：满足规范的实现性质。</li>
<li>要求(requirement) ：规范对实现的作为判断符合性的条件。</li>
<li>约束(constraint) ：可被<a href="#%E9%9D%9E%E8%87%AA%E6%8C%87">形式</a>表达，用于限制和明确行为的规则。不一定使用形式表达。</li>
<li>违反(violation) ：对约束指定的条件的不满足。</li>
<li>过时的(obsolesent) ：已确认因为存在更合适的选项而建议不继续使用的（接口/特性）。</li>
<li>废弃的(deprecated) ：过时的但因为兼容性等原因，暂时保留的、一般可提供替代的接口或特性。</li>
<li>语言：<a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">模型</a>或者非形式地其它方式定义的一种<a href="#%E9%9D%9E%E8%87%AA%E6%8C%87">接口</a>。</li>
<li><em>&lt;语言&gt;</em> 接口(<em>&lt;language&gt;</em> interface) ：和表达<a href="#%E8%87%AA%E6%8C%87">语义</a>有关的语言的可见的特征。</li>
</ul>
<p>　　包含关于语言的规范的定义。</p>
<ul>
<li><em>&lt;语言&gt;</em> 实现(<em>&lt;language&gt;</em> implementation)：对语言规则中的要求的<a href="#%E9%9D%9E%E8%87%AA%E6%8C%87"><em>&lt;非自指&gt;</em> 实现</a>。</li>
<li><em>&lt;语言&gt;</em> 人类接口(human interface) ：语义仅对人类有意义（内容改变时可以导致语义的差异性），不提供为涉及作为计算模型实现的语言接口。</li>
<li><em>&lt;语言&gt;</em> 机器接口(machine interface) ：对机器（或特定语言实现的特定部分）有意义的语言接口。注意不同语言实现组成部分可以不同。
<ul>
<li><strong>举例</strong> 对 <a href="https://zh.wikipedia.org/zh-cn/C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8">C 语言的预处理器</a>，C 源代码中的空白符是机器接口，而对翻译器来说则不是。就源代码而言，机器接口总是人类接口的子集。</li>
</ul>
</li>
<li><em>&lt;语言&gt;</em> 特性(*&lt;language&gt; feature) ：作为功能提供的人类接口。</li>
<li>语言规则(language rule) ：约定可实现及应被实现的语言接口的描述，可包含语言特性的表达。</li>
<li>语言规范(language specialization) ：包含正式的(normative) 的语言规则的集合的<a href="#%E8%87%AA%E6%8C%87">规范</a>；或称语言规格说明。</li>
<li>语言实现(language implementation) ：语言提供的接口的实现，是语言的表现形式，可以是具体语言实现或抽象语言实现之一。
<ul>
<li>具体语言实现(concreate language implementation) ：能最终完全表达为可预测的物理现象一一对应的表达<a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">可计算性</a>的实现（如机器指令），一般应为程序。</li>
<li>抽象语言实现(abstract language implementation) ：非具体语言实现的语言实现。形式意义的标准定义的语言属于此类。</li>
</ul>
</li>
<li>派生语言实现(derived language implementation) ：派生已有实现的部分或全部得到的语言实现。以下简作“派生实现”。</li>
<li><em>&lt;语言&gt;</em> 实现环境(environment of implementation) ：对应特定语言实现的特定不变状态（对机器来说可以是配置项，对人来说不确定，所以一般忽略）的集合。</li>
<li><em>&lt;语言&gt;</em> 互操作(interoperation) ：不同的语言实现环境中发生的交互。</li>
</ul>
<h1 id="程序设计语言"><a class="header" href="#程序设计语言">程序设计语言</a></h1>
<p>　　提供上下文 <em>&lt;程序设计语言&gt;</em> ，特别是语言规范的定义。</p>
<p>　　主要用例参见版本库中的项目文档 <code>doc/NPL.txt</code> 。</p>
<ul>
<li>广义实体：<em>&lt;通用领域&gt;</em> 实体。语言抽象的目标，不另行定义（意义最终取决于自然语言）。</li>
<li>名称(name) ：一种特殊的广义实体，专用于指称另一个广义实体。</li>
<li>实体(entity) ：非名称的广义实体。</li>
<li>表示(representation) ：以一个符合某种形式的约束的实体指称另一个实体。</li>
<li>符号(symbol) ：语言规则允许的不使用其它对象表示的对象。符号可实现名称。</li>
<li>字母表(alphabet) ：符号在语言中的全集。</li>
<li>串(string) ：可能重复出现的符号的有限序列。</li>
<li>文法(grammar) ：描述任意的可形式化的语言规则。</li>
<li>语法(syntax) ：以语言中的串作为基本元素，描述语言的字面(literal) 结构模式(pattern) 的语言规则，通常是文法的一部分。</li>
<li>语义(semantics) ：非语法的考虑逻辑上的释义(interpretation) 或含义(meaning) 的规则、原理和过程，通常可被语法以外的文法描述并可约束含义的表达。</li>
<li>实例(instance) ：具有代表性含义的集合的元素。</li>
<li>代码(code)：任意有限的语言的实例片段组成的语法范畴。</li>
<li>伪代码(pseudo code)：抽象语言实现的语言的代码。
<ul>
<li><strong>注释</strong> 习惯上和具体语言实现代码完全一致的代码可以不作为伪代码考虑。</li>
</ul>
</li>
<li>程序(program) ：具体语言实现接受的以代码表示的输入，或被变换后对应的输出。</li>
<li>行为(behavior) ：语言实现或在满足符合性的具体语言实现中的程序的外部表现。基于可操作性考虑，一般仅约束实现的机器<a href="#%E9%9D%9E%E8%87%AA%E6%8C%87">接口</a>。</li>
<li>计算作用(computational effect) ：可被某个形式化计算模型描述的行为。</li>
<li>作用(effect) ：语言支持的一定上下文内的表达式规约的结果的计算作用，包括计算得到的值、产生的副作用以及其它可由区域和变化的状态二元组描述的实体。</li>
<li>翻译(translation) ：不同语言的程序之间的变换，可作为语言实现的形式。
<ul>
<li><strong>注释</strong> 输入和输出具有相同表示的恒等变换不被视为翻译。</li>
</ul>
</li>
<li>运行(run) ：实现程序或组成程序的实体的行为的动作。</li>
<li>加载(load) ：运行程序或组成程序的实体时从实现环境取得相关实体的动作，可蕴含创建这些实体的副本或翻译其中的代码到特定形式。</li>
<li>执行(execute) ：处理程序或组成程序的实体，使这些实体或实体的副本作为资源被消费而蕴含这些实体被运行，同时可能蕴含消费实现环境的其它资源。
<ul>
<li><strong>注释</strong> 执行强调资源的消费，是运行的子集。资源被消费后不再可用。因此，除非同时蕴含资源的<em>再生(reclaim)</em> ，被执行的同一实体不预期被再次执行。再生资源包括实体加载时翻译或取得副本，及实现环境中补充的替代资源。</li>
</ul>
</li>
<li>解释(interpretation) ：通过不依赖显式指定的附加的程序翻译而直接运行表现行为的具体语言实现的形式。</li>
<li>源语言(source language) ：翻译的输入的语言。</li>
<li>目标语言(destination language) ：翻译的输入的语言。</li>
<li>源代码(source code) ：源语言编码的代码。</li>
<li>源程序(source program) ：形式为作为翻译的输入的源代码程序。</li>
<li>复杂度(complexity) ：以程序的规模作为参数的关于程序的直接执行的<a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算复杂度</a>。</li>
<li>元语言(metalanguage) ：描述其它语言的语言。</li>
<li>对象语言(object language)：被元语言操作或实现的语言。</li>
<li>元编程(metaprograming) ：使用元语言编程。</li>
<li>反射(reflection) ：元语言和对象语言相同的元编程。</li>
<li>具现(reification) ：在对象语言中以数据模型作为关联实体以表示程序的语义。</li>
<li>诊断(diagnostics) ：明确的对特定预期或非预期执行的行为的响应的总和。</li>
<li>诊断消息(diagnostic message) ：用于和用户交互的表现诊断的告知及提示。</li>
<li>未定义的(undefined) ：可能导致违反语言规范的约束但语言规范同时没有要求提供任何可能影响<a href="#%E9%9D%9E%E8%87%AA%E6%8C%87">符合性</a>的保证（如具有诊断消息）的。表示置于语言规则下的行为等不可预测。</li>
<li>未指定的(unspecified) ：在各个实现中可能存在的，通常允许多种不同的实现选项。不应假定不同实现在明确未指定的规则上表现一致。</li>
<li>由实现定义的(implementation-defined) ：取决于各个具体语言实现的，要求有文档说明。</li>
<li>由派生实现定义的(derived-implementation-defined) ：取决于各个具体派生实现的，要求除存在默认定义或被派生实现的部分有明确的文档说明。</li>
<li>未定义行为(undefined behavior) ：未定义的行为。</li>
<li>未指定行为(unspecified behavior) ：未指定的行为，由实现选取规格中可能允许的指定行为的不确定选项，后者可能由显式或隐式的语言规则确定。</li>
<li>语言特性(language feature) ：语言提供的功能接口，可以是具体语言特性或抽象语言特性之一。</li>
<li>具体语言特性(concrete language feature) ：完全没有派生语言实现定义的语言特性。</li>
<li>抽象语言特性(abstract language feature) ：非具体语言特性的语言特性。</li>
<li>外部环境(external environment) ：和程序及被翻译的程序没有交集的和实现环境无关的状态。</li>
<li>外部表示(external representation) ：具有特定形式的用于和外部环境交互的表示。</li>
<li>内部表示(internal representation) ：非外部表示的表示。</li>
</ul>
<h1 id="项目管理"><a class="header" href="#项目管理">项目管理</a></h1>
<h2 id="依赖dependency-管理"><a class="header" href="#依赖dependency-管理">依赖(dependency) 管理</a></h2>
<p>　　项目管理的客体被分解为特定关联的<strong>依赖项</strong>。任意两个依赖项之间存在<a href="https://zh.wikipedia.org/zh-cn/%E5%8F%8D%E5%AF%B9%E7%A7%B0%E5%85%B3%E7%B3%BB">反对称</a>和<a href="https://zh.wikipedia.org/zh-cn/%E4%BC%A0%E9%80%92%E5%85%B3%E7%B3%BB">传递</a>的<a href="https://zh.wikipedia.org/zh-cn/%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB">二元关系</a>称为<strong>依赖关系</strong>。<strong>严格依赖关系</strong>是反自反的依赖关系。</p>
<p>　　依赖项和依赖项之间的严格依赖关系统称为<strong>依赖</strong>。</p>
<h3 id="依赖引用"><a class="header" href="#依赖引用">依赖引用</a></h3>
<p>　　因为依赖关系的传递性，多个依赖关系可能存在无法满足严格依赖关系的情形，即<strong>循环依赖</strong>。这导致以确定的顺序解析依赖不可行，增加维护成本。</p>
<p>　　为了避免一定层次上的循环依赖，以该层次内组件为顶点的依赖关系的关系图应明确组织为有向无环图。
在最简单情况下依赖关系可退化为线性顺序依赖。</p>
<h3 id="内部依赖和外部依赖"><a class="header" href="#内部依赖和外部依赖">内部依赖和外部依赖</a></h3>
<p>　　项目中的组成部分之间的依赖称为<strong>内部依赖</strong>，其它依赖为<strong>外部依赖</strong>。</p>
<h2 id="a-hrefe7a88be5ba8fe8aebee8aea1e8afade8a880源代码a"><a class="header" href="#a-hrefe7a88be5ba8fe8aebee8aea1e8afade8a880源代码a"><a href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">源代码</a></a></h2>
<p>　　源代码用于生成指定目标代码(target code) 。</p>
<p>　　通常源代码以文件形式保存，即源代码文件(source code file) ，简称源文件(source file) 。</p>
<h2 id="版本库repository"><a class="header" href="#版本库repository">版本库(repository)</a></h2>
<p>　　本项目使用的版本控制(version controll) 的存储实体。</p>
<p>　　当前使用的主要版本控制系统为 <a href="https://www.mercurial-scm.org/">Mercurial</a> 。因为是分布式版本控制，也用于直接分发源代码。</p>
<p>　　每个文件系统上存储的版本库实例中， <code>.hg</code> 目录存储版本库元数据。</p>
<h1 id="设计和模型"><a class="header" href="#设计和模型">设计和模型</a></h1>
<h2 id="环境environment"><a class="header" href="#环境environment">环境(environment)</a></h2>
<p>　　程序中的某一部分的外界称为<strong>环境</strong>。根据限定程序的范围，可以有更确切的定义，如<a href="#%E8%A7%84%E8%8C%83">实现环境</a>（对一类语言实现而言）、运行时环境（对共享实现环境的一类程序而言）。</p>
<p>　　一般地，实现环境可以分为<strong>独立环境(freestanding environment)</strong> 和<strong>宿主环境(hosted environment)</strong> ，区分依据为是否依赖宿主（对部署在单一计算机上的实现，一般指操作系统）的支持。因此，环境有时指操作系统及其提供的外部服务的集合。</p>
<p>　　一些语言，如 ISO C 和 ISO C++ ，可以同时支持宿主环境和独立环境的实现，对应<strong>独立实现(freestanding impementation)</strong> 和<strong>宿主实现(hosted impementation)</strong> 。</p>
<h2 id="平台platform-环境"><a class="header" href="#平台platform-环境">平台(platform) 环境</a></h2>
<p>　　环境中决定程序适用环境的被依赖的特定资源集合称为<strong>平台环境</strong>，简称<strong>平台</strong>。平台的典型例子有：</p>
<ul>
<li>运行时支持的<a href="https://zh.wikipedia.org/zh-cn/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%A7%8B">硬件的体系结构</a> ；</li>
<li>操作系统和 <a href="https://zh.wikipedia.org/zh-cn/%E5%BA%94%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8E%A5%E5%8F%A3">ABI</a> 。</li>
</ul>
<p>　　平台的内涵是资源的集合，其构成并非任意。构成平台的特定准则应使之保持相对的稳定和可预期，即可配置；即平台是名义的(nominal) 可配置的资源集合。</p>
<p>　　若平台包含的资源是已知的，则不需要平台的观念，分析其资源子集（即便不构成平台）即可解决几乎平台抽象涉及的所有技术问题（同时这也是<em>定义</em>一个具体平台的基础）。但在简化资源集合的全局性质分析（如比较资源配置方案）和名义抽象以隐藏实现（如为开发者提供预设环境集合）的应用角度上，平台仍有被单独讨论的意义。</p>
<h3 id="兼容性compatibility-和可移植性portability"><a class="header" href="#兼容性compatibility-和可移植性portability">兼容性(compatibility) 和可移植性(portability)</a></h3>
<p>　　若一个依赖项对应的平台可以替换，则此依赖项和此平台<strong>兼容(compatible)</strong> 。兼容性不是一种<a href="https://zh.wikipedia.org/zh-cn/%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB">等价关系</a>，因为不保证传递。</p>
<p>　　替换平台的过程称为<strong>移植(porting)</strong> 。移植的可行性称为<strong>可移植性</strong>。</p>
<p>　　兼容任意平台的依赖项被称为是<strong>平台中立(platform-neutral)</strong> 的。</p>
<p>　　当平台中立的依赖项的依赖能被自动满足而不需要考虑时，是<strong>平台无关(platform-independent)</strong> 的。平台中立<a href="https://zh.wikipedia.org/zh-cn/%E5%AE%9E%E8%B4%A8%E6%9D%A1%E4%BB%B6">实质蕴含</a>平台无关。</p>
<h3 id="依赖和外延"><a class="header" href="#依赖和外延">依赖和外延</a></h3>
<p>　　若平台之间不出现平台的实现（如开发语言的实现）和环境自身的相互依赖，则这些平台相互<strong>独立</strong>。总是保持相互独立的一组平台称为<strong>独立平台(independent platforms)</strong> 。每一组独立平台保证可以相对于其它独立平台分离开发和测试。</p>
<p>　　注意以上术语和 ISO C 和 ISO C++ 定义的<strong>宿主实现(hosted implementation)</strong> 和<strong>独立实现(freestanding implementation)</strong> 的关联和区别。</p>
<p>　　典型的应用场景约定以下类型的平台：</p>
<ul>
<li><strong>构建平台(build platform)</strong> 运行开发环境的平台。</li>
<li><strong>宿主平台(host platform)</strong> 运行构建平台输出代码的平台。</li>
<li><strong>目标平台(target platform)</strong> 运行最终目标代码的平台。</li>
</ul>
<p>　　若宿主平台和构建平台一致，称为<strong>本机构建(native build)</strong>；否则，称为<strong>交叉构建(corss build)</strong>。</p>
<p>　　通常构建工具在本机构建时提供对构建平台的检查以确定自身是否能够运行；交叉构建环境需要显式指定。</p>
<p>　　目标平台通常和宿主平台一致。指定目标平台的理由是，存在最终不一定在宿主平台上运行的程序，其运行的环境可能需要宿主平台不保证支持的特性，这典型地包括：</p>
<ul>
<li>构建的程序自身是生成其它程序的程序，如编译器和链接器。这些程序生成的平台是目标平台，不需要和它们的宿主平台相同。</li>
<li>构建的程序可以在宿主平台上运行，但在其它平台上具有更完全的特性集。后者被作为目标平台。</li>
</ul>
<p><strong>注意</strong> 此处的宿主平台具有相对意义，不一定脱离被运行的目标平台。一个宿主平台通常自身是宿主实现平台，但这点不被保证。</p>
<h3 id="模拟emulation-和仿真simulation"><a class="header" href="#模拟emulation-和仿真simulation">模拟(emulation) 和仿真(simulation)</a></h3>
<p>　　模拟指适配和运行为不同平台设计的程序，广义上包括以下两类：</p>
<ul>
<li>环境模拟(environment emulation) ：使用模拟器(emulator) 或虚拟机(virtual machine) 等作为宿主平台的程序，模拟运行环境的通用解决方案；</li>
<li>程序模拟(program emulation) ：直接以运行时环境适配层嵌入宿主平台运行时，在具体程序中提供类似被模拟的目标平台的具体特性和接口。</li>
</ul>
<p>　　运行模拟程序的环境和被模拟环境分别是宿主平台和目标平台。</p>
<p>　　注意虚拟机在这个意义下是广义的模拟器，但一般仍然分别对待。</p>
<p>　　环境模拟和程序模拟的主要差异为是否独立的、专用的宿主平台程序作为中介以维护目标平台和宿主平台的隔离。</p>
<p>　　在一般意义上，仿真指对需要分析的问题建立的模型(model) 的过程、方法和机制，在软件工程以外也被称为模拟，如计算机模拟(computer simulation) 。对于以计算机系统为目标的仿真，建立的模型可以是具体的实物（包括硬件和软件），称为仿真器(simulator) 。以软件接口为主要操作方式实现的仿真器同时实现了环境模拟，但侧重不同：精确重现需要分析行为，而非实用的功能等价性和体系中的可替换性。</p>
<h3 id="平台配置"><a class="header" href="#平台配置">平台配置</a></h3>
<p>　　实际的平台实现可能复用部分实现，配置之间可存在某种构成依赖关系的<a href="https://zh.wikipedia.org/zh-cn/%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB">偏序关系</a>（如继承关系）。这些在项目中所有被配置的平台称为<strong>公共平台(common platform)</strong> ，其中能对应生成输出的称为<strong>具体平台(concrete platform)</strong> ，否则为<strong>抽象平台(abstract platform)</strong> 。</p>
<h3 id="标识"><a class="header" href="#标识">标识</a></h3>
<p>　　不同平台可以标识符加以区分。由于平台受到不同环境因素决定的正交性，通常此类标识符可以分解为表示这些正交环境的标识符的元组形式，用 <code>-</code> 等字符分隔。</p>
<p>　　一种常用的方式是 GNU 构建系统的<a href="https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.69/html_node/System-Type.html#System-Type">系统类型(en-US)</a>，经典表示方式为三元组(triplet) ，或其省略形式：</p>
<ul>
<li>一般包括体系结构、系统厂商和系统软件环境</li>
<li>第一项不可省略，之后的项可省略</li>
<li>体系结构一般指定 CPU 要求的最小指令集架构</li>
<li>系统厂商指集成平台的环境厂商</li>
<li>系统软件环境保证满足 ABI 要求，可以包含操作系统及本机语言运行时实现的名称</li>
</ul>
<p>　　确定为宿主环境时，系统软件同时指定操作系统和运行时环境而拆分为两项，三元组扩充为四元组，如 <a href="https://wiki.gentoo.org/wiki/CHOST">Gentoo 使用的 CHOST (en-US)</a>。</p>
<p>　　在不够充分体现平台的必要差异（尤其是体系结构相关的配置）时也可通过自行定义标识符并指定与三元组的对应关系，如 <a href="%5Bhttps://wiki.debian.org/Multiarch/Tuples%5D">Debian multiarch (en-US)</a> 。</p>
<p>　　除非必要时另行指定， YSLib 使用三元组作为指定平台标识的基本形式。</p>
<h3 id="多平台构建"><a class="header" href="#多平台构建">多平台构建</a></h3>
<p>　　构建系统中可能涉及多个平台。</p>
<p>　　运行构建系统的环境和被构建的程序的环境不需要相同，对应的平台分别称为宿主平台(host platform) 和目标平台(target platform) 。宿主平台和目标平台相同时称为本机(native) 构建；不同时称为交叉(build) 构建。</p>
<p>　　多个构建过程可能串联组成更大的构建过程。不同构建过程存在输出和输入之间的依赖。此时，前一过程输出的目标平台需要兼容于后一过程作为输入的宿主平台，否则无法直接运行。典型情况下这些平台是相同的，但也可以存在平台之间自身保证二进制<a href="#%E8%A7%84%E8%8C%83">互操作</a>兼容性（如支持 x86_64 的体系结构上混用 i686 和 x86_64 ）的情况。</p>
<p>　　一些构建系统如 <a href="https://gcc.gnu.org/onlinedocs/gccint/Configure-Terms.html">GNU 工具链(en-US) 使用更复杂的术语</a>，单独引入构建(build) 平台。为确保一般性并简化模型， YSLib <strong>不使用</strong>这个概念，而把构建平台作为第一级构建过程（即 GNU autoconf 的“配置”）的宿主平台。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="EMPTY.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="StandardUsing.en-US.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="EMPTY.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="StandardUsing.en-US.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
